
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>JAVA-Spring开发-IoC - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg"},"articleBody":"在学习Spring框架时，我们遇到的第一个也是最核心的概念就是容器。\n什么是容器？容器是一种为某种特定组件的运行提供必要支持的一个软件环境。例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。\n通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供了许多底层服务。例如，Servlet容器底层实现了TCP连接，解析HTTP协议等非常复杂的服务，如果没有容器来提供这些服务，我们就无法编写像Servlet这样代码简单，功能强大的组件。早期的JavaEE服务器提供的EJB容器最重要的功能就是通过声明式事务服务，使得EJB组件的开发人员不必自己编写冗长的事务处理代码，所以极大地简化了事务处理。\nSpring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。\n本章我们讨论的IoC容器，主要介绍Spring容器如何对组件进行生命周期管理和配置组装服务。\nSpring提供的容器又称为IoC容器，什么是IoC？\nIoC全称Inversion of Control，直译为控制反转。那么何谓IoC？在理解IoC之前，我们先看看通常的Java组件是如何协作的。\n我们假定一个在线书店，通过BookService获取书籍：\n1234567891011public class BookService &#123;    private HikariConfig config = new HikariConfig();    private DataSource dataSource = new HikariDataSource(config);    public Book getBook(long bookId) &#123;        try (Connection conn = dataSource.getConnection()) &#123;            ...            return book;        &#125;    &#125;&#125;\n为了从数据库查询书籍，BookService持有一个DataSource。为了实例化一个HikariDataSource，又不得不实例化一个HikariConfig。\n现在，我们继续编写UserService获取用户：\n1234567891011public class UserService &#123;    private HikariConfig config = new HikariConfig();    private DataSource dataSource = new HikariDataSource(config);    public User getUser(long userId) &#123;        try (Connection conn = dataSource.getConnection()) &#123;            ...            return user;        &#125;    &#125;&#125;\n因为UserService也需要访问数据库，因此，我们不得不也实例化一个HikariDataSource。\n在处理用户购买的CartServlet中，我们需要实例化UserService和BookService：\n123456789101112public class CartServlet extends HttpServlet &#123;    private BookService bookService = new BookService();    private UserService userService = new UserService();    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        long currentUserId = getFromCookie(req);        User currentUser = userService.getUser(currentUserId);        Book book = bookService.getBook(req.getParameter(&quot;bookId&quot;));        cartService.addToCart(currentUser, book);        ...    &#125;&#125;\n类似的，在购买历史HistoryServlet中，也需要实例化UserService和BookService：\n1234public class HistoryServlet extends HttpServlet &#123;    private BookService bookService = new BookService();    private UserService userService = new UserService();&#125;\n上述每个组件都采用了一种简单的通过new创建实例并持有的方式。仔细观察，会发现以下缺点：\n\n实例化一个组件其实很难，例如，BookService和UserService要创建HikariDataSource，实际上需要读取配置，才能先实例化HikariConfig，再实例化HikariDataSource。\n没有必要让BookService和UserService分别创建DataSource实例，完全可以共享同一个DataSource，但谁负责创建DataSource，谁负责获取其他组件已经创建的DataSource，不好处理。类似的，CartServlet和HistoryServlet也应当共享BookService实例和UserService实例，但也不好处理。\n很多组件需要销毁以便释放资源，例如DataSource，但如果该组件被多个组件共享，如何确保它的使用方都已经全部被销毁？\n随着更多的组件被引入，例如，书籍评论，需要共享的组件写起来会更困难，这些组件的依赖关系会越来越复杂。\n测试某个组件，例如BookService，是复杂的，因为必须要在真实的数据库环境下执行。\n\n从上面的例子可以看出，如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。\n因此，核心问题是：\n\n谁负责创建组件？\n谁负责根据依赖关系组装组件？\n销毁时，如何按依赖顺序正确销毁？\n\n解决这一问题的核心方案就是IoC。\n传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制，例如：\nCartServlet创建了BookService，在创建BookService的过程中，又创建了DataSource组件。这种模式的缺点是，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。\n在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，例如，BookService自己并不会创建DataSource，而是等待外部通过setDataSource()方法来注入一个DataSource：\n1234567public class BookService &#123;    private DataSource dataSource;    public void setDataSource(DataSource dataSource) &#123;        this.dataSource = dataSource;    &#125;&#125;\n不直接new一个DataSource，而是注入一个DataSource，这个小小的改动虽然简单，却带来了一系列好处：\n\nBookService不再关心如何创建DataSource，因此，不必编写读取数据库配置之类的代码；\nDataSource实例被注入到BookService，同样也可以注入到UserService，因此，共享一个组件非常简单；\n测试BookService更容易，因为注入的是DataSource，可以使用内存数据库，而不是真实的MySQL配置。\n\n因此，IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。\n因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现，例如：\n123456789&lt;beans&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;HikariDataSource&quot; /&gt;    &lt;bean id=&quot;bookService&quot; class=&quot;BookService&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;/bean&gt;    &lt;bean id=&quot;userService&quot; class=&quot;UserService&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;\n上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为dataSource的组件通过属性dataSource（即调用setDataSource()方法）注入到另外两个组件中。\n在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。\n依赖注入方式\n我们从上面的代码可以看到，依赖注入可以通过set()方法实现。但依赖注入也可以通过构造方法实现。\n很多Java类都具有带参数的构造方法，如果我们把BookService改造为通过构造方法注入，那么实现代码如下：\n1234567public class BookService &#123;    private DataSource dataSource;    public BookService(DataSource dataSource) &#123;        this.dataSource = dataSource;    &#125;&#125;\nSpring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用。\n无侵入容器\n在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：\n\n应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；\n测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。\n\n我们前面讨论了为什么要使用Spring的IoC容器，因为让容器来为我们创建并装配Bean能获得很大的好处，那么到底如何使用IoC容器？装配好的Bean又如何使用？\n我们来看一个具体的用户注册登录的例子。整个工程的结构如下：\n123456789101112131415spring-ioc-appcontext├── pom.xml└── src    └── main        ├── java        │   └── com        │       └── itranswarp        │           └── learnjava        │               ├── Main.java        │               └── service        │                   ├── MailService.java        │                   ├── User.java        │                   └── UserService.java        └── resources            └── application.xml\n首先，我们用Maven创建工程并引入spring-context依赖：\n\norg.springframework:spring-context:6.0.0\n\n我们先编写一个MailService，用于在用户登录和注册成功后发送邮件通知：\n1234567891011121314151617181920public class MailService &#123;    private ZoneId zoneId = ZoneId.systemDefault();    public void setZoneId(ZoneId zoneId) &#123;        this.zoneId = zoneId;    &#125;    public String getTime() &#123;        return ZonedDateTime.now(this.zoneId).format(DateTimeFormatter.ISO_ZONED_DATE_TIME);    &#125;    public void sendLoginMail(User user) &#123;        System.err.println(String.format(&quot;Hi, %s! You are logged in at %s&quot;, user.getName(), getTime()));    &#125;    public void sendRegistrationMail(User user) &#123;        System.err.println(String.format(&quot;Welcome, %s!&quot;, user.getName()));    &#125;&#125;\n再编写一个UserService，实现用户注册和登录：\n1234567891011121314151617181920212223242526272829303132333435363738public class UserService &#123;    private MailService mailService;    public void setMailService(MailService mailService) &#123;        this.mailService = mailService;    &#125;    private List&lt;User&gt; users = new ArrayList&lt;&gt;(List.of( // users:            new User(1, &quot;bob@example.com&quot;, &quot;password&quot;, &quot;Bob&quot;), // bob            new User(2, &quot;alice@example.com&quot;, &quot;password&quot;, &quot;Alice&quot;), // alice            new User(3, &quot;tom@example.com&quot;, &quot;password&quot;, &quot;Tom&quot;))); // tom    public User login(String email, String password) &#123;        for (User user : users) &#123;            if (user.getEmail().equalsIgnoreCase(email) &amp;&amp; user.getPassword().equals(password)) &#123;                mailService.sendLoginMail(user);                return user;            &#125;        &#125;        throw new RuntimeException(&quot;login failed.&quot;);    &#125;    public User getUser(long id) &#123;        return this.users.stream().filter(user -&gt; user.getId() == id).findFirst().orElseThrow();    &#125;    public User register(String email, String password, String name) &#123;        users.forEach((user) -&gt; &#123;            if (user.getEmail().equalsIgnoreCase(email)) &#123;                throw new RuntimeException(&quot;email exist.&quot;);            &#125;        &#125;);        User user = new User(users.stream().mapToLong(u -&gt; u.getId()).max().getAsLong() + 1, email, password, name);        users.add(user);        mailService.sendRegistrationMail(user);        return user;    &#125;&#125;\n注意到UserService通过setMailService()注入了一个MailService。\n然后，我们需要编写一个特定的application.xml配置文件，告诉Spring的IoC容器应该如何创建并组装Bean：\n123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;userService&quot; class=&quot;com.itranswarp.learnjava.service.UserService&quot;&gt;        &lt;property name=&quot;mailService&quot; ref=&quot;mailService&quot; /&gt;    &lt;/bean&gt;    &lt;bean id=&quot;mailService&quot; class=&quot;com.itranswarp.learnjava.service.MailService&quot; /&gt;&lt;/beans&gt;\n注意观察上述配置文件，其中与XML Schema相关的部分格式是固定的，我们只关注两个&lt;bean ...&gt;的配置：\n\n每个&lt;bean ...&gt;都有一个id标识，相当于Bean的唯一ID；\n在userServiceBean中，通过&lt;property name=&quot;...&quot; ref=&quot;...&quot; /&gt;注入了另一个Bean；\nBean的顺序不重要，Spring根据依赖关系会自动正确初始化。\n\n把上述XML配置文件用Java代码写出来，就像这样：\n123UserService userService = new UserService();MailService mailService = new MailService();userService.setMailService(mailService);\n只不过Spring容器是通过读取XML文件后使用反射完成的。\n如果注入的不是Bean，而是boolean、int、String这样的数据类型，则通过value注入，例如，创建一个HikariDataSource：\n1234567&lt;bean id=&quot;dataSource&quot; class=&quot;com.zaxxer.hikari.HikariDataSource&quot;&gt;    &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot; /&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;    &lt;property name=&quot;password&quot; value=&quot;password&quot; /&gt;    &lt;property name=&quot;maximumPoolSize&quot; value=&quot;10&quot; /&gt;    &lt;property name=&quot;autoCommit&quot; value=&quot;true&quot; /&gt;&lt;/bean&gt;\n最后一步，我们需要创建一个Spring的IoC容器实例，然后加载配置文件，让Spring容器为我们创建并装配好配置文件中指定的所有Bean，这只需要一行代码：\n1ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);\n接下来，我们就可以从Spring容器中“取出”装配好的Bean然后使用它：\n1234// 获取Bean:UserService userService = context.getBean(UserService.class);// 正常调用:User user = userService.login(&quot;bob@example.com&quot;, &quot;password&quot;);\n完整的main()方法如下：\n12345678public class Main &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);        UserService userService = context.getBean(UserService.class);        User user = userService.login(&quot;bob@example.com&quot;, &quot;password&quot;);        System.out.println(user.getName());    &#125;&#125;\nApplicationContext\n我们从创建Spring容器的代码：\n1ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);\n可以看到，Spring容器就是ApplicationContext，它是一个接口，有很多实现类，这里我们选择ClassPathXmlApplicationContext，表示它会自动从classpath中查找指定的XML配置文件。\n获得了ApplicationContext的实例，就获得了IoC容器的引用。从ApplicationContext中我们可以根据Bean的ID获取Bean，但更多的时候我们根据Bean的类型获取Bean的引用：\n1UserService userService = context.getBean(UserService.class);\nSpring还提供另一种IoC容器叫BeanFactory，使用方式和ApplicationContext类似：\n12BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;application.xml&quot;));MailService mailService = factory.getBean(MailService.class);\nBeanFactory和ApplicationContext的区别在于，BeanFactory的实现是按需创建，即第一次获取Bean时才创建这个Bean，而ApplicationContext会一次性创建所有的Bean。实际上，ApplicationContext接口是从BeanFactory接口继承而来的，并且，ApplicationContext提供了一些额外的功能，包括国际化支持、事件和通知机制等。通常情况下，我们总是使用ApplicationContext，很少会考虑使用BeanFactory。\n练习\n在上述示例的基础上，继续给UserService注入DataSource，并把注册和登录功能通过数据库实现。\n下载练习\n小结\nSpring的IoC容器接口是ApplicationContext，并提供了多种实现类；\n通过XML配置文件创建IoC容器时，使用ClassPathXmlApplicationContext；\n持有IoC容器后，通过getBean()方法获取Bean的引用。\n使用Spring的IoC容器，实际上就是通过类似XML这样的配置文件，把我们自己的Bean的依赖关系描述出来，然后让容器来创建并装配Bean。一旦容器初始化完毕，我们就直接从容器中获取Bean使用它们。\n使用XML配置的优点是所有的Bean都能一目了然地列出来，并通过配置注入能直观地看到每个Bean的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。\n有没有其他更简单的配置方式呢？\n有！我们可以使用Annotation配置，可以完全不需要XML，让Spring自动扫描Bean并组装它们。\n我们把上一节的示例改造一下，先删除XML配置文件，然后，给UserService和MailService添加几个注解。\n首先，我们给MailService添加一个@Component注解：\n1234@Componentpublic class MailService &#123;    ...&#125;\n这个@Component注解就相当于定义了一个Bean，它有一个可选的名称，默认是mailService，即小写开头的类名。\n然后，我们给UserService添加一个@Component注解和一个@Autowired注解：\n1234567@Componentpublic class UserService &#123;    @Autowired    MailService mailService;    ...&#125;\n使用@Autowired就相当于把指定类型的Bean注入到指定的字段中。和XML配置相比，@Autowired大幅简化了注入，因为它不但可以写在set()方法上，还可以直接写在字段上，甚至可以写在构造方法中：\n123456789@Componentpublic class UserService &#123;    MailService mailService;    public UserService(@Autowired MailService mailService) &#123;        this.mailService = mailService;    &#125;    ...&#125;\n我们一般把@Autowired写在字段上，通常使用package权限的字段，便于测试。\n最后，编写一个AppConfig类启动容器：\n12345678910@Configuration@ComponentScanpublic class AppConfig &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);        UserService userService = context.getBean(UserService.class);        User user = userService.login(&quot;bob@example.com&quot;, &quot;password&quot;);        System.out.println(user.getName());    &#125;&#125;\n除了main()方法外，AppConfig标注了@Configuration，表示它是一个配置类，因为我们创建ApplicationContext时：\n1ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);\n使用的实现类是AnnotationConfigApplicationContext，必须传入一个标注了@Configuration的类名。\n此外，AppConfig还标注了@ComponentScan，它告诉容器，自动搜索当前类所在的包以及子包，把所有标注为@Component的Bean自动创建出来，并根据@Autowired进行装配。\n整个工程结构如下：\n12345678910111213spring-ioc-annoconfig├── pom.xml└── src    └── main        └── java            └── com                └── itranswarp                    └── learnjava                        ├── AppConfig.java                        └── service                            ├── MailService.java                            ├── User.java                            └── UserService.java\n使用Annotation配合自动扫描能大幅简化Spring的配置，我们只需要保证：\n\n每个Bean被标注为@Component并正确使用@Autowired注入；\n配置类被标注为@Configuration和@ComponentScan；\n所有Bean均在指定包以及子包内。\n\n使用@ComponentScan非常方便，但是，我们也要特别注意包的层次结构。通常来说，启动配置AppConfig位于自定义的顶层包（例如com.itranswarp.learnjava），其他Bean按类别放入子包。\n思考\n如果我们想给UserService注入HikariDataSource，但是这个类位于com.zaxxer.hikari包中，并且HikariDataSource也不可能有@Component注解，如何告诉IoC容器创建并配置HikariDataSource？或者换个说法，如何创建并配置一个第三方Bean？\n练习\n使用Annotation配置IoC容器。\n下载练习\n小结\n使用Annotation可以大幅简化配置，每个Bean通过@Component和@Autowired注入；\n必须合理设计包的层次结构，才能发挥@ComponentScan的威力。\nScope\n对于Spring容器来说，当我们把一个Bean标记为@Component后，它就会自动为我们创建一个单例（Singleton），即容器初始化时创建Bean，容器关闭前销毁Bean。在容器运行期间，我们调用getBean(Class)获取到的Bean总是同一个实例。\n还有一种Bean，我们每次调用getBean(Class)，容器都返回一个新的实例，这种Bean称为Prototype（原型），它的生命周期显然和Singleton不同。声明一个Prototype的Bean时，需要添加一个额外的@Scope注解：\n12345@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) // @Scope(&quot;prototype&quot;)public class MailSession &#123;    ...&#125;\n注入List\n有些时候，我们会有一系列接口相同，不同实现类的Bean。例如，注册用户时，我们要对email、password和name这3个变量进行验证。为了便于扩展，我们先定义验证接口：\n123public interface Validator &#123;    void validate(String email, String password, String name);&#125;\n然后，分别使用3个Validator对用户参数进行验证：\n1234567891011121314151617181920212223242526@Componentpublic class EmailValidator implements Validator &#123;    public void validate(String email, String password, String name) &#123;        if (!email.matches(&quot;^[a-z0-9]+\\\\@[a-z0-9]+\\\\.[a-z]&#123;2,10&#125;$&quot;)) &#123;            throw new IllegalArgumentException(&quot;invalid email: &quot; + email);        &#125;    &#125;&#125;@Componentpublic class PasswordValidator implements Validator &#123;    public void validate(String email, String password, String name) &#123;        if (!password.matches(&quot;^.&#123;6,20&#125;$&quot;)) &#123;            throw new IllegalArgumentException(&quot;invalid password&quot;);        &#125;    &#125;&#125;@Componentpublic class NameValidator implements Validator &#123;    public void validate(String email, String password, String name) &#123;        if (name == null || name.isBlank() || name.length() &gt; 20) &#123;            throw new IllegalArgumentException(&quot;invalid name: &quot; + name);        &#125;    &#125;&#125;\n最后，我们通过一个Validators作为入口进行验证：\n1234567891011@Componentpublic class Validators &#123;    @Autowired    List&lt;Validator&gt; validators;    public void validate(String email, String password, String name) &#123;        for (var validator : this.validators) &#123;            validator.validate(email, password, name);        &#125;    &#125;&#125;\n注意到Validators被注入了一个List&lt;Validator&gt;，Spring会自动把所有类型为Validator的Bean装配为一个List注入进来，这样一来，我们每新增一个Validator类型，就自动被Spring装配到Validators中了，非常方便。\n因为Spring是通过扫描classpath获取到所有的Bean，而List是有序的，要指定List中Bean的顺序，可以加上@Order注解：\n1234567891011121314151617@Component@Order(1)public class EmailValidator implements Validator &#123;    ...&#125;@Component@Order(2)public class PasswordValidator implements Validator &#123;    ...&#125;@Component@Order(3)public class NameValidator implements Validator &#123;    ...&#125;\n可选注入\n默认情况下，当我们标记了一个@Autowired后，Spring如果没有找到对应类型的Bean，它会抛出NoSuchBeanDefinitionException异常。\n可以给@Autowired增加一个required = false的参数：\n123456@Componentpublic class MailService &#123;    @Autowired(required = false)    ZoneId zoneId = ZoneId.systemDefault();    ...&#125;\n这个参数告诉Spring容器，如果找到一个类型为ZoneId的Bean，就注入，如果找不到，就忽略。\n这种方式非常适合有定义就使用定义，没有就使用默认值的情况。\n创建第三方Bean\n如果一个Bean不在我们自己的package管理之内，例如ZoneId，如何创建它？\n答案是我们自己在@Configuration类中编写一个Java方法创建并返回它，注意给方法标记一个@Bean注解：\n123456789@Configuration@ComponentScanpublic class AppConfig &#123;    // 创建一个Bean:    @Bean    ZoneId createZoneId() &#123;        return ZoneId.of(&quot;Z&quot;);    &#125;&#125;\nSpring对标记为@Bean的方法只调用一次，因此返回的Bean仍然是单例。\n初始化和销毁\n有些时候，一个Bean在注入必要的依赖后，需要进行初始化（监听消息等）。在容器关闭时，有时候还需要清理资源（关闭连接池等）。我们通常会定义一个init()方法进行初始化，定义一个shutdown()方法进行清理，然后，引入JSR-250定义的Annotation：\n\njakarta.annotation:jakarta.annotation-api:2.1.1\n\n在Bean的初始化和清理方法上标记@PostConstruct和@PreDestroy：\n123456789101112131415@Componentpublic class MailService &#123;    @Autowired(required = false)    ZoneId zoneId = ZoneId.systemDefault();    @PostConstruct    public void init() &#123;        System.out.println(&quot;Init mail service with zoneId = &quot; + this.zoneId);    &#125;    @PreDestroy    public void shutdown() &#123;        System.out.println(&quot;Shutdown mail service&quot;);    &#125;&#125;\nSpring容器会对上述Bean做如下初始化流程：\n\n调用构造方法创建MailService实例；\n根据@Autowired进行注入；\n调用标记有@PostConstruct的init()方法进行初始化。\n\n而销毁时，容器会首先调用标记有@PreDestroy的shutdown()方法。\nSpring只根据Annotation查找无参数方法，对方法名不作要求。\n使用别名\n默认情况下，对一种类型的Bean，容器只创建一个实例。但有些时候，我们需要对一种类型的Bean创建多个实例。例如，同时连接多个数据库，就必须创建多个DataSource实例。\n如果我们在@Configuration类中创建了多个同类型的Bean：\n12345678910111213@Configuration@ComponentScanpublic class AppConfig &#123;    @Bean    ZoneId createZoneOfZ() &#123;        return ZoneId.of(&quot;Z&quot;);    &#125;    @Bean    ZoneId createZoneOfUTC8() &#123;        return ZoneId.of(&quot;UTC+08:00&quot;);    &#125;&#125;\nSpring会报NoUniqueBeanDefinitionException异常，意思是出现了重复的Bean定义。\n这个时候，需要给每个Bean添加不同的名字：\n1234567891011121314@Configuration@ComponentScanpublic class AppConfig &#123;    @Bean(&quot;z&quot;)    ZoneId createZoneOfZ() &#123;        return ZoneId.of(&quot;Z&quot;);    &#125;    @Bean    @Qualifier(&quot;utc8&quot;)    ZoneId createZoneOfUTC8() &#123;        return ZoneId.of(&quot;UTC+08:00&quot;);    &#125;&#125;\n可以用@Bean(&quot;name&quot;)指定别名，也可以用@Bean+@Qualifier(&quot;name&quot;)指定别名。\n存在多个同类型的Bean时，注入ZoneId又会报错：\n1NoUniqueBeanDefinitionException: No qualifying bean of type &#x27;java.time.ZoneId&#x27; available: expected single matching bean but found 2\n意思是期待找到唯一的ZoneId类型Bean，但是找到两。因此，注入时，要指定Bean的名称：\n1234567@Componentpublic class MailService &#123;\t@Autowired(required = false)\t@Qualifier(&quot;z&quot;) // 指定注入名称为&quot;z&quot;的ZoneId\tZoneId zoneId = ZoneId.systemDefault();    ...&#125;\n还有一种方法是把其中某个Bean指定为@Primary：\n12345678910111213141516@Configuration@ComponentScanpublic class AppConfig &#123;    @Bean    @Primary // 指定为主要Bean    @Qualifier(&quot;z&quot;)    ZoneId createZoneOfZ() &#123;        return ZoneId.of(&quot;Z&quot;);    &#125;    @Bean    @Qualifier(&quot;utc8&quot;)    ZoneId createZoneOfUTC8() &#123;        return ZoneId.of(&quot;UTC+08:00&quot;);    &#125;&#125;\n这样，在注入时，如果没有指出Bean的名字，Spring会注入标记有@Primary的Bean。这种方式也很常用。例如，对于主从两个数据源，通常将主数据源定义为@Primary：\n123456789101112131415@Configuration@ComponentScanpublic class AppConfig &#123;    @Bean    @Primary    DataSource createMasterDataSource() &#123;        ...    &#125;    @Bean    @Qualifier(&quot;slave&quot;)    DataSource createSlaveDataSource() &#123;        ...    &#125;&#125;\n其他Bean默认注入的就是主数据源。如果要注入从数据源，那么只需要指定名称即可。\n使用FactoryBean\n我们在设计模式的工厂方法中讲到，很多时候，可以通过工厂模式创建对象。Spring也提供了工厂模式，允许定义一个工厂，然后由工厂创建真正的Bean。\n用工厂模式创建Bean需要实现FactoryBean接口。我们观察下面的代码：\n123456789101112131415@Componentpublic class ZoneIdFactoryBean implements FactoryBean&lt;ZoneId&gt; &#123;    String zone = &quot;Z&quot;;    @Override    public ZoneId getObject() throws Exception &#123;        return ZoneId.of(zone);    &#125;    @Override    public Class&lt;?&gt; getObjectType() &#123;        return ZoneId.class;    &#125;&#125;\n当一个Bean实现了FactoryBean接口后，Spring会先实例化这个工厂，然后调用getObject()创建真正的Bean。getObjectType()可以指定创建的Bean的类型，因为指定类型不一定与实际类型一致，可以是接口或抽象类。\n因此，如果定义了一个FactoryBean，要注意Spring创建的Bean实际上是这个FactoryBean的getObject()方法返回的Bean。为了和普通Bean区分，我们通常都以XxxFactoryBean命名。\n由于可以用@Bean方法创建第三方Bean，本质上@Bean方法就是工厂方法，所以，FactoryBean已经用得越来越少了。\n练习\n定制Bean。\n下载练习\n小结\nSpring默认使用Singleton创建Bean，也可指定Scope为Prototype；\n可将相同类型的Bean注入List或数组；\n可用@Autowired(required=false)允许可选注入；\n可用带@Bean标注的方法创建Bean；\n可使用@PostConstruct和@PreDestroy对Bean进行初始化和清理；\n相同类型的Bean只能有一个指定为@Primary，其他必须用@Qualifier(&quot;beanName&quot;)指定别名；\n注入时，可通过别名@Qualifier(&quot;beanName&quot;)指定某个Bean；\n可以定义FactoryBean来使用工厂模式创建Bean。\n使用Resource\n在Java程序中，我们经常会读取配置文件、资源文件等。使用Spring容器时，我们也可以把“文件”注入进来，方便程序读取。\n例如，AppService需要读取logo.txt这个文件，通常情况下，我们需要写很多繁琐的代码，主要是为了定位文件，打开InputStream。\nSpring提供了一个org.springframework.core.io.Resource（注意不是jarkata.annotation.Resource或javax.annotation.Resource），它可以像String、int一样使用@Value注入：\n123456789101112131415@Componentpublic class AppService &#123;    @Value(&quot;classpath:/logo.txt&quot;)    private Resource resource;    private String logo;    @PostConstruct    public void init() throws IOException &#123;        try (var reader = new BufferedReader(                new InputStreamReader(resource.getInputStream(), StandardCharsets.UTF_8))) &#123;            this.logo = reader.lines().collect(Collectors.joining(&quot;\\n&quot;));        &#125;    &#125;&#125;\n注入Resource最常用的方式是通过classpath，即类似classpath:/logo.txt表示在classpath中搜索logo.txt文件，然后，我们直接调用Resource.getInputStream()就可以获取到输入流，避免了自己搜索文件的代码。\n也可以直接指定文件的路径，例如：\n12@Value(&quot;file:/path/to/logo.txt&quot;)private Resource resource;\n但使用classpath是最简单的方式。上述工程结构如下：\n123456789101112spring-ioc-resource├── pom.xml└── src    └── main        ├── java        │   └── com        │       └── itranswarp        │           └── learnjava        │               ├── AppConfig.java        │               └── AppService.java        └── resources            └── logo.txt\n使用Maven的标准目录结构，所有资源文件放入src/main/resources即可。\n练习\n使用Spring的Resource注入app.properties文件，然后读取该配置文件。\n下载练习\n小结\nSpring提供了Resource类便于注入资源文件。\n最常用的注入是通过classpath以classpath:/path/to/file的形式注入。\n\n\n注入配置\n在开发应用程序时，经常需要读取配置文件。最常用的配置方法是以key=value的形式写在.properties文件中。\n例如，MailService根据配置的app.zone=Asia/Shanghai来决定使用哪个时区。要读取配置文件，我们可以使用上一节讲到的Resource来读取位于classpath下的一个app.properties文件。但是，这样仍然比较繁琐。\nSpring容器还提供了一个更简单的@PropertySource来自动读取配置文件。我们只需要在@Configuration配置类上再添加一个注解：\n123456789101112@Configuration@ComponentScan@PropertySource(&quot;app.properties&quot;) // 表示读取classpath的app.propertiespublic class AppConfig &#123;    @Value(&quot;$&#123;app.zone:Z&#125;&quot;)    String zoneId;    @Bean    ZoneId createZoneId() &#123;        return ZoneId.of(zoneId);    &#125;&#125;\nSpring容器看到@PropertySource(&quot;app.properties&quot;)注解后，自动读取这个配置文件，然后，我们使用@Value正常注入：\n12@Value(&quot;$&#123;app.zone:Z&#125;&quot;)String zoneId;\n注意注入的字符串语法，它的格式如下：\n\n&quot;$&#123;app.zone&#125;&quot;表示读取key为app.zone的value，如果key不存在，启动将报错；\n&quot;$&#123;app.zone:Z&#125;&quot;表示读取key为app.zone的value，但如果key不存在，就使用默认值Z。\n\n这样一来，我们就可以根据app.zone的配置来创建ZoneId。\n还可以把注入的注解写到方法参数中：\n1234@BeanZoneId createZoneId(@Value(&quot;$&#123;app.zone:Z&#125;&quot;) String zoneId) &#123;    return ZoneId.of(zoneId);&#125;\n可见，先使用@PropertySource读取配置文件，然后通过@Value以$&#123;key:defaultValue&#125;的形式注入，可以极大地简化读取配置的麻烦。\n另一种注入配置的方式是先通过一个简单的JavaBean持有所有的配置，例如，一个SmtpConfig：\n12345678910111213141516@Componentpublic class SmtpConfig &#123;    @Value(&quot;$&#123;smtp.host&#125;&quot;)    private String host;    @Value(&quot;$&#123;smtp.port:25&#125;&quot;)    private int port;    public String getHost() &#123;        return host;    &#125;    public int getPort() &#123;        return port;    &#125;&#125;\n然后，在需要读取的地方，使用#&#123;smtpConfig.host&#125;注入：\n12345678@Componentpublic class MailService &#123;    @Value(&quot;#&#123;smtpConfig.host&#125;&quot;)    private String smtpHost;    @Value(&quot;#&#123;smtpConfig.port&#125;&quot;)    private int smtpPort;&#125;\n注意观察#&#123;&#125;这种注入语法，它和$&#123;key&#125;不同的是，#&#123;&#125;表示从JavaBean读取属性。&quot;#&#123;smtpConfig.host&#125;&quot;的意思是，从名称为smtpConfig的Bean读取host属性，即调用getHost()方法。一个Class名为SmtpConfig的Bean，它在Spring容器中的默认名称就是smtpConfig，除非用@Qualifier指定了名称。\n使用一个独立的JavaBean持有所有属性，然后在其他Bean中以#&#123;bean.property&#125;注入的好处是，多个Bean都可以引用同一个Bean的某个属性。例如，如果SmtpConfig决定从数据库中读取相关配置项，那么MailService注入的@Value(&quot;#&#123;smtpConfig.host&#125;&quot;)仍然可以不修改正常运行。\n练习\n注入SMTP配置。\n下载练习\n小结\nSpring容器可以通过@PropertySource自动读取配置，并以@Value(&quot;$&#123;key&#125;&quot;)的形式注入；\n可以通过$&#123;key:defaultValue&#125;指定默认值；\n以#&#123;bean.property&#125;形式注入时，Spring容器自动把指定Bean的指定属性值注入。\n\n\n开发应用程序时，我们会使用开发环境，例如，使用内存数据库以便快速启动。而运行在生产环境时，我们会使用生产环境，例如，使用MySQL数据库。如果应用程序可以根据自身的环境做一些适配，无疑会更加灵活。\nSpring为应用程序准备了Profile这一概念，用来表示不同的环境。例如，我们分别定义开发、测试和生产这3个环境：\n\nnative\ntest\nproduction\n\n创建某个Bean时，Spring容器可以根据注解@Profile来决定是否创建。例如，以下配置：\n123456789101112131415@Configuration@ComponentScanpublic class AppConfig &#123;    @Bean    @Profile(&quot;!test&quot;)    ZoneId createZoneId() &#123;        return ZoneId.systemDefault();    &#125;    @Bean    @Profile(&quot;test&quot;)    ZoneId createZoneIdForTest() &#123;        return ZoneId.of(&quot;America/New_York&quot;);    &#125;&#125;\n如果当前的Profile设置为test，则Spring容器会调用createZoneIdForTest()创建ZoneId，否则，调用createZoneId()创建ZoneId。注意到@Profile(&quot;!test&quot;)表示非test环境。\n在运行程序时，加上JVM参数-Dspring.profiles.active=test就可以指定以test环境启动。\n实际上，Spring允许指定多个Profile，例如：\n1-Dspring.profiles.active=test,master\n可以表示test环境，并使用master分支代码。\n要满足多个Profile条件，可以这样写：\n12345@Bean@Profile(&#123; &quot;test&quot;, &quot;master&quot; &#125;) // 满足test或masterZoneId createZoneId() &#123;    ...&#125;\n使用Conditional\n除了根据@Profile条件来决定是否创建某个Bean外，Spring还可以根据@Conditional决定是否创建某个Bean。\n例如，我们对SmtpMailService添加如下注解：\n12345@Component@Conditional(OnSmtpEnvCondition.class)public class SmtpMailService implements MailService &#123;    ...&#125;\n它的意思是，如果满足OnSmtpEnvCondition的条件，才会创建SmtpMailService这个Bean。OnSmtpEnvCondition的条件是什么呢？我们看一下代码：\n12345public class OnSmtpEnvCondition implements Condition &#123;    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;        return &quot;true&quot;.equalsIgnoreCase(System.getenv(&quot;smtp&quot;));    &#125;&#125;\n因此，OnSmtpEnvCondition的条件是存在环境变量smtp，值为true。这样，我们就可以通过环境变量来控制是否创建SmtpMailService。\nSpring只提供了@Conditional注解，具体判断逻辑还需要我们自己实现。Spring Boot提供了更多使用起来更简单的条件注解，例如，如果配置文件中存在app.smtp=true，则创建MailService：\n12345@Component@ConditionalOnProperty(name=&quot;app.smtp&quot;, havingValue=&quot;true&quot;)public class MailService &#123;    ...&#125;\n如果当前classpath中存在类javax.mail.Transport，则创建MailService：\n12345@Component@ConditionalOnClass(name = &quot;javax.mail.Transport&quot;)public class MailService &#123;    ...&#125;\n后续我们会介绍Spring Boot的条件装配。我们以文件存储为例，假设我们需要保存用户上传的头像，并返回存储路径，在本地开发运行时，我们总是存储到文件：\n12345@Component@ConditionalOnProperty(name = &quot;app.storage&quot;, havingValue = &quot;file&quot;, matchIfMissing = true)public class FileUploader implements Uploader &#123;    ...&#125;\n在生产环境运行时，我们会把文件存储到类似AWS S3上：\n12345@Component@ConditionalOnProperty(name = &quot;app.storage&quot;, havingValue = &quot;s3&quot;)public class S3Uploader implements Uploader &#123;    ...&#125;\n其他需要存储的服务则注入Uploader：\n12345@Componentpublic class UserImageService &#123;    @Autowired    Uploader uploader;&#125;\n当应用程序检测到配置文件存在app.storage=s3时，自动使用S3Uploader，如果存在配置app.storage=file，或者配置app.storage不存在，则使用FileUploader。\n可见，使用条件注解，能更灵活地装配Bean。\n练习\n使用@Profile进行条件装配。\n下载练习\n小结\nSpring允许通过@Profile配置不同的Bean；\nSpring还提供了@Conditional来进行条件装配，Spring Boot在此基础上进一步提供了基于配置、Class、Bean等条件进行装配。\n","dateCreated":"2025-05-26T16:16:12+08:00","dateModified":"2025-05-26T16:20:51+08:00","datePublished":"2025-05-26T16:16:12+08:00","description":"","headline":"JAVA-Spring开发-IoC","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://chankein.github.io/2025/05/26/JAVA/JAVA-Spring%E5%BC%80%E5%8F%91-IoC/"},"publisher":{"@type":"Organization","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg","logo":{"@type":"ImageObject","url":"profile.jpg"}},"url":"https://chankein.github.io/2025/05/26/JAVA/JAVA-Spring%E5%BC%80%E5%8F%91-IoC/","keywords":"Java, Spirng"}</script>
    <meta name="description" content="在学习Spring框架时，我们遇到的第一个也是最核心的概念就是容器。 什么是容器？容器是一种为某种特定组件的运行提供必要支持的一个软件环境。例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。 通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供">
<meta property="og:type" content="blog">
<meta property="og:title" content="JAVA-Spring开发-IoC">
<meta property="og:url" content="https://chankein.github.io/2025/05/26/JAVA/JAVA-Spring%E5%BC%80%E5%8F%91-IoC/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:description" content="在学习Spring框架时，我们遇到的第一个也是最核心的概念就是容器。 什么是容器？容器是一种为某种特定组件的运行提供必要支持的一个软件环境。例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。 通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供">
<meta property="og:locale" content="zh_TW">
<meta property="article:published_time" content="2025-05-26T08:16:12.000Z">
<meta property="article:modified_time" content="2025-05-26T08:20:51.441Z">
<meta property="article:author" content="Kein Chan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spirng">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../../../#about"
            >
        
        
            <img class="header-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>Kein目前居住在東京和澳門.</br>熱愛旅遊.已探訪日本40多個都道府縣.曾自駕環繞日本半個本州.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            JAVA-Spring开发-IoC
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2025-05-26T16:16:12+08:00">
	
		    2025 年 5 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/">Java</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>在学习Spring框架时，我们遇到的第一个也是最核心的概念就是容器。</p>
<p>什么是容器？容器是一种为某种特定组件的运行提供必要支持的一个软件环境。例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。</p>
<p>通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供了许多底层服务。例如，Servlet容器底层实现了TCP连接，解析HTTP协议等非常复杂的服务，如果没有容器来提供这些服务，我们就无法编写像Servlet这样代码简单，功能强大的组件。早期的JavaEE服务器提供的EJB容器最重要的功能就是通过声明式事务服务，使得EJB组件的开发人员不必自己编写冗长的事务处理代码，所以极大地简化了事务处理。</p>
<p>Spring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。</p>
<p>本章我们讨论的IoC容器，主要介绍Spring容器如何对组件进行生命周期管理和配置组装服务。</p>
<p>Spring提供的容器又称为IoC容器，什么是IoC？</p>
<p>IoC全称Inversion of Control，直译为控制反转。那么何谓IoC？在理解IoC之前，我们先看看通常的Java组件是如何协作的。</p>
<p>我们假定一个在线书店，通过<code>BookService</code>获取书籍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">HikariConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(config);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getBook</span><span class="params">(<span class="type">long</span> bookId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> dataSource.getConnection()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> book;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了从数据库查询书籍，<code>BookService</code>持有一个<code>DataSource</code>。为了实例化一个<code>HikariDataSource</code>，又不得不实例化一个<code>HikariConfig</code>。</p>
<p>现在，我们继续编写<code>UserService</code>获取用户：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">HikariConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(config);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="type">long</span> userId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> dataSource.getConnection()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>UserService</code>也需要访问数据库，因此，我们不得不也实例化一个<code>HikariDataSource</code>。</p>
<p>在处理用户购买的<code>CartServlet</code>中，我们需要实例化<code>UserService</code>和<code>BookService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookService</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">currentUserId</span> <span class="operator">=</span> getFromCookie(req);</span><br><span class="line">        <span class="type">User</span> <span class="variable">currentUser</span> <span class="operator">=</span> userService.getUser(currentUserId);</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> bookService.getBook(req.getParameter(<span class="string">&quot;bookId&quot;</span>));</span><br><span class="line">        cartService.addToCart(currentUser, book);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，在购买历史<code>HistoryServlet</code>中，也需要实例化<code>UserService</code>和<code>BookService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HistoryServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookService</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述每个组件都采用了一种简单的通过<code>new</code>创建实例并持有的方式。仔细观察，会发现以下缺点：</p>
<ol>
<li>实例化一个组件其实很难，例如，<code>BookService</code>和<code>UserService</code>要创建<code>HikariDataSource</code>，实际上需要读取配置，才能先实例化<code>HikariConfig</code>，再实例化<code>HikariDataSource</code>。</li>
<li>没有必要让<code>BookService</code>和<code>UserService</code>分别创建<code>DataSource</code>实例，完全可以共享同一个<code>DataSource</code>，但谁负责创建<code>DataSource</code>，谁负责获取其他组件已经创建的<code>DataSource</code>，不好处理。类似的，<code>CartServlet</code>和<code>HistoryServlet</code>也应当共享<code>BookService</code>实例和<code>UserService</code>实例，但也不好处理。</li>
<li>很多组件需要销毁以便释放资源，例如<code>DataSource</code>，但如果该组件被多个组件共享，如何确保它的使用方都已经全部被销毁？</li>
<li>随着更多的组件被引入，例如，书籍评论，需要共享的组件写起来会更困难，这些组件的依赖关系会越来越复杂。</li>
<li>测试某个组件，例如<code>BookService</code>，是复杂的，因为必须要在真实的数据库环境下执行。</li>
</ol>
<p>从上面的例子可以看出，如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。</p>
<p>因此，核心问题是：</p>
<ol>
<li>谁负责创建组件？</li>
<li>谁负责根据依赖关系组装组件？</li>
<li>销毁时，如何按依赖顺序正确销毁？</li>
</ol>
<p>解决这一问题的核心方案就是IoC。</p>
<p>传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制，例如：</p>
<p><code>CartServlet</code>创建了<code>BookService</code>，在创建<code>BookService</code>的过程中，又创建了<code>DataSource</code>组件。这种模式的缺点是，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。</p>
<p>在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，例如，<code>BookService</code>自己并不会创建<code>DataSource</code>，而是等待外部通过<code>setDataSource()</code>方法来注入一个<code>DataSource</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataSource</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不直接<code>new</code>一个<code>DataSource</code>，而是注入一个<code>DataSource</code>，这个小小的改动虽然简单，却带来了一系列好处：</p>
<ol>
<li><code>BookService</code>不再关心如何创建<code>DataSource</code>，因此，不必编写读取数据库配置之类的代码；</li>
<li><code>DataSource</code>实例被注入到<code>BookService</code>，同样也可以注入到<code>UserService</code>，因此，共享一个组件非常简单；</li>
<li>测试<code>BookService</code>更容易，因为注入的是<code>DataSource</code>，可以使用内存数据库，而不是真实的MySQL配置。</li>
</ol>
<p>因此，IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。</p>
<p>因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;HikariDataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;BookService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为<code>dataSource</code>的组件通过属性<code>dataSource</code>（即调用<code>setDataSource()</code>方法）注入到另外两个组件中。</p>
<p>在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。</p>
<h3 id="依赖注入方式">依赖注入方式</h3>
<p>我们从上面的代码可以看到，依赖注入可以通过<code>set()</code>方法实现。但依赖注入也可以通过构造方法实现。</p>
<p>很多Java类都具有带参数的构造方法，如果我们把<code>BookService</code>改造为通过构造方法注入，那么实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookService</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用。</p>
<h3 id="无侵入容器">无侵入容器</h3>
<p>在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：</p>
<ol>
<li>应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；</li>
<li>测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。</li>
</ol>
<p>我们前面讨论了为什么要使用Spring的IoC容器，因为让容器来为我们创建并装配Bean能获得很大的好处，那么到底如何使用IoC容器？装配好的Bean又如何使用？</p>
<p>我们来看一个具体的用户注册登录的例子。整个工程的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">spring-ioc-appcontext</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── itranswarp</span><br><span class="line">        │           └── learnjava</span><br><span class="line">        │               ├── Main.java</span><br><span class="line">        │               └── service</span><br><span class="line">        │                   ├── MailService.java</span><br><span class="line">        │                   ├── User.java</span><br><span class="line">        │                   └── UserService.java</span><br><span class="line">        └── resources</span><br><span class="line">            └── application.xml</span><br></pre></td></tr></table></figure>
<p>首先，我们用Maven创建工程并引入<code>spring-context</code>依赖：</p>
<ul>
<li>org.springframework:spring-context:6.0.0</li>
</ul>
<p>我们先编写一个<code>MailService</code>，用于在用户登录和注册成功后发送邮件通知：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZoneId</span><span class="params">(ZoneId zoneId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.zoneId = zoneId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZonedDateTime.now(<span class="built_in">this</span>.zoneId).format(DateTimeFormatter.ISO_ZONED_DATE_TIME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendLoginMail</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        System.err.println(String.format(<span class="string">&quot;Hi, %s! You are logged in at %s&quot;</span>, user.getName(), getTime()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendRegistrationMail</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        System.err.println(String.format(<span class="string">&quot;Welcome, %s!&quot;</span>, user.getName()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再编写一个<code>UserService</code>，实现用户注册和登录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MailService mailService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMailService</span><span class="params">(MailService mailService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mailService = mailService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of( <span class="comment">// users:</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;Bob&quot;</span>), <span class="comment">// bob</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;alice@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;Alice&quot;</span>), <span class="comment">// alice</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>, <span class="string">&quot;tom@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;Tom&quot;</span>))); <span class="comment">// tom</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            <span class="keyword">if</span> (user.getEmail().equalsIgnoreCase(email) &amp;&amp; user.getPassword().equals(password)) &#123;</span><br><span class="line">                mailService.sendLoginMail(user);</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;login failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.users.stream().filter(user -&gt; user.getId() == id).findFirst().orElseThrow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        users.forEach((user) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (user.getEmail().equalsIgnoreCase(email)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;email exist.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(users.stream().mapToLong(u -&gt; u.getId()).max().getAsLong() + <span class="number">1</span>, email, password, name);</span><br><span class="line">        users.add(user);</span><br><span class="line">        mailService.sendRegistrationMail(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>UserService</code>通过<code>setMailService()</code>注入了一个<code>MailService</code>。</p>
<p>然后，我们需要编写一个特定的<code>application.xml</code>配置文件，告诉Spring的IoC容器应该如何创建并组装Bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itranswarp.learnjava.service.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mailService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mailService&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mailService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itranswarp.learnjava.service.MailService&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意观察上述配置文件，其中与XML Schema相关的部分格式是固定的，我们只关注两个<code>&lt;bean ...&gt;</code>的配置：</p>
<ul>
<li>每个<code>&lt;bean ...&gt;</code>都有一个<code>id</code>标识，相当于Bean的唯一ID；</li>
<li>在<code>userService</code>Bean中，通过<code>&lt;property name=&quot;...&quot; ref=&quot;...&quot; /&gt;</code>注入了另一个Bean；</li>
<li>Bean的顺序不重要，Spring根据依赖关系会自动正确初始化。</li>
</ul>
<p>把上述XML配置文件用Java代码写出来，就像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line"><span class="type">MailService</span> <span class="variable">mailService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MailService</span>();</span><br><span class="line">userService.setMailService(mailService);</span><br></pre></td></tr></table></figure>
<p>只不过Spring容器是通过读取XML文件后使用反射完成的。</p>
<p>如果注入的不是Bean，而是<code>boolean</code>、<code>int</code>、<code>String</code>这样的数据类型，则通过<code>value</code>注入，例如，创建一个<code>HikariDataSource</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zaxxer.hikari.HikariDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maximumPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;autoCommit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后一步，我们需要创建一个Spring的IoC容器实例，然后加载配置文件，让Spring容器为我们创建并装配好配置文件中指定的所有Bean，这只需要一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>接下来，我们就可以从Spring容器中“取出”装配好的Bean然后使用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Bean:</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line"><span class="comment">// 正常调用:</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.login(<span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>完整的<code>main()</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.login(<span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ApplicationContext">ApplicationContext</h3>
<p>我们从创建Spring容器的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到，Spring容器就是<code>ApplicationContext</code>，它是一个接口，有很多实现类，这里我们选择<code>ClassPathXmlApplicationContext</code>，表示它会自动从classpath中查找指定的XML配置文件。</p>
<p>获得了<code>ApplicationContext</code>的实例，就获得了IoC容器的引用。从<code>ApplicationContext</code>中我们可以根据Bean的ID获取Bean，但更多的时候我们根据Bean的类型获取Bean的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br></pre></td></tr></table></figure>
<p>Spring还提供另一种IoC容器叫<code>BeanFactory</code>，使用方式和<code>ApplicationContext</code>类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;application.xml&quot;</span>));</span><br><span class="line"><span class="type">MailService</span> <span class="variable">mailService</span> <span class="operator">=</span> factory.getBean(MailService.class);</span><br></pre></td></tr></table></figure>
<p><code>BeanFactory</code>和<code>ApplicationContext</code>的区别在于，<code>BeanFactory</code>的实现是按需创建，即第一次获取Bean时才创建这个Bean，而<code>ApplicationContext</code>会一次性创建所有的Bean。实际上，<code>ApplicationContext</code>接口是从<code>BeanFactory</code>接口继承而来的，并且，<code>ApplicationContext</code>提供了一些额外的功能，包括国际化支持、事件和通知机制等。通常情况下，我们总是使用<code>ApplicationContext</code>，很少会考虑使用<code>BeanFactory</code>。</p>
<h3 id="练习">练习</h3>
<p>在上述示例的基础上，继续给<code>UserService</code>注入<code>DataSource</code>，并把注册和登录功能通过数据库实现。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/ioc/injection/spring-ioc-appcontext.zip">下载练习</a></p>
<h3 id="小结">小结</h3>
<p>Spring的IoC容器接口是<code>ApplicationContext</code>，并提供了多种实现类；</p>
<p>通过XML配置文件创建IoC容器时，使用<code>ClassPathXmlApplicationContext</code>；</p>
<p>持有IoC容器后，通过<code>getBean()</code>方法获取Bean的引用。</p>
<p>使用Spring的IoC容器，实际上就是通过类似XML这样的配置文件，把我们自己的Bean的依赖关系描述出来，然后让容器来创建并装配Bean。一旦容器初始化完毕，我们就直接从容器中获取Bean使用它们。</p>
<p>使用XML配置的优点是所有的Bean都能一目了然地列出来，并通过配置注入能直观地看到每个Bean的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。</p>
<p>有没有其他更简单的配置方式呢？</p>
<p>有！我们可以使用Annotation配置，可以完全不需要XML，让Spring自动扫描Bean并组装它们。</p>
<p>我们把上一节的示例改造一下，先删除XML配置文件，然后，给<code>UserService</code>和<code>MailService</code>添加几个注解。</p>
<p>首先，我们给<code>MailService</code>添加一个<code>@Component</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>@Component</code>注解就相当于定义了一个Bean，它有一个可选的名称，默认是<code>mailService</code>，即小写开头的类名。</p>
<p>然后，我们给<code>UserService</code>添加一个<code>@Component</code>注解和一个<code>@Autowired</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MailService mailService;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>@Autowired</code>就相当于把指定类型的Bean注入到指定的字段中。和XML配置相比，<code>@Autowired</code>大幅简化了注入，因为它不但可以写在<code>set()</code>方法上，还可以直接写在字段上，甚至可以写在构造方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    MailService mailService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(<span class="meta">@Autowired</span> MailService mailService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mailService = mailService;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们一般把<code>@Autowired</code>写在字段上，通常使用package权限的字段，便于测试。</p>
<p>最后，编写一个<code>AppConfig</code>类启动容器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.login(<span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了<code>main()</code>方法外，<code>AppConfig</code>标注了<code>@Configuration</code>，表示它是一个配置类，因为我们创建<code>ApplicationContext</code>时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br></pre></td></tr></table></figure>
<p>使用的实现类是<code>AnnotationConfigApplicationContext</code>，必须传入一个标注了<code>@Configuration</code>的类名。</p>
<p>此外，<code>AppConfig</code>还标注了<code>@ComponentScan</code>，它告诉容器，自动搜索当前类所在的包以及子包，把所有标注为<code>@Component</code>的Bean自动创建出来，并根据<code>@Autowired</code>进行装配。</p>
<p>整个工程结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring-ioc-annoconfig</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        └── java</span><br><span class="line">            └── com</span><br><span class="line">                └── itranswarp</span><br><span class="line">                    └── learnjava</span><br><span class="line">                        ├── AppConfig.java</span><br><span class="line">                        └── service</span><br><span class="line">                            ├── MailService.java</span><br><span class="line">                            ├── User.java</span><br><span class="line">                            └── UserService.java</span><br></pre></td></tr></table></figure>
<p>使用Annotation配合自动扫描能大幅简化Spring的配置，我们只需要保证：</p>
<ul>
<li>每个Bean被标注为<code>@Component</code>并正确使用<code>@Autowired</code>注入；</li>
<li>配置类被标注为<code>@Configuration</code>和<code>@ComponentScan</code>；</li>
<li>所有Bean均在指定包以及子包内。</li>
</ul>
<p>使用<code>@ComponentScan</code>非常方便，但是，我们也要特别注意包的层次结构。通常来说，启动配置<code>AppConfig</code>位于自定义的顶层包（例如<code>com.itranswarp.learnjava</code>），其他Bean按类别放入子包。</p>
<h3 id="思考">思考</h3>
<p>如果我们想给<code>UserService</code>注入<code>HikariDataSource</code>，但是这个类位于<code>com.zaxxer.hikari</code>包中，并且<code>HikariDataSource</code>也不可能有<code>@Component</code>注解，如何告诉IoC容器创建并配置<code>HikariDataSource</code>？或者换个说法，如何创建并配置一个第三方Bean？</p>
<h3 id="练习-2">练习</h3>
<p>使用Annotation配置IoC容器。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/ioc/annotation-config/spring-ioc-annoconfig.zip">下载练习</a></p>
<h3 id="小结-2">小结</h3>
<p>使用Annotation可以大幅简化配置，每个Bean通过<code>@Component</code>和<code>@Autowired</code>注入；</p>
<p>必须合理设计包的层次结构，才能发挥<code>@ComponentScan</code>的威力。</p>
<h3 id="Scope">Scope</h3>
<p>对于Spring容器来说，当我们把一个Bean标记为<code>@Component</code>后，它就会自动为我们创建一个单例（Singleton），即容器初始化时创建Bean，容器关闭前销毁Bean。在容器运行期间，我们调用<code>getBean(Class)</code>获取到的Bean总是同一个实例。</p>
<p>还有一种Bean，我们每次调用<code>getBean(Class)</code>，容器都返回一个新的实例，这种Bean称为Prototype（原型），它的生命周期显然和Singleton不同。声明一个Prototype的Bean时，需要添加一个额外的<code>@Scope</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span> <span class="comment">// @Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailSession</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注入List">注入List</h3>
<p>有些时候，我们会有一系列接口相同，不同实现类的Bean。例如，注册用户时，我们要对email、password和name这3个变量进行验证。为了便于扩展，我们先定义验证接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(String email, String password, String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，分别使用3个<code>Validator</code>对用户参数进行验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!email.matches(<span class="string">&quot;^[a-z0-9]+\\@[a-z0-9]+\\.[a-z]&#123;2,10&#125;$&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invalid email: &quot;</span> + email);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PasswordValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!password.matches(<span class="string">&quot;^.&#123;6,20&#125;$&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invalid password&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NameValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span> || name.isBlank() || name.length() &gt; <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invalid name: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们通过一个<code>Validators</code>作为入口进行验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Validators</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    List&lt;Validator&gt; validators;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> validator : <span class="built_in">this</span>.validators) &#123;</span><br><span class="line">            validator.validate(email, password, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>Validators</code>被注入了一个<code>List&lt;Validator&gt;</code>，Spring会自动把所有类型为<code>Validator</code>的Bean装配为一个<code>List</code>注入进来，这样一来，我们每新增一个<code>Validator</code>类型，就自动被Spring装配到<code>Validators</code>中了，非常方便。</p>
<p>因为Spring是通过扫描classpath获取到所有的Bean，而<code>List</code>是有序的，要指定<code>List</code>中Bean的顺序，可以加上<code>@Order</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PasswordValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(3)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NameValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可选注入">可选注入</h3>
<p>默认情况下，当我们标记了一个<code>@Autowired</code>后，Spring如果没有找到对应类型的Bean，它会抛出<code>NoSuchBeanDefinitionException</code>异常。</p>
<p>可以给<code>@Autowired</code>增加一个<code>required = false</code>的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个参数告诉Spring容器，如果找到一个类型为<code>ZoneId</code>的Bean，就注入，如果找不到，就忽略。</p>
<p>这种方式非常适合有定义就使用定义，没有就使用默认值的情况。</p>
<h3 id="创建第三方Bean">创建第三方Bean</h3>
<p>如果一个Bean不在我们自己的package管理之内，例如<code>ZoneId</code>，如何创建它？</p>
<p>答案是我们自己在<code>@Configuration</code>类中编写一个Java方法创建并返回它，注意给方法标记一个<code>@Bean</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个Bean:</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring对标记为<code>@Bean</code>的方法只调用一次，因此返回的Bean仍然是单例。</p>
<h3 id="初始化和销毁">初始化和销毁</h3>
<p>有些时候，一个Bean在注入必要的依赖后，需要进行初始化（监听消息等）。在容器关闭时，有时候还需要清理资源（关闭连接池等）。我们通常会定义一个<code>init()</code>方法进行初始化，定义一个<code>shutdown()</code>方法进行清理，然后，引入JSR-250定义的Annotation：</p>
<ul>
<li>jakarta.annotation:jakarta.annotation-api:2.1.1</li>
</ul>
<p>在Bean的初始化和清理方法上标记<code>@PostConstruct</code>和<code>@PreDestroy</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Init mail service with zoneId = &quot;</span> + <span class="built_in">this</span>.zoneId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shutdown mail service&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring容器会对上述Bean做如下初始化流程：</p>
<ul>
<li>调用构造方法创建<code>MailService</code>实例；</li>
<li>根据<code>@Autowired</code>进行注入；</li>
<li>调用标记有<code>@PostConstruct</code>的<code>init()</code>方法进行初始化。</li>
</ul>
<p>而销毁时，容器会首先调用标记有<code>@PreDestroy</code>的<code>shutdown()</code>方法。</p>
<p>Spring只根据Annotation查找<em>无参数</em>方法，对方法名不作要求。</p>
<h3 id="使用别名">使用别名</h3>
<p>默认情况下，对一种类型的Bean，容器只创建一个实例。但有些时候，我们需要对一种类型的Bean创建多个实例。例如，同时连接多个数据库，就必须创建多个<code>DataSource</code>实例。</p>
<p>如果我们在<code>@Configuration</code>类中创建了多个同类型的Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneOfZ</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneOfUTC8</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;UTC+08:00&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring会报<code>NoUniqueBeanDefinitionException</code>异常，意思是出现了重复的Bean定义。</p>
<p>这个时候，需要给每个Bean添加不同的名字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;z&quot;)</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneOfZ</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;utc8&quot;)</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneOfUTC8</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;UTC+08:00&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以用<code>@Bean(&quot;name&quot;)</code>指定别名，也可以用<code>@Bean</code>+<code>@Qualifier(&quot;name&quot;)</code>指定别名。</p>
<p>存在多个同类型的Bean时，注入<code>ZoneId</code>又会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NoUniqueBeanDefinitionException: No qualifying bean of type &#x27;java.time.ZoneId&#x27; available: expected single matching bean but found 2</span><br></pre></td></tr></table></figure>
<p>意思是期待找到唯一的<code>ZoneId</code>类型Bean，但是找到两。因此，注入时，要指定Bean的名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">	<span class="meta">@Autowired(required = false)</span></span><br><span class="line">	<span class="meta">@Qualifier(&quot;z&quot;)</span> <span class="comment">// 指定注入名称为&quot;z&quot;的ZoneId</span></span><br><span class="line">	<span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种方法是把其中某个Bean指定为<code>@Primary</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span> <span class="comment">// 指定为主要Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;z&quot;)</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneOfZ</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;utc8&quot;)</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneOfUTC8</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;UTC+08:00&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在注入时，如果没有指出Bean的名字，Spring会注入标记有<code>@Primary</code>的Bean。这种方式也很常用。例如，对于主从两个数据源，通常将主数据源定义为<code>@Primary</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    DataSource <span class="title function_">createMasterDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;slave&quot;)</span></span><br><span class="line">    DataSource <span class="title function_">createSlaveDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他Bean默认注入的就是主数据源。如果要注入从数据源，那么只需要指定名称即可。</p>
<h3 id="使用FactoryBean">使用FactoryBean</h3>
<p>我们在设计模式的<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/creational/factory-method/index.html">工厂方法</a>中讲到，很多时候，可以通过工厂模式创建对象。Spring也提供了工厂模式，允许定义一个工厂，然后由工厂创建真正的Bean。</p>
<p>用工厂模式创建Bean需要实现<code>FactoryBean</code>接口。我们观察下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZoneIdFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;ZoneId&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">zone</span> <span class="operator">=</span> <span class="string">&quot;Z&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ZoneId <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(zone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个Bean实现了<code>FactoryBean</code>接口后，Spring会先实例化这个工厂，然后调用<code>getObject()</code>创建真正的Bean。<code>getObjectType()</code>可以指定创建的Bean的类型，因为指定类型不一定与实际类型一致，可以是接口或抽象类。</p>
<p>因此，如果定义了一个<code>FactoryBean</code>，要注意Spring创建的Bean实际上是这个<code>FactoryBean</code>的<code>getObject()</code>方法返回的Bean。为了和普通Bean区分，我们通常都以<code>XxxFactoryBean</code>命名。</p>
<p>由于可以用<code>@Bean</code>方法创建第三方Bean，本质上<code>@Bean</code>方法就是工厂方法，所以，<code>FactoryBean</code>已经用得越来越少了。</p>
<h3 id="练习-3">练习</h3>
<p>定制Bean。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/ioc/customize/spring-ioc-customize.zip">下载练习</a></p>
<h3 id="小结-3">小结</h3>
<p>Spring默认使用Singleton创建Bean，也可指定Scope为Prototype；</p>
<p>可将相同类型的Bean注入<code>List</code>或数组；</p>
<p>可用<code>@Autowired(required=false)</code>允许可选注入；</p>
<p>可用带<code>@Bean</code>标注的方法创建Bean；</p>
<p>可使用<code>@PostConstruct</code>和<code>@PreDestroy</code>对Bean进行初始化和清理；</p>
<p>相同类型的Bean只能有一个指定为<code>@Primary</code>，其他必须用<code>@Qualifier(&quot;beanName&quot;)</code>指定别名；</p>
<p>注入时，可通过别名<code>@Qualifier(&quot;beanName&quot;)</code>指定某个Bean；</p>
<p>可以定义<code>FactoryBean</code>来使用工厂模式创建Bean。</p>
<h2 id="使用Resource">使用Resource</h2>
<p>在Java程序中，我们经常会读取配置文件、资源文件等。使用Spring容器时，我们也可以把“文件”注入进来，方便程序读取。</p>
<p>例如，AppService需要读取<code>logo.txt</code>这个文件，通常情况下，我们需要写很多繁琐的代码，主要是为了定位文件，打开InputStream。</p>
<p>Spring提供了一个<code>org.springframework.core.io.Resource</code>（注意不是<code>jarkata.annotation.Resource</code>或<code>javax.annotation.Resource</code>），它可以像<code>String</code>、<code>int</code>一样使用<code>@Value</code>注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppService</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;classpath:/logo.txt&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Resource resource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String logo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(resource.getInputStream(), StandardCharsets.UTF_8))) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logo = reader.lines().collect(Collectors.joining(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注入<code>Resource</code>最常用的方式是通过classpath，即类似<code>classpath:/logo.txt</code>表示在classpath中搜索<code>logo.txt</code>文件，然后，我们直接调用<code>Resource.getInputStream()</code>就可以获取到输入流，避免了自己搜索文件的代码。</p>
<p>也可以直接指定文件的路径，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;file:/path/to/logo.txt&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Resource resource;</span><br></pre></td></tr></table></figure>
<p>但使用classpath是最简单的方式。上述工程结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring-ioc-resource</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── itranswarp</span><br><span class="line">        │           └── learnjava</span><br><span class="line">        │               ├── AppConfig.java</span><br><span class="line">        │               └── AppService.java</span><br><span class="line">        └── resources</span><br><span class="line">            └── logo.txt</span><br></pre></td></tr></table></figure>
<p>使用Maven的标准目录结构，所有资源文件放入<code>src/main/resources</code>即可。</p>
<h3 id="练习-4">练习</h3>
<p>使用Spring的<code>Resource</code>注入<code>app.properties</code>文件，然后读取该配置文件。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/ioc/resource/spring-ioc-resource.zip">下载练习</a></p>
<h3 id="小结-4">小结</h3>
<p>Spring提供了Resource类便于注入资源文件。</p>
<p>最常用的注入是通过classpath以<code>classpath:/path/to/file</code>的形式注入。</p>
<hr>
<hr>
<h2 id="注入配置">注入配置</h2>
<p>在开发应用程序时，经常需要读取配置文件。最常用的配置方法是以<code>key=value</code>的形式写在<code>.properties</code>文件中。</p>
<p>例如，<code>MailService</code>根据配置的<code>app.zone=Asia/Shanghai</code>来决定使用哪个时区。要读取配置文件，我们可以使用上一节讲到的<code>Resource</code>来读取位于classpath下的一个<code>app.properties</code>文件。但是，这样仍然比较繁琐。</p>
<p>Spring容器还提供了一个更简单的<code>@PropertySource</code>来自动读取配置文件。我们只需要在<code>@Configuration</code>配置类上再添加一个注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;app.properties&quot;)</span> <span class="comment">// 表示读取classpath的app.properties</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.zone:Z&#125;&quot;)</span></span><br><span class="line">    String zoneId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(zoneId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring容器看到<code>@PropertySource(&quot;app.properties&quot;)</code>注解后，自动读取这个配置文件，然后，我们使用<code>@Value</code>正常注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;app.zone:Z&#125;&quot;)</span></span><br><span class="line">String zoneId;</span><br></pre></td></tr></table></figure>
<p>注意注入的字符串语法，它的格式如下：</p>
<ul>
<li><code>&quot;$&#123;app.zone&#125;&quot;</code>表示读取key为<code>app.zone</code>的value，如果key不存在，启动将报错；</li>
<li><code>&quot;$&#123;app.zone:Z&#125;&quot;</code>表示读取key为<code>app.zone</code>的value，但如果key不存在，就使用默认值<code>Z</code>。</li>
</ul>
<p>这样一来，我们就可以根据<code>app.zone</code>的配置来创建<code>ZoneId</code>。</p>
<p>还可以把注入的注解写到方法参数中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">ZoneId <span class="title function_">createZoneId</span><span class="params">(<span class="meta">@Value(&quot;$&#123;app.zone:Z&#125;&quot;)</span> String zoneId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ZoneId.of(zoneId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，先使用<code>@PropertySource</code>读取配置文件，然后通过<code>@Value</code>以<code>$&#123;key:defaultValue&#125;</code>的形式注入，可以极大地简化读取配置的麻烦。</p>
<p>另一种注入配置的方式是先通过一个简单的JavaBean持有所有的配置，例如，一个<code>SmtpConfig</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmtpConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;smtp.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;smtp.port:25&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在需要读取的地方，使用<code>#&#123;smtpConfig.host&#125;</code>注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;smtpConfig.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String smtpHost;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;smtpConfig.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> smtpPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意观察<code>#&#123;&#125;</code>这种注入语法，它和<code>$&#123;key&#125;</code>不同的是，<code>#&#123;&#125;</code>表示从JavaBean读取属性。<code>&quot;#&#123;smtpConfig.host&#125;&quot;</code>的意思是，从名称为<code>smtpConfig</code>的Bean读取<code>host</code>属性，即调用<code>getHost()</code>方法。一个Class名为<code>SmtpConfig</code>的Bean，它在Spring容器中的默认名称就是<code>smtpConfig</code>，除非用<code>@Qualifier</code>指定了名称。</p>
<p>使用一个独立的JavaBean持有所有属性，然后在其他Bean中以<code>#&#123;bean.property&#125;</code>注入的好处是，多个Bean都可以引用同一个Bean的某个属性。例如，如果<code>SmtpConfig</code>决定从数据库中读取相关配置项，那么<code>MailService</code>注入的<code>@Value(&quot;#&#123;smtpConfig.host&#125;&quot;)</code>仍然可以不修改正常运行。</p>
<h3 id="练习-5">练习</h3>
<p>注入SMTP配置。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/ioc/properties/spring-ioc-properties.zip">下载练习</a></p>
<h3 id="小结-5">小结</h3>
<p>Spring容器可以通过<code>@PropertySource</code>自动读取配置，并以<code>@Value(&quot;$&#123;key&#125;&quot;)</code>的形式注入；</p>
<p>可以通过<code>$&#123;key:defaultValue&#125;</code>指定默认值；</p>
<p>以<code>#&#123;bean.property&#125;</code>形式注入时，Spring容器自动把指定Bean的指定属性值注入。</p>
<hr>
<hr>
<p>开发应用程序时，我们会使用开发环境，例如，使用内存数据库以便快速启动。而运行在生产环境时，我们会使用生产环境，例如，使用MySQL数据库。如果应用程序可以根据自身的环境做一些适配，无疑会更加灵活。</p>
<p>Spring为应用程序准备了Profile这一概念，用来表示不同的环境。例如，我们分别定义开发、测试和生产这3个环境：</p>
<ul>
<li>native</li>
<li>test</li>
<li>production</li>
</ul>
<p>创建某个Bean时，Spring容器可以根据注解<code>@Profile</code>来决定是否创建。例如，以下配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;!test&quot;)</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.systemDefault();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;test&quot;)</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneIdForTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前的Profile设置为<code>test</code>，则Spring容器会调用<code>createZoneIdForTest()</code>创建<code>ZoneId</code>，否则，调用<code>createZoneId()</code>创建<code>ZoneId</code>。注意到<code>@Profile(&quot;!test&quot;)</code>表示非test环境。</p>
<p>在运行程序时，加上JVM参数<code>-Dspring.profiles.active=test</code>就可以指定以<code>test</code>环境启动。</p>
<p>实际上，Spring允许指定多个Profile，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dspring.profiles.active=test,master</span><br></pre></td></tr></table></figure>
<p>可以表示<code>test</code>环境，并使用<code>master</code>分支代码。</p>
<p>要满足多个Profile条件，可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile(&#123; &quot;test&quot;, &quot;master&quot; &#125;)</span> <span class="comment">// 满足test或master</span></span><br><span class="line">ZoneId <span class="title function_">createZoneId</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用Conditional">使用Conditional</h3>
<p>除了根据<code>@Profile</code>条件来决定是否创建某个Bean外，Spring还可以根据<code>@Conditional</code>决定是否创建某个Bean。</p>
<p>例如，我们对<code>SmtpMailService</code>添加如下注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Conditional(OnSmtpEnvCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmtpMailService</span> <span class="keyword">implements</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的意思是，如果满足<code>OnSmtpEnvCondition</code>的条件，才会创建<code>SmtpMailService</code>这个Bean。<code>OnSmtpEnvCondition</code>的条件是什么呢？我们看一下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnSmtpEnvCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;true&quot;</span>.equalsIgnoreCase(System.getenv(<span class="string">&quot;smtp&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，<code>OnSmtpEnvCondition</code>的条件是存在环境变量<code>smtp</code>，值为<code>true</code>。这样，我们就可以通过环境变量来控制是否创建<code>SmtpMailService</code>。</p>
<p>Spring只提供了<code>@Conditional</code>注解，具体判断逻辑还需要我们自己实现。Spring Boot提供了更多使用起来更简单的条件注解，例如，如果配置文件中存在<code>app.smtp=true</code>，则创建<code>MailService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name=&quot;app.smtp&quot;, havingValue=&quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前classpath中存在类<code>javax.mail.Transport</code>，则创建<code>MailService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;javax.mail.Transport&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续我们会介绍Spring Boot的条件装配。我们以文件存储为例，假设我们需要保存用户上传的头像，并返回存储路径，在本地开发运行时，我们总是存储到文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;app.storage&quot;, havingValue = &quot;file&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploader</span> <span class="keyword">implements</span> <span class="title class_">Uploader</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在生产环境运行时，我们会把文件存储到类似AWS S3上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;app.storage&quot;, havingValue = &quot;s3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">S3Uploader</span> <span class="keyword">implements</span> <span class="title class_">Uploader</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他需要存储的服务则注入<code>Uploader</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserImageService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Uploader uploader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当应用程序检测到配置文件存在<code>app.storage=s3</code>时，自动使用<code>S3Uploader</code>，如果存在配置<code>app.storage=file</code>，或者配置<code>app.storage</code>不存在，则使用<code>FileUploader</code>。</p>
<p>可见，使用条件注解，能更灵活地装配Bean。</p>
<h3 id="练习-6">练习</h3>
<p>使用@Profile进行条件装配。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/ioc/conditional/spring-ioc-conditional.zip">下载练习</a></p>
<h3 id="小结-6">小结</h3>
<p>Spring允许通过<code>@Profile</code>配置不同的Bean；</p>
<p>Spring还提供了<code>@Conditional</code>来进行条件装配，Spring Boot在此基础上进一步提供了基于配置、Class、Bean等条件进行装配。</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">標籤</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/Java/" rel="tag">Java</a> <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/Spirng/" rel="tag">Spirng</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JAVA-Spring%E5%BC%80%E5%8F%91-AOP/"
                    data-tooltip="JAVA-Spring开发-AOP"
                    aria-label="上一篇: JAVA-Spring开发-AOP"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JAVA-Spring%E5%BC%80%E5%8F%91-%E4%BB%8B%E7%BB%8D/"
                    data-tooltip="JAVA-Spring开发-介绍"
                    aria-label="下一篇: JAVA-Spring开发-介绍"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/26/JAVA/JAVA-Spring%E5%BC%80%E5%8F%91-IoC/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/26/JAVA/JAVA-Spring%E5%BC%80%E5%8F%91-IoC/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/26/JAVA/JAVA-Spring%E5%BC%80%E5%8F%91-IoC/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/26/JAVA/JAVA-Spring%E5%BC%80%E5%8F%91-IoC/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JAVA-Spring%E5%BC%80%E5%8F%91-AOP/"
                    data-tooltip="JAVA-Spring开发-AOP"
                    aria-label="上一篇: JAVA-Spring开发-AOP"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JAVA-Spring%E5%BC%80%E5%8F%91-%E4%BB%8B%E7%BB%8D/"
                    data-tooltip="JAVA-Spring开发-介绍"
                    aria-label="下一篇: JAVA-Spring开发-介绍"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/26/JAVA/JAVA-Spring%E5%BC%80%E5%8F%91-IoC/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/26/JAVA/JAVA-Spring%E5%BC%80%E5%8F%91-IoC/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/26/JAVA/JAVA-Spring%E5%BC%80%E5%8F%91-IoC/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/26/JAVA/JAVA-Spring%E5%BC%80%E5%8F%91-IoC/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/26/JAVA/JAVA-Spring%E5%BC%80%E5%8F%91-IoC/"
                        aria-label="分享到 Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/26/JAVA/JAVA-Spring%E5%BC%80%E5%8F%91-IoC/"
                        aria-label="分享到 Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/26/JAVA/JAVA-Spring%E5%BC%80%E5%8F%91-IoC/"
                        aria-label="global.share_on_linkedin"
                    >
                        <i class="fab fa-linkedin" aria-hidden="true"></i><span>global.share_on_linkedin</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/26/JAVA/JAVA-Spring%E5%BC%80%E5%8F%91-IoC/"
                        aria-label="分享到 Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>Kein目前居住在東京和澳門.</br>熱愛旅遊.已探訪日本40多個都道府縣.曾自駕環繞日本半個本州.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macao
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 134 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
