
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>JAVA-Spring Boot开发 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg"},"articleBody":"使用Conditional\n使用Profile能根据不同的Profile进行条件装配，但是Profile控制比较糙，如果想要精细控制，例如，配置本地存储，AWS存储和阿里云存储，将来很可能会增加Azure存储等，用Profile就很难实现。\nSpring本身提供了条件装配@Conditional，但是要自己编写比较复杂的Condition来做判断，比较麻烦。Spring Boot则为我们准备好了几个非常有用的条件：\n\n@ConditionalOnProperty：如果有指定的配置，条件生效；\n@ConditionalOnBean：如果有指定的Bean，条件生效；\n@ConditionalOnMissingBean：如果没有指定的Bean，条件生效；\n@ConditionalOnMissingClass：如果没有指定的Class，条件生效；\n@ConditionalOnWebApplication：在Web环境中条件生效；\n@ConditionalOnExpression：根据表达式判断条件是否生效。\n\n我们以最常用的@ConditionalOnProperty为例，把上一节的StorageService改写如下。首先，定义配置storage.type=xxx，用来判断条件，默认为local：\n12storage:  type: $&#123;STORAGE_TYPE:local&#125;\n设定为local时，启用LocalStorageService：\n12345@Component@ConditionalOnProperty(value = &quot;storage.type&quot;, havingValue = &quot;local&quot;, matchIfMissing = true)public class LocalStorageService implements StorageService &#123;    ...&#125;\n设定为aws时，启用AwsStorageService：\n12345@Component@ConditionalOnProperty(value = &quot;storage.type&quot;, havingValue = &quot;aws&quot;)public class AwsStorageService implements StorageService &#123;    ...&#125;\n设定为aliyun时，启用AliyunStorageService：\n12345@Component@ConditionalOnProperty(value = &quot;storage.type&quot;, havingValue = &quot;aliyun&quot;)public class AliyunStorageService implements StorageService &#123;    ...&#125;\n注意到LocalStorageService的注解，当指定配置为local，或者配置不存在，均启用LocalStorageService。\n可见，Spring Boot提供的条件装配使得应用程序更加具有灵活性。\n练习\n使用Spring Boot提供的条件装配。\n下载练习\n小结\nSpring Boot提供了几个非常有用的条件装配注解，可实现灵活的条件装配。\n\n\nProfile本身是Spring提供的功能，我们在使用条件装配中已经讲到了，Profile表示一个环境的概念，如开发、测试和生产这3个环境：\n\nnative\ntest\nproduction\n\n或者按git分支定义master、dev这些环境：\n\nmaster\ndev\n\n在启动一个Spring应用程序的时候，可以传入一个或多个环境，例如：\n1-Dspring.profiles.active=test,master\n大多数情况下，使用一个环境就足够了。\nSpring Boot对Profiles的支持在于，可以在application.yml中为每个环境进行配置。下面是一个示例配置：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445spring:  application:    name: $&#123;APP_NAME:unnamed&#125;  datasource:    url: jdbc:hsqldb:file:testdb    username: sa    password:    dirver-class-name: org.hsqldb.jdbc.JDBCDriver    hikari:      auto-commit: false      connection-timeout: 3000      validation-timeout: 3000      max-lifetime: 60000      maximum-pool-size: 20      minimum-idle: 1pebble:  suffix:  cache: falseserver:  port: $&#123;APP_PORT:8080&#125;---spring:  config:    activate:      on-profile: testserver:  port: 8000---spring:  config:    activate:      on-profile: productionserver:  port: 80pebble:  cache: true\n注意到分隔符---，最前面的配置是默认配置，不需要指定Profile，后面的每段配置都必须以spring.config.activate.on-profile: xxx开头，表示一个Profile。上述配置默认使用8080端口，但是在test环境下，使用8000端口，在production环境下，使用80端口，并且启用Pebble的缓存。\n如果我们不指定任何Profile，直接启动应用程序，那么Profile实际上就是default，可以从Spring Boot启动日志看出：\n12...2022-11-25T11:10:34.006+08:00  INFO 13537 --- [           main] com.itranswarp.learnjava.Application     : No active profile set, falling back to 1 default profile: &quot;default&quot;\n上述日志显示未设置Profile，使用默认的Profile为default。\n要以test环境启动，可输入如下命令：\n1234567$ java -Dspring.profiles.active=test -jar springboot-profiles-1.0-SNAPSHOT.jar...2022-11-25T11:09:02.946+08:00  INFO 13510 --- [           main] com.itranswarp.learnjava.Application     : The following 1 profile is active: &quot;test&quot;...2022-11-25T11:09:05.124+08:00  INFO 13510 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8000 (http) with context path &#x27;&#x27;...\n从日志看到活动的Profile是test，Tomcat的监听端口是8000。\n通过Profile可以实现一套代码在不同环境启用不同的配置和功能。假设我们需要一个存储服务，在本地开发时，直接使用文件存储即可，但是，在测试和生产环境，需要存储到云端如S3上，如何通过Profile实现该功能？\n首先，我们要定义存储接口StorageService：\n12345678public interface StorageService &#123;    // 根据URI打开InputStream:    InputStream openInputStream(String uri) throws IOException;    // 根据扩展名+InputStream保存并返回URI:    String store(String extName, InputStream input) throws IOException;&#125;\n本地存储可通过LocalStorageService实现：\n1234567891011121314151617181920212223242526272829303132@Component@Profile(&quot;default&quot;)public class LocalStorageService implements StorageService &#123;    @Value(&quot;$&#123;storage.local:/var/static&#125;&quot;)    String localStorageRootDir;    final Logger logger = LoggerFactory.getLogger(getClass());    private File localStorageRoot;    @PostConstruct    public void init() &#123;        logger.info(&quot;Intializing local storage with root dir: &#123;&#125;&quot;, this.localStorageRootDir);        this.localStorageRoot = new File(this.localStorageRootDir);    &#125;    @Override    public InputStream openInputStream(String uri) throws IOException &#123;        File targetFile = new File(this.localStorageRoot, uri);        return new BufferedInputStream(new FileInputStream(targetFile));    &#125;    @Override    public String store(String extName, InputStream input) throws IOException &#123;        String fileName = UUID.randomUUID().toString() + &quot;.&quot; + extName;        File targetFile = new File(this.localStorageRoot, fileName);        try (OutputStream output = new BufferedOutputStream(new FileOutputStream(targetFile))) &#123;            input.transferTo(output);        &#125;        return fileName;    &#125;&#125;\n而云端存储可通过CloudStorageService实现：\n1234567891011121314151617181920212223242526272829303132@Component@Profile(&quot;!default&quot;)public class CloudStorageService implements StorageService &#123;    @Value(&quot;$&#123;storage.cloud.bucket:&#125;&quot;)    String bucket;    @Value(&quot;$&#123;storage.cloud.access-key:&#125;&quot;)    String accessKey;    @Value(&quot;$&#123;storage.cloud.access-secret:&#125;&quot;)    String accessSecret;    final Logger logger = LoggerFactory.getLogger(getClass());    @PostConstruct    public void init() &#123;        // TODO:        logger.info(&quot;Initializing cloud storage...&quot;);    &#125;    @Override    public InputStream openInputStream(String uri) throws IOException &#123;        // TODO:        throw new IOException(&quot;File not found: &quot; + uri);    &#125;    @Override    public String store(String extName, InputStream input) throws IOException &#123;        // TODO:        throw new IOException(&quot;Unable to access cloud storage.&quot;);    &#125;&#125;\n注意到LocalStorageService使用了条件装配@Profile(&quot;default&quot;)，即默认启用LocalStorageService，而CloudStorageService使用了条件装配@Profile(&quot;!default&quot;)，即非default环境时，自动启用CloudStorageService。这样，一套代码，就实现了不同环境启用不同的配置。\n练习\n使用Profile启动Spring Boot应用。\n下载练习\n小结\nSpring Boot允许在一个配置文件中针对不同Profile进行配置；\nSpring Boot在未指定Profile时默认为default。\n使用Actuator\n在生产环境中，需要对应用程序的状态进行监控。前面我们已经介绍了使用JMX对Java应用程序包括JVM进行监控，使用JMX需要把一些监控信息以MBean的形式暴露给JMX Server，而Spring Boot已经内置了一个监控功能，它叫Actuator。\n使用Actuator非常简单，只需添加如下依赖：\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;\n然后正常启动应用程序，Actuator会把它能收集到的所有信息都暴露给JMX。此外，Actuator还可以通过URL/actuator/挂载一些监控点，例如，输入http://localhost:8080/actuator/health，我们可以查看应用程序当前状态：\n123&#123;    &quot;status&quot;: &quot;UP&quot;&#125;\n许多网关作为反向代理需要一个URL来探测后端集群应用是否存活，这个URL就可以提供给网关使用。\nActuator默认把所有访问点暴露给JMX，但处于安全原因，只有health和info会暴露给Web。Actuator提供的所有访问点均在官方文档列出，要暴露更多的访问点给Web，需要在application.yml中加上配置：\n12345management:  endpoints:    web:      exposure:        include: info, health, beans, env, metrics\n要特别注意暴露的URL的安全性，例如，/actuator/env可以获取当前机器的所有环境变量，不可暴露给公网。\n练习\n使用Actuator实现监控。\n下载练习\n小结\nSpring Boot提供了一个Actuator，可以方便地实现监控，并可通过Web访问特定类型的监控。\n\n\n打包Spring Boot应用\n我们在Maven的使用插件一节中介绍了如何使用maven-shade-plugin打包一个可执行的jar包。在Spring Boot应用中，打包更加简单，因为Spring Boot自带一个更简单的spring-boot-maven-plugin插件用来打包，我们只需要在pom.xml中加入以下配置：\n1234567891011&lt;project ...&gt;    ...    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n无需任何配置，Spring Boot的这款插件会自动定位应用程序的入口Class，我们执行以下Maven命令即可打包：\n1$ mvn clean package\n以springboot-exec-jar项目为例，打包后我们在target目录下可以看到两个jar文件：\n1234567$ lsclassesgenerated-sourcesmaven-archivermaven-statusspringboot-exec-jar-1.0-SNAPSHOT.jarspringboot-exec-jar-1.0-SNAPSHOT.jar.original\n其中，springboot-exec-jar-1.0-SNAPSHOT.jar.original是Maven标准打包插件打的jar包，它只包含我们自己的Class，不包含依赖，而springboot-exec-jar-1.0-SNAPSHOT.jar是Spring Boot打包插件创建的包含依赖的jar，可以直接运行：\n1$ java -jar springboot-exec-jar-1.0-SNAPSHOT.jar\n这样，部署一个Spring Boot应用就非常简单，无需预装任何服务器，只需要上传jar包即可。\n在打包的时候，因为打包后的Spring Boot应用不会被修改，因此，默认情况下，spring-boot-devtools这个依赖不会被打包进去。但是要注意，使用早期的Spring Boot版本时，需要配置一下才能排除spring-boot-devtools这个依赖：\n1234567&lt;plugin&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;    &lt;configuration&gt;        &lt;excludeDevtools&gt;true&lt;/excludeDevtools&gt;    &lt;/configuration&gt;&lt;/plugin&gt;\n如果不喜欢默认的项目名+版本号作为文件名，可以加一个配置指定文件名：\n1234567&lt;project ...&gt;    ...    &lt;build&gt;        &lt;finalName&gt;awesome-app&lt;/finalName&gt;        ...    &lt;/build&gt;&lt;/project&gt;\n这样打包后的文件名就是awesome-app.jar。\n练习\n使用Spring Boot插件打包可执行jar。\n下载练习\n小结\nSpring Boot提供了一个Maven插件用于打包所有依赖到单一jar文件，此插件十分易用，无需配置。\n\n\n在开发阶段，我们经常要修改代码，然后重启Spring Boot应用。经常手动停止再启动，比较麻烦。\nSpring Boot提供了一个开发者工具，可以监控classpath路径上的文件。只要源码或配置文件发生修改，Spring Boot应用可以自动重启。在开发阶段，这个功能比较有用。\n要使用这一开发者功能，我们只需添加如下依赖到pom.xml：\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt;\n然后，没有然后了。直接启动应用程序，然后试着修改源码，保存，观察日志输出，Spring Boot会自动重新加载。\n默认配置下，针对/static、/public和/templates目录中的文件修改，不会自动重启，因为禁用缓存后，这些文件的修改可以实时更新。\n练习\n使用devtools检测修改并自动重启。\n下载练习\n小结\nSpring Boot提供了一个开发阶段非常有用的spring-boot-devtools，能自动检测classpath路径上文件修改并自动重启。\n要了解Spring Boot，我们先来编写第一个Spring Boot应用程序，看看与前面我们编写的Spring应用程序有何异同。\n我们新建一个springboot-hello的工程，创建标准的Maven目录结构如下：\n1234567891011springboot-hello├── pom.xml├── src│   └── main│       ├── java│       └── resources│           ├── application.yml│           ├── logback-spring.xml│           ├── static│           └── templates└── target\n其中，在src/main/resources目录下，注意到几个文件：\napplication.yml\n这是Spring Boot默认的配置文件，它采用YAML格式而不是.properties格式，文件名必须是application.yml而不是其他名称。\nYAML格式比key=value格式的.properties文件更易读。比较一下两者的写法：\n使用.properties格式：\n123456789101112131415# application.propertiesspring.application.name=$&#123;APP_NAME:unnamed&#125;spring.datasource.url=jdbc:hsqldb:file:testdbspring.datasource.username=saspring.datasource.password=spring.datasource.driver-class-name=org.hsqldb.jdbc.JDBCDriverspring.datasource.hikari.auto-commit=falsespring.datasource.hikari.connection-timeout=3000spring.datasource.hikari.validation-timeout=3000spring.datasource.hikari.max-lifetime=60000spring.datasource.hikari.maximum-pool-size=20spring.datasource.hikari.minimum-idle=1\n使用YAML格式：\n1234567891011121314151617# application.ymlspring:  application:    name: $&#123;APP_NAME:unnamed&#125;  datasource:    url: jdbc:hsqldb:file:testdb    username: sa    password:    driver-class-name: org.hsqldb.jdbc.JDBCDriver    hikari:      auto-commit: false      connection-timeout: 3000      validation-timeout: 3000      max-lifetime: 60000      maximum-pool-size: 20      minimum-idle: 1\n可见，YAML是一种层级格式，它和.properties很容易互相转换，它的优点是去掉了大量重复的前缀，并且更加易读。\n提示\n也可以使用application.properties作为配置文件，但不如YAML格式简单。\n使用环境变量\n在配置文件中，我们经常使用如下的格式对某个key进行配置：\n12345app:  db:    host: $&#123;DB_HOST:localhost&#125;    user: $&#123;DB_USER:root&#125;    password: $&#123;DB_PASSWORD:password&#125;\n这种$&#123;DB_HOST:localhost&#125;意思是，首先从环境变量查找DB_HOST，如果环境变量定义了，那么使用环境变量的值，否则，使用默认值localhost。\n这使得我们在开发和部署时更加方便，因为开发时无需设定任何环境变量，直接使用默认值即本地数据库，而实际线上运行的时候，只需要传入环境变量即可：\n1$ DB_HOST=10.0.1.123 DB_USER=prod DB_PASSWORD=xxxx java -jar xxx.jar\nlogback-spring.xml\n这是Spring Boot的logback配置文件名称（也可以使用logback.xml），一个标准的写法如下：\n12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt;    &lt;include resource=&quot;org/springframework/boot/logging/logback/defaults.xml&quot; /&gt;    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;encoder&gt;            &lt;pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/pattern&gt;            &lt;charset&gt;utf8&lt;/charset&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;appender name=&quot;APP_LOG&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;encoder&gt;            &lt;pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;/pattern&gt;            &lt;charset&gt;utf8&lt;/charset&gt;        &lt;/encoder&gt;          &lt;file&gt;app.log&lt;/file&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;&gt;            &lt;maxIndex&gt;1&lt;/maxIndex&gt;            &lt;fileNamePattern&gt;app.log.%i&lt;/fileNamePattern&gt;        &lt;/rollingPolicy&gt;        &lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;            &lt;MaxFileSize&gt;1MB&lt;/MaxFileSize&gt;        &lt;/triggeringPolicy&gt;    &lt;/appender&gt;    &lt;root level=&quot;INFO&quot;&gt;        &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;        &lt;appender-ref ref=&quot;APP_LOG&quot; /&gt;    &lt;/root&gt;&lt;/configuration&gt;\n它主要通过&lt;include resource=&quot;...&quot; /&gt;引入了Spring Boot的一个缺省配置，这样我们就可以引用类似$&#123;CONSOLE_LOG_PATTERN&#125;这样的变量。上述配置定义了一个控制台输出和文件输出，可根据需要修改。\nstatic是静态文件目录，templates是模板文件目录，注意它们不再存放在src/main/webapp下，而是直接放到src/main/resources这个classpath目录，因为在Spring Boot中已经不需要专门的webapp目录了。\n以上就是Spring Boot的标准目录结构，它完全是一个基于Java应用的普通Maven项目。\n我们再来看源码目录结构：\n1234567891011src/main/java└── com    └── itranswarp        └── learnjava            ├── Application.java            ├── entity            │   └── User.java            ├── service            │   └── UserService.java            └── web                └── UserController.java\n在存放源码的src/main/java目录中，Spring Boot对Java包的层级结构有一个要求。注意到我们的根package是com.itranswarp.learnjava，下面还有entity、service、web等子package。Spring Boot要求main()方法所在的启动类必须放到根package下，命名不做要求，这里我们以Application.java命名，它的内容如下：\n123456@SpringBootApplicationpublic class Application &#123;    public static void main(String[] args) throws Exception &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;\n启动Spring Boot应用程序只需要一行代码加上一个注解@SpringBootApplication，该注解实际上又包含了：\n\n@SpringBootConfiguration\n\n@Configuration\n\n\n@EnableAutoConfiguration\n\n@AutoConfigurationPackage\n\n\n@ComponentScan\n\n这样一个注解就相当于启动了自动配置和自动扫描。\n我们再观察pom.xml，它的内容如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;project ...&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;3.0.0&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;    &lt;artifactId&gt;springboot-hello&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;        &lt;java.version&gt;17&lt;/java.version&gt;        &lt;pebble.version&gt;3.2.0&lt;/pebble.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- 集成Pebble View --&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.pebbletemplates&lt;/groupId&gt;            &lt;artifactId&gt;pebble-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;$&#123;pebble.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- JDBC驱动 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;            &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n使用Spring Boot时，强烈推荐从spring-boot-starter-parent继承，因为这样就可以引入Spring Boot的预置配置。\n紧接着，我们引入了依赖spring-boot-starter-web和spring-boot-starter-jdbc，它们分别引入了Spring MVC相关依赖和Spring JDBC相关依赖，无需指定版本号，因为引入的&lt;parent&gt;内已经指定了，只有我们自己引入的某些第三方jar包需要指定版本号。这里我们引入pebble-spring-boot-starter作为View，以及hsqldb作为嵌入式数据库。hsqldb已在spring-boot-starter-jdbc中预置了版本号3.0.0，因此此处无需指定版本号。\n根据pebble-spring-boot-starter的文档，加入如下配置到application.yml：\n12345pebble:  # 默认为&quot;.peb&quot;，改为&quot;&quot;:  suffix:  # 开发阶段禁用模板缓存:  cache: false\n对Application稍作改动，添加WebMvcConfigurer这个Bean：\n12345678910111213141516@SpringBootApplicationpublic class Application &#123;    ...    @Bean    WebMvcConfigurer createWebMvcConfigurer(@Autowired HandlerInterceptor[] interceptors) &#123;        return new WebMvcConfigurer() &#123;            @Override            public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;                // 映射路径`/static/`到classpath路径:                registry.addResourceHandler(&quot;/static/**&quot;)                        .addResourceLocations(&quot;classpath:/static/&quot;);            &#125;        &#125;;    &#125;&#125;\n现在就可以直接运行Application，启动后观察Spring Boot的日志：\n123456789101112131415161718192021222324  .   ____          _            __ _ _ /\\\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \\ \\ \\ \\( ( )\\___ | &#x27;_ | &#x27;_| | &#x27;_ \\/ _` | \\ \\ \\ \\ \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )  &#x27;  |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot ::                (v3.0.0)2022-11-25T10:49:31.100+08:00  INFO 13105 --- [           main] com.itranswarp.learnjava.Application     : Starting Application using Java 17 with PID 13105 (/Users/liaoxuefeng/Git/springboot-hello/target/classes started by liaoxuefeng in /Users/liaoxuefeng/Git/springboot-hello)2022-11-25T10:49:31.107+08:00  INFO 13105 --- [           main] com.itranswarp.learnjava.Application     : No active profile set, falling back to 1 default profile: &quot;default&quot;2022-11-25T10:49:32.404+08:00  INFO 13105 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)2022-11-25T10:49:32.423+08:00  INFO 13105 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]2022-11-25T10:49:32.426+08:00  INFO 13105 --- [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.1]2022-11-25T10:49:32.549+08:00  INFO 13105 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext2022-11-25T10:49:32.551+08:00  INFO 13105 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1327 ms2022-11-25T10:49:32.668+08:00  WARN 13105 --- [           main] com.zaxxer.hikari.HikariConfig           : HikariPool-1 - idleTimeout is close to or more than maxLifetime, disabling it.2022-11-25T10:49:32.669+08:00  INFO 13105 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...2022-11-25T10:49:32.996+08:00  INFO 13105 --- [           main] com.zaxxer.hikari.pool.PoolBase          : HikariPool-1 - Driver does not support get/set network timeout for connections. (feature not supported)2022-11-25T10:49:32.998+08:00  INFO 13105 --- [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection org.hsqldb.jdbc.JDBCConnection@31a2a9fa2022-11-25T10:49:33.002+08:00  INFO 13105 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.2022-11-25T10:49:33.391+08:00  WARN 13105 --- [           main] ocalVariableTableParameterNameDiscoverer : Using deprecated &#x27;-debug&#x27; fallback for parameter name resolution. Compile the affected code with &#x27;-parameters&#x27; instead or avoid its introspection: io.pebbletemplates.boot.autoconfigure.PebbleServletWebConfiguration2022-11-25T10:49:33.398+08:00  WARN 13105 --- [           main] ocalVariableTableParameterNameDiscoverer : Using deprecated &#x27;-debug&#x27; fallback for parameter name resolution. Compile the affected code with &#x27;-parameters&#x27; instead or avoid its introspection: io.pebbletemplates.boot.autoconfigure.PebbleAutoConfiguration2022-11-25T10:49:33.619+08:00  INFO 13105 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path &#x27;&#x27;2022-11-25T10:49:33.637+08:00  INFO 13105 --- [           main] com.itranswarp.learnjava.Application     : Started Application in 3.151 seconds (process running for 3.835)\nSpring Boot自动启动了嵌入式Tomcat，当看到Started Application in xxx seconds时，Spring Boot应用启动成功。\n现在，我们在浏览器输入localhost:8080就可以直接访问页面。那么问题来了：\n前面我们定义的数据源、声明式事务、JdbcTemplate在哪创建的？怎么就可以直接注入到自己编写的UserService中呢？\n这些自动创建的Bean就是Spring Boot的特色：AutoConfiguration。\n当我们引入spring-boot-starter-jdbc时，启动时会自动扫描所有的XxxAutoConfiguration：\n\nDataSourceAutoConfiguration：自动创建一个DataSource，其中配置项从application.yml的spring.datasource读取；\nDataSourceTransactionManagerAutoConfiguration：自动创建了一个基于JDBC的事务管理器；\nJdbcTemplateAutoConfiguration：自动创建了一个JdbcTemplate。\n\n因此，我们自动得到了一个DataSource、一个DataSourceTransactionManager和一个JdbcTemplate。\n类似的，当我们引入spring-boot-starter-web时，自动创建了：\n\nServletWebServerFactoryAutoConfiguration：自动创建一个嵌入式Web服务器，默认是Tomcat；\nDispatcherServletAutoConfiguration：自动创建一个DispatcherServlet；\nHttpEncodingAutoConfiguration：自动创建一个CharacterEncodingFilter；\nWebMvcAutoConfiguration：自动创建若干与MVC相关的Bean。\n…\n\n引入第三方pebble-spring-boot-starter时，自动创建了：\n\nPebbleAutoConfiguration：自动创建了一个PebbleViewResolver。\n\nSpring Boot大量使用XxxAutoConfiguration来使得许多组件被自动化配置并创建，而这些创建过程又大量使用了Spring的Conditional功能。例如，我们观察JdbcTemplateAutoConfiguration，它的代码如下：\n12345678@Configuration(proxyBeanMethods = false)@ConditionalOnClass(&#123; DataSource.class, JdbcTemplate.class &#125;)@ConditionalOnSingleCandidate(DataSource.class)@AutoConfigureAfter(DataSourceAutoConfiguration.class)@EnableConfigurationProperties(JdbcProperties.class)@Import(&#123; JdbcTemplateConfiguration.class, NamedParameterJdbcTemplateConfiguration.class &#125;)public class JdbcTemplateAutoConfiguration &#123;&#125;\n当满足条件：\n\n@ConditionalOnClass：在classpath中能找到DataSource和JdbcTemplate；\n@ConditionalOnSingleCandidate(DataSource.class)：在当前Bean的定义中能找到唯一的DataSource；\n\n该JdbcTemplateAutoConfiguration就会起作用。实际创建由导入的JdbcTemplateConfiguration完成：\n12345678910111213141516@Configuration(proxyBeanMethods = false)@ConditionalOnMissingBean(JdbcOperations.class)class JdbcTemplateConfiguration &#123;    @Bean    @Primary    JdbcTemplate jdbcTemplate(DataSource dataSource, JdbcProperties properties) &#123;        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);        JdbcProperties.Template template = properties.getTemplate();        jdbcTemplate.setFetchSize(template.getFetchSize());        jdbcTemplate.setMaxRows(template.getMaxRows());        if (template.getQueryTimeout() != null) &#123;            jdbcTemplate.setQueryTimeout((int) template.getQueryTimeout().getSeconds());        &#125;        return jdbcTemplate;    &#125;&#125;\n创建JdbcTemplate之前，要满足@ConditionalOnMissingBean(JdbcOperations.class)，即不存在JdbcOperations的Bean。\n如果我们自己创建了一个JdbcTemplate，例如，在Application中自己写个方法：\n12345678@SpringBootApplicationpublic class Application &#123;    ...    @Bean    JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) &#123;        return new JdbcTemplate(dataSource);    &#125;&#125;\n那么根据条件@ConditionalOnMissingBean(JdbcOperations.class)，Spring Boot就不会再创建一个重复的JdbcTemplate（因为JdbcOperations是JdbcTemplate的父类）。\n可见，Spring Boot自动装配功能是通过自动扫描+条件装配实现的，这一套机制在默认情况下工作得很好，但是，如果我们要手动控制某个Bean的创建，就需要详细地了解Spring Boot自动创建的原理，很多时候还要跟踪XxxAutoConfiguration，以便设定条件使得某个Bean不会被自动创建。\n练习\n使用Spring Boot编写hello应用程序。\n下载练习\n小结\nSpring Boot是一个基于Spring提供了开箱即用的一组套件，它可以让我们基于很少的配置和代码快速搭建出一个完整的应用程序。\nSpring Boot有非常强大的AutoConfiguration功能，它是通过自动扫描+条件装配实现的。\nSpring Boot开发\n我们已经在前面详细介绍了Spring框架，它的主要功能包括IoC容器、AOP支持、事务支持、MVC开发以及强大的第三方集成功能等。\n那么，Spring Boot又是什么？它和Spring是什么关系？\nSpring Boot是一个基于Spring的套件，它帮我们预组装了Spring的一系列组件，以便以尽可能少的代码和配置来开发基于Spring的Java应用程序。\n以汽车为例，如果我们想组装一辆汽车，我们需要发动机、传动、轮胎、底盘、外壳、座椅、内饰等各种部件，然后把它们装配起来。Spring就相当于提供了一系列这样的部件，但是要装好汽车上路，还需要我们自己动手。而Spring Boot则相当于已经帮我们预装好了一辆可以上路的汽车，如果有特殊的要求，例如把发动机从普通款换成涡轮增压款，可以通过修改配置或编写少量代码完成。\n因此，Spring Boot和Spring的关系就是整车和零部件的关系，它们不是取代关系，试图跳过Spring直接学习Spring Boot是不可能的。\nSpring Boot的目标就是提供一个开箱即用的应用程序架构，我们基于Spring Boot的预置结构继续开发，省时省力。\n本章我们将详细介绍如何使用Spring Boot。\n本教程使用的Spring Boot版本是3.x版，如果使用Spring Boot 2.x则需注意，两者有以下不同：\n\n\n\n\nSpring Boot 2.x\nSpring Boot 3.x\n\n\n\n\nSpring版本\nSpring 5.x\nSpring 6.x\n\n\nJDK版本\n&gt;= 1.8\n&gt;= 17\n\n\nTomcat版本\n9.x\n10.x\n\n\nAnnotation包\njavax.annotation\njakarta.annotation\n\n\nServlet包\njavax.servlet\njakarta.servlet\n\n\nJMS包\njavax.jms\njakarta.jms\n\n\nJavaMail包\njavax.mail\njakarta.mail\n\n\n\n如果使用Spring Boot的其他版本，则需要根据需要调整代码。\nSpring Boot的官网入口是这里，建议添加到浏览器收藏夹。\n\n\n加载配置文件\n加载配置文件可以直接使用注解@Value，例如，我们定义了一个最大允许上传的文件大小配置：\n123storage:  local:    max-size: 102400\n在某个FileUploader里，需要获取该配置，可使用@Value注入：\n1234567@Componentpublic class FileUploader &#123;    @Value(&quot;$&#123;storage.local.max-size:102400&#125;&quot;)    int maxSize;    ...&#125;\n在另一个UploadFilter中，因为要检查文件的MD5，同时也要检查输入流的大小，因此，也需要该配置：\n1234567@Componentpublic class UploadFilter implements Filter &#123;    @Value(&quot;$&#123;storage.local.max-size:100000&#125;&quot;)    int maxSize;    ...&#125;\n多次引用同一个@Value不但麻烦，而且@Value使用字符串，缺少编译器检查，容易造成多处引用不一致（例如，UploadFilter把缺省值误写为100000）。\n为了更好地管理配置，Spring Boot允许创建一个Bean，持有一组配置，并由Spring Boot自动注入。\n假设我们在application.yml中添加了如下配置：\n12345678910storage:  local:    # 文件存储根目录:    root-dir: $&#123;STORAGE_LOCAL_ROOT:/var/storage&#125;    # 最大文件大小，默认100K:    max-size: $&#123;STORAGE_LOCAL_MAX_SIZE:102400&#125;    # 是否允许空文件:    allow-empty: false    # 允许的文件类型:    allow-types: jpg, png, gif\n可以首先定义一个Java Bean，持有该组配置：\n123456789public class StorageConfiguration &#123;    private String rootDir;    private int maxSize;    private boolean allowEmpty;    private List&lt;String&gt; allowTypes;    // TODO: getters and setters&#125;\n保证Java Bean的属性名称与配置一致即可。然后，我们添加两个注解：\n12345@Configuration@ConfigurationProperties(&quot;storage.local&quot;)public class StorageConfiguration &#123;    ...&#125;\n注意到@ConfigurationProperties(&quot;storage.local&quot;)表示将从配置项storage.local读取该项的所有子项配置，并且，@Configuration表示StorageConfiguration也是一个Spring管理的Bean，可直接注入到其他Bean中：\n1234567891011121314@Componentpublic class StorageService &#123;    final Logger logger = LoggerFactory.getLogger(getClass());    @Autowired    StorageConfiguration storageConfig;    @PostConstruct    public void init() &#123;        logger.info(&quot;Load configuration: root-dir = &#123;&#125;&quot;, storageConfig.getRootDir());        logger.info(&quot;Load configuration: max-size = &#123;&#125;&quot;, storageConfig.getMaxSize());        logger.info(&quot;Load configuration: allowed-types = &#123;&#125;&quot;, storageConfig.getAllowTypes());    &#125;&#125;\n这样一来，引入storage.local的相关配置就很容易了，因为只需要注入StorageConfiguration这个Bean，这样可以由编译器检查类型，无需编写重复的@Value注解。\n练习\n用Spring Boot加载配置文件。\n下载练习\n小结\nSpring Boot提供了@ConfigurationProperties注解，可以非常方便地把一段配置加载到一个Bean中。\n\n\nSpring Boot大量使用自动配置和默认配置，极大地减少了代码，通常只需要加上几个注解，并按照默认规则设定一下必要的配置即可。例如，配置JDBC，默认情况下，只需要配置一个spring.datasource：\n123456spring:  datasource:    url: jdbc:hsqldb:file:testdb    username: sa    password:    dirver-class-name: org.hsqldb.jdbc.JDBCDriver\nSpring Boot就会自动创建出DataSource、JdbcTemplate、DataSourceTransactionManager，非常方便。\n但是，有时候，我们又必须要禁用某些自动配置。例如，系统有主从两个数据库，而Spring Boot的自动配置只能配一个，怎么办？\n这个时候，针对DataSource相关的自动配置，就必须关掉。我们需要用exclude指定需要关掉的自动配置：\n123456@SpringBootApplication// 启动自动配置，但排除指定的自动配置:@EnableAutoConfiguration(exclude = DataSourceAutoConfiguration.class)public class Application &#123;    ...&#125;\n现在，Spring Boot不再给我们自动创建DataSource、JdbcTemplate和DataSourceTransactionManager了，要实现主从数据库支持，怎么办？\n让我们一步一步开始编写支持主从数据库的功能。首先，我们需要把主从数据库配置写到application.yml中，仍然按照Spring Boot默认的格式写，但datasource改为datasource-master和datasource-slave：\n1234567891011spring:  datasource-master:    url: jdbc:hsqldb:file:testdb    username: sa    password:    dirver-class-name: org.hsqldb.jdbc.JDBCDriver  datasource-slave:    url: jdbc:hsqldb:file:testdb    username: sa    password:    dirver-class-name: org.hsqldb.jdbc.JDBCDriver\n注意到两个数据库实际上是同一个库。如果使用MySQL，可以创建一个只读用户，作为datasource-slave的用户来模拟一个从库。\n下一步，我们分别创建两个HikariCP的DataSource：\n12345678910111213141516171819202122232425public class MasterDataSourceConfiguration &#123;    @Bean(&quot;masterDataSourceProperties&quot;)    @ConfigurationProperties(&quot;spring.datasource-master&quot;)    DataSourceProperties dataSourceProperties() &#123;        return new DataSourceProperties();    &#125;    @Bean(&quot;masterDataSource&quot;)    DataSource dataSource(@Autowired @Qualifier(&quot;masterDataSourceProperties&quot;) DataSourceProperties props) &#123;        return props.initializeDataSourceBuilder().build();    &#125;&#125;public class SlaveDataSourceConfiguration &#123;    @Bean(&quot;slaveDataSourceProperties&quot;)    @ConfigurationProperties(&quot;spring.datasource-slave&quot;)    DataSourceProperties dataSourceProperties() &#123;        return new DataSourceProperties();    &#125;    @Bean(&quot;slaveDataSource&quot;)    DataSource dataSource(@Autowired @Qualifier(&quot;slaveDataSourceProperties&quot;) DataSourceProperties props) &#123;        return props.initializeDataSourceBuilder().build();    &#125;&#125;\n注意到上述class并未添加@Configuration和@Component，要使之生效，可以使用@Import导入：\n123456@SpringBootApplication@EnableAutoConfiguration(exclude = DataSourceAutoConfiguration.class)@Import(&#123; MasterDataSourceConfiguration.class, SlaveDataSourceConfiguration.class&#125;)public class Application &#123;    ...&#125;\n此外，上述两个DataSource的Bean名称分别为masterDataSource和slaveDataSource，我们还需要一个最终的@Primary标注的DataSource，它采用Spring提供的AbstractRoutingDataSource，代码实现如下：\n1234567class RoutingDataSource extends AbstractRoutingDataSource &#123;    @Override    protected Object determineCurrentLookupKey() &#123;        // 从ThreadLocal中取出key:        return RoutingDataSourceContext.getDataSourceRoutingKey();    &#125;&#125;\nRoutingDataSource本身并不是真正的DataSource，它通过Map关联一组DataSource，下面的代码创建了包含两个DataSource的RoutingDataSource，关联的key分别为masterDataSource和slaveDataSource：\n1234567891011121314151617181920212223242526public class RoutingDataSourceConfiguration &#123;    @Primary    @Bean    DataSource dataSource(            @Autowired @Qualifier(&quot;masterDataSource&quot;) DataSource masterDataSource,            @Autowired @Qualifier(&quot;slaveDataSource&quot;) DataSource slaveDataSource) &#123;        var ds = new RoutingDataSource();        // 关联两个DataSource:        ds.setTargetDataSources(Map.of(                &quot;masterDataSource&quot;, masterDataSource,                &quot;slaveDataSource&quot;, slaveDataSource));        // 默认使用masterDataSource:        ds.setDefaultTargetDataSource(masterDataSource);        return ds;    &#125;    @Bean    JdbcTemplate jdbcTemplate(@Autowired DataSource dataSource) &#123;        return new JdbcTemplate(dataSource);    &#125;    @Bean    DataSourceTransactionManager dataSourceTransactionManager(@Autowired DataSource dataSource) &#123;        return new DataSourceTransactionManager(dataSource);    &#125;&#125;\n仍然需要自己创建JdbcTemplate和PlatformTransactionManager，注入的是标记为@Primary的RoutingDataSource。\n这样，我们通过如下的代码就可以切换RoutingDataSource底层使用的真正的DataSource：\n12RoutingDataSourceContext.setDataSourceRoutingKey(&quot;slaveDataSource&quot;);jdbcTemplate.query(...);\n只不过写代码切换DataSource即麻烦又容易出错，更好的方式是通过注解配合AOP实现自动切换，这样，客户端代码实现如下：\n12345678@Controllerpublic class UserController &#123;\t@RoutingWithSlave // &lt;-- 指示在此方法中使用slave数据库\t@GetMapping(&quot;/profile&quot;)\tpublic ModelAndView profile(HttpSession session) &#123;        ...    &#125;&#125;\n实现上述功能需要编写一个@RoutingWithSlave注解，一个AOP织入和一个ThreadLocal来保存key。由于代码比较简单，这里我们不再详述。\n如果我们想要确认是否真的切换了DataSource，可以覆写determineTargetDataSource()方法并打印出DataSource的名称：\n12345678910class RoutingDataSource extends AbstractRoutingDataSource &#123;    ...    @Override    protected DataSource determineTargetDataSource() &#123;        DataSource ds = super.determineTargetDataSource();        logger.info(&quot;determin target datasource: &#123;&#125;&quot;, ds);        return ds;    &#125;&#125;\n访问不同的URL，可以在日志中看到两个DataSource，分别是HikariPool-1和hikariPool-2：\n122020-06-14 17:55:21.676  INFO 91561 --- [nio-8080-exec-7] c.i.learnjava.config.RoutingDataSource   : determin target datasource: HikariDataSource (HikariPool-1)2020-06-14 17:57:08.992  INFO 91561 --- [io-8080-exec-10] c.i.learnjava.config.RoutingDataSource   : determin target datasource: HikariDataSource (HikariPool-2)\n我们用一个图来表示创建的DataSource以及相关Bean的关系：\n12345678910┌────────────────────┐       ┌──────────────────┐│@Primary            │&lt;──────│   JdbcTemplate   ││RoutingDataSource   │       └──────────────────┘│ ┌────────────────┐ │       ┌──────────────────┐│ │MasterDataSource│ │&lt;──────│DataSource        ││ └────────────────┘ │       │TransactionManager││ ┌────────────────┐ │       └──────────────────┘│ │SlaveDataSource │ ││ └────────────────┘ │└────────────────────┘\n注意到DataSourceTransactionManager和JdbcTemplate引用的都是RoutingDataSource，所以，这种设计的一个限制就是：在一个请求中，一旦切换了内部数据源，在同一个事务中，不能再切到另一个，否则，DataSourceTransactionManager和JdbcTemplate操作的就不是同一个数据库连接。\n练习\n禁用DataSourceAutoConfiguration并配置多数据源。\n下载练习\n小结\n可以通过@EnableAutoConfiguration(exclude = &#123;...&#125;)指定禁用的自动配置；\n可以通过@Import(&#123;...&#125;)导入自定义配置。\n添加Filter\n我们在Spring中已经学过了集成Filter，本质上就是通过代理，把Spring管理的Bean注册到Servlet容器中，不过步骤比较繁琐，需要配置web.xml。\n在Spring Boot中，添加一个Filter更简单了，可以做到零配置。我们来看看在Spring Boot中如何添加Filter。\nSpring Boot会自动扫描所有的FilterRegistrationBean类型的Bean，然后，将它们返回的Filter自动注册到Servlet容器中，无需任何配置。\n我们还是以AuthFilter为例，首先编写一个AuthFilterRegistrationBean，它继承自FilterRegistrationBean：\n123456789101112131415@Componentpublic class AuthFilterRegistrationBean extends FilterRegistrationBean&lt;Filter&gt; &#123;    @Autowired    UserService userService;    @Override    public Filter getFilter() &#123;        setOrder(10);        return new AuthFilter();    &#125;    class AuthFilter implements Filter &#123;        ...    &#125;&#125;\nFilterRegistrationBean本身不是Filter，它实际上是Filter的工厂。Spring Boot会调用getFilter()，把返回的Filter注册到Servlet容器中。因为我们可以在FilterRegistrationBean中注入需要的资源，然后，在返回的AuthFilter中，这个内部类可以引用外部类的所有字段，自然也包括注入的UserService，所以，整个过程完全基于Spring的IoC容器完成。\n再注意到AuthFilterRegistrationBean使用了setOrder(10)，因为Spring Boot支持给多个Filter排序，数字小的在前面，所以，多个Filter的顺序是可以固定的。\n我们再编写一个ApiFilter，专门过滤/api/*这样的URL。首先编写一个ApiFilterRegistrationBean\n12345678910111213@Componentpublic class ApiFilterRegistrationBean extends FilterRegistrationBean&lt;Filter&gt; &#123;    @PostConstruct    public void init() &#123;        setOrder(20);        setFilter(new ApiFilter());        setUrlPatterns(List.of(&quot;/api/*&quot;));    &#125;    class ApiFilter implements Filter &#123;        ...    &#125;&#125;\n这个ApiFilterRegistrationBean和AuthFilterRegistrationBean又有所不同。因为我们要过滤URL，而不是针对所有URL生效，因此，在@PostConstruct方法中，通过setFilter()设置一个Filter实例后，再调用setUrlPatterns()传入要过滤的URL列表。\n练习\n在Spring Boot中添加Filter并指定顺序。\n下载练习\n小结\n在Spring Boot中添加Filter更加方便，并且支持对多个Filter进行排序。\n\n\n和Spring相比，使用Spring Boot通过自动配置来集成第三方组件通常来说更简单。\n我们将详细介绍如何通过Spring Boot集成常用的第三方组件，包括：\n\nOpen API\nRedis\nArtemis\nRabbitMQ\nKafka\n\n\nOpen API是一个标准，它的主要作用是描述REST API，既可以作为文档给开发者阅读，又可以让机器根据这个文档自动生成客户端代码等。\n在Spring Boot应用中，假设我们编写了一堆REST API，如何添加Open API的支持？\n我们只需要在pom.xml中加入以下依赖：\n\norg.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.0\n\n然后呢？没有然后了，直接启动应用，打开浏览器输入http://localhost:8080/swagger-ui.html：\n\n立刻可以看到自动生成的API文档，这里列出了3个API，来自api-controller（因为定义在ApiController这个类中），点击某个API还可以交互，即输入API参数，点“Try it out”按钮，获得运行结果。\n是不是太方便了！\n因为我们引入springdoc-openapi-ui这个依赖后，它自动引入Swagger UI用来创建API文档。可以给API加入一些描述信息，例如：\n1234567891011@RestController@RequestMapping(&quot;/api&quot;)public class ApiController &#123;    ...    @Operation(summary = &quot;Get specific user object by it&#x27;s id.&quot;)\t@GetMapping(&quot;/users/&#123;id&#125;&quot;)\tpublic User user(@Parameter(description = &quot;id of the user.&quot;) @PathVariable(&quot;id&quot;) long id) &#123;\t\treturn userService.getUserById(id);\t&#125;    ...&#125;\n@Operation可以对API进行描述，@Parameter可以对参数进行描述，它们的目的是用于生成API文档的描述信息。添加了描述的API文档如下：\n\n大多数情况下，不需要任何配置，我们就直接得到了一个运行时动态生成的可交互的API文档，该API文档总是和代码保持同步，大大简化了文档的编写工作。\n要自定义文档的样式、控制某些API显示等，请参考springdoc文档。\n配置反向代理\n如果在服务器上，用户访问的域名是https://example.com，但内部是通过类似Nginx这样的反向代理访问实际的Spring Boot应用，比如http://localhost:8080，这个时候，在页面https://example.com/swagger-ui.html上，显示的URL仍然是http://localhost:8080，这样一来，就无法直接在页面执行API，非常不方便。\n这是因为Spring Boot内置的Tomcat默认获取的服务器名称是localhost，端口是实际监听端口，而不是对外暴露的域名和80或443端口。要让Tomcat获取到对外暴露的域名等信息，必须在Nginx配置中传入必要的HTTP Header，常用的配置如下：\n123456789101112# Nginx配置server &#123;    ...    location / &#123;        proxy_pass http://localhost:8080;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-Proto $scheme;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    &#125;    ...&#125;\n然后，在Spring Boot的application.yml中，加入如下配置：\n12345server:  # 实际监听端口:  port: 8080  # 从反向代理读取相关的HTTP Header:  forward-headers-strategy: native\n重启Spring Boot应用，即可在Swagger中显示正确的URL。\n练习\n利用springdoc实现API文档。\n下载练习\n小结\n使用springdoc让其自动创建API文档非常容易，引入依赖后无需任何配置即可访问交互式API文档。\n可以对API添加注解以便生成更详细的描述。\n在Spring Boot中，要访问Redis，可以直接引入spring-boot-starter-data-redis依赖，它实际上是Spring Data的一个子项目——Spring Data Redis，主要用到了这几个组件：\n\nLettuce：一个基于Netty的高性能Redis客户端；\nRedisTemplate：一个类似于JdbcTemplate的接口，用于简化Redis的操作。\n\n因为Spring Data Redis引入的依赖项很多，如果只是为了使用Redis，完全可以只引入Lettuce，剩下的操作都自己来完成。\n本节我们稍微深入一下Redis的客户端，看看怎么一步一步把一个第三方组件引入到Spring Boot中。\n首先，我们添加必要的几个依赖项：\n\nio.lettuce:lettuce-core\norg.apache.commons:commons-pool2\n\n注意我们并未指定版本号，因为在spring-boot-starter-parent中已经把常用组件的版本号确定下来了。\n第一步是在配置文件application.yml中添加Redis的相关配置：\n1234567spring:  redis:    host: $&#123;REDIS_HOST:localhost&#125;    port: $&#123;REDIS_PORT:6379&#125;    password: $&#123;REDIS_PASSWORD:&#125;    ssl: $&#123;REDIS_SSL:false&#125;    database: $&#123;REDIS_DATABASE:0&#125;\n然后，通过RedisConfiguration来加载它：\n123456789@ConfigurationProperties(&quot;spring.redis&quot;)public class RedisConfiguration &#123;\tprivate String host;\tprivate int port;\tprivate String password;\tprivate int database;    // getters and setters...&#125;\n再编写一个@Bean方法来创建RedisClient，可以直接放在RedisConfiguration中：\n12345678910111213@ConfigurationProperties(&quot;spring.redis&quot;)public class RedisConfiguration &#123;    ...    @Bean    RedisClient redisClient() &#123;        RedisURI uri = RedisURI.Builder.redis(this.host, this.port)                .withPassword(this.password)                .withDatabase(this.database)                .build();        return RedisClient.create(uri);    &#125;&#125;\n在启动入口引入该配置：\n12345@SpringBootApplication@Import(RedisConfiguration.class) // 加载Redis配置public class Application &#123;    ...&#125;\n注意：如果在RedisConfiguration中标注@Configuration，则可通过Spring Boot的自动扫描机制自动加载，否则，使用@Import手动加载。\n紧接着，我们用一个RedisService来封装所有的Redis操作。基础代码如下：\n1234567891011121314151617181920212223@Componentpublic class RedisService &#123;    @Autowired    RedisClient redisClient;    GenericObjectPool&lt;StatefulRedisConnection&lt;String, String&gt;&gt; redisConnectionPool;    @PostConstruct    public void init() &#123;        GenericObjectPoolConfig&lt;StatefulRedisConnection&lt;String, String&gt;&gt; poolConfig = new GenericObjectPoolConfig&lt;&gt;();        poolConfig.setMaxTotal(20);        poolConfig.setMaxIdle(5);        poolConfig.setTestOnReturn(true);        poolConfig.setTestWhileIdle(true);        this.redisConnectionPool = ConnectionPoolSupport.createGenericObjectPool(() -&gt; redisClient.connect(), poolConfig);    &#125;    @PreDestroy    public void shutdown() &#123;        this.redisConnectionPool.close();        this.redisClient.shutdown();    &#125;&#125;\n注意到上述代码引入了Commons Pool的一个对象池，用于缓存Redis连接。因为Lettuce本身是基于Netty的异步驱动，在异步访问时并不需要创建连接池，但基于Servlet模型的同步访问时，连接池是有必要的。连接池在@PostConstruct方法中初始化，在@PreDestroy方法中关闭。\n下一步，是在RedisService中添加Redis访问方法。为了简化代码，我们仿照JdbcTemplate.execute(ConnectionCallback)方法，传入回调函数，可大幅减少样板代码。\n首先定义回调函数接口SyncCommandCallback：\n12345@FunctionalInterfacepublic interface SyncCommandCallback&lt;T&gt; &#123;    // 在此操作Redis:    T doInConnection(RedisCommands&lt;String, String&gt; commands);&#125;\n编写executeSync方法，在该方法中，获取Redis连接，利用callback操作Redis，最后释放连接，并返回操作结果：\n12345678910public &lt;T&gt; T executeSync(SyncCommandCallback&lt;T&gt; callback) &#123;    try (StatefulRedisConnection&lt;String, String&gt; connection = redisConnectionPool.borrowObject()) &#123;        connection.setAutoFlushCommands(true);        RedisCommands&lt;String, String&gt; commands = connection.sync();        return callback.doInConnection(commands);    &#125; catch (Exception e) &#123;        logger.warn(&quot;executeSync redis failed.&quot;, e);        throw new RuntimeException(e);    &#125;&#125;\n有的童鞋觉得这样访问Redis的代码太复杂了，实际上我们可以针对常用操作把它封装一下，例如set和get命令：\n1234567public String set(String key, String value) &#123;    return executeSync(commands -&gt; commands.set(key, value));&#125;public String get(String key) &#123;    return executeSync(commands -&gt; commands.get(key));&#125;\n类似的，hget和hset操作如下：\n1234567891011public boolean hset(String key, String field, String value) &#123;    return executeSync(commands -&gt; commands.hset(key, field, value));&#125;public String hget(String key, String field) &#123;    return executeSync(commands -&gt; commands.hget(key, field));&#125;public Map&lt;String, String&gt; hgetall(String key) &#123;    return executeSync(commands -&gt; commands.hgetall(key));&#125;\n常用命令可以提供方法接口，如果要执行任意复杂的操作，就可以通过executeSync(SyncCommandCallback&lt;T&gt;)来完成。\n完成了RedisService后，我们就可以使用Redis了。例如，在UserController中，我们在Session中只存放登录用户的ID，用户信息存放到Redis，提供两个方法用于读写：\n1234567891011121314151617181920212223242526@Controllerpublic class UserController &#123;    public static final String KEY_USER_ID = &quot;__userid__&quot;;    public static final String KEY_USERS = &quot;__users__&quot;;    @Autowired ObjectMapper objectMapper;    @Autowired RedisService redisService;    // 把User写入Redis:    private void putUserIntoRedis(User user) throws Exception &#123;        redisService.hset(KEY_USERS, user.getId().toString(), objectMapper.writeValueAsString(user));    &#125;    // 从Redis读取User:    private User getUserFromRedis(HttpSession session) throws Exception &#123;        Long id = (Long) session.getAttribute(KEY_USER_ID);        if (id != null) &#123;            String s = redisService.hget(KEY_USERS, id.toString());            if (s != null) &#123;                return objectMapper.readValue(s, User.class);            &#125;        &#125;        return null;    &#125;    ...&#125;\n用户登录成功后，把ID放入Session，把User实例放入Redis：\n1234567891011@PostMapping(&quot;/signin&quot;)public ModelAndView doSignin(@RequestParam(&quot;email&quot;) String email, @RequestParam(&quot;password&quot;) String password, HttpSession session) throws Exception &#123;    try &#123;        User user = userService.signin(email, password);        session.setAttribute(KEY_USER_ID, user.getId());        putUserIntoRedis(user);    &#125; catch (RuntimeException e) &#123;        return new ModelAndView(&quot;signin.html&quot;, Map.of(&quot;email&quot;, email, &quot;error&quot;, &quot;Signin failed&quot;));    &#125;    return new ModelAndView(&quot;redirect:/profile&quot;);&#125;\n需要获取User时，从Redis取出：\n12345678@GetMapping(&quot;/profile&quot;)public ModelAndView profile(HttpSession session) throws Exception &#123;    User user = getUserFromRedis(session);    if (user == null) &#123;        return new ModelAndView(&quot;redirect:/signin&quot;);    &#125;    return new ModelAndView(&quot;profile.html&quot;, Map.of(&quot;user&quot;, user));&#125;\n从Redis读写Java对象时，序列化和反序列化是应用程序的工作，上述代码使用JSON作为序列化方案，简单可靠。也可将相关序列化操作封装到RedisService中，这样可以提供更加通用的方法：\n1234567public &lt;T&gt; T get(String key, Class&lt;T&gt; clazz) &#123;    ...&#125;public &lt;T&gt; T set(String key, T value) &#123;    ...&#125;\n练习\n在Spring Boot中访问Redis。\n下载练习\n小结\nSpring Boot默认使用Lettuce作为Redis客户端，同步使用时，应通过连接池提高效率。\n集成Artemis\nActiveMQ Artemis是一个JMS服务器，在集成JMS一节中我们已经详细讨论了如何在Spring中集成Artemis，本节我们讨论如何在Spring Boot中集成Artemis。\n我们还是以实际工程为例，创建一个springboot-jms工程，引入的依赖除了spring-boot-starter-web，spring-boot-starter-jdbc等以外，新增spring-boot-starter-artemis：\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-artemis&lt;/artifactId&gt;&lt;/dependency&gt;\n同样无需指定版本号。\n如何创建Artemis服务器我们已经在集成JMS一节中详细讲述了，此处不再重复。创建Artemis服务器后，我们在application.yml中加入相关配置：\n12345678910spring:  artemis:    # 指定连接外部Artemis服务器，而不是启动嵌入式服务:    mode: native    # 服务器地址和端口号:    host: 127.0.0.1    port: 61616    # 连接用户名和口令由创建Artemis服务器时指定:    user: admin    password: password\n和Spring版本的JMS代码相比，使用Spring Boot集成JMS时，只要引入了spring-boot-starter-artemis，Spring Boot会自动创建JMS相关的ConnectionFactory、JmsListenerContainerFactory、JmsTemplate等，无需我们再手动配置了。\n发送消息时只需要引入JmsTemplate：\n1234567891011121314@Componentpublic class MessagingService &#123;    @Autowired    JmsTemplate jmsTemplate;    public void sendMailMessage() throws Exception &#123;        String text = &quot;...&quot;;        jmsTemplate.send(&quot;jms/queue/mail&quot;, new MessageCreator() &#123;            public Message createMessage(Session session) throws JMSException &#123;                return session.createTextMessage(text);            &#125;        &#125;);    &#125;&#125;\n接收消息时只需要标注@JmsListener：\n123456789@Componentpublic class MailMessageListener &#123;    final Logger logger = LoggerFactory.getLogger(getClass());    @JmsListener(destination = &quot;jms/queue/mail&quot;, concurrency = &quot;10&quot;)    public void onMailMessageReceived(Message message) throws Exception &#123;        logger.info(&quot;received message: &quot; + message);    &#125;&#125;\n可见，应用程序收发消息的逻辑和Spring中使用JMS完全相同，只是通过Spring Boot，我们把工程简化到只需要设定Artemis相关配置。\n练习\n在Spring Boot中使用Artemis。\n下载练习\n小结\n在Spring Boot中使用Artemis作为JMS服务时，只需引入spring-boot-starter-artemis依赖，即可直接使用JMS。\n\n\n前面我们讲了ActiveMQ Artemis，它实现了JMS的消息服务协议。JMS是JavaEE的消息服务标准接口，但是，如果Java程序要和另一种语言编写的程序通过消息服务器进行通信，那么JMS就不太适合了。\nAMQP是一种使用广泛的独立于语言的消息协议，它的全称是Advanced Message Queuing Protocol，即高级消息队列协议，它定义了一种二进制格式的消息流，任何编程语言都可以实现该协议。实际上，Artemis也支持AMQP，但实际应用最广泛的AMQP服务器是使用Erlang编写的RabbitMQ。\n安装RabbitMQ\n我们先从RabbitMQ的官网下载并安装RabbitMQ，安装和启动RabbitMQ请参考官方文档。要验证启动是否成功，可以访问RabbitMQ的管理后台http://localhost:15672，如能看到登录界面表示RabbitMQ启动成功：\n\nRabbitMQ后台管理的默认用户名和口令均为guest。\nAMQP协议\nAMQP协议和前面我们介绍的JMS协议有所不同。在JMS中，有两种类型的消息通道：\n\n点对点的Queue，即Producer发送消息到指定的Queue，接收方从Queue收取消息；\n一对多的Topic，即Producer发送消息到指定的Topic，任意多个在线的接收方均可从Topic获得一份完整的消息副本。\n\n但是AMQP协议比JMS要复杂一点，它只有Queue，没有Topic，并且引入了Exchange的概念。当Producer想要发送消息的时候，它将消息发送给Exchange，由Exchange将消息根据各种规则投递到一个或多个Queue：\n1234567891011                                    ┌───────┐                                ┌──▶│Queue-1│                  ┌──────────┐  │   └───────┘              ┌──▶│Exchange-1│──┤┌──────────┐  │   └──────────┘  │   ┌───────┐│Producer-1│──┤                 ├──▶│Queue-2│└──────────┘  │   ┌──────────┐  │   └───────┘              └──▶│Exchange-2│──┤                  └──────────┘  │   ┌───────┐                                └──▶│Queue-3│                                    └───────┘\n如果某个Exchange总是把消息发送到固定的Queue，那么这个消息通道就相当于JMS的Queue。如果某个Exchange把消息发送到多个Queue，那么这个消息通道就相当于JMS的Topic。和JMS的Topic相比，Exchange的投递规则更灵活，比如一个“登录成功”的消息被投递到Queue-1和Queue-2，而“登录失败”的消息则被投递到Queue-3。这些路由规则称之为Binding，通常都在RabbitMQ的管理后台设置。\n我们以具体的业务为例子，在RabbitMQ中，首先创建3个Queue，分别用于发送邮件、短信和App通知：\n\n创建Queue时注意到可配置为持久化（Durable）和非持久化（Transient），当Consumer不在线时，持久化的Queue会暂存消息，非持久化的Queue会丢弃消息。\n紧接着，我们在Exchanges中创建一个Direct类型的Exchange，命名为registration，并添加如下两个Binding：\n\n上述Binding的规则就是：凡是发送到registration这个Exchange的消息，均被发送到q_mail和q_sms这两个Queue。\n我们再创建一个Direct类型的Exchange，命名为login，并添加如下Binding：\n\n上述Binding的规则稍微复杂一点，当发送消息给login这个Exchange时，如果消息没有指定Routing Key，则被投递到q_app和q_mail，如果消息指定了Routing Key=“login_failed”，那么消息被投递到q_sms。\n配置好RabbitMQ后，我们就可以基于Spring Boot开发AMQP程序。\n使用RabbitMQ\n我们首先创建Spring Boot工程springboot-rabbitmq，并添加如下依赖引入RabbitMQ：\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;\n然后在application.yml中添加RabbitMQ相关配置：\n123456spring:  rabbitmq:    host: localhost    port: 5672    username: guest    password: guest\n我们还需要在Application中添加一个MessageConverter：\n1234567891011import org.springframework.amqp.support.converter.MessageConverter;@SpringBootApplicationpublic class Application &#123;    ...    @Bean    MessageConverter createMessageConverter() &#123;        return new Jackson2JsonMessageConverter();    &#125;&#125;\nMessageConverter用于将Java对象转换为RabbitMQ的消息。默认情况下，Spring Boot使用SimpleMessageConverter，只能发送String和byte[]类型的消息，不太方便。使用Jackson2JsonMessageConverter，我们就可以发送JavaBean对象，由Spring Boot自动序列化为JSON并以文本消息传递。\n因为引入了starter，所有RabbitMQ相关的Bean均自动装配，我们需要在Producer注入的是RabbitTemplate：\n1234567891011121314@Componentpublic class MessagingService &#123;    @Autowired    RabbitTemplate rabbitTemplate;    public void sendRegistrationMessage(RegistrationMessage msg) &#123;        rabbitTemplate.convertAndSend(&quot;registration&quot;, &quot;&quot;, msg);    &#125;    public void sendLoginMessage(LoginMessage msg) &#123;        String routingKey = msg.success ? &quot;&quot; : &quot;login_failed&quot;;        rabbitTemplate.convertAndSend(&quot;login&quot;, routingKey, msg);    &#125;&#125;\n发送消息时，使用convertAndSend(exchange, routingKey, message)可以指定Exchange、Routing Key以及消息本身。这里传入JavaBean后会自动序列化为JSON文本。上述代码将RegistrationMessage发送到registration，将LoginMessage发送到login，并根据登录是否成功来指定Routing Key。\n接收消息时，需要在消息处理的方法上标注@RabbitListener：\n123456789101112131415161718192021222324252627282930313233@Componentpublic class QueueMessageListener &#123;    final Logger logger = LoggerFactory.getLogger(getClass());    static final String QUEUE_MAIL = &quot;q_mail&quot;;    static final String QUEUE_SMS = &quot;q_sms&quot;;    static final String QUEUE_APP = &quot;q_app&quot;;    @RabbitListener(queues = QUEUE_MAIL)    public void onRegistrationMessageFromMailQueue(RegistrationMessage message) throws Exception &#123;        logger.info(&quot;queue &#123;&#125; received registration message: &#123;&#125;&quot;, QUEUE_MAIL, message);    &#125;    @RabbitListener(queues = QUEUE_SMS)    public void onRegistrationMessageFromSmsQueue(RegistrationMessage message) throws Exception &#123;        logger.info(&quot;queue &#123;&#125; received registration message: &#123;&#125;&quot;, QUEUE_SMS, message);    &#125;    @RabbitListener(queues = QUEUE_MAIL)    public void onLoginMessageFromMailQueue(LoginMessage message) throws Exception &#123;        logger.info(&quot;queue &#123;&#125; received message: &#123;&#125;&quot;, QUEUE_MAIL, message);    &#125;    @RabbitListener(queues = QUEUE_SMS)    public void onLoginMessageFromSmsQueue(LoginMessage message) throws Exception &#123;        logger.info(&quot;queue &#123;&#125; received message: &#123;&#125;&quot;, QUEUE_SMS, message);    &#125;    @RabbitListener(queues = QUEUE_APP)    public void onLoginMessageFromAppQueue(LoginMessage message) throws Exception &#123;        logger.info(&quot;queue &#123;&#125; received message: &#123;&#125;&quot;, QUEUE_APP, message);    &#125;&#125;\n上述代码一共定义了5个Consumer，监听3个Queue。\n启动应用程序，我们注册一个新用户，然后发送一条RegistrationMessage消息。此时，根据registration这个Exchange的设定，我们会在两个Queue收到消息：\n1234... c.i.learnjava.service.UserService        : try register by bob@example.com...... c.i.learnjava.web.UserController         : user registered: bob@example.com... c.i.l.service.QueueMessageListener       : queue q_mail received registration message: [RegistrationMessage: email=bob@example.com, name=Bob, timestamp=1594559871495]... c.i.l.service.QueueMessageListener       : queue q_sms received registration message: [RegistrationMessage: email=bob@example.com, name=Bob, timestamp=1594559871495]\n当我们登录失败时，发送LoginMessage并设定Routing Key为login_failed，此时，只有q_sms会收到消息：\n12... c.i.learnjava.service.UserService        : try login by bob@example.com...... c.i.l.service.QueueMessageListener       : queue q_sms received message: [LoginMessage: email=bob@example.com, name=(unknown), success=false, timestamp=1594559886722]\n登录成功后，发送LoginMessage，此时，q_mail和q_app将收到消息：\n123... c.i.learnjava.service.UserService        : try login by bob@example.com...... c.i.l.service.QueueMessageListener       : queue q_mail received message: [LoginMessage: email=bob@example.com, name=Bob, success=true, timestamp=1594559895251]... c.i.l.service.QueueMessageListener       : queue q_app received message: [LoginMessage: email=bob@example.com, name=Bob, success=true, timestamp=1594559895251]\nRabbitMQ还提供了使用Topic的Exchange（此Topic指消息的标签，并非JMS的Topic概念），可以使用*进行匹配并路由。可见，掌握RabbitMQ的核心是理解其消息的路由规则。\n直接指定一个Queue并投递消息也是可以的，此时指定Routing Key为Queue的名称即可，因为RabbitMQ提供了一个default exchange用于根据Routing Key查找Queue并直接投递消息到指定的Queue。但是要实现一对多的投递就必须自己配置Exchange。\n练习\n在Spring Boot中使用RabbitMQ。\n下载练习\n小结\nSpring Boot提供了AMQP的集成，默认使用RabbitMQ作为AMQP消息服务器。\n使用RabbitMQ发送消息时，理解Exchange如何路由至一个或多个Queue至关重要。\n我们在前面已经介绍了JMS和AMQP，JMS是JavaEE的标准消息接口，Artemis是一个JMS实现产品，AMQP是跨语言的一个标准消息接口，RabbitMQ是一个AMQP实现产品。\nKafka也是一个消息服务器，它的特点一是快，二是有巨大的吞吐量，那么Kafka实现了什么标准消息接口呢？\nKafka没有实现任何标准的消息接口，它自己提供的API就是Kafka的接口。\n\n哥没有实现任何标准，哥自己就是标准。\n—— Kafka\n\nKafka本身是Scala编写的，运行在JVM之上。Producer和Consumer都通过Kafka的客户端使用网络来与之通信。从逻辑上讲，Kafka设计非常简单，它只有一种类似JMS的Topic的消息通道：\n123456789                           ┌──────────┐                       ┌──▶│Consumer-1│                       │   └──────────┘┌────────┐    ┌─────┐  │   ┌──────────┐│Producer│───▶│Topic│──┼──▶│Consumer-2│└────────┘    └─────┘  │   └──────────┘                       │   ┌──────────┐                       └──▶│Consumer-3│                           └──────────┘\n那么Kafka如何支持十万甚至百万的并发呢？答案是分区。Kafka的一个Topic可以有一个至多个Partition，并且可以分布到多台机器上：\n12345678910111213            ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐             Topic            │                   │                ┌───────────┐        ┌──────────┐            │┌─▶│Partition-1│──┐│┌──▶│Consumer-1│             │  └───────────┘  │ │   └──────────┘┌────────┐  ││  ┌───────────┐  │││   ┌──────────┐│Producer│───┼─▶│Partition-2│──┼─┼──▶│Consumer-2│└────────┘  ││  └───────────┘  │││   └──────────┘             │  ┌───────────┐  │ │   ┌──────────┐            │└─▶│Partition-3│──┘│└──▶│Consumer-3│                └───────────┘        └──────────┘            └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘\nKafka只保证在一个Partition内部，消息是有序的，但是，存在多个Partition的情况下，Producer发送的3个消息会依次发送到Partition-1、Partition-2和Partition-3，Consumer从3个Partition接收的消息并不一定是Producer发送的顺序，因此，多个Partition只能保证接收消息大概率按发送时间有序，并不能保证完全按Producer发送的顺序。这一点在使用Kafka作为消息服务器时要特别注意，对发送顺序有严格要求的Topic只能有一个Partition。\nKafka的另一个特点是消息发送和接收都尽量使用批处理，一次处理几十甚至上百条消息，比一次一条效率要高很多。\n最后要注意的是消息的持久性。Kafka总是将消息写入Partition对应的文件，消息保存多久取决于服务器的配置，可以按照时间删除（默认3天），也可以按照文件大小删除，因此，只要Consumer在离线期内的消息还没有被删除，再次上线仍然可以接收到完整的消息流。这一功能实际上是客户端自己实现的，客户端会存储它接收到的最后一个消息的offsetId，再次上线后按上次的offsetId查询。offsetId是Kafka标识某个Partion的每一条消息的递增整数，客户端通常将它存储在ZooKeeper中。\n有了Kafka消息设计的基本概念，我们来看看如何在Spring Boot中使用Kafka。\n安装Kafka\n首先从Kafka官网下载最新版Kafaka，解压后在bin目录找到两个文件：\n\nzookeeper-server-start.sh：启动ZooKeeper（已内置在Kafka中）；\nkafka-server-start.sh：启动Kafka。\n\n先启动ZooKeeper：\n1$ ./zookeeper-server-start.sh ../config/zookeeper.properties \n再启动Kafka：\n1./kafka-server-start.sh ../config/server.properties\n看到如下输出表示启动成功：\n1... INFO [KafkaServer id=0] started (kafka.server.KafkaServer)\n如果要关闭Kafka和ZooKeeper，依次按Ctrl-C退出即可。注意这是在本地开发时使用Kafka的方式，线上Kafka服务推荐使用云服务厂商托管模式（AWS的MSK，阿里云的消息队列Kafka版）。\n使用Kafka\n在Spring Boot中使用Kafka，首先要引入依赖：\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&lt;/dependency&gt;\n注意这个依赖是spring-kafka项目提供的。\n然后，在application.yml中添加Kafka配置：\n1234567spring:  kafka:    bootstrap-servers: localhost:9092    consumer:      auto-offset-reset: latest      max-poll-records: 100      max-partition-fetch-bytes: 1000000\n除了bootstrap-servers必须指定外，consumer相关的配置项均为调优选项。例如，max-poll-records表示一次最多抓取100条消息。配置名称去哪里看？IDE里定义一个KafkaProperties.Consumer的变量：\n1KafkaProperties.Consumer c = null;\n然后按住Ctrl查看源码即可。\n发送消息\nSpring Boot自动为我们创建一个KafkaTemplate用于发送消息。注意到这是一个泛型类，而默认配置总是使用String作为Kafka消息的类型，所以注入KafkaTemplate&lt;String, String&gt;即可：\n1234567891011121314151617181920@Componentpublic class MessagingService &#123;    @Autowired ObjectMapper objectMapper;    @Autowired KafkaTemplate&lt;String, String&gt; kafkaTemplate;    public void sendRegistrationMessage(RegistrationMessage msg) throws IOException &#123;        send(&quot;topic_registration&quot;, msg);    &#125;    public void sendLoginMessage(LoginMessage msg) throws IOException &#123;        send(&quot;topic_login&quot;, msg);    &#125;    private void send(String topic, Object msg) throws IOException &#123;        ProducerRecord&lt;String, String&gt; pr = new ProducerRecord&lt;&gt;(topic, objectMapper.writeValueAsString(msg));        pr.headers().add(&quot;type&quot;, msg.getClass().getName().getBytes(StandardCharsets.UTF_8));        kafkaTemplate.send(pr);    &#125;&#125;\n发送消息时，需指定Topic名称，消息正文。为了发送一个JavaBean，这里我们没有使用MessageConverter来转换JavaBean，而是直接把消息类型作为Header添加到消息中，Header名称为type，值为Class全名。消息正文是序列化的JSON。\n接收消息\n接收消息可以使用@KafkaListener注解：\n1234567891011121314151617181920212223242526272829303132333435@Componentpublic class TopicMessageListener &#123;    private final Logger logger = LoggerFactory.getLogger(getClass());    @Autowired    ObjectMapper objectMapper;    @KafkaListener(topics = &quot;topic_registration&quot;, groupId = &quot;group1&quot;)    public void onRegistrationMessage(@Payload String message, @Header(&quot;type&quot;) String type) throws Exception &#123;        RegistrationMessage msg = objectMapper.readValue(message, getType(type));        logger.info(&quot;received registration message: &#123;&#125;&quot;, msg);    &#125;    @KafkaListener(topics = &quot;topic_login&quot;, groupId = &quot;group1&quot;)    public void onLoginMessage(@Payload String message, @Header(&quot;type&quot;) String type) throws Exception &#123;        LoginMessage msg = objectMapper.readValue(message, getType(type));        logger.info(&quot;received login message: &#123;&#125;&quot;, msg);    &#125;    @KafkaListener(topics = &quot;topic_login&quot;, groupId = &quot;group2&quot;)    public void processLoginMessage(@Payload String message, @Header(&quot;type&quot;) String type) throws Exception &#123;        LoginMessage msg = objectMapper.readValue(message, getType(type));        logger.info(&quot;process login message: &#123;&#125;&quot;, msg);    &#125;    @SuppressWarnings(&quot;unchecked&quot;)    private static &lt;T&gt; Class&lt;T&gt; getType(String type) &#123;        // TODO: use cache:        try &#123;            return (Class&lt;T&gt;) Class.forName(type);        &#125; catch (ClassNotFoundException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n在接收消息的方法中，使用@Payload表示传入的是消息正文，使用@Header可传入消息的指定Header，这里传入@Header(&quot;type&quot;)，就是我们发送消息时指定的Class全名。接收消息时，我们需要根据Class全名来反序列化获得JavaBean。\n上述代码一共定义了3个Listener，其中有两个方法监听的是同一个Topic，但它们的Group ID不同。假设Producer发送的消息流是A、B、C、D，Group ID不同表示这是两个不同的Consumer，它们将分别收取完整的消息流，即各自均收到A、B、C、D。Group ID相同的多个Consumer实际上被视作一个Consumer，即如果有两个Group ID相同的Consumer，那么它们各自收到的很可能是A、C和B、D。\n运行应用程序，注册新用户后，观察日志输出：\n123... c.i.learnjava.service.UserService        : try register by bob@example.com...... c.i.learnjava.web.UserController         : user registered: bob@example.com... c.i.l.service.TopicMessageListener       : received registration message: [RegistrationMessage: email=bob@example.com, name=Bob, timestamp=1594637517458]\n用户登录后，观察日志输出：\n123... c.i.learnjava.service.UserService        : try login by bob@example.com...... c.i.l.service.TopicMessageListener       : received login message: [LoginMessage: email=bob@example.com, name=Bob, success=true, timestamp=1594637523470]... c.i.l.service.TopicMessageListener       : process login message: [LoginMessage: email=bob@example.com, name=Bob, success=true, timestamp=1594637523470]\n因为Group ID不同，同一个消息被两个Consumer分别独立接收。如果把Group ID改为相同，那么同一个消息只会被两者之一接收。\n有细心的童鞋可能会问，在Kafka中是如何创建Topic的？又如何指定某个Topic的分区数量？\n实际上开发使用的Kafka默认允许自动创建Topic，创建Topic时默认的分区数量是2，可以通过server.properties修改默认分区数量。\n在生产环境中通常会关闭自动创建功能，Topic需要由运维人员先创建好。和RabbitMQ相比，Kafka并不提供网页版管理后台，管理Topic需要使用命令行，比较繁琐，只有云服务商通常会提供更友好的管理后台。\n练习\n在Spring Boot中使用Kafka。\n下载练习\n小结\nSpring Boot通过KafkaTemplate发送消息，通过@KafkaListener接收消息；\n配置Consumer时，指定Group ID非常重要。\n","dateCreated":"2025-05-26T16:48:03+08:00","dateModified":"2025-05-26T16:59:44+08:00","datePublished":"2025-05-26T16:48:03+08:00","description":"","headline":"JAVA-Spring Boot开发","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://chankein.github.io/2025/05/26/java/JAVA-Spring-Boot%E5%BC%80%E5%8F%91/"},"publisher":{"@type":"Organization","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg","logo":{"@type":"ImageObject","url":"profile.jpg"}},"url":"https://chankein.github.io/2025/05/26/java/JAVA-Spring-Boot%E5%BC%80%E5%8F%91/","keywords":"Java, Spring Boot"}</script>
    <meta name="description" content="使用Conditional 使用Profile能根据不同的Profile进行条件装配，但是Profile控制比较糙，如果想要精细控制，例如，配置本地存储，AWS存储和阿里云存储，将来很可能会增加Azure存储等，用Profile就很难实现。 Spring本身提供了条件装配@Conditional，但是要自己编写比较复杂的Condition来做判断，比较麻烦。Spring Boot则为我们准备好了几">
<meta property="og:type" content="blog">
<meta property="og:title" content="JAVA-Spring Boot开发">
<meta property="og:url" content="https://chankein.github.io/2025/05/26/java/JAVA-Spring-Boot%E5%BC%80%E5%8F%91/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:description" content="使用Conditional 使用Profile能根据不同的Profile进行条件装配，但是Profile控制比较糙，如果想要精细控制，例如，配置本地存储，AWS存储和阿里云存储，将来很可能会增加Azure存储等，用Profile就很难实现。 Spring本身提供了条件装配@Conditional，但是要自己编写比较复杂的Condition来做判断，比较麻烦。Spring Boot则为我们准备好了几">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/springboot/integration/boot.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/springboot/integration/open-api/open-api.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/springboot/integration/open-api/open-api-desc.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/springboot/integration/rabbitmq/rabbitmq.jpg">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/springboot/integration/rabbitmq/queue.jpg">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/springboot/integration/rabbitmq/exchange.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/springboot/integration/rabbitmq/exchange2.png">
<meta property="article:published_time" content="2025-05-26T08:48:03.000Z">
<meta property="article:modified_time" content="2025-05-26T08:59:44.055Z">
<meta property="article:author" content="Kein Chan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spring Boot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liaoxuefeng.com/books/java/springboot/integration/boot.png">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../../../#about"
            >
        
        
            <img class="header-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            JAVA-Spring Boot开发
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2025-05-26T16:48:03+08:00">
	
		    2025 年 5 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/">Java</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h2 id="使用Conditional">使用Conditional</h2>
<p>使用Profile能根据不同的Profile进行条件装配，但是Profile控制比较糙，如果想要精细控制，例如，配置本地存储，AWS存储和阿里云存储，将来很可能会增加Azure存储等，用Profile就很难实现。</p>
<p>Spring本身提供了条件装配<code>@Conditional</code>，但是要自己编写比较复杂的<code>Condition</code>来做判断，比较麻烦。Spring Boot则为我们准备好了几个非常有用的条件：</p>
<ul>
<li>@ConditionalOnProperty：如果有指定的配置，条件生效；</li>
<li>@ConditionalOnBean：如果有指定的Bean，条件生效；</li>
<li>@ConditionalOnMissingBean：如果没有指定的Bean，条件生效；</li>
<li>@ConditionalOnMissingClass：如果没有指定的Class，条件生效；</li>
<li>@ConditionalOnWebApplication：在Web环境中条件生效；</li>
<li>@ConditionalOnExpression：根据表达式判断条件是否生效。</li>
</ul>
<p>我们以最常用的<code>@ConditionalOnProperty</code>为例，把上一节的<code>StorageService</code>改写如下。首先，定义配置<code>storage.type=xxx</code>，用来判断条件，默认为<code>local</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">$&#123;STORAGE_TYPE:local&#125;</span></span><br></pre></td></tr></table></figure>
<p>设定为<code>local</code>时，启用<code>LocalStorageService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;storage.type&quot;, havingValue = &quot;local&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalStorageService</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设定为<code>aws</code>时，启用<code>AwsStorageService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;storage.type&quot;, havingValue = &quot;aws&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AwsStorageService</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设定为<code>aliyun</code>时，启用<code>AliyunStorageService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;storage.type&quot;, havingValue = &quot;aliyun&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliyunStorageService</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>LocalStorageService</code>的注解，当指定配置为<code>local</code>，或者配置不存在，均启用<code>LocalStorageService</code>。</p>
<p>可见，Spring Boot提供的条件装配使得应用程序更加具有灵活性。</p>
<h3 id="练习">练习</h3>
<p>使用Spring Boot提供的条件装配。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/conditional/springboot-conditional.zip">下载练习</a></p>
<h3 id="小结">小结</h3>
<p>Spring Boot提供了几个非常有用的条件装配注解，可实现灵活的条件装配。</p>
<hr>
<hr>
<p>Profile本身是Spring提供的功能，我们在<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/ioc/conditional/index.html">使用条件装配</a>中已经讲到了，Profile表示一个环境的概念，如开发、测试和生产这3个环境：</p>
<ul>
<li>native</li>
<li>test</li>
<li>production</li>
</ul>
<p>或者按git分支定义master、dev这些环境：</p>
<ul>
<li>master</li>
<li>dev</li>
</ul>
<p>在启动一个Spring应用程序的时候，可以传入一个或多个环境，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dspring.profiles.active=test,master</span><br></pre></td></tr></table></figure>
<p>大多数情况下，使用一个环境就足够了。</p>
<p>Spring Boot对Profiles的支持在于，可以在<code>application.yml</code>中为每个环境进行配置。下面是一个示例配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">$&#123;APP_NAME:unnamed&#125;</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:hsqldb:file:testdb</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">sa</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="attr">dirver-class-name:</span> <span class="string">org.hsqldb.jdbc.JDBCDriver</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">auto-commit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">connection-timeout:</span> <span class="number">3000</span></span><br><span class="line">      <span class="attr">validation-timeout:</span> <span class="number">3000</span></span><br><span class="line">      <span class="attr">max-lifetime:</span> <span class="number">60000</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">20</span></span><br><span class="line">      <span class="attr">minimum-idle:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pebble:</span></span><br><span class="line">  <span class="attr">suffix:</span></span><br><span class="line">  <span class="attr">cache:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="string">$&#123;APP_PORT:8080&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">production</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pebble:</span></span><br><span class="line">  <span class="attr">cache:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>注意到分隔符<code>---</code>，最前面的配置是默认配置，不需要指定Profile，后面的每段配置都必须以<code>spring.config.activate.on-profile: xxx</code>开头，表示一个Profile。上述配置默认使用8080端口，但是在<code>test</code>环境下，使用<code>8000</code>端口，在<code>production</code>环境下，使用<code>80</code>端口，并且启用Pebble的缓存。</p>
<p>如果我们不指定任何Profile，直接启动应用程序，那么Profile实际上就是<code>default</code>，可以从Spring Boot启动日志看出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">2022-11-25T11:10:34.006+08:00  INFO 13537 --- [           main] com.itranswarp.learnjava.Application     : No active profile set, falling back to 1 default profile: &quot;default&quot;</span><br></pre></td></tr></table></figure>
<p>上述日志显示未设置Profile，使用默认的Profile为<code>default</code>。</p>
<p>要以<code>test</code>环境启动，可输入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ java -Dspring.profiles.active=test -jar springboot-profiles-1.0-SNAPSHOT.jar</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">2022-11-25T11:09:02.946+08:00  INFO 13510 --- [           main] com.itranswarp.learnjava.Application     : The following 1 profile is active: &quot;test&quot;</span><br><span class="line">...</span><br><span class="line">2022-11-25T11:09:05.124+08:00  INFO 13510 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8000 (http) with context path &#x27;&#x27;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>从日志看到活动的Profile是<code>test</code>，Tomcat的监听端口是<code>8000</code>。</p>
<p>通过Profile可以实现一套代码在不同环境启用不同的配置和功能。假设我们需要一个存储服务，在本地开发时，直接使用文件存储即可，但是，在测试和生产环境，需要存储到云端如S3上，如何通过Profile实现该功能？</p>
<p>首先，我们要定义存储接口<code>StorageService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据URI打开InputStream:</span></span><br><span class="line">    InputStream <span class="title function_">openInputStream</span><span class="params">(String uri)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据扩展名+InputStream保存并返回URI:</span></span><br><span class="line">    String <span class="title function_">store</span><span class="params">(String extName, InputStream input)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本地存储可通过<code>LocalStorageService</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Profile(&quot;default&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalStorageService</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;storage.local:/var/static&#125;&quot;)</span></span><br><span class="line">    String localStorageRootDir;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> File localStorageRoot;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Intializing local storage with root dir: &#123;&#125;&quot;</span>, <span class="built_in">this</span>.localStorageRootDir);</span><br><span class="line">        <span class="built_in">this</span>.localStorageRoot = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.localStorageRootDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> InputStream <span class="title function_">openInputStream</span><span class="params">(String uri)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.localStorageRoot, uri);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(targetFile));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">store</span><span class="params">(String extName, InputStream input)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + <span class="string">&quot;.&quot;</span> + extName;</span><br><span class="line">        <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.localStorageRoot, fileName);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(targetFile))) &#123;</span><br><span class="line">            input.transferTo(output);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fileName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而云端存储可通过<code>CloudStorageService</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Profile(&quot;!default&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloudStorageService</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;storage.cloud.bucket:&#125;&quot;)</span></span><br><span class="line">    String bucket;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;storage.cloud.access-key:&#125;&quot;)</span></span><br><span class="line">    String accessKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;storage.cloud.access-secret:&#125;&quot;)</span></span><br><span class="line">    String accessSecret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">        logger.info(<span class="string">&quot;Initializing cloud storage...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> InputStream <span class="title function_">openInputStream</span><span class="params">(String uri)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;File not found: &quot;</span> + uri);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">store</span><span class="params">(String extName, InputStream input)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Unable to access cloud storage.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>LocalStorageService</code>使用了条件装配<code>@Profile(&quot;default&quot;)</code>，即默认启用<code>LocalStorageService</code>，而<code>CloudStorageService</code>使用了条件装配<code>@Profile(&quot;!default&quot;)</code>，即非<code>default</code>环境时，自动启用<code>CloudStorageService</code>。这样，一套代码，就实现了不同环境启用不同的配置。</p>
<h3 id="练习-2">练习</h3>
<p>使用Profile启动Spring Boot应用。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/profiles/springboot-profiles.zip">下载练习</a></p>
<h3 id="小结-2">小结</h3>
<p>Spring Boot允许在一个配置文件中针对不同Profile进行配置；</p>
<p>Spring Boot在未指定Profile时默认为<code>default</code>。</p>
<h2 id="使用Actuator">使用Actuator</h2>
<p>在生产环境中，需要对应用程序的状态进行监控。前面我们已经介绍了使用JMX对Java应用程序包括JVM进行监控，使用JMX需要把一些监控信息以MBean的形式暴露给JMX Server，而Spring Boot已经内置了一个监控功能，它叫Actuator。</p>
<p>使用Actuator非常简单，只需添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后正常启动应用程序，Actuator会把它能收集到的所有信息都暴露给JMX。此外，Actuator还可以通过URL<code>/actuator/</code>挂载一些监控点，例如，输入<code>http://localhost:8080/actuator/health</code>，我们可以查看应用程序当前状态：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UP&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>许多网关作为反向代理需要一个URL来探测后端集群应用是否存活，这个URL就可以提供给网关使用。</p>
<p>Actuator默认把所有访问点暴露给JMX，但处于安全原因，只有<code>health</code>和<code>info</code>会暴露给Web。Actuator提供的所有访问点均在官方文档列出，要暴露更多的访问点给Web，需要在<code>application.yml</code>中加上配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">info,</span> <span class="string">health,</span> <span class="string">beans,</span> <span class="string">env,</span> <span class="string">metrics</span></span><br></pre></td></tr></table></figure>
<p>要特别注意暴露的URL的安全性，例如，<code>/actuator/env</code>可以获取当前机器的所有环境变量，不可暴露给公网。</p>
<h3 id="练习-3">练习</h3>
<p>使用Actuator实现监控。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/actuator/springboot-actuator.zip">下载练习</a></p>
<h3 id="小结-3">小结</h3>
<p>Spring Boot提供了一个Actuator，可以方便地实现监控，并可通过Web访问特定类型的监控。</p>
<hr>
<hr>
<h2 id="打包Spring-Boot应用">打包Spring Boot应用</h2>
<p>我们在Maven的<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/maven/plugin/index.html">使用插件</a>一节中介绍了如何使用<code>maven-shade-plugin</code>打包一个可执行的jar包。在Spring Boot应用中，打包更加简单，因为Spring Boot自带一个更简单的<code>spring-boot-maven-plugin</code>插件用来打包，我们只需要在<code>pom.xml</code>中加入以下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>无需任何配置，Spring Boot的这款插件会自动定位应用程序的入口Class，我们执行以下Maven命令即可打包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn clean package</span><br></pre></td></tr></table></figure>
<p>以<code>springboot-exec-jar</code>项目为例，打包后我们在<code>target</code>目录下可以看到两个jar文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">classes</span><br><span class="line">generated-sources</span><br><span class="line">maven-archiver</span><br><span class="line">maven-status</span><br><span class="line">springboot-exec-jar-1.0-SNAPSHOT.jar</span><br><span class="line">springboot-exec-jar-1.0-SNAPSHOT.jar.original</span><br></pre></td></tr></table></figure>
<p>其中，<code>springboot-exec-jar-1.0-SNAPSHOT.jar.original</code>是Maven标准打包插件打的jar包，它只包含我们自己的Class，不包含依赖，而<code>springboot-exec-jar-1.0-SNAPSHOT.jar</code>是Spring Boot打包插件创建的包含依赖的jar，可以直接运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar springboot-exec-jar-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<p>这样，部署一个Spring Boot应用就非常简单，无需预装任何服务器，只需要上传jar包即可。</p>
<p>在打包的时候，因为打包后的Spring Boot应用不会被修改，因此，默认情况下，<code>spring-boot-devtools</code>这个依赖不会被打包进去。但是要注意，使用早期的Spring Boot版本时，需要配置一下才能排除<code>spring-boot-devtools</code>这个依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludeDevtools</span>&gt;</span>true<span class="tag">&lt;/<span class="name">excludeDevtools</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果不喜欢默认的项目名+版本号作为文件名，可以加一个配置指定文件名：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>awesome-app<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样打包后的文件名就是<code>awesome-app.jar</code>。</p>
<h3 id="练习-4">练习</h3>
<p>使用Spring Boot插件打包可执行jar。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/package/springboot-exec-jar.zip">下载练习</a></p>
<h3 id="小结-4">小结</h3>
<p>Spring Boot提供了一个Maven插件用于打包所有依赖到单一jar文件，此插件十分易用，无需配置。</p>
<hr>
<hr>
<p>在开发阶段，我们经常要修改代码，然后重启Spring Boot应用。经常手动停止再启动，比较麻烦。</p>
<p>Spring Boot提供了一个开发者工具，可以监控classpath路径上的文件。只要源码或配置文件发生修改，Spring Boot应用可以自动重启。在开发阶段，这个功能比较有用。</p>
<p>要使用这一开发者功能，我们只需添加如下依赖到<code>pom.xml</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后，没有然后了。直接启动应用程序，然后试着修改源码，保存，观察日志输出，Spring Boot会自动重新加载。</p>
<p>默认配置下，针对<code>/static</code>、<code>/public</code>和<code>/templates</code>目录中的文件修改，不会自动重启，因为禁用缓存后，这些文件的修改可以实时更新。</p>
<h3 id="练习-5">练习</h3>
<p>使用devtools检测修改并自动重启。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/devtools/springboot-devtools.zip">下载练习</a></p>
<h3 id="小结-5">小结</h3>
<p>Spring Boot提供了一个开发阶段非常有用的<code>spring-boot-devtools</code>，能自动检测classpath路径上文件修改并自动重启。</p>
<p>要了解Spring Boot，我们先来编写第一个Spring Boot应用程序，看看与前面我们编写的Spring应用程序有何异同。</p>
<p>我们新建一个<code>springboot-hello</code>的工程，创建标准的Maven目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">springboot-hello</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   └── main</span><br><span class="line">│       ├── java</span><br><span class="line">│       └── resources</span><br><span class="line">│           ├── application.yml</span><br><span class="line">│           ├── logback-spring.xml</span><br><span class="line">│           ├── static</span><br><span class="line">│           └── templates</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure>
<p>其中，在<code>src/main/resources</code>目录下，注意到几个文件：</p>
<h3 id="application-yml">application.yml</h3>
<p>这是Spring Boot默认的配置文件，它采用<a target="_blank" rel="noopener" href="https://yaml.org/">YAML</a>格式而不是<code>.properties</code>格式，文件名必须是<code>application.yml</code>而不是其他名称。</p>
<p>YAML格式比<code>key=value</code>格式的<code>.properties</code>文件更易读。比较一下两者的写法：</p>
<p>使用<code>.properties</code>格式：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">$&#123;APP_NAME:unnamed&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:hsqldb:file:testdb</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string"></span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">org.hsqldb.jdbc.JDBCDriver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.datasource.hikari.auto-commit</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.connection-timeout</span>=<span class="string">3000</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.validation-timeout</span>=<span class="string">3000</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.max-lifetime</span>=<span class="string">60000</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.maximum-pool-size</span>=<span class="string">20</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.minimum-idle</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure>
<p>使用YAML格式：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">$&#123;APP_NAME:unnamed&#125;</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:hsqldb:file:testdb</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">sa</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.hsqldb.jdbc.JDBCDriver</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">auto-commit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">connection-timeout:</span> <span class="number">3000</span></span><br><span class="line">      <span class="attr">validation-timeout:</span> <span class="number">3000</span></span><br><span class="line">      <span class="attr">max-lifetime:</span> <span class="number">60000</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">20</span></span><br><span class="line">      <span class="attr">minimum-idle:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可见，YAML是一种层级格式，它和<code>.properties</code>很容易互相转换，它的优点是去掉了大量重复的前缀，并且更加易读。</p>
<p>提示</p>
<p>也可以使用application.properties作为配置文件，但不如YAML格式简单。</p>
<h3 id="使用环境变量">使用环境变量</h3>
<p>在配置文件中，我们经常使用如下的格式对某个key进行配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">$&#123;DB_HOST:localhost&#125;</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">$&#123;DB_USER:root&#125;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;DB_PASSWORD:password&#125;</span></span><br></pre></td></tr></table></figure>
<p>这种<code>$&#123;DB_HOST:localhost&#125;</code>意思是，首先从环境变量查找<code>DB_HOST</code>，如果环境变量定义了，那么使用环境变量的值，否则，使用默认值<code>localhost</code>。</p>
<p>这使得我们在开发和部署时更加方便，因为开发时无需设定任何环境变量，直接使用默认值即本地数据库，而实际线上运行的时候，只需要传入环境变量即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ DB_HOST=10.0.1.123 DB_USER=prod DB_PASSWORD=xxxx java -jar xxx.jar</span><br></pre></td></tr></table></figure>
<h3 id="logback-spring-xml">logback-spring.xml</h3>
<p>这是Spring Boot的logback配置文件名称（也可以使用<code>logback.xml</code>），一个标准的写法如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;APP_LOG&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">file</span>&gt;</span>app.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxIndex</span>&gt;</span>1<span class="tag">&lt;/<span class="name">maxIndex</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>app.log.%i<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxFileSize</span>&gt;</span>1MB<span class="tag">&lt;/<span class="name">MaxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;APP_LOG&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>它主要通过<code>&lt;include resource=&quot;...&quot; /&gt;</code>引入了Spring Boot的一个缺省配置，这样我们就可以引用类似<code>$&#123;CONSOLE_LOG_PATTERN&#125;</code>这样的变量。上述配置定义了一个控制台输出和文件输出，可根据需要修改。</p>
<p><code>static</code>是静态文件目录，<code>templates</code>是模板文件目录，注意它们不再存放在<code>src/main/webapp</code>下，而是直接放到<code>src/main/resources</code>这个classpath目录，因为在Spring Boot中已经不需要专门的webapp目录了。</p>
<p>以上就是Spring Boot的标准目录结构，它完全是一个基于Java应用的普通Maven项目。</p>
<p>我们再来看源码目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">src/main/java</span><br><span class="line">└── com</span><br><span class="line">    └── itranswarp</span><br><span class="line">        └── learnjava</span><br><span class="line">            ├── Application.java</span><br><span class="line">            ├── entity</span><br><span class="line">            │   └── User.java</span><br><span class="line">            ├── service</span><br><span class="line">            │   └── UserService.java</span><br><span class="line">            └── web</span><br><span class="line">                └── UserController.java</span><br></pre></td></tr></table></figure>
<p>在存放源码的<code>src/main/java</code>目录中，Spring Boot对Java包的层级结构有一个要求。注意到我们的根package是<code>com.itranswarp.learnjava</code>，下面还有<code>entity</code>、<code>service</code>、<code>web</code>等子package。Spring Boot要求<code>main()</code>方法所在的启动类必须放到根package下，命名不做要求，这里我们以<code>Application.java</code>命名，它的内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动Spring Boot应用程序只需要一行代码加上一个注解<code>@SpringBootApplication</code>，该注解实际上又包含了：</p>
<ul>
<li>@SpringBootConfiguration
<ul>
<li>@Configuration</li>
</ul>
</li>
<li>@EnableAutoConfiguration
<ul>
<li>@AutoConfigurationPackage</li>
</ul>
</li>
<li>@ComponentScan</li>
</ul>
<p>这样一个注解就相当于启动了自动配置和自动扫描。</p>
<p>我们再观察<code>pom.xml</code>，它的内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>17<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pebble.version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">pebble.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 集成Pebble View --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.pebbletemplates<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pebble-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;pebble.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- JDBC驱动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用Spring Boot时，强烈推荐从<code>spring-boot-starter-parent</code>继承，因为这样就可以引入Spring Boot的预置配置。</p>
<p>紧接着，我们引入了依赖<code>spring-boot-starter-web</code>和<code>spring-boot-starter-jdbc</code>，它们分别引入了Spring MVC相关依赖和Spring JDBC相关依赖，无需指定版本号，因为引入的<code>&lt;parent&gt;</code>内已经指定了，只有我们自己引入的某些第三方jar包需要指定版本号。这里我们引入<code>pebble-spring-boot-starter</code>作为View，以及<code>hsqldb</code>作为嵌入式数据库。<code>hsqldb</code>已在<code>spring-boot-starter-jdbc</code>中预置了版本号<code>3.0.0</code>，因此此处无需指定版本号。</p>
<p>根据<code>pebble-spring-boot-starter</code>的<a target="_blank" rel="noopener" href="https://pebbletemplates.io/wiki/guide/spring-boot-integration/">文档</a>，加入如下配置到<code>application.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pebble:</span></span><br><span class="line">  <span class="comment"># 默认为&quot;.peb&quot;，改为&quot;&quot;:</span></span><br><span class="line">  <span class="attr">suffix:</span></span><br><span class="line">  <span class="comment"># 开发阶段禁用模板缓存:</span></span><br><span class="line">  <span class="attr">cache:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>对<code>Application</code>稍作改动，添加<code>WebMvcConfigurer</code>这个Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    WebMvcConfigurer <span class="title function_">createWebMvcConfigurer</span><span class="params">(<span class="meta">@Autowired</span> HandlerInterceptor[] interceptors)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">                <span class="comment">// 映射路径`/static/`到classpath路径:</span></span><br><span class="line">                registry.addResourceHandler(<span class="string">&quot;/static/**&quot;</span>)</span><br><span class="line">                        .addResourceLocations(<span class="string">&quot;classpath:/static/&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在就可以直接运行<code>Application</code>，启动后观察Spring Boot的日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &#x27;_ | &#x27;_| | &#x27;_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"> :: Spring Boot ::                (v3.0.0)</span><br><span class="line"></span><br><span class="line">2022-11-25T10:49:31.100+08:00  INFO 13105 --- [           main] com.itranswarp.learnjava.Application     : Starting Application using Java 17 with PID 13105 (/Users/liaoxuefeng/Git/springboot-hello/target/classes started by liaoxuefeng in /Users/liaoxuefeng/Git/springboot-hello)</span><br><span class="line">2022-11-25T10:49:31.107+08:00  INFO 13105 --- [           main] com.itranswarp.learnjava.Application     : No active profile set, falling back to 1 default profile: &quot;default&quot;</span><br><span class="line">2022-11-25T10:49:32.404+08:00  INFO 13105 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)</span><br><span class="line">2022-11-25T10:49:32.423+08:00  INFO 13105 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]</span><br><span class="line">2022-11-25T10:49:32.426+08:00  INFO 13105 --- [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.1]</span><br><span class="line">2022-11-25T10:49:32.549+08:00  INFO 13105 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class="line">2022-11-25T10:49:32.551+08:00  INFO 13105 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1327 ms</span><br><span class="line">2022-11-25T10:49:32.668+08:00  WARN 13105 --- [           main] com.zaxxer.hikari.HikariConfig           : HikariPool-1 - idleTimeout is close to or more than maxLifetime, disabling it.</span><br><span class="line">2022-11-25T10:49:32.669+08:00  INFO 13105 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...</span><br><span class="line">2022-11-25T10:49:32.996+08:00  INFO 13105 --- [           main] com.zaxxer.hikari.pool.PoolBase          : HikariPool-1 - Driver does not support get/set network timeout for connections. (feature not supported)</span><br><span class="line">2022-11-25T10:49:32.998+08:00  INFO 13105 --- [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection org.hsqldb.jdbc.JDBCConnection@31a2a9fa</span><br><span class="line">2022-11-25T10:49:33.002+08:00  INFO 13105 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.</span><br><span class="line">2022-11-25T10:49:33.391+08:00  WARN 13105 --- [           main] ocalVariableTableParameterNameDiscoverer : Using deprecated &#x27;-debug&#x27; fallback for parameter name resolution. Compile the affected code with &#x27;-parameters&#x27; instead or avoid its introspection: io.pebbletemplates.boot.autoconfigure.PebbleServletWebConfiguration</span><br><span class="line">2022-11-25T10:49:33.398+08:00  WARN 13105 --- [           main] ocalVariableTableParameterNameDiscoverer : Using deprecated &#x27;-debug&#x27; fallback for parameter name resolution. Compile the affected code with &#x27;-parameters&#x27; instead or avoid its introspection: io.pebbletemplates.boot.autoconfigure.PebbleAutoConfiguration</span><br><span class="line">2022-11-25T10:49:33.619+08:00  INFO 13105 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path &#x27;&#x27;</span><br><span class="line">2022-11-25T10:49:33.637+08:00  INFO 13105 --- [           main] com.itranswarp.learnjava.Application     : Started Application in 3.151 seconds (process running for 3.835)</span><br></pre></td></tr></table></figure>
<p>Spring Boot自动启动了嵌入式Tomcat，当看到<code>Started Application in xxx seconds</code>时，Spring Boot应用启动成功。</p>
<p>现在，我们在浏览器输入<code>localhost:8080</code>就可以直接访问页面。那么问题来了：</p>
<p>前面我们定义的数据源、声明式事务、JdbcTemplate在哪创建的？怎么就可以直接注入到自己编写的<code>UserService</code>中呢？</p>
<p>这些自动创建的Bean就是Spring Boot的特色：AutoConfiguration。</p>
<p>当我们引入<code>spring-boot-starter-jdbc</code>时，启动时会自动扫描所有的<code>XxxAutoConfiguration</code>：</p>
<ul>
<li><code>DataSourceAutoConfiguration</code>：自动创建一个<code>DataSource</code>，其中配置项从<code>application.yml</code>的<code>spring.datasource</code>读取；</li>
<li><code>DataSourceTransactionManagerAutoConfiguration</code>：自动创建了一个基于JDBC的事务管理器；</li>
<li><code>JdbcTemplateAutoConfiguration</code>：自动创建了一个<code>JdbcTemplate</code>。</li>
</ul>
<p>因此，我们自动得到了一个<code>DataSource</code>、一个<code>DataSourceTransactionManager</code>和一个<code>JdbcTemplate</code>。</p>
<p>类似的，当我们引入<code>spring-boot-starter-web</code>时，自动创建了：</p>
<ul>
<li><code>ServletWebServerFactoryAutoConfiguration</code>：自动创建一个嵌入式Web服务器，默认是Tomcat；</li>
<li><code>DispatcherServletAutoConfiguration</code>：自动创建一个<code>DispatcherServlet</code>；</li>
<li><code>HttpEncodingAutoConfiguration</code>：自动创建一个<code>CharacterEncodingFilter</code>；</li>
<li><code>WebMvcAutoConfiguration</code>：自动创建若干与MVC相关的Bean。</li>
<li>…</li>
</ul>
<p>引入第三方<code>pebble-spring-boot-starter</code>时，自动创建了：</p>
<ul>
<li><code>PebbleAutoConfiguration</code>：自动创建了一个<code>PebbleViewResolver</code>。</li>
</ul>
<p>Spring Boot大量使用<code>XxxAutoConfiguration</code>来使得许多组件被自动化配置并创建，而这些创建过程又大量使用了Spring的Conditional功能。例如，我们观察<code>JdbcTemplateAutoConfiguration</code>，它的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; DataSource.class, JdbcTemplate.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(DataSource.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(DataSourceAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(JdbcProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; JdbcTemplateConfiguration.class, NamedParameterJdbcTemplateConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplateAutoConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当满足条件：</p>
<ul>
<li><code>@ConditionalOnClass</code>：在classpath中能找到<code>DataSource</code>和<code>JdbcTemplate</code>；</li>
<li><code>@ConditionalOnSingleCandidate(DataSource.class)</code>：在当前Bean的定义中能找到唯一的<code>DataSource</code>；</li>
</ul>
<p>该<code>JdbcTemplateAutoConfiguration</code>就会起作用。实际创建由导入的<code>JdbcTemplateConfiguration</code>完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(JdbcOperations.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JdbcTemplateConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">(DataSource dataSource, JdbcProperties properties)</span> &#123;</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">        JdbcProperties.<span class="type">Template</span> <span class="variable">template</span> <span class="operator">=</span> properties.getTemplate();</span><br><span class="line">        jdbcTemplate.setFetchSize(template.getFetchSize());</span><br><span class="line">        jdbcTemplate.setMaxRows(template.getMaxRows());</span><br><span class="line">        <span class="keyword">if</span> (template.getQueryTimeout() != <span class="literal">null</span>) &#123;</span><br><span class="line">            jdbcTemplate.setQueryTimeout((<span class="type">int</span>) template.getQueryTimeout().getSeconds());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建<code>JdbcTemplate</code>之前，要满足<code>@ConditionalOnMissingBean(JdbcOperations.class)</code>，即不存在<code>JdbcOperations</code>的Bean。</p>
<p>如果我们自己创建了一个<code>JdbcTemplate</code>，例如，在<code>Application</code>中自己写个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    JdbcTemplate <span class="title function_">createJdbcTemplate</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么根据条件<code>@ConditionalOnMissingBean(JdbcOperations.class)</code>，Spring Boot就不会再创建一个重复的<code>JdbcTemplate</code>（因为<code>JdbcOperations</code>是<code>JdbcTemplate</code>的父类）。</p>
<p>可见，Spring Boot自动装配功能是通过自动扫描+条件装配实现的，这一套机制在默认情况下工作得很好，但是，如果我们要手动控制某个Bean的创建，就需要详细地了解Spring Boot自动创建的原理，很多时候还要跟踪<code>XxxAutoConfiguration</code>，以便设定条件使得某个Bean不会被自动创建。</p>
<h3 id="练习-6">练习</h3>
<p>使用Spring Boot编写hello应用程序。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/first-webapp/springboot-hello.zip">下载练习</a></p>
<h3 id="小结-6">小结</h3>
<p>Spring Boot是一个基于Spring提供了开箱即用的一组套件，它可以让我们基于很少的配置和代码快速搭建出一个完整的应用程序。</p>
<p>Spring Boot有非常强大的AutoConfiguration功能，它是通过自动扫描+条件装配实现的。</p>
<h2 id="Spring-Boot开发">Spring Boot开发</h2>
<p>我们已经在前面详细介绍了Spring框架，它的主要功能包括IoC容器、AOP支持、事务支持、MVC开发以及强大的第三方集成功能等。</p>
<p>那么，Spring Boot又是什么？它和Spring是什么关系？</p>
<p>Spring Boot是一个基于Spring的套件，它帮我们预组装了Spring的一系列组件，以便以尽可能少的代码和配置来开发基于Spring的Java应用程序。</p>
<p>以汽车为例，如果我们想组装一辆汽车，我们需要发动机、传动、轮胎、底盘、外壳、座椅、内饰等各种部件，然后把它们装配起来。Spring就相当于提供了一系列这样的部件，但是要装好汽车上路，还需要我们自己动手。而Spring Boot则相当于已经帮我们预装好了一辆可以上路的汽车，如果有特殊的要求，例如把发动机从普通款换成涡轮增压款，可以通过修改配置或编写少量代码完成。</p>
<p>因此，Spring Boot和Spring的关系就是整车和零部件的关系，它们不是取代关系，试图跳过Spring直接学习Spring Boot是不可能的。</p>
<p>Spring Boot的目标就是提供一个开箱即用的应用程序架构，我们基于Spring Boot的预置结构继续开发，省时省力。</p>
<p>本章我们将详细介绍如何使用Spring Boot。</p>
<p>本教程使用的Spring Boot版本是3.x版，如果使用Spring Boot 2.x则需注意，两者有以下不同：</p>
<table>
<thead>
<tr>
<th></th>
<th>Spring Boot 2.x</th>
<th>Spring Boot 3.x</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spring版本</td>
<td>Spring 5.x</td>
<td>Spring 6.x</td>
</tr>
<tr>
<td>JDK版本</td>
<td>&gt;= 1.8</td>
<td>&gt;= 17</td>
</tr>
<tr>
<td>Tomcat版本</td>
<td>9.x</td>
<td>10.x</td>
</tr>
<tr>
<td>Annotation包</td>
<td>javax.annotation</td>
<td>jakarta.annotation</td>
</tr>
<tr>
<td>Servlet包</td>
<td>javax.servlet</td>
<td>jakarta.servlet</td>
</tr>
<tr>
<td>JMS包</td>
<td>javax.jms</td>
<td>jakarta.jms</td>
</tr>
<tr>
<td>JavaMail包</td>
<td>javax.mail</td>
<td>jakarta.mail</td>
</tr>
</tbody>
</table>
<p>如果使用Spring Boot的其他版本，则需要根据需要调整代码。</p>
<p>Spring Boot的官网入口是<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-boot">这里</a>，建议添加到浏览器收藏夹。</p>
<hr>
<hr>
<h2 id="加载配置文件">加载配置文件</h2>
<p>加载配置文件可以直接使用注解<code>@Value</code>，例如，我们定义了一个最大允许上传的文件大小配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">max-size:</span> <span class="number">102400</span></span><br></pre></td></tr></table></figure>
<p>在某个FileUploader里，需要获取该配置，可使用<code>@Value</code>注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploader</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;storage.local.max-size:102400&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在另一个<code>UploadFilter</code>中，因为要检查文件的MD5，同时也要检查输入流的大小，因此，也需要该配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;storage.local.max-size:100000&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多次引用同一个<code>@Value</code>不但麻烦，而且<code>@Value</code>使用字符串，缺少编译器检查，容易造成多处引用不一致（例如，<code>UploadFilter</code>把缺省值误写为<code>100000</code>）。</p>
<p>为了更好地管理配置，Spring Boot允许创建一个Bean，持有一组配置，并由Spring Boot自动注入。</p>
<p>假设我们在<code>application.yml</code>中添加了如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="comment"># 文件存储根目录:</span></span><br><span class="line">    <span class="attr">root-dir:</span> <span class="string">$&#123;STORAGE_LOCAL_ROOT:/var/storage&#125;</span></span><br><span class="line">    <span class="comment"># 最大文件大小，默认100K:</span></span><br><span class="line">    <span class="attr">max-size:</span> <span class="string">$&#123;STORAGE_LOCAL_MAX_SIZE:102400&#125;</span></span><br><span class="line">    <span class="comment"># 是否允许空文件:</span></span><br><span class="line">    <span class="attr">allow-empty:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 允许的文件类型:</span></span><br><span class="line">    <span class="attr">allow-types:</span> <span class="string">jpg,</span> <span class="string">png,</span> <span class="string">gif</span></span><br></pre></td></tr></table></figure>
<p>可以首先定义一个Java Bean，持有该组配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StorageConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> allowEmpty;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; allowTypes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保证Java Bean的属性名称与配置一致即可。然后，我们添加两个注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;storage.local&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StorageConfiguration</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>@ConfigurationProperties(&quot;storage.local&quot;)</code>表示将从配置项<code>storage.local</code>读取该项的所有子项配置，并且，<code>@Configuration</code>表示<code>StorageConfiguration</code>也是一个Spring管理的Bean，可直接注入到其他Bean中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StorageConfiguration storageConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Load configuration: root-dir = &#123;&#125;&quot;</span>, storageConfig.getRootDir());</span><br><span class="line">        logger.info(<span class="string">&quot;Load configuration: max-size = &#123;&#125;&quot;</span>, storageConfig.getMaxSize());</span><br><span class="line">        logger.info(<span class="string">&quot;Load configuration: allowed-types = &#123;&#125;&quot;</span>, storageConfig.getAllowTypes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，引入<code>storage.local</code>的相关配置就很容易了，因为只需要注入<code>StorageConfiguration</code>这个Bean，这样可以由编译器检查类型，无需编写重复的<code>@Value</code>注解。</p>
<h3 id="练习-7">练习</h3>
<p>用Spring Boot加载配置文件。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/configuration/springboot-configuration.zip">下载练习</a></p>
<h3 id="小结-7">小结</h3>
<p>Spring Boot提供了<code>@ConfigurationProperties</code>注解，可以非常方便地把一段配置加载到一个Bean中。</p>
<hr>
<hr>
<p>Spring Boot大量使用自动配置和默认配置，极大地减少了代码，通常只需要加上几个注解，并按照默认规则设定一下必要的配置即可。例如，配置JDBC，默认情况下，只需要配置一个<code>spring.datasource</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:hsqldb:file:testdb</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">sa</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="attr">dirver-class-name:</span> <span class="string">org.hsqldb.jdbc.JDBCDriver</span></span><br></pre></td></tr></table></figure>
<p>Spring Boot就会自动创建出<code>DataSource</code>、<code>JdbcTemplate</code>、<code>DataSourceTransactionManager</code>，非常方便。</p>
<p>但是，有时候，我们又必须要禁用某些自动配置。例如，系统有主从两个数据库，而Spring Boot的自动配置只能配一个，怎么办？</p>
<p>这个时候，针对<code>DataSource</code>相关的自动配置，就必须关掉。我们需要用<code>exclude</code>指定需要关掉的自动配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 启动自动配置，但排除指定的自动配置:</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration(exclude = DataSourceAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，Spring Boot不再给我们自动创建<code>DataSource</code>、<code>JdbcTemplate</code>和<code>DataSourceTransactionManager</code>了，要实现主从数据库支持，怎么办？</p>
<p>让我们一步一步开始编写支持主从数据库的功能。首先，我们需要把主从数据库配置写到<code>application.yml</code>中，仍然按照Spring Boot默认的格式写，但<code>datasource</code>改为<code>datasource-master</code>和<code>datasource-slave</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource-master:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:hsqldb:file:testdb</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">sa</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="attr">dirver-class-name:</span> <span class="string">org.hsqldb.jdbc.JDBCDriver</span></span><br><span class="line">  <span class="attr">datasource-slave:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:hsqldb:file:testdb</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">sa</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="attr">dirver-class-name:</span> <span class="string">org.hsqldb.jdbc.JDBCDriver</span></span><br></pre></td></tr></table></figure>
<p>注意到两个数据库实际上是同一个库。如果使用MySQL，可以创建一个只读用户，作为<code>datasource-slave</code>的用户来模拟一个从库。</p>
<p>下一步，我们分别创建两个HikariCP的<code>DataSource</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MasterDataSourceConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;masterDataSourceProperties&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;spring.datasource-master&quot;)</span></span><br><span class="line">    DataSourceProperties <span class="title function_">dataSourceProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProperties</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;masterDataSource&quot;)</span></span><br><span class="line">    DataSource <span class="title function_">dataSource</span><span class="params">(<span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;masterDataSourceProperties&quot;)</span> DataSourceProperties props)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> props.initializeDataSourceBuilder().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlaveDataSourceConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;slaveDataSourceProperties&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;spring.datasource-slave&quot;)</span></span><br><span class="line">    DataSourceProperties <span class="title function_">dataSourceProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProperties</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;slaveDataSource&quot;)</span></span><br><span class="line">    DataSource <span class="title function_">dataSource</span><span class="params">(<span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;slaveDataSourceProperties&quot;)</span> DataSourceProperties props)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> props.initializeDataSourceBuilder().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到上述class并未添加<code>@Configuration</code>和<code>@Component</code>，要使之生效，可以使用<code>@Import</code>导入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration(exclude = DataSourceAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; MasterDataSourceConfiguration.class, SlaveDataSourceConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，上述两个<code>DataSource</code>的Bean名称分别为<code>masterDataSource</code>和<code>slaveDataSource</code>，我们还需要一个最终的<code>@Primary</code>标注的<code>DataSource</code>，它采用Spring提供的<code>AbstractRoutingDataSource</code>，代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RoutingDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">determineCurrentLookupKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 从ThreadLocal中取出key:</span></span><br><span class="line">        <span class="keyword">return</span> RoutingDataSourceContext.getDataSourceRoutingKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RoutingDataSource</code>本身并不是真正的<code>DataSource</code>，它通过Map关联一组<code>DataSource</code>，下面的代码创建了包含两个<code>DataSource</code>的<code>RoutingDataSource</code>，关联的key分别为<code>masterDataSource</code>和<code>slaveDataSource</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoutingDataSourceConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">dataSource</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;masterDataSource&quot;)</span> DataSource masterDataSource,</span></span><br><span class="line"><span class="params">            <span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;slaveDataSource&quot;)</span> DataSource slaveDataSource)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoutingDataSource</span>();</span><br><span class="line">        <span class="comment">// 关联两个DataSource:</span></span><br><span class="line">        ds.setTargetDataSources(Map.of(</span><br><span class="line">                <span class="string">&quot;masterDataSource&quot;</span>, masterDataSource,</span><br><span class="line">                <span class="string">&quot;slaveDataSource&quot;</span>, slaveDataSource));</span><br><span class="line">        <span class="comment">// 默认使用masterDataSource:</span></span><br><span class="line">        ds.setDefaultTargetDataSource(masterDataSource);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSourceTransactionManager <span class="title function_">dataSourceTransactionManager</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仍然需要自己创建<code>JdbcTemplate</code>和<code>PlatformTransactionManager</code>，注入的是标记为<code>@Primary</code>的<code>RoutingDataSource</code>。</p>
<p>这样，我们通过如下的代码就可以切换<code>RoutingDataSource</code>底层使用的真正的<code>DataSource</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RoutingDataSourceContext.setDataSourceRoutingKey(<span class="string">&quot;slaveDataSource&quot;</span>);</span><br><span class="line">jdbcTemplate.query(...);</span><br></pre></td></tr></table></figure>
<p>只不过写代码切换DataSource即麻烦又容易出错，更好的方式是通过注解配合AOP实现自动切换，这样，客户端代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">	<span class="meta">@RoutingWithSlave</span> <span class="comment">// &lt;-- 指示在此方法中使用slave数据库</span></span><br><span class="line">	<span class="meta">@GetMapping(&quot;/profile&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> ModelAndView <span class="title function_">profile</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现上述功能需要编写一个<code>@RoutingWithSlave</code>注解，一个AOP织入和一个<code>ThreadLocal</code>来保存key。由于代码比较简单，这里我们不再详述。</p>
<p>如果我们想要确认是否真的切换了<code>DataSource</code>，可以覆写<code>determineTargetDataSource()</code>方法并打印出<code>DataSource</code>的名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RoutingDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> DataSource <span class="title function_">determineTargetDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="built_in">super</span>.determineTargetDataSource();</span><br><span class="line">        logger.info(<span class="string">&quot;determin target datasource: &#123;&#125;&quot;</span>, ds);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问不同的URL，可以在日志中看到两个<code>DataSource</code>，分别是<code>HikariPool-1</code>和<code>hikariPool-2</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-06-14 17:55:21.676  INFO 91561 --- [nio-8080-exec-7] c.i.learnjava.config.RoutingDataSource   : determin target datasource: HikariDataSource (HikariPool-1)</span><br><span class="line">2020-06-14 17:57:08.992  INFO 91561 --- [io-8080-exec-10] c.i.learnjava.config.RoutingDataSource   : determin target datasource: HikariDataSource (HikariPool-2)</span><br></pre></td></tr></table></figure>
<p>我们用一个图来表示创建的DataSource以及相关Bean的关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────────┐       ┌──────────────────┐</span><br><span class="line">│@Primary            │&lt;──────│   JdbcTemplate   │</span><br><span class="line">│RoutingDataSource   │       └──────────────────┘</span><br><span class="line">│ ┌────────────────┐ │       ┌──────────────────┐</span><br><span class="line">│ │MasterDataSource│ │&lt;──────│DataSource        │</span><br><span class="line">│ └────────────────┘ │       │TransactionManager│</span><br><span class="line">│ ┌────────────────┐ │       └──────────────────┘</span><br><span class="line">│ │SlaveDataSource │ │</span><br><span class="line">│ └────────────────┘ │</span><br><span class="line">└────────────────────┘</span><br></pre></td></tr></table></figure>
<p>注意到<code>DataSourceTransactionManager</code>和<code>JdbcTemplate</code>引用的都是<code>RoutingDataSource</code>，所以，这种设计的一个限制就是：在一个请求中，一旦切换了内部数据源，在同一个事务中，不能再切到另一个，否则，<code>DataSourceTransactionManager</code>和<code>JdbcTemplate</code>操作的就不是同一个数据库连接。</p>
<h3 id="练习-8">练习</h3>
<p>禁用DataSourceAutoConfiguration并配置多数据源。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/disable-auto-config/springboot-multi-datasource.zip">下载练习</a></p>
<h3 id="小结-8">小结</h3>
<p>可以通过<code>@EnableAutoConfiguration(exclude = &#123;...&#125;)</code>指定禁用的自动配置；</p>
<p>可以通过<code>@Import(&#123;...&#125;)</code>导入自定义配置。</p>
<h2 id="添加Filter">添加Filter</h2>
<p>我们在Spring中已经学过了<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/web/filter/index.html">集成Filter</a>，本质上就是通过代理，把Spring管理的Bean注册到Servlet容器中，不过步骤比较繁琐，需要配置<code>web.xml</code>。</p>
<p>在Spring Boot中，添加一个<code>Filter</code>更简单了，可以做到零配置。我们来看看在Spring Boot中如何添加<code>Filter</code>。</p>
<p>Spring Boot会自动扫描所有的<code>FilterRegistrationBean</code>类型的Bean，然后，将它们返回的<code>Filter</code>自动注册到Servlet容器中，无需任何配置。</p>
<p>我们还是以<code>AuthFilter</code>为例，首先编写一个<code>AuthFilterRegistrationBean</code>，它继承自<code>FilterRegistrationBean</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthFilterRegistrationBean</span> <span class="keyword">extends</span> <span class="title class_">FilterRegistrationBean</span>&lt;Filter&gt; &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Filter <span class="title function_">getFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        setOrder(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthFilter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AuthFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FilterRegistrationBean</code>本身不是<code>Filter</code>，它实际上是<code>Filter</code>的工厂。Spring Boot会调用<code>getFilter()</code>，把返回的<code>Filter</code>注册到Servlet容器中。因为我们可以在<code>FilterRegistrationBean</code>中注入需要的资源，然后，在返回的<code>AuthFilter</code>中，这个内部类可以引用外部类的所有字段，自然也包括注入的<code>UserService</code>，所以，整个过程完全基于Spring的IoC容器完成。</p>
<p>再注意到<code>AuthFilterRegistrationBean</code>使用了<code>setOrder(10)</code>，因为Spring Boot支持给多个<code>Filter</code>排序，数字小的在前面，所以，多个<code>Filter</code>的顺序是可以固定的。</p>
<p>我们再编写一个<code>ApiFilter</code>，专门过滤<code>/api/*</code>这样的URL。首先编写一个<code>ApiFilterRegistrationBean</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiFilterRegistrationBean</span> <span class="keyword">extends</span> <span class="title class_">FilterRegistrationBean</span>&lt;Filter&gt; &#123;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        setOrder(<span class="number">20</span>);</span><br><span class="line">        setFilter(<span class="keyword">new</span> <span class="title class_">ApiFilter</span>());</span><br><span class="line">        setUrlPatterns(List.of(<span class="string">&quot;/api/*&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ApiFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>ApiFilterRegistrationBean</code>和<code>AuthFilterRegistrationBean</code>又有所不同。因为我们要过滤URL，而不是针对所有URL生效，因此，在<code>@PostConstruct</code>方法中，通过<code>setFilter()</code>设置一个<code>Filter</code>实例后，再调用<code>setUrlPatterns()</code>传入要过滤的URL列表。</p>
<h3 id="练习-9">练习</h3>
<p>在Spring Boot中添加Filter并指定顺序。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/filter/springboot-filter.zip">下载练习</a></p>
<h3 id="小结-9">小结</h3>
<p>在Spring Boot中添加<code>Filter</code>更加方便，并且支持对多个<code>Filter</code>进行排序。</p>
<hr>
<hr>
<p>和Spring相比，使用Spring Boot通过自动配置来集成第三方组件通常来说更简单。</p>
<p>我们将详细介绍如何通过Spring Boot集成常用的第三方组件，包括：</p>
<ul>
<li>Open API</li>
<li>Redis</li>
<li>Artemis</li>
<li>RabbitMQ</li>
<li>Kafka</li>
</ul>
<p><img src="https://liaoxuefeng.com/books/java/springboot/integration/boot.png" alt="spring-boot"></p>
<p><a target="_blank" rel="noopener" href="https://www.openapis.org/">Open API</a>是一个标准，它的主要作用是描述REST API，既可以作为文档给开发者阅读，又可以让机器根据这个文档自动生成客户端代码等。</p>
<p>在Spring Boot应用中，假设我们编写了一堆REST API，如何添加Open API的支持？</p>
<p>我们只需要在<code>pom.xml</code>中加入以下依赖：</p>
<ul>
<li>org.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.0</li>
</ul>
<p>然后呢？没有然后了，直接启动应用，打开浏览器输入<code>http://localhost:8080/swagger-ui.html</code>：</p>
<p><img src="https://liaoxuefeng.com/books/java/springboot/integration/open-api/open-api.png" alt="swagger-ui"></p>
<p>立刻可以看到自动生成的API文档，这里列出了3个API，来自<code>api-controller</code>（因为定义在<code>ApiController</code>这个类中），点击某个API还可以交互，即输入API参数，点“Try it out”按钮，获得运行结果。</p>
<h2 id="是不是太方便了！">是不是太方便了！</h2>
<p>因为我们引入<code>springdoc-openapi-ui</code>这个依赖后，它自动引入Swagger UI用来创建API文档。可以给API加入一些描述信息，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiController</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Operation(summary = &quot;Get specific user object by it&#x27;s id.&quot;)</span></span><br><span class="line">	<span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> User <span class="title function_">user</span><span class="params">(<span class="meta">@Parameter(description = &quot;id of the user.&quot;)</span> <span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> userService.getUserById(id);</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Operation</code>可以对API进行描述，<code>@Parameter</code>可以对参数进行描述，它们的目的是用于生成API文档的描述信息。添加了描述的API文档如下：</p>
<p><img src="https://liaoxuefeng.com/books/java/springboot/integration/open-api/open-api-desc.png" alt="api-description"></p>
<p>大多数情况下，不需要任何配置，我们就直接得到了一个运行时动态生成的可交互的API文档，该API文档总是和代码保持同步，大大简化了文档的编写工作。</p>
<p>要自定义文档的样式、控制某些API显示等，请参考<a target="_blank" rel="noopener" href="https://springdoc.org/">springdoc文档</a>。</p>
<h3 id="配置反向代理">配置反向代理</h3>
<p>如果在服务器上，用户访问的域名是<code>https://example.com</code>，但内部是通过类似Nginx这样的反向代理访问实际的Spring Boot应用，比如<code>http://localhost:8080</code>，这个时候，在页面<code>https://example.com/swagger-ui.html</code>上，显示的URL仍然是<code>http://localhost:8080</code>，这样一来，就无法直接在页面执行API，非常不方便。</p>
<p>这是因为Spring Boot内置的Tomcat默认获取的服务器名称是<code>localhost</code>，端口是实际监听端口，而不是对外暴露的域名和<code>80</code>或<code>443</code>端口。要让Tomcat获取到对外暴露的域名等信息，必须在Nginx配置中传入必要的HTTP Header，常用的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Nginx配置</span><br><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在Spring Boot的<code>application.yml</code>中，加入如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="comment"># 实际监听端口:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="comment"># 从反向代理读取相关的HTTP Header:</span></span><br><span class="line">  <span class="attr">forward-headers-strategy:</span> <span class="string">native</span></span><br></pre></td></tr></table></figure>
<p>重启Spring Boot应用，即可在Swagger中显示正确的URL。</p>
<h3 id="练习-10">练习</h3>
<p>利用springdoc实现API文档。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/integration/open-api/springboot-openapi.zip">下载练习</a></p>
<h3 id="小结-10">小结</h3>
<p>使用springdoc让其自动创建API文档非常容易，引入依赖后无需任何配置即可访问交互式API文档。</p>
<p>可以对API添加注解以便生成更详细的描述。</p>
<p>在Spring Boot中，要访问Redis，可以直接引入<code>spring-boot-starter-data-redis</code>依赖，它实际上是Spring Data的一个子项目——Spring Data Redis，主要用到了这几个组件：</p>
<ul>
<li>Lettuce：一个基于Netty的高性能Redis客户端；</li>
<li>RedisTemplate：一个类似于JdbcTemplate的接口，用于简化Redis的操作。</li>
</ul>
<p>因为Spring Data Redis引入的依赖项很多，如果只是为了使用Redis，完全可以只引入Lettuce，剩下的操作都自己来完成。</p>
<p>本节我们稍微深入一下Redis的客户端，看看怎么一步一步把一个第三方组件引入到Spring Boot中。</p>
<p>首先，我们添加必要的几个依赖项：</p>
<ul>
<li>io.lettuce:lettuce-core</li>
<li>org.apache.commons:commons-pool2</li>
</ul>
<p>注意我们并未指定版本号，因为在<code>spring-boot-starter-parent</code>中已经把常用组件的版本号确定下来了。</p>
<p>第一步是在配置文件<code>application.yml</code>中添加Redis的相关配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">$&#123;REDIS_HOST:localhost&#125;</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">$&#123;REDIS_PORT:6379&#125;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;REDIS_PASSWORD:&#125;</span></span><br><span class="line">    <span class="attr">ssl:</span> <span class="string">$&#123;REDIS_SSL:false&#125;</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">$&#123;REDIS_DATABASE:0&#125;</span></span><br></pre></td></tr></table></figure>
<p>然后，通过<code>RedisConfiguration</code>来加载它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;spring.redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String host;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再编写一个<code>@Bean</code>方法来创建<code>RedisClient</code>，可以直接放在<code>RedisConfiguration</code>中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;spring.redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    RedisClient <span class="title function_">redisClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RedisURI</span> <span class="variable">uri</span> <span class="operator">=</span> RedisURI.Builder.redis(<span class="built_in">this</span>.host, <span class="built_in">this</span>.port)</span><br><span class="line">                .withPassword(<span class="built_in">this</span>.password)</span><br><span class="line">                .withDatabase(<span class="built_in">this</span>.database)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> RedisClient.create(uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在启动入口引入该配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@Import(RedisConfiguration.class)</span> <span class="comment">// 加载Redis配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果在<code>RedisConfiguration</code>中标注<code>@Configuration</code>，则可通过Spring Boot的自动扫描机制自动加载，否则，使用<code>@Import</code>手动加载。</p>
<p>紧接着，我们用一个<code>RedisService</code>来封装所有的Redis操作。基础代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisClient redisClient;</span><br><span class="line"></span><br><span class="line">    GenericObjectPool&lt;StatefulRedisConnection&lt;String, String&gt;&gt; redisConnectionPool;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        GenericObjectPoolConfig&lt;StatefulRedisConnection&lt;String, String&gt;&gt; poolConfig = <span class="keyword">new</span> <span class="title class_">GenericObjectPoolConfig</span>&lt;&gt;();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">20</span>);</span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">5</span>);</span><br><span class="line">        poolConfig.setTestOnReturn(<span class="literal">true</span>);</span><br><span class="line">        poolConfig.setTestWhileIdle(<span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.redisConnectionPool = ConnectionPoolSupport.createGenericObjectPool(() -&gt; redisClient.connect(), poolConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisConnectionPool.close();</span><br><span class="line">        <span class="built_in">this</span>.redisClient.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到上述代码引入了Commons Pool的一个对象池，用于缓存Redis连接。因为Lettuce本身是基于Netty的异步驱动，在异步访问时并不需要创建连接池，但基于Servlet模型的同步访问时，连接池是有必要的。连接池在<code>@PostConstruct</code>方法中初始化，在<code>@PreDestroy</code>方法中关闭。</p>
<p>下一步，是在<code>RedisService</code>中添加Redis访问方法。为了简化代码，我们仿照<code>JdbcTemplate.execute(ConnectionCallback)</code>方法，传入回调函数，可大幅减少样板代码。</p>
<p>首先定义回调函数接口<code>SyncCommandCallback</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SyncCommandCallback</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 在此操作Redis:</span></span><br><span class="line">    T <span class="title function_">doInConnection</span><span class="params">(RedisCommands&lt;String, String&gt; commands)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写<code>executeSync</code>方法，在该方法中，获取Redis连接，利用callback操作Redis，最后释放连接，并返回操作结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">executeSync</span><span class="params">(SyncCommandCallback&lt;T&gt; callback)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (StatefulRedisConnection&lt;String, String&gt; connection = redisConnectionPool.borrowObject()) &#123;</span><br><span class="line">        connection.setAutoFlushCommands(<span class="literal">true</span>);</span><br><span class="line">        RedisCommands&lt;String, String&gt; commands = connection.sync();</span><br><span class="line">        <span class="keyword">return</span> callback.doInConnection(commands);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;executeSync redis failed.&quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有的童鞋觉得这样访问Redis的代码太复杂了，实际上我们可以针对常用操作把它封装一下，例如<code>set</code>和<code>get</code>命令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">set</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> executeSync(commands -&gt; commands.set(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> executeSync(commands -&gt; commands.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，<code>hget</code>和<code>hset</code>操作如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key, String field, String value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> executeSync(commands -&gt; commands.hset(key, field, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hget</span><span class="params">(String key, String field)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> executeSync(commands -&gt; commands.hget(key, field));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">hgetall</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> executeSync(commands -&gt; commands.hgetall(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常用命令可以提供方法接口，如果要执行任意复杂的操作，就可以通过<code>executeSync(SyncCommandCallback&lt;T&gt;)</code>来完成。</p>
<p>完成了<code>RedisService</code>后，我们就可以使用Redis了。例如，在<code>UserController</code>中，我们在Session中只存放登录用户的ID，用户信息存放到Redis，提供两个方法用于读写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_USER_ID</span> <span class="operator">=</span> <span class="string">&quot;__userid__&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_USERS</span> <span class="operator">=</span> <span class="string">&quot;__users__&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> ObjectMapper objectMapper;</span><br><span class="line">    <span class="meta">@Autowired</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把User写入Redis:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">putUserIntoRedis</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        redisService.hset(KEY_USERS, user.getId().toString(), objectMapper.writeValueAsString(user));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从Redis读取User:</span></span><br><span class="line">    <span class="keyword">private</span> User <span class="title function_">getUserFromRedis</span><span class="params">(HttpSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> (Long) session.getAttribute(KEY_USER_ID);</span><br><span class="line">        <span class="keyword">if</span> (id != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> redisService.hget(KEY_USERS, id.toString());</span><br><span class="line">            <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> objectMapper.readValue(s, User.class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户登录成功后，把ID放入Session，把<code>User</code>实例放入Redis：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/signin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">doSignin</span><span class="params">(<span class="meta">@RequestParam(&quot;email&quot;)</span> String email, <span class="meta">@RequestParam(&quot;password&quot;)</span> String password, HttpSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.signin(email, password);</span><br><span class="line">        session.setAttribute(KEY_USER_ID, user.getId());</span><br><span class="line">        putUserIntoRedis(user);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;signin.html&quot;</span>, Map.of(<span class="string">&quot;email&quot;</span>, email, <span class="string">&quot;error&quot;</span>, <span class="string">&quot;Signin failed&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;redirect:/profile&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要获取<code>User</code>时，从Redis取出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/profile&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">profile</span><span class="params">(HttpSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getUserFromRedis(session);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;redirect:/signin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;profile.html&quot;</span>, Map.of(<span class="string">&quot;user&quot;</span>, user));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从Redis读写Java对象时，序列化和反序列化是应用程序的工作，上述代码使用JSON作为序列化方案，简单可靠。也可将相关序列化操作封装到<code>RedisService</code>中，这样可以提供更加通用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(String key, Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">set</span><span class="params">(String key, T value)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习-11">练习</h3>
<p>在Spring Boot中访问Redis。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/integration/redis/springboot-redis.zip">下载练习</a></p>
<h3 id="小结-11">小结</h3>
<p>Spring Boot默认使用Lettuce作为Redis客户端，同步使用时，应通过连接池提高效率。</p>
<h2 id="集成Artemis">集成Artemis</h2>
<p>ActiveMQ Artemis是一个JMS服务器，在<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/integration/jms/index.html">集成JMS</a>一节中我们已经详细讨论了如何在Spring中集成Artemis，本节我们讨论如何在Spring Boot中集成Artemis。</p>
<p>我们还是以实际工程为例，创建一个<code>springboot-jms</code>工程，引入的依赖除了<code>spring-boot-starter-web</code>，<code>spring-boot-starter-jdbc</code>等以外，新增<code>spring-boot-starter-artemis</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-artemis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同样无需指定版本号。</p>
<p>如何创建Artemis服务器我们已经在集成JMS一节中详细讲述了，此处不再重复。创建Artemis服务器后，我们在<code>application.yml</code>中加入相关配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">artemis:</span></span><br><span class="line">    <span class="comment"># 指定连接外部Artemis服务器，而不是启动嵌入式服务:</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">native</span></span><br><span class="line">    <span class="comment"># 服务器地址和端口号:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">61616</span></span><br><span class="line">    <span class="comment"># 连接用户名和口令由创建Artemis服务器时指定:</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">password</span></span><br></pre></td></tr></table></figure>
<p>和Spring版本的JMS代码相比，使用Spring Boot集成JMS时，只要引入了<code>spring-boot-starter-artemis</code>，Spring Boot会自动创建JMS相关的<code>ConnectionFactory</code>、<code>JmsListenerContainerFactory</code>、<code>JmsTemplate</code>等，无需我们再手动配置了。</p>
<p>发送消息时只需要引入<code>JmsTemplate</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessagingService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMailMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;</span><br><span class="line">        jmsTemplate.send(<span class="string">&quot;jms/queue/mail&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessageCreator</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> Message <span class="title function_">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException &#123;</span><br><span class="line">                <span class="keyword">return</span> session.createTextMessage(text);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接收消息时只需要标注<code>@JmsListener</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailMessageListener</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;jms/queue/mail&quot;, concurrency = &quot;10&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMailMessageReceived</span><span class="params">(Message message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;received message: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，应用程序收发消息的逻辑和Spring中使用JMS完全相同，只是通过Spring Boot，我们把工程简化到只需要设定Artemis相关配置。</p>
<h3 id="练习-12">练习</h3>
<p>在Spring Boot中使用Artemis。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/integration/artemis/springboot-jms.zip">下载练习</a></p>
<h3 id="小结-12">小结</h3>
<p>在Spring Boot中使用Artemis作为JMS服务时，只需引入<code>spring-boot-starter-artemis</code>依赖，即可直接使用JMS。</p>
<hr>
<hr>
<p>前面我们讲了ActiveMQ Artemis，它实现了JMS的消息服务协议。JMS是JavaEE的消息服务标准接口，但是，如果Java程序要和另一种语言编写的程序通过消息服务器进行通信，那么JMS就不太适合了。</p>
<p>AMQP是一种使用广泛的独立于语言的消息协议，它的全称是Advanced Message Queuing Protocol，即高级消息队列协议，它定义了一种二进制格式的消息流，任何编程语言都可以实现该协议。实际上，Artemis也支持AMQP，但实际应用最广泛的AMQP服务器是使用<a target="_blank" rel="noopener" href="https://www.erlang.org/">Erlang</a>编写的<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/">RabbitMQ</a>。</p>
<h3 id="安装RabbitMQ">安装RabbitMQ</h3>
<p>我们先从RabbitMQ的官网<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/download.html">下载</a>并安装RabbitMQ，安装和启动RabbitMQ请参考官方文档。要验证启动是否成功，可以访问RabbitMQ的管理后台<a target="_blank" rel="noopener" href="http://localhost:15672/">http://localhost:15672</a>，如能看到登录界面表示RabbitMQ启动成功：</p>
<p><img src="https://liaoxuefeng.com/books/java/springboot/integration/rabbitmq/rabbitmq.jpg" alt="rabbitmq-manage"></p>
<p>RabbitMQ后台管理的默认用户名和口令均为<code>guest</code>。</p>
<h3 id="AMQP协议">AMQP协议</h3>
<p>AMQP协议和前面我们介绍的JMS协议有所不同。在JMS中，有两种类型的消息通道：</p>
<ol>
<li>点对点的Queue，即Producer发送消息到指定的Queue，接收方从Queue收取消息；</li>
<li>一对多的Topic，即Producer发送消息到指定的Topic，任意多个在线的接收方均可从Topic获得一份完整的消息副本。</li>
</ol>
<p>但是AMQP协议比JMS要复杂一点，它只有Queue，没有Topic，并且引入了Exchange的概念。当Producer想要发送消息的时候，它将消息发送给Exchange，由Exchange将消息根据各种规则投递到一个或多个Queue：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                                    ┌───────┐</span><br><span class="line">                                ┌──▶│Queue-1│</span><br><span class="line">                  ┌──────────┐  │   └───────┘</span><br><span class="line">              ┌──▶│Exchange-1│──┤</span><br><span class="line">┌──────────┐  │   └──────────┘  │   ┌───────┐</span><br><span class="line">│Producer-1│──┤                 ├──▶│Queue-2│</span><br><span class="line">└──────────┘  │   ┌──────────┐  │   └───────┘</span><br><span class="line">              └──▶│Exchange-2│──┤</span><br><span class="line">                  └──────────┘  │   ┌───────┐</span><br><span class="line">                                └──▶│Queue-3│</span><br><span class="line">                                    └───────┘</span><br></pre></td></tr></table></figure>
<p>如果某个Exchange总是把消息发送到固定的Queue，那么这个消息通道就相当于JMS的Queue。如果某个Exchange把消息发送到多个Queue，那么这个消息通道就相当于JMS的Topic。和JMS的Topic相比，Exchange的投递规则更灵活，比如一个“登录成功”的消息被投递到Queue-1和Queue-2，而“登录失败”的消息则被投递到Queue-3。这些路由规则称之为Binding，通常都在RabbitMQ的管理后台设置。</p>
<p>我们以具体的业务为例子，在RabbitMQ中，首先创建3个Queue，分别用于发送邮件、短信和App通知：</p>
<p><img src="https://liaoxuefeng.com/books/java/springboot/integration/rabbitmq/queue.jpg" alt="queues"></p>
<p>创建Queue时注意到可配置为持久化（Durable）和非持久化（Transient），当Consumer不在线时，持久化的Queue会暂存消息，非持久化的Queue会丢弃消息。</p>
<p>紧接着，我们在Exchanges中创建一个Direct类型的Exchange，命名为<code>registration</code>，并添加如下两个Binding：</p>
<p><img src="https://liaoxuefeng.com/books/java/springboot/integration/rabbitmq/exchange.png" alt="exchange-registration"></p>
<p>上述Binding的规则就是：凡是发送到<code>registration</code>这个Exchange的消息，均被发送到<code>q_mail</code>和<code>q_sms</code>这两个Queue。</p>
<p>我们再创建一个Direct类型的Exchange，命名为<code>login</code>，并添加如下Binding：</p>
<p><img src="https://liaoxuefeng.com/books/java/springboot/integration/rabbitmq/exchange2.png" alt="exchange-login"></p>
<p>上述Binding的规则稍微复杂一点，当发送消息给<code>login</code>这个Exchange时，如果消息没有指定Routing Key，则被投递到<code>q_app</code>和<code>q_mail</code>，如果消息指定了Routing Key=“login_failed”，那么消息被投递到<code>q_sms</code>。</p>
<p>配置好RabbitMQ后，我们就可以基于Spring Boot开发AMQP程序。</p>
<h3 id="使用RabbitMQ">使用RabbitMQ</h3>
<p>我们首先创建Spring Boot工程<code>springboot-rabbitmq</code>，并添加如下依赖引入RabbitMQ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在<code>application.yml</code>中添加RabbitMQ相关配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br></pre></td></tr></table></figure>
<p>我们还需要在<code>Application</code>中添加一个<code>MessageConverter</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.MessageConverter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    MessageConverter <span class="title function_">createMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MessageConverter</code>用于将Java对象转换为RabbitMQ的消息。默认情况下，Spring Boot使用<code>SimpleMessageConverter</code>，只能发送<code>String</code>和<code>byte[]</code>类型的消息，不太方便。使用<code>Jackson2JsonMessageConverter</code>，我们就可以发送JavaBean对象，由Spring Boot自动序列化为JSON并以文本消息传递。</p>
<p>因为引入了starter，所有RabbitMQ相关的Bean均自动装配，我们需要在Producer注入的是<code>RabbitTemplate</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessagingService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendRegistrationMessage</span><span class="params">(RegistrationMessage msg)</span> &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;registration&quot;</span>, <span class="string">&quot;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendLoginMessage</span><span class="params">(LoginMessage msg)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> msg.success ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;login_failed&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;login&quot;</span>, routingKey, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送消息时，使用<code>convertAndSend(exchange, routingKey, message)</code>可以指定Exchange、Routing Key以及消息本身。这里传入JavaBean后会自动序列化为JSON文本。上述代码将<code>RegistrationMessage</code>发送到<code>registration</code>，将<code>LoginMessage</code>发送到<code>login</code>，并根据登录是否成功来指定Routing Key。</p>
<p>接收消息时，需要在消息处理的方法上标注<code>@RabbitListener</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueMessageListener</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_MAIL</span> <span class="operator">=</span> <span class="string">&quot;q_mail&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_SMS</span> <span class="operator">=</span> <span class="string">&quot;q_sms&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_APP</span> <span class="operator">=</span> <span class="string">&quot;q_app&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = QUEUE_MAIL)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRegistrationMessageFromMailQueue</span><span class="params">(RegistrationMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;queue &#123;&#125; received registration message: &#123;&#125;&quot;</span>, QUEUE_MAIL, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = QUEUE_SMS)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRegistrationMessageFromSmsQueue</span><span class="params">(RegistrationMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;queue &#123;&#125; received registration message: &#123;&#125;&quot;</span>, QUEUE_SMS, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = QUEUE_MAIL)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoginMessageFromMailQueue</span><span class="params">(LoginMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;queue &#123;&#125; received message: &#123;&#125;&quot;</span>, QUEUE_MAIL, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = QUEUE_SMS)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoginMessageFromSmsQueue</span><span class="params">(LoginMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;queue &#123;&#125; received message: &#123;&#125;&quot;</span>, QUEUE_SMS, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = QUEUE_APP)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoginMessageFromAppQueue</span><span class="params">(LoginMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;queue &#123;&#125; received message: &#123;&#125;&quot;</span>, QUEUE_APP, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码一共定义了5个Consumer，监听3个Queue。</p>
<p>启动应用程序，我们注册一个新用户，然后发送一条<code>RegistrationMessage</code>消息。此时，根据<code>registration</code>这个Exchange的设定，我们会在两个Queue收到消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">... c.i.learnjava.service.UserService        : try register by bob@example.com...</span><br><span class="line">... c.i.learnjava.web.UserController         : user registered: bob@example.com</span><br><span class="line">... c.i.l.service.QueueMessageListener       : queue q_mail received registration message: [RegistrationMessage: email=bob@example.com, name=Bob, timestamp=1594559871495]</span><br><span class="line">... c.i.l.service.QueueMessageListener       : queue q_sms received registration message: [RegistrationMessage: email=bob@example.com, name=Bob, timestamp=1594559871495]</span><br></pre></td></tr></table></figure>
<p>当我们登录失败时，发送<code>LoginMessage</code>并设定Routing Key为<code>login_failed</code>，此时，只有<code>q_sms</code>会收到消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... c.i.learnjava.service.UserService        : try login by bob@example.com...</span><br><span class="line">... c.i.l.service.QueueMessageListener       : queue q_sms received message: [LoginMessage: email=bob@example.com, name=(unknown), success=false, timestamp=1594559886722]</span><br></pre></td></tr></table></figure>
<p>登录成功后，发送<code>LoginMessage</code>，此时，<code>q_mail</code>和<code>q_app</code>将收到消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">... c.i.learnjava.service.UserService        : try login by bob@example.com...</span><br><span class="line">... c.i.l.service.QueueMessageListener       : queue q_mail received message: [LoginMessage: email=bob@example.com, name=Bob, success=true, timestamp=1594559895251]</span><br><span class="line">... c.i.l.service.QueueMessageListener       : queue q_app received message: [LoginMessage: email=bob@example.com, name=Bob, success=true, timestamp=1594559895251]</span><br></pre></td></tr></table></figure>
<p>RabbitMQ还提供了使用Topic的Exchange（此Topic指消息的标签，并非JMS的Topic概念），可以使用<code>*</code>进行匹配并路由。可见，掌握RabbitMQ的核心是理解其消息的路由规则。</p>
<p>直接指定一个Queue并投递消息也是可以的，此时指定Routing Key为Queue的名称即可，因为RabbitMQ提供了一个<code>default exchange</code>用于根据Routing Key查找Queue并直接投递消息到指定的Queue。但是要实现一对多的投递就必须自己配置Exchange。</p>
<h3 id="练习-13">练习</h3>
<p>在Spring Boot中使用RabbitMQ。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/integration/rabbitmq/springboot-rabbitmq.zip">下载练习</a></p>
<h3 id="小结-13">小结</h3>
<p>Spring Boot提供了AMQP的集成，默认使用RabbitMQ作为AMQP消息服务器。</p>
<p>使用RabbitMQ发送消息时，理解Exchange如何路由至一个或多个Queue至关重要。</p>
<p>我们在前面已经介绍了JMS和AMQP，JMS是JavaEE的标准消息接口，Artemis是一个JMS实现产品，AMQP是跨语言的一个标准消息接口，RabbitMQ是一个AMQP实现产品。</p>
<p>Kafka也是一个消息服务器，它的特点一是快，二是有巨大的吞吐量，那么Kafka实现了什么标准消息接口呢？</p>
<p>Kafka没有实现任何标准的消息接口，它自己提供的API就是Kafka的接口。</p>
<blockquote>
<p>哥没有实现任何标准，哥自己就是标准。</p>
<p>—— Kafka</p>
</blockquote>
<p>Kafka本身是Scala编写的，运行在JVM之上。Producer和Consumer都通过Kafka的客户端使用网络来与之通信。从逻辑上讲，Kafka设计非常简单，它只有一种类似JMS的Topic的消息通道：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                           ┌──────────┐</span><br><span class="line">                       ┌──▶│Consumer-1│</span><br><span class="line">                       │   └──────────┘</span><br><span class="line">┌────────┐    ┌─────┐  │   ┌──────────┐</span><br><span class="line">│Producer│───▶│Topic│──┼──▶│Consumer-2│</span><br><span class="line">└────────┘    └─────┘  │   └──────────┘</span><br><span class="line">                       │   ┌──────────┐</span><br><span class="line">                       └──▶│Consumer-3│</span><br><span class="line">                           └──────────┘</span><br></pre></td></tr></table></figure>
<p>那么Kafka如何支持十万甚至百万的并发呢？答案是分区。Kafka的一个Topic可以有一个至多个Partition，并且可以分布到多台机器上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">            ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line">             Topic</span><br><span class="line">            │                   │</span><br><span class="line">                ┌───────────┐        ┌──────────┐</span><br><span class="line">            │┌─▶│Partition-1│──┐│┌──▶│Consumer-1│</span><br><span class="line">             │  └───────────┘  │ │   └──────────┘</span><br><span class="line">┌────────┐  ││  ┌───────────┐  │││   ┌──────────┐</span><br><span class="line">│Producer│───┼─▶│Partition-2│──┼─┼──▶│Consumer-2│</span><br><span class="line">└────────┘  ││  └───────────┘  │││   └──────────┘</span><br><span class="line">             │  ┌───────────┐  │ │   ┌──────────┐</span><br><span class="line">            │└─▶│Partition-3│──┘│└──▶│Consumer-3│</span><br><span class="line">                └───────────┘        └──────────┘</span><br><span class="line">            └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>
<p>Kafka只保证在一个Partition内部，消息是有序的，但是，存在多个Partition的情况下，Producer发送的3个消息会依次发送到Partition-1、Partition-2和Partition-3，Consumer从3个Partition接收的消息并不一定是Producer发送的顺序，因此，多个Partition只能保证接收消息大概率按发送时间有序，并不能保证完全按Producer发送的顺序。这一点在使用Kafka作为消息服务器时要特别注意，对发送顺序有严格要求的Topic只能有一个Partition。</p>
<p>Kafka的另一个特点是消息发送和接收都尽量使用批处理，一次处理几十甚至上百条消息，比一次一条效率要高很多。</p>
<p>最后要注意的是消息的持久性。Kafka总是将消息写入Partition对应的文件，消息保存多久取决于服务器的配置，可以按照时间删除（默认3天），也可以按照文件大小删除，因此，只要Consumer在离线期内的消息还没有被删除，再次上线仍然可以接收到完整的消息流。这一功能实际上是客户端自己实现的，客户端会存储它接收到的最后一个消息的offsetId，再次上线后按上次的offsetId查询。offsetId是Kafka标识某个Partion的每一条消息的递增整数，客户端通常将它存储在ZooKeeper中。</p>
<p>有了Kafka消息设计的基本概念，我们来看看如何在Spring Boot中使用Kafka。</p>
<h3 id="安装Kafka">安装Kafka</h3>
<p>首先从Kafka官网<a target="_blank" rel="noopener" href="https://kafka.apache.org/downloads">下载</a>最新版Kafaka，解压后在<code>bin</code>目录找到两个文件：</p>
<ul>
<li><code>zookeeper-server-start.sh</code>：启动ZooKeeper（已内置在Kafka中）；</li>
<li><code>kafka-server-start.sh</code>：启动Kafka。</li>
</ul>
<p>先启动ZooKeeper：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./zookeeper-server-start.sh ../config/zookeeper.properties </span><br></pre></td></tr></table></figure>
<p>再启动Kafka：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-server-start.sh ../config/server.properties</span><br></pre></td></tr></table></figure>
<p>看到如下输出表示启动成功：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... INFO [KafkaServer id=0] started (kafka.server.KafkaServer)</span><br></pre></td></tr></table></figure>
<p>如果要关闭Kafka和ZooKeeper，依次按Ctrl-C退出即可。注意这是在本地开发时使用Kafka的方式，线上Kafka服务推荐使用云服务厂商托管模式（AWS的MSK，阿里云的消息队列Kafka版）。</p>
<h3 id="使用Kafka">使用Kafka</h3>
<p>在Spring Boot中使用Kafka，首先要引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意这个依赖是<code>spring-kafka</code>项目提供的。</p>
<p>然后，在<code>application.yml</code>中添加Kafka配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="string">localhost:9092</span></span><br><span class="line">    <span class="attr">consumer:</span></span><br><span class="line">      <span class="attr">auto-offset-reset:</span> <span class="string">latest</span></span><br><span class="line">      <span class="attr">max-poll-records:</span> <span class="number">100</span></span><br><span class="line">      <span class="attr">max-partition-fetch-bytes:</span> <span class="number">1000000</span></span><br></pre></td></tr></table></figure>
<p>除了<code>bootstrap-servers</code>必须指定外，<code>consumer</code>相关的配置项均为调优选项。例如，<code>max-poll-records</code>表示一次最多抓取100条消息。配置名称去哪里看？IDE里定义一个<code>KafkaProperties.Consumer</code>的变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KafkaProperties.<span class="type">Consumer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>然后按住Ctrl查看源码即可。</p>
<h3 id="发送消息">发送消息</h3>
<p>Spring Boot自动为我们创建一个<code>KafkaTemplate</code>用于发送消息。注意到这是一个泛型类，而默认配置总是使用<code>String</code>作为Kafka消息的类型，所以注入<code>KafkaTemplate&lt;String, String&gt;</code>即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessagingService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendRegistrationMessage</span><span class="params">(RegistrationMessage msg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        send(<span class="string">&quot;topic_registration&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendLoginMessage</span><span class="params">(LoginMessage msg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        send(<span class="string">&quot;topic_login&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String topic, Object msg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ProducerRecord&lt;String, String&gt; pr = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(topic, objectMapper.writeValueAsString(msg));</span><br><span class="line">        pr.headers().add(<span class="string">&quot;type&quot;</span>, msg.getClass().getName().getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        kafkaTemplate.send(pr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送消息时，需指定Topic名称，消息正文。为了发送一个JavaBean，这里我们没有使用<code>MessageConverter</code>来转换JavaBean，而是直接把消息类型作为Header添加到消息中，Header名称为<code>type</code>，值为Class全名。消息正文是序列化的JSON。</p>
<h3 id="接收消息">接收消息</h3>
<p>接收消息可以使用<code>@KafkaListener</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicMessageListener</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = &quot;topic_registration&quot;, groupId = &quot;group1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRegistrationMessage</span><span class="params">(<span class="meta">@Payload</span> String message, <span class="meta">@Header(&quot;type&quot;)</span> String type)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">RegistrationMessage</span> <span class="variable">msg</span> <span class="operator">=</span> objectMapper.readValue(message, getType(type));</span><br><span class="line">        logger.info(<span class="string">&quot;received registration message: &#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = &quot;topic_login&quot;, groupId = &quot;group1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoginMessage</span><span class="params">(<span class="meta">@Payload</span> String message, <span class="meta">@Header(&quot;type&quot;)</span> String type)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">LoginMessage</span> <span class="variable">msg</span> <span class="operator">=</span> objectMapper.readValue(message, getType(type));</span><br><span class="line">        logger.info(<span class="string">&quot;received login message: &#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = &quot;topic_login&quot;, groupId = &quot;group2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processLoginMessage</span><span class="params">(<span class="meta">@Payload</span> String message, <span class="meta">@Header(&quot;type&quot;)</span> String type)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">LoginMessage</span> <span class="variable">msg</span> <span class="operator">=</span> objectMapper.readValue(message, getType(type));</span><br><span class="line">        logger.info(<span class="string">&quot;process login message: &#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; Class&lt;T&gt; <span class="title function_">getType</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> use cache:</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Class&lt;T&gt;) Class.forName(type);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在接收消息的方法中，使用<code>@Payload</code>表示传入的是消息正文，使用<code>@Header</code>可传入消息的指定Header，这里传入<code>@Header(&quot;type&quot;)</code>，就是我们发送消息时指定的Class全名。接收消息时，我们需要根据Class全名来反序列化获得JavaBean。</p>
<p>上述代码一共定义了3个Listener，其中有两个方法监听的是同一个Topic，但它们的Group ID不同。假设Producer发送的消息流是A、B、C、D，Group ID不同表示这是两个不同的Consumer，它们将分别收取完整的消息流，即各自均收到A、B、C、D。Group ID相同的多个Consumer实际上被视作一个Consumer，即如果有两个Group ID相同的Consumer，那么它们各自收到的很可能是A、C和B、D。</p>
<p>运行应用程序，注册新用户后，观察日志输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">... c.i.learnjava.service.UserService        : try register by bob@example.com...</span><br><span class="line">... c.i.learnjava.web.UserController         : user registered: bob@example.com</span><br><span class="line">... c.i.l.service.TopicMessageListener       : received registration message: [RegistrationMessage: email=bob@example.com, name=Bob, timestamp=1594637517458]</span><br></pre></td></tr></table></figure>
<p>用户登录后，观察日志输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">... c.i.learnjava.service.UserService        : try login by bob@example.com...</span><br><span class="line">... c.i.l.service.TopicMessageListener       : received login message: [LoginMessage: email=bob@example.com, name=Bob, success=true, timestamp=1594637523470]</span><br><span class="line">... c.i.l.service.TopicMessageListener       : process login message: [LoginMessage: email=bob@example.com, name=Bob, success=true, timestamp=1594637523470]</span><br></pre></td></tr></table></figure>
<p>因为Group ID不同，同一个消息被两个Consumer分别独立接收。如果把Group ID改为相同，那么同一个消息只会被两者之一接收。</p>
<p>有细心的童鞋可能会问，在Kafka中是如何创建Topic的？又如何指定某个Topic的分区数量？</p>
<p>实际上开发使用的Kafka默认允许自动创建Topic，创建Topic时默认的分区数量是2，可以通过<code>server.properties</code>修改默认分区数量。</p>
<p>在生产环境中通常会关闭自动创建功能，Topic需要由运维人员先创建好。和RabbitMQ相比，Kafka并不提供网页版管理后台，管理Topic需要使用命令行，比较繁琐，只有云服务商通常会提供更友好的管理后台。</p>
<h3 id="练习-14">练习</h3>
<p>在Spring Boot中使用Kafka。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/integration/kafka/springboot-kafka.zip">下载练习</a></p>
<h3 id="小结-14">小结</h3>
<p>Spring Boot通过<code>KafkaTemplate</code>发送消息，通过<code>@KafkaListener</code>接收消息；</p>
<p>配置Consumer时，指定Group ID非常重要。</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">標籤</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/Java/" rel="tag">Java</a> <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/Spring-Boot/" rel="tag">Spring Boot</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../JavaScript/JavaScript-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"
                    data-tooltip="JavaScript-快速入门"
                    aria-label="上一篇: JavaScript-快速入门"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JAVA-Spring%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/"
                    data-tooltip="JAVA-Spring开发-集成第三方组件"
                    aria-label="下一篇: JAVA-Spring开发-集成第三方组件"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/26/java/JAVA-Spring-Boot%E5%BC%80%E5%8F%91/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/26/java/JAVA-Spring-Boot%E5%BC%80%E5%8F%91/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/26/java/JAVA-Spring-Boot%E5%BC%80%E5%8F%91/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/26/java/JAVA-Spring-Boot%E5%BC%80%E5%8F%91/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../JavaScript/JavaScript-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"
                    data-tooltip="JavaScript-快速入门"
                    aria-label="上一篇: JavaScript-快速入门"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JAVA-Spring%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/"
                    data-tooltip="JAVA-Spring开发-集成第三方组件"
                    aria-label="下一篇: JAVA-Spring开发-集成第三方组件"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/26/java/JAVA-Spring-Boot%E5%BC%80%E5%8F%91/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/26/java/JAVA-Spring-Boot%E5%BC%80%E5%8F%91/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/26/java/JAVA-Spring-Boot%E5%BC%80%E5%8F%91/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/26/java/JAVA-Spring-Boot%E5%BC%80%E5%8F%91/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/26/java/JAVA-Spring-Boot%E5%BC%80%E5%8F%91/"
                        aria-label="分享到 Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/26/java/JAVA-Spring-Boot%E5%BC%80%E5%8F%91/"
                        aria-label="分享到 Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/26/java/JAVA-Spring-Boot%E5%BC%80%E5%8F%91/"
                        aria-label="global.share_on_linkedin"
                    >
                        <i class="fab fa-linkedin" aria-hidden="true"></i><span>global.share_on_linkedin</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/26/java/JAVA-Spring-Boot%E5%BC%80%E5%8F%91/"
                        aria-label="分享到 Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 134 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
