
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>JAVA-Spring开发-访问数据库 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg"},"articleBody":"数据库基本上是现代应用程序的标准存储，绝大多数程序都把自己的业务数据存储在关系数据库中，可见，访问数据库几乎是所有应用程序必备能力。\n我们在前面已经介绍了Java程序访问数据库的标准接口JDBC，它的实现方式非常简洁，即：Java标准库定义接口，各数据库厂商以“驱动”的形式实现接口。应用程序要使用哪个数据库，就把该数据库厂商的驱动以jar包形式引入进来，同时自身仅使用JDBC接口，编译期并不需要特定厂商的驱动。\n使用JDBC虽然简单，但代码比较繁琐。Spring为了简化数据库访问，主要做了以下几点工作：\n\n提供了简化的访问JDBC的模板类，不必手动释放资源；\n提供了一个统一的DAO类以实现Data Access Object模式；\n把SQLException封装为DataAccessException，这个异常是一个RuntimeException，并且让我们能区分SQL异常的原因，例如，DuplicateKeyException表示违反了一个唯一约束；\n能方便地集成Hibernate、JPA和MyBatis这些数据库访问框架。\n\n本章我们将详细讲解在Spring中访问数据库的最佳实践。\n我们在前面介绍JDBC编程时已经讲过，Java程序使用JDBC接口访问关系数据库的时候，需要以下几步：\n\n创建全局DataSource实例，表示数据库连接池；\n在需要读写数据库的方法内部，按如下步骤访问数据库：\n\n从全局DataSource实例获取Connection实例；\n通过Connection实例创建PreparedStatement实例；\n执行SQL语句，如果是查询，则通过ResultSet读取结果集，如果是修改，则获得int结果。\n\n\n\n正确编写JDBC代码的关键是使用try ... finally释放资源，涉及到事务的代码需要正确提交或回滚事务。\n在Spring使用JDBC，首先我们通过IoC容器创建并管理一个DataSource实例，然后，Spring提供了一个JdbcTemplate，可以方便地让我们操作JDBC，因此，通常情况下，我们会实例化一个JdbcTemplate。顾名思义，这个类主要使用了Template模式。\n编写示例代码或者测试代码时，我们强烈推荐使用HSQLDB这个数据库，它是一个用Java编写的关系数据库，可以以内存模式或者文件模式运行，本身只有一个jar包，非常适合演示代码或者测试代码。\n我们以实际工程为例，先创建Maven工程spring-data-jdbc，然后引入以下依赖：\n\norg.springframework:spring-context:6.0.0\norg.springframework:spring-jdbc:6.0.0\njakarta.annotation:jakarta.annotation-api:2.1.1\ncom.zaxxer:HikariCP:5.0.1\norg.hsqldb:hsqldb:2.7.1\n\n在AppConfig中，我们需要创建以下几个必须的Bean：\n12345678910111213141516171819202122232425262728293031@Configuration@ComponentScan@PropertySource(&quot;jdbc.properties&quot;)public class AppConfig &#123;    @Value(&quot;$&#123;jdbc.url&#125;&quot;)    String jdbcUrl;    @Value(&quot;$&#123;jdbc.username&#125;&quot;)    String jdbcUsername;    @Value(&quot;$&#123;jdbc.password&#125;&quot;)    String jdbcPassword;    @Bean    DataSource createDataSource() &#123;        HikariConfig config = new HikariConfig();        config.setJdbcUrl(jdbcUrl);        config.setUsername(jdbcUsername);        config.setPassword(jdbcPassword);        config.addDataSourceProperty(&quot;autoCommit&quot;, &quot;true&quot;);        config.addDataSourceProperty(&quot;connectionTimeout&quot;, &quot;5&quot;);        config.addDataSourceProperty(&quot;idleTimeout&quot;, &quot;60&quot;);        return new HikariDataSource(config);    &#125;    @Bean    JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) &#123;        return new JdbcTemplate(dataSource);    &#125;&#125;\n在上述配置中：\n\n通过@PropertySource(&quot;jdbc.properties&quot;)读取数据库配置文件；\n通过@Value(&quot;$&#123;jdbc.url&#125;&quot;)注入配置文件的相关配置；\n创建一个DataSource实例，它的实际类型是HikariDataSource，创建时需要用到注入的配置；\n创建一个JdbcTemplate实例，它需要注入DataSource，这是通过方法参数完成注入的。\n\n最后，针对HSQLDB写一个配置文件jdbc.properties：\n123456# 数据库文件名为testdb:jdbc.url=jdbc:hsqldb:file:testdb# Hsqldb默认的用户名是sa，口令是空字符串:jdbc.username=sajdbc.password=\n可以通过HSQLDB自带的工具来初始化数据库表，这里我们写一个Bean，在Spring容器启动时自动创建一个users表：\n123456789101112131415@Componentpublic class DatabaseInitializer &#123;    @Autowired    JdbcTemplate jdbcTemplate;    @PostConstruct    public void init() &#123;        jdbcTemplate.update(&quot;CREATE TABLE IF NOT EXISTS users (&quot; //                + &quot;id BIGINT IDENTITY NOT NULL PRIMARY KEY, &quot; //                + &quot;email VARCHAR(100) NOT NULL, &quot; //                + &quot;password VARCHAR(100) NOT NULL, &quot; //                + &quot;name VARCHAR(100) NOT NULL, &quot; //                + &quot;UNIQUE (email))&quot;);    &#125;&#125;\n现在，所有准备工作都已完毕。我们只需要在需要访问数据库的Bean中，注入JdbcTemplate即可：\n123456@Componentpublic class UserService &#123;    @Autowired    JdbcTemplate jdbcTemplate;    ...&#125;\nJdbcTemplate用法\nSpring提供的JdbcTemplate采用Template模式，提供了一系列以回调为特点的工具方法，目的是避免繁琐的try...catch语句。\n我们以具体的示例来说明JdbcTemplate的用法。\n首先我们看T execute(ConnectionCallback&lt;T&gt; action)方法，它提供了Jdbc的Connection供我们使用：\n1234567891011121314151617181920public User getUserById(long id) &#123;    // 注意传入的是ConnectionCallback:    return jdbcTemplate.execute((Connection conn) -&gt; &#123;        // 可以直接使用conn实例，不要释放它，回调结束后JdbcTemplate自动释放:        // 在内部手动创建的PreparedStatement、ResultSet必须用try(...)释放:        try (var ps = conn.prepareStatement(&quot;SELECT * FROM users WHERE id = ?&quot;)) &#123;            ps.setObject(1, id);            try (var rs = ps.executeQuery()) &#123;                if (rs.next()) &#123;                    return new User( // new User object:                            rs.getLong(&quot;id&quot;), // id                            rs.getString(&quot;email&quot;), // email                            rs.getString(&quot;password&quot;), // password                            rs.getString(&quot;name&quot;)); // name                &#125;                throw new RuntimeException(&quot;user not found by id.&quot;);            &#125;        &#125;    &#125;);&#125;\n也就是说，上述回调方法允许获取Connection，然后做任何基于Connection的操作。\n我们再看T execute(String sql, PreparedStatementCallback&lt;T&gt; action)的用法：\n1234567891011121314151617public User getUserByName(String name) &#123;    // 需要传入SQL语句，以及PreparedStatementCallback:    return jdbcTemplate.execute(&quot;SELECT * FROM users WHERE name = ?&quot;, (PreparedStatement ps) -&gt; &#123;        // PreparedStatement实例已经由JdbcTemplate创建，并在回调后自动释放:        ps.setObject(1, name);        try (var rs = ps.executeQuery()) &#123;            if (rs.next()) &#123;                return new User( // new User object:                        rs.getLong(&quot;id&quot;), // id                        rs.getString(&quot;email&quot;), // email                        rs.getString(&quot;password&quot;), // password                        rs.getString(&quot;name&quot;)); // name            &#125;            throw new RuntimeException(&quot;user not found by id.&quot;);        &#125;    &#125;);&#125;\n最后，我们看T queryForObject(String sql, RowMapper&lt;T&gt; rowMapper, Object... args)方法：\n12345678910111213public User getUserByEmail(String email) &#123;    // 传入SQL，参数和RowMapper实例:    return jdbcTemplate.queryForObject(&quot;SELECT * FROM users WHERE email = ?&quot;,            (ResultSet rs, int rowNum) -&gt; &#123;                // 将ResultSet的当前行映射为一个JavaBean:                return new User( // new User object:                        rs.getLong(&quot;id&quot;), // id                        rs.getString(&quot;email&quot;), // email                        rs.getString(&quot;password&quot;), // password                        rs.getString(&quot;name&quot;)); // name            &#125;,            email);&#125;\n在queryForObject()方法中，传入SQL以及SQL参数后，JdbcTemplate会自动创建PreparedStatement，自动执行查询并返回ResultSet，我们提供的RowMapper需要做的事情就是把ResultSet的当前行映射成一个JavaBean并返回。整个过程中，使用Connection、PreparedStatement和ResultSet都不需要我们手动管理。\nRowMapper不一定返回JavaBean，实际上它可以返回任何Java对象。例如，使用SELECT COUNT(*)查询时，可以返回Long：\n123456public long getUsers() &#123;    return jdbcTemplate.queryForObject(&quot;SELECT COUNT(*) FROM users&quot;, (ResultSet rs, int rowNum) -&gt; &#123;        // SELECT COUNT(*)查询只有一列，取第一列数据:        return rs.getLong(1);    &#125;);&#125;\n如果我们期望返回多行记录，而不是一行，可以用query()方法：\n1234567public List&lt;User&gt; getUsers(int pageIndex) &#123;    int limit = 100;    int offset = limit * (pageIndex - 1);    return jdbcTemplate.query(&quot;SELECT * FROM users LIMIT ? OFFSET ?&quot;,            new BeanPropertyRowMapper&lt;&gt;(User.class),            limit, offset);&#125;\n上述query()方法传入的参数仍然是SQL、SQL参数以及RowMapper实例。这里我们直接使用Spring提供的BeanPropertyRowMapper。如果数据库表的结构恰好和JavaBean的属性名称一致，那么BeanPropertyRowMapper就可以直接把一行记录按列名转换为JavaBean。\n如果我们执行的不是查询，而是插入、更新和删除操作，那么需要使用update()方法：\n123456public void updateUser(User user) &#123;    // 传入SQL，SQL参数，返回更新的行数:    if (1 != jdbcTemplate.update(&quot;UPDATE users SET name = ? WHERE id = ?&quot;, user.getName(), user.getId())) &#123;        throw new RuntimeException(&quot;User not found by id&quot;);    &#125;&#125;\n只有一种INSERT操作比较特殊，那就是如果某一列是自增列（例如自增主键），通常，我们需要获取插入后的自增值。JdbcTemplate提供了一个KeyHolder来简化这一操作：\n12345678910111213141516171819202122public User register(String email, String password, String name) &#123;    // 创建一个KeyHolder:    KeyHolder holder = new GeneratedKeyHolder();    if (1 != jdbcTemplate.update(        // 参数1:PreparedStatementCreator        (conn) -&gt; &#123;            // 创建PreparedStatement时，必须指定RETURN_GENERATED_KEYS:            var ps = conn.prepareStatement(&quot;INSERT INTO users(email, password, name) VALUES(?, ?, ?)&quot;,                    Statement.RETURN_GENERATED_KEYS);            ps.setObject(1, email);            ps.setObject(2, password);            ps.setObject(3, name);            return ps;        &#125;,        // 参数2:KeyHolder        holder)    ) &#123;        throw new RuntimeException(&quot;Insert failed.&quot;);    &#125;    // 从KeyHolder中获取返回的自增值:    return new User(holder.getKey().longValue(), email, password, name);&#125;\nJdbcTemplate还有许多重载方法，这里我们不一一介绍。需要强调的是，JdbcTemplate只是对JDBC操作的一个简单封装，它的目的是尽量减少手动编写try(resource) &#123;...&#125;的代码，对于查询，主要通过RowMapper实现了JDBC结果集到Java对象的转换。\n我们总结一下JdbcTemplate的用法，那就是：\n\n针对简单查询，优选query()和queryForObject()，因为只需提供SQL语句、参数和RowMapper；\n针对更新操作，优选update()，因为只需提供SQL语句和参数；\n任何复杂的操作，最终也可以通过execute(ConnectionCallback)实现，因为拿到Connection就可以做任何JDBC操作。\n\n实际上我们使用最多的仍然是各种查询。如果在设计表结构的时候，能够和JavaBean的属性一一对应，那么直接使用BeanPropertyRowMapper就很方便。如果表结构和JavaBean不一致怎么办？那就需要稍微改写一下查询，使结果集的结构和JavaBean保持一致。\n例如，表的列名是office_address，而JavaBean属性是workAddress，就需要指定别名，改写查询如下：\n1SELECT id, email, office_address AS workAddress, name FROM users WHERE email = ?\n练习\n使用JdbcTemplate。\n下载练习\n小结\nSpring提供了JdbcTemplate来简化JDBC操作；\n使用JdbcTemplate时，根据需要优先选择高级方法；\n任何JDBC操作都可以使用保底的execute(ConnectionCallback)方法。\n使用Spring操作JDBC虽然方便，但是我们在前面讨论JDBC的时候，讲到过JDBC事务，如果要在Spring中操作事务，没必要手写JDBC事务，可以使用Spring提供的高级接口来操作事务。\nSpring提供了一个PlatformTransactionManager来表示事务管理器，所有的事务都由它负责管理。而事务由TransactionStatus表示。如果手写事务代码，使用try...catch如下：\n1234567891011121314TransactionStatus tx = null;try &#123;    // 开启事务:    tx = txManager.getTransaction(new DefaultTransactionDefinition());    // 相关JDBC操作:    jdbcTemplate.update(&quot;...&quot;);    jdbcTemplate.update(&quot;...&quot;);    // 提交事务:    txManager.commit(tx);&#125; catch (RuntimeException e) &#123;    // 回滚事务:    txManager.rollback(tx);    throw e;&#125;\nSpring为啥要抽象出PlatformTransactionManager和TransactionStatus？原因是JavaEE除了提供JDBC事务外，它还支持分布式事务JTA（Java Transaction API）。分布式事务是指多个数据源（比如多个数据库，多个消息系统）要在分布式环境下实现事务的时候，应该怎么实现。分布式事务实现起来非常复杂，简单地说就是通过一个分布式事务管理器实现两阶段提交，但本身数据库事务就不快，基于数据库事务实现的分布式事务就慢得难以忍受，所以使用率不高。\nSpring为了同时支持JDBC和JTA两种事务模型，就抽象出PlatformTransactionManager。因为我们的代码只需要JDBC事务，因此，在AppConfig中，需要再定义一个PlatformTransactionManager对应的Bean，它的实际类型是DataSourceTransactionManager：\n12345678910@Configuration@ComponentScan@PropertySource(&quot;jdbc.properties&quot;)public class AppConfig &#123;    ...    @Bean    PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) &#123;        return new DataSourceTransactionManager(dataSource);    &#125;&#125;\n使用编程的方式使用Spring事务仍然比较繁琐，更好的方式是通过声明式事务来实现。使用声明式事务非常简单，除了在AppConfig中追加一个上述定义的PlatformTransactionManager外，再加一个@EnableTransactionManagement就可以启用声明式事务：\n1234567@Configuration@ComponentScan@EnableTransactionManagement // 启用声明式@PropertySource(&quot;jdbc.properties&quot;)public class AppConfig &#123;    ...&#125;\n然后，对需要事务支持的方法，加一个@Transactional注解：\n12345678@Componentpublic class UserService &#123;    // 此public方法自动具有事务支持:    @Transactional    public User register(String email, String password, String name) &#123;       ...    &#125;&#125;\n或者更简单一点，直接在Bean的class处加上，表示所有public方法都具有事务支持：\n12345@Component@Transactionalpublic class UserService &#123;    ...&#125;\nSpring对一个声明式事务的方法，如何开启事务支持？原理仍然是AOP代理，即通过自动创建Bean的Proxy实现：\n1234567891011121314151617public class UserService$$EnhancerBySpringCGLIB extends UserService &#123;    UserService target = ...    PlatformTransactionManager txManager = ...    public User register(String email, String password, String name) &#123;        TransactionStatus tx = null;        try &#123;            tx = txManager.getTransaction(new DefaultTransactionDefinition());            target.register(email, password, name);            txManager.commit(tx);        &#125; catch (RuntimeException e) &#123;            txManager.rollback(tx);            throw e;        &#125;    &#125;    ...&#125;\n注意：声明了@EnableTransactionManagement后，不必额外添加@EnableAspectJAutoProxy。\n回滚事务\n默认情况下，如果发生了RuntimeException，Spring的声明式事务将自动回滚。在一个事务方法中，如果程序判断需要回滚事务，只需抛出RuntimeException，例如：\n123456789@Transactionalpublic buyProducts(long productId, int num) &#123;    ...    if (store &lt; num) &#123;        // 库存不够，购买失败:        throw new IllegalArgumentException(&quot;No enough products&quot;);    &#125;    ...&#125;\n如果要针对Checked Exception回滚事务，需要在@Transactional注解中写出来：\n1234@Transactional(rollbackFor = &#123;RuntimeException.class, IOException.class&#125;)public buyProducts(long productId, int num) throws IOException &#123;    ...&#125;\n上述代码表示在抛出RuntimeException或IOException时，事务将回滚。\n为了简化代码，我们强烈建议业务异常体系从RuntimeException派生，这样就不必声明任何特殊异常即可让Spring的声明式事务正常工作：\n1234567891011public class BusinessException extends RuntimeException &#123;    ...&#125;public class LoginException extends BusinessException &#123;    ...&#125;public class PaymentException extends BusinessException &#123;    ...&#125;\n事务边界\n在使用事务的时候，明确事务边界非常重要。对于声明式事务，例如，下面的register()方法：\n1234567@Componentpublic class UserService &#123;    @Transactional    public User register(String email, String password, String name) &#123; // 事务开始       ...    &#125; // 事务结束&#125;\n它的事务边界就是register()方法开始和结束。\n类似的，一个负责给用户增加积分的addBonus()方法：\n1234567@Componentpublic class BonusService &#123;    @Transactional    public void addBonus(long userId, int bonus) &#123; // 事务开始       ...    &#125; // 事务结束&#125;\n它的事务边界就是addBonus()方法开始和结束。\n在现实世界中，问题总是要复杂一点点。用户注册后，能自动获得100积分，因此，实际代码如下：\n12345678910111213@Componentpublic class UserService &#123;    @Autowired    BonusService bonusService;    @Transactional    public User register(String email, String password, String name) &#123;        // 插入用户记录:        User user = jdbcTemplate.insert(&quot;...&quot;);        // 增加100积分:        bonusService.addBonus(user.id, 100);    &#125;&#125;\n现在问题来了：调用方（比如RegisterController）调用UserService.register()这个事务方法，它在内部又调用了BonusService.addBonus()这个事务方法，一共有几个事务？如果addBonus()抛出了异常需要回滚事务，register()方法的事务是否也要回滚？\n问题的复杂度是不是一下子提高了10倍？\n事务传播\n要解决上面的问题，我们首先要定义事务的传播模型。\n假设用户注册的入口是RegisterController，它本身没有事务，仅仅是调用UserService.register()这个事务方法：\n1234567891011121314@Controllerpublic class RegisterController &#123;    @Autowired    UserService userService;    @PostMapping(&quot;/register&quot;)    public ModelAndView doRegister(HttpServletRequest req) &#123;        String email = req.getParameter(&quot;email&quot;);        String password = req.getParameter(&quot;password&quot;);        String name = req.getParameter(&quot;name&quot;);        User user = userService.register(email, password, name);        return ...    &#125;&#125;\n因此，UserService.register()这个事务方法的起始和结束，就是事务的范围。\n我们需要关心的问题是，在UserService.register()这个事务方法内，调用BonusService.addBonus()，我们期待的事务行为是什么：\n1234567@Transactionalpublic User register(String email, String password, String name) &#123;    // 事务已开启:    User user = jdbcTemplate.insert(&quot;...&quot;);    // ???:    bonusService.addBonus(user.id, 100);&#125; // 事务结束\n对于大多数业务来说，我们期待BonusService.addBonus()的调用，和UserService.register()应当融合在一起，它的行为应该如下：\nUserService.register()已经开启了一个事务，那么在内部调用BonusService.addBonus()时，BonusService.addBonus()方法就没必要再开启一个新事务，直接加入到BonusService.register()的事务里就好了。\n其实就相当于：\n\nUserService.register()先执行了一条INSERT语句：INSERT INTO users ...\nBonusService.addBonus()再执行一条INSERT语句：INSERT INTO bonus ...\n\n因此，Spring的声明式事务为事务传播定义了几个级别，默认传播级别就是REQUIRED，它的意思是，如果当前没有事务，就创建一个新事务，如果当前有事务，就加入到当前事务中执行。\n我们观察UserService.register()方法，它在RegisterController中执行，因为RegisterController没有事务，因此，UserService.register()方法会自动创建一个新事务。\n在UserService.register()方法内部，调用BonusService.addBonus()方法时，因为BonusService.addBonus()检测到当前已经有事务了，因此，它会加入到当前事务中执行。\n因此，整个业务流程的事务边界就清晰了：它只有一个事务，并且范围就是UserService.register()方法。\n有的童鞋会问：把BonusService.addBonus()方法的@Transactional去掉，变成一个普通方法，那不就规避了复杂的传播模型吗？\n去掉BonusService.addBonus()方法的@Transactional，会引来另一个问题，即其他地方如果调用BonusService.addBonus()方法，那就没法保证事务了。例如，规定用户登录时积分+5：\n1234567891011@Controllerpublic class LoginController &#123;    @Autowired    BonusService bonusService;    @PostMapping(&quot;/login&quot;)    public ModelAndView doLogin(HttpServletRequest req) &#123;        User user = ...        bonusService.addBonus(user.id, 5);    &#125;&#125;\n可见，BonusService.addBonus()方法必须要有@Transactional，否则，登录后积分就无法添加了。\n默认的事务传播级别是REQUIRED，它满足绝大部分的需求。还有一些其他的传播级别：\nSUPPORTS：表示如果有事务，就加入到当前事务，如果没有，那也不开启事务执行。这种传播级别可用于查询方法，因为SELECT语句既可以在事务内执行，也可以不需要事务；\nMANDATORY：表示必须要存在当前事务并加入执行，否则将抛出异常。这种传播级别可用于核心更新逻辑，比如用户余额变更，它总是被其他事务方法调用，不能直接由非事务方法调用；\nREQUIRES_NEW：表示不管当前有没有事务，都必须开启一个新的事务执行。如果当前已经有事务，那么当前事务会挂起，等新事务完成后，再恢复执行；\nNOT_SUPPORTED：表示不支持事务，如果当前有事务，那么当前事务会挂起，等这个方法执行完成后，再恢复执行；\nNEVER：和NOT_SUPPORTED相比，它不但不支持事务，而且在监测到当前有事务时，会抛出异常拒绝执行；\nNESTED：表示如果当前有事务，则开启一个嵌套级别事务，如果当前没有事务，则开启一个新事务。\n上面这么多种事务的传播级别，其实默认的REQUIRED已经满足绝大部分需求，SUPPORTS和REQUIRES_NEW在少数情况下会用到，其他基本不会用到，因为把事务搞得越复杂，不仅逻辑跟着复杂，而且速度也会越慢。\n定义事务的传播级别也是写在@Transactional注解里的：\n1234@Transactional(propagation = Propagation.REQUIRES_NEW)public Product createProduct() &#123;    ...&#125;\n现在只剩最后一个问题了：Spring是如何传播事务的？\n我们在JDBC中使用事务的时候，是这么个写法：\n123456789101112131415Connection conn = openConnection();try &#123;    // 关闭自动提交:    conn.setAutoCommit(false);    // 执行多条SQL语句:    insert(); update(); delete();    // 提交事务:    conn.commit();&#125; catch (SQLException e) &#123;    // 回滚事务:    conn.rollback();&#125; finally &#123;    conn.setAutoCommit(true);    conn.close();&#125;\nSpring使用声明式事务，最终也是通过执行JDBC事务来实现功能的，那么，一个事务方法，如何获知当前是否存在事务？\n答案是使用ThreadLocal。Spring总是把JDBC相关的Connection和TransactionStatus实例绑定到ThreadLocal。如果一个事务方法从ThreadLocal未取到事务，那么它会打开一个新的JDBC连接，同时开启一个新的事务，否则，它就直接使用从ThreadLocal获取的JDBC连接以及TransactionStatus。\n因此，事务能正确传播的前提是，方法调用是在一个线程内才行。如果像下面这样写：\n123456789@Transactionalpublic User register(String email, String password, String name) &#123; // BEGIN TX-A    User user = jdbcTemplate.insert(&quot;...&quot;);    new Thread(() -&gt; &#123;        // BEGIN TX-B:        bonusService.addBonus(user.id, 100);        // END TX-B    &#125;).start();&#125; // END TX-A\n在另一个线程中调用BonusService.addBonus()，它根本获取不到当前事务，因此，UserService.register()和BonusService.addBonus()两个方法，将分别开启两个完全独立的事务。\n换句话说，事务只能在当前线程传播，无法跨线程传播。\n那如果我们想实现跨线程传播事务呢？原理很简单，就是要想办法把当前线程绑定到ThreadLocal的Connection和TransactionStatus实例传递给新线程，但实现起来非常复杂，根据异常回滚更加复杂，不推荐自己去实现。\n练习\n使用声明式事务。\n下载练习\n小结\nSpring提供的声明式事务极大地方便了在数据库中使用事务，正确使用声明式事务的关键在于确定好事务边界，理解事务传播级别。\n在传统的多层应用程序中，通常是Web层调用业务层，业务层调用数据访问层。业务层负责处理各种业务逻辑，而数据访问层只负责对数据进行增删改查。因此，实现数据访问层就是用JdbcTemplate实现对数据库的操作。\n编写数据访问层的时候，可以使用DAO模式。DAO即Data Access Object的缩写，它没有什么神秘之处，实现起来基本如下：\n12345678910111213141516171819202122232425public class UserDao &#123;    @Autowired    JdbcTemplate jdbcTemplate;    User getById(long id) &#123;        ...    &#125;    List&lt;User&gt; getUsers(int page) &#123;        ...    &#125;    User createUser(User user) &#123;        ...    &#125;    User updateUser(User user) &#123;        ...    &#125;    void deleteUser(User user) &#123;        ...    &#125;&#125;\nSpring提供了一个JdbcDaoSupport类，用于简化DAO的实现。这个JdbcDaoSupport没什么复杂的，核心代码就是持有一个JdbcTemplate：\n123456789101112131415public abstract class JdbcDaoSupport extends DaoSupport &#123;    private JdbcTemplate jdbcTemplate;    public final void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;        this.jdbcTemplate = jdbcTemplate;        initTemplateConfig();    &#125;    public final JdbcTemplate getJdbcTemplate() &#123;        return this.jdbcTemplate;    &#125;    ...&#125;\n它的意图是子类直接从JdbcDaoSupport继承后，可以随时调用getJdbcTemplate()获得JdbcTemplate的实例。那么问题来了：因为JdbcDaoSupport的jdbcTemplate字段没有标记@Autowired，所以，子类想要注入JdbcTemplate，还得自己想个办法：\n1234567891011@Component@Transactionalpublic class UserDao extends JdbcDaoSupport &#123;    @Autowired    JdbcTemplate jdbcTemplate;    @PostConstruct    public void init() &#123;        super.setJdbcTemplate(jdbcTemplate);    &#125;&#125;\n有的童鞋可能看出来了：既然UserDao都已经注入了JdbcTemplate，那再把它放到父类里，通过getJdbcTemplate()访问岂不是多此一举？\n如果使用传统的XML配置，并不需要编写@Autowired JdbcTemplate jdbcTemplate，但是考虑到现在基本上是使用注解的方式，我们可以编写一个AbstractDao，专门负责注入JdbcTemplate：\n123456789public abstract class AbstractDao extends JdbcDaoSupport &#123;    @Autowired    private JdbcTemplate jdbcTemplate;    @PostConstruct    public void init() &#123;        super.setJdbcTemplate(jdbcTemplate);    &#125;&#125;\n这样，子类的代码就非常干净，可以直接调用getJdbcTemplate()：\n123456789101112@Component@Transactionalpublic class UserDao extends AbstractDao &#123;    public User getById(long id) &#123;        return getJdbcTemplate().queryForObject(                &quot;SELECT * FROM users WHERE id = ?&quot;,                new BeanPropertyRowMapper&lt;&gt;(User.class),                id        );    &#125;    ...&#125;\n倘若肯再多写一点样板代码，就可以把AbstractDao改成泛型，并实现getById()，getAll()，deleteById()这样的通用方法：\n1234567891011121314151617181920212223242526272829public abstract class AbstractDao&lt;T&gt; extends JdbcDaoSupport &#123;    private String table;    private Class&lt;T&gt; entityClass;    private RowMapper&lt;T&gt; rowMapper;    public AbstractDao() &#123;        // 获取当前类型的泛型类型:        this.entityClass = getParameterizedType();        this.table = this.entityClass.getSimpleName().toLowerCase() + &quot;s&quot;;        this.rowMapper = new BeanPropertyRowMapper&lt;&gt;(entityClass);    &#125;    public T getById(long id) &#123;        return getJdbcTemplate().queryForObject(&quot;SELECT * FROM &quot; + table + &quot; WHERE id = ?&quot;, this.rowMapper, id);    &#125;    public List&lt;T&gt; getAll(int pageIndex) &#123;        int limit = 100;        int offset = limit * (pageIndex - 1);        return getJdbcTemplate().query(&quot;SELECT * FROM &quot; + table + &quot; LIMIT ? OFFSET ?&quot;,                new Object[] &#123; limit, offset &#125;,                this.rowMapper);    &#125;    public void deleteById(long id) &#123;        getJdbcTemplate().update(&quot;DELETE FROM &quot; + table + &quot; WHERE id = ?&quot;, id);    &#125;    ...&#125;\n这样，每个子类就自动获得了这些通用方法：\n1234567891011121314151617@Component@Transactionalpublic class UserDao extends AbstractDao&lt;User&gt; &#123;    // 已经有了:    // User getById(long)    // List&lt;User&gt; getAll(int)    // void deleteById(long)&#125;@Component@Transactionalpublic class BookDao extends AbstractDao&lt;Book&gt; &#123;    // 已经有了:    // Book getById(long)    // List&lt;Book&gt; getAll(int)    // void deleteById(long)&#125;\n可见，DAO模式就是一个简单的数据访问模式，是否使用DAO，根据实际情况决定，因为很多时候，直接在Service层操作数据库也是完全没有问题的。\n练习\n使用DAO模式访问数据库。\n下载练习\n小结\nSpring提供了JdbcDaoSupport来便于我们实现DAO模式；\n可以基于泛型实现更通用、更简洁的DAO模式。\n使用JdbcTemplate的时候，我们用得最多的方法就是List&lt;T&gt; query(String, RowMapper, Object...)。这个RowMapper的作用就是把ResultSet的一行记录映射为Java Bean。\n这种把关系数据库的表记录映射为Java对象的过程就是ORM：Object-Relational Mapping。ORM既可以把记录转换成Java对象，也可以把Java对象转换为行记录。\n使用JdbcTemplate配合RowMapper可以看作是最原始的ORM。如果要实现更自动化的ORM，可以选择成熟的ORM框架，例如Hibernate。\n我们来看看如何在Spring中集成Hibernate。\nHibernate作为ORM框架，它可以替代JdbcTemplate，但Hibernate仍然需要JDBC驱动，所以，我们需要引入JDBC驱动、连接池，以及Hibernate本身。在Maven中，我们加入以下依赖项：\n\norg.springframework:spring-context:6.0.0\norg.springframework:spring-orm:6.0.0\njakarta.annotation:jakarta.annotation-api:2.1.1\njakarta.persistence:jakarta.persistence-api:3.1.0\norg.hibernate:hibernate-core:6.1.4.Final\ncom.zaxxer:HikariCP:5.0.1\norg.hsqldb:hsqldb:2.7.1\n\n在AppConfig中，我们仍然需要创建DataSource、引入JDBC配置文件，以及启用声明式事务：\n12345678910@Configuration@ComponentScan@EnableTransactionManagement@PropertySource(&quot;jdbc.properties&quot;)public class AppConfig &#123;    @Bean    DataSource createDataSource() &#123;        ...    &#125;&#125;\n为了启用Hibernate，我们需要创建一个LocalSessionFactoryBean：\n123456789101112131415public class AppConfig &#123;    @Bean    LocalSessionFactoryBean createSessionFactory(@Autowired DataSource dataSource) &#123;        var props = new Properties();        props.setProperty(&quot;hibernate.hbm2ddl.auto&quot;, &quot;update&quot;); // 生产环境不要使用        props.setProperty(&quot;hibernate.dialect&quot;, &quot;org.hibernate.dialect.HSQLDialect&quot;);        props.setProperty(&quot;hibernate.show_sql&quot;, &quot;true&quot;);        var sessionFactoryBean = new LocalSessionFactoryBean();        sessionFactoryBean.setDataSource(dataSource);        // 扫描指定的package获取所有entity class:        sessionFactoryBean.setPackagesToScan(&quot;com.itranswarp.learnjava.entity&quot;);        sessionFactoryBean.setHibernateProperties(props);        return sessionFactoryBean;    &#125;&#125;\n注意我们在定制Bean中讲到过FactoryBean，LocalSessionFactoryBean是一个FactoryBean，它会再自动创建一个SessionFactory，在Hibernate中，Session是封装了一个JDBC Connection的实例，而SessionFactory是封装了JDBC DataSource的实例，即SessionFactory持有连接池，每次需要操作数据库的时候，SessionFactory创建一个新的Session，相当于从连接池获取到一个新的Connection。SessionFactory就是Hibernate提供的最核心的一个对象，但LocalSessionFactoryBean是Spring提供的为了让我们方便创建SessionFactory的类。\n注意到上面创建LocalSessionFactoryBean的代码，首先用Properties持有Hibernate初始化SessionFactory时用到的所有设置，常用的设置请参考Hibernate文档，这里我们只定义了3个设置：\n\nhibernate.hbm2ddl.auto=update：表示自动创建数据库的表结构，注意不要在生产环境中启用；\nhibernate.dialect=org.hibernate.dialect.HSQLDialect：指示Hibernate使用的数据库是HSQLDB。Hibernate使用一种HQL的查询语句，它和SQL类似，但真正在“翻译”成SQL时，会根据设定的数据库“方言”来生成针对数据库优化的SQL；\nhibernate.show_sql=true：让Hibernate打印执行的SQL，这对于调试非常有用，我们可以方便地看到Hibernate生成的SQL语句是否符合我们的预期。\n\n除了设置DataSource和Properties之外，注意到setPackagesToScan()我们传入了一个package名称，它指示Hibernate扫描这个包下面的所有Java类，自动找出能映射为数据库表记录的JavaBean。后面我们会仔细讨论如何编写符合Hibernate要求的JavaBean。\n紧接着，我们还需要创建HibernateTransactionManager：\n123456public class AppConfig &#123;    @Bean    PlatformTransactionManager createTxManager(@Autowired SessionFactory sessionFactory) &#123;        return new HibernateTransactionManager(sessionFactory);    &#125;&#125;\nHibernateTransactionManager是配合Hibernate使用声明式事务所必须的。到此为止，所有的配置都定义完毕，我们来看看如何将数据库表结构映射为Java对象。\n考察如下的数据库表：\n123456789CREATE TABLE user    id BIGINT NOT NULL AUTO_INCREMENT,    email VARCHAR(100) NOT NULL,    password VARCHAR(100) NOT NULL,    name VARCHAR(100) NOT NULL,    createdAt BIGINT NOT NULL,    PRIMARY KEY (`id`),    UNIQUE KEY `email` (`email`));\n其中，id是自增主键，email、password、name是VARCHAR类型，email带唯一索引以确保唯一性，createdAt存储整型类型的时间戳。用JavaBean表示如下：\n12345678910public class User &#123;    private Long id;    private String email;    private String password;    private String name;    private Long createdAt;    // getters and setters    ...&#125;\n这种映射关系十分易懂，但我们需要添加一些注解来告诉Hibernate如何把User类映射到表记录：\n12345678910111213141516171819@Entitypublic class User &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    @Column(nullable = false, updatable = false)    public Long getId() &#123; ... &#125;    @Column(nullable = false, unique = true, length = 100)    public String getEmail() &#123; ... &#125;    @Column(nullable = false, length = 100)    public String getPassword() &#123; ... &#125;    @Column(nullable = false, length = 100)    public String getName() &#123; ... &#125;    @Column(nullable = false, updatable = false)    public Long getCreatedAt() &#123; ... &#125;&#125;\n如果一个JavaBean被用于映射，我们就标记一个@Entity。默认情况下，映射的表名是user，如果实际的表名不同，例如实际表名是users，可以追加一个@Table(name=&quot;users&quot;)表示：\n12345@Entity@Table(name=&quot;users&quot;)public class User &#123;    ...&#125;\n每个属性到数据库列的映射用@Column()标识，nullable指示列是否允许为NULL，updatable指示该列是否允许被用在UPDATE语句，length指示String类型的列的长度（如果没有指定，默认是255）。\n对于主键，还需要用@Id标识，自增主键再追加一个@GeneratedValue，以便Hibernate能读取到自增主键的值。\n细心的童鞋可能还注意到，主键id定义的类型不是long，而是Long。这是因为Hibernate如果检测到主键为null，就不会在INSERT语句中指定主键的值，而是返回由数据库生成的自增值，否则，Hibernate认为我们的程序指定了主键的值，会在INSERT语句中直接列出。long型字段总是具有默认值0，因此，每次插入的主键值总是0，导致除第一次外后续插入都将失败。\ncreatedAt虽然是整型，但我们并没有使用long，而是Long，这是因为使用基本类型会导致findByExample查询会添加意外的条件，这里只需牢记，作为映射使用的JavaBean，所有属性都使用包装类型而不是基本类型。\n注意\n使用Hibernate时，不要使用基本类型的属性，总是使用包装类型，如Long或Integer。\n类似的，我们再定义一个Book类：\n12345678910111213@Entitypublic class Book &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    @Column(nullable = false, updatable = false)    public Long getId() &#123; ... &#125;    @Column(nullable = false, length = 100)    public String getTitle() &#123; ... &#125;    @Column(nullable = false, updatable = false)    public Long getCreatedAt() &#123; ... &#125;&#125;\n如果仔细观察User和Book，会发现它们定义的id、createdAt属性是一样的，这在数据库表结构的设计中很常见：对于每个表，通常我们会统一使用一种主键生成机制，并添加createdAt表示创建时间，updatedAt表示修改时间等通用字段。\n不必在User和Book中重复定义这些通用字段，我们可以把它们提到一个抽象类中：\n123456789101112131415161718192021222324@MappedSuperclasspublic abstract class AbstractEntity &#123;    private Long id;    private Long createdAt;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    @Column(nullable = false, updatable = false)    public Long getId() &#123; ... &#125;    @Column(nullable = false, updatable = false)    public Long getCreatedAt() &#123; ... &#125;    @Transient    public ZonedDateTime getCreatedDateTime() &#123;        return Instant.ofEpochMilli(this.createdAt).atZone(ZoneId.systemDefault());    &#125;    @PrePersist    public void preInsert() &#123;        setCreatedAt(System.currentTimeMillis());    &#125;&#125;\n对于AbstractEntity来说，我们要标注一个@MappedSuperclass表示它用于继承。此外，注意到我们定义了一个@Transient方法，它返回一个“虚拟”的属性。因为getCreatedDateTime()是计算得出的属性，而不是从数据库表读出的值，因此必须要标注@Transient，否则Hibernate会尝试从数据库读取名为createdDateTime这个不存在的字段从而出错。\n再注意到@PrePersist标识的方法，它表示在我们将一个JavaBean持久化到数据库之前（即执行INSERT语句），Hibernate会先执行该方法，这样我们就可以自动设置好createdAt属性。\n有了AbstractEntity，我们就可以大幅简化User和Book：\n123456789101112@Entitypublic class User extends AbstractEntity &#123;    @Column(nullable = false, unique = true, length = 100)    public String getEmail() &#123; ... &#125;    @Column(nullable = false, length = 100)    public String getPassword() &#123; ... &#125;    @Column(nullable = false, length = 100)    public String getName() &#123; ... &#125;&#125;\n注意到使用的所有注解均来自jakarta.persistence，它是JPA规范的一部分。这里我们只介绍使用注解的方式配置Hibernate映射关系，不再介绍传统的比较繁琐的XML配置。通过Spring集成Hibernate时，也不再需要hibernate.cfg.xml配置文件，用一句话总结：\n提示\n使用Spring集成Hibernate，配合JPA注解，无需任何额外的XML配置。\n类似User、Book这样的用于ORM的Java Bean，我们通常称之为Entity Bean。\n最后，我们来看看如果对user表进行增删改查。因为使用了Hibernate，因此，我们要做的，实际上是对User这个JavaBean进行“增删改查”。我们编写一个UserService，注入SessionFactory：\n123456@Component@Transactionalpublic class UserService &#123;    @Autowired    SessionFactory sessionFactory;&#125;\nInsert操作\n要持久化一个User实例，我们只需调用persist()方法。以register()方法为例，代码如下：\n1234567891011121314public User register(String email, String password, String name) &#123;    // 创建一个User对象:    User user = new User();    // 设置好各个属性:    user.setEmail(email);    user.setPassword(password);    user.setName(name);    // 不要设置id，因为使用了自增主键    // 保存到数据库:    sessionFactory.getCurrentSession().persist(user);    // 现在已经自动获得了id:    System.out.println(user.getId());    return user;&#125;\nDelete操作\n删除一个User相当于从表中删除对应的记录。注意Hibernate总是用id来删除记录，因此，要正确设置User的id属性才能正常删除记录：\n12345678public boolean deleteUser(Long id) &#123;    User user = sessionFactory.getCurrentSession().byId(User.class).load(id);    if (user != null) &#123;        sessionFactory.getCurrentSession().remove(user);        return true;    &#125;    return false;&#125;\n通过主键删除记录时，一个常见的用法是先根据主键加载该记录，再删除。注意到当记录不存在时，load()返回null。\nUpdate操作\n更新记录相当于先更新User的指定属性，然后调用merge()方法：\n12345public void updateUser(Long id, String name) &#123;    User user = sessionFactory.getCurrentSession().byId(User.class).load(id);    user.setName(name);    sessionFactory.getCurrentSession().merge(user);&#125;\n前面我们在定义User时，对有的属性标注了@Column(updatable=false)。Hibernate在更新记录时，它只会把@Column(updatable=true)的属性加入到UPDATE语句中，这样可以提供一层额外的安全性，即如果不小心修改了User的email、createdAt等属性，执行update()时并不会更新对应的数据库列。但也必须牢记：这个功能是Hibernate提供的，如果绕过Hibernate直接通过JDBC执行UPDATE语句仍然可以更新数据库的任意列的值。\n最后，我们编写的大部分方法都是各种各样的查询。根据id查询我们可以直接调用load()，如果要使用条件查询，例如，假设我们想执行以下查询：\n1SELECT * FROM user WHERE email = ? AND password = ?\n我们来看看可以使用什么查询。\n使用HQL查询\n一种常用的查询是直接编写Hibernate内置的HQL查询：\n1234List&lt;User&gt; list = sessionFactory.getCurrentSession()        .createQuery(&quot;from User u where u.email = ?1 and u.password = ?2&quot;, User.class)        .setParameter(1, email).setParameter(2, password)        .list();\n和SQL相比，HQL使用类名和属性名，由Hibernate自动转换为实际的表名和列名。详细的HQL语法可以参考Hibernate文档。\n除了可以直接传入HQL字符串外，Hibernate还可以使用一种NamedQuery，它给查询起个名字，然后保存在注解中。使用NamedQuery时，我们要先在User类标注：\n123456789101112@NamedQueries(    @NamedQuery(        // 查询名称:        name = &quot;login&quot;,        // 查询语句:        query = &quot;SELECT u FROM User u WHERE u.email = :e AND u.password = :pwd&quot;    ))@Entitypublic class User extends AbstractEntity &#123;    ...&#125;\n注意到引入的NamedQuery是jakarta.persistence.NamedQuery，它和直接传入HQL有点不同的是，占位符使用:e和:pwd。\n使用NamedQuery只需要引入查询名和参数：\n12345678public User login(String email, String password) &#123;    List&lt;User&gt; list = sessionFactory.getCurrentSession()        .createNamedQuery(&quot;login&quot;, User.class) // 创建NamedQuery        .setParameter(&quot;e&quot;, email) // 绑定e参数        .setParameter(&quot;pwd&quot;, password) // 绑定pwd参数        .list();    return list.isEmpty() ? null : list.get(0);&#125;\n直接写HQL和使用NamedQuery各有优劣。前者可以在代码中直观地看到查询语句，后者可以在User类统一管理所有相关查询。\n练习\n集成Hibernate操作数据库。\n下载练习\n小结\n在Spring中集成Hibernate需要配置的Bean如下：\n\nDataSource；\nLocalSessionFactory；\nHibernateTransactionManager。\n\n推荐使用Annotation配置所有的Entity Bean。\n上一节我们讲了在Spring中集成Hibernate。Hibernate是第一个被广泛使用的ORM框架，但是很多小伙伴还听说过JPA：Java Persistence API，这又是啥？\n在讨论JPA之前，我们要注意到JavaEE早在1999年就发布了，并且有Servlet、JMS等诸多标准。和其他平台不同，Java世界早期非常热衷于标准先行，各家跟进：大家先坐下来把接口定了，然后，各自回家干活去实现接口，这样，用户就可以在不同的厂家提供的产品进行选择，还可以随意切换，因为用户编写代码的时候只需要引用接口，并不需要引用具体的底层实现（想想JDBC）。\nJPA就是JavaEE的一个ORM标准，它的实现其实和Hibernate没啥本质区别，但是用户如果使用JPA，那么引用的就是jakarta.persistence这个“标准”包，而不是org.hibernate这样的第三方包。因为JPA只是接口，所以，还需要选择一个实现产品，跟JDBC接口和MySQL驱动一个道理。\n我们使用JPA时也完全可以选择Hibernate作为底层实现，但也可以选择其它的JPA提供方，比如EclipseLink。Spring内置了JPA的集成，并支持选择Hibernate或EclipseLink作为实现。这里我们仍然以主流的Hibernate作为JPA实现为例子，演示JPA的基本用法。\n和使用Hibernate一样，我们只需要引入如下依赖：\n\norg.springframework:spring-context:6.0.0\norg.springframework:spring-orm:6.0.0\njakarta.annotation:jakarta.annotation-api:2.1.1\njakarta.persistence:jakarta.persistence-api:3.1.0\norg.hibernate:hibernate-core:6.1.4.Final\ncom.zaxxer:HikariCP:5.0.1\norg.hsqldb:hsqldb:2.7.1\n\n实际上我们这里引入的依赖和上一节集成Hibernate引入的依赖完全一样，因为Hibernate既提供了它自己的接口，也提供了JPA接口，我们用JPA接口就相当于通过JPA操作Hibernate。\n然后，在AppConfig中启用声明式事务管理，创建DataSource：\n12345678@Configuration@ComponentScan@EnableTransactionManagement@PropertySource(&quot;jdbc.properties&quot;)public class AppConfig &#123;    @Bean    DataSource createDataSource() &#123; ... &#125;&#125;\n使用Hibernate时，我们需要创建一个LocalSessionFactoryBean，并让它再自动创建一个SessionFactory。使用JPA也是类似的，我们也创建一个LocalContainerEntityManagerFactoryBean，并让它再自动创建一个EntityManagerFactory：\n1234567891011121314151617@Beanpublic LocalContainerEntityManagerFactoryBean createEntityManagerFactory(@Autowired DataSource dataSource) &#123;    var emFactory = new LocalContainerEntityManagerFactoryBean();    // 注入DataSource:    emFactory.setDataSource(dataSource);    // 扫描指定的package获取所有entity class:    emFactory.setPackagesToScan(AbstractEntity.class.getPackageName());    // 使用Hibernate作为JPA实现:    emFactory.setJpaVendorAdapter(new HibernateJpaVendorAdapter());    // 其他配置项:    var props = new Properties();    props.setProperty(&quot;hibernate.hbm2ddl.auto&quot;, &quot;update&quot;); // 生产环境不要使用    props.setProperty(&quot;hibernate.dialect&quot;, &quot;org.hibernate.dialect.HSQLDialect&quot;);    props.setProperty(&quot;hibernate.show_sql&quot;, &quot;true&quot;);    emFactory.setJpaProperties(props);    return emFactory;&#125;\n观察上述代码，除了需要注入DataSource和设定自动扫描的package外，还需要指定JPA的提供商，这里使用Spring提供的一个HibernateJpaVendorAdapter，最后，针对Hibernate自己需要的配置，以Properties的形式注入。\n最后，我们还需要实例化一个JpaTransactionManager，以实现声明式事务：\n1234@BeanPlatformTransactionManager createTxManager(@Autowired EntityManagerFactory entityManagerFactory) &#123;    return new JpaTransactionManager(entityManagerFactory);&#125;\n这样，我们就完成了JPA的全部初始化工作。有些童鞋可能从网上搜索得知JPA需要persistence.xml配置文件，以及复杂的orm.xml文件。这里我们负责地告诉大家，使用Spring+Hibernate作为JPA实现，无需任何配置文件。\n所有Entity Bean的配置和上一节完全相同，全部采用Annotation标注。我们现在只需关心具体的业务类如何通过JPA接口操作数据库。\n还是以UserService为例，除了标注@Component和@Transactional外，我们需要注入一个EntityManager，但是不要使用Autowired，而是@PersistenceContext：\n123456@Component@Transactionalpublic class UserService &#123;    @PersistenceContext    EntityManager em;&#125;\n我们回顾一下JDBC、Hibernate和JPA提供的接口，实际上，它们的关系如下：\n\n\n\nJDBC\nHibernate\nJPA\n\n\n\n\nDataSource\nSessionFactory\nEntityManagerFactory\n\n\nConnection\nSession\nEntityManager\n\n\n\nSessionFactory和EntityManagerFactory相当于DataSource，Session和EntityManager相当于Connection。每次需要访问数据库的时候，需要获取新的Session和EntityManager，用完后再关闭。\n但是，注意到UserService注入的不是EntityManagerFactory，而是EntityManager，并且标注了@PersistenceContext。难道使用JPA可以允许多线程操作同一个EntityManager？\n实际上这里注入的并不是真正的EntityManager，而是一个EntityManager的代理类，相当于：\n123public class EntityManagerProxy implements EntityManager &#123;    private EntityManagerFactory emf;&#125;\nSpring遇到标注了@PersistenceContext的EntityManager会自动注入代理，该代理会在必要的时候自动打开EntityManager。换句话说，多线程引用的EntityManager虽然是同一个代理类，但该代理类内部针对不同线程会创建不同的EntityManager实例。\n简单总结一下，标注了@PersistenceContext的EntityManager可以被多线程安全地共享。\n因此，在UserService的每个业务方法里，直接使用EntityManager就很方便。以主键查询为例：\n1234567public User getUserById(long id) &#123;    User user = this.em.find(User.class, id);    if (user == null) &#123;        throw new RuntimeException(&quot;User not found by id: &quot; + id);    &#125;    return user;&#125;\n与HQL查询类似，JPA使用JPQL查询，它的语法和HQL基本差不多：\n12345678910public User fetchUserByEmail(String email) &#123;    // JPQL查询:    TypedQuery&lt;User&gt; query = em.createQuery(&quot;SELECT u FROM User u WHERE u.email = :e&quot;, User.class);    query.setParameter(&quot;e&quot;, email);    List&lt;User&gt; list = query.getResultList();    if (list.isEmpty()) &#123;        return null;    &#125;    return list.get(0);&#125;\n同样的，JPA也支持NamedQuery，即先给查询起个名字，再按名字创建查询：\n1234567public User login(String email, String password) &#123;    TypedQuery&lt;User&gt; query = em.createNamedQuery(&quot;login&quot;, User.class);    query.setParameter(&quot;e&quot;, email);    query.setParameter(&quot;pwd&quot;, password);    List&lt;User&gt; list = query.getResultList();    return list.isEmpty() ? null : list.get(0);&#125;\nNamedQuery通过注解标注在User类上，它的定义和上一节的User类一样：\n12345678910@NamedQueries(    @NamedQuery(        name = &quot;login&quot;,        query = &quot;SELECT u FROM User u WHERE u.email=:e AND u.password=:pwd&quot;    ))@Entitypublic class User &#123;    ...&#125;\n对数据库进行增删改的操作，可以分别使用persist()、remove()和merge()方法，参数均为Entity Bean本身，使用非常简单，这里不再多述。\n练习\n使用JPA操作数据库。\n下载练习\n小结\n在Spring中集成JPA要选择一个实现，可以选择Hibernate或EclipseLink；\n使用JPA与Hibernate类似，但注入的核心资源是带有@PersistenceContext注解的EntityManager代理类。\n使用Hibernate或JPA操作数据库时，这类ORM干的主要工作就是把ResultSet的每一行变成Java Bean，或者把Java Bean自动转换到INSERT或UPDATE语句的参数中，从而实现ORM。\n而ORM框架之所以知道如何把行数据映射到Java Bean，是因为我们在Java Bean的属性上给了足够的注解作为元数据，ORM框架获取Java Bean的注解后，就知道如何进行双向映射。\n那么，ORM框架是如何跟踪Java Bean的修改，以便在update()操作中更新必要的属性？\n答案是使用Proxy模式，从ORM框架读取的User实例实际上并不是User类，而是代理类，代理类继承自User类，但针对每个setter方法做了覆写：\n12345678public class UserProxy extends User &#123;    boolean _isNameChanged;    public void setName(String name) &#123;        super.setName(name);        _isNameChanged = true;    &#125;&#125;\n这样，代理类可以跟踪到每个属性的变化。\n针对一对多或多对一关系时，代理类可以直接通过getter方法查询数据库：\n12345678910111213141516171819public class UserProxy extends User &#123;    Session _session;    boolean _isNameChanged;    public void setName(String name) &#123;        super.setName(name);        _isNameChanged = true;    &#125;    /**     * 获取User对象关联的Address对象:     */    public Address getAddress() &#123;        Query q = _session.createQuery(&quot;from Address where userId = :userId&quot;);        q.setParameter(&quot;userId&quot;, this.getId());        List&lt;Address&gt; list = query.list();        return list.isEmpty() ? null : list(0);    &#125;&#125;\n为了实现这样的查询，UserProxy必须保存Hibernate的当前Session。但是，当事务提交后，Session自动关闭，此时再获取getAddress()将无法访问数据库，或者获取的不是事务一致的数据。因此，ORM框架总是引入了Attached/Detached状态，表示当前此Java Bean到底是在Session的范围内，还是脱离了Session变成了一个“游离”对象。很多初学者无法正确理解状态变化和事务边界，就会造成大量的PersistentObjectException异常。这种隐式状态使得普通Java Bean的生命周期变得复杂。\n此外，Hibernate和JPA为了实现兼容多种数据库，它使用HQL或JPQL查询，经过一道转换，变成特定数据库的SQL，理论上这样可以做到无缝切换数据库，但这一层自动转换除了少许的性能开销外，给SQL级别的优化带来了麻烦。\n最后，ORM框架通常提供了缓存，并且还分为一级缓存和二级缓存。一级缓存是指在一个Session范围内的缓存，常见的情景是根据主键查询时，两次查询可以返回同一实例：\n12User user1 = session.load(User.class, 123);User user2 = session.load(User.class, 123);\n二级缓存是指跨Session的缓存，一般默认关闭，需要手动配置。二级缓存极大的增加了数据的不一致性，原因在于SQL非常灵活，常常会导致意外的更新。例如：\n12345// 线程1读取:User user1 = session1.load(User.class, 123);...// 一段时间后，线程2读取:User user2 = session2.load(User.class, 123);\n当二级缓存生效的时候，两个线程读取的User实例是一样的，但是，数据库对应的行记录完全可能被修改，例如：\n12-- 给老用户增加100积分:UPDATE users SET bonus = bonus + 100 WHERE createdAt &lt;= ?\nORM无法判断id=123的用户是否受该UPDATE语句影响。考虑到数据库通常会支持多个应用程序，此UPDATE语句可能由其他进程执行，ORM框架就更不知道了。\n我们把这种ORM框架称之为全自动ORM框架。\n对比Spring提供的JdbcTemplate，它和ORM框架相比，主要有几点差别：\n\n查询后需要手动提供Mapper实例以便把ResultSet的每一行变为Java对象；\n增删改操作所需的参数列表，需要手动传入，即把User实例变为[user.id, user.name, user.email]这样的列表，比较麻烦。\n\n但是JdbcTemplate的优势在于它的确定性：即每次读取操作一定是数据库操作而不是缓存，所执行的SQL是完全确定的，缺点就是代码比较繁琐，构造INSERT INTO users VALUES (?,?,?)更是复杂。\n所以，介于全自动ORM如Hibernate和手写全部如JdbcTemplate之间，还有一种半自动的ORM，它只负责把ResultSet自动映射到Java Bean，或者自动填充Java Bean参数，但仍需自己写出SQL。MyBatis就是这样一种半自动化ORM框架。\n我们来看看如何在Spring中集成MyBatis。\n首先，我们要引入MyBatis本身，其次，由于Spring并没有像Hibernate那样内置对MyBatis的集成，所以，我们需要再引入MyBatis官方自己开发的一个与Spring集成的库：\n\norg.mybatis:mybatis:3.5.11\norg.mybatis:mybatis-spring:3.0.0\n\n和前面一样，先创建DataSource是必不可少的：\n12345678@Configuration@ComponentScan@EnableTransactionManagement@PropertySource(&quot;jdbc.properties&quot;)public class AppConfig &#123;    @Bean    DataSource createDataSource() &#123; ... &#125;&#125;\n再回顾一下Hibernate和JPA的SessionFactory与EntityManagerFactory，MyBatis与之对应的是SqlSessionFactory和SqlSession：\n\n\n\nJDBC\nHibernate\nJPA\nMyBatis\n\n\n\n\nDataSource\nSessionFactory\nEntityManagerFactory\nSqlSessionFactory\n\n\nConnection\nSession\nEntityManager\nSqlSession\n\n\n\n可见，ORM的设计套路都是类似的。使用MyBatis的核心就是创建SqlSessionFactory，这里我们需要创建的是SqlSessionFactoryBean：\n123456@BeanSqlSessionFactoryBean createSqlSessionFactoryBean(@Autowired DataSource dataSource) &#123;    var sqlSessionFactoryBean = new SqlSessionFactoryBean();    sqlSessionFactoryBean.setDataSource(dataSource);    return sqlSessionFactoryBean;&#125;\n因为MyBatis可以直接使用Spring管理的声明式事务，因此，创建事务管理器和使用JDBC是一样的：\n1234@BeanPlatformTransactionManager createTxManager(@Autowired DataSource dataSource) &#123;    return new DataSourceTransactionManager(dataSource);&#125;\n和Hibernate不同的是，MyBatis使用Mapper来实现映射，而且Mapper必须是接口。我们以User类为例，在User类和users表之间映射的UserMapper编写如下：\n1234public interface UserMapper &#123;\t@Select(&quot;SELECT * FROM users WHERE id = #&#123;id&#125;&quot;)\tUser getById(@Param(&quot;id&quot;) long id);&#125;\n注意：这里的Mapper不是JdbcTemplate的RowMapper的概念，它是定义访问users表的接口方法。比如我们定义了一个User getById(long)的主键查询方法，不仅要定义接口方法本身，还要明确写出查询的SQL，这里用注解@Select标记。SQL语句的任何参数，都与方法参数按名称对应。例如，方法参数id的名字通过注解@Param()标记为id，则SQL语句里将来替换的占位符就是#&#123;id&#125;。\n如果有多个参数，那么每个参数命名后直接在SQL中写出对应的占位符即可：\n12@Select(&quot;SELECT * FROM users LIMIT #&#123;offset&#125;, #&#123;maxResults&#125;&quot;)List&lt;User&gt; getAll(@Param(&quot;offset&quot;) int offset, @Param(&quot;maxResults&quot;) int maxResults);\n注意：MyBatis执行查询后，将根据方法的返回类型自动把ResultSet的每一行转换为User实例，转换规则当然是按列名和属性名对应。如果列名和属性名不同，最简单的方式是编写SELECT语句的别名：\n12-- 列名是created_time，属性名是createdAt:SELECT id, name, email, created_time AS createdAt FROM users\n执行INSERT语句就稍微麻烦点，因为我们希望传入User实例，因此，定义的方法接口与@Insert注解如下：\n12@Insert(&quot;INSERT INTO users (email, password, name, createdAt) VALUES (#&#123;user.email&#125;, #&#123;user.password&#125;, #&#123;user.name&#125;, #&#123;user.createdAt&#125;)&quot;)void insert(@Param(&quot;user&quot;) User user);\n上述方法传入的参数名称是user，参数类型是User类，在SQL中引用的时候，以#&#123;obj.property&#125;的方式写占位符。和Hibernate这样的全自动化ORM相比，MyBatis必须写出完整的INSERT语句。\n如果users表的id是自增主键，那么，我们在SQL中不传入id，但希望获取插入后的主键，需要再加一个@Options注解：\n123@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;, keyColumn = &quot;id&quot;)@Insert(&quot;INSERT INTO users (email, password, name, createdAt) VALUES (#&#123;user.email&#125;, #&#123;user.password&#125;, #&#123;user.name&#125;, #&#123;user.createdAt&#125;)&quot;)void insert(@Param(&quot;user&quot;) User user);\nkeyProperty和keyColumn分别指出JavaBean的属性和数据库的主键列名。\n执行UPDATE和DELETE语句相对比较简单，我们定义方法如下：\n12345@Update(&quot;UPDATE users SET name = #&#123;user.name&#125;, createdAt = #&#123;user.createdAt&#125; WHERE id = #&#123;user.id&#125;&quot;)void update(@Param(&quot;user&quot;) User user);@Delete(&quot;DELETE FROM users WHERE id = #&#123;id&#125;&quot;)void deleteById(@Param(&quot;id&quot;) long id);\n有了UserMapper接口，还需要对应的实现类才能真正执行这些数据库操作的方法。虽然可以自己写实现类，但我们除了编写UserMapper接口外，还有BookMapper、BonusMapper……一个一个写太麻烦，因此，MyBatis提供了一个MapperFactoryBean来自动创建所有Mapper的实现类。可以用一个简单的注解来启用它：\n12345@MapperScan(&quot;com.itranswarp.learnjava.mapper&quot;)...其他注解...public class AppConfig &#123;    ...&#125;\n有了@MapperScan，就可以让MyBatis自动扫描指定包的所有Mapper并创建实现类。在真正的业务逻辑中，我们可以直接注入：\n12345678910111213141516@Component@Transactionalpublic class UserService &#123;    // 注入UserMapper:    @Autowired    UserMapper userMapper;    public User getUserById(long id) &#123;        // 调用Mapper方法:        User user = userMapper.getById(id);        if (user == null) &#123;            throw new RuntimeException(&quot;User not found by id.&quot;);        &#125;        return user;    &#125;&#125;\n可见，业务逻辑主要就是通过XxxMapper定义的数据库方法来访问数据库。\nXML配置\n上述在Spring中集成MyBatis的方式，我们只需要用到注解，并没有任何XML配置文件。MyBatis也允许使用XML配置映射关系和SQL语句，例如，更新User时根据属性值构造动态SQL：\n123456789&lt;update id=&quot;updateUser&quot;&gt;  UPDATE users SET  &lt;set&gt;    &lt;if test=&quot;user.name != null&quot;&gt; name = #&#123;user.name&#125; &lt;/if&gt;    &lt;if test=&quot;user.hobby != null&quot;&gt; hobby = #&#123;user.hobby&#125; &lt;/if&gt;    &lt;if test=&quot;user.summary != null&quot;&gt; summary = #&#123;user.summary&#125; &lt;/if&gt;  &lt;/set&gt;  WHERE id = #&#123;user.id&#125;&lt;/update&gt;\n编写XML配置的优点是可以组装出动态SQL，并且把所有SQL操作集中在一起。缺点是配置起来太繁琐，调用方法时如果想查看SQL还需要定位到XML配置中。这里我们不介绍XML的配置方式，需要了解的童鞋请自行阅读官方文档。\n使用MyBatis最大的问题是所有SQL都需要全部手写，优点是执行的SQL就是我们自己写的SQL，对SQL进行优化非常简单，也可以编写任意复杂的SQL，或者使用数据库的特定语法，但切换数据库可能就不太容易。好消息是大部分项目并没有切换数据库的需求，完全可以针对某个数据库编写尽可能优化的SQL。\n练习\n集成MyBatis操作数据库。\n下载练习\n小结\nMyBatis是一个半自动化的ORM框架，需要手写SQL语句，没有自动加载一对多或多对一关系的功能。\n我们从前几节可以看到，所谓ORM，也是建立在JDBC的基础上，通过ResultSet到JavaBean的映射，实现各种查询。有自动跟踪Entity修改的全自动化ORM如Hibernate和JPA，需要为每个Entity创建代理，也有完全自己映射，连INSERT和UPDATE语句都需要手动编写的MyBatis，但没有任何透明的Proxy。\n而查询是涉及到数据库使用最广泛的操作，需要最大的灵活性。各种ORM解决方案各不相同，Hibernate和JPA自己实现了HQL和JPQL查询语法，用以生成最终的SQL，而MyBatis则完全手写，每增加一个查询都需要先编写SQL并增加接口方法。\n还有一种Hibernate和JPA支持的Criteria查询，用Hibernate写出来类似：\n1234DetachedCriteria criteria = DetachedCriteria.forClass(User.class);criteria.add(Restrictions.eq(&quot;email&quot;, email))        .add(Restrictions.eq(&quot;password&quot;, password));List&lt;User&gt; list = (List&lt;User&gt;) hibernateTemplate.findByCriteria(criteria);\n上述Criteria查询写法复杂，但和JPA相比，还是小巫见大巫了：\n1234567var cb = em.getCriteriaBuilder();CriteriaQuery&lt;User&gt; q = cb.createQuery(User.class);Root&lt;User&gt; r = q.from(User.class);q.where(cb.equal(r.get(&quot;email&quot;), cb.parameter(String.class, &quot;e&quot;)));TypedQuery&lt;User&gt; query = em.createQuery(q);query.setParameter(&quot;e&quot;, email);List&lt;User&gt; list = query.getResultList();\n此外，是否支持自动读取一对多和多对一关系也是全自动化ORM框架的一个重要功能。\n如果我们自己来设计并实现一个ORM，应该吸取这些ORM的哪些特色，然后高效实现呢？\n设计ORM接口\n任何设计，都必须明确设计目标。这里我们准备实现的ORM并不想要全自动ORM那种自动读取一对多和多对一关系的功能，也不想给Entity加上复杂的状态，因此，对于Entity来说，它就是纯粹的JavaBean，没有任何Proxy。\n此外，ORM要兼顾易用性和适用性。易用性是指能覆盖95%的应用场景，但总有一些复杂的SQL，很难用ORM去自动生成，因此，也要给出原生的JDBC接口，能支持5%的特殊需求。\n最后，我们希望设计的接口要易于编写，并使用流式API便于阅读。为了配合编译器检查，还应该支持泛型，避免强制转型。\n以User类为例，我们设计的查询接口如下：\n1234567891011121314151617181920// 按主键查询: SELECT * FROM users WHERE id = ?User u = db.get(User.class, 123);// 条件查询唯一记录: SELECT * FROM users WHERE email = ? AND password = ?User u = db.from(User.class)           .where(&quot;email=? AND password=?&quot;, &quot;bob@example.com&quot;, &quot;bob123&quot;)           .unique();// 条件查询多条记录: SELECT * FROM users WHERE id &lt; ? ORDER BY email LIMIT ?, ?List&lt;User&gt; us = db.from(User.class)                  .where(&quot;id &lt; ?&quot;, 1000)                  .orderBy(&quot;email&quot;)                  .limit(0, 10)                  .list();// 查询特定列: SELECT id, name FROM users WHERE email = ?User u = db.select(&quot;id&quot;, &quot;name&quot;)           .from(User.class)           .where(&quot;email = ?&quot;, &quot;bob@example.com&quot;)           .unique();\n这样的流式API便于阅读，也非常容易推导出最终生成的SQL。\n对于插入、更新和删除操作，就相对比较简单：\n12345678// 插入User:db.insert(user);// 按主键更新更新User:db.update(user);// 按主键删除User:db.delete(User.class, 123);\n对于Entity来说，通常一个表对应一个。手动列出所有Entity是非常麻烦的，一定要传入package自动扫描。\n最后，ORM总是需要元数据才能知道如何映射。我们不想编写复杂的XML配置，也没必要自己去定义一套规则，直接使用JPA的注解就行。\n实现ORM\n我们并不需要从JDBC底层开始编写，并且，还要考虑到事务，最好能直接使用Spring的声明式事务。实际上，我们可以设计一个全局DbTemplate，它注入了Spring的JdbcTemplate，涉及到数据库操作时，全部通过JdbcTemplate完成，自然天生支持Spring的声明式事务，因为这个ORM只是在JdbcTemplate的基础上做了一层封装。\n在AppConfig中，我们初始化所有Bean如下：\n1234567891011121314151617181920212223@Configuration@ComponentScan@EnableTransactionManagement@PropertySource(&quot;jdbc.properties&quot;)public class AppConfig &#123;    @Bean    DataSource createDataSource() &#123; ... &#125;    @Bean    JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) &#123;        return new JdbcTemplate(dataSource);    &#125;    @Bean    DbTemplate createDbTemplate(@Autowired JdbcTemplate jdbcTemplate) &#123;        return new DbTemplate(jdbcTemplate, &quot;com.itranswarp.learnjava.entity&quot;);    &#125;    @Bean    PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) &#123;        return new DataSourceTransactionManager(dataSource);    &#125;&#125;\n以上就是我们所需的所有配置。\n编写业务逻辑，例如UserService，写出来像这样：\n1234567891011121314151617181920212223242526272829303132333435@Component@Transactionalpublic class UserService &#123;    @Autowired    DbTemplate db;    public User getUserById(long id) &#123;        return db.get(User.class, id);    &#125;    public User getUserByEmail(String email) &#123;        return db.from(User.class)                 .where(&quot;email = ?&quot;, email)                 .unique();    &#125;    public List&lt;User&gt; getUsers(int pageIndex) &#123;        int pageSize = 100;        return db.from(User.class)                 .orderBy(&quot;id&quot;)                 .limit((pageIndex - 1) * pageSize, pageSize)                 .list();    &#125;    public User register(String email, String password, String name) &#123;        User user = new User();        user.setEmail(email);        user.setPassword(password);        user.setName(name);        user.setCreatedAt(System.currentTimeMillis());        db.insert(user);        return user;    &#125;    ...&#125;\n上述代码给出了ORM的接口，以及如何在业务逻辑中使用ORM。下一步，就是如何实现这个DbTemplate。这里我们只给出框架代码，有兴趣的童鞋可以自己实现核心代码：\n12345678910111213141516171819202122232425262728293031public class DbTemplate &#123;    private JdbcTemplate jdbcTemplate;    // 保存Entity Class到Mapper的映射:    private Map&lt;Class&lt;?&gt;, Mapper&lt;?&gt;&gt; classMapping;    public &lt;T&gt; T fetch(Class&lt;T&gt; clazz, Object id) &#123;        Mapper&lt;T&gt; mapper = getMapper(clazz);        List&lt;T&gt; list = (List&lt;T&gt;) jdbcTemplate.query(mapper.selectSQL, new Object[] &#123; id &#125;, mapper.rowMapper);        if (list.isEmpty()) &#123;            return null;        &#125;        return list.get(0);    &#125;    public &lt;T&gt; T get(Class&lt;T&gt; clazz, Object id) &#123;        ...    &#125;    public &lt;T&gt; void insert(T bean) &#123;        ...    &#125;    public &lt;T&gt; void update(T bean) &#123;        ...    &#125;    public &lt;T&gt; void delete(Class&lt;T&gt; clazz, Object id) &#123;        ...    &#125;&#125;\n实现链式API的核心代码是第一步从DbTemplate调用select()或from()时实例化一个CriteriaQuery实例，并在后续的链式调用中设置它的字段：\n1234567891011public class DbTemplate &#123;    ...    public Select select(String... selectFields) &#123;        return new Select(new Criteria(this), selectFields);    &#125;    public &lt;T&gt; From&lt;T&gt; from(Class&lt;T&gt; entityClass) &#123;        Mapper&lt;T&gt; mapper = getMapper(entityClass);        return new From&lt;&gt;(new Criteria&lt;&gt;(this), mapper);    &#125;&#125;\n然后以此定义Select、From、Where、OrderBy、Limit等。在From中可以设置Class类型、表名等：\n12345678910111213public final class From&lt;T&gt; extends CriteriaQuery&lt;T&gt; &#123;    From(Criteria&lt;T&gt; criteria, Mapper&lt;T&gt; mapper) &#123;        super(criteria);        // from可以设置class、tableName:        this.criteria.mapper = mapper;        this.criteria.clazz = mapper.entityClass;        this.criteria.table = mapper.tableName;    &#125;    public Where&lt;T&gt; where(String clause, Object... args) &#123;        return new Where&lt;&gt;(this.criteria, clause, args);    &#125;&#125;\n在Where中可以设置条件参数：\n1234567891011public final class Where&lt;T&gt; extends CriteriaQuery&lt;T&gt; &#123;    Where(Criteria&lt;T&gt; criteria, String clause, Object... params) &#123;        super(criteria);        this.criteria.where = clause;        this.criteria.whereParams = new ArrayList&lt;&gt;();        // add:        for (Object param : params) &#123;            this.criteria.whereParams.add(param);        &#125;    &#125;&#125;\n最后，链式调用的尽头是调用list()返回一组结果，调用unique()返回唯一结果，调用first()返回首个结果。\n在IDE中，可以非常方便地实现链式调用：\n\n需要复杂查询的时候，总是可以使用JdbcTemplate执行任意复杂的SQL。\n练习\n设计并实现一个微型ORM。\n下载练习\n小结\nORM框架就是自动映射数据库表结构到JavaBean的工具，设计并实现一个简单高效的ORM框架并不困难。\n","dateCreated":"2025-05-26T16:32:39+08:00","dateModified":"2025-05-26T16:40:27+08:00","datePublished":"2025-05-26T16:32:39+08:00","description":"","headline":"JAVA-Spring开发-访问数据库","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://chankein.github.io/2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"},"publisher":{"@type":"Organization","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg","logo":{"@type":"ImageObject","url":"profile.jpg"}},"url":"https://chankein.github.io/2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/","keywords":"Java, Spirng"}</script>
    <meta name="description" content="数据库基本上是现代应用程序的标准存储，绝大多数程序都把自己的业务数据存储在关系数据库中，可见，访问数据库几乎是所有应用程序必备能力。 我们在前面已经介绍了Java程序访问数据库的标准接口JDBC，它的实现方式非常简洁，即：Java标准库定义接口，各数据库厂商以“驱动”的形式实现接口。应用程序要使用哪个数据库，就把该数据库厂商的驱动以jar包形式引入进来，同时自身仅使用JDBC接口，编译期并不需要特">
<meta property="og:type" content="blog">
<meta property="og:title" content="JAVA-Spring开发-访问数据库">
<meta property="og:url" content="https://chankein.github.io/2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:description" content="数据库基本上是现代应用程序的标准存储，绝大多数程序都把自己的业务数据存储在关系数据库中，可见，访问数据库几乎是所有应用程序必备能力。 我们在前面已经介绍了Java程序访问数据库的标准接口JDBC，它的实现方式非常简洁，即：Java标准库定义接口，各数据库厂商以“驱动”的形式实现接口。应用程序要使用哪个数据库，就把该数据库厂商的驱动以jar包形式引入进来，同时自身仅使用JDBC接口，编译期并不需要特">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/spring/database/orm/db.gif">
<meta property="article:published_time" content="2025-05-26T08:32:39.000Z">
<meta property="article:modified_time" content="2025-05-26T08:40:27.015Z">
<meta property="article:author" content="Kein Chan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spirng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liaoxuefeng.com/books/java/spring/database/orm/db.gif">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../../../#about"
            >
        
        
            <img class="header-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            JAVA-Spring开发-访问数据库
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2025-05-26T16:32:39+08:00">
	
		    2025 年 5 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/">Java</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>数据库基本上是现代应用程序的标准存储，绝大多数程序都把自己的业务数据存储在关系数据库中，可见，访问数据库几乎是所有应用程序必备能力。</p>
<p>我们在前面已经介绍了Java程序访问数据库的标准接口JDBC，它的实现方式非常简洁，即：Java标准库定义接口，各数据库厂商以“驱动”的形式实现接口。应用程序要使用哪个数据库，就把该数据库厂商的驱动以jar包形式引入进来，同时自身仅使用JDBC接口，编译期并不需要特定厂商的驱动。</p>
<p>使用JDBC虽然简单，但代码比较繁琐。Spring为了简化数据库访问，主要做了以下几点工作：</p>
<ul>
<li>提供了简化的访问JDBC的模板类，不必手动释放资源；</li>
<li>提供了一个统一的DAO类以实现Data Access Object模式；</li>
<li>把<code>SQLException</code>封装为<code>DataAccessException</code>，这个异常是一个<code>RuntimeException</code>，并且让我们能区分SQL异常的原因，例如，<code>DuplicateKeyException</code>表示违反了一个唯一约束；</li>
<li>能方便地集成Hibernate、JPA和MyBatis这些数据库访问框架。</li>
</ul>
<p>本章我们将详细讲解在Spring中访问数据库的最佳实践。</p>
<p>我们在前面介绍<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/jdbc/index.html">JDBC编程</a>时已经讲过，Java程序使用JDBC接口访问关系数据库的时候，需要以下几步：</p>
<ul>
<li>创建全局<code>DataSource</code>实例，表示数据库连接池；</li>
<li>在需要读写数据库的方法内部，按如下步骤访问数据库：
<ul>
<li>从全局<code>DataSource</code>实例获取<code>Connection</code>实例；</li>
<li>通过<code>Connection</code>实例创建<code>PreparedStatement</code>实例；</li>
<li>执行SQL语句，如果是查询，则通过<code>ResultSet</code>读取结果集，如果是修改，则获得<code>int</code>结果。</li>
</ul>
</li>
</ul>
<p>正确编写JDBC代码的关键是使用<code>try ... finally</code>释放资源，涉及到事务的代码需要正确提交或回滚事务。</p>
<p>在Spring使用JDBC，首先我们通过IoC容器创建并管理一个<code>DataSource</code>实例，然后，Spring提供了一个<code>JdbcTemplate</code>，可以方便地让我们操作JDBC，因此，通常情况下，我们会实例化一个<code>JdbcTemplate</code>。顾名思义，这个类主要使用了<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/template-method/index.html">Template模式</a>。</p>
<p>编写示例代码或者测试代码时，我们强烈推荐使用<a target="_blank" rel="noopener" href="https://hsqldb.org/">HSQLDB</a>这个数据库，它是一个用Java编写的关系数据库，可以以内存模式或者文件模式运行，本身只有一个jar包，非常适合演示代码或者测试代码。</p>
<p>我们以实际工程为例，先创建Maven工程<code>spring-data-jdbc</code>，然后引入以下依赖：</p>
<ul>
<li>org.springframework:spring-context:6.0.0</li>
<li>org.springframework:spring-jdbc:6.0.0</li>
<li>jakarta.annotation:jakarta.annotation-api:2.1.1</li>
<li>com.zaxxer:HikariCP:5.0.1</li>
<li>org.hsqldb:hsqldb:2.7.1</li>
</ul>
<p>在<code>AppConfig</code>中，我们需要创建以下几个必须的Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    String jdbcUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    String jdbcUsername;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    String jdbcPassword;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HikariConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">        config.setJdbcUrl(jdbcUrl);</span><br><span class="line">        config.setUsername(jdbcUsername);</span><br><span class="line">        config.setPassword(jdbcPassword);</span><br><span class="line">        config.addDataSourceProperty(<span class="string">&quot;autoCommit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        config.addDataSourceProperty(<span class="string">&quot;connectionTimeout&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">        config.addDataSourceProperty(<span class="string">&quot;idleTimeout&quot;</span>, <span class="string">&quot;60&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    JdbcTemplate <span class="title function_">createJdbcTemplate</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述配置中：</p>
<ol>
<li>通过<code>@PropertySource(&quot;jdbc.properties&quot;)</code>读取数据库配置文件；</li>
<li>通过<code>@Value(&quot;$&#123;jdbc.url&#125;&quot;)</code>注入配置文件的相关配置；</li>
<li>创建一个DataSource实例，它的实际类型是<code>HikariDataSource</code>，创建时需要用到注入的配置；</li>
<li>创建一个JdbcTemplate实例，它需要注入<code>DataSource</code>，这是通过方法参数完成注入的。</li>
</ol>
<p>最后，针对HSQLDB写一个配置文件<code>jdbc.properties</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 数据库文件名为testdb:</span><br><span class="line">jdbc.url=jdbc:hsqldb:file:testdb</span><br><span class="line"></span><br><span class="line"># Hsqldb默认的用户名是sa，口令是空字符串:</span><br><span class="line">jdbc.username=sa</span><br><span class="line">jdbc.password=</span><br></pre></td></tr></table></figure>
<p>可以通过HSQLDB自带的工具来初始化数据库表，这里我们写一个Bean，在Spring容器启动时自动创建一个<code>users</code>表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseInitializer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;CREATE TABLE IF NOT EXISTS users (&quot;</span> <span class="comment">//</span></span><br><span class="line">                + <span class="string">&quot;id BIGINT IDENTITY NOT NULL PRIMARY KEY, &quot;</span> <span class="comment">//</span></span><br><span class="line">                + <span class="string">&quot;email VARCHAR(100) NOT NULL, &quot;</span> <span class="comment">//</span></span><br><span class="line">                + <span class="string">&quot;password VARCHAR(100) NOT NULL, &quot;</span> <span class="comment">//</span></span><br><span class="line">                + <span class="string">&quot;name VARCHAR(100) NOT NULL, &quot;</span> <span class="comment">//</span></span><br><span class="line">                + <span class="string">&quot;UNIQUE (email))&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，所有准备工作都已完毕。我们只需要在需要访问数据库的Bean中，注入<code>JdbcTemplate</code>即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JdbcTemplate用法">JdbcTemplate用法</h3>
<p>Spring提供的<code>JdbcTemplate</code>采用Template模式，提供了一系列以回调为特点的工具方法，目的是避免繁琐的<code>try...catch</code>语句。</p>
<p>我们以具体的示例来说明JdbcTemplate的用法。</p>
<p>首先我们看<code>T execute(ConnectionCallback&lt;T&gt; action)</code>方法，它提供了Jdbc的<code>Connection</code>供我们使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">    <span class="comment">// 注意传入的是ConnectionCallback:</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.execute((Connection conn) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 可以直接使用conn实例，不要释放它，回调结束后JdbcTemplate自动释放:</span></span><br><span class="line">        <span class="comment">// 在内部手动创建的PreparedStatement、ResultSet必须用try(...)释放:</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(<span class="string">&quot;SELECT * FROM users WHERE id = ?&quot;</span>)) &#123;</span><br><span class="line">            ps.setObject(<span class="number">1</span>, id);</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>( <span class="comment">// new User object:</span></span><br><span class="line">                            rs.getLong(<span class="string">&quot;id&quot;</span>), <span class="comment">// id</span></span><br><span class="line">                            rs.getString(<span class="string">&quot;email&quot;</span>), <span class="comment">// email</span></span><br><span class="line">                            rs.getString(<span class="string">&quot;password&quot;</span>), <span class="comment">// password</span></span><br><span class="line">                            rs.getString(<span class="string">&quot;name&quot;</span>)); <span class="comment">// name</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;user not found by id.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，上述回调方法允许获取Connection，然后做任何基于Connection的操作。</p>
<p>我们再看<code>T execute(String sql, PreparedStatementCallback&lt;T&gt; action)</code>的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserByName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 需要传入SQL语句，以及PreparedStatementCallback:</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.execute(<span class="string">&quot;SELECT * FROM users WHERE name = ?&quot;</span>, (PreparedStatement ps) -&gt; &#123;</span><br><span class="line">        <span class="comment">// PreparedStatement实例已经由JdbcTemplate创建，并在回调后自动释放:</span></span><br><span class="line">        ps.setObject(<span class="number">1</span>, name);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>( <span class="comment">// new User object:</span></span><br><span class="line">                        rs.getLong(<span class="string">&quot;id&quot;</span>), <span class="comment">// id</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;email&quot;</span>), <span class="comment">// email</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;password&quot;</span>), <span class="comment">// password</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;name&quot;</span>)); <span class="comment">// name</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;user not found by id.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们看<code>T queryForObject(String sql, RowMapper&lt;T&gt; rowMapper, Object... args)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserByEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">    <span class="comment">// 传入SQL，参数和RowMapper实例:</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(<span class="string">&quot;SELECT * FROM users WHERE email = ?&quot;</span>,</span><br><span class="line">            (ResultSet rs, <span class="type">int</span> rowNum) -&gt; &#123;</span><br><span class="line">                <span class="comment">// 将ResultSet的当前行映射为一个JavaBean:</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>( <span class="comment">// new User object:</span></span><br><span class="line">                        rs.getLong(<span class="string">&quot;id&quot;</span>), <span class="comment">// id</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;email&quot;</span>), <span class="comment">// email</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;password&quot;</span>), <span class="comment">// password</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;name&quot;</span>)); <span class="comment">// name</span></span><br><span class="line">            &#125;,</span><br><span class="line">            email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>queryForObject()</code>方法中，传入SQL以及SQL参数后，<code>JdbcTemplate</code>会自动创建<code>PreparedStatement</code>，自动执行查询并返回<code>ResultSet</code>，我们提供的<code>RowMapper</code>需要做的事情就是把<code>ResultSet</code>的当前行映射成一个JavaBean并返回。整个过程中，使用<code>Connection</code>、<code>PreparedStatement</code>和<code>ResultSet</code>都不需要我们手动管理。</p>
<p><code>RowMapper</code>不一定返回JavaBean，实际上它可以返回任何Java对象。例如，使用<code>SELECT COUNT(*)</code>查询时，可以返回<code>Long</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(<span class="string">&quot;SELECT COUNT(*) FROM users&quot;</span>, (ResultSet rs, <span class="type">int</span> rowNum) -&gt; &#123;</span><br><span class="line">        <span class="comment">// SELECT COUNT(*)查询只有一列，取第一列数据:</span></span><br><span class="line">        <span class="keyword">return</span> rs.getLong(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们期望返回多行记录，而不是一行，可以用<code>query()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUsers</span><span class="params">(<span class="type">int</span> pageIndex)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> limit * (pageIndex - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.query(<span class="string">&quot;SELECT * FROM users LIMIT ? OFFSET ?&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class),</span><br><span class="line">            limit, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述<code>query()</code>方法传入的参数仍然是SQL、SQL参数以及<code>RowMapper</code>实例。这里我们直接使用Spring提供的<code>BeanPropertyRowMapper</code>。如果数据库表的结构恰好和JavaBean的属性名称一致，那么<code>BeanPropertyRowMapper</code>就可以直接把一行记录按列名转换为JavaBean。</p>
<p>如果我们执行的不是查询，而是插入、更新和删除操作，那么需要使用<code>update()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="comment">// 传入SQL，SQL参数，返回更新的行数:</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> != jdbcTemplate.update(<span class="string">&quot;UPDATE users SET name = ? WHERE id = ?&quot;</span>, user.getName(), user.getId())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;User not found by id&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有一种<code>INSERT</code>操作比较特殊，那就是如果某一列是自增列（例如自增主键），通常，我们需要获取插入后的自增值。<code>JdbcTemplate</code>提供了一个<code>KeyHolder</code>来简化这一操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个KeyHolder:</span></span><br><span class="line">    <span class="type">KeyHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneratedKeyHolder</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> != jdbcTemplate.update(</span><br><span class="line">        <span class="comment">// 参数1:PreparedStatementCreator</span></span><br><span class="line">        (conn) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 创建PreparedStatement时，必须指定RETURN_GENERATED_KEYS:</span></span><br><span class="line">            <span class="type">var</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(<span class="string">&quot;INSERT INTO users(email, password, name) VALUES(?, ?, ?)&quot;</span>,</span><br><span class="line">                    Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">            ps.setObject(<span class="number">1</span>, email);</span><br><span class="line">            ps.setObject(<span class="number">2</span>, password);</span><br><span class="line">            ps.setObject(<span class="number">3</span>, name);</span><br><span class="line">            <span class="keyword">return</span> ps;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 参数2:KeyHolder</span></span><br><span class="line">        holder)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Insert failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从KeyHolder中获取返回的自增值:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(holder.getKey().longValue(), email, password, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>JdbcTemplate</code>还有许多重载方法，这里我们不一一介绍。需要强调的是，<code>JdbcTemplate</code>只是对JDBC操作的一个简单封装，它的目的是尽量减少手动编写<code>try(resource) &#123;...&#125;</code>的代码，对于查询，主要通过<code>RowMapper</code>实现了JDBC结果集到Java对象的转换。</p>
<p>我们总结一下<code>JdbcTemplate</code>的用法，那就是：</p>
<ul>
<li>针对简单查询，优选<code>query()</code>和<code>queryForObject()</code>，因为只需提供SQL语句、参数和<code>RowMapper</code>；</li>
<li>针对更新操作，优选<code>update()</code>，因为只需提供SQL语句和参数；</li>
<li>任何复杂的操作，最终也可以通过<code>execute(ConnectionCallback)</code>实现，因为拿到<code>Connection</code>就可以做任何JDBC操作。</li>
</ul>
<p>实际上我们使用最多的仍然是各种查询。如果在设计表结构的时候，能够和JavaBean的属性一一对应，那么直接使用<code>BeanPropertyRowMapper</code>就很方便。如果表结构和JavaBean不一致怎么办？那就需要稍微改写一下查询，使结果集的结构和JavaBean保持一致。</p>
<p>例如，表的列名是<code>office_address</code>，而JavaBean属性是<code>workAddress</code>，就需要指定别名，改写查询如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, email, office_address AS workAddress, name FROM users <span class="type">WHERE</span> <span class="variable">email</span> <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure>
<h3 id="练习">练习</h3>
<p>使用JdbcTemplate。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/database/jdbc/spring-data-jdbc.zip">下载练习</a></p>
<h3 id="小结">小结</h3>
<p>Spring提供了<code>JdbcTemplate</code>来简化JDBC操作；</p>
<p>使用<code>JdbcTemplate</code>时，根据需要优先选择高级方法；</p>
<p>任何JDBC操作都可以使用保底的<code>execute(ConnectionCallback)</code>方法。</p>
<p>使用Spring操作JDBC虽然方便，但是我们在前面讨论JDBC的时候，讲到过<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/jdbc/tx/index.html">JDBC事务</a>，如果要在Spring中操作事务，没必要手写JDBC事务，可以使用Spring提供的高级接口来操作事务。</p>
<p>Spring提供了一个<code>PlatformTransactionManager</code>来表示事务管理器，所有的事务都由它负责管理。而事务由<code>TransactionStatus</code>表示。如果手写事务代码，使用<code>try...catch</code>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TransactionStatus</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 开启事务:</span></span><br><span class="line">    tx = txManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line">    <span class="comment">// 相关JDBC操作:</span></span><br><span class="line">    jdbcTemplate.update(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    jdbcTemplate.update(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    <span class="comment">// 提交事务:</span></span><br><span class="line">    txManager.commit(tx);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="comment">// 回滚事务:</span></span><br><span class="line">    txManager.rollback(tx);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring为啥要抽象出<code>PlatformTransactionManager</code>和<code>TransactionStatus</code>？原因是JavaEE除了提供JDBC事务外，它还支持分布式事务JTA（Java Transaction API）。分布式事务是指多个数据源（比如多个数据库，多个消息系统）要在分布式环境下实现事务的时候，应该怎么实现。分布式事务实现起来非常复杂，简单地说就是通过一个分布式事务管理器实现两阶段提交，但本身数据库事务就不快，基于数据库事务实现的分布式事务就慢得难以忍受，所以使用率不高。</p>
<p>Spring为了同时支持JDBC和JTA两种事务模型，就抽象出<code>PlatformTransactionManager</code>。因为我们的代码只需要JDBC事务，因此，在<code>AppConfig</code>中，需要再定义一个<code>PlatformTransactionManager</code>对应的Bean，它的实际类型是<code>DataSourceTransactionManager</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    PlatformTransactionManager <span class="title function_">createTxManager</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用编程的方式使用Spring事务仍然比较繁琐，更好的方式是通过声明式事务来实现。使用声明式事务非常简单，除了在<code>AppConfig</code>中追加一个上述定义的<code>PlatformTransactionManager</code>外，再加一个<code>@EnableTransactionManagement</code>就可以启用声明式事务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">// 启用声明式</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，对需要事务支持的方法，加一个<code>@Transactional</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 此public方法自动具有事务支持:</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者更简单一点，直接在Bean的<code>class</code>处加上，表示所有<code>public</code>方法都具有事务支持：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring对一个声明式事务的方法，如何开启事务支持？原理仍然是AOP代理，即通过自动创建Bean的Proxy实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService$$EnhancerBySpringCGLIB</span> <span class="keyword">extends</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">target</span> <span class="operator">=</span> ...</span><br><span class="line">    <span class="type">PlatformTransactionManager</span> <span class="variable">txManager</span> <span class="operator">=</span> ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tx = txManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line">            target.register(email, password, name);</span><br><span class="line">            txManager.commit(tx);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            txManager.rollback(tx);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：声明了<code>@EnableTransactionManagement</code>后，不必额外添加<code>@EnableAspectJAutoProxy</code>。</p>
<h3 id="回滚事务">回滚事务</h3>
<p>默认情况下，如果发生了<code>RuntimeException</code>，Spring的声明式事务将自动回滚。在一个事务方法中，如果程序判断需要回滚事务，只需抛出<code>RuntimeException</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">buyProducts</span><span class="params">(<span class="type">long</span> productId, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (store &lt; num) &#123;</span><br><span class="line">        <span class="comment">// 库存不够，购买失败:</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;No enough products&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要针对Checked Exception回滚事务，需要在<code>@Transactional</code>注解中写出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;RuntimeException.class, IOException.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">buyProducts</span><span class="params">(<span class="type">long</span> productId, <span class="type">int</span> num)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码表示在抛出<code>RuntimeException</code>或<code>IOException</code>时，事务将回滚。</p>
<p>为了简化代码，我们强烈建议业务异常体系从<code>RuntimeException</code>派生，这样就不必声明任何特殊异常即可让Spring的声明式事务正常工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginException</span> <span class="keyword">extends</span> <span class="title class_">BusinessException</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentException</span> <span class="keyword">extends</span> <span class="title class_">BusinessException</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事务边界">事务边界</h3>
<p>在使用事务的时候，明确事务边界非常重要。对于声明式事务，例如，下面的<code>register()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123; <span class="comment">// 事务开始</span></span><br><span class="line">       ...</span><br><span class="line">    &#125; <span class="comment">// 事务结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的事务边界就是<code>register()</code>方法开始和结束。</p>
<p>类似的，一个负责给用户增加积分的<code>addBonus()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BonusService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBonus</span><span class="params">(<span class="type">long</span> userId, <span class="type">int</span> bonus)</span> &#123; <span class="comment">// 事务开始</span></span><br><span class="line">       ...</span><br><span class="line">    &#125; <span class="comment">// 事务结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的事务边界就是<code>addBonus()</code>方法开始和结束。</p>
<p>在现实世界中，问题总是要复杂一点点。用户注册后，能自动获得100积分，因此，实际代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    BonusService bonusService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="comment">// 插入用户记录:</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> jdbcTemplate.insert(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        <span class="comment">// 增加100积分:</span></span><br><span class="line">        bonusService.addBonus(user.id, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在问题来了：调用方（比如<code>RegisterController</code>）调用<code>UserService.register()</code>这个事务方法，它在内部又调用了<code>BonusService.addBonus()</code>这个事务方法，一共有几个事务？如果<code>addBonus()</code>抛出了异常需要回滚事务，<code>register()</code>方法的事务是否也要回滚？</p>
<p>问题的复杂度是不是一下子提高了10倍？</p>
<h3 id="事务传播">事务传播</h3>
<p>要解决上面的问题，我们首先要定义事务的传播模型。</p>
<p>假设用户注册的入口是<code>RegisterController</code>，它本身没有事务，仅仅是调用<code>UserService.register()</code>这个事务方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">doRegister</span><span class="params">(HttpServletRequest req)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.register(email, password, name);</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，<code>UserService.register()</code>这个事务方法的起始和结束，就是事务的范围。</p>
<p>我们需要关心的问题是，在<code>UserService.register()</code>这个事务方法内，调用<code>BonusService.addBonus()</code>，我们期待的事务行为是什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 事务已开启:</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> jdbcTemplate.insert(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    <span class="comment">// ???:</span></span><br><span class="line">    bonusService.addBonus(user.id, <span class="number">100</span>);</span><br><span class="line">&#125; <span class="comment">// 事务结束</span></span><br></pre></td></tr></table></figure>
<p>对于大多数业务来说，我们期待<code>BonusService.addBonus()</code>的调用，和<code>UserService.register()</code>应当融合在一起，它的行为应该如下：</p>
<p><code>UserService.register()</code>已经开启了一个事务，那么在内部调用<code>BonusService.addBonus()</code>时，<code>BonusService.addBonus()</code>方法就没必要再开启一个新事务，直接加入到<code>BonusService.register()</code>的事务里就好了。</p>
<p>其实就相当于：</p>
<ol>
<li><code>UserService.register()</code>先执行了一条INSERT语句：<code>INSERT INTO users ...</code></li>
<li><code>BonusService.addBonus()</code>再执行一条INSERT语句：<code>INSERT INTO bonus ...</code></li>
</ol>
<p>因此，Spring的声明式事务为事务传播定义了几个级别，默认传播级别就是REQUIRED，它的意思是，如果当前没有事务，就创建一个新事务，如果当前有事务，就加入到当前事务中执行。</p>
<p>我们观察<code>UserService.register()</code>方法，它在<code>RegisterController</code>中执行，因为<code>RegisterController</code>没有事务，因此，<code>UserService.register()</code>方法会自动创建一个新事务。</p>
<p>在<code>UserService.register()</code>方法内部，调用<code>BonusService.addBonus()</code>方法时，因为<code>BonusService.addBonus()</code>检测到当前已经有事务了，因此，它会加入到当前事务中执行。</p>
<p>因此，整个业务流程的事务边界就清晰了：它只有一个事务，并且范围就是<code>UserService.register()</code>方法。</p>
<p>有的童鞋会问：把<code>BonusService.addBonus()</code>方法的<code>@Transactional</code>去掉，变成一个普通方法，那不就规避了复杂的传播模型吗？</p>
<p>去掉<code>BonusService.addBonus()</code>方法的<code>@Transactional</code>，会引来另一个问题，即其他地方如果调用<code>BonusService.addBonus()</code>方法，那就没法保证事务了。例如，规定用户登录时积分+5：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    BonusService bonusService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">doLogin</span><span class="params">(HttpServletRequest req)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> ...</span><br><span class="line">        bonusService.addBonus(user.id, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，<code>BonusService.addBonus()</code>方法必须要有<code>@Transactional</code>，否则，登录后积分就无法添加了。</p>
<p>默认的事务传播级别是<code>REQUIRED</code>，它满足绝大部分的需求。还有一些其他的传播级别：</p>
<p><code>SUPPORTS</code>：表示如果有事务，就加入到当前事务，如果没有，那也不开启事务执行。这种传播级别可用于查询方法，因为SELECT语句既可以在事务内执行，也可以不需要事务；</p>
<p><code>MANDATORY</code>：表示必须要存在当前事务并加入执行，否则将抛出异常。这种传播级别可用于核心更新逻辑，比如用户余额变更，它总是被其他事务方法调用，不能直接由非事务方法调用；</p>
<p><code>REQUIRES_NEW</code>：表示不管当前有没有事务，都必须开启一个新的事务执行。如果当前已经有事务，那么当前事务会挂起，等新事务完成后，再恢复执行；</p>
<p><code>NOT_SUPPORTED</code>：表示不支持事务，如果当前有事务，那么当前事务会挂起，等这个方法执行完成后，再恢复执行；</p>
<p><code>NEVER</code>：和<code>NOT_SUPPORTED</code>相比，它不但不支持事务，而且在监测到当前有事务时，会抛出异常拒绝执行；</p>
<p><code>NESTED</code>：表示如果当前有事务，则开启一个嵌套级别事务，如果当前没有事务，则开启一个新事务。</p>
<p>上面这么多种事务的传播级别，其实默认的<code>REQUIRED</code>已经满足绝大部分需求，<code>SUPPORTS</code>和<code>REQUIRES_NEW</code>在少数情况下会用到，其他基本不会用到，因为把事务搞得越复杂，不仅逻辑跟着复杂，而且速度也会越慢。</p>
<p>定义事务的传播级别也是写在<code>@Transactional</code>注解里的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在只剩最后一个问题了：Spring是如何传播事务的？</p>
<p>我们<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/jdbc/tx/index.html">在JDBC中使用事务</a>的时候，是这么个写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> openConnection();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭自动提交:</span></span><br><span class="line">    conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 执行多条SQL语句:</span></span><br><span class="line">    insert(); update(); delete();</span><br><span class="line">    <span class="comment">// 提交事务:</span></span><br><span class="line">    conn.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="comment">// 回滚事务:</span></span><br><span class="line">    conn.rollback();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    conn.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring使用声明式事务，最终也是通过执行JDBC事务来实现功能的，那么，一个事务方法，如何获知当前是否存在事务？</p>
<p>答案是<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/threading/thread-local/index.html">使用ThreadLocal</a>。Spring总是把JDBC相关的<code>Connection</code>和<code>TransactionStatus</code>实例绑定到<code>ThreadLocal</code>。如果一个事务方法从<code>ThreadLocal</code>未取到事务，那么它会打开一个新的JDBC连接，同时开启一个新的事务，否则，它就直接使用从<code>ThreadLocal</code>获取的JDBC连接以及<code>TransactionStatus</code>。</p>
<p>因此，事务能正确传播的前提是，方法调用是在一个线程内才行。如果像下面这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123; <span class="comment">// BEGIN TX-A</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> jdbcTemplate.insert(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// BEGIN TX-B:</span></span><br><span class="line">        bonusService.addBonus(user.id, <span class="number">100</span>);</span><br><span class="line">        <span class="comment">// END TX-B</span></span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125; <span class="comment">// END TX-A</span></span><br></pre></td></tr></table></figure>
<p>在另一个线程中调用<code>BonusService.addBonus()</code>，它根本获取不到当前事务，因此，<code>UserService.register()</code>和<code>BonusService.addBonus()</code>两个方法，将分别开启两个完全独立的事务。</p>
<p>换句话说，事务只能在当前线程传播，无法跨线程传播。</p>
<p>那如果我们想实现跨线程传播事务呢？原理很简单，就是要想办法把当前线程绑定到<code>ThreadLocal</code>的<code>Connection</code>和<code>TransactionStatus</code>实例传递给新线程，但实现起来非常复杂，根据异常回滚更加复杂，不推荐自己去实现。</p>
<h3 id="练习-2">练习</h3>
<p>使用声明式事务。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/database/declarative-tx/spring-data-tx.zip">下载练习</a></p>
<h3 id="小结-2">小结</h3>
<p>Spring提供的声明式事务极大地方便了在数据库中使用事务，正确使用声明式事务的关键在于确定好事务边界，理解事务传播级别。</p>
<p>在传统的多层应用程序中，通常是Web层调用业务层，业务层调用数据访问层。业务层负责处理各种业务逻辑，而数据访问层只负责对数据进行增删改查。因此，实现数据访问层就是用<code>JdbcTemplate</code>实现对数据库的操作。</p>
<p>编写数据访问层的时候，可以使用DAO模式。DAO即Data Access Object的缩写，它没有什么神秘之处，实现起来基本如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    User <span class="title function_">getById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; <span class="title function_">getUsers</span><span class="params">(<span class="type">int</span> page)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    User <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    User <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring提供了一个<code>JdbcDaoSupport</code>类，用于简化DAO的实现。这个<code>JdbcDaoSupport</code>没什么复杂的，核心代码就是持有一个<code>JdbcTemplate</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">JdbcDaoSupport</span> <span class="keyword">extends</span> <span class="title class_">DaoSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setJdbcTemplate</span><span class="params">(JdbcTemplate jdbcTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">        initTemplateConfig();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> JdbcTemplate <span class="title function_">getJdbcTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的意图是子类直接从<code>JdbcDaoSupport</code>继承后，可以随时调用<code>getJdbcTemplate()</code>获得<code>JdbcTemplate</code>的实例。那么问题来了：因为<code>JdbcDaoSupport</code>的<code>jdbcTemplate</code>字段没有标记<code>@Autowired</code>，所以，子类想要注入<code>JdbcTemplate</code>，还得自己想个办法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> <span class="keyword">extends</span> <span class="title class_">JdbcDaoSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setJdbcTemplate(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有的童鞋可能看出来了：既然<code>UserDao</code>都已经注入了<code>JdbcTemplate</code>，那再把它放到父类里，通过<code>getJdbcTemplate()</code>访问岂不是多此一举？</p>
<p>如果使用传统的XML配置，并不需要编写<code>@Autowired JdbcTemplate jdbcTemplate</code>，但是考虑到现在基本上是使用注解的方式，我们可以编写一个<code>AbstractDao</code>，专门负责注入<code>JdbcTemplate</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractDao</span> <span class="keyword">extends</span> <span class="title class_">JdbcDaoSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setJdbcTemplate(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，子类的代码就非常干净，可以直接调用<code>getJdbcTemplate()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> <span class="keyword">extends</span> <span class="title class_">AbstractDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getJdbcTemplate().queryForObject(</span><br><span class="line">                <span class="string">&quot;SELECT * FROM users WHERE id = ?&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class),</span><br><span class="line">                id</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>倘若肯再多写一点样板代码，就可以把<code>AbstractDao</code>改成泛型，并实现<code>getById()</code>，<code>getAll()</code>，<code>deleteById()</code>这样的通用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractDao</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">JdbcDaoSupport</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String table;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; entityClass;</span><br><span class="line">    <span class="keyword">private</span> RowMapper&lt;T&gt; rowMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前类型的泛型类型:</span></span><br><span class="line">        <span class="built_in">this</span>.entityClass = getParameterizedType();</span><br><span class="line">        <span class="built_in">this</span>.table = <span class="built_in">this</span>.entityClass.getSimpleName().toLowerCase() + <span class="string">&quot;s&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.rowMapper = <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(entityClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getJdbcTemplate().queryForObject(<span class="string">&quot;SELECT * FROM &quot;</span> + table + <span class="string">&quot; WHERE id = ?&quot;</span>, <span class="built_in">this</span>.rowMapper, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">getAll</span><span class="params">(<span class="type">int</span> pageIndex)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> limit * (pageIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> getJdbcTemplate().query(<span class="string">&quot;SELECT * FROM &quot;</span> + table + <span class="string">&quot; LIMIT ? OFFSET ?&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; limit, offset &#125;,</span><br><span class="line">                <span class="built_in">this</span>.rowMapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        getJdbcTemplate().update(<span class="string">&quot;DELETE FROM &quot;</span> + table + <span class="string">&quot; WHERE id = ?&quot;</span>, id);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，每个子类就自动获得了这些通用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> <span class="keyword">extends</span> <span class="title class_">AbstractDao</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 已经有了:</span></span><br><span class="line">    <span class="comment">// User getById(long)</span></span><br><span class="line">    <span class="comment">// List&lt;User&gt; getAll(int)</span></span><br><span class="line">    <span class="comment">// void deleteById(long)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDao</span> <span class="keyword">extends</span> <span class="title class_">AbstractDao</span>&lt;Book&gt; &#123;</span><br><span class="line">    <span class="comment">// 已经有了:</span></span><br><span class="line">    <span class="comment">// Book getById(long)</span></span><br><span class="line">    <span class="comment">// List&lt;Book&gt; getAll(int)</span></span><br><span class="line">    <span class="comment">// void deleteById(long)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，DAO模式就是一个简单的数据访问模式，是否使用DAO，根据实际情况决定，因为很多时候，直接在Service层操作数据库也是完全没有问题的。</p>
<h3 id="练习-3">练习</h3>
<p>使用DAO模式访问数据库。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/database/dao/spring-data-dao.zip">下载练习</a></p>
<h3 id="小结-3">小结</h3>
<p>Spring提供了<code>JdbcDaoSupport</code>来便于我们实现DAO模式；</p>
<p>可以基于泛型实现更通用、更简洁的DAO模式。</p>
<p>使用<code>JdbcTemplate</code>的时候，我们用得最多的方法就是<code>List&lt;T&gt; query(String, RowMapper, Object...)</code>。这个<code>RowMapper</code>的作用就是把<code>ResultSet</code>的一行记录映射为Java Bean。</p>
<p>这种把关系数据库的表记录映射为Java对象的过程就是ORM：Object-Relational Mapping。ORM既可以把记录转换成Java对象，也可以把Java对象转换为行记录。</p>
<p>使用<code>JdbcTemplate</code>配合<code>RowMapper</code>可以看作是最原始的ORM。如果要实现更自动化的ORM，可以选择成熟的ORM框架，例如<a target="_blank" rel="noopener" href="https://hibernate.org/">Hibernate</a>。</p>
<p>我们来看看如何在Spring中集成Hibernate。</p>
<p>Hibernate作为ORM框架，它可以替代<code>JdbcTemplate</code>，但Hibernate仍然需要JDBC驱动，所以，我们需要引入JDBC驱动、连接池，以及Hibernate本身。在Maven中，我们加入以下依赖项：</p>
<ul>
<li>org.springframework:spring-context:6.0.0</li>
<li>org.springframework:spring-orm:6.0.0</li>
<li>jakarta.annotation:jakarta.annotation-api:2.1.1</li>
<li>jakarta.persistence:jakarta.persistence-api:3.1.0</li>
<li>org.hibernate:hibernate-core:6.1.4.Final</li>
<li>com.zaxxer:HikariCP:5.0.1</li>
<li>org.hsqldb:hsqldb:2.7.1</li>
</ul>
<p>在<code>AppConfig</code>中，我们仍然需要创建<code>DataSource</code>、引入JDBC配置文件，以及启用声明式事务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了启用Hibernate，我们需要创建一个<code>LocalSessionFactoryBean</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    LocalSessionFactoryBean <span class="title function_">createSessionFactory</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        props.setProperty(<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>, <span class="string">&quot;update&quot;</span>); <span class="comment">// 生产环境不要使用</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;hibernate.dialect&quot;</span>, <span class="string">&quot;org.hibernate.dialect.HSQLDialect&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;hibernate.show_sql&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="type">var</span> <span class="variable">sessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalSessionFactoryBean</span>();</span><br><span class="line">        sessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">// 扫描指定的package获取所有entity class:</span></span><br><span class="line">        sessionFactoryBean.setPackagesToScan(<span class="string">&quot;com.itranswarp.learnjava.entity&quot;</span>);</span><br><span class="line">        sessionFactoryBean.setHibernateProperties(props);</span><br><span class="line">        <span class="keyword">return</span> sessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意我们在<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/ioc/customize/index.html">定制Bean</a>中讲到过<code>FactoryBean</code>，<code>LocalSessionFactoryBean</code>是一个<code>FactoryBean</code>，它会再自动创建一个<code>SessionFactory</code>，在Hibernate中，<code>Session</code>是封装了一个JDBC <code>Connection</code>的实例，而<code>SessionFactory</code>是封装了JDBC <code>DataSource</code>的实例，即<code>SessionFactory</code>持有连接池，每次需要操作数据库的时候，<code>SessionFactory</code>创建一个新的<code>Session</code>，相当于从连接池获取到一个新的<code>Connection</code>。<code>SessionFactory</code>就是Hibernate提供的最核心的一个对象，但<code>LocalSessionFactoryBean</code>是Spring提供的为了让我们方便创建<code>SessionFactory</code>的类。</p>
<p>注意到上面创建<code>LocalSessionFactoryBean</code>的代码，首先用<code>Properties</code>持有Hibernate初始化<code>SessionFactory</code>时用到的所有设置，常用的设置请参考<a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#configurations">Hibernate文档</a>，这里我们只定义了3个设置：</p>
<ul>
<li><code>hibernate.hbm2ddl.auto=update</code>：表示自动创建数据库的表结构，注意不要在生产环境中启用；</li>
<li><code>hibernate.dialect=org.hibernate.dialect.HSQLDialect</code>：指示Hibernate使用的数据库是HSQLDB。Hibernate使用一种HQL的查询语句，它和SQL类似，但真正在“翻译”成SQL时，会根据设定的数据库“方言”来生成针对数据库优化的SQL；</li>
<li><code>hibernate.show_sql=true</code>：让Hibernate打印执行的SQL，这对于调试非常有用，我们可以方便地看到Hibernate生成的SQL语句是否符合我们的预期。</li>
</ul>
<p>除了设置<code>DataSource</code>和<code>Properties</code>之外，注意到<code>setPackagesToScan()</code>我们传入了一个<code>package</code>名称，它指示Hibernate扫描这个包下面的所有Java类，自动找出能映射为数据库表记录的JavaBean。后面我们会仔细讨论如何编写符合Hibernate要求的JavaBean。</p>
<p>紧接着，我们还需要创建<code>HibernateTransactionManager</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    PlatformTransactionManager <span class="title function_">createTxManager</span><span class="params">(<span class="meta">@Autowired</span> SessionFactory sessionFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HibernateTransactionManager</span>(sessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HibernateTransactionManager</code>是配合Hibernate使用声明式事务所必须的。到此为止，所有的配置都定义完毕，我们来看看如何将数据库表结构映射为Java对象。</p>
<p>考察如下的数据库表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> <span class="keyword">user</span></span><br><span class="line">    id <span class="type">BIGINT</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    password <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    createdAt <span class="type">BIGINT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `email` (`email`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>其中，<code>id</code>是自增主键，<code>email</code>、<code>password</code>、<code>name</code>是<code>VARCHAR</code>类型，<code>email</code>带唯一索引以确保唯一性，<code>createdAt</code>存储整型类型的时间戳。用JavaBean表示如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Long createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种映射关系十分易懂，但我们需要添加一些注解来告诉Hibernate如何把<code>User</code>类映射到表记录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, unique = true, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getCreatedAt</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个JavaBean被用于映射，我们就标记一个<code>@Entity</code>。默认情况下，映射的表名是<code>user</code>，如果实际的表名不同，例如实际表名是<code>users</code>，可以追加一个<code>@Table(name=&quot;users&quot;)</code>表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name=&quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个属性到数据库列的映射用<code>@Column()</code>标识，<code>nullable</code>指示列是否允许为<code>NULL</code>，<code>updatable</code>指示该列是否允许被用在<code>UPDATE</code>语句，<code>length</code>指示<code>String</code>类型的列的长度（如果没有指定，默认是<code>255</code>）。</p>
<p>对于主键，还需要用<code>@Id</code>标识，自增主键再追加一个<code>@GeneratedValue</code>，以便Hibernate能读取到自增主键的值。</p>
<p>细心的童鞋可能还注意到，主键<code>id</code>定义的类型不是<code>long</code>，而是<code>Long</code>。这是因为Hibernate如果检测到主键为<code>null</code>，就不会在<code>INSERT</code>语句中指定主键的值，而是返回由数据库生成的自增值，否则，Hibernate认为我们的程序指定了主键的值，会在<code>INSERT</code>语句中直接列出。<code>long</code>型字段总是具有默认值<code>0</code>，因此，每次插入的主键值总是0，导致除第一次外后续插入都将失败。</p>
<p><code>createdAt</code>虽然是整型，但我们并没有使用<code>long</code>，而是<code>Long</code>，这是因为使用基本类型会导致findByExample查询会添加意外的条件，这里只需牢记，作为映射使用的JavaBean，所有属性都使用包装类型而不是基本类型。</p>
<p>注意</p>
<p>使用Hibernate时，不要使用基本类型的属性，总是使用包装类型，如Long或Integer。</p>
<p>类似的，我们再定义一个<code>Book</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getCreatedAt</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果仔细观察<code>User</code>和<code>Book</code>，会发现它们定义的<code>id</code>、<code>createdAt</code>属性是一样的，这在数据库表结构的设计中很常见：对于每个表，通常我们会统一使用一种主键生成机制，并添加<code>createdAt</code>表示创建时间，<code>updatedAt</code>表示修改时间等通用字段。</p>
<p>不必在<code>User</code>和<code>Book</code>中重复定义这些通用字段，我们可以把它们提到一个抽象类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Long createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getCreatedAt</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">public</span> ZonedDateTime <span class="title function_">getCreatedDateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Instant.ofEpochMilli(<span class="built_in">this</span>.createdAt).atZone(ZoneId.systemDefault());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PrePersist</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInsert</span><span class="params">()</span> &#123;</span><br><span class="line">        setCreatedAt(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>AbstractEntity</code>来说，我们要标注一个<code>@MappedSuperclass</code>表示它用于继承。此外，注意到我们定义了一个<code>@Transient</code>方法，它返回一个“虚拟”的属性。因为<code>getCreatedDateTime()</code>是计算得出的属性，而不是从数据库表读出的值，因此必须要标注<code>@Transient</code>，否则Hibernate会尝试从数据库读取名为<code>createdDateTime</code>这个不存在的字段从而出错。</p>
<p>再注意到<code>@PrePersist</code>标识的方法，它表示在我们将一个JavaBean持久化到数据库之前（即执行INSERT语句），Hibernate会先执行该方法，这样我们就可以自动设置好<code>createdAt</code>属性。</p>
<p>有了<code>AbstractEntity</code>，我们就可以大幅简化<code>User</code>和<code>Book</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">AbstractEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, unique = true, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到使用的所有注解均来自<code>jakarta.persistence</code>，它是JPA规范的一部分。这里我们只介绍使用注解的方式配置Hibernate映射关系，不再介绍传统的比较繁琐的XML配置。通过Spring集成Hibernate时，也不再需要<code>hibernate.cfg.xml</code>配置文件，用一句话总结：</p>
<p>提示</p>
<p>使用Spring集成Hibernate，配合JPA注解，无需任何额外的XML配置。</p>
<p>类似<code>User</code>、<code>Book</code>这样的用于ORM的Java Bean，我们通常称之为Entity Bean。</p>
<p>最后，我们来看看如果对<code>user</code>表进行增删改查。因为使用了Hibernate，因此，我们要做的，实际上是对<code>User</code>这个JavaBean进行“增删改查”。我们编写一个<code>UserService</code>，注入<code>SessionFactory</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    SessionFactory sessionFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Insert操作">Insert操作</h3>
<p>要持久化一个<code>User</code>实例，我们只需调用<code>persist()</code>方法。以<code>register()</code>方法为例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个User对象:</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="comment">// 设置好各个属性:</span></span><br><span class="line">    user.setEmail(email);</span><br><span class="line">    user.setPassword(password);</span><br><span class="line">    user.setName(name);</span><br><span class="line">    <span class="comment">// 不要设置id，因为使用了自增主键</span></span><br><span class="line">    <span class="comment">// 保存到数据库:</span></span><br><span class="line">    sessionFactory.getCurrentSession().persist(user);</span><br><span class="line">    <span class="comment">// 现在已经自动获得了id:</span></span><br><span class="line">    System.out.println(user.getId());</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Delete操作">Delete操作</h3>
<p>删除一个<code>User</code>相当于从表中删除对应的记录。注意Hibernate总是用<code>id</code>来删除记录，因此，要正确设置<code>User</code>的<code>id</code>属性才能正常删除记录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> sessionFactory.getCurrentSession().byId(User.class).load(id);</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">        sessionFactory.getCurrentSession().remove(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过主键删除记录时，一个常见的用法是先根据主键加载该记录，再删除。注意到当记录不存在时，<code>load()</code>返回<code>null</code>。</p>
<h3 id="Update操作">Update操作</h3>
<p>更新记录相当于先更新<code>User</code>的指定属性，然后调用<code>merge()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(Long id, String name)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> sessionFactory.getCurrentSession().byId(User.class).load(id);</span><br><span class="line">    user.setName(name);</span><br><span class="line">    sessionFactory.getCurrentSession().merge(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面我们在定义<code>User</code>时，对有的属性标注了<code>@Column(updatable=false)</code>。Hibernate在更新记录时，它只会把<code>@Column(updatable=true)</code>的属性加入到<code>UPDATE</code>语句中，这样可以提供一层额外的安全性，即如果不小心修改了<code>User</code>的<code>email</code>、<code>createdAt</code>等属性，执行<code>update()</code>时并不会更新对应的数据库列。但也必须牢记：这个功能是Hibernate提供的，如果绕过Hibernate直接通过JDBC执行<code>UPDATE</code>语句仍然可以更新数据库的任意列的值。</p>
<p>最后，我们编写的大部分方法都是各种各样的查询。根据<code>id</code>查询我们可以直接调用<code>load()</code>，如果要使用条件查询，例如，假设我们想执行以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> email <span class="operator">=</span> ? <span class="keyword">AND</span> password <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure>
<p>我们来看看可以使用什么查询。</p>
<h3 id="使用HQL查询">使用HQL查询</h3>
<p>一种常用的查询是直接编写Hibernate内置的HQL查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; list = sessionFactory.getCurrentSession()</span><br><span class="line">        .createQuery(<span class="string">&quot;from User u where u.email = ?1 and u.password = ?2&quot;</span>, User.class)</span><br><span class="line">        .setParameter(<span class="number">1</span>, email).setParameter(<span class="number">2</span>, password)</span><br><span class="line">        .list();</span><br></pre></td></tr></table></figure>
<p>和SQL相比，HQL使用类名和属性名，由Hibernate自动转换为实际的表名和列名。详细的HQL语法可以参考<a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/6.1/userguide/html_single/Hibernate_User_Guide.html#query-language">Hibernate文档</a>。</p>
<p>除了可以直接传入HQL字符串外，Hibernate还可以使用一种<code>NamedQuery</code>，它给查询起个名字，然后保存在注解中。使用<code>NamedQuery</code>时，我们要先在<code>User</code>类标注：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NamedQueries(</span></span><br><span class="line"><span class="meta">    @NamedQuery(</span></span><br><span class="line"><span class="meta">        // 查询名称:</span></span><br><span class="line"><span class="meta">        name = &quot;login&quot;,</span></span><br><span class="line"><span class="meta">        // 查询语句:</span></span><br><span class="line"><span class="meta">        query = &quot;SELECT u FROM User u WHERE u.email = :e AND u.password = :pwd&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">AbstractEntity</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到引入的<code>NamedQuery</code>是<code>jakarta.persistence.NamedQuery</code>，它和直接传入HQL有点不同的是，占位符使用<code>:e</code>和<code>:pwd</code>。</p>
<p>使用<code>NamedQuery</code>只需要引入查询名和参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">    List&lt;User&gt; list = sessionFactory.getCurrentSession()</span><br><span class="line">        .createNamedQuery(<span class="string">&quot;login&quot;</span>, User.class) <span class="comment">// 创建NamedQuery</span></span><br><span class="line">        .setParameter(<span class="string">&quot;e&quot;</span>, email) <span class="comment">// 绑定e参数</span></span><br><span class="line">        .setParameter(<span class="string">&quot;pwd&quot;</span>, password) <span class="comment">// 绑定pwd参数</span></span><br><span class="line">        .list();</span><br><span class="line">    <span class="keyword">return</span> list.isEmpty() ? <span class="literal">null</span> : list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接写HQL和使用<code>NamedQuery</code>各有优劣。前者可以在代码中直观地看到查询语句，后者可以在<code>User</code>类统一管理所有相关查询。</p>
<h3 id="练习-4">练习</h3>
<p>集成Hibernate操作数据库。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/database/hibernate/spring-data-hibernate.zip">下载练习</a></p>
<h3 id="小结-4">小结</h3>
<p>在Spring中集成Hibernate需要配置的Bean如下：</p>
<ul>
<li>DataSource；</li>
<li>LocalSessionFactory；</li>
<li>HibernateTransactionManager。</li>
</ul>
<p>推荐使用Annotation配置所有的Entity Bean。</p>
<p>上一节我们讲了在Spring中集成Hibernate。Hibernate是第一个被广泛使用的ORM框架，但是很多小伙伴还听说过JPA：Java Persistence API，这又是啥？</p>
<p>在讨论JPA之前，我们要注意到JavaEE早在1999年就发布了，并且有Servlet、JMS等诸多标准。和其他平台不同，Java世界早期非常热衷于标准先行，各家跟进：大家先坐下来把接口定了，然后，各自回家干活去实现接口，这样，用户就可以在不同的厂家提供的产品进行选择，还可以随意切换，因为用户编写代码的时候只需要引用接口，并不需要引用具体的底层实现（想想JDBC）。</p>
<p>JPA就是JavaEE的一个ORM标准，它的实现其实和Hibernate没啥本质区别，但是用户如果使用JPA，那么引用的就是<code>jakarta.persistence</code>这个“标准”包，而不是<code>org.hibernate</code>这样的第三方包。因为JPA只是接口，所以，还需要选择一个实现产品，跟JDBC接口和MySQL驱动一个道理。</p>
<p>我们使用JPA时也完全可以选择Hibernate作为底层实现，但也可以选择其它的JPA提供方，比如<a target="_blank" rel="noopener" href="https://www.eclipse.org/eclipselink/">EclipseLink</a>。Spring内置了JPA的集成，并支持选择Hibernate或EclipseLink作为实现。这里我们仍然以主流的Hibernate作为JPA实现为例子，演示JPA的基本用法。</p>
<p>和使用Hibernate一样，我们只需要引入如下依赖：</p>
<ul>
<li>org.springframework:spring-context:6.0.0</li>
<li>org.springframework:spring-orm:6.0.0</li>
<li>jakarta.annotation:jakarta.annotation-api:2.1.1</li>
<li>jakarta.persistence:jakarta.persistence-api:3.1.0</li>
<li>org.hibernate:hibernate-core:6.1.4.Final</li>
<li>com.zaxxer:HikariCP:5.0.1</li>
<li>org.hsqldb:hsqldb:2.7.1</li>
</ul>
<p>实际上我们这里引入的依赖和上一节集成Hibernate引入的依赖完全一样，因为Hibernate既提供了它自己的接口，也提供了JPA接口，我们用JPA接口就相当于通过JPA操作Hibernate。</p>
<p>然后，在<code>AppConfig</code>中启用声明式事务管理，创建<code>DataSource</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Hibernate时，我们需要创建一个<code>LocalSessionFactoryBean</code>，并让它再自动创建一个<code>SessionFactory</code>。使用JPA也是类似的，我们也创建一个<code>LocalContainerEntityManagerFactoryBean</code>，并让它再自动创建一个<code>EntityManagerFactory</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title function_">createEntityManagerFactory</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">emFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalContainerEntityManagerFactoryBean</span>();</span><br><span class="line">    <span class="comment">// 注入DataSource:</span></span><br><span class="line">    emFactory.setDataSource(dataSource);</span><br><span class="line">    <span class="comment">// 扫描指定的package获取所有entity class:</span></span><br><span class="line">    emFactory.setPackagesToScan(AbstractEntity.class.getPackageName());</span><br><span class="line">    <span class="comment">// 使用Hibernate作为JPA实现:</span></span><br><span class="line">    emFactory.setJpaVendorAdapter(<span class="keyword">new</span> <span class="title class_">HibernateJpaVendorAdapter</span>());</span><br><span class="line">    <span class="comment">// 其他配置项:</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    props.setProperty(<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>, <span class="string">&quot;update&quot;</span>); <span class="comment">// 生产环境不要使用</span></span><br><span class="line">    props.setProperty(<span class="string">&quot;hibernate.dialect&quot;</span>, <span class="string">&quot;org.hibernate.dialect.HSQLDialect&quot;</span>);</span><br><span class="line">    props.setProperty(<span class="string">&quot;hibernate.show_sql&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    emFactory.setJpaProperties(props);</span><br><span class="line">    <span class="keyword">return</span> emFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察上述代码，除了需要注入<code>DataSource</code>和设定自动扫描的<code>package</code>外，还需要指定JPA的提供商，这里使用Spring提供的一个<code>HibernateJpaVendorAdapter</code>，最后，针对Hibernate自己需要的配置，以<code>Properties</code>的形式注入。</p>
<p>最后，我们还需要实例化一个<code>JpaTransactionManager</code>，以实现声明式事务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">PlatformTransactionManager <span class="title function_">createTxManager</span><span class="params">(<span class="meta">@Autowired</span> EntityManagerFactory entityManagerFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JpaTransactionManager</span>(entityManagerFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就完成了JPA的全部初始化工作。有些童鞋可能从网上搜索得知JPA需要<code>persistence.xml</code>配置文件，以及复杂的<code>orm.xml</code>文件。这里我们负责地告诉大家，使用Spring+Hibernate作为JPA实现，无需任何配置文件。</p>
<p>所有Entity Bean的配置和上一节完全相同，全部采用Annotation标注。我们现在只需关心具体的业务类如何通过JPA接口操作数据库。</p>
<p>还是以<code>UserService</code>为例，除了标注<code>@Component</code>和<code>@Transactional</code>外，我们需要注入一个<code>EntityManager</code>，但是不要使用<code>Autowired</code>，而是<code>@PersistenceContext</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@PersistenceContext</span></span><br><span class="line">    EntityManager em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们回顾一下JDBC、Hibernate和JPA提供的接口，实际上，它们的关系如下：</p>
<table>
<thead>
<tr>
<th>JDBC</th>
<th>Hibernate</th>
<th>JPA</th>
</tr>
</thead>
<tbody>
<tr>
<td>DataSource</td>
<td>SessionFactory</td>
<td>EntityManagerFactory</td>
</tr>
<tr>
<td>Connection</td>
<td>Session</td>
<td>EntityManager</td>
</tr>
</tbody>
</table>
<p><code>SessionFactory</code>和<code>EntityManagerFactory</code>相当于<code>DataSource</code>，<code>Session</code>和<code>EntityManager</code>相当于<code>Connection</code>。每次需要访问数据库的时候，需要获取新的<code>Session</code>和<code>EntityManager</code>，用完后再关闭。</p>
<p>但是，注意到<code>UserService</code>注入的不是<code>EntityManagerFactory</code>，而是<code>EntityManager</code>，并且标注了<code>@PersistenceContext</code>。难道使用JPA可以允许多线程操作同一个<code>EntityManager</code>？</p>
<p>实际上这里注入的并不是真正的<code>EntityManager</code>，而是一个<code>EntityManager</code>的代理类，相当于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EntityManagerProxy</span> <span class="keyword">implements</span> <span class="title class_">EntityManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> EntityManagerFactory emf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring遇到标注了<code>@PersistenceContext</code>的<code>EntityManager</code>会自动注入代理，该代理会在必要的时候自动打开<code>EntityManager</code>。换句话说，多线程引用的<code>EntityManager</code>虽然是同一个代理类，但该代理类内部针对不同线程会创建不同的<code>EntityManager</code>实例。</p>
<p>简单总结一下，标注了<code>@PersistenceContext</code>的<code>EntityManager</code>可以被多线程安全地共享。</p>
<p>因此，在<code>UserService</code>的每个业务方法里，直接使用<code>EntityManager</code>就很方便。以主键查询为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="built_in">this</span>.em.find(User.class, id);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;User not found by id: &quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与HQL查询类似，JPA使用JPQL查询，它的语法和HQL基本差不多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">fetchUserByEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">    <span class="comment">// JPQL查询:</span></span><br><span class="line">    TypedQuery&lt;User&gt; query = em.createQuery(<span class="string">&quot;SELECT u FROM User u WHERE u.email = :e&quot;</span>, User.class);</span><br><span class="line">    query.setParameter(<span class="string">&quot;e&quot;</span>, email);</span><br><span class="line">    List&lt;User&gt; list = query.getResultList();</span><br><span class="line">    <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，JPA也支持<code>NamedQuery</code>，即先给查询起个名字，再按名字创建查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">    TypedQuery&lt;User&gt; query = em.createNamedQuery(<span class="string">&quot;login&quot;</span>, User.class);</span><br><span class="line">    query.setParameter(<span class="string">&quot;e&quot;</span>, email);</span><br><span class="line">    query.setParameter(<span class="string">&quot;pwd&quot;</span>, password);</span><br><span class="line">    List&lt;User&gt; list = query.getResultList();</span><br><span class="line">    <span class="keyword">return</span> list.isEmpty() ? <span class="literal">null</span> : list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NamedQuery</code>通过注解标注在<code>User</code>类上，它的定义和上一节的<code>User</code>类一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NamedQueries(</span></span><br><span class="line"><span class="meta">    @NamedQuery(</span></span><br><span class="line"><span class="meta">        name = &quot;login&quot;,</span></span><br><span class="line"><span class="meta">        query = &quot;SELECT u FROM User u WHERE u.email=:e AND u.password=:pwd&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对数据库进行增删改的操作，可以分别使用<code>persist()</code>、<code>remove()</code>和<code>merge()</code>方法，参数均为Entity Bean本身，使用非常简单，这里不再多述。</p>
<h3 id="练习-5">练习</h3>
<p>使用JPA操作数据库。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/database/jpa/spring-data-jpa.zip">下载练习</a></p>
<h3 id="小结-5">小结</h3>
<p>在Spring中集成JPA要选择一个实现，可以选择Hibernate或EclipseLink；</p>
<p>使用JPA与Hibernate类似，但注入的核心资源是带有<code>@PersistenceContext</code>注解的<code>EntityManager</code>代理类。</p>
<p>使用Hibernate或JPA操作数据库时，这类ORM干的主要工作就是把ResultSet的每一行变成Java Bean，或者把Java Bean自动转换到INSERT或UPDATE语句的参数中，从而实现ORM。</p>
<p>而ORM框架之所以知道如何把行数据映射到Java Bean，是因为我们在Java Bean的属性上给了足够的注解作为元数据，ORM框架获取Java Bean的注解后，就知道如何进行双向映射。</p>
<p>那么，ORM框架是如何跟踪Java Bean的修改，以便在<code>update()</code>操作中更新必要的属性？</p>
<p>答案是使用<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/structural/proxy/index.html">Proxy模式</a>，从ORM框架读取的User实例实际上并不是User类，而是代理类，代理类继承自User类，但针对每个setter方法做了覆写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> <span class="keyword">extends</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> _isNameChanged;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setName(name);</span><br><span class="line">        _isNameChanged = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，代理类可以跟踪到每个属性的变化。</p>
<p>针对一对多或多对一关系时，代理类可以直接通过getter方法查询数据库：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> <span class="keyword">extends</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    Session _session;</span><br><span class="line">    <span class="type">boolean</span> _isNameChanged;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setName(name);</span><br><span class="line">        _isNameChanged = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取User对象关联的Address对象:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Query</span> <span class="variable">q</span> <span class="operator">=</span> _session.createQuery(<span class="string">&quot;from Address where userId = :userId&quot;</span>);</span><br><span class="line">        q.setParameter(<span class="string">&quot;userId&quot;</span>, <span class="built_in">this</span>.getId());</span><br><span class="line">        List&lt;Address&gt; list = query.list();</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty() ? <span class="literal">null</span> : list(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了实现这样的查询，UserProxy必须保存Hibernate的当前Session。但是，当事务提交后，Session自动关闭，此时再获取<code>getAddress()</code>将无法访问数据库，或者获取的不是事务一致的数据。因此，ORM框架总是引入了Attached/Detached状态，表示当前此Java Bean到底是在Session的范围内，还是脱离了Session变成了一个“游离”对象。很多初学者无法正确理解状态变化和事务边界，就会造成大量的<code>PersistentObjectException</code>异常。这种隐式状态使得普通Java Bean的生命周期变得复杂。</p>
<p>此外，Hibernate和JPA为了实现兼容多种数据库，它使用HQL或JPQL查询，经过一道转换，变成特定数据库的SQL，理论上这样可以做到无缝切换数据库，但这一层自动转换除了少许的性能开销外，给SQL级别的优化带来了麻烦。</p>
<p>最后，ORM框架通常提供了缓存，并且还分为一级缓存和二级缓存。一级缓存是指在一个Session范围内的缓存，常见的情景是根据主键查询时，两次查询可以返回同一实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> session.load(User.class, <span class="number">123</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> session.load(User.class, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<p>二级缓存是指跨Session的缓存，一般默认关闭，需要手动配置。二级缓存极大的增加了数据的不一致性，原因在于SQL非常灵活，常常会导致意外的更新。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程1读取:</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> session1.load(User.class, <span class="number">123</span>);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 一段时间后，线程2读取:</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> session2.load(User.class, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<p>当二级缓存生效的时候，两个线程读取的User实例是一样的，但是，数据库对应的行记录完全可能被修改，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给老用户增加100积分:</span></span><br><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> bonus <span class="operator">=</span> bonus <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> createdAt <span class="operator">&lt;=</span> ?</span><br></pre></td></tr></table></figure>
<p>ORM无法判断<code>id=123</code>的用户是否受该<code>UPDATE</code>语句影响。考虑到数据库通常会支持多个应用程序，此UPDATE语句可能由其他进程执行，ORM框架就更不知道了。</p>
<p>我们把这种ORM框架称之为全自动ORM框架。</p>
<p>对比Spring提供的JdbcTemplate，它和ORM框架相比，主要有几点差别：</p>
<ol>
<li>查询后需要手动提供Mapper实例以便把ResultSet的每一行变为Java对象；</li>
<li>增删改操作所需的参数列表，需要手动传入，即把User实例变为[user.id, <a target="_blank" rel="noopener" href="http://user.name">user.name</a>, user.email]这样的列表，比较麻烦。</li>
</ol>
<p>但是JdbcTemplate的优势在于它的确定性：即每次读取操作一定是数据库操作而不是缓存，所执行的SQL是完全确定的，缺点就是代码比较繁琐，构造<code>INSERT INTO users VALUES (?,?,?)</code>更是复杂。</p>
<p>所以，介于全自动ORM如Hibernate和手写全部如JdbcTemplate之间，还有一种半自动的ORM，它只负责把ResultSet自动映射到Java Bean，或者自动填充Java Bean参数，但仍需自己写出SQL。<a target="_blank" rel="noopener" href="https://mybatis.org/">MyBatis</a>就是这样一种半自动化ORM框架。</p>
<p>我们来看看如何在Spring中集成MyBatis。</p>
<p>首先，我们要引入MyBatis本身，其次，由于Spring并没有像Hibernate那样内置对MyBatis的集成，所以，我们需要再引入MyBatis官方自己开发的一个与Spring集成的库：</p>
<ul>
<li>org.mybatis:mybatis:3.5.11</li>
<li>org.mybatis:mybatis-spring:3.0.0</li>
</ul>
<p>和前面一样，先创建<code>DataSource</code>是必不可少的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再回顾一下Hibernate和JPA的<code>SessionFactory</code>与<code>EntityManagerFactory</code>，MyBatis与之对应的是<code>SqlSessionFactory</code>和<code>SqlSession</code>：</p>
<table>
<thead>
<tr>
<th>JDBC</th>
<th>Hibernate</th>
<th>JPA</th>
<th>MyBatis</th>
</tr>
</thead>
<tbody>
<tr>
<td>DataSource</td>
<td>SessionFactory</td>
<td>EntityManagerFactory</td>
<td>SqlSessionFactory</td>
</tr>
<tr>
<td>Connection</td>
<td>Session</td>
<td>EntityManager</td>
<td>SqlSession</td>
</tr>
</tbody>
</table>
<p>可见，ORM的设计套路都是类似的。使用MyBatis的核心就是创建<code>SqlSessionFactory</code>，这里我们需要创建的是<code>SqlSessionFactoryBean</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">SqlSessionFactoryBean <span class="title function_">createSqlSessionFactoryBean</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">    sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为MyBatis可以直接使用Spring管理的声明式事务，因此，创建事务管理器和使用JDBC是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">PlatformTransactionManager <span class="title function_">createTxManager</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和Hibernate不同的是，MyBatis使用Mapper来实现映射，而且Mapper必须是接口。我们以<code>User</code>类为例，在<code>User</code>类和<code>users</code>表之间映射的<code>UserMapper</code>编写如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">	<span class="meta">@Select(&quot;SELECT * FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">	User <span class="title function_">getById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：这里的Mapper不是<code>JdbcTemplate</code>的<code>RowMapper</code>的概念，它是定义访问<code>users</code>表的接口方法。比如我们定义了一个<code>User getById(long)</code>的主键查询方法，不仅要定义接口方法本身，还要明确写出查询的SQL，这里用注解<code>@Select</code>标记。SQL语句的任何参数，都与方法参数按名称对应。例如，方法参数id的名字通过注解<code>@Param()</code>标记为<code>id</code>，则SQL语句里将来替换的占位符就是<code>#&#123;id&#125;</code>。</p>
<p>如果有多个参数，那么每个参数命名后直接在SQL中写出对应的占位符即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users LIMIT #&#123;offset&#125;, #&#123;maxResults&#125;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getAll</span><span class="params">(<span class="meta">@Param(&quot;offset&quot;)</span> <span class="type">int</span> offset, <span class="meta">@Param(&quot;maxResults&quot;)</span> <span class="type">int</span> maxResults)</span>;</span><br></pre></td></tr></table></figure>
<p>注意：MyBatis执行查询后，将根据方法的返回类型自动把ResultSet的每一行转换为User实例，转换规则当然是按列名和属性名对应。如果列名和属性名不同，最简单的方式是编写SELECT语句的别名：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 列名是created_time，属性名是createdAt:</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, email, created_time <span class="keyword">AS</span> createdAt <span class="keyword">FROM</span> users</span><br></pre></td></tr></table></figure>
<p>执行INSERT语句就稍微麻烦点，因为我们希望传入User实例，因此，定义的方法接口与<code>@Insert</code>注解如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert(&quot;INSERT INTO users (email, password, name, createdAt) VALUES (#&#123;user.email&#125;, #&#123;user.password&#125;, #&#123;user.name&#125;, #&#123;user.createdAt&#125;)&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="meta">@Param(&quot;user&quot;)</span> User user)</span>;</span><br></pre></td></tr></table></figure>
<p>上述方法传入的参数名称是<code>user</code>，参数类型是User类，在SQL中引用的时候，以<code>#&#123;obj.property&#125;</code>的方式写占位符。和Hibernate这样的全自动化ORM相比，MyBatis必须写出完整的INSERT语句。</p>
<p>如果<code>users</code>表的<code>id</code>是自增主键，那么，我们在SQL中不传入<code>id</code>，但希望获取插入后的主键，需要再加一个<code>@Options</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;, keyColumn = &quot;id&quot;)</span></span><br><span class="line"><span class="meta">@Insert(&quot;INSERT INTO users (email, password, name, createdAt) VALUES (#&#123;user.email&#125;, #&#123;user.password&#125;, #&#123;user.name&#125;, #&#123;user.createdAt&#125;)&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="meta">@Param(&quot;user&quot;)</span> User user)</span>;</span><br></pre></td></tr></table></figure>
<p><code>keyProperty</code>和<code>keyColumn</code>分别指出JavaBean的属性和数据库的主键列名。</p>
<p>执行<code>UPDATE</code>和<code>DELETE</code>语句相对比较简单，我们定义方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update(&quot;UPDATE users SET name = #&#123;user.name&#125;, createdAt = #&#123;user.createdAt&#125; WHERE id = #&#123;user.id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(&quot;user&quot;)</span> User user)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Delete(&quot;DELETE FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">long</span> id)</span>;</span><br></pre></td></tr></table></figure>
<p>有了<code>UserMapper</code>接口，还需要对应的实现类才能真正执行这些数据库操作的方法。虽然可以自己写实现类，但我们除了编写<code>UserMapper</code>接口外，还有<code>BookMapper</code>、<code>BonusMapper</code>……一个一个写太麻烦，因此，MyBatis提供了一个<code>MapperFactoryBean</code>来自动创建所有Mapper的实现类。可以用一个简单的注解来启用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.itranswarp.learnjava.mapper&quot;)</span></span><br><span class="line">...其他注解...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了<code>@MapperScan</code>，就可以让MyBatis自动扫描指定包的所有Mapper并创建实现类。在真正的业务逻辑中，我们可以直接注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 注入UserMapper:</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用Mapper方法:</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.getById(id);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;User not found by id.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，业务逻辑主要就是通过<code>XxxMapper</code>定义的数据库方法来访问数据库。</p>
<h3 id="XML配置">XML配置</h3>
<p>上述在Spring中集成MyBatis的方式，我们只需要用到注解，并没有任何XML配置文件。MyBatis也允许使用XML配置映射关系和SQL语句，例如，更新<code>User</code>时根据属性值构造动态SQL：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span>&gt;</span></span><br><span class="line">  UPDATE users SET</span><br><span class="line">  <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;user.name != null&quot;</span>&gt;</span> name = #&#123;user.name&#125; <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;user.hobby != null&quot;</span>&gt;</span> hobby = #&#123;user.hobby&#125; <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;user.summary != null&quot;</span>&gt;</span> summary = #&#123;user.summary&#125; <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  WHERE id = #&#123;user.id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写XML配置的优点是可以组装出动态SQL，并且把所有SQL操作集中在一起。缺点是配置起来太繁琐，调用方法时如果想查看SQL还需要定位到XML配置中。这里我们不介绍XML的配置方式，需要了解的童鞋请自行阅读<a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html">官方文档</a>。</p>
<p>使用MyBatis最大的问题是所有SQL都需要全部手写，优点是执行的SQL就是我们自己写的SQL，对SQL进行优化非常简单，也可以编写任意复杂的SQL，或者使用数据库的特定语法，但切换数据库可能就不太容易。好消息是大部分项目并没有切换数据库的需求，完全可以针对某个数据库编写尽可能优化的SQL。</p>
<h3 id="练习-6">练习</h3>
<p>集成MyBatis操作数据库。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/database/mybatis/spring-data-mybatis.zip">下载练习</a></p>
<h3 id="小结-6">小结</h3>
<p>MyBatis是一个半自动化的ORM框架，需要手写SQL语句，没有自动加载一对多或多对一关系的功能。</p>
<p>我们从前几节可以看到，所谓ORM，也是建立在JDBC的基础上，通过ResultSet到JavaBean的映射，实现各种查询。有自动跟踪Entity修改的全自动化ORM如Hibernate和JPA，需要为每个Entity创建代理，也有完全自己映射，连INSERT和UPDATE语句都需要手动编写的MyBatis，但没有任何透明的Proxy。</p>
<p>而查询是涉及到数据库使用最广泛的操作，需要最大的灵活性。各种ORM解决方案各不相同，Hibernate和JPA自己实现了HQL和JPQL查询语法，用以生成最终的SQL，而MyBatis则完全手写，每增加一个查询都需要先编写SQL并增加接口方法。</p>
<p>还有一种Hibernate和JPA支持的Criteria查询，用Hibernate写出来类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DetachedCriteria</span> <span class="variable">criteria</span> <span class="operator">=</span> DetachedCriteria.forClass(User.class);</span><br><span class="line">criteria.add(Restrictions.eq(<span class="string">&quot;email&quot;</span>, email))</span><br><span class="line">        .add(Restrictions.eq(<span class="string">&quot;password&quot;</span>, password));</span><br><span class="line">List&lt;User&gt; list = (List&lt;User&gt;) hibernateTemplate.findByCriteria(criteria);</span><br></pre></td></tr></table></figure>
<p>上述Criteria查询写法复杂，但和JPA相比，还是小巫见大巫了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">cb</span> <span class="operator">=</span> em.getCriteriaBuilder();</span><br><span class="line">CriteriaQuery&lt;User&gt; q = cb.createQuery(User.class);</span><br><span class="line">Root&lt;User&gt; r = q.from(User.class);</span><br><span class="line">q.where(cb.equal(r.get(<span class="string">&quot;email&quot;</span>), cb.parameter(String.class, <span class="string">&quot;e&quot;</span>)));</span><br><span class="line">TypedQuery&lt;User&gt; query = em.createQuery(q);</span><br><span class="line">query.setParameter(<span class="string">&quot;e&quot;</span>, email);</span><br><span class="line">List&lt;User&gt; list = query.getResultList();</span><br></pre></td></tr></table></figure>
<p>此外，是否支持自动读取一对多和多对一关系也是全自动化ORM框架的一个重要功能。</p>
<p>如果我们自己来设计并实现一个ORM，应该吸取这些ORM的哪些特色，然后高效实现呢？</p>
<h3 id="设计ORM接口">设计ORM接口</h3>
<p>任何设计，都必须明确设计目标。这里我们准备实现的ORM并不想要全自动ORM那种自动读取一对多和多对一关系的功能，也不想给Entity加上复杂的状态，因此，对于Entity来说，它就是纯粹的JavaBean，没有任何Proxy。</p>
<p>此外，ORM要兼顾易用性和适用性。易用性是指能覆盖95%的应用场景，但总有一些复杂的SQL，很难用ORM去自动生成，因此，也要给出原生的JDBC接口，能支持5%的特殊需求。</p>
<p>最后，我们希望设计的接口要易于编写，并使用流式API便于阅读。为了配合编译器检查，还应该支持泛型，避免强制转型。</p>
<p>以User类为例，我们设计的查询接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按主键查询: SELECT * FROM users WHERE id = ?</span></span><br><span class="line"><span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> db.get(User.class, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件查询唯一记录: SELECT * FROM users WHERE email = ? AND password = ?</span></span><br><span class="line"><span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> db.from(User.class)</span><br><span class="line">           .where(<span class="string">&quot;email=? AND password=?&quot;</span>, <span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;bob123&quot;</span>)</span><br><span class="line">           .unique();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件查询多条记录: SELECT * FROM users WHERE id &lt; ? ORDER BY email LIMIT ?, ?</span></span><br><span class="line">List&lt;User&gt; us = db.from(User.class)</span><br><span class="line">                  .where(<span class="string">&quot;id &lt; ?&quot;</span>, <span class="number">1000</span>)</span><br><span class="line">                  .orderBy(<span class="string">&quot;email&quot;</span>)</span><br><span class="line">                  .limit(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">                  .list();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询特定列: SELECT id, name FROM users WHERE email = ?</span></span><br><span class="line"><span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> db.select(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>)</span><br><span class="line">           .from(User.class)</span><br><span class="line">           .where(<span class="string">&quot;email = ?&quot;</span>, <span class="string">&quot;bob@example.com&quot;</span>)</span><br><span class="line">           .unique();</span><br></pre></td></tr></table></figure>
<p>这样的流式API便于阅读，也非常容易推导出最终生成的SQL。</p>
<p>对于插入、更新和删除操作，就相对比较简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入User:</span></span><br><span class="line">db.insert(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按主键更新更新User:</span></span><br><span class="line">db.update(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按主键删除User:</span></span><br><span class="line">db.delete(User.class, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<p>对于Entity来说，通常一个表对应一个。手动列出所有Entity是非常麻烦的，一定要传入package自动扫描。</p>
<p>最后，ORM总是需要元数据才能知道如何映射。我们不想编写复杂的XML配置，也没必要自己去定义一套规则，直接使用JPA的注解就行。</p>
<h3 id="实现ORM">实现ORM</h3>
<p>我们并不需要从JDBC底层开始编写，并且，还要考虑到事务，最好能直接使用Spring的声明式事务。实际上，我们可以设计一个全局<code>DbTemplate</code>，它注入了Spring的<code>JdbcTemplate</code>，涉及到数据库操作时，全部通过<code>JdbcTemplate</code>完成，自然天生支持Spring的声明式事务，因为这个ORM只是在<code>JdbcTemplate</code>的基础上做了一层封装。</p>
<p>在<code>AppConfig</code>中，我们初始化所有Bean如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    JdbcTemplate <span class="title function_">createJdbcTemplate</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DbTemplate <span class="title function_">createDbTemplate</span><span class="params">(<span class="meta">@Autowired</span> JdbcTemplate jdbcTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DbTemplate</span>(jdbcTemplate, <span class="string">&quot;com.itranswarp.learnjava.entity&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    PlatformTransactionManager <span class="title function_">createTxManager</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是我们所需的所有配置。</p>
<p>编写业务逻辑，例如<code>UserService</code>，写出来像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DbTemplate db;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> db.get(User.class, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserByEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> db.from(User.class)</span><br><span class="line">                 .where(<span class="string">&quot;email = ?&quot;</span>, email)</span><br><span class="line">                 .unique();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUsers</span><span class="params">(<span class="type">int</span> pageIndex)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pageSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> db.from(User.class)</span><br><span class="line">                 .orderBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                 .limit((pageIndex - <span class="number">1</span>) * pageSize, pageSize)</span><br><span class="line">                 .list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setEmail(email);</span><br><span class="line">        user.setPassword(password);</span><br><span class="line">        user.setName(name);</span><br><span class="line">        user.setCreatedAt(System.currentTimeMillis());</span><br><span class="line">        db.insert(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码给出了ORM的接口，以及如何在业务逻辑中使用ORM。下一步，就是如何实现这个<code>DbTemplate</code>。这里我们只给出框架代码，有兴趣的童鞋可以自己实现核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DbTemplate</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存Entity Class到Mapper的映射:</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Mapper&lt;?&gt;&gt; classMapping;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">fetch</span><span class="params">(Class&lt;T&gt; clazz, Object id)</span> &#123;</span><br><span class="line">        Mapper&lt;T&gt; mapper = getMapper(clazz);</span><br><span class="line">        List&lt;T&gt; list = (List&lt;T&gt;) jdbcTemplate.query(mapper.selectSQL, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; id &#125;, mapper.rowMapper);</span><br><span class="line">        <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(Class&lt;T&gt; clazz, Object id)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T bean)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(T bean)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Class&lt;T&gt; clazz, Object id)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现链式API的核心代码是第一步从<code>DbTemplate</code>调用<code>select()</code>或<code>from()</code>时实例化一个<code>CriteriaQuery</code>实例，并在后续的链式调用中设置它的字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DbTemplate</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> Select <span class="title function_">select</span><span class="params">(String... selectFields)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Select</span>(<span class="keyword">new</span> <span class="title class_">Criteria</span>(<span class="built_in">this</span>), selectFields);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; From&lt;T&gt; <span class="title function_">from</span><span class="params">(Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        Mapper&lt;T&gt; mapper = getMapper(entityClass);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">From</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Criteria</span>&lt;&gt;(<span class="built_in">this</span>), mapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后以此定义<code>Select</code>、<code>From</code>、<code>Where</code>、<code>OrderBy</code>、<code>Limit</code>等。在<code>From</code>中可以设置Class类型、表名等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">From</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">CriteriaQuery</span>&lt;T&gt; &#123;</span><br><span class="line">    From(Criteria&lt;T&gt; criteria, Mapper&lt;T&gt; mapper) &#123;</span><br><span class="line">        <span class="built_in">super</span>(criteria);</span><br><span class="line">        <span class="comment">// from可以设置class、tableName:</span></span><br><span class="line">        <span class="built_in">this</span>.criteria.mapper = mapper;</span><br><span class="line">        <span class="built_in">this</span>.criteria.clazz = mapper.entityClass;</span><br><span class="line">        <span class="built_in">this</span>.criteria.table = mapper.tableName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Where&lt;T&gt; <span class="title function_">where</span><span class="params">(String clause, Object... args)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Where</span>&lt;&gt;(<span class="built_in">this</span>.criteria, clause, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Where</code>中可以设置条件参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Where</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">CriteriaQuery</span>&lt;T&gt; &#123;</span><br><span class="line">    Where(Criteria&lt;T&gt; criteria, String clause, Object... params) &#123;</span><br><span class="line">        <span class="built_in">super</span>(criteria);</span><br><span class="line">        <span class="built_in">this</span>.criteria.where = clause;</span><br><span class="line">        <span class="built_in">this</span>.criteria.whereParams = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// add:</span></span><br><span class="line">        <span class="keyword">for</span> (Object param : params) &#123;</span><br><span class="line">            <span class="built_in">this</span>.criteria.whereParams.add(param);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，链式调用的尽头是调用<code>list()</code>返回一组结果，调用<code>unique()</code>返回唯一结果，调用<code>first()</code>返回首个结果。</p>
<p>在IDE中，可以非常方便地实现链式调用：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/database/orm/db.gif" alt="db"></p>
<p>需要复杂查询的时候，总是可以使用<code>JdbcTemplate</code>执行任意复杂的SQL。</p>
<h3 id="练习-7">练习</h3>
<p>设计并实现一个微型ORM。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/database/orm/spring-data-orm.zip">下载练习</a></p>
<h3 id="小结-7">小结</h3>
<p>ORM框架就是自动映射数据库表结构到JavaBean的工具，设计并实现一个简单高效的ORM框架并不困难。</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">標籤</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/Java/" rel="tag">Java</a> <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/Spirng/" rel="tag">Spirng</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JAVA-Spring%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/"
                    data-tooltip="JAVA-Spring开发-开发Web应用"
                    aria-label="上一篇: JAVA-Spring开发-开发Web应用"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JAVA-Spring%E5%BC%80%E5%8F%91-AOP/"
                    data-tooltip="JAVA-Spring开发-AOP"
                    aria-label="下一篇: JAVA-Spring开发-AOP"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JAVA-Spring%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/"
                    data-tooltip="JAVA-Spring开发-开发Web应用"
                    aria-label="上一篇: JAVA-Spring开发-开发Web应用"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JAVA-Spring%E5%BC%80%E5%8F%91-AOP/"
                    data-tooltip="JAVA-Spring开发-AOP"
                    aria-label="下一篇: JAVA-Spring开发-AOP"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"
                        aria-label="分享到 Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"
                        aria-label="分享到 Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"
                        aria-label="global.share_on_linkedin"
                    >
                        <i class="fab fa-linkedin" aria-hidden="true"></i><span>global.share_on_linkedin</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"
                        aria-label="分享到 Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 198 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
