
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>JavaScript-浏览器 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg"},"articleBody":"JavaScript可以获取浏览器提供的很多对象，并进行操作。\nwindow\nwindow对象不但充当全局作用域，而且表示浏览器窗口。\nwindow对象有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。\n兼容性：IE&lt;=8不支持。\n12// 可以调整浏览器窗口大小试试:console.log(&#x27;window inner size: &#x27; + window.innerWidth + &#x27; x &#x27; + window.innerHeight);\n对应的，还有一个outerWidth和outerHeight属性，可以获取浏览器窗口的整个宽高。\nnavigator\nnavigator对象表示浏览器的信息，最常用的属性包括：\n\nnavigator.appName：浏览器名称；\nnavigator.appVersion：浏览器版本；\nnavigator.language：浏览器设置的语言；\nnavigator.platform：操作系统类型；\nnavigator.userAgent：浏览器设定的User-Agent字符串。\n\n12345console.log(&#x27;appName = &#x27; + navigator.appName);console.log(&#x27;appVersion = &#x27; + navigator.appVersion);console.log(&#x27;language = &#x27; + navigator.language);console.log(&#x27;platform = &#x27; + navigator.platform);console.log(&#x27;userAgent = &#x27; + navigator.userAgent);\n请注意，navigator的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。很多初学者为了针对不同浏览器编写不同的代码，喜欢用if判断浏览器版本，例如：\n123456let width;if (getIEVersion(navigator.userAgent) &lt; 9) &#123;    width = document.body.clientWidth;&#125; else &#123;    width = window.innerWidth;&#125;\n但这样既可能判断不准确，也很难维护代码。正确的方法是充分利用JavaScript对不存在属性返回undefined的特性，直接用短路运算符||计算：\n1let width = window.innerWidth || document.body.clientWidth;\nscreen\nscreen对象表示屏幕的信息，常用的属性有：\n\nscreen.width：屏幕宽度，以像素为单位；\nscreen.height：屏幕高度，以像素为单位；\nscreen.colorDepth：返回颜色位数，如8、16、24。\n\n1console.log(&#x27;Screen size = &#x27; + screen.width + &#x27; x &#x27; + screen.height);\nlocation\nlocation对象表示当前页面的URL信息。例如，一个完整的URL：\n1http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP\n可以用location.href获取。要获得URL各个部分的值，可以这么写：\n123456location.protocol; // &#x27;http&#x27;location.host; // &#x27;www.example.com&#x27;location.port; // &#x27;8080&#x27;location.pathname; // &#x27;/path/index.html&#x27;location.search; // &#x27;?a=1&amp;b=2&#x27;location.hash; // &#x27;TOP&#x27;\n要加载一个新页面，可以调用location.assign()。如果要重新加载当前页面，调用location.reload()方法非常方便。\n12345if (confirm(&#x27;重新加载当前页&#x27; + location.href + &#x27;?&#x27;)) &#123;    location.reload();&#125; else &#123;    location.assign(&#x27;/&#x27;); // 设置一个新的URL地址&#125;\ndocument\ndocument对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。\ndocument的title属性是从HTML文档中的&lt;title&gt;xxx&lt;/title&gt;读取的，但是可以动态改变：\n1document.title = &#x27;努力学习JavaScript!&#x27;;\n请观察浏览器窗口标题的变化。\n要查找DOM树的某个节点，需要从document对象开始查找。最常用的查找是根据ID和Tag Name。\n我们先准备HTML数据：\n12345678&lt;dl id=&quot;drink-menu&quot; style=&quot;border:solid 1px #ccc;padding:6px;&quot;&gt;    &lt;dt&gt;摩卡&lt;/dt&gt;    &lt;dd&gt;热摩卡咖啡&lt;/dd&gt;    &lt;dt&gt;酸奶&lt;/dt&gt;    &lt;dd&gt;北京老酸奶&lt;/dd&gt;    &lt;dt&gt;果汁&lt;/dt&gt;    &lt;dd&gt;鲜榨苹果汁&lt;/dd&gt;&lt;/dl&gt;\n摩卡\n热摩卡咖啡\n酸奶\n北京老酸奶\n果汁\n鲜榨苹果汁\n用document对象提供的getElementById()和getElementsByTagName()可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点：\n12345678let menu = document.getElementById(&#x27;drink-menu&#x27;);let drinks = document.getElementsByTagName(&#x27;dt&#x27;);let s = &#x27;提供的饮料有:&#x27;;for (let i=0; i&lt;drinks.length; i++) &#123;    s = s + drinks[i].innerHTML + &#x27;,&#x27;;&#125;console.log(s);\ndocument对象还有一个cookie属性，可以获取当前页面的Cookie。\nCookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如user=ABC123XYZ(加密的字符串)...，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。\nCookie还可以存储网站的一些设置，例如，页面显示的语言等等。\nJavaScript可以通过document.cookie读取到当前页面的Cookie：\n1document.cookie; // &#x27;v=123; remember=true; prefer=zh&#x27;\n由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患，这是因为在HTML页面中引入第三方的JavaScript代码是允许的：\n1234567&lt;!-- 当前页面在wwwexample.com --&gt;&lt;html&gt;    &lt;head&gt;        &lt;script src=&quot;http://www.foo.com/jquery.js&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    ...&lt;/html&gt;\n如果引入的第三方的JavaScript中存在恶意代码，则www.foo.com网站将直接获取到www.example.com网站的用户登录信息。\n为了解决这个问题，服务器在设置Cookie时可以使用httpOnly，设定了httpOnly的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持httpOnly选项，IE从IE6 SP1开始支持。\n为了确保安全，服务器端在设置Cookie时，应该始终坚持使用httpOnly。\nhistory\nhistory对象保存了浏览器的历史记录，JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮。\n这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用history.back()可能会让用户感到非常愤怒。\n新手开始设计Web页面时喜欢在登录页登录成功时调用history.back()，试图回到登录前的页面。这是一种错误的方法。\n对使用AJAX动态加载的页面，如果希望页面更新时同时更新history对象，应当使用history.pushState()方法：\n1234// when AJAX is done:let state = &#x27;any-data&#x27;;let newUrl = &#x27;/ajax.html#signin&#x27;;history.pushState(state, &#x27;&#x27;, newUrl);\n当用户点击“后退”时，浏览器并不会刷新页面，而是触发popstate事件，可由JavaScript捕获并更新相应的部分页面内容。\n参考\n常用浏览器对象参考：\n\nWindow\nNavigator\nScreen\nLocation\nDocument\nHistory\n\n操作DOM\n由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。\n始终记住DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作：\n\n更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容；\n遍历：遍历该DOM节点下的子节点，以便进行进一步操作；\n添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点；\n删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。\n\n在操作一个DOM节点前，我们需要通过各种方式先拿到这个DOM节点。最常用的方法是document.getElementById()和document.getElementsByTagName()，以及CSS选择器document.getElementsByClassName()。\n由于ID在HTML文档中是唯一的，所以document.getElementById()可以直接定位唯一的一个DOM节点。document.getElementsByTagName()和document.getElementsByClassName()总是返回一组DOM节点。要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。\n例如：\n123456789101112131415// 返回ID为&#x27;test&#x27;的节点：let test = document.getElementById(&#x27;test&#x27;);// 先定位ID为&#x27;test-table&#x27;的节点，再返回其内部所有tr节点：let trs = document.getElementById(&#x27;test-table&#x27;).getElementsByTagName(&#x27;tr&#x27;);// 先定位ID为&#x27;test-div&#x27;的节点，再返回其内部所有class包含red的节点：let reds = document.getElementById(&#x27;test-div&#x27;).getElementsByClassName(&#x27;red&#x27;);// 获取节点test下的所有直属子节点:let cs = test.children;// 获取节点test下第一个、最后一个子节点：let first = test.firstElementChild;let last = test.lastElementChild;\n第二种方法是使用querySelector()和querySelectorAll()，需要了解selector语法，然后使用条件来获取节点，更加方便：\n12345// 通过querySelector获取ID为q1的节点：let q1 = document.querySelector(&#x27;#q1&#x27;);// 通过querySelectorAll获取q1节点内的符合条件的所有节点：let ps = q1.querySelectorAll(&#x27;div.highlighted &gt; p&#x27;);\n注意：低版本的IE&lt;8不支持querySelector和querySelectorAll。IE8仅有限支持。\n严格地讲，我们这里的DOM节点是指Element，但是DOM节点实际上是Node，在HTML中，Node包括Element、Comment、CDATA_SECTION等很多种，以及根节点Document类型，但是，绝大多数时候我们只关心Element，也就是实际控制页面结构的Node，其他类型的Node忽略即可。根节点Document已经自动绑定为全局变量document。\n练习\n如下的HTML结构：\n12345678910111213141516&lt;!-- HTML结构 --&gt;&lt;div id=&quot;test-div&quot;&gt;  &lt;div class=&quot;c-red&quot;&gt;    &lt;p id=&quot;test-p&quot;&gt;JavaScript&lt;/p&gt;    &lt;p&gt;Java&lt;/p&gt;  &lt;/div&gt;  &lt;div class=&quot;c-red c-green&quot;&gt;    &lt;p&gt;Python&lt;/p&gt;    &lt;p&gt;Ruby&lt;/p&gt;    &lt;p&gt;Swift&lt;/p&gt;  &lt;/div&gt;  &lt;div class=&quot;c-green&quot;&gt;    &lt;p&gt;Scheme&lt;/p&gt;    &lt;p&gt;Haskell&lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;\n请选择出指定条件的节点：\n12345678910111213141516171819// 选择&lt;p&gt;JavaScript&lt;/p&gt;:let js = ???;// 选择&lt;p&gt;Python&lt;/p&gt;,&lt;p&gt;Ruby&lt;/p&gt;,&lt;p&gt;Swift&lt;/p&gt;:let arr = ???;// 选择&lt;p&gt;Haskell&lt;/p&gt;:let haskell = ???;// 测试:if (!js || js.innerText !== &#x27;JavaScript&#x27;) &#123;    alert(&#x27;选择JavaScript失败!&#x27;);&#125; else if (!arr || arr.length !== 3 || !arr[0] || !arr[1] || !arr[2] || arr[0].innerText !== &#x27;Python&#x27; || arr[1].innerText !== &#x27;Ruby&#x27; || arr[2].innerText !== &#x27;Swift&#x27;) &#123;    console.log(&#x27;选择Python,Ruby,Swift失败!&#x27;);&#125; else if (!haskell || haskell.innerText !== &#x27;Haskell&#x27;) &#123;    console.log(&#x27;选择Haskell失败!&#x27;);&#125; else &#123;    console.log(&#x27;测试通过!&#x27;);&#125;\n\n\n更新DOM\n拿到一个DOM节点后，我们可以对它进行更新。\n可以直接修改节点的文本，方法有两种：\n一种是修改innerHTML属性，这个方式非常强大，不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树：\n1234567// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;let p = document.getElementById(&#x27;p-id&#x27;);// 设置文本为abc:p.innerHTML = &#x27;ABC&#x27;; // &lt;p id=&quot;p-id&quot;&gt;ABC&lt;/p&gt;// 设置HTML:p.innerHTML = &#x27;ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ&#x27;;// &lt;p&gt;...&lt;/p&gt;的内部结构已修改\n用innerHTML时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到的，要注意对字符编码来避免XSS攻击。\n第二种是修改innerText或textContent属性，这样可以自动对字符串进行HTML编码，保证无法设置任何HTML标签：\n123456// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;let p = document.getElementById(&#x27;p-id&#x27;);// 设置文本:p.innerText = &#x27;&lt;script&gt;alert(&quot;Hi&quot;)&lt;/script&gt;&#x27;;// HTML被自动编码，无法设置一个&lt;script&gt;节点:// &lt;p id=&quot;p-id&quot;&gt;&amp;lt;script&amp;gt;alert(&quot;Hi&quot;)&amp;lt;/script&amp;gt;&lt;/p&gt;\n两者的区别在于读取属性时，innerText不返回隐藏元素的文本，而textContent返回所有文本。另外注意IE&lt;9不支持textContent。\n修改CSS也是经常需要的操作。DOM节点的style属性对应所有的CSS，可以直接获取或设置。因为CSS允许font-size这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名fontSize：\n123456// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;let p = document.getElementById(&#x27;p-id&#x27;);// 设置CSS:p.style.color = &#x27;#ff0000&#x27;;p.style.fontSize = &#x27;20px&#x27;;p.style.paddingTop = &#x27;2em&#x27;;\n练习\n有如下的HTML结构：\n12345&lt;!-- HTML结构 --&gt;&lt;div id=&quot;test-div&quot;&gt;  &lt;p id=&quot;test-js&quot;&gt;javascript&lt;/p&gt;  &lt;p&gt;Java&lt;/p&gt;&lt;/div&gt;\n请尝试获取指定节点并修改：\n1234567891011121314151617181920212223// 获取&lt;p&gt;javascript&lt;/p&gt;节点:let js = ???;// 修改文本为JavaScript:// TODO:// 修改CSS为: color: #ff0000, font-weight: bold// TODO:// 测试:if (js &amp;&amp; js.parentNode &amp;&amp; js.parentNode.id === &#x27;test-div&#x27; &amp;&amp; js.id === &#x27;test-js&#x27;) &#123;    if (js.innerText === &#x27;JavaScript&#x27;) &#123;        if (js.style &amp;&amp; js.style.fontWeight === &#x27;bold&#x27; &amp;&amp; (js.style.color === &#x27;red&#x27; || js.style.color === &#x27;#ff0000&#x27; || js.style.color === &#x27;#f00&#x27; || js.style.color === &#x27;rgb(255, 0, 0)&#x27;)) &#123;            console.log(&#x27;测试通过!&#x27;);        &#125; else &#123;            console.log(&#x27;CSS样式测试失败!&#x27;);        &#125;    &#125; else &#123;        console.log(&#x27;文本测试失败!&#x27;);    &#125;&#125; else &#123;    console.log(&#x27;节点测试失败!&#x27;);&#125;\n\n\n当我们获得了某个DOM节点，想在这个DOM节点内插入新的DOM，应该如何做？\n如果这个DOM节点是空的，例如，&lt;div&gt;&lt;/div&gt;，那么，直接使用innerHTML = '&lt;span&gt;child&lt;/span&gt;'就可以修改DOM节点的内容，相当于“插入”了新的DOM节点。\n如果这个DOM节点不是空的，那就不能这么做，因为innerHTML会直接替换掉原来的所有子节点。\n有两个办法可以插入新的节点。一个是使用appendChild，把一个子节点添加到父节点的最后一个子节点。例如：\n1234567&lt;!-- HTML结构 --&gt;&lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;&lt;div id=&quot;list&quot;&gt;    &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt;    &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt;    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;&lt;/div&gt;\n把&lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;添加到&lt;div id=&quot;list&quot;&gt;的最后一项：\n1234let    js = document.getElementById(&#x27;js&#x27;),    list = document.getElementById(&#x27;list&#x27;);list.appendChild(js);\n现在，HTML结构变成了这样：\n1234567&lt;!-- HTML结构 --&gt;&lt;div id=&quot;list&quot;&gt;    &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt;    &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt;    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;    &lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;&lt;/div&gt;\n因为我们插入的js节点已经存在于当前的文档树，因此这个节点首先会从原先的位置删除，再插入到新的位置。\n更多的时候我们会从零创建一个新的节点，然后插入到指定位置：\n123456let    list = document.getElementById(&#x27;list&#x27;),    haskell = document.createElement(&#x27;p&#x27;);haskell.id = &#x27;haskell&#x27;;haskell.innerText = &#x27;Haskell&#x27;;list.appendChild(haskell);\n这样我们就动态添加了一个新的节点：\n1234567&lt;!-- HTML结构 --&gt;&lt;div id=&quot;list&quot;&gt;    &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt;    &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt;    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;    &lt;p id=&quot;haskell&quot;&gt;Haskell&lt;/p&gt;&lt;/div&gt;\n动态创建一个节点然后添加到DOM树中，可以实现很多功能。举个例子，下面的代码动态创建了一个&lt;style&gt;节点，然后把它添加到&lt;head&gt;节点的末尾，这样就动态地给文档添加了新的CSS定义：\n1234let d = document.createElement(&#x27;style&#x27;);d.setAttribute(&#x27;type&#x27;, &#x27;text/css&#x27;);d.innerHTML = &#x27;p &#123; color: red &#125;&#x27;;document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(d);\n可以在Chrome的控制台执行上述代码，观察页面样式的变化。\ninsertBefore\n如果我们要把子节点插入到指定的位置怎么办？可以使用parentElement.insertBefore(newElement, referenceElement);，子节点会插入到referenceElement之前。\n还是以上面的HTML为例，假定我们要把Haskell插入到Python之前：\n123456&lt;!-- HTML结构 --&gt;&lt;div id=&quot;list&quot;&gt;    &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt;    &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt;    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;&lt;/div&gt;\n可以这么写：\n1234567let    list = document.getElementById(&#x27;list&#x27;),    ref = document.getElementById(&#x27;python&#x27;),    haskell = document.createElement(&#x27;p&#x27;);haskell.id = &#x27;haskell&#x27;;haskell.innerText = &#x27;Haskell&#x27;;list.insertBefore(haskell, ref);\n新的HTML结构如下：\n1234567&lt;!-- HTML结构 --&gt;&lt;div id=&quot;list&quot;&gt;    &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt;    &lt;p id=&quot;haskell&quot;&gt;Haskell&lt;/p&gt;    &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt;    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;&lt;/div&gt;\n可见，使用insertBefore重点是要拿到一个“参考子节点”的引用。很多时候，需要循环一个父节点的所有子节点，可以通过迭代children属性实现：\n123456let    i, c,    list = document.getElementById(&#x27;list&#x27;);for (i = 0; i &lt; list.children.length; i++) &#123;    c = list.children[i]; // 拿到第i个子节点&#125;\n练习\n对于一个已有的HTML结构：\n12345678&lt;!-- HTML结构 --&gt;&lt;ol id=&quot;test-list&quot;&gt;    &lt;li class=&quot;lang&quot;&gt;Scheme&lt;/li&gt;    &lt;li class=&quot;lang&quot;&gt;JavaScript&lt;/li&gt;    &lt;li class=&quot;lang&quot;&gt;Python&lt;/li&gt;    &lt;li class=&quot;lang&quot;&gt;Ruby&lt;/li&gt;    &lt;li class=&quot;lang&quot;&gt;Haskell&lt;/li&gt;&lt;/ol&gt;\n\nScheme\nJavaScript\nPython\nRuby\nHaskell\n\n按字符串顺序重新排序DOM节点：\n123456789101112131415161718192021222324// sort list:TODO// 测试:(function () &#123;    let        arr, i,        t = document.getElementById(&#x27;test-list&#x27;);    if (t &amp;&amp; t.children &amp;&amp; t.children.length === 5) &#123;        arr = [];        for (i=0; i&lt;t.children.length; i++) &#123;            arr.push(t.children[i].innerText);        &#125;        if (arr.toString() === [&#x27;Haskell&#x27;, &#x27;JavaScript&#x27;, &#x27;Python&#x27;, &#x27;Ruby&#x27;, &#x27;Scheme&#x27;].toString()) &#123;            console.log(&#x27;测试通过!&#x27;);        &#125;        else &#123;            console.log(&#x27;测试失败: &#x27; + arr.toString());        &#125;    &#125;    else &#123;        console.log(&#x27;测试失败!&#x27;);    &#125;&#125;)();\n删除DOM\n删除一个DOM节点就比插入要容易得多。\n要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉：\n1234567// 拿到待删除节点:let self = document.getElementById(&#x27;to-be-removed&#x27;);// 拿到父节点:let parent = self.parentElement;// 删除:let removed = parent.removeChild(self);removed === self; // true\n注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。\n当你遍历一个父节点的子节点并进行删除操作时，要注意，children属性是一个只读属性，并且它在子节点变化时会实时更新。\n例如，对于如下HTML结构：\n1234&lt;div id=&quot;parent&quot;&gt;    &lt;p&gt;First&lt;/p&gt;    &lt;p&gt;Second&lt;/p&gt;&lt;/div&gt;\n当我们用如下代码删除子节点时：\n123let parent = document.getElementById(&#x27;parent&#x27;);parent.removeChild(parent.children[0]);parent.removeChild(parent.children[1]); // &lt;-- 浏览器报错\n浏览器报错：parent.children[1]不是一个有效的节点。原因就在于，当&lt;p&gt;First&lt;/p&gt;节点被删除后，parent.children的节点数量已经从2变为了1，索引[1]已经不存在了。\n因此，删除多个节点时，要注意children属性时刻都在变化。\n练习\n123456789&lt;!-- HTML结构 --&gt;&lt;ul id=&quot;test-list&quot;&gt;    &lt;li&gt;JavaScript&lt;/li&gt;    &lt;li&gt;Swift&lt;/li&gt;    &lt;li&gt;HTML&lt;/li&gt;    &lt;li&gt;ANSI C&lt;/li&gt;    &lt;li&gt;CSS&lt;/li&gt;    &lt;li&gt;DirectX&lt;/li&gt;&lt;/ul&gt;\n\nJavaScript\nSwift\nHTML\nANSI C\nCSS\nDirectX\n\n把与Web开发技术不相关的节点删掉：\n1234567891011121314151617181920212223// TODO// 测试:(function () &#123;    let        arr, i,        t = document.getElementById(&#x27;test-list&#x27;);    if (t &amp;&amp; t.children &amp;&amp; t.children.length === 3) &#123;        arr = [];        for (i = 0; i &lt; t.children.length; i ++) &#123;            arr.push(t.children[i].innerText);        &#125;        if (arr.toString() === [&#x27;JavaScript&#x27;, &#x27;HTML&#x27;, &#x27;CSS&#x27;].toString()) &#123;            console.log(&#x27;测试通过!&#x27;);        &#125;        else &#123;            console.log(&#x27;测试失败: &#x27; + arr.toString());        &#125;    &#125;    else &#123;        console.log(&#x27;测试失败!&#x27;);    &#125;&#125;)();\n\n\n用JavaScript操作表单和操作DOM是类似的，因为表单本身也是DOM树。\n不过表单的输入框、下拉框等可以接收用户输入，所以用JavaScript来操作表单，可以获得用户输入的内容，或者对一个输入框设置新的内容。\nHTML表单的输入控件主要有以下几种：\n\n文本框，对应的&lt;input type=&quot;text&quot;&gt;，用于输入文本；\n口令框，对应的&lt;input type=&quot;password&quot;&gt;，用于输入口令；\n单选框，对应的&lt;input type=&quot;radio&quot;&gt;，用于选择一项；\n复选框，对应的&lt;input type=&quot;checkbox&quot;&gt;，用于选择多项；\n下拉框，对应的&lt;select&gt;，用于选择一项；\n隐藏文本，对应的&lt;input type=&quot;hidden&quot;&gt;，用户不可见，但表单提交时会把隐藏文本发送到服务器。\n\n获取值\n如果我们获得了一个&lt;input&gt;节点的引用，就可以直接调用value获得对应的用户输入值：\n123// &lt;input type=&quot;text&quot; id=&quot;email&quot;&gt;let input = document.getElementById(&#x27;email&#x27;);input.value; // &#x27;用户输入的值&#x27;\n这种方式可以应用于text、password、hidden以及select。但是，对于单选框和复选框，value属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用checked判断：\n12345678// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;monday&quot; value=&quot;1&quot;&gt; Monday&lt;/label&gt;// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;tuesday&quot; value=&quot;2&quot;&gt; Tuesday&lt;/label&gt;let mon = document.getElementById(&#x27;monday&#x27;);let tue = document.getElementById(&#x27;tuesday&#x27;);mon.value; // &#x27;1&#x27;tue.value; // &#x27;2&#x27;mon.checked; // true或者falsetue.checked; // true或者false\n设置值\n设置值和获取值类似，对于text、password、hidden以及select，直接设置value就可以：\n123// &lt;input type=&quot;text&quot; id=&quot;email&quot;&gt;let input = document.getElementById(&#x27;email&#x27;);input.value = &#x27;test@example.com&#x27;; // 文本框的内容已更新\n对于单选框和复选框，设置checked为true或false即可。\nHTML5控件\nHTML5新增了大量标准控件，常用的包括date、datetime、datetime-local、color等，它们都使用&lt;input&gt;标签：\n1&lt;input type=&quot;date&quot; value=&quot;2021-12-02&quot;&gt;\n1&lt;input type=&quot;datetime-local&quot; value=&quot;2021-12-02T20:21:12&quot;&gt;\n1&lt;input type=&quot;color&quot; value=&quot;#ff0000&quot;&gt;\n不支持HTML5的浏览器无法识别新的控件，会把它们当做type=&quot;text&quot;来显示。支持HTML5的浏览器将获得格式化的字符串。例如，type=&quot;date&quot;类型的input的value将保证是一个有效的YYYY-MM-DD格式的日期，或者空字符串。\n提交表单\n最后，JavaScript可以以两种方式来处理表单的提交（AJAX方式在后面章节介绍）。\n方式一是通过&lt;form&gt;元素的submit()方法提交一个表单，例如，响应一个&lt;button&gt;的click事件，在JavaScript代码中提交表单：\n1234567891011121314&lt;!-- HTML --&gt;&lt;form id=&quot;test-form&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;test&quot;&gt;    &lt;button type=&quot;button&quot; onclick=&quot;doSubmitForm()&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function doSubmitForm() &#123;    let form = document.getElementById(&#x27;test-form&#x27;);    // 可以在此修改form的input...    // 提交form:    form.submit();&#125;&lt;/script&gt;\n这种方式的缺点是扰乱了浏览器对form的正常提交。浏览器默认点击&lt;button type=&quot;submit&quot;&gt;时提交表单，或者用户在最后一个输入框按回车键。因此，第二种方式是响应&lt;form&gt;本身的onsubmit事件，在提交form时作修改：\n1234567891011121314&lt;!-- HTML --&gt;&lt;form id=&quot;test-form&quot; onsubmit=&quot;return checkForm()&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;test&quot;&gt;    &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function checkForm() &#123;    let form = document.getElementById(&#x27;test-form&#x27;);    // 可以在此修改form的input...    // 继续下一步:    return true;&#125;&lt;/script&gt;\n注意要return true来告诉浏览器继续提交，如果return false，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。\n在检查和修改&lt;input&gt;时，要充分利用&lt;input type=&quot;hidden&quot;&gt;来传递数据。\n例如，很多登录表单希望用户输入用户名和口令，但是，安全考虑，提交表单时不传输明文口令，而是口令的MD5。普通JavaScript开发人员会直接修改&lt;input&gt;：\n12345678910111213141516&lt;!-- HTML --&gt;&lt;form id=&quot;login-form&quot; method=&quot;post&quot; onsubmit=&quot;return checkForm()&quot;&gt;    &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt;    &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;&gt;    &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function checkForm() &#123;    let pwd = document.getElementById(&#x27;password&#x27;);    // 把用户输入的明文变为MD5:    pwd.value = toMD5(pwd.value);    // 继续下一步:    return true;&#125;&lt;/script&gt;\n这个做法看上去没啥问题，但用户输入了口令提交时，口令框的显示会突然从几个*变成32个*（因为MD5有32个字符）。\n要想不改变用户的输入，可以利用&lt;input type=&quot;hidden&quot;&gt;实现：\n123456789101112131415161718&lt;!-- HTML --&gt;&lt;form id=&quot;login-form&quot; method=&quot;post&quot; onsubmit=&quot;return checkForm()&quot;&gt;    &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt;    &lt;input type=&quot;password&quot; id=&quot;input-password&quot;&gt;    &lt;input type=&quot;hidden&quot; id=&quot;md5-password&quot; name=&quot;password&quot;&gt;    &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function checkForm() &#123;    let input_pwd = document.getElementById(&#x27;input-password&#x27;);    let md5_pwd = document.getElementById(&#x27;md5-password&#x27;);    // 把用户输入的明文变为MD5:    md5_pwd.value = toMD5(input_pwd.value);    // 继续下一步:    return true;&#125;&lt;/script&gt;\n注意到id为md5-password的&lt;input&gt;标记了name=&quot;password&quot;，而用户输入的id为input-password的&lt;input&gt;没有name属性。没有name属性的&lt;input&gt;的数据不会被提交。\n练习\n利用JavaScript检查用户注册信息是否正确，在以下情况不满足时报错并阻止提交表单：\n\n用户名必须是3-10位英文字母或数字；\n口令必须是6-20位；\n两次输入口令必须一致。\n\n12345678910111213141516&lt;!-- HTML结构 --&gt;&lt;form id=&quot;test-register&quot; action=&quot;#&quot; target=&quot;_blank&quot; onsubmit=&quot;return checkRegisterForm()&quot;&gt;    &lt;p id=&quot;test-error&quot; style=&quot;color:red&quot;&gt;&lt;/p&gt;    &lt;p&gt;        用户名: &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        口令: &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        重复口令: &lt;input type=&quot;password&quot; id=&quot;password-2&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;    &lt;/p&gt;&lt;/form&gt;\n12345678910111213141516171819window.checkRegisterForm = function () &#123;    // TODO:    return false;&#125;;// 测试:(function () &#123;    window.testFormHandler = window.checkRegisterForm;    let form = document.getElementById(&#x27;test-register&#x27;);    if (form.dispatchEvent) &#123;        let event = new Event(&#x27;submit&#x27;, &#123;    \t\tbubbles: true,    \t\tcancelable: true  \t\t&#125;);        form.dispatchEvent(event);    &#125; else &#123;        form.fireEvent(&#x27;onsubmit&#x27;);    &#125;&#125;)();\n在HTML表单中，可以上传文件的唯一控件就是&lt;input type=&quot;file&quot;&gt;。\n注意：当一个表单包含&lt;input type=&quot;file&quot;&gt;时，表单的enctype必须指定为multipart/form-data，method必须指定为post，浏览器才能正确编码并以multipart/form-data格式发送表单的数据。\n出于安全考虑，浏览器只允许用户点击&lt;input type=&quot;file&quot;&gt;来选择本地文件，用JavaScript对&lt;input type=&quot;file&quot;&gt;的value赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径：\n通常，上传的文件都由后台服务器处理，JavaScript可以在提交表单时对文件扩展名做检查，以便防止用户上传无效格式的文件：\n123456let f = document.getElementById(&#x27;test-file-upload&#x27;);let filename = f.value; // &#x27;C:\\fakepath\\test.png&#x27;if (!filename || !(filename.endsWith(&#x27;.jpg&#x27;) || filename.endsWith(&#x27;.png&#x27;) || filename.endsWith(&#x27;.gif&#x27;))) &#123;    alert(&#x27;Can only upload image file.&#x27;);    return false;&#125;\nFile API\n由于JavaScript对用户上传的文件操作非常有限，尤其是无法读取文件内容，使得很多需要操作文件的网页不得不用Flash这样的第三方插件来实现。\n随着HTML5的普及，新增的File API允许JavaScript读取文件内容，获得更多的文件信息。\nHTML5的File API提供了File和FileReader两个主要对象，可以获得文件信息并读取文件。\n下面的例子演示了如何读取用户选取的图片文件，并在一个&lt;div&gt;中预览图像：\n123456789101112131415161718192021222324252627282930313233let    fileInput = document.getElementById(&#x27;test-image-file&#x27;),    info = document.getElementById(&#x27;test-file-info&#x27;),    preview = document.getElementById(&#x27;test-image-preview&#x27;);// 监听change事件:fileInput.addEventListener(&#x27;change&#x27;, function () &#123;    // 清除背景图片:    preview.style.backgroundImage = &#x27;&#x27;;    // 检查文件是否选择:    if (!fileInput.value) &#123;        info.innerHTML = &#x27;没有选择文件&#x27;;        return;    &#125;    // 获取File引用:    let file = fileInput.files[0];    // 获取File信息:    info.innerHTML = &#x27;文件: &#x27; + file.name + &#x27;&lt;br&gt;&#x27; +                     &#x27;大小: &#x27; + file.size + &#x27;&lt;br&gt;&#x27; +                     &#x27;修改: &#x27; + file.lastModified;    if (file.type !== &#x27;image/jpeg&#x27; &amp;&amp; file.type !== &#x27;image/png&#x27; &amp;&amp; file.type !== &#x27;image/gif&#x27;) &#123;        alert(&#x27;不是有效的图片文件!&#x27;);        return;    &#125;    // 读取文件:    let reader = new FileReader();    reader.onload = function(e) &#123;        let            data = e.target.result; // &#x27;data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...&#x27;                    preview.style.backgroundImage = &#x27;url(&#x27; + data + &#x27;)&#x27;;    &#125;;    // 以DataURL的形式读取文件:    reader.readAsDataURL(file);&#125;);\n上面的代码演示了如何通过HTML5的File API读取文件内容。以DataURL的形式读取到的文件是一个字符串，类似于data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...，常用于设置图像。如果需要服务器端处理，把字符串base64,后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。\n回调\n上面的代码还演示了JavaScript的一个重要的特性就是单线程执行模式。在JavaScript中，浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行，也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行。\n你可能会问，单线程模式执行的JavaScript，如何处理多任务？\n在JavaScript中，执行多任务实际上都是异步调用，比如上面的代码：\n1reader.readAsDataURL(file);\n就会发起一个异步操作来读取文件内容。因为是异步操作，所以我们在JavaScript代码中就不知道什么时候操作结束，因此需要先设置一个回调函数：\n123reader.onload = function(e) &#123;    // 当文件读取完成后，自动调用此函数:&#125;;\n当文件读取完成后，JavaScript引擎将自动调用我们设置的回调函数。执行回调函数时，文件已经读取完毕，所以我们可以在回调函数内部安全地获得文件内容。\nAJAX不是JavaScript的规范，它只是一个哥们“发明”的缩写：Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求。\n如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。\n这就是Web的运作原理：一次HTTP请求对应一个页面。\n如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。\n最早大规模使用AJAX的就是Gmail，Gmail的页面在首次加载后，剩下的所有数据都依赖于AJAX来更新。\n用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。\n在现代浏览器上写AJAX主要依靠XMLHttpRequest对象，如果不考虑早期浏览器的兼容性问题，现代浏览器还提供了原生支持的Fetch API，以Promise方式提供。使用Fetch API发送HTTP请求代码如下：\n1234567891011async function get(url) &#123;    let resp = await fetch(url);    let result = await resp.text();    return result;&#125;// 发送异步请求:get(&#x27;./content.html&#x27;).then(data =&gt; &#123;    let textarea = document.getElementById(&#x27;fetch-response-text&#x27;);    textarea.value = data;&#125;);\n使用Fetch API配合async写法，代码更加简单。\nFetch API的详细用法可以参考MDN文档。\n安全限制\n上面代码的URL使用的是相对路径。如果你把它改为'https://www.sina.com.cn/'，再运行，肯定报错。在Chrome的控制台里，还可以看到错误信息。\n这是因为浏览器的同源策略导致的。默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致。\n完全一致的意思是，域名要相同（www.example.com和example.com不同），协议要相同（http和https不同），端口号要相同（http默认是:80端口，它和:8080就不同）。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。\n那是不是用JavaScript无法请求外域（就是其他网站）的URL了呢？方法还是有的，大概有这么几种：\n一是通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，而且现在用得也越来越少了。\n二是通过在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器：\n1&#x27;/proxy?url=https://www.sina.com.cn&#x27;\n代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发。\n第三种方式称为JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源：\n123456789&lt;html&gt;&lt;head&gt;    &lt;script src=&quot;http://example.com/abc.js&quot;&gt;&lt;/script&gt;    ...&lt;/head&gt;&lt;body&gt;...&lt;/body&gt;&lt;/html&gt;\nJSONP通常以函数调用的形式返回，例如，返回JavaScript内容如下：\n1foo(&#x27;data&#x27;);\n这样一来，我们如果在页面中先准备好foo()函数，然后给页面动态加一个&lt;script&gt;节点，相当于动态读取外域的JavaScript资源，最后就等着接收回调了。\nCORS\n如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：CORS了。\nCORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。\n了解CORS前，我们先搞明白概念：\nOrigin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。\n用一个图来表示就是：\n12345678910         GET /res/abc.data         Host: sina.com┌──────┐ Origin: http://my.com                      ┌────────┐│my.com│───────────────────────────────────────────▶│sina.com││      │◀───────────────────────────────────────────│        │└──────┘ HTTP/1.1 200 OK                            └────────┘         Access-Control-Allow-Origin: http://my.com         Content-Type: text/xml         &lt;xml data...&gt;\n假设本域是my.com，外域是sina.com，只要响应头Access-Control-Allow-Origin为http://my.com，或者是*，本次请求就可以成功。\n可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的Access-Control-Allow-Origin，决定权始终在对方手中。\n上面这种跨域请求，称之为“简单请求”。简单请求包括GET、HEAD和POST（POST的Content-Type类型 仅限application/x-www-form-urlencoded、multipart/form-data和text/plain），并且不能出现任何自定义头（例如，X-Custom: 12345），通常能满足90%的需求。\n无论你是否需要用JavaScript通过CORS跨域请求资源，你都要了解CORS的原理。最新的浏览器全面支持HTML5。在引用外域资源时，除了JavaScript和CSS外，都要验证CORS。例如，当你引用了某个第三方CDN上的字体文件时：\n12345/* CSS */@font-face &#123;  font-family: &#x27;FontAwesome&#x27;;  src: url(&#x27;http://cdn.com/fonts/fontawesome.ttf&#x27;) format(&#x27;truetype&#x27;);&#125;\n如果该CDN服务商未正确设置Access-Control-Allow-Origin，那么浏览器无法加载字体资源。\n对于PUT、DELETE以及其他类型如application/json的POST请求，在发送AJAX请求之前，浏览器会先发送一个OPTIONS请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受：\n1234OPTIONS /path/to/resource HTTP/1.1Host: bar.comOrigin: http://my.comAccess-Control-Request-Method: POST\n服务器必须响应并明确指出允许的Method：\n1234HTTP/1.1 200 OKAccess-Control-Allow-Origin: http://my.comAccess-Control-Allow-Methods: POST, GET, PUT, OPTIONSAccess-Control-Max-Age: 86400\n浏览器确认服务器响应的Access-Control-Allow-Methods头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。\n由于以POST、PUT方式传送JSON格式的数据在REST中很常见，所以要跨域正确处理POST和PUT请求，服务器端必须正确响应OPTIONS请求。\n需要深入了解CORS的童鞋请移步MDN文档和W3C文档。\n在JavaScript的世界中，所有代码都是单线程执行的。\n由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现：\n123456function callback() &#123;    console.log(&#x27;Done&#x27;);&#125;console.log(&#x27;before setTimeout()&#x27;);setTimeout(callback, 1000); // 1秒钟后调用callback函数console.log(&#x27;after setTimeout()&#x27;);\n观察上述代码执行，在Chrome的控制台输出可以看到：\n1234before setTimeout()after setTimeout()(等待1秒后)Done\n可见，异步操作会在将来的某个时间点触发一个函数调用。\nAJAX就是典型的异步操作：\n123456789request.onreadystatechange = function () &#123;    if (request.readyState === 4) &#123;        if (request.status === 200) &#123;            return success(request.responseText);        &#125; else &#123;            return fail(request.status);        &#125;    &#125;&#125;\n把回调函数success(request.responseText)和fail(request.status)写到一个AJAX操作里很正常，但是不好看，而且不利于代码复用。\n有没有更好的写法？比如写成这样：\n123let ajax = ajaxGet(&#x27;http://...&#x27;);ajax.ifSuccess(success)    .ifFail(fail);\n这种链式写法的好处在于，先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败，在将来的某个时候调用success函数或fail函数。\n古人云：“君子一诺千金”，这种“承诺将来会执行”的对象在JavaScript中称为Promise对象。\nPromise有各种开源实现，在ES6中被统一规范，由浏览器直接支持。先测试一下你的浏览器是否支持Promise：\n1234new Promise(function () &#123;&#125;);// 直接运行测试:console.log(&#x27;支持Promise!&#x27;);\n我们先看一个最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败：\n1234567891011121314function test(resolve, reject) &#123;    let timeOut = Math.random() * 2;    log(&#x27;set timeout to: &#x27; + timeOut + &#x27; seconds.&#x27;);    setTimeout(function () &#123;        if (timeOut &lt; 1) &#123;            log(&#x27;call resolve()...&#x27;);            resolve(&#x27;200 OK&#x27;);        &#125;        else &#123;            log(&#x27;call reject()...&#x27;);            reject(&#x27;timeout in &#x27; + timeOut + &#x27; seconds.&#x27;);        &#125;    &#125;, timeOut * 1000);&#125;\n这个test()函数有两个参数，这两个参数都是函数，如果执行成功，我们将调用resolve('200 OK')，如果执行失败，我们将调用reject('timeout in ' + timeOut + ' seconds.')。可以看出，test()函数只关心自身的逻辑，并不关心具体的resolve和reject将如何处理结果。\n有了执行函数，我们就可以用一个Promise对象来执行它，并在将来某个时刻获得成功或失败的结果：\n1234567let p1 = new Promise(test);let p2 = p1.then(function (result) &#123;    console.log(&#x27;成功：&#x27; + result);&#125;);let p3 = p2.catch(function (reason) &#123;    console.log(&#x27;失败：&#x27; + reason);&#125;);\n变量p1是一个Promise对象，它负责执行test函数。由于test函数在内部是异步执行的，当test函数执行成功时，我们告诉Promise对象：\n1234// 如果成功，执行这个函数：p1.then(function (result) &#123;    console.log(&#x27;成功：&#x27; + result);&#125;);\n当test函数执行失败时，我们告诉Promise对象：\n123p2.catch(function (reason) &#123;    console.log(&#x27;失败：&#x27; + reason);&#125;);\nPromise对象可以串联起来，所以上述代码可以简化为：\n12345new Promise(test).then(function (result) &#123;    console.log(&#x27;成功：&#x27; + result);&#125;).catch(function (reason) &#123;    console.log(&#x27;失败：&#x27; + reason);&#125;);\n实际测试一下，看看Promise是如何异步执行的：\n1234567891011121314151617181920212223242526272829303132// 清除log:let logging = document.getElementById(&#x27;test-promise-log&#x27;);while (logging.children.length &gt; 1) &#123;    logging.removeChild(logging.children[logging.children.length - 1]);&#125;// 输出log到页面:function log(s) &#123;    let p = document.createElement(&#x27;p&#x27;);    p.innerHTML = s;    logging.appendChild(p);&#125;new Promise(function (resolve, reject) &#123;    log(&#x27;start new Promise...&#x27;);    let timeOut = Math.random() * 2;    log(&#x27;set timeout to: &#x27; + timeOut + &#x27; seconds.&#x27;);    setTimeout(function () &#123;        if (timeOut &lt; 1) &#123;            log(&#x27;call resolve()...&#x27;);            resolve(&#x27;200 OK&#x27;);        &#125;        else &#123;            log(&#x27;call reject()...&#x27;);            reject(&#x27;timeout in &#x27; + timeOut + &#x27; seconds.&#x27;);        &#125;    &#125;, timeOut * 1000);&#125;).then(function (r) &#123;    log(&#x27;Done: &#x27; + r);&#125;).catch(function (reason) &#123;    log(&#x27;Failed: &#x27; + reason);&#125;);\nLog:\n可见Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了：\n1234567891011121314151617                                   ┌──────────────────┐                           then    │on_resolve(data) &#123;│                       ┌──────────▶│    // TODO       │                       │           │&#125;                 │┌────────────────────────┐         └──────────────────┘│   new Promise(async)   │└────────────────────────┘         ┌──────────────────┐             │         │           │on_reject(data) &#123; │             │         └──────────▶│    // TODO       │      promise│             catch   │&#125;                 │             │                     └──────────────────┘             ▼┌────────────────────────┐│async(resolve, reject) &#123;││    // TODO             ││&#125;                       │└────────────────────────┘\nPromise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。\n要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写：\n1job1.then(job2).then(job3).catch(handleError);\n其中，job1、job2和job3都是Promise对象。\n下面的例子演示了如何串行执行一系列需要异步计算获得结果的任务：\n123456789101112131415161718192021222324252627282930313233343536373839let logging = document.getElementById(&#x27;test-promise2-log&#x27;);while (logging.children.length &gt; 1) &#123;    logging.removeChild(logging.children[logging.children.length - 1]);&#125;function log(s) &#123;    let p = document.createElement(&#x27;p&#x27;);    p.innerHTML = s;    logging.appendChild(p);&#125;// 0.5秒后返回input*input的计算结果:function multiply(input) &#123;    return new Promise(function (resolve, reject) &#123;        log(&#x27;calculating &#x27; + input + &#x27; x &#x27; + input + &#x27;...&#x27;);        setTimeout(resolve, 500, input * input);    &#125;);&#125;// 0.5秒后返回input+input的计算结果:function add(input) &#123;    return new Promise(function (resolve, reject) &#123;        log(&#x27;calculating &#x27; + input + &#x27; + &#x27; + input + &#x27;...&#x27;);        setTimeout(resolve, 500, input + input);    &#125;);&#125;let p = new Promise(function (resolve, reject) &#123;    log(&#x27;start new Promise...&#x27;);    resolve(123);&#125;);p.then(multiply) .then(add) .then(multiply) .then(add) .then(function (result) &#123;    log(&#x27;Got value: &#x27; + result);&#125;);\nLog:\nsetTimeout可以看成一个模拟网络等异步执行的函数。\n除了串行执行若干异步任务外，Promise还可以并行执行异步任务。\n试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用Promise.all()实现如下：\n12345678910let p1 = new Promise(function (resolve, reject) &#123;    setTimeout(resolve, 500, &#x27;P1&#x27;);&#125;);let p2 = new Promise(function (resolve, reject) &#123;    setTimeout(resolve, 600, &#x27;P2&#x27;);&#125;);// 同时执行p1和p2，并在它们都完成后执行then:Promise.all([p1, p2]).then(function (results) &#123;    console.log(results); // 获得一个Array: [&#x27;P1&#x27;, &#x27;P2&#x27;]&#125;);\n有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用Promise.race()实现：\n123456789let p1 = new Promise(function (resolve, reject) &#123;    setTimeout(resolve, 500, &#x27;P1&#x27;);&#125;);let p2 = new Promise(function (resolve, reject) &#123;    setTimeout(resolve, 600, &#x27;P2&#x27;);&#125;);Promise.race([p1, p2]).then(function (result) &#123;    console.log(result); // &#x27;P1&#x27;&#125;);\n由于p1执行较快，Promise的then()将获得结果'P1'。p2仍在继续执行，但执行结果将被丢弃。\n如果我们组合使用Promise，就可以把很多异步任务以并行和串行的方式组合起来执行。\n我们说JavaScript异步操作需要通过Promise实现，一个Promise对象在操作网络时是异步的，等到返回后再调用回调函数，执行正确就调用then()，执行错误就调用catch()，虽然异步实现了，不会让用户感觉到页面“卡住”了，但是一堆then()、catch()写起来麻烦看起来也乱。\n有没有更简单的写法？\n可以用关键字async配合await调用Promise，实现异步操作，但代码却和同步写法类似：\n12345async function get(url) &#123;    let resp = await fetch(url);    let result = await resp.json();    return result;&#125;\n使用async function可以定义一个异步函数，异步函数和Promise可以看作是等价的，在async function内部，用await调用另一个异步函数，写起来和同步代码没啥区别，但执行起来是异步的。\n也就是说：\n1let resp = await fetch(url);\n自动实现了异步调用，它和下面的Promise代码等价：\n1234let promise = fetch(url);promise.then((resp) =&gt; &#123;    // 拿到resp&#125;);\n如果我们要实现catch()怎么办？用Promise的写法如下：\n123456let promise = fetch(url);promise.then((resp) =&gt; &#123;    // 拿到resp&#125;).catch(e =&gt; &#123;    // 出错了&#125;);\n用await调用时，直接用传统的try &#123; ... &#125; catch：\n123456789async function get(url) &#123;    try &#123;        let resp = await fetch(url);        let result = await resp.json();        return result;    &#125; catch (e) &#123;        // 出错了    &#125;&#125;\n用async定义异步函数，用await调用异步函数，写起来和同步代码差不多，但可读性大大提高。\n需要特别注意的是，await调用必须在async function中，不能在传统的同步代码中调用。那么问题来了，一个同步function怎么调用async function呢？\n首先，普通function直接用await调用异步函数将报错：\n1234567891011async function get(url) &#123;    let resp = await fetch(url);    return resp.json();&#125;function doGet() &#123;    let data = await get(&#x27;/api/categories&#x27;);    console.log(data);&#125;doGet();\n如果把await去掉，调用实际上发生了，但我们拿不到结果，因为我们拿到的并不是异步结果，而是一个Promise对象：\n123456789101112async function get(url) &#123;    let resp = await fetch(url);    let result = await resp.text();    return result;&#125;function doGet() &#123;    let promise = get(&#x27;./content.html&#x27;);    console.log(promise);&#125;doGet();\n因此，在普通function中调用async function，不能使用await，但可以直接调用async function拿到Promise对象，后面加上then()和catch()就可以拿到结果或错误了：\n123456789101112131415async function get(url) &#123;    let resp = await fetch(url);    let result = await resp.text();    return result;&#125;function doGet() &#123;    let promise = get(&#x27;./content.html&#x27;);    promise.then(data =&gt; &#123;        // 拿到data        document.getElementById(&#x27;test-response-text&#x27;).value = JSON.stringify(data);    &#125;);&#125;doGet();\n因此，定义异步任务时，使用async function比Promise简单，调用异步任务时，使用await比Promise简单，捕获错误时，按传统的try...catch写法，也比Promise简单。只要浏览器支持，完全可以用async简洁地实现异步操作。\nCanvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。\n没有Canvas的年代，绘图只能借助Flash插件实现，页面不得不用JavaScript和Flash进行交互。有了Canvas，我们就再也不需要Flash了，直接使用JavaScript完成绘制。\n一个Canvas定义了一个指定尺寸的矩形框，在这个范围内我们可以随意绘制：\n1&lt;canvas id=&quot;test-canvas&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;\n由于浏览器对HTML5标准支持不一致，所以，通常在&lt;canvas&gt;内部添加一些说明性HTML代码，如果浏览器支持Canvas，它将忽略&lt;canvas&gt;内部的HTML，如果浏览器不支持Canvas，它将显示&lt;canvas&gt;内部的HTML。在使用Canvas前，用canvas.getContext来测试浏览器是否支持Canvas：\n1234&lt;!-- HTML代码 --&gt;&lt;canvas id=&quot;test-canvas&quot; width=&quot;200&quot; heigth=&quot;100&quot;&gt;    &lt;p&gt;你的浏览器不支持Canvas&lt;/p&gt;&lt;/canvas&gt;\n你的浏览器不支持Canvas\n123456let canvas = document.getElementById(&#x27;test-canvas&#x27;);if (canvas.getContext) &#123;    console.log(&#x27;你的浏览器支持Canvas!&#x27;);&#125; else &#123;    console.log(&#x27;你的浏览器不支持Canvas!&#x27;);&#125;\ngetContext('2d')方法让我们拿到一个CanvasRenderingContext2D对象，所有的绘图操作都需要通过这个对象完成。\n1let ctx = canvas.getContext(&#x27;2d&#x27;);\n如果需要绘制3D怎么办？HTML5还有一个WebGL规范，允许在Canvas中绘制3D图形：\n1gl = canvas.getContext(&quot;webgl&quot;);\n本节我们只专注于绘制2D图形。\n绘制形状\n我们可以在Canvas上绘制各种形状。在绘制前，我们需要先了解一下Canvas的坐标系统：\n123456789 0,0                20  ┌───────────────────────▶ x  │                 │  │  │                 │10│─ ─ ─ ─ ─ ─ ─ ─ ─●  │                  20,10  ▼  y\nCanvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。\nCanvasRenderingContext2D对象有若干方法来绘制图形：\n123456789101112131415161718let    canvas = document.getElementById(&#x27;test-shape-canvas&#x27;),    ctx = canvas.getContext(&#x27;2d&#x27;);ctx.clearRect(0, 0, 200, 200); // 擦除(0,0)位置大小为200x200的矩形，擦除的意思是把该区域变为透明ctx.fillStyle = &#x27;#dddddd&#x27;; // 设置颜色ctx.fillRect(10, 10, 130, 130); // 把(10,10)位置大小为130x130的矩形涂色// 利用Path绘制复杂路径:let path=new Path2D();path.arc(75, 75, 50, 0, Math.PI*2, true);path.moveTo(110,75);path.arc(75, 75, 35, 0, Math.PI, false);path.moveTo(65, 65);path.arc(60, 65, 5, 0, Math.PI*2, true);path.moveTo(95, 65);path.arc(90, 65, 5, 0, Math.PI*2, true);ctx.strokeStyle = &#x27;#0000ff&#x27;;ctx.stroke(path);\n绘制文本\n绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致：\n12345678910111213let    canvas = document.getElementById(&#x27;test-text-canvas&#x27;),    ctx = canvas.getContext(&#x27;2d&#x27;);ctx.fillStyle = &#x27;#fff&#x27;;ctx.fillRect(0, 0, 300, 100);ctx.shadowOffsetX = 2;ctx.shadowOffsetY = 2;ctx.shadowBlur = 2;ctx.shadowColor = &#x27;#ccc&#x27;;ctx.font = &#x27;28px Arial&#x27;;ctx.fillStyle = &#x27;#999&#x27;;ctx.fillText(&#x27;带阴影的文字&#x27;, 20, 40);\nCanvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常复杂的操作，考虑以下优化方案：\n\n通过创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中；\n尽量使用整数坐标而不是浮点数；\n可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图；\n背景图片如果不变可以直接用&lt;img&gt;标签并放到最底层。\n\n练习\n请根据天气API返回的JSON数据在Canvas上绘制未来天气预报，如下图所示：\n\n下载\n123456789101112131415let data = [    &#123; high: 35, low: 22 &#125;,    &#123; high: 37, low: 24 &#125;,    &#123; high: 37, low: 25 &#125;,    &#123; high: 34, low: 24 &#125;,    &#123; high: 33, low: 23 &#125;];let canvas = document.getElementById(&#x27;weather-canvas&#x27;);// TODO: 绘图// 400x200// 下载:let download = document.getElementById(&#x27;weather-download&#x27;);download.href = canvas.toDataURL();\n","dateCreated":"2025-05-26T21:31:30+08:00","dateModified":"2025-05-26T21:45:13+08:00","datePublished":"2025-05-26T21:31:30+08:00","description":"","headline":"JavaScript-浏览器","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E6%B5%8F%E8%A7%88%E5%99%A8/"},"publisher":{"@type":"Organization","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg","logo":{"@type":"ImageObject","url":"profile.jpg"}},"url":"https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E6%B5%8F%E8%A7%88%E5%99%A8/","keywords":"JavaScript, 前端"}</script>
    <meta name="description" content="JavaScript可以获取浏览器提供的很多对象，并进行操作。 window window对象不但充当全局作用域，而且表示浏览器窗口。 window对象有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。 兼容性：IE&lt;&#x3D;8不支持。 12&#x2F;&#x2F; 可以调整浏览器窗口大小试试:console">
<meta property="og:type" content="blog">
<meta property="og:title" content="JavaScript-浏览器">
<meta property="og:url" content="https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E6%B5%8F%E8%A7%88%E5%99%A8/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:description" content="JavaScript可以获取浏览器提供的很多对象，并进行操作。 window window对象不但充当全局作用域，而且表示浏览器窗口。 window对象有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。 兼容性：IE&lt;&#x3D;8不支持。 12&#x2F;&#x2F; 可以调整浏览器窗口大小试试:console">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/browser/canvas/weather.jpg">
<meta property="article:published_time" content="2025-05-26T13:31:30.000Z">
<meta property="article:modified_time" content="2025-05-26T13:45:13.922Z">
<meta property="article:author" content="Kein Chan">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liaoxuefeng.com/books/javascript/browser/canvas/weather.jpg">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../../../#about"
            >
        
        
            <img class="header-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            JavaScript-浏览器
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2025-05-26T21:31:30+08:00">
	
		    2025 年 5 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/">JavaScript</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>JavaScript可以获取浏览器提供的很多对象，并进行操作。</p>
<h3 id="window">window</h3>
<p><code>window</code>对象不但充当全局作用域，而且表示浏览器窗口。</p>
<p><code>window</code>对象有<code>innerWidth</code>和<code>innerHeight</code>属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。</p>
<p>兼容性：IE&lt;=8不支持。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 可以调整浏览器窗口大小试试:</span><br><span class="line">console.log(&#x27;window inner size: &#x27; + window.innerWidth + &#x27; x &#x27; + window.innerHeight);</span><br></pre></td></tr></table></figure>
<p>对应的，还有一个<code>outerWidth</code>和<code>outerHeight</code>属性，可以获取浏览器窗口的整个宽高。</p>
<h3 id="navigator">navigator</h3>
<p><code>navigator</code>对象表示浏览器的信息，最常用的属性包括：</p>
<ul>
<li>navigator.appName：浏览器名称；</li>
<li>navigator.appVersion：浏览器版本；</li>
<li>navigator.language：浏览器设置的语言；</li>
<li>navigator.platform：操作系统类型；</li>
<li>navigator.userAgent：浏览器设定的<code>User-Agent</code>字符串。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;appName = &#x27; + navigator.appName);</span><br><span class="line">console.log(&#x27;appVersion = &#x27; + navigator.appVersion);</span><br><span class="line">console.log(&#x27;language = &#x27; + navigator.language);</span><br><span class="line">console.log(&#x27;platform = &#x27; + navigator.platform);</span><br><span class="line">console.log(&#x27;userAgent = &#x27; + navigator.userAgent);</span><br></pre></td></tr></table></figure>
<p><em>请注意</em>，<code>navigator</code>的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。很多初学者为了针对不同浏览器编写不同的代码，喜欢用<code>if</code>判断浏览器版本，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> width;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">getIEVersion</span>(navigator.<span class="property">userAgent</span>) &lt; <span class="number">9</span>) &#123;</span><br><span class="line">    width = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    width = <span class="variable language_">window</span>.<span class="property">innerWidth</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这样既可能判断不准确，也很难维护代码。正确的方法是充分利用JavaScript对不存在属性返回<code>undefined</code>的特性，直接用短路运算符<code>||</code>计算：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> width = <span class="variable language_">window</span>.<span class="property">innerWidth</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>;</span><br></pre></td></tr></table></figure>
<h3 id="screen">screen</h3>
<p><code>screen</code>对象表示屏幕的信息，常用的属性有：</p>
<ul>
<li>screen.width：屏幕宽度，以像素为单位；</li>
<li>screen.height：屏幕高度，以像素为单位；</li>
<li>screen.colorDepth：返回颜色位数，如8、16、24。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;Screen size = &#x27; + screen.width + &#x27; x &#x27; + screen.height);</span><br></pre></td></tr></table></figure>
<h3 id="location">location</h3>
<p><code>location</code>对象表示当前页面的URL信息。例如，一个完整的URL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP</span><br></pre></td></tr></table></figure>
<p>可以用<code>location.href</code>获取。要获得URL各个部分的值，可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location.<span class="property">protocol</span>; <span class="comment">// &#x27;http&#x27;</span></span><br><span class="line">location.<span class="property">host</span>; <span class="comment">// &#x27;www.example.com&#x27;</span></span><br><span class="line">location.<span class="property">port</span>; <span class="comment">// &#x27;8080&#x27;</span></span><br><span class="line">location.<span class="property">pathname</span>; <span class="comment">// &#x27;/path/index.html&#x27;</span></span><br><span class="line">location.<span class="property">search</span>; <span class="comment">// &#x27;?a=1&amp;b=2&#x27;</span></span><br><span class="line">location.<span class="property">hash</span>; <span class="comment">// &#x27;TOP&#x27;</span></span><br></pre></td></tr></table></figure>
<p>要加载一个新页面，可以调用<code>location.assign()</code>。如果要重新加载当前页面，调用<code>location.reload()</code>方法非常方便。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (confirm(&#x27;重新加载当前页&#x27; + location.href + &#x27;?&#x27;)) &#123;</span><br><span class="line">    location.reload();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    location.assign(&#x27;/&#x27;); // 设置一个新的URL地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="document">document</h3>
<p><code>document</code>对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，<code>document</code>对象就是整个DOM树的根节点。</p>
<p><code>document</code>的<code>title</code>属性是从HTML文档中的<code>&lt;title&gt;xxx&lt;/title&gt;</code>读取的，但是可以动态改变：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.title = &#x27;努力学习JavaScript!&#x27;;</span><br></pre></td></tr></table></figure>
<p>请观察浏览器窗口标题的变化。</p>
<p>要查找DOM树的某个节点，需要从<code>document</code>对象开始查找。最常用的查找是根据ID和Tag Name。</p>
<p>我们先准备HTML数据：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span> <span class="attr">id</span>=<span class="string">&quot;drink-menu&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border:solid 1px #ccc;padding:6px;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>摩卡<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>热摩卡咖啡<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>酸奶<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>北京老酸奶<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>果汁<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>鲜榨苹果汁<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>摩卡</p>
<p>热摩卡咖啡</p>
<p>酸奶</p>
<p>北京老酸奶</p>
<p>果汁</p>
<p>鲜榨苹果汁</p>
<p>用<code>document</code>对象提供的<code>getElementById()</code>和<code>getElementsByTagName()</code>可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let menu = document.getElementById(&#x27;drink-menu&#x27;);</span><br><span class="line">let drinks = document.getElementsByTagName(&#x27;dt&#x27;);</span><br><span class="line">let s = &#x27;提供的饮料有:&#x27;;</span><br><span class="line"></span><br><span class="line">for (let i=0; i&lt;drinks.length; i++) &#123;</span><br><span class="line">    s = s + drinks[i].innerHTML + &#x27;,&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(s);</span><br></pre></td></tr></table></figure>
<p><code>document</code>对象还有一个<code>cookie</code>属性，可以获取当前页面的Cookie。</p>
<p>Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如<code>user=ABC123XYZ(加密的字符串)...</code>，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。</p>
<p>Cookie还可以存储网站的一些设置，例如，页面显示的语言等等。</p>
<p>JavaScript可以通过<code>document.cookie</code>读取到当前页面的Cookie：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span>; <span class="comment">// &#x27;v=123; remember=true; prefer=zh&#x27;</span></span><br></pre></td></tr></table></figure>
<p>由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患，这是因为在HTML页面中引入第三方的JavaScript代码是允许的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当前页面在wwwexample.com --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://www.foo.com/jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果引入的第三方的JavaScript中存在恶意代码，则<code>www.foo.com</code>网站将直接获取到<code>www.example.com</code>网站的用户登录信息。</p>
<p>为了解决这个问题，服务器在设置Cookie时可以使用<code>httpOnly</code>，设定了<code>httpOnly</code>的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持<code>httpOnly</code>选项，IE从IE6 SP1开始支持。</p>
<p>为了确保安全，服务器端在设置Cookie时，应该始终坚持使用<code>httpOnly</code>。</p>
<h3 id="history">history</h3>
<p><code>history</code>对象保存了浏览器的历史记录，JavaScript可以调用<code>history</code>对象的<code>back()</code>或<code>forward ()</code>，相当于用户点击了浏览器的“后退”或“前进”按钮。</p>
<p>这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用<code>history.back()</code>可能会让用户感到非常愤怒。</p>
<p>新手开始设计Web页面时喜欢在登录页登录成功时调用<code>history.back()</code>，试图回到登录前的页面。这是一种错误的方法。</p>
<p>对使用AJAX动态加载的页面，如果希望页面更新时同时更新<code>history</code>对象，应当使用<code>history.pushState()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// when AJAX is done:</span></span><br><span class="line"><span class="keyword">let</span> state = <span class="string">&#x27;any-data&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> newUrl = <span class="string">&#x27;/ajax.html#signin&#x27;</span>;</span><br><span class="line">history.<span class="title function_">pushState</span>(state, <span class="string">&#x27;&#x27;</span>, newUrl);</span><br></pre></td></tr></table></figure>
<p>当用户点击“后退”时，浏览器并不会刷新页面，而是触发<code>popstate</code>事件，可由JavaScript捕获并更新相应的部分页面内容。</p>
<h3 id="参考">参考</h3>
<p>常用浏览器对象参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/API/Window">Window</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/API/Navigator">Navigator</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/API/Screen">Screen</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/API/Location">Location</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/API/Document">Document</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/API/History_API">History</a></li>
</ul>
<h2 id="操作DOM">操作DOM</h2>
<p>由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。</p>
<p>始终记住DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作：</p>
<ul>
<li>更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容；</li>
<li>遍历：遍历该DOM节点下的子节点，以便进行进一步操作；</li>
<li>添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点；</li>
<li>删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。</li>
</ul>
<p>在操作一个DOM节点前，我们需要通过各种方式先拿到这个DOM节点。最常用的方法是<code>document.getElementById()</code>和<code>document.getElementsByTagName()</code>，以及CSS选择器<code>document.getElementsByClassName()</code>。</p>
<p>由于ID在HTML文档中是唯一的，所以<code>document.getElementById()</code>可以直接定位唯一的一个DOM节点。<code>document.getElementsByTagName()</code>和<code>document.getElementsByClassName()</code>总是返回一组DOM节点。要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回ID为&#x27;test&#x27;的节点：</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先定位ID为&#x27;test-table&#x27;的节点，再返回其内部所有tr节点：</span></span><br><span class="line"><span class="keyword">let</span> trs = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test-table&#x27;</span>).<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;tr&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先定位ID为&#x27;test-div&#x27;的节点，再返回其内部所有class包含red的节点：</span></span><br><span class="line"><span class="keyword">let</span> reds = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test-div&#x27;</span>).<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点test下的所有直属子节点:</span></span><br><span class="line"><span class="keyword">let</span> cs = test.<span class="property">children</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点test下第一个、最后一个子节点：</span></span><br><span class="line"><span class="keyword">let</span> first = test.<span class="property">firstElementChild</span>;</span><br><span class="line"><span class="keyword">let</span> last = test.<span class="property">lastElementChild</span>;</span><br></pre></td></tr></table></figure>
<p>第二种方法是使用<code>querySelector()</code>和<code>querySelectorAll()</code>，需要了解selector语法，然后使用条件来获取节点，更加方便：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过querySelector获取ID为q1的节点：</span></span><br><span class="line"><span class="keyword">let</span> q1 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#q1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过querySelectorAll获取q1节点内的符合条件的所有节点：</span></span><br><span class="line"><span class="keyword">let</span> ps = q1.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div.highlighted &gt; p&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>注意：低版本的IE&lt;8不支持<code>querySelector</code>和<code>querySelectorAll</code>。IE8仅有限支持。</p>
<p>严格地讲，我们这里的DOM节点是指<code>Element</code>，但是DOM节点实际上是<code>Node</code>，在HTML中，<code>Node</code>包括<code>Element</code>、<code>Comment</code>、<code>CDATA_SECTION</code>等很多种，以及根节点<code>Document</code>类型，但是，绝大多数时候我们只关心<code>Element</code>，也就是实际控制页面结构的<code>Node</code>，其他类型的<code>Node</code>忽略即可。根节点<code>Document</code>已经自动绑定为全局变量<code>document</code>。</p>
<h3 id="练习">练习</h3>
<p>如下的HTML结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test-div&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-red&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;test-p&quot;</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-red c-green&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Ruby<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-green&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Haskell<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>请选择出指定条件的节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 选择&lt;p&gt;JavaScript&lt;/p&gt;:</span><br><span class="line">let js = ???;</span><br><span class="line"></span><br><span class="line">// 选择&lt;p&gt;Python&lt;/p&gt;,&lt;p&gt;Ruby&lt;/p&gt;,&lt;p&gt;Swift&lt;/p&gt;:</span><br><span class="line">let arr = ???;</span><br><span class="line"></span><br><span class="line">// 选择&lt;p&gt;Haskell&lt;/p&gt;:</span><br><span class="line">let haskell = ???;</span><br><span class="line"></span><br><span class="line">// 测试:</span><br><span class="line">if (!js || js.innerText !== &#x27;JavaScript&#x27;) &#123;</span><br><span class="line">    alert(&#x27;选择JavaScript失败!&#x27;);</span><br><span class="line">&#125; else if (!arr || arr.length !== 3 || !arr[0] || !arr[1] || !arr[2] || arr[0].innerText !== &#x27;Python&#x27; || arr[1].innerText !== &#x27;Ruby&#x27; || arr[2].innerText !== &#x27;Swift&#x27;) &#123;</span><br><span class="line">    console.log(&#x27;选择Python,Ruby,Swift失败!&#x27;);</span><br><span class="line">&#125; else if (!haskell || haskell.innerText !== &#x27;Haskell&#x27;) &#123;</span><br><span class="line">    console.log(&#x27;选择Haskell失败!&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&#x27;测试通过!&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<h2 id="更新DOM">更新DOM</h2>
<p>拿到一个DOM节点后，我们可以对它进行更新。</p>
<p>可以直接修改节点的文本，方法有两种：</p>
<p>一种是修改<code>innerHTML</code>属性，这个方式非常强大，不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p-id&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置文本为abc:</span></span><br><span class="line">p.<span class="property">innerHTML</span> = <span class="string">&#x27;ABC&#x27;</span>; <span class="comment">// &lt;p id=&quot;p-id&quot;&gt;ABC&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// 设置HTML:</span></span><br><span class="line">p.<span class="property">innerHTML</span> = <span class="string">&#x27;ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ&#x27;</span>;</span><br><span class="line"><span class="comment">// &lt;p&gt;...&lt;/p&gt;的内部结构已修改</span></span><br></pre></td></tr></table></figure>
<p>用<code>innerHTML</code>时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到的，要注意对字符编码来避免XSS攻击。</p>
<p>第二种是修改<code>innerText</code>或<code>textContent</code>属性，这样可以自动对字符串进行HTML编码，保证无法设置任何HTML标签：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p-id&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置文本:</span></span><br><span class="line">p.<span class="property">innerText</span> = <span class="string">&#x27;&lt;script&gt;alert(&quot;Hi&quot;)&lt;/script&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">// HTML被自动编码，无法设置一个&lt;script&gt;节点:</span></span><br><span class="line"><span class="comment">// &lt;p id=&quot;p-id&quot;&gt;&amp;lt;script&amp;gt;alert(&quot;Hi&quot;)&amp;lt;/script&amp;gt;&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>
<p>两者的区别在于读取属性时，<code>innerText</code>不返回隐藏元素的文本，而<code>textContent</code>返回所有文本。另外注意IE&lt;9不支持<code>textContent</code>。</p>
<p>修改CSS也是经常需要的操作。DOM节点的<code>style</code>属性对应所有的CSS，可以直接获取或设置。因为CSS允许<code>font-size</code>这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名<code>fontSize</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p-id&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置CSS:</span></span><br><span class="line">p.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;#ff0000&#x27;</span>;</span><br><span class="line">p.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&#x27;20px&#x27;</span>;</span><br><span class="line">p.<span class="property">style</span>.<span class="property">paddingTop</span> = <span class="string">&#x27;2em&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="练习-2">练习</h3>
<p>有如下的HTML结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test-div&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;test-js&quot;</span>&gt;</span>javascript<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>请尝试获取指定节点并修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 获取&lt;p&gt;javascript&lt;/p&gt;节点:</span><br><span class="line">let js = ???;</span><br><span class="line"></span><br><span class="line">// 修改文本为JavaScript:</span><br><span class="line">// TODO:</span><br><span class="line"></span><br><span class="line">// 修改CSS为: color: #ff0000, font-weight: bold</span><br><span class="line">// TODO:</span><br><span class="line"></span><br><span class="line">// 测试:</span><br><span class="line">if (js &amp;&amp; js.parentNode &amp;&amp; js.parentNode.id === &#x27;test-div&#x27; &amp;&amp; js.id === &#x27;test-js&#x27;) &#123;</span><br><span class="line">    if (js.innerText === &#x27;JavaScript&#x27;) &#123;</span><br><span class="line">        if (js.style &amp;&amp; js.style.fontWeight === &#x27;bold&#x27; &amp;&amp; (js.style.color === &#x27;red&#x27; || js.style.color === &#x27;#ff0000&#x27; || js.style.color === &#x27;#f00&#x27; || js.style.color === &#x27;rgb(255, 0, 0)&#x27;)) &#123;</span><br><span class="line">            console.log(&#x27;测试通过!&#x27;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&#x27;CSS样式测试失败!&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&#x27;文本测试失败!&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&#x27;节点测试失败!&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<p>当我们获得了某个DOM节点，想在这个DOM节点内插入新的DOM，应该如何做？</p>
<p>如果这个DOM节点是空的，例如，<code>&lt;div&gt;&lt;/div&gt;</code>，那么，直接使用<code>innerHTML = '&lt;span&gt;child&lt;/span&gt;'</code>就可以修改DOM节点的内容，相当于“插入”了新的DOM节点。</p>
<p>如果这个DOM节点不是空的，那就不能这么做，因为<code>innerHTML</code>会直接替换掉原来的所有子节点。</p>
<p>有两个办法可以插入新的节点。一个是使用<code>appendChild</code>，把一个子节点添加到父节点的最后一个子节点。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;js&quot;</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;java&quot;</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;python&quot;</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;scheme&quot;</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>把<code>&lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;</code>添加到<code>&lt;div id=&quot;list&quot;&gt;</code>的最后一项：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span></span><br><span class="line">    js = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;js&#x27;</span>),</span><br><span class="line">    list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line">list.<span class="title function_">appendChild</span>(js);</span><br></pre></td></tr></table></figure>
<p>现在，HTML结构变成了这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;java&quot;</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;python&quot;</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;scheme&quot;</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;js&quot;</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为我们插入的<code>js</code>节点已经存在于当前的文档树，因此这个节点首先会从原先的位置删除，再插入到新的位置。</p>
<p>更多的时候我们会从零创建一个新的节点，然后插入到指定位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span></span><br><span class="line">    list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>),</span><br><span class="line">    haskell = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">haskell.<span class="property">id</span> = <span class="string">&#x27;haskell&#x27;</span>;</span><br><span class="line">haskell.<span class="property">innerText</span> = <span class="string">&#x27;Haskell&#x27;</span>;</span><br><span class="line">list.<span class="title function_">appendChild</span>(haskell);</span><br></pre></td></tr></table></figure>
<p>这样我们就动态添加了一个新的节点：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;java&quot;</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;python&quot;</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;scheme&quot;</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;haskell&quot;</span>&gt;</span>Haskell<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>动态创建一个节点然后添加到DOM树中，可以实现很多功能。举个例子，下面的代码动态创建了一个<code>&lt;style&gt;</code>节点，然后把它添加到<code>&lt;head&gt;</code>节点的末尾，这样就动态地给文档添加了新的CSS定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;style&#x27;</span>);</span><br><span class="line">d.<span class="title function_">setAttribute</span>(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text/css&#x27;</span>);</span><br><span class="line">d.<span class="property">innerHTML</span> = <span class="string">&#x27;p &#123; color: red &#125;&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(d);</span><br></pre></td></tr></table></figure>
<p>可以在Chrome的控制台执行上述代码，观察页面样式的变化。</p>
<h3 id="insertBefore">insertBefore</h3>
<p>如果我们要把子节点插入到指定的位置怎么办？可以使用<code>parentElement.insertBefore(newElement, referenceElement);</code>，子节点会插入到<code>referenceElement</code>之前。</p>
<p>还是以上面的HTML为例，假定我们要把<code>Haskell</code>插入到<code>Python</code>之前：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;java&quot;</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;python&quot;</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;scheme&quot;</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span></span><br><span class="line">    list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>),</span><br><span class="line">    ref = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;python&#x27;</span>),</span><br><span class="line">    haskell = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">haskell.<span class="property">id</span> = <span class="string">&#x27;haskell&#x27;</span>;</span><br><span class="line">haskell.<span class="property">innerText</span> = <span class="string">&#x27;Haskell&#x27;</span>;</span><br><span class="line">list.<span class="title function_">insertBefore</span>(haskell, ref);</span><br></pre></td></tr></table></figure>
<p>新的HTML结构如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;java&quot;</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;haskell&quot;</span>&gt;</span>Haskell<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;python&quot;</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;scheme&quot;</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可见，使用<code>insertBefore</code>重点是要拿到一个“参考子节点”的引用。很多时候，需要循环一个父节点的所有子节点，可以通过迭代<code>children</code>属性实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span></span><br><span class="line">    i, c,</span><br><span class="line">    list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; list.<span class="property">children</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    c = list.<span class="property">children</span>[i]; <span class="comment">// 拿到第i个子节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习-3">练习</h3>
<p>对于一个已有的HTML结构：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- HTML结构 --&gt;</span><br><span class="line">&lt;ol id=&quot;test-list&quot;&gt;</span><br><span class="line">    &lt;li class=&quot;lang&quot;&gt;Scheme&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;lang&quot;&gt;JavaScript&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;lang&quot;&gt;Python&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;lang&quot;&gt;Ruby&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;lang&quot;&gt;Haskell&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>Scheme</li>
<li>JavaScript</li>
<li>Python</li>
<li>Ruby</li>
<li>Haskell</li>
</ol>
<p>按字符串顺序重新排序DOM节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// sort list:</span><br><span class="line">TODO</span><br><span class="line"></span><br><span class="line">// 测试:</span><br><span class="line">(function () &#123;</span><br><span class="line">    let</span><br><span class="line">        arr, i,</span><br><span class="line">        t = document.getElementById(&#x27;test-list&#x27;);</span><br><span class="line">    if (t &amp;&amp; t.children &amp;&amp; t.children.length === 5) &#123;</span><br><span class="line">        arr = [];</span><br><span class="line">        for (i=0; i&lt;t.children.length; i++) &#123;</span><br><span class="line">            arr.push(t.children[i].innerText);</span><br><span class="line">        &#125;</span><br><span class="line">        if (arr.toString() === [&#x27;Haskell&#x27;, &#x27;JavaScript&#x27;, &#x27;Python&#x27;, &#x27;Ruby&#x27;, &#x27;Scheme&#x27;].toString()) &#123;</span><br><span class="line">            console.log(&#x27;测试通过!&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            console.log(&#x27;测试失败: &#x27; + arr.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        console.log(&#x27;测试失败!&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h2 id="删除DOM">删除DOM</h2>
<p>删除一个DOM节点就比插入要容易得多。</p>
<p>要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的<code>removeChild</code>把自己删掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到待删除节点:</span></span><br><span class="line"><span class="keyword">let</span> self = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;to-be-removed&#x27;</span>);</span><br><span class="line"><span class="comment">// 拿到父节点:</span></span><br><span class="line"><span class="keyword">let</span> parent = self.<span class="property">parentElement</span>;</span><br><span class="line"><span class="comment">// 删除:</span></span><br><span class="line"><span class="keyword">let</span> removed = parent.<span class="title function_">removeChild</span>(self);</span><br><span class="line">removed === self; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。</p>
<p>当你遍历一个父节点的子节点并进行删除操作时，要注意，<code>children</code>属性是一个只读属性，并且它在子节点变化时会实时更新。</p>
<p>例如，对于如下HTML结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>First<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Second<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当我们用如下代码删除子节点时：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parent = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;parent&#x27;</span>);</span><br><span class="line">parent.<span class="title function_">removeChild</span>(parent.<span class="property">children</span>[<span class="number">0</span>]);</span><br><span class="line">parent.<span class="title function_">removeChild</span>(parent.<span class="property">children</span>[<span class="number">1</span>]); <span class="comment">// &lt;-- 浏览器报错</span></span><br></pre></td></tr></table></figure>
<p>浏览器报错：<code>parent.children[1]</code>不是一个有效的节点。原因就在于，当<code>&lt;p&gt;First&lt;/p&gt;</code>节点被删除后，<code>parent.children</code>的节点数量已经从2变为了1，索引<code>[1]</code>已经不存在了。</p>
<p>因此，删除多个节点时，要注意<code>children</code>属性时刻都在变化。</p>
<h3 id="练习-4">练习</h3>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;test-list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>ANSI C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>CSS<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>DirectX<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>JavaScript</li>
<li>Swift</li>
<li>HTML</li>
<li>ANSI C</li>
<li>CSS</li>
<li>DirectX</li>
</ul>
<p>把与Web开发技术不相关的节点删掉：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// TODO</span><br><span class="line"></span><br><span class="line">// 测试:</span><br><span class="line">(function () &#123;</span><br><span class="line">    let</span><br><span class="line">        arr, i,</span><br><span class="line">        t = document.getElementById(&#x27;test-list&#x27;);</span><br><span class="line">    if (t &amp;&amp; t.children &amp;&amp; t.children.length === 3) &#123;</span><br><span class="line">        arr = [];</span><br><span class="line">        for (i = 0; i &lt; t.children.length; i ++) &#123;</span><br><span class="line">            arr.push(t.children[i].innerText);</span><br><span class="line">        &#125;</span><br><span class="line">        if (arr.toString() === [&#x27;JavaScript&#x27;, &#x27;HTML&#x27;, &#x27;CSS&#x27;].toString()) &#123;</span><br><span class="line">            console.log(&#x27;测试通过!&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            console.log(&#x27;测试失败: &#x27; + arr.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        console.log(&#x27;测试失败!&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<p>用JavaScript操作表单和操作DOM是类似的，因为表单本身也是DOM树。</p>
<p>不过表单的输入框、下拉框等可以接收用户输入，所以用JavaScript来操作表单，可以获得用户输入的内容，或者对一个输入框设置新的内容。</p>
<p>HTML表单的输入控件主要有以下几种：</p>
<ul>
<li>文本框，对应的<code>&lt;input type=&quot;text&quot;&gt;</code>，用于输入文本；</li>
<li>口令框，对应的<code>&lt;input type=&quot;password&quot;&gt;</code>，用于输入口令；</li>
<li>单选框，对应的<code>&lt;input type=&quot;radio&quot;&gt;</code>，用于选择一项；</li>
<li>复选框，对应的<code>&lt;input type=&quot;checkbox&quot;&gt;</code>，用于选择多项；</li>
<li>下拉框，对应的<code>&lt;select&gt;</code>，用于选择一项；</li>
<li>隐藏文本，对应的<code>&lt;input type=&quot;hidden&quot;&gt;</code>，用户不可见，但表单提交时会把隐藏文本发送到服务器。</li>
</ul>
<h3 id="获取值">获取值</h3>
<p>如果我们获得了一个<code>&lt;input&gt;</code>节点的引用，就可以直接调用<code>value</code>获得对应的用户输入值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;input type=&quot;text&quot; id=&quot;email&quot;&gt;</span></span><br><span class="line"><span class="keyword">let</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;email&#x27;</span>);</span><br><span class="line">input.<span class="property">value</span>; <span class="comment">// &#x27;用户输入的值&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这种方式可以应用于<code>text</code>、<code>password</code>、<code>hidden</code>以及<code>select</code>。但是，对于单选框和复选框，<code>value</code>属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用<code>checked</code>判断：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;monday&quot; value=&quot;1&quot;&gt; Monday&lt;/label&gt;</span></span><br><span class="line"><span class="comment">// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;tuesday&quot; value=&quot;2&quot;&gt; Tuesday&lt;/label&gt;</span></span><br><span class="line"><span class="keyword">let</span> mon = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;monday&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> tue = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;tuesday&#x27;</span>);</span><br><span class="line">mon.<span class="property">value</span>; <span class="comment">// &#x27;1&#x27;</span></span><br><span class="line">tue.<span class="property">value</span>; <span class="comment">// &#x27;2&#x27;</span></span><br><span class="line">mon.<span class="property">checked</span>; <span class="comment">// true或者false</span></span><br><span class="line">tue.<span class="property">checked</span>; <span class="comment">// true或者false</span></span><br></pre></td></tr></table></figure>
<h3 id="设置值">设置值</h3>
<p>设置值和获取值类似，对于<code>text</code>、<code>password</code>、<code>hidden</code>以及<code>select</code>，直接设置<code>value</code>就可以：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;input type=&quot;text&quot; id=&quot;email&quot;&gt;</span></span><br><span class="line"><span class="keyword">let</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;email&#x27;</span>);</span><br><span class="line">input.<span class="property">value</span> = <span class="string">&#x27;test@example.com&#x27;</span>; <span class="comment">// 文本框的内容已更新</span></span><br></pre></td></tr></table></figure>
<p>对于单选框和复选框，设置<code>checked</code>为<code>true</code>或<code>false</code>即可。</p>
<h3 id="HTML5控件">HTML5控件</h3>
<p>HTML5新增了大量标准控件，常用的包括<code>date</code>、<code>datetime</code>、<code>datetime-local</code>、<code>color</code>等，它们都使用<code>&lt;input&gt;</code>标签：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2021-12-02&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;datetime-local&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2021-12-02T20:21:12&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;color&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#ff0000&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不支持HTML5的浏览器无法识别新的控件，会把它们当做<code>type=&quot;text&quot;</code>来显示。支持HTML5的浏览器将获得格式化的字符串。例如，<code>type=&quot;date&quot;</code>类型的<code>input</code>的<code>value</code>将保证是一个有效的<code>YYYY-MM-DD</code>格式的日期，或者空字符串。</p>
<h3 id="提交表单">提交表单</h3>
<p>最后，JavaScript可以以两种方式来处理表单的提交（AJAX方式在后面章节介绍）。</p>
<p>方式一是通过<code>&lt;form&gt;</code>元素的<code>submit()</code>方法提交一个表单，例如，响应一个<code>&lt;button&gt;</code>的<code>click</code>事件，在JavaScript代码中提交表单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;test-form&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;doSubmitForm()&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">doSubmitForm</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test-form&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 可以在此修改form的input...</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 提交form:</span></span></span><br><span class="line"><span class="language-javascript">    form.<span class="title function_">submit</span>();</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种方式的缺点是扰乱了浏览器对form的正常提交。浏览器默认点击<code>&lt;button type=&quot;submit&quot;&gt;</code>时提交表单，或者用户在最后一个输入框按回车键。因此，第二种方式是响应<code>&lt;form&gt;</code>本身的<code>onsubmit</code>事件，在提交form时作修改：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;test-form&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return checkForm()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">checkForm</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test-form&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 可以在此修改form的input...</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 继续下一步:</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意要<code>return true</code>来告诉浏览器继续提交，如果<code>return false</code>，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。</p>
<p>在检查和修改<code>&lt;input&gt;</code>时，要充分利用<code>&lt;input type=&quot;hidden&quot;&gt;</code>来传递数据。</p>
<p>例如，很多登录表单希望用户输入用户名和口令，但是，安全考虑，提交表单时不传输明文口令，而是口令的MD5。普通JavaScript开发人员会直接修改<code>&lt;input&gt;</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;login-form&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return checkForm()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">checkForm</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> pwd = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;password&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 把用户输入的明文变为MD5:</span></span></span><br><span class="line"><span class="language-javascript">    pwd.<span class="property">value</span> = <span class="title function_">toMD5</span>(pwd.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 继续下一步:</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个做法看上去没啥问题，但用户输入了口令提交时，口令框的显示会突然从几个<code>*</code>变成32个<code>*</code>（因为MD5有32个字符）。</p>
<p>要想不改变用户的输入，可以利用<code>&lt;input type=&quot;hidden&quot;&gt;</code>实现：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;login-form&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return checkForm()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input-password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">id</span>=<span class="string">&quot;md5-password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">checkForm</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> input_pwd = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;input-password&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> md5_pwd = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;md5-password&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 把用户输入的明文变为MD5:</span></span></span><br><span class="line"><span class="language-javascript">    md5_pwd.<span class="property">value</span> = <span class="title function_">toMD5</span>(input_pwd.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 继续下一步:</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意到<code>id</code>为<code>md5-password</code>的<code>&lt;input&gt;</code>标记了<code>name=&quot;password&quot;</code>，而用户输入的<code>id</code>为<code>input-password</code>的<code>&lt;input&gt;</code>没有<code>name</code>属性。没有<code>name</code>属性的<code>&lt;input&gt;</code>的数据不会被提交。</p>
<h3 id="练习-5">练习</h3>
<p>利用JavaScript检查用户注册信息是否正确，在以下情况不满足时报错并阻止提交表单：</p>
<ul>
<li>用户名必须是3-10位英文字母或数字；</li>
<li>口令必须是6-20位；</li>
<li>两次输入口令必须一致。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;test-register&quot;</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return checkRegisterForm()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;test-error&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        用户名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        口令: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        重复口令: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password-2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">window.checkRegisterForm = function () &#123;</span><br><span class="line">    // TODO:</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 测试:</span><br><span class="line">(function () &#123;</span><br><span class="line">    window.testFormHandler = window.checkRegisterForm;</span><br><span class="line">    let form = document.getElementById(&#x27;test-register&#x27;);</span><br><span class="line">    if (form.dispatchEvent) &#123;</span><br><span class="line">        let event = new Event(&#x27;submit&#x27;, &#123;</span><br><span class="line">    		bubbles: true,</span><br><span class="line">    		cancelable: true</span><br><span class="line">  		&#125;);</span><br><span class="line">        form.dispatchEvent(event);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        form.fireEvent(&#x27;onsubmit&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>在HTML表单中，可以上传文件的唯一控件就是<code>&lt;input type=&quot;file&quot;&gt;</code>。</p>
<p><em>注意</em>：当一个表单包含<code>&lt;input type=&quot;file&quot;&gt;</code>时，表单的<code>enctype</code>必须指定为<code>multipart/form-data</code>，<code>method</code>必须指定为<code>post</code>，浏览器才能正确编码并以<code>multipart/form-data</code>格式发送表单的数据。</p>
<p>出于安全考虑，浏览器只允许用户点击<code>&lt;input type=&quot;file&quot;&gt;</code>来选择本地文件，用JavaScript对<code>&lt;input type=&quot;file&quot;&gt;</code>的<code>value</code>赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径：</p>
<p>通常，上传的文件都由后台服务器处理，JavaScript可以在提交表单时对文件扩展名做检查，以便防止用户上传无效格式的文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test-file-upload&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> filename = f.<span class="property">value</span>; <span class="comment">// &#x27;C:\fakepath\test.png&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (!filename || !(filename.<span class="title function_">endsWith</span>(<span class="string">&#x27;.jpg&#x27;</span>) || filename.<span class="title function_">endsWith</span>(<span class="string">&#x27;.png&#x27;</span>) || filename.<span class="title function_">endsWith</span>(<span class="string">&#x27;.gif&#x27;</span>))) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Can only upload image file.&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="File-API">File API</h3>
<p>由于JavaScript对用户上传的文件操作非常有限，尤其是无法读取文件内容，使得很多需要操作文件的网页不得不用Flash这样的第三方插件来实现。</p>
<p>随着HTML5的普及，新增的File API允许JavaScript读取文件内容，获得更多的文件信息。</p>
<p>HTML5的File API提供了<code>File</code>和<code>FileReader</code>两个主要对象，可以获得文件信息并读取文件。</p>
<p>下面的例子演示了如何读取用户选取的图片文件，并在一个<code>&lt;div&gt;</code>中预览图像：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span></span><br><span class="line">    fileInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test-image-file&#x27;</span>),</span><br><span class="line">    info = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test-file-info&#x27;</span>),</span><br><span class="line">    preview = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test-image-preview&#x27;</span>);</span><br><span class="line"><span class="comment">// 监听change事件:</span></span><br><span class="line">fileInput.<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 清除背景图片:</span></span><br><span class="line">    preview.<span class="property">style</span>.<span class="property">backgroundImage</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 检查文件是否选择:</span></span><br><span class="line">    <span class="keyword">if</span> (!fileInput.<span class="property">value</span>) &#123;</span><br><span class="line">        info.<span class="property">innerHTML</span> = <span class="string">&#x27;没有选择文件&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取File引用:</span></span><br><span class="line">    <span class="keyword">let</span> file = fileInput.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 获取File信息:</span></span><br><span class="line">    info.<span class="property">innerHTML</span> = <span class="string">&#x27;文件: &#x27;</span> + file.<span class="property">name</span> + <span class="string">&#x27;&lt;br&gt;&#x27;</span> +</span><br><span class="line">                     <span class="string">&#x27;大小: &#x27;</span> + file.<span class="property">size</span> + <span class="string">&#x27;&lt;br&gt;&#x27;</span> +</span><br><span class="line">                     <span class="string">&#x27;修改: &#x27;</span> + file.<span class="property">lastModified</span>;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="property">type</span> !== <span class="string">&#x27;image/jpeg&#x27;</span> &amp;&amp; file.<span class="property">type</span> !== <span class="string">&#x27;image/png&#x27;</span> &amp;&amp; file.<span class="property">type</span> !== <span class="string">&#x27;image/gif&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;不是有效的图片文件!&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取文件:</span></span><br><span class="line">    <span class="keyword">let</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">    reader.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span></span><br><span class="line">            data = e.<span class="property">target</span>.<span class="property">result</span>; <span class="comment">// &#x27;data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...&#x27;            </span></span><br><span class="line">        preview.<span class="property">style</span>.<span class="property">backgroundImage</span> = <span class="string">&#x27;url(&#x27;</span> + data + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 以DataURL的形式读取文件:</span></span><br><span class="line">    reader.<span class="title function_">readAsDataURL</span>(file);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码演示了如何通过HTML5的File API读取文件内容。以DataURL的形式读取到的文件是一个字符串，类似于<code>data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...</code>，常用于设置图像。如果需要服务器端处理，把字符串<code>base64,</code>后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。</p>
<h3 id="回调">回调</h3>
<p>上面的代码还演示了JavaScript的一个重要的特性就是单线程执行模式。在JavaScript中，浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行，也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行。</p>
<p>你可能会问，单线程模式执行的JavaScript，如何处理多任务？</p>
<p>在JavaScript中，执行多任务实际上都是异步调用，比如上面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reader.<span class="title function_">readAsDataURL</span>(file);</span><br></pre></td></tr></table></figure>
<p>就会发起一个异步操作来读取文件内容。因为是异步操作，所以我们在JavaScript代码中就不知道什么时候操作结束，因此需要先设置一个回调函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reader.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// 当文件读取完成后，自动调用此函数:</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当文件读取完成后，JavaScript引擎将自动调用我们设置的回调函数。执行回调函数时，文件已经读取完毕，所以我们可以在回调函数内部安全地获得文件内容。</p>
<p>AJAX不是JavaScript的规范，它只是一个哥们“发明”的缩写：Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求。</p>
<p>如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。</p>
<p>这就是Web的运作原理：一次HTTP请求对应一个页面。</p>
<p>如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。</p>
<p>最早大规模使用AJAX的就是Gmail，Gmail的页面在首次加载后，剩下的所有数据都依赖于AJAX来更新。</p>
<p>用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。</p>
<p>在现代浏览器上写AJAX主要依靠<code>XMLHttpRequest</code>对象，如果不考虑早期浏览器的兼容性问题，现代浏览器还提供了原生支持的Fetch API，以<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/browser/promise/index.html">Promise</a>方式提供。使用Fetch API发送HTTP请求代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function get(url) &#123;</span><br><span class="line">    let resp = await fetch(url);</span><br><span class="line">    let result = await resp.text();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 发送异步请求:</span><br><span class="line">get(&#x27;./content.html&#x27;).then(data =&gt; &#123;</span><br><span class="line">    let textarea = document.getElementById(&#x27;fetch-response-text&#x27;);</span><br><span class="line">    textarea.value = data;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用Fetch API配合<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/browser/async/index.html">async</a>写法，代码更加简单。</p>
<p>Fetch API的详细用法可以参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/API/Fetch_API">MDN文档</a>。</p>
<h3 id="安全限制">安全限制</h3>
<p>上面代码的URL使用的是相对路径。如果你把它改为<code>'https://www.sina.com.cn/'</code>，再运行，肯定报错。在Chrome的控制台里，还可以看到错误信息。</p>
<p>这是因为浏览器的同源策略导致的。默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致。</p>
<p>完全一致的意思是，域名要相同（<code>www.example.com</code>和<code>example.com</code>不同），协议要相同（<code>http</code>和<code>https</code>不同），端口号要相同（http默认是<code>:80</code>端口，它和<code>:8080</code>就不同）。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。</p>
<p>那是不是用JavaScript无法请求外域（就是其他网站）的URL了呢？方法还是有的，大概有这么几种：</p>
<p>一是通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，而且现在用得也越来越少了。</p>
<p>二是通过在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;/proxy?url=https://www.sina.com.cn&#x27;</span><br></pre></td></tr></table></figure>
<p>代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发。</p>
<p>第三种方式称为JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://example.com/abc.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>JSONP通常以函数调用的形式返回，例如，返回JavaScript内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>(<span class="string">&#x27;data&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>这样一来，我们如果在页面中先准备好<code>foo()</code>函数，然后给页面动态加一个<code>&lt;script&gt;</code>节点，相当于动态读取外域的JavaScript资源，最后就等着接收回调了。</p>
<h3 id="CORS">CORS</h3>
<p>如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：CORS了。</p>
<p>CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。</p>
<p>了解CORS前，我们先搞明白概念：</p>
<p>Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（<a target="_blank" rel="noopener" href="http://xn--sina-f96g.com">如sina.com</a>）发起请求后，浏览器收到响应后，首先检查<code>Access-Control-Allow-Origin</code>是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。</p>
<p>用一个图来表示就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">         GET /res/abc.data</span><br><span class="line">         Host: sina.com</span><br><span class="line">┌──────┐ Origin: http://my.com                      ┌────────┐</span><br><span class="line">│my.com│───────────────────────────────────────────▶│sina.com│</span><br><span class="line">│      │◀───────────────────────────────────────────│        │</span><br><span class="line">└──────┘ HTTP/1.1 200 OK                            └────────┘</span><br><span class="line">         Access-Control-Allow-Origin: http://my.com</span><br><span class="line">         Content-Type: text/xml</span><br><span class="line"></span><br><span class="line">         &lt;xml data...&gt;</span><br></pre></td></tr></table></figure>
<p>假设本域是<code>my.com</code>，外域是<code>sina.com</code>，只要响应头<code>Access-Control-Allow-Origin</code>为<code>http://my.com</code>，或者是<code>*</code>，本次请求就可以成功。</p>
<p>可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的<code>Access-Control-Allow-Origin</code>，决定权始终在对方手中。</p>
<p>上面这种跨域请求，称之为“简单请求”。简单请求包括GET、HEAD和POST（POST的Content-Type类型 仅限<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>和<code>text/plain</code>），并且不能出现任何自定义头（例如，<code>X-Custom: 12345</code>），通常能满足90%的需求。</p>
<p>无论你是否需要用JavaScript通过CORS跨域请求资源，你都要了解CORS的原理。最新的浏览器全面支持HTML5。在引用外域资源时，除了JavaScript和CSS外，都要验证CORS。例如，当你引用了某个第三方CDN上的字体文件时：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CSS */</span></span><br><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;FontAwesome&#x27;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;http://cdn.com/fonts/fontawesome.ttf&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果该CDN服务商未正确设置<code>Access-Control-Allow-Origin</code>，那么浏览器无法加载字体资源。</p>
<p>对于PUT、DELETE以及其他类型如<code>application/json</code>的POST请求，在发送AJAX请求之前，浏览器会先发送一个<code>OPTIONS</code>请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /path/to/resource HTTP/1.1</span><br><span class="line">Host: bar.com</span><br><span class="line">Origin: http://my.com</span><br><span class="line">Access-Control-Request-Method: POST</span><br></pre></td></tr></table></figure>
<p>服务器必须响应并明确指出允许的Method：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Access-Control-Allow-Origin: http://my.com</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, PUT, OPTIONS</span><br><span class="line">Access-Control-Max-Age: 86400</span><br></pre></td></tr></table></figure>
<p>浏览器确认服务器响应的<code>Access-Control-Allow-Methods</code>头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。</p>
<p>由于以<code>POST</code>、<code>PUT</code>方式传送JSON格式的数据在REST中很常见，所以要跨域正确处理<code>POST</code>和<code>PUT</code>请求，服务器端必须正确响应<code>OPTIONS</code>请求。</p>
<p>需要深入了解CORS的童鞋请移步<a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/HTTP/CORS">MDN文档</a>和<a target="_blank" rel="noopener" href="http://www.w3.org/TR/cors/">W3C文档</a>。</p>
<p>在JavaScript的世界中，所有代码都是单线程执行的。</p>
<p>由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Done&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;before setTimeout()&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(callback, <span class="number">1000</span>); <span class="comment">// 1秒钟后调用callback函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after setTimeout()&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>观察上述代码执行，在Chrome的控制台输出可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before setTimeout()</span><br><span class="line">after setTimeout()</span><br><span class="line">(等待1秒后)</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>
<p>可见，异步操作会在将来的某个时间点触发一个函数调用。</p>
<p>AJAX就是典型的异步操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">success</span>(request.<span class="property">responseText</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">fail</span>(request.<span class="property">status</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把回调函数<code>success(request.responseText)</code>和<code>fail(request.status)</code>写到一个AJAX操作里很正常，但是不好看，而且不利于代码复用。</p>
<p>有没有更好的写法？比如写成这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ajax = <span class="title function_">ajaxGet</span>(<span class="string">&#x27;http://...&#x27;</span>);</span><br><span class="line">ajax.<span class="title function_">ifSuccess</span>(success)</span><br><span class="line">    .<span class="title function_">ifFail</span>(fail);</span><br></pre></td></tr></table></figure>
<p>这种链式写法的好处在于，先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败，在将来的某个时候调用<code>success</code>函数或<code>fail</code>函数。</p>
<p>古人云：“君子一诺千金”，这种“承诺将来会执行”的对象在JavaScript中称为Promise对象。</p>
<p>Promise有各种开源实现，在ES6中被统一规范，由浏览器直接支持。先测试一下你的浏览器是否支持Promise：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function () &#123;&#125;);</span><br><span class="line"></span><br><span class="line">// 直接运行测试:</span><br><span class="line">console.log(&#x27;支持Promise!&#x27;);</span><br></pre></td></tr></table></figure>
<p>我们先看一个最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeOut = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2</span>;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;set timeout to: &#x27;</span> + timeOut + <span class="string">&#x27; seconds.&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeOut &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="title function_">log</span>(<span class="string">&#x27;call resolve()...&#x27;</span>);</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;200 OK&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">log</span>(<span class="string">&#x27;call reject()...&#x27;</span>);</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&#x27;timeout in &#x27;</span> + timeOut + <span class="string">&#x27; seconds.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, timeOut * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>test()</code>函数有两个参数，这两个参数都是函数，如果执行成功，我们将调用<code>resolve('200 OK')</code>，如果执行失败，我们将调用<code>reject('timeout in ' + timeOut + ' seconds.')</code>。可以看出，<code>test()</code>函数只关心自身的逻辑，并不关心具体的<code>resolve</code>和<code>reject</code>将如何处理结果。</p>
<p>有了执行函数，我们就可以用一个Promise对象来执行它，并在将来某个时刻获得成功或失败的结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(test);</span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功：&#x27;</span> + result);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p3 = p2.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败：&#x27;</span> + reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>变量<code>p1</code>是一个Promise对象，它负责执行<code>test</code>函数。由于<code>test</code>函数在内部是异步执行的，当<code>test</code>函数执行成功时，我们告诉Promise对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果成功，执行这个函数：</span></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功：&#x27;</span> + result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当<code>test</code>函数执行失败时，我们告诉Promise对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p2.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败：&#x27;</span> + reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Promise对象可以串联起来，所以上述代码可以简化为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(test).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功：&#x27;</span> + result);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败：&#x27;</span> + reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>实际测试一下，看看Promise是如何异步执行的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 清除log:</span><br><span class="line">let logging = document.getElementById(&#x27;test-promise-log&#x27;);</span><br><span class="line">while (logging.children.length &gt; 1) &#123;</span><br><span class="line">    logging.removeChild(logging.children[logging.children.length - 1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出log到页面:</span><br><span class="line">function log(s) &#123;</span><br><span class="line">    let p = document.createElement(&#x27;p&#x27;);</span><br><span class="line">    p.innerHTML = s;</span><br><span class="line">    logging.appendChild(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve, reject) &#123;</span><br><span class="line">    log(&#x27;start new Promise...&#x27;);</span><br><span class="line">    let timeOut = Math.random() * 2;</span><br><span class="line">    log(&#x27;set timeout to: &#x27; + timeOut + &#x27; seconds.&#x27;);</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        if (timeOut &lt; 1) &#123;</span><br><span class="line">            log(&#x27;call resolve()...&#x27;);</span><br><span class="line">            resolve(&#x27;200 OK&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            log(&#x27;call reject()...&#x27;);</span><br><span class="line">            reject(&#x27;timeout in &#x27; + timeOut + &#x27; seconds.&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, timeOut * 1000);</span><br><span class="line">&#125;).then(function (r) &#123;</span><br><span class="line">    log(&#x27;Done: &#x27; + r);</span><br><span class="line">&#125;).catch(function (reason) &#123;</span><br><span class="line">    log(&#x27;Failed: &#x27; + reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Log:</p>
<p>可见Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">                                   ┌──────────────────┐</span><br><span class="line">                           then    │on_resolve(data) &#123;│</span><br><span class="line">                       ┌──────────▶│    // TODO       │</span><br><span class="line">                       │           │&#125;                 │</span><br><span class="line">┌────────────────────────┐         └──────────────────┘</span><br><span class="line">│   new Promise(async)   │</span><br><span class="line">└────────────────────────┘         ┌──────────────────┐</span><br><span class="line">             │         │           │on_reject(data) &#123; │</span><br><span class="line">             │         └──────────▶│    // TODO       │</span><br><span class="line">      promise│             catch   │&#125;                 │</span><br><span class="line">             │                     └──────────────────┘</span><br><span class="line">             ▼</span><br><span class="line">┌────────────────────────┐</span><br><span class="line">│async(resolve, reject) &#123;│</span><br><span class="line">│    // TODO             │</span><br><span class="line">│&#125;                       │</span><br><span class="line">└────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>Promise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。</p>
<p>要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">job1.<span class="title function_">then</span>(job2).<span class="title function_">then</span>(job3).<span class="title function_">catch</span>(handleError);</span><br></pre></td></tr></table></figure>
<p>其中，<code>job1</code>、<code>job2</code>和<code>job3</code>都是Promise对象。</p>
<p>下面的例子演示了如何串行执行一系列需要异步计算获得结果的任务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">let logging = document.getElementById(&#x27;test-promise2-log&#x27;);</span><br><span class="line">while (logging.children.length &gt; 1) &#123;</span><br><span class="line">    logging.removeChild(logging.children[logging.children.length - 1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function log(s) &#123;</span><br><span class="line">    let p = document.createElement(&#x27;p&#x27;);</span><br><span class="line">    p.innerHTML = s;</span><br><span class="line">    logging.appendChild(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 0.5秒后返回input*input的计算结果:</span><br><span class="line">function multiply(input) &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        log(&#x27;calculating &#x27; + input + &#x27; x &#x27; + input + &#x27;...&#x27;);</span><br><span class="line">        setTimeout(resolve, 500, input * input);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 0.5秒后返回input+input的计算结果:</span><br><span class="line">function add(input) &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        log(&#x27;calculating &#x27; + input + &#x27; + &#x27; + input + &#x27;...&#x27;);</span><br><span class="line">        setTimeout(resolve, 500, input + input);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = new Promise(function (resolve, reject) &#123;</span><br><span class="line">    log(&#x27;start new Promise...&#x27;);</span><br><span class="line">    resolve(123);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(multiply)</span><br><span class="line"> .then(add)</span><br><span class="line"> .then(multiply)</span><br><span class="line"> .then(add)</span><br><span class="line"> .then(function (result) &#123;</span><br><span class="line">    log(&#x27;Got value: &#x27; + result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Log:</p>
<p><code>setTimeout</code>可以看成一个模拟网络等异步执行的函数。</p>
<p>除了串行执行若干异步任务外，Promise还可以并行执行异步任务。</p>
<p>试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用<code>Promise.all()</code>实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, <span class="string">&#x27;P1&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">600</span>, <span class="string">&#x27;P2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 同时执行p1和p2，并在它们都完成后执行then:</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2]).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results); <span class="comment">// 获得一个Array: [&#x27;P1&#x27;, &#x27;P2&#x27;]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用<code>Promise.race()</code>实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, <span class="string">&#x27;P1&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">600</span>, <span class="string">&#x27;P2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2]).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &#x27;P1&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>由于<code>p1</code>执行较快，Promise的<code>then()</code>将获得结果<code>'P1'</code>。<code>p2</code>仍在继续执行，但执行结果将被丢弃。</p>
<p>如果我们组合使用Promise，就可以把很多异步任务以并行和串行的方式组合起来执行。</p>
<p>我们说JavaScript异步操作需要通过Promise实现，一个Promise对象在操作网络时是异步的，等到返回后再调用回调函数，执行正确就调用<code>then()</code>，执行错误就调用<code>catch()</code>，虽然异步实现了，不会让用户感觉到页面“卡住”了，但是一堆<code>then()</code>、<code>catch()</code>写起来麻烦看起来也乱。</p>
<p>有没有更简单的写法？</p>
<p>可以用关键字<code>async</code>配合<code>await</code>调用Promise，实现异步操作，但代码却和同步写法类似：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> resp = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> resp.<span class="title function_">json</span>();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>async function</code>可以定义一个异步函数，异步函数和Promise可以看作是等价的，在async function内部，用<code>await</code>调用另一个异步函数，写起来和同步代码没啥区别，但执行起来是异步的。</p>
<p>也就是说：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> resp = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br></pre></td></tr></table></figure>
<p>自动实现了异步调用，它和下面的Promise代码等价：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="title function_">fetch</span>(url);</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">resp</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到resp</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果我们要实现<code>catch()</code>怎么办？用Promise的写法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="title function_">fetch</span>(url);</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">resp</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到resp</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 出错了</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>用<code>await</code>调用时，直接用传统的<code>try &#123; ... &#125; catch</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> resp = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> resp.<span class="title function_">json</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// 出错了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用async定义异步函数，用await调用异步函数，写起来和同步代码差不多，但可读性大大提高。</p>
<p>需要特别注意的是，<code>await</code>调用必须在async function中，不能在传统的同步代码中调用。那么问题来了，一个同步function怎么调用async function呢？</p>
<p>首先，普通function直接用await调用异步函数将报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function get(url) &#123;</span><br><span class="line">    let resp = await fetch(url);</span><br><span class="line">    return resp.json();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function doGet() &#123;</span><br><span class="line">    let data = await get(&#x27;/api/categories&#x27;);</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doGet();</span><br></pre></td></tr></table></figure>
<p>如果把<code>await</code>去掉，调用实际上发生了，但我们拿不到结果，因为我们拿到的并不是异步结果，而是一个Promise对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function get(url) &#123;</span><br><span class="line">    let resp = await fetch(url);</span><br><span class="line">    let result = await resp.text();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function doGet() &#123;</span><br><span class="line">    let promise = get(&#x27;./content.html&#x27;);</span><br><span class="line">    console.log(promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doGet();</span><br></pre></td></tr></table></figure>
<p>因此，在普通function中调用async function，不能使用await，但可以直接调用async function拿到Promise对象，后面加上<code>then()</code>和<code>catch()</code>就可以拿到结果或错误了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">async function get(url) &#123;</span><br><span class="line">    let resp = await fetch(url);</span><br><span class="line">    let result = await resp.text();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function doGet() &#123;</span><br><span class="line">    let promise = get(&#x27;./content.html&#x27;);</span><br><span class="line">    promise.then(data =&gt; &#123;</span><br><span class="line">        // 拿到data</span><br><span class="line">        document.getElementById(&#x27;test-response-text&#x27;).value = JSON.stringify(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doGet();</span><br></pre></td></tr></table></figure>
<p>因此，定义异步任务时，使用async function比Promise简单，调用异步任务时，使用await比Promise简单，捕获错误时，按传统的<code>try...catch</code>写法，也比Promise简单。只要浏览器支持，完全可以用<code>async</code>简洁地实现异步操作。</p>
<p>Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。</p>
<p>没有Canvas的年代，绘图只能借助Flash插件实现，页面不得不用JavaScript和Flash进行交互。有了Canvas，我们就再也不需要Flash了，直接使用JavaScript完成绘制。</p>
<p>一个Canvas定义了一个指定尺寸的矩形框，在这个范围内我们可以随意绘制：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;test-canvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于浏览器对HTML5标准支持不一致，所以，通常在<code>&lt;canvas&gt;</code>内部添加一些说明性HTML代码，如果浏览器支持Canvas，它将忽略<code>&lt;canvas&gt;</code>内部的HTML，如果浏览器不支持Canvas，它将显示<code>&lt;canvas&gt;</code>内部的HTML。在使用Canvas前，用<code>canvas.getContext</code>来测试浏览器是否支持Canvas：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;test-canvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">heigth</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>你的浏览器不支持Canvas<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你的浏览器不支持Canvas</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let canvas = document.getElementById(&#x27;test-canvas&#x27;);</span><br><span class="line">if (canvas.getContext) &#123;</span><br><span class="line">    console.log(&#x27;你的浏览器支持Canvas!&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&#x27;你的浏览器不支持Canvas!&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getContext('2d')</code>方法让我们拿到一个<code>CanvasRenderingContext2D</code>对象，所有的绘图操作都需要通过这个对象完成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>如果需要绘制3D怎么办？HTML5还有一个WebGL规范，允许在Canvas中绘制3D图形：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;webgl&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>本节我们只专注于绘制2D图形。</p>
<h3 id="绘制形状">绘制形状</h3>
<p>我们可以在Canvas上绘制各种形状。在绘制前，我们需要先了解一下Canvas的坐标系统：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 0,0                20</span><br><span class="line">  ┌───────────────────────▶ x</span><br><span class="line">  │                 │</span><br><span class="line">  │</span><br><span class="line">  │                 │</span><br><span class="line">10│─ ─ ─ ─ ─ ─ ─ ─ ─●</span><br><span class="line">  │                  20,10</span><br><span class="line">  ▼</span><br><span class="line">  y</span><br></pre></td></tr></table></figure>
<p>Canvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。</p>
<p><code>CanvasRenderingContext2D</code>对象有若干方法来绘制图形：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let</span><br><span class="line">    canvas = document.getElementById(&#x27;test-shape-canvas&#x27;),</span><br><span class="line">    ctx = canvas.getContext(&#x27;2d&#x27;);</span><br><span class="line"></span><br><span class="line">ctx.clearRect(0, 0, 200, 200); // 擦除(0,0)位置大小为200x200的矩形，擦除的意思是把该区域变为透明</span><br><span class="line">ctx.fillStyle = &#x27;#dddddd&#x27;; // 设置颜色</span><br><span class="line">ctx.fillRect(10, 10, 130, 130); // 把(10,10)位置大小为130x130的矩形涂色</span><br><span class="line">// 利用Path绘制复杂路径:</span><br><span class="line">let path=new Path2D();</span><br><span class="line">path.arc(75, 75, 50, 0, Math.PI*2, true);</span><br><span class="line">path.moveTo(110,75);</span><br><span class="line">path.arc(75, 75, 35, 0, Math.PI, false);</span><br><span class="line">path.moveTo(65, 65);</span><br><span class="line">path.arc(60, 65, 5, 0, Math.PI*2, true);</span><br><span class="line">path.moveTo(95, 65);</span><br><span class="line">path.arc(90, 65, 5, 0, Math.PI*2, true);</span><br><span class="line">ctx.strokeStyle = &#x27;#0000ff&#x27;;</span><br><span class="line">ctx.stroke(path);</span><br></pre></td></tr></table></figure>
<h3 id="绘制文本">绘制文本</h3>
<p>绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let</span><br><span class="line">    canvas = document.getElementById(&#x27;test-text-canvas&#x27;),</span><br><span class="line">    ctx = canvas.getContext(&#x27;2d&#x27;);</span><br><span class="line"></span><br><span class="line">ctx.fillStyle = &#x27;#fff&#x27;;</span><br><span class="line">ctx.fillRect(0, 0, 300, 100);</span><br><span class="line">ctx.shadowOffsetX = 2;</span><br><span class="line">ctx.shadowOffsetY = 2;</span><br><span class="line">ctx.shadowBlur = 2;</span><br><span class="line">ctx.shadowColor = &#x27;#ccc&#x27;;</span><br><span class="line">ctx.font = &#x27;28px Arial&#x27;;</span><br><span class="line">ctx.fillStyle = &#x27;#999&#x27;;</span><br><span class="line">ctx.fillText(&#x27;带阴影的文字&#x27;, 20, 40);</span><br></pre></td></tr></table></figure>
<p>Canvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常复杂的操作，考虑以下优化方案：</p>
<ul>
<li>通过创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中；</li>
<li>尽量使用整数坐标而不是浮点数；</li>
<li>可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图；</li>
<li>背景图片如果不变可以直接用<code>&lt;img&gt;</code>标签并放到最底层。</li>
</ul>
<h3 id="练习-6">练习</h3>
<p>请根据天气API返回的JSON数据在Canvas上绘制未来天气预报，如下图所示：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/browser/canvas/weather.jpg" alt="weather"></p>
<p><a href="#0">下载</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let data = [</span><br><span class="line">    &#123; high: 35, low: 22 &#125;,</span><br><span class="line">    &#123; high: 37, low: 24 &#125;,</span><br><span class="line">    &#123; high: 37, low: 25 &#125;,</span><br><span class="line">    &#123; high: 34, low: 24 &#125;,</span><br><span class="line">    &#123; high: 33, low: 23 &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">let canvas = document.getElementById(&#x27;weather-canvas&#x27;);</span><br><span class="line">// TODO: 绘图</span><br><span class="line">// 400x200</span><br><span class="line"></span><br><span class="line">// 下载:</span><br><span class="line">let download = document.getElementById(&#x27;weather-download&#x27;);</span><br><span class="line">download.href = canvas.toDataURL();</span><br></pre></td></tr></table></figure>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">標籤</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/JavaScript/" rel="tag">JavaScript</a> <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JavaScript-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"
                    data-tooltip="JavaScript-错误处理"
                    aria-label="上一篇: JavaScript-错误处理"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JavaScript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"
                    data-tooltip="JavaScript-面向对象编程"
                    aria-label="下一篇: JavaScript-面向对象编程"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E6%B5%8F%E8%A7%88%E5%99%A8/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E6%B5%8F%E8%A7%88%E5%99%A8/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E6%B5%8F%E8%A7%88%E5%99%A8/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E6%B5%8F%E8%A7%88%E5%99%A8/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JavaScript-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"
                    data-tooltip="JavaScript-错误处理"
                    aria-label="上一篇: JavaScript-错误处理"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JavaScript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"
                    data-tooltip="JavaScript-面向对象编程"
                    aria-label="下一篇: JavaScript-面向对象编程"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E6%B5%8F%E8%A7%88%E5%99%A8/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E6%B5%8F%E8%A7%88%E5%99%A8/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E6%B5%8F%E8%A7%88%E5%99%A8/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E6%B5%8F%E8%A7%88%E5%99%A8/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E6%B5%8F%E8%A7%88%E5%99%A8/"
                        aria-label="分享到 Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E6%B5%8F%E8%A7%88%E5%99%A8/"
                        aria-label="分享到 Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E6%B5%8F%E8%A7%88%E5%99%A8/"
                        aria-label="global.share_on_linkedin"
                    >
                        <i class="fab fa-linkedin" aria-hidden="true"></i><span>global.share_on_linkedin</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E6%B5%8F%E8%A7%88%E5%99%A8/"
                        aria-label="分享到 Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 211 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
