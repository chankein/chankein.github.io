
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>JavaScript-函数 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg"},"articleBody":"函数\n我们知道圆的面积计算公式为：\n当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：\n123456let r1 = 12.34;let r2 = 9.08;let r3 = 73.1;let s1 = 3.14 * r1 * r1;let s2 = 3.14 * r2 * r2;let s3 = 3.14 * r3 * r3;\n当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 * x * x不仅很麻烦，而且，如果要把3.14改成3.1416的时候，得全部替换。\n有了函数，我们就不再每次写s = 3.14 * x * x，而是写成更有意义的函数调用s = area_of_circle(x)，而函数area_of_circle本身只需要写一次，就可以多次调用。\n基本上所有的高级语言都支持函数，JavaScript也不例外。JavaScript的函数不但是“头等公民”，而且可以像变量一样使用，具有非常强大的抽象能力。\n抽象\n抽象是数学中非常常见的概念。举个例子：\n计算数列的和，比如：1 + 2 + 3 + ... + 100，写起来十分不方便，于是数学家发明了求和符号∑，可以把1 + 2 + 3 + ... + 100记作：\n这种抽象记法非常强大，因为我们看到 ∑ 就可以理解成求和，而不是还原成低级的加法运算。\n而且，这种抽象记法是可扩展的，比如：\n还原成加法运算就变成了：\n可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。\n写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。\n\n\n定义函数\n在JavaScript中，定义函数的方式如下：\n1234567function abs(x) &#123;    if (x &gt;= 0) &#123;        return x;    &#125; else &#123;        return -x;    &#125;&#125;\n上述abs()函数的定义如下：\n\nfunction指出这是一个函数定义；\nabs是函数的名称；\n(x)括号内列出函数的参数，多个参数以,分隔；\n&#123; ... &#125;之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。\n\n请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。\n如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined。\n由于JavaScript的函数也是一个对象，上述定义的abs()函数实际上是一个函数对象，而函数名abs可以视为指向该函数的变量。\n因此，第二种定义函数的方式如下：\n1234567let abs = function (x) &#123;    if (x &gt;= 0) &#123;        return x;    &#125; else &#123;        return -x;    &#125;&#125;;\n在这种方式下，function (x) &#123; ... &#125;是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。\n上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。\n调用函数\n调用函数时，按顺序传入参数即可：\n12abs(10); // 返回10abs(-9); // 返回9\n由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：\n12abs(10, &#x27;blablabla&#x27;); // 返回10abs(-9, &#x27;haha&#x27;, &#x27;hehe&#x27;, null); // 返回9\n传入的参数比定义的少也没有问题：\n1abs(); // 返回NaN\n此时abs(x)函数的参数x将收到undefined，计算结果为NaN。\n要避免收到undefined，可以对参数进行检查：\n12345678910function abs(x) &#123;    if (typeof x !== &#x27;number&#x27;) &#123;        throw &#x27;Not a number&#x27;;    &#125;    if (x &gt;= 0) &#123;        return x;    &#125; else &#123;        return -x;    &#125;&#125;\narguments\nJavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array：\n1234567function foo(x) &#123;    console.log(&#x27;x = &#x27; + x); // 10    for (let i=0; i&lt;arguments.length; i++) &#123;        console.log(&#x27;arg &#x27; + i + &#x27; = &#x27; + arguments[i]); // 10, 20, 30    &#125;&#125;foo(10, 20, 30);\n利用arguments，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值：\n1234567891011function abs() &#123;    if (arguments.length === 0) &#123;        return 0;    &#125;    let x = arguments[0];    return x &gt;= 0 ? x : -x;&#125;abs(); // 0abs(10); // 10abs(-9); // 9\n实际上arguments最常用于判断传入参数的个数。你可能会看到这样的写法：\n12345678910// foo(a[, b], c)// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：function foo(a, b, c) &#123;    if (arguments.length === 2) &#123;        // 实际拿到的参数是a和b，c为undefined        c = b; // 把b赋给c        b = null; // b变为默认值    &#125;    // ...&#125;\n要把中间的参数b变为“可选”参数，就只能通过arguments判断，然后重新调整参数并赋值。\nrest参数\n由于JavaScript函数允许接收任意个参数，于是我们就不得不用arguments来获取所有参数：\n1234567891011function foo(a, b) &#123;    let i, rest = [];    if (arguments.length &gt; 2) &#123;        for (i = 2; i&lt;arguments.length; i++) &#123;            rest.push(arguments[i]);        &#125;    &#125;    console.log(&#x27;a = &#x27; + a);    console.log(&#x27;b = &#x27; + b);    console.log(rest);&#125;\n为了获取除了已定义参数a、b之外的参数，我们不得不用arguments，并且循环要从索引2开始以便排除前两个参数，这种写法很别扭，只是为了获得额外的rest参数，有没有更好的方法？\nES6标准引入了rest参数，上面的函数可以改写为：\n1234567891011121314151617function foo(a, b, ...rest) &#123;    console.log(&#x27;a = &#x27; + a);    console.log(&#x27;b = &#x27; + b);    console.log(rest);&#125;foo(1, 2, 3, 4, 5);// 结果:// a = 1// b = 2// Array [ 3, 4, 5 ]foo(1);// 结果:// a = 1// b = undefined// Array []\nrest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。\n如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。\n因为rest参数是ES6新标准，所以你需要测试一下浏览器是否支持。请用rest参数编写一个sum()函数，接收任意个参数并返回它们的和：\n1234567891011121314151617181920function sum(...rest) &#123;   ???&#125;// 测试:let i, args = [];for (i=1; i&lt;=100; i++) &#123;    args.push(i);&#125;if (sum() !== 0) &#123;    console.log(&#x27;测试失败: sum() = &#x27; + sum());&#125; else if (sum(1) !== 1) &#123;    console.log(&#x27;测试失败: sum(1) = &#x27; + sum(1));&#125; else if (sum(2, 3) !== 5) &#123;    console.log(&#x27;测试失败: sum(2, 3) = &#x27; + sum(2, 3));&#125; else if (sum.apply(null, args) !== 5050) &#123;    console.log(&#x27;测试失败: sum(1, 2, 3, ..., 100) = &#x27; + sum.apply(null, args));&#125; else &#123;    console.log(&#x27;测试通过!&#x27;);&#125;\n小心你的return语句\n前面我们讲到了JavaScript引擎有一个在行末自动添加分号的机制，这可能让你栽到return语句的一个大坑：\n12345function foo() &#123;    return &#123; name: &#x27;foo&#x27; &#125;;&#125;foo(); // &#123; name: &#x27;foo&#x27; &#125;\n如果把return语句拆成两行：\n123456function foo() &#123;    return        &#123; name: &#x27;foo&#x27; &#125;;&#125;foo(); // undefined\n要小心了，由于JavaScript引擎在行末自动添加分号的机制，上面的代码实际上变成了：\n1234function foo() &#123;    return; // 自动添加了分号，相当于return undefined;        &#123; name: &#x27;foo&#x27; &#125;; // 这行语句已经没法执行到了&#125;\n所以正确的多行写法是：\n12345function foo() &#123;    return &#123; // 这里不会自动加分号，因为&#123;表示语句尚未结束        name: &#x27;foo&#x27;    &#125;;&#125;\n练习\n定义一个计算圆面积的函数area_of_circle()，它有两个参数：\n\nr: 表示圆的半径；\npi: 表示π的值，如果不传，则默认3.14\n\n12345678910function area_of_circle(r, pi) &#123;    // FIXME:    return 0;&#125;// 测试:if (area_of_circle(2) === 12.56 &amp;&amp; area_of_circle(2, 3.1416) === 12.5664) &#123;    console.log(&#x27;测试通过&#x27;);&#125; else &#123;    console.log(&#x27;测试失败&#x27;);&#125;\n小明是一个JavaScript新手，他写了一个max()函数，返回两个数中较大的那个：\n12345678910function max(a, b) &#123;    if (a &gt; b) &#123;        return                a;    &#125; else &#123;        return                b;    &#125;&#125;console.log(max(15, 20));\n但是小明抱怨他的浏览器出问题了，无论传入什么数，max()函数总是返回undefined。请帮他指出问题并修复。\n在JavaScript中，用var申明的变量实际上是有作用域的。\n如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量：\n123456function foo() &#123;    var x = 1;    x = x + 1;&#125;x = x + 2; // ReferenceError! 无法在函数体外引用变量x\n如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响：\n123456789function foo() &#123;    var x = 1;    x = x + 1;&#125;function bar() &#123;    var x = &#x27;A&#x27;;    x = x + &#x27;B&#x27;;&#125;\n由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行：\n1234567function foo() &#123;    var x = 1;    function bar() &#123;        var y = x + 1; // bar可以访问foo的变量x!    &#125;    var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!&#125;\n如果内部函数和外部函数的变量名重名怎么办？来测试一下：\n1234567891011function foo() &#123;    var x = 1;    function bar() &#123;        var x = &#x27;A&#x27;;        console.log(&#x27;x in bar() = &#x27; + x); // &#x27;A&#x27;    &#125;    console.log(&#x27;x in foo() = &#x27; + x); // 1    bar();&#125;foo();\n这说明JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。\n变量提升\nJavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有用var申明的变量“提升”到函数顶部：\n1234567function foo() &#123;    var x = &#x27;Hello, &#x27; + y;    console.log(x);    var y = &#x27;Bob&#x27;;&#125;foo();\n虽然是strict模式，但语句var x = 'Hello, ' + y;并不报错，原因是变量y在稍后申明了。但是console.log显示Hello, undefined，说明变量y的值为undefined。这正是因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。\n对于上述foo()函数，JavaScript引擎看到的代码相当于：\n123456function foo() &#123;    var y; // 提升变量y的申明，此时y为undefined    var x = &#x27;Hello, &#x27; + y;    console.log(x);    y = &#x27;Bob&#x27;;&#125;\n由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个var申明函数内部用到的所有变量：\n12345678910function foo() &#123;    var        x = 1, // x初始化为1        y = x + 1, // y初始化为2        z, i; // z和i为undefined    // 其他语句:    for (i=0; i&lt;100; i++) &#123;        ...    &#125;&#125;\n如果不需要兼容低版本浏览器，完全可以用let代替var来申明变量。\n注意\n建议使用let申明变量，避免var申明变量时带来的隐患。\n全局作用域\n不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性：\n123var course = &#x27;Learn JavaScript&#x27;;console.log(course); // &#x27;Learn JavaScript&#x27;console.log(window.course); // &#x27;Learn JavaScript&#x27;\n因此，直接访问全局变量course和访问window.course是完全一样的。\n你可能猜到了，由于函数定义有两种方式，以变量方式var foo = function () &#123;&#125;定义的函数实际上也是一个全局变量，因此，顶层函数的定义也被视为一个全局变量，并绑定到window对象：\n123456function foo() &#123;    alert(&#x27;foo&#x27;);&#125;foo(); // 直接调用foo()window.foo(); // 通过window.foo()调用\n进一步大胆地猜测，我们每次直接调用的alert()函数其实也是window的一个变量：\n1234567891011window.alert(&#x27;调用window.alert()&#x27;);// 把alert保存到另一个变量:let old_alert = window.alert;// 给alert赋一个新函数:window.alert = function () &#123;&#125;alert(&#x27;无法用alert()显示了!&#x27;);// 恢复alert:window.alert = old_alert;alert(&#x27;又可以用alert()了!&#x27;);\n这说明JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。\n名字空间\n全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。\n减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：\n1234567891011// 唯一的全局变量MYAPP:let MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = &#x27;myapp&#x27;;MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123;    return &#x27;foo&#x27;;&#125;;\n把自己的代码全部放入唯一的名字空间MYAPP中，会大大减少全局变量冲突的可能。\n许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。\n局部作用域\n由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的：\n123456function foo() &#123;    for (var i=0; i&lt;100; i++) &#123;        //    &#125;    i += 100; // 仍然可以引用变量i&#125;\n为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量：\n12345678function foo() &#123;    let sum = 0;    for (let i=0; i&lt;100; i++) &#123;        sum += i;    &#125;    // SyntaxError:    i += 1;&#125;\n常量\n由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”：\n1let PI = 3.14;\nES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域：\n123const PI = 3.14;PI = 3; // 某些浏览器不报错，但是无效果！PI; // 3.14\n解构赋值\n从ES6开始，JavaScript引入了解构赋值，可以同时对一组变量进行赋值。\n什么是解构赋值？我们先看看传统的做法，如何把一个数组的元素分别赋值给几个变量：\n1234let array = [&#x27;hello&#x27;, &#x27;JavaScript&#x27;, &#x27;ES6&#x27;];let x = array[0];let y = array[1];let z = array[2];\n现在，在ES6中，可以使用解构赋值，直接对多个变量同时赋值：\n12345// 如果浏览器支持解构赋值就不会报错:let [x, y, z] = [&#x27;hello&#x27;, &#x27;JavaScript&#x27;, &#x27;ES6&#x27;];// x, y, z分别被赋值为数组对应元素:console.log(`x = $&#123;x&#125;, y = $&#123;y&#125;, z = $&#123;z&#125;`);\n注意，对数组元素进行解构赋值时，多个变量要用[...]括起来。\n如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致：\n1234let [x, [y, z]] = [&#x27;hello&#x27;, [&#x27;JavaScript&#x27;, &#x27;ES6&#x27;]];x; // &#x27;hello&#x27;y; // &#x27;JavaScript&#x27;z; // &#x27;ES6&#x27;\n解构赋值还可以忽略某些元素：\n12let [, , z] = [&#x27;hello&#x27;, &#x27;JavaScript&#x27;, &#x27;ES6&#x27;]; // 忽略前两个元素，只对z赋值第三个元素z; // &#x27;ES6&#x27;\n如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性：\n1234567891011let person = &#123;    name: &#x27;小明&#x27;,    age: 20,    gender: &#x27;male&#x27;,    passport: &#x27;G-12345678&#x27;,    school: &#x27;No.4 middle school&#x27;&#125;;let &#123;name, age, passport&#125; = person;// name, age, passport分别被赋值为对应属性:console.log(`name = $&#123;name&#125;, age = $&#123;age&#125;, passport = $&#123;passport&#125;`);\n对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的：\n123456789101112131415161718let person = &#123;    name: &#x27;小明&#x27;,    age: 20,    gender: &#x27;male&#x27;,    passport: &#x27;G-12345678&#x27;,    school: &#x27;No.4 middle school&#x27;,    address: &#123;        city: &#x27;Beijing&#x27;,        street: &#x27;No.1 Road&#x27;,        zipcode: &#x27;100001&#x27;    &#125;&#125;;let &#123;name, address: &#123;city, zip&#125;&#125; = person;name; // &#x27;小明&#x27;city; // &#x27;Beijing&#x27;zip; // undefined, 因为属性名是zipcode而不是zip// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:address; // Uncaught ReferenceError: address is not defined\n使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为undefined，这和引用一个不存在的属性获得undefined是一致的。如果要使用的变量名和属性名不一致，可以用下面的语法获取：\n1234567891011121314let person = &#123;    name: &#x27;小明&#x27;,    age: 20,    gender: &#x27;male&#x27;,    passport: &#x27;G-12345678&#x27;,    school: &#x27;No.4 middle school&#x27;&#125;;// 把passport属性赋值给变量id:let &#123;name, passport:id&#125; = person;name; // &#x27;小明&#x27;id; // &#x27;G-12345678&#x27;// 注意: passport不是变量，而是为了让变量id获得passport属性:passport; // Uncaught ReferenceError: passport is not defined\n解构赋值还可以使用默认值，这样就避免了不存在的属性返回undefined的问题：\n1234567891011let person = &#123;    name: &#x27;小明&#x27;,    age: 20,    gender: &#x27;male&#x27;,    passport: &#x27;G-12345678&#x27;&#125;;// 如果person对象没有single属性，默认赋值为true:let &#123;name, single=true&#125; = person;name; // &#x27;小明&#x27;single; // true\n有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：\n12345// 声明变量:let x, y;// 解构赋值:&#123;x, y&#125; = &#123; name: &#x27;小明&#x27;, x: 100, y: 200&#125;;// 语法错误: Uncaught SyntaxError: Unexpected token =\n这是因为JavaScript引擎把&#123;开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来：\n1(&#123;x, y&#125; = &#123; name: &#x27;小明&#x27;, x: 100, y: 200&#125;);\n使用场景\n解构赋值在很多时候可以大大简化代码。例如，交换两个变量x和y的值，可以这么写，不再需要临时变量：\n12let x=1, y=2;[x, y] = [y, x]\n快速获取当前页面的域名和路径：\n1let &#123;hostname:domain, pathname:path&#125; = location;\n如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个Date对象：\n123function buildDate(&#123;year, month, day, hour=0, minute=0, second=0&#125;) &#123;    return new Date(`$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125; $&#123;hour&#125;:$&#123;minute&#125;:$&#123;second&#125;`);&#125;\n它的方便之处在于传入的对象只需要year、month和day这三个属性：\n12buildDate(&#123; year: 2017, month: 1, day: 1 &#125;);// Sun Jan 01 2017 00:00:00 GMT+0800 (CST)\n也可以传入hour、minute和second属性：\n12buildDate(&#123; year: 2017, month: 1, day: 1, hour: 20, minute: 15 &#125;);// Sun Jan 01 2017 20:15:00 GMT+0800 (CST)\n使用解构赋值可以减少代码量，但是，需要在支持ES6解构赋值特性的现代浏览器中才能正常运行。目前支持解构赋值的浏览器包括Chrome，Firefox，Edge等。\n在一个对象中绑定函数，称为这个对象的方法。\n在JavaScript中，对象的定义是这样的：\n1234let xiaoming = &#123;    name: &#x27;小明&#x27;,    birth: 1990&#125;;\n但是，如果我们给xiaoming绑定一个函数，就可以做更多的事情。比如，写个age()方法，返回xiaoming的年龄：\n1234567891011let xiaoming = &#123;    name: &#x27;小明&#x27;,    birth: 1990,    age: function () &#123;        let y = new Date().getFullYear();        return y - this.birth;    &#125;&#125;;xiaoming.age; // function xiaoming.age()xiaoming.age(); // 今年调用是25,明年调用就变成26了\n绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字，这个东东是什么？\n在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。\n让我们拆开写：\n12345678910111213function getAge() &#123;    let y = new Date().getFullYear();    return y - this.birth;&#125;let xiaoming = &#123;    name: &#x27;小明&#x27;,    birth: 1990,    age: getAge&#125;;xiaoming.age(); // 25, 正常结果getAge(); // NaN\n单独调用函数getAge()怎么返回了NaN？请注意，我们已经进入到了JavaScript的一个大坑里。\nJavaScript的函数内部如果调用了this，那么这个this到底指向谁？\n答案是，视情况而定！\n如果以对象的方法形式调用，比如xiaoming.age()，该函数的this指向被调用的对象，也就是xiaoming，这是符合我们预期的。\n如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。\n坑爹啊！\n更坑爹的是，如果这么写：\n12let fn = xiaoming.age; // 先拿到xiaoming的age函数fn(); // NaN\n也是不行的！要保证this指向正确，必须用obj.xxx()的形式调用！\n由于这是一个巨大的设计错误，要想纠正可没那么简单。ECMA决定，在strict模式下让函数的this指向undefined，因此，在strict模式下，你会得到一个错误：\n12345678910111213&#x27;use strict&#x27;;let xiaoming = &#123;    name: &#x27;小明&#x27;,    birth: 1990,    age: function () &#123;        let y = new Date().getFullYear();        return y - this.birth;    &#125;&#125;;let fn = xiaoming.age;fn(); // Uncaught TypeError: Cannot read property &#x27;birth&#x27; of undefined\n这个决定只是让错误及时暴露出来，并没有解决this应该指向的正确位置。\n有些时候，喜欢重构的你把方法重构了一下：\n123456789101112131415&#x27;use strict&#x27;;let xiaoming = &#123;    name: &#x27;小明&#x27;,    birth: 1990,    age: function () &#123;        function getAgeFromBirth() &#123;            let y = new Date().getFullYear();            return y - this.birth;        &#125;        return getAgeFromBirth();    &#125;&#125;;xiaoming.age(); // Uncaught TypeError: Cannot read property &#x27;birth&#x27; of undefined\n结果又报错了！原因是this指针只在age方法的函数内指向xiaoming，在函数内部定义的函数，this又指向undefined了！（在非strict模式下，它重新指向全局对象window！）\n修复的办法也不是没有，我们用一个that变量首先捕获this：\n12345678910111213141516&#x27;use strict&#x27;;let xiaoming = &#123;    name: &#x27;小明&#x27;,    birth: 1990,    age: function () &#123;        let that = this; // 在方法内部一开始就捕获this        function getAgeFromBirth() &#123;            let y = new Date().getFullYear();            return y - that.birth; // 用that而不是this        &#125;        return getAgeFromBirth();    &#125;&#125;;xiaoming.age(); // 25\n用let that = this;，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。\napply\n虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们还是可以控制this的指向的！\n要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。\n用apply修复getAge()调用：\n12345678910111213function getAge() &#123;    let y = new Date().getFullYear();    return y - this.birth;&#125;let xiaoming = &#123;    name: &#x27;小明&#x27;,    birth: 1990,    age: getAge&#125;;xiaoming.age(); // 25getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空\n另一个与apply()类似的方法是call()，唯一区别是：\n\napply()把参数打包成Array再传入；\ncall()把参数按顺序传入。\n\n比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下：\n12Math.max.apply(null, [3, 5, 4]); // 5Math.max.call(null, 3, 5, 4); // 5\n对普通函数调用，我们通常把this绑定为null。\n装饰器\n利用apply()，我们还可以动态改变函数的行为。\nJavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。\n现在假定我们想统计一下代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count += 1，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()：\n123456789101112131415&#x27;use strict&#x27;;let count = 0;let oldParseInt = parseInt; // 保存原函数window.parseInt = function () &#123;    count += 1;    return oldParseInt.apply(null, arguments); // 调用原函数&#125;;// 测试:parseInt(&#x27;10&#x27;);parseInt(&#x27;20&#x27;);parseInt(&#x27;30&#x27;);console.log(&#x27;count = &#x27; + count); // 3\n高阶函数英文叫Higher-order function。那么什么是高阶函数？\nJavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。\n一个最简单的高阶函数：\n123function add(x, y, f) &#123;    return f(x) + f(y);&#125;\n当我们调用add(-5, 6, Math.abs)时，参数x，y和f分别接收-5，6和函数Math.abs，根据函数定义，我们可以推导计算过程为：\n12345x = -5;y = 6;f = Math.abs;f(x) + f(y) ==&gt; Math.abs(-5) + Math.abs(6) ==&gt; 11;return 11;\n用代码验证一下：\n123456function add(x, y, f) &#123;    return f(x) + f(y);&#125;let x = add(-5, 6, Math.abs);console.log(x); // 11\n编写高阶函数，就是让函数的参数能够接收别的函数。\n如果你读过Google的那篇大名鼎鼎的论文“MapReduce: Simplified Data Processing on Large Clusters”，你就能大概明白map/reduce的概念。\nmap\n举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个数组[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map实现如下：\n123456789101112131415            f(x) = x * x                  │                  │  ┌───┬───┬───┬───┼───┬───┬───┬───┐  │   │   │   │   │   │   │   │   │  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼[ 1   2   3   4   5   6   7   8   9 ]  │   │   │   │   │   │   │   │   │  │   │   │   │   │   │   │   │   │  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼[ 1   4   9  16  25  36  49  64  81 ]\n由于map()方法定义在JavaScript的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果：\n1234567function pow(x) &#123;    return x * x;&#125;let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];let results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]console.log(results);\n注意：map()传入的参数是pow，即函数对象本身。\n你可能会想，不需要map()，写一个循环，也可以计算出结果：\n123456789let f = function (x) &#123;    return x * x;&#125;;let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];let result = [];for (let i=0; i&lt;arr.length; i++) &#123;    result.push(f(arr[i]));&#125;\n的确可以，但是，从上面的循环代码，我们无法一眼看明白“把f(x)作用在Array的每一个元素并把结果生成一个新的Array”。\n所以，map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把Array的所有数字转为字符串：\n12let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(String); // [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;]\n只需要一行代码。\nreduce\n再看reduce的用法。Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是：\n1[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)\n比方说对一个Array求和，就可以用reduce实现：\n1234let arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123;    return x + y;&#125;); // 25\n如果数组元素只有1个，那么还需要提供一个额外的初始参数以便至少凑够两：\n1234let arr = [123];arr.reduce(function (x, y) &#123;    return x + y;&#125;, 0); // 123\n练习：利用reduce()求积：\n123456789101112function product(arr) &#123;    // FIXME:    return 0;&#125;// 测试:if (product([1, 2, 3, 4]) === 24 &amp;&amp; product([0, 1, 2]) === 0 &amp;&amp; product([99, 88, 77, 66]) === 44274384) &#123;    console.log(&#x27;测试通过!&#x27;);&#125;else &#123;    console.log(&#x27;测试失败!&#x27;);&#125;\n要把[1, 3, 5, 7, 9]变换成整数13579，reduce()也能派上用场：\n1234let arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123;    return x * 10 + y;&#125;); // 13579\n如果我们继续改进这个例子，想办法把一个字符串13579先变成Array——[1, 3, 5, 7, 9]，再利用reduce()就可以写出一个把字符串转换为Number的函数。\n练习：不要使用JavaScript内置的parseInt()函数，利用map和reduce操作实现一个string2int()函数：\n123456789101112131415161718function string2int(s) &#123;    // FIXME:    return 0;&#125;// 测试:if (string2int(&#x27;0&#x27;) === 0 &amp;&amp; string2int(&#x27;12345&#x27;) === 12345 &amp;&amp; string2int(&#x27;12300&#x27;) === 12300) &#123;    if (string2int.toString().indexOf(&#x27;parseInt&#x27;) !== -1) &#123;        console.log(&#x27;请勿使用parseInt()!&#x27;);    &#125; else if (string2int.toString().indexOf(&#x27;Number&#x27;) !== -1) &#123;        console.log(&#x27;请勿使用Number()!&#x27;);    &#125; else &#123;        console.log(&#x27;测试通过!&#x27;);    &#125;&#125;else &#123;    console.log(&#x27;测试失败!&#x27;);&#125;\n练习\n请把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']。\n123456789101112function normalize(arr) &#123;    // FIXME:    return [];&#125;// 测试:if (normalize([&#x27;adam&#x27;, &#x27;LISA&#x27;, &#x27;barT&#x27;]).toString() === [&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;].toString()) &#123;    console.log(&#x27;测试通过!&#x27;);&#125;else &#123;    console.log(&#x27;测试失败!&#x27;);&#125;\n小明希望利用map()把字符串变成整数，他写的代码很简洁：\n12345let arr = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;];let r;r = arr.map(parseInt);console.log(r);\n结果竟然是1, NaN, NaN，小明百思不得其解，请帮他找到原因并修正代码。\n提示：参考Array.prototype.map()的文档。\n原因分析:\n由于map()接收的回调函数可以有3个参数：callback(currentValue, index, array)，通常我们仅需要第一个参数，而忽略了传入的后面两个参数。不幸的是，parseInt(string, radix)没有忽略第二个参数，导致实际执行的函数分别是：\nparseInt(‘1’, 0); // 1, 按十进制转换\nparseInt(‘2’, 1); // NaN, 没有一进制\nparseInt(‘3’, 2); // NaN, 按二进制转换不允许出现3\n可以改为r = arr.map(Number);，因为Number(value)函数仅接收一个参数。\nfilter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。\n和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。\n例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：\n12345let arr = [1, 2, 4, 5, 6, 9, 10, 15];let r = arr.filter(function (x) &#123;    return x % 2 !== 0;&#125;);r; // [1, 5, 9, 15]\n把一个Array中的空字符串删掉，可以这么写：\n12345let arr = [&#x27;A&#x27;, &#x27;&#x27;, &#x27;B&#x27;, null, undefined, &#x27;C&#x27;, &#x27;  &#x27;];let r = arr.filter(function (s) &#123;    return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法&#125;);r; // [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]\n可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。\n回调函数\nfilter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身：\n1234567let arr = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;];let r = arr.filter(function (element, index, self) &#123;    console.log(element); // 依次打印&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;    console.log(index); // 依次打印0, 1, 2    console.log(self); // self就是变量arr    return true;&#125;);\n利用filter，可以巧妙地去除Array的重复元素：\n123456789let    r,    arr = [&#x27;apple&#x27;, &#x27;strawberry&#x27;, &#x27;banana&#x27;, &#x27;pear&#x27;, &#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;orange&#x27;, &#x27;strawberry&#x27;];r = arr.filter(function (element, index, self) &#123;    return self.indexOf(element) === index;&#125;);console.log(r);\n去除重复元素依靠的是indexOf总是返回第一个元素的位置，后续的重复元素位置与indexOf返回的位置不相等，因此被filter滤掉了。\n练习\n请尝试用filter()筛选出素数：\n12345678910111213141516171819function get_primes(arr) &#123;    // FIXME:    return [];&#125;// 测试:let    x,    r,    arr = [];for (x = 1; x &lt; 100; x++) &#123;    arr.push(x);&#125;r = get_primes(arr);if (r.toString() === [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97].toString()) &#123;    console.log(&#x27;测试通过!&#x27;);&#125; else &#123;    console.log(&#x27;测试失败: &#x27; + r.toString());&#125;\n排序算法\n排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个对象呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。\nJavaScript的Array的sort()方法就是用于排序的，但是排序结果可能让你大吃一惊：\n12345678// 看上去正常的结果:[&#x27;Google&#x27;, &#x27;Apple&#x27;, &#x27;Microsoft&#x27;].sort(); // [&#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Microsoft&#x27;];// apple排在了最后:[&#x27;Google&#x27;, &#x27;apple&#x27;, &#x27;Microsoft&#x27;].sort(); // [&#x27;Google&#x27;, &#x27;Microsoft&quot;, &#x27;apple&#x27;]// 无法理解的结果:[10, 20, 1, 2].sort(); // [1, 10, 2, 20]\n第二个排序把apple排在了最后，是因为字符串根据ASCII码进行排序，而小写字母a的ASCII码在大写字母之后。\n第三个排序结果是什么鬼？简单的数字排序都能错？\n这是因为Array的sort()方法默认把所有元素先转换为String再排序，结果'10'排在了'2'的前面，因为字符'1'比字符'2'的ASCII码小。\n\n如果不知道sort()方法的默认排序规则，直接对数字排序，绝对栽进坑里！\n幸运的是，sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。\n要按数字大小排序，我们可以这么写：\n12345678910111213let arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123;    if (x &lt; y) &#123;        return -1;    &#125;    if (x &gt; y) &#123;        return 1;    &#125;    return 0;&#125;);console.log(arr); // [1, 2, 10, 20]\n如果要倒序排序，我们可以把大的数放前面：\n1234let arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123;    return y - x;&#125;); // [20, 10, 2, 1]\n给sort()传入的比较函数接受x和y两个参数，如果x&lt;y，应返回负数，如果x&gt;y，应返回正数，如果x=y，应返回0。\n默认情况下，对字符串排序，是按照ASCII的大小比较的，现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：\n123456789101112let arr = [&#x27;Google&#x27;, &#x27;apple&#x27;, &#x27;Microsoft&#x27;];arr.sort(function (s1, s2) &#123;    x1 = s1.toUpperCase();    x2 = s2.toUpperCase();    if (x1 &lt; x2) &#123;        return -1;    &#125;    if (x1 &gt; x2) &#123;        return 1;    &#125;    return 0;&#125;); // [&#x27;apple&#x27;, &#x27;Google&#x27;, &#x27;Microsoft&#x27;]\n忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。\n从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。\n最后友情提示，sort()方法会直接对Array进行修改，它返回的结果仍是当前Array：\n12345let a1 = [&#x27;B&#x27;, &#x27;A&#x27;, &#x27;C&#x27;];let a2 = a1.sort();a1; // [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]a2; // [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]a1 === a2; // true, a1和a2是同一对象\nArray\n对于数组，除了map()、reduce、filter()、sort()这些方法可以传入一个函数外，Array对象还提供了很多非常实用的高阶函数。\nevery\nevery()方法可以判断数组的所有元素是否满足测试条件。\n例如，给定一个包含若干字符串的数组，判断所有字符串是否满足指定的测试条件：\n12345678let arr = [&#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;];console.log(arr.every(function (s) &#123;    return s.length &gt; 0;&#125;)); // true, 因为每个元素都满足s.length&gt;0console.log(arr.every(function (s) &#123;    return s.toLowerCase() === s;&#125;)); // false, 因为不是每个元素都全部是小写\nfind\nfind()方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回undefined：\n12345678let arr = [&#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;];console.log(arr.find(function (s) &#123;    return s.toLowerCase() === s;&#125;)); // &#x27;pear&#x27;, 因为pear全部是小写console.log(arr.find(function (s) &#123;    return s.toUpperCase() === s;&#125;)); // undefined, 因为没有全部是大写的元素\nfindIndex\nfindIndex()和find()类似，也是查找符合条件的第一个元素，不同之处在于findIndex()会返回这个元素的索引，如果没有找到，返回-1：\n12345678let arr = [&#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;];console.log(arr.findIndex(function (s) &#123;    return s.toLowerCase() === s;&#125;)); // 1, 因为&#x27;pear&#x27;的索引是1console.log(arr.findIndex(function (s) &#123;    return s.toUpperCase() === s;&#125;)); // -1\nforEach\nforEach()和map()类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。forEach()常用于遍历数组，因此，传入的函数不需要返回值：\n12let arr = [&#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;];arr.forEach(x=&gt;console.log(x)); // 依次打印每个元素\n\n\n函数作为返回值\n高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。\n我们来实现一个对Array的求和。通常情况下，求和的函数是这样定义的：\n1234567function sum(arr) &#123;    return arr.reduce(function (x, y) &#123;        return x + y;    &#125;);&#125;sum([1, 2, 3, 4, 5]); // 15\n但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！\n12345678function lazy_sum(arr) &#123;    let sum = function () &#123;        return arr.reduce(function (x, y) &#123;            return x + y;        &#125;);    &#125;    return sum;&#125;\n当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：\n1let f = lazy_sum([1, 2, 3, 4, 5]); // function sum()\n调用函数f时，才真正计算求和的结果：\n1f(); // 15\n在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。\n请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：\n123let f1 = lazy_sum([1, 2, 3, 4, 5]);let f2 = lazy_sum([1, 2, 3, 4, 5]);f1 === f2; // false\nf1()和f2()的调用结果互不影响。\n闭包\n注意到返回的函数在其定义内部引用了局部变量arr，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。\n另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：\n123456789101112function count() &#123;    let arr = [];    for (var i=1; i&lt;=3; i++) &#123;        arr.push(function () &#123;            return i * i;        &#125;);    &#125;    return arr;&#125;let results = count();let [f1, f2, f3] = results;\n在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了。\n你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：\n123f1(); // 16f2(); // 16f3(); // 16\n全部都是16！原因就在于返回的函数引用了用var定义的变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了4，因此最终结果为16。\n返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。\n如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：\n1234567891011121314151617function count() &#123;    let arr = [];    for (var i=1; i&lt;=3; i++) &#123;        arr.push((function (n) &#123;            return function () &#123;                return n * n;            &#125;        &#125;)(i));    &#125;    return arr;&#125;let [f1, f2, f3] = count();f1(); // 1f2(); // 4f3(); // 9\n注意这里用了一个“创建一个匿名函数并立刻执行”的语法：\n123(function (x) &#123;    return x * x;&#125;)(3); // 9\n理论上讲，创建一个匿名函数并立刻执行可以这么写：\n1function (x) &#123; return x * x &#125; (3);\n但是由于JavaScript语法解析的问题，会报SyntaxError错误，因此需要用括号把整个函数定义括起来：\n1(function (x) &#123; return x * x &#125;) (3);\n通常，一个立即执行的匿名函数可以把函数体拆开，一般这么写：\n123(function (x) &#123;    return x * x;&#125;)(3);\n另一个方法是把循环变量i用let定义在for循环体中，let作用域决定了在每次循环时都会绑定新的i：\n123456789function count() &#123;    let arr = [];    for (let i=1; i&lt;=3; i++) &#123;        arr.push(function () &#123;            return i * i;        &#125;);    &#125;    return arr;&#125;\n但如果i定义在for循环外面，则仍然是错误的：\n12345678910function count() &#123;    let arr = [];    let i;    for (i=1; i&lt;=3; i++) &#123;        arr.push(function () &#123;            return i * i;        &#125;);    &#125;    return arr;&#125;\n因此，最好的办法还是返回函数不要引用任何循环变量。\n说了这么多，难道闭包就是为了返回一个函数然后延迟执行吗？\n当然不是！闭包有非常强大的功能。举个栗子：\n在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。\n在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：\n123456789function create_counter(initial) &#123;    let x = initial || 0;    return &#123;        inc: function () &#123;            x += 1;            return x;        &#125;    &#125;&#125;\n它用起来像这样：\n123456789let c1 = create_counter();c1.inc(); // 1c1.inc(); // 2c1.inc(); // 3let c2 = create_counter(10);c2.inc(); // 11c2.inc(); // 12c2.inc(); // 13\n在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。\n闭包还可以把多参数的函数变成单参数的函数。例如，要计算xy可以用Math.pow(x, y)函数，不过考虑到经常计算x2或x3，我们可以利用闭包创建新的函数pow2和pow3：\n123456789101112function make_pow(n) &#123;    return function (x) &#123;        return Math.pow(x, n);    &#125;&#125;// 创建两个新函数:let pow2 = make_pow(2);let pow3 = make_pow(3);console.log(pow2(5)); // 25console.log(pow3(7)); // 343\n\n廖雪峰\n资深软件开发工程师，业余马拉松选手。\nES6标准新增了一种新的函数：箭头函数（Arrow Function）。\n为什么叫箭头函数？因为它的定义用的就是一个箭头：\n1x =&gt; x * x\n上面的箭头函数相当于：\n123function (x) &#123;    return x * x;&#125;\n在继续学习箭头函数之前，请测试你的浏览器是否支持ES6的Arrow Function：\n12let fn = x =&gt; x * x;console.log(&#x27;你的浏览器支持ES6的Arrow Function!&#x27;);\n箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连&#123; ... &#125;和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略&#123; ... &#125;和return：\n12345678x =&gt; &#123;    if (x &gt; 0) &#123;        return x * x;    &#125;    else &#123;        return - x * x;    &#125;&#125;\n如果参数不是一个，就需要用括号()括起来：\n1234567891011121314// 两个参数:(x, y) =&gt; x * x + y * y// 无参数:() =&gt; 3.14// 可变参数:(x, y, ...rest) =&gt; &#123;    let i, sum = x + y;    for (i=0; i&lt;rest.length; i++) &#123;        sum += rest[i];    &#125;    return sum;&#125;\n如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：\n12// SyntaxError:x =&gt; &#123; foo: x &#125;\n因为和函数体的&#123; ... &#125;有语法冲突，所以要改为：\n12// ok:x =&gt; (&#123; foo: x &#125;)\nthis\n箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。\n回顾前面的例子，由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果：\n12345678910let obj = &#123;    birth: 1990,    getAge: function () &#123;        let b = this.birth; // 1990        let fn = function () &#123;            return new Date().getFullYear() - this.birth; // this指向window或undefined        &#125;;        return fn();    &#125;&#125;;\n现在，箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：\n123456789let obj = &#123;    birth: 1990,    getAge: function () &#123;        let b = this.birth; // 1990        let fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象        return fn();    &#125;&#125;;obj.getAge(); // 25\n如果使用箭头函数，以前的那种hack写法：\n1let that = this;\n就不再需要了。\n由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略：\n123456789let obj = &#123;    birth: 1990,    getAge: function (year) &#123;        let b = this.birth; // 1990        let fn = (y) =&gt; y - this.birth; // this.birth仍是1990        return fn.call(&#123;birth:2000&#125;, year);    &#125;&#125;;obj.getAge(2015); // 25\n练习\n请使用箭头函数简化排序时传入的函数：\n12345let arr = [10, 20, 1, 2];arr.sort((x, y) =&gt; &#123;    ???&#125;);console.log(arr); // [1, 2, 10, 20]\n标签函数\n\n廖雪峰\n资深软件开发工程师，业余马拉松选手。\n前面我们介绍了模板字符串，它可以非常方便地引用变量，并合并出最终的字符串：\n1234let name = &#x27;小明&#x27;;let age = 20;let s = `你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`;console.log(s);\n对于模板字符串，除了方便引用变量构造字符串外，还有一种更强大的功能，即可以使用标签函数（Tag Function）。\n什么是标签函数？让我们看一个例子：\n123456789101112131415const email = &quot;test@example.com&quot;;const password = &#x27;hello123&#x27;;function sql(strings, ...exps) &#123;    console.log(`SQL: $&#123;strings.join(&#x27;?&#x27;)&#125;`);    console.log(`SQL parameters: $&#123;JSON.stringify(exps)&#125;`);    return &#123;        name: &#x27;小明&#x27;,        age: 20    &#125;;&#125;const result = sql`SELECT * FROM users WHERE email=$&#123;email&#125; AND password=$&#123;password&#125;`;console.log(JSON.stringify(result));\n这里出现了一个奇怪的语法：\n1sql`SELECT * FROM users WHERE email=$&#123;email&#125; AND password=$&#123;password&#125;`\n模板字符串前面以sql开头，实际上这是一个标签函数，上述语法会自动转换为对sql()函数的调用。我们关注的是，传入sql()函数的参数是什么。\nsql()函数实际上接收两个参数：\n第一个参数strings是一个字符串数组，它是[&quot;SELECT * FROM users WHERE email=&quot;, &quot; AND password=&quot;, &quot;&quot;]，即除去$&#123;xxx&#125;剩下的字符组成的数组；\n第二个参数...exps是一个可变参数，它接收的也是一个数组，但数组的内容是由模板字符串里所有的$&#123;xxx&#125;的实际值组成，即[&quot;test@example.com&quot;, &quot;hello123&quot;]，因为解析$&#123;email&#125;得到&quot;test@example.com&quot;，解析$&#123;password&#125;得到&quot;hello123&quot;。\n标签函数sql()实际上是一个普通函数，我们在内部把strings拼接成一个SQL字符串，把...exps作为参数，就可以实现一个安全的SQL查询，并返回查询结果。此处并没有真正的数据库连接，因此返回一个固定的Object。\n标签函数和普通函数的定义区别仅仅在于参数，如果我们想对数据库进行修改，完全可以定义一个标签函数如下：\n12345function update(strings, ...exps) &#123;    let sql = strings.join(&#x27;?&#x27;);    // 执行数据库更新    // TODO:&#125;\n函数调用可以简化为带标签的模板字符串：\n12345let id = 123;let age = 21;let score = &#x27;A&#x27;;update`UPDATE users SET age=$&#123;age&#125;, score=$&#123;score&#125; WHERE id=$&#123;id&#125;`;\n是不是非常简洁？\n\n\n\n廖雪峰\n资深软件开发工程师，业余马拉松选手。\n生成器（generator）是ES6标准引入的新的数据类型。一个生成器看上去像一个函数，但可以返回多次。\nES6定义生成器标准的哥们借鉴了Python的generator的概念和语法，如果你对Python的generator很熟悉，那么ES6的generator就是小菜一碟了。如果你对Python还不熟，赶快恶补Python教程！。\n我们先复习函数的概念。一个函数是一段完整的代码，调用一个函数就是传入参数，然后返回结果：\n12345function foo(x) &#123;    return x + x;&#125;let r = foo(1); // 调用foo函数\n函数在执行过程中，如果没有遇到return语句（函数末尾如果没有return，就是隐含的return undefined;），控制权无法交回被调用的代码。\ngenerator跟函数很像，定义如下：\n12345function* foo(x) &#123;    yield x + 1;    yield x + 2;    return x + 3;&#125;\ngenerator和函数不同的是，generator由function*定义（注意多出的*号），并且，除了return语句，还可以用yield返回多次。\n大多数同学立刻就晕了，generator就是能够返回多次的“函数”？返回多次有啥用？\n还是举个栗子吧。\n我们以一个著名的斐波那契数列为例，它由0，1开头：\n10 1 1 2 3 5 8 13 21 34 ...\n要编写一个产生斐波那契数列的函数，可以这么写：\n12345678910111213141516function fib(max) &#123;    let        t,        a = 0,        b = 1,        arr = [0, 1];    while (arr.length &lt; max) &#123;        [a, b] = [b, a + b];        arr.push(b);    &#125;    return arr;&#125;// 测试:fib(5); // [0, 1, 1, 2, 3]fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n函数只能返回一次，所以必须返回一个Array。但是，如果换成generator，就可以一次返回一个数，不断返回多次。用generator改写如下：\n12345678910111213function* fib(max) &#123;    let        t,        a = 0,        b = 1,        n = 0;    while (n &lt; max) &#123;        yield a;        [a, b] = [b, a + b];        n ++;    &#125;    return;&#125;\n直接调用试试：\n1fib(5); // fib &#123;[[GeneratorStatus]]: &quot;suspended&quot;, [[GeneratorReceiver]]: Window&#125;\n直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。\n调用generator对象有两个方法，一是不断地调用generator对象的next()方法：\n1234567let f = fib(5);f.next(); // &#123;value: 0, done: false&#125;f.next(); // &#123;value: 1, done: false&#125;f.next(); // &#123;value: 1, done: false&#125;f.next(); // &#123;value: 2, done: false&#125;f.next(); // &#123;value: 3, done: false&#125;f.next(); // &#123;value: undefined, done: true&#125;\nnext()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象&#123;value: x, done: true/false&#125;，然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。\n当执行到done为true时，这个generator对象就已经全部执行完毕，不要再继续调用next()了。\n第二个方法是直接用for ... of循环迭代generator对象，这种方式不需要我们自己判断done：\n12345678910111213141516function* fib(max) &#123;    let        a = 0,        b = 1,        n = 0;    while (n &lt; max) &#123;        yield a;        [a, b] = [b, a + b];        n ++;    &#125;    return;&#125;for (let x of fib(10)) &#123;    console.log(x); // 依次输出0, 1, 1, 2, 3, ...&#125;\ngenerator和普通函数相比，有什么用？\n因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。例如，用一个对象来保存状态，得这么写：\n12345678910111213141516171819let fib = &#123;    a: 0,    b: 1,    n: 0,    max: 5,    next: function () &#123;        let            r = this.a,            t = this.a + this.b;        this.a = this.b;        this.b = t;        if (this.n &lt; this.max) &#123;            this.n ++;            return r;        &#125; else &#123;            return undefined;        &#125;    &#125;&#125;;\n用对象的属性来保存状态，相当繁琐。\ngenerator还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。这个好处要等到后面学了AJAX以后才能体会到。\n没有generator之前的黑暗时代，用AJAX时需要这么写代码：\n12345678910111213141516ajax(&#x27;http://url-1&#x27;, data1, function (err, result) &#123;    if (err) &#123;        return handle(err);    &#125;    ajax(&#x27;http://url-2&#x27;, data2, function (err, result) &#123;        if (err) &#123;            return handle(err);        &#125;        ajax(&#x27;http://url-3&#x27;, data3, function (err, result) &#123;            if (err) &#123;                return handle(err);            &#125;            return success(result);        &#125;);    &#125;);&#125;);\n回调越多，代码越难看。\n有了generator的美好时代，用AJAX时可以这么写：\n123456789try &#123;    r1 = yield ajax(&#x27;http://url-1&#x27;, data1);    r2 = yield ajax(&#x27;http://url-2&#x27;, data2);    r3 = yield ajax(&#x27;http://url-3&#x27;, data3);    success(r3);&#125;catch (err) &#123;    handle(err);&#125;\n看上去是同步的代码，实际执行是异步的。\n练习\n要生成一个自增的ID，可以编写一个next_id()函数：\n123456let current_id = 0;function next_id() &#123;    current_id ++;    return current_id;&#125;\n由于函数无法保存状态，故需要一个全局变量current_id来保存数字。\n不用闭包，试用generator改写：\n12345678910111213141516171819function* next_id() &#123;    ???&#125;// 测试:let    x,    pass = true,    g = next_id();for (x = 1; x &lt; 100; x ++) &#123;    if (g.next().value !== x) &#123;        pass = false;        console.log(&#x27;测试失败!&#x27;);        break;    &#125;&#125;if (pass) &#123;    console.log(&#x27;测试通过!&#x27;);&#125;\n","dateCreated":"2025-05-26T21:05:28+08:00","dateModified":"2025-05-26T21:14:04+08:00","datePublished":"2025-05-26T21:05:28+08:00","description":"","headline":"JavaScript-函数","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E5%87%BD%E6%95%B0/"},"publisher":{"@type":"Organization","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg","logo":{"@type":"ImageObject","url":"profile.jpg"}},"url":"https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E5%87%BD%E6%95%B0/","keywords":"JavaScript, 前端"}</script>
    <meta name="description" content="函数 我们知道圆的面积计算公式为： 当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积： 123456let r1 &#x3D; 12.34;let r2 &#x3D; 9.08;let r3 &#x3D; 73.1;let s1 &#x3D; 3.14 * r1 * r1;let s2 &#x3D; 3.14 * r2 * r2;let s3 &#x3D; 3.14 * r3 * r3; 当代码出现有规律的重复的时候">
<meta property="og:type" content="blog">
<meta property="og:title" content="JavaScript-函数">
<meta property="og:url" content="https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E5%87%BD%E6%95%B0/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:description" content="函数 我们知道圆的面积计算公式为： 当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积： 123456let r1 &#x3D; 12.34;let r2 &#x3D; 9.08;let r3 &#x3D; 73.1;let s1 &#x3D; 3.14 * r1 * r1;let s2 &#x3D; 3.14 * r2 * r2;let s3 &#x3D; 3.14 * r3 * r3; 当代码出现有规律的重复的时候">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/function/higher-order-function/sort/douwo.jpg">
<meta property="og:image" content="http://thirdqq.qlogo.cn/ek_qqapp/AQVJKMtqeFCGNEZqicOj7qb7mnpcJiaZNlEOf0iasx2DicuEycbIG9cQktWUBxWR1dFWfLMI2Ilt/100">
<meta property="og:image" content="http://thirdqq.qlogo.cn/ek_qqapp/AQVJKMtqeFCGNEZqicOj7qb7mnpcJiaZNlEOf0iasx2DicuEycbIG9cQktWUBxWR1dFWfLMI2Ilt/100">
<meta property="og:image" content="http://thirdqq.qlogo.cn/ek_qqapp/AQVJKMtqeFCGNEZqicOj7qb7mnpcJiaZNlEOf0iasx2DicuEycbIG9cQktWUBxWR1dFWfLMI2Ilt/100">
<meta property="article:published_time" content="2025-05-26T13:05:28.000Z">
<meta property="article:modified_time" content="2025-05-26T13:14:04.825Z">
<meta property="article:author" content="Kein Chan">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liaoxuefeng.com/books/javascript/function/higher-order-function/sort/douwo.jpg">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../../../#about"
            >
        
        
            <img class="header-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            JavaScript-函数
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2025-05-26T21:05:28+08:00">
	
		    2025 年 5 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/">JavaScript</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h2 id="函数">函数</h2>
<p>我们知道圆的面积计算公式为：</p>
<p>当我们知道半径<code>r</code>的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r1 = <span class="number">12.34</span>;</span><br><span class="line"><span class="keyword">let</span> r2 = <span class="number">9.08</span>;</span><br><span class="line"><span class="keyword">let</span> r3 = <span class="number">73.1</span>;</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="number">3.14</span> * r1 * r1;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="number">3.14</span> * r2 * r2;</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="number">3.14</span> * r3 * r3;</span><br></pre></td></tr></table></figure>
<p>当代码出现有规律的重复的时候，你就需要当心了，每次写<code>3.14 * x * x</code>不仅很麻烦，而且，如果要把<code>3.14</code>改成<code>3.1416</code>的时候，得全部替换。</p>
<p>有了函数，我们就不再每次写<code>s = 3.14 * x * x</code>，而是写成更有意义的函数调用<code>s = area_of_circle(x)</code>，而函数<code>area_of_circle</code>本身只需要写一次，就可以多次调用。</p>
<p>基本上所有的高级语言都支持函数，JavaScript也不例外。JavaScript的函数不但是“头等公民”，而且可以像变量一样使用，具有非常强大的抽象能力。</p>
<h3 id="抽象">抽象</h3>
<p>抽象是数学中非常常见的概念。举个例子：</p>
<p>计算数列的和，比如：<code>1 + 2 + 3 + ... + 100</code>，写起来十分不方便，于是数学家发明了求和符号∑，可以把<code>1 + 2 + 3 + ... + 100</code>记作：</p>
<p>这种抽象记法非常强大，因为我们看到 ∑ 就可以理解成求和，而不是还原成低级的加法运算。</p>
<p>而且，这种抽象记法是可扩展的，比如：</p>
<p>还原成加法运算就变成了：</p>
<p>可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。</p>
<p>写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。</p>
<hr>
<hr>
<h3 id="定义函数">定义函数</h3>
<p>在JavaScript中，定义函数的方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">abs</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述<code>abs()</code>函数的定义如下：</p>
<ul>
<li><code>function</code>指出这是一个函数定义；</li>
<li><code>abs</code>是函数的名称；</li>
<li><code>(x)</code>括号内列出函数的参数，多个参数以<code>,</code>分隔；</li>
<li><code>&#123; ... &#125;</code>之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。</li>
</ul>
<p>请注意，函数体内部的语句在执行时，一旦执行到<code>return</code>时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。</p>
<p>如果没有<code>return</code>语句，函数执行完毕后也会返回结果，只是结果为<code>undefined</code>。</p>
<p>由于JavaScript的函数也是一个对象，上述定义的<code>abs()</code>函数实际上是一个函数对象，而函数名<code>abs</code>可以视为指向该函数的变量。</p>
<p>因此，第二种定义函数的方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> abs = <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这种方式下，<code>function (x) &#123; ... &#125;</code>是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量<code>abs</code>，所以，通过变量<code>abs</code>就可以调用该函数。</p>
<p>上述两种定义<em>完全等价</em>，注意第二种方式按照完整语法需要在函数体末尾加一个<code>;</code>，表示赋值语句结束。</p>
<h3 id="调用函数">调用函数</h3>
<p>调用函数时，按顺序传入参数即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">abs</span>(<span class="number">10</span>); <span class="comment">// 返回10</span></span><br><span class="line"><span class="title function_">abs</span>(-<span class="number">9</span>); <span class="comment">// 返回9</span></span><br></pre></td></tr></table></figure>
<p>由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">abs</span>(<span class="number">10</span>, <span class="string">&#x27;blablabla&#x27;</span>); <span class="comment">// 返回10</span></span><br><span class="line"><span class="title function_">abs</span>(-<span class="number">9</span>, <span class="string">&#x27;haha&#x27;</span>, <span class="string">&#x27;hehe&#x27;</span>, <span class="literal">null</span>); <span class="comment">// 返回9</span></span><br></pre></td></tr></table></figure>
<p>传入的参数比定义的少也没有问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">abs</span>(); <span class="comment">// 返回NaN</span></span><br></pre></td></tr></table></figure>
<p>此时<code>abs(x)</code>函数的参数<code>x</code>将收到<code>undefined</code>，计算结果为<code>NaN</code>。</p>
<p>要避免收到<code>undefined</code>，可以对参数进行检查：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">abs</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;Not a number&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="arguments">arguments</h3>
<p>JavaScript还有一个免费赠送的关键字<code>arguments</code>，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。<code>arguments</code>类似<code>Array</code>但它不是一个<code>Array</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo(x) &#123;</span><br><span class="line">    console.log(&#x27;x = &#x27; + x); // 10</span><br><span class="line">    for (let i=0; i&lt;arguments.length; i++) &#123;</span><br><span class="line">        console.log(&#x27;arg &#x27; + i + &#x27; = &#x27; + arguments[i]); // 10, 20, 30</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(10, 20, 30);</span><br></pre></td></tr></table></figure>
<p>利用<code>arguments</code>，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">abs</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="variable language_">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">abs</span>(); <span class="comment">// 0</span></span><br><span class="line"><span class="title function_">abs</span>(<span class="number">10</span>); <span class="comment">// 10</span></span><br><span class="line"><span class="title function_">abs</span>(-<span class="number">9</span>); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<p>实际上<code>arguments</code>最常用于判断传入参数的个数。你可能会看到这样的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo(a[, b], c)</span></span><br><span class="line"><span class="comment">// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 实际拿到的参数是a和b，c为undefined</span></span><br><span class="line">        c = b; <span class="comment">// 把b赋给c</span></span><br><span class="line">        b = <span class="literal">null</span>; <span class="comment">// b变为默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要把中间的参数<code>b</code>变为“可选”参数，就只能通过<code>arguments</code>判断，然后重新调整参数并赋值。</p>
<h3 id="rest参数">rest参数</h3>
<p>由于JavaScript函数允许接收任意个参数，于是我们就不得不用<code>arguments</code>来获取所有参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i, rest = [];</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i&lt;<span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            rest.<span class="title function_">push</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a = &#x27;</span> + a);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b = &#x27;</span> + b);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(rest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了获取除了已定义参数<code>a</code>、<code>b</code>之外的参数，我们不得不用<code>arguments</code>，并且循环要从索引<code>2</code>开始以便排除前两个参数，这种写法很别扭，只是为了获得额外的<code>rest</code>参数，有没有更好的方法？</p>
<p>ES6标准引入了rest参数，上面的函数可以改写为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b, ...rest</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a = &#x27;</span> + a);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b = &#x27;</span> + b);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(rest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// Array [ 3, 4, 5 ]</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = undefined</span></span><br><span class="line"><span class="comment">// Array []</span></span><br></pre></td></tr></table></figure>
<p>rest参数只能写在最后，前面用<code>...</code>标识，从运行结果可知，传入的参数先绑定<code>a</code>、<code>b</code>，多余的参数以数组形式交给变量<code>rest</code>，所以，不再需要<code>arguments</code>我们就获取了全部参数。</p>
<p>如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是<code>undefined</code>）。</p>
<p>因为rest参数是ES6新标准，所以你需要测试一下浏览器是否支持。请用rest参数编写一个<code>sum()</code>函数，接收任意个参数并返回它们的和：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function sum(...rest) &#123;</span><br><span class="line">   ???</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试:</span><br><span class="line">let i, args = [];</span><br><span class="line">for (i=1; i&lt;=100; i++) &#123;</span><br><span class="line">    args.push(i);</span><br><span class="line">&#125;</span><br><span class="line">if (sum() !== 0) &#123;</span><br><span class="line">    console.log(&#x27;测试失败: sum() = &#x27; + sum());</span><br><span class="line">&#125; else if (sum(1) !== 1) &#123;</span><br><span class="line">    console.log(&#x27;测试失败: sum(1) = &#x27; + sum(1));</span><br><span class="line">&#125; else if (sum(2, 3) !== 5) &#123;</span><br><span class="line">    console.log(&#x27;测试失败: sum(2, 3) = &#x27; + sum(2, 3));</span><br><span class="line">&#125; else if (sum.apply(null, args) !== 5050) &#123;</span><br><span class="line">    console.log(&#x27;测试失败: sum(1, 2, 3, ..., 100) = &#x27; + sum.apply(null, args));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&#x27;测试通过!&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小心你的return语句">小心你的return语句</h3>
<p>前面我们讲到了JavaScript引擎有一个在行末自动添加分号的机制，这可能让你栽到return语句的一个大坑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// &#123; name: &#x27;foo&#x27; &#125;</span></span><br></pre></td></tr></table></figure>
<p>如果把return语句拆成两行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p><em>要小心了</em>，由于JavaScript引擎在行末自动添加分号的机制，上面的代码实际上变成了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 自动添加了分号，相当于return undefined;</span></span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span> &#125;; <span class="comment">// 这行语句已经没法执行到了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以正确的多行写法是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 这里不会自动加分号，因为&#123;表示语句尚未结束</span></span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习">练习</h3>
<p>定义一个计算圆面积的函数<code>area_of_circle()</code>，它有两个参数：</p>
<ul>
<li>r: 表示圆的半径；</li>
<li>pi: 表示π的值，如果不传，则默认3.14</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function area_of_circle(r, pi) &#123;</span><br><span class="line">    // FIXME:</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 测试:</span><br><span class="line">if (area_of_circle(2) === 12.56 &amp;&amp; area_of_circle(2, 3.1416) === 12.5664) &#123;</span><br><span class="line">    console.log(&#x27;测试通过&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&#x27;测试失败&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小明是一个JavaScript新手，他写了一个<code>max()</code>函数，返回两个数中较大的那个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function max(a, b) &#123;</span><br><span class="line">    if (a &gt; b) &#123;</span><br><span class="line">        return</span><br><span class="line">                a;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return</span><br><span class="line">                b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(max(15, 20));</span><br></pre></td></tr></table></figure>
<p>但是小明抱怨他的浏览器出问题了，无论传入什么数，<code>max()</code>函数总是返回<code>undefined</code>。请帮他指出问题并修复。</p>
<p>在JavaScript中，用<code>var</code>申明的变量实际上是有作用域的。</p>
<p>如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x = x + <span class="number">2</span>; <span class="comment">// ReferenceError! 无法在函数体外引用变量x</span></span><br></pre></td></tr></table></figure>
<p>如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    x = x + <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> y = x + <span class="number">1</span>; <span class="comment">// bar可以访问foo的变量x!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> z = y + <span class="number">1</span>; <span class="comment">// ReferenceError! foo不可以访问bar的变量y!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果内部函数和外部函数的变量名重名怎么办？来测试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    var x = 1;</span><br><span class="line">    function bar() &#123;</span><br><span class="line">        var x = &#x27;A&#x27;;</span><br><span class="line">        console.log(&#x27;x in bar() = &#x27; + x); // &#x27;A&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#x27;x in foo() = &#x27; + x); // 1</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>这说明JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。</p>
<h3 id="变量提升">变量提升</h3>
<p>JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有用<code>var</code>申明的变量“提升”到函数顶部：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">&#x27;Hello, &#x27;</span> + y;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">    <span class="keyword">var</span> y = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>
<p>虽然是strict模式，但语句<code>var x = 'Hello, ' + y;</code>并不报错，原因是变量<code>y</code>在稍后申明了。但是<code>console.log</code>显示<code>Hello, undefined</code>，说明变量<code>y</code>的值为<code>undefined</code>。这正是因为JavaScript引擎自动提升了变量<code>y</code>的声明，但不会提升变量<code>y</code>的赋值。</p>
<p>对于上述<code>foo()</code>函数，JavaScript引擎看到的代码相当于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> y; <span class="comment">// 提升变量y的申明，此时y为undefined</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">&#x27;Hello, &#x27;</span> + y;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">    y = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个<code>var</code>申明函数内部用到的所有变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        x = <span class="number">1</span>, <span class="comment">// x初始化为1</span></span><br><span class="line">        y = x + <span class="number">1</span>, <span class="comment">// y初始化为2</span></span><br><span class="line">        z, i; <span class="comment">// z和i为undefined</span></span><br><span class="line">    <span class="comment">// 其他语句:</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不需要兼容低版本浏览器，完全可以用<code>let</code>代替<code>var</code>来申明变量。</p>
<p>注意</p>
<p>建议使用let申明变量，避免var申明变量时带来的隐患。</p>
<h3 id="全局作用域">全局作用域</h3>
<p>不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象<code>window</code>，全局作用域的变量实际上被绑定到<code>window</code>的一个属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> course = <span class="string">&#x27;Learn JavaScript&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(course); <span class="comment">// &#x27;Learn JavaScript&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">course</span>); <span class="comment">// &#x27;Learn JavaScript&#x27;</span></span><br></pre></td></tr></table></figure>
<p>因此，直接访问全局变量<code>course</code>和访问<code>window.course</code>是完全一样的。</p>
<p>你可能猜到了，由于函数定义有两种方式，以变量方式<code>var foo = function () &#123;&#125;</code>定义的函数实际上也是一个全局变量，因此，顶层函数的定义也被视为一个全局变量，并绑定到<code>window</code>对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 直接调用foo()</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">foo</span>(); <span class="comment">// 通过window.foo()调用</span></span><br></pre></td></tr></table></figure>
<p>进一步大胆地猜测，我们每次直接调用的<code>alert()</code>函数其实也是<code>window</code>的一个变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.alert(&#x27;调用window.alert()&#x27;);</span><br><span class="line">// 把alert保存到另一个变量:</span><br><span class="line">let old_alert = window.alert;</span><br><span class="line">// 给alert赋一个新函数:</span><br><span class="line">window.alert = function () &#123;&#125;</span><br><span class="line"></span><br><span class="line">alert(&#x27;无法用alert()显示了!&#x27;);</span><br><span class="line"></span><br><span class="line">// 恢复alert:</span><br><span class="line">window.alert = old_alert;</span><br><span class="line">alert(&#x27;又可以用alert()了!&#x27;);</span><br></pre></td></tr></table></figure>
<p>这说明JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报<code>ReferenceError</code>错误。</p>
<h3 id="名字空间">名字空间</h3>
<p>全局变量会绑定到<code>window</code>上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。</p>
<p>减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唯一的全局变量MYAPP:</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable constant_">MYAPP</span> = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他变量:</span></span><br><span class="line"><span class="variable constant_">MYAPP</span>.<span class="property">name</span> = <span class="string">&#x27;myapp&#x27;</span>;</span><br><span class="line"><span class="variable constant_">MYAPP</span>.<span class="property">version</span> = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他函数:</span></span><br><span class="line"><span class="variable constant_">MYAPP</span>.<span class="property">foo</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>把自己的代码全部放入唯一的名字空间<code>MYAPP</code>中，会大大减少全局变量冲突的可能。</p>
<p>许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。</p>
<h3 id="局部作用域">局部作用域</h3>
<p>由于JavaScript的变量作用域实际上是函数内部，我们在<code>for</code>循环等语句块中是无法定义具有局部作用域的变量的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    i += <span class="number">100</span>; <span class="comment">// 仍然可以引用变量i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决块级作用域，ES6引入了新的关键字<code>let</code>，用<code>let</code>替代<code>var</code>可以申明一个块级作用域的变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// SyntaxError:</span></span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常量">常量</h3>
<p>由于<code>var</code>和<code>let</code>申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>
<p>ES6标准引入了新的关键字<code>const</code>来定义常量，<code>const</code>与<code>let</code>都具有块级作用域：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span>;</span><br><span class="line"><span class="variable constant_">PI</span> = <span class="number">3</span>; <span class="comment">// 某些浏览器不报错，但是无效果！</span></span><br><span class="line"><span class="variable constant_">PI</span>; <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>
<h3 id="解构赋值">解构赋值</h3>
<p>从ES6开始，JavaScript引入了解构赋值，可以同时对一组变量进行赋值。</p>
<p>什么是解构赋值？我们先看看传统的做法，如何把一个数组的元素分别赋值给几个变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;ES6&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> x = array[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> y = array[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> z = array[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>现在，在ES6中，可以使用解构赋值，直接对多个变量同时赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 如果浏览器支持解构赋值就不会报错:</span><br><span class="line">let [x, y, z] = [&#x27;hello&#x27;, &#x27;JavaScript&#x27;, &#x27;ES6&#x27;];</span><br><span class="line"></span><br><span class="line">// x, y, z分别被赋值为数组对应元素:</span><br><span class="line">console.log(`x = $&#123;x&#125;, y = $&#123;y&#125;, z = $&#123;z&#125;`);</span><br></pre></td></tr></table></figure>
<p>注意，对数组元素进行解构赋值时，多个变量要用<code>[...]</code>括起来。</p>
<p>如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, [y, z]] = [<span class="string">&#x27;hello&#x27;</span>, [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;ES6&#x27;</span>]];</span><br><span class="line">x; <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">y; <span class="comment">// &#x27;JavaScript&#x27;</span></span><br><span class="line">z; <span class="comment">// &#x27;ES6&#x27;</span></span><br></pre></td></tr></table></figure>
<p>解构赋值还可以忽略某些元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [, , z] = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;ES6&#x27;</span>]; <span class="comment">// 忽略前两个元素，只对z赋值第三个元素</span></span><br><span class="line">z; <span class="comment">// &#x27;ES6&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">    name: &#x27;小明&#x27;,</span><br><span class="line">    age: 20,</span><br><span class="line">    gender: &#x27;male&#x27;,</span><br><span class="line">    passport: &#x27;G-12345678&#x27;,</span><br><span class="line">    school: &#x27;No.4 middle school&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">let &#123;name, age, passport&#125; = person;</span><br><span class="line"></span><br><span class="line">// name, age, passport分别被赋值为对应属性:</span><br><span class="line">console.log(`name = $&#123;name&#125;, age = $&#123;age&#125;, passport = $&#123;passport&#125;`);</span><br></pre></td></tr></table></figure>
<p>对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    <span class="attr">passport</span>: <span class="string">&#x27;G-12345678&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;No.4 middle school&#x27;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">city</span>: <span class="string">&#x27;Beijing&#x27;</span>,</span><br><span class="line">        <span class="attr">street</span>: <span class="string">&#x27;No.1 Road&#x27;</span>,</span><br><span class="line">        <span class="attr">zipcode</span>: <span class="string">&#x27;100001&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;name, <span class="attr">address</span>: &#123;city, zip&#125;&#125; = person;</span><br><span class="line">name; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">city; <span class="comment">// &#x27;Beijing&#x27;</span></span><br><span class="line">zip; <span class="comment">// undefined, 因为属性名是zipcode而不是zip</span></span><br><span class="line"><span class="comment">// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:</span></span><br><span class="line">address; <span class="comment">// Uncaught ReferenceError: address is not defined</span></span><br></pre></td></tr></table></figure>
<p>使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为<code>undefined</code>，这和引用一个不存在的属性获得<code>undefined</code>是一致的。如果要使用的变量名和属性名不一致，可以用下面的语法获取：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    <span class="attr">passport</span>: <span class="string">&#x27;G-12345678&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;No.4 middle school&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把passport属性赋值给变量id:</span></span><br><span class="line"><span class="keyword">let</span> &#123;name, <span class="attr">passport</span>:id&#125; = person;</span><br><span class="line">name; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">id; <span class="comment">// &#x27;G-12345678&#x27;</span></span><br><span class="line"><span class="comment">// 注意: passport不是变量，而是为了让变量id获得passport属性:</span></span><br><span class="line">passport; <span class="comment">// Uncaught ReferenceError: passport is not defined</span></span><br></pre></td></tr></table></figure>
<p>解构赋值还可以使用默认值，这样就避免了不存在的属性返回<code>undefined</code>的问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    <span class="attr">passport</span>: <span class="string">&#x27;G-12345678&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果person对象没有single属性，默认赋值为true:</span></span><br><span class="line"><span class="keyword">let</span> &#123;name, single=<span class="literal">true</span>&#125; = person;</span><br><span class="line">name; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">single; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量:</span></span><br><span class="line"><span class="keyword">let</span> x, y;</span><br><span class="line"><span class="comment">// 解构赋值:</span></span><br><span class="line">&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;;</span><br><span class="line"><span class="comment">// 语法错误: Uncaught SyntaxError: Unexpected token =</span></span><br></pre></td></tr></table></figure>
<p>这是因为JavaScript引擎把<code>&#123;</code>开头的语句当作了块处理，于是<code>=</code>不再合法。解决方法是用小括号括起来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="使用场景">使用场景</h3>
<p>解构赋值在很多时候可以大大简化代码。例如，交换两个变量<code>x</code>和<code>y</code>的值，可以这么写，不再需要临时变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x=<span class="number">1</span>, y=<span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x]</span><br></pre></td></tr></table></figure>
<p>快速获取当前页面的域名和路径：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">hostname</span>:domain, <span class="attr">pathname</span>:path&#125; = location;</span><br></pre></td></tr></table></figure>
<p>如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个<code>Date</code>对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildDate</span>(<span class="params">&#123;year, month, day, hour=<span class="number">0</span>, minute=<span class="number">0</span>, second=<span class="number">0</span>&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">`<span class="subst">$&#123;year&#125;</span>-<span class="subst">$&#123;month&#125;</span>-<span class="subst">$&#123;day&#125;</span> <span class="subst">$&#123;hour&#125;</span>:<span class="subst">$&#123;minute&#125;</span>:<span class="subst">$&#123;second&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的方便之处在于传入的对象只需要<code>year</code>、<code>month</code>和<code>day</code>这三个属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">buildDate</span>(&#123; <span class="attr">year</span>: <span class="number">2017</span>, <span class="attr">month</span>: <span class="number">1</span>, <span class="attr">day</span>: <span class="number">1</span> &#125;);</span><br><span class="line"><span class="comment">// Sun Jan 01 2017 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p>也可以传入<code>hour</code>、<code>minute</code>和<code>second</code>属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">buildDate</span>(&#123; <span class="attr">year</span>: <span class="number">2017</span>, <span class="attr">month</span>: <span class="number">1</span>, <span class="attr">day</span>: <span class="number">1</span>, <span class="attr">hour</span>: <span class="number">20</span>, <span class="attr">minute</span>: <span class="number">15</span> &#125;);</span><br><span class="line"><span class="comment">// Sun Jan 01 2017 20:15:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p>使用解构赋值可以减少代码量，但是，需要在支持ES6解构赋值特性的现代浏览器中才能正常运行。目前支持解构赋值的浏览器包括Chrome，Firefox，Edge等。</p>
<p>在一个对象中绑定函数，称为这个对象的方法。</p>
<p>在JavaScript中，对象的定义是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是，如果我们给<code>xiaoming</code>绑定一个函数，就可以做更多的事情。比如，写个<code>age()</code>方法，返回<code>xiaoming</code>的年龄：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> y = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>();</span><br><span class="line">        <span class="keyword">return</span> y - <span class="variable language_">this</span>.<span class="property">birth</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="property">age</span>; <span class="comment">// function xiaoming.age()</span></span><br><span class="line">xiaoming.<span class="title function_">age</span>(); <span class="comment">// 今年调用是25,明年调用就变成26了</span></span><br></pre></td></tr></table></figure>
<p>绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个<code>this</code>关键字，这个东东是什么？</p>
<p>在一个方法内部，<code>this</code>是一个特殊变量，它始终指向当前对象，也就是<code>xiaoming</code>这个变量。所以，<code>this.birth</code>可以拿到<code>xiaoming</code>的<code>birth</code>属性。</p>
<p>让我们拆开写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="variable language_">this</span>.<span class="property">birth</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">age</span>: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="title function_">age</span>(); <span class="comment">// 25, 正常结果</span></span><br><span class="line"><span class="title function_">getAge</span>(); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>单独调用函数<code>getAge()</code>怎么返回了<code>NaN</code>？<em>请注意</em>，我们已经进入到了JavaScript的一个大坑里。</p>
<p>JavaScript的函数内部如果调用了<code>this</code>，那么这个<code>this</code>到底指向谁？</p>
<p>答案是，视情况而定！</p>
<p>如果以对象的方法形式调用，比如<code>xiaoming.age()</code>，该函数的<code>this</code>指向被调用的对象，也就是<code>xiaoming</code>，这是符合我们预期的。</p>
<p>如果单独调用函数，比如<code>getAge()</code>，此时，该函数的<code>this</code>指向全局对象，也就是<code>window</code>。</p>
<p>坑爹啊！</p>
<p>更坑爹的是，如果这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = xiaoming.<span class="property">age</span>; <span class="comment">// 先拿到xiaoming的age函数</span></span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>也是不行的！要保证<code>this</code>指向正确，必须用<code>obj.xxx()</code>的形式调用！</p>
<p>由于这是一个巨大的设计错误，要想纠正可没那么简单。ECMA决定，在strict模式下让函数的<code>this</code>指向<code>undefined</code>，因此，在strict模式下，你会得到一个错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> y = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>();</span><br><span class="line">        <span class="keyword">return</span> y - <span class="variable language_">this</span>.<span class="property">birth</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = xiaoming.<span class="property">age</span>;</span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// Uncaught TypeError: Cannot read property &#x27;birth&#x27; of undefined</span></span><br></pre></td></tr></table></figure>
<p>这个决定只是让错误及时暴露出来，并没有解决<code>this</code>应该指向的正确位置。</p>
<p>有些时候，喜欢重构的你把方法重构了一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">getAgeFromBirth</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> y = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>();</span><br><span class="line">            <span class="keyword">return</span> y - <span class="variable language_">this</span>.<span class="property">birth</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">getAgeFromBirth</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="title function_">age</span>(); <span class="comment">// Uncaught TypeError: Cannot read property &#x27;birth&#x27; of undefined</span></span><br></pre></td></tr></table></figure>
<p>结果又报错了！原因是<code>this</code>指针只在<code>age</code>方法的函数内指向<code>xiaoming</code>，在函数内部定义的函数，<code>this</code>又指向<code>undefined</code>了！（在非strict模式下，它重新指向全局对象<code>window</code>！）</p>
<p>修复的办法也不是没有，我们用一个<code>that</code>变量首先捕获<code>this</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="variable language_">this</span>; <span class="comment">// 在方法内部一开始就捕获this</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">getAgeFromBirth</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> y = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>();</span><br><span class="line">            <span class="keyword">return</span> y - that.<span class="property">birth</span>; <span class="comment">// 用that而不是this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">getAgeFromBirth</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="title function_">age</span>(); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<p>用<code>let that = this;</code>，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。</p>
<h3 id="apply">apply</h3>
<p>虽然在一个独立的函数调用中，根据是否是strict模式，<code>this</code>指向<code>undefined</code>或<code>window</code>，不过，我们还是可以控制<code>this</code>的指向的！</p>
<p>要指定函数的<code>this</code>指向哪个对象，可以用函数本身的<code>apply</code>方法，它接收两个参数，第一个参数就是需要绑定的<code>this</code>变量，第二个参数是<code>Array</code>，表示函数本身的参数。</p>
<p>用<code>apply</code>修复<code>getAge()</code>调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="variable language_">this</span>.<span class="property">birth</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">age</span>: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="title function_">age</span>(); <span class="comment">// 25</span></span><br><span class="line">getAge.<span class="title function_">apply</span>(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></span><br></pre></td></tr></table></figure>
<p>另一个与<code>apply()</code>类似的方法是<code>call()</code>，唯一区别是：</p>
<ul>
<li><code>apply()</code>把参数打包成<code>Array</code>再传入；</li>
<li><code>call()</code>把参数按顺序传入。</li>
</ul>
<p>比如调用<code>Math.max(3, 5, 4)</code>，分别用<code>apply()</code>和<code>call()</code>实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]); <span class="comment">// 5</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">call</span>(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>对普通函数调用，我们通常把<code>this</code>绑定为<code>null</code>。</p>
<h3 id="装饰器">装饰器</h3>
<p>利用<code>apply()</code>，我们还可以动态改变函数的行为。</p>
<p>JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。</p>
<p>现在假定我们想统计一下代码一共调用了多少次<code>parseInt()</code>，可以把所有的调用都找出来，然后手动加上<code>count += 1</code>，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的<code>parseInt()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line"></span><br><span class="line">let count = 0;</span><br><span class="line">let oldParseInt = parseInt; // 保存原函数</span><br><span class="line"></span><br><span class="line">window.parseInt = function () &#123;</span><br><span class="line">    count += 1;</span><br><span class="line">    return oldParseInt.apply(null, arguments); // 调用原函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 测试:</span><br><span class="line">parseInt(&#x27;10&#x27;);</span><br><span class="line">parseInt(&#x27;20&#x27;);</span><br><span class="line">parseInt(&#x27;30&#x27;);</span><br><span class="line">console.log(&#x27;count = &#x27; + count); // 3</span><br></pre></td></tr></table></figure>
<p>高阶函数英文叫Higher-order function。那么什么是高阶函数？</p>
<p>JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p>
<p>一个最简单的高阶函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y, f</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">f</span>(x) + <span class="title function_">f</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用<code>add(-5, 6, Math.abs)</code>时，参数<code>x</code>，<code>y</code>和<code>f</code>分别接收<code>-5</code>，<code>6</code>和函数<code>Math.abs</code>，根据函数定义，我们可以推导计算过程为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = -5;</span><br><span class="line">y = 6;</span><br><span class="line">f = Math.abs;</span><br><span class="line">f(x) + f(y) ==&gt; Math.abs(-5) + Math.abs(6) ==&gt; 11;</span><br><span class="line">return 11;</span><br></pre></td></tr></table></figure>
<p>用代码验证一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y, f) &#123;</span><br><span class="line">    return f(x) + f(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let x = add(-5, 6, Math.abs);</span><br><span class="line">console.log(x); // 11</span><br></pre></td></tr></table></figure>
<p>编写高阶函数，就是让函数的参数能够接收别的函数。</p>
<p>如果你读过Google的那篇大名鼎鼎的论文“<a target="_blank" rel="noopener" href="https://research.google/pubs/mapreduce-simplified-data-processing-on-large-clusters/">MapReduce: Simplified Data Processing on Large Clusters</a>”，你就能大概明白map/reduce的概念。</p>
<h3 id="map">map</h3>
<p>举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个数组<code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code>上，就可以用<code>map</code>实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">            f(x) = x * x</span><br><span class="line"></span><br><span class="line">                  │</span><br><span class="line">                  │</span><br><span class="line">  ┌───┬───┬───┬───┼───┬───┬───┬───┐</span><br><span class="line">  │   │   │   │   │   │   │   │   │</span><br><span class="line">  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼</span><br><span class="line"></span><br><span class="line">[ 1   2   3   4   5   6   7   8   9 ]</span><br><span class="line"></span><br><span class="line">  │   │   │   │   │   │   │   │   │</span><br><span class="line">  │   │   │   │   │   │   │   │   │</span><br><span class="line">  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼</span><br><span class="line"></span><br><span class="line">[ 1   4   9  16  25  36  49  64  81 ]</span><br></pre></td></tr></table></figure>
<p>由于<code>map()</code>方法定义在JavaScript的<code>Array</code>中，我们调用<code>Array</code>的<code>map()</code>方法，传入我们自己的函数，就得到了一个新的<code>Array</code>作为结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function pow(x) &#123;</span><br><span class="line">    return x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];</span><br><span class="line">let results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">console.log(results);</span><br></pre></td></tr></table></figure>
<p>注意：<code>map()</code>传入的参数是<code>pow</code>，即函数对象本身。</p>
<p>你可能会想，不需要<code>map()</code>，写一个循环，也可以计算出结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(<span class="title function_">f</span>(arr[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的确可以，但是，从上面的循环代码，我们无法一眼看明白“把f(x)作用在Array的每一个元素并把结果生成一个新的Array”。</p>
<p>所以，<code>map()</code>作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把<code>Array</code>的所有数字转为字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line">arr.<span class="title function_">map</span>(<span class="title class_">String</span>); <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>只需要一行代码。</p>
<h3 id="reduce">reduce</h3>
<p>再看reduce的用法。Array的<code>reduce()</code>把一个函数作用在这个<code>Array</code>的<code>[x1, x2, x3...]</code>上，这个函数必须接收两个参数，<code>reduce()</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x1, x2, x3, x4].<span class="title function_">reduce</span>(f) = <span class="title function_">f</span>(<span class="title function_">f</span>(<span class="title function_">f</span>(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure>
<p>比方说对一个<code>Array</code>求和，就可以用<code>reduce</code>实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<p>如果数组元素只有1个，那么还需要提供一个额外的初始参数以便至少凑够两：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">123</span>];</span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;, <span class="number">0</span>); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p>练习：利用<code>reduce()</code>求积：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function product(arr) &#123;</span><br><span class="line">    // FIXME:</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试:</span><br><span class="line">if (product([1, 2, 3, 4]) === 24 &amp;&amp; product([0, 1, 2]) === 0 &amp;&amp; product([99, 88, 77, 66]) === 44274384) &#123;</span><br><span class="line">    console.log(&#x27;测试通过!&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    console.log(&#x27;测试失败!&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要把<code>[1, 3, 5, 7, 9]</code>变换成整数13579，<code>reduce()</code>也能派上用场：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">10</span> + y;</span><br><span class="line">&#125;); <span class="comment">// 13579</span></span><br></pre></td></tr></table></figure>
<p>如果我们继续改进这个例子，想办法把一个字符串<code>13579</code>先变成<code>Array</code>——<code>[1, 3, 5, 7, 9]</code>，再利用<code>reduce()</code>就可以写出一个把字符串转换为Number的函数。</p>
<p>练习：不要使用JavaScript内置的<code>parseInt()</code>函数，利用map和reduce操作实现一个<code>string2int()</code>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function string2int(s) &#123;</span><br><span class="line">    // FIXME:</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试:</span><br><span class="line">if (string2int(&#x27;0&#x27;) === 0 &amp;&amp; string2int(&#x27;12345&#x27;) === 12345 &amp;&amp; string2int(&#x27;12300&#x27;) === 12300) &#123;</span><br><span class="line">    if (string2int.toString().indexOf(&#x27;parseInt&#x27;) !== -1) &#123;</span><br><span class="line">        console.log(&#x27;请勿使用parseInt()!&#x27;);</span><br><span class="line">    &#125; else if (string2int.toString().indexOf(&#x27;Number&#x27;) !== -1) &#123;</span><br><span class="line">        console.log(&#x27;请勿使用Number()!&#x27;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&#x27;测试通过!&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    console.log(&#x27;测试失败!&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习-2">练习</h3>
<p>请把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：<code>['adam', 'LISA', 'barT']</code>，输出：<code>['Adam', 'Lisa', 'Bart']</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function normalize(arr) &#123;</span><br><span class="line">    // FIXME:</span><br><span class="line">    return [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试:</span><br><span class="line">if (normalize([&#x27;adam&#x27;, &#x27;LISA&#x27;, &#x27;barT&#x27;]).toString() === [&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;].toString()) &#123;</span><br><span class="line">    console.log(&#x27;测试通过!&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    console.log(&#x27;测试失败!&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小明希望利用<code>map()</code>把字符串变成整数，他写的代码很简洁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;];</span><br><span class="line">let r;</span><br><span class="line"></span><br><span class="line">r = arr.map(parseInt);</span><br><span class="line">console.log(r);</span><br></pre></td></tr></table></figure>
<p>结果竟然是<code>1</code>, <code>NaN</code>, <code>NaN</code>，小明百思不得其解，请帮他找到原因并修正代码。</p>
<p>提示：参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">Array.prototype.map()的文档</a>。</p>
<p>原因分析:</p>
<p>由于map()接收的回调函数可以有3个参数：callback(currentValue, index, array)，通常我们仅需要第一个参数，而忽略了传入的后面两个参数。不幸的是，parseInt(string, radix)没有忽略第二个参数，导致实际执行的函数分别是：</p>
<p>parseInt(‘1’, 0); // 1, 按十进制转换<br>
parseInt(‘2’, 1); // NaN, 没有一进制<br>
parseInt(‘3’, 2); // NaN, 按二进制转换不允许出现3<br>
可以改为r = arr.map(Number);，因为Number(value)函数仅接收一个参数。</p>
<p>filter也是一个常用的操作，它用于把<code>Array</code>的某些元素过滤掉，然后返回剩下的元素。</p>
<p>和<code>map()</code>类似，<code>Array</code>的<code>filter()</code>也接收一个函数。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>true</code>还是<code>false</code>决定保留还是丢弃该元素。</p>
<p>例如，在一个<code>Array</code>中，删掉偶数，只保留奇数，可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">let</span> r = arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> !== <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line">r; <span class="comment">// [1, 5, 9, 15]</span></span><br></pre></td></tr></table></figure>
<p>把一个<code>Array</code>中的空字符串删掉，可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;  &#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> r = arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s &amp;&amp; s.<span class="title function_">trim</span>(); <span class="comment">// 注意：IE9以下的版本没有trim()方法</span></span><br><span class="line">&#125;);</span><br><span class="line">r; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>可见用<code>filter()</code>这个高阶函数，关键在于正确实现一个“筛选”函数。</p>
<h3 id="回调函数">回调函数</h3>
<p><code>filter()</code>接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示<code>Array</code>的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> r = arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">element, index, self</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(element); <span class="comment">// 依次打印&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(index); <span class="comment">// 依次打印0, 1, 2</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(self); <span class="comment">// self就是变量arr</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>利用<code>filter</code>，可以巧妙地去除<code>Array</code>的重复元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let</span><br><span class="line">    r,</span><br><span class="line">    arr = [&#x27;apple&#x27;, &#x27;strawberry&#x27;, &#x27;banana&#x27;, &#x27;pear&#x27;, &#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;orange&#x27;, &#x27;strawberry&#x27;];</span><br><span class="line"></span><br><span class="line">r = arr.filter(function (element, index, self) &#123;</span><br><span class="line">    return self.indexOf(element) === index;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(r);</span><br></pre></td></tr></table></figure>
<p>去除重复元素依靠的是<code>indexOf</code>总是返回第一个元素的位置，后续的重复元素位置与<code>indexOf</code>返回的位置不相等，因此被<code>filter</code>滤掉了。</p>
<h3 id="练习-3">练习</h3>
<p>请尝试用<code>filter()</code>筛选出素数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function get_primes(arr) &#123;</span><br><span class="line">    // FIXME:</span><br><span class="line">    return [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试:</span><br><span class="line">let</span><br><span class="line">    x,</span><br><span class="line">    r,</span><br><span class="line">    arr = [];</span><br><span class="line">for (x = 1; x &lt; 100; x++) &#123;</span><br><span class="line">    arr.push(x);</span><br><span class="line">&#125;</span><br><span class="line">r = get_primes(arr);</span><br><span class="line">if (r.toString() === [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97].toString()) &#123;</span><br><span class="line">    console.log(&#x27;测试通过!&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&#x27;测试失败: &#x27; + r.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序算法">排序算法</h3>
<p>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个对象呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。通常规定，对于两个元素<code>x</code>和<code>y</code>，如果认为<code>x &lt; y</code>，则返回<code>-1</code>，如果认为<code>x == y</code>，则返回<code>0</code>，如果认为<code>x &gt; y</code>，则返回<code>1</code>，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。</p>
<p>JavaScript的<code>Array</code>的<code>sort()</code>方法就是用于排序的，但是排序结果可能让你大吃一惊：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看上去正常的结果:</span></span><br><span class="line">[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Microsoft&#x27;</span>].<span class="title function_">sort</span>(); <span class="comment">// [&#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Microsoft&#x27;];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// apple排在了最后:</span></span><br><span class="line">[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;Microsoft&#x27;</span>].<span class="title function_">sort</span>(); <span class="comment">// [&#x27;Google&#x27;, &#x27;Microsoft&quot;, &#x27;apple&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法理解的结果:</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>].<span class="title function_">sort</span>(); <span class="comment">// [1, 10, 2, 20]</span></span><br></pre></td></tr></table></figure>
<p>第二个排序把<code>apple</code>排在了最后，是因为字符串根据ASCII码进行排序，而小写字母<code>a</code>的ASCII码在大写字母之后。</p>
<p>第三个排序结果是什么鬼？简单的数字排序都能错？</p>
<p>这是因为<code>Array</code>的<code>sort()</code>方法默认把所有元素先转换为String再排序，结果<code>'10'</code>排在了<code>'2'</code>的前面，因为字符<code>'1'</code>比字符<code>'2'</code>的ASCII码小。</p>
<p><img src="https://liaoxuefeng.com/books/javascript/function/higher-order-function/sort/douwo.jpg" alt="douwo"></p>
<p>如果不知道<code>sort()</code>方法的默认排序规则，直接对数字排序，绝对栽进坑里！</p>
<p>幸运的是，<code>sort()</code>方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。</p>
<p>要按数字大小排序，我们可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let arr = [10, 20, 1, 2];</span><br><span class="line"></span><br><span class="line">arr.sort(function (x, y) &#123;</span><br><span class="line">    if (x &lt; y) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (x &gt; y) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(arr); // [1, 2, 10, 20]</span><br></pre></td></tr></table></figure>
<p>如果要倒序排序，我们可以把大的数放前面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> y - x;</span><br><span class="line">&#125;); <span class="comment">// [20, 10, 2, 1]</span></span><br></pre></td></tr></table></figure>
<p>给<code>sort()</code>传入的比较函数接受<code>x</code>和<code>y</code>两个参数，如果<code>x&lt;y</code>，应返回负数，如果<code>x&gt;y</code>，应返回正数，如果<code>x=y</code>，应返回0。</p>
<p>默认情况下，对字符串排序，是按照ASCII的大小比较的，现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;Microsoft&#x27;</span>];</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">s1, s2</span>) &#123;</span><br><span class="line">    x1 = s1.<span class="title function_">toUpperCase</span>();</span><br><span class="line">    x2 = s2.<span class="title function_">toUpperCase</span>();</span><br><span class="line">    <span class="keyword">if</span> (x1 &lt; x2) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; x2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;); <span class="comment">// [&#x27;apple&#x27;, &#x27;Google&#x27;, &#x27;Microsoft&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。</p>
<p>从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。</p>
<p>最后友情提示，<code>sort()</code>方法会直接对<code>Array</code>进行修改，它返回的结果仍是当前<code>Array</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> a2 = a1.<span class="title function_">sort</span>();</span><br><span class="line">a1; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line">a2; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line">a1 === a2; <span class="comment">// true, a1和a2是同一对象</span></span><br></pre></td></tr></table></figure>
<h2 id="Array">Array</h2>
<p>对于数组，除了<code>map()</code>、<code>reduce</code>、<code>filter()</code>、<code>sort()</code>这些方法可以传入一个函数外，<code>Array</code>对象还提供了很多非常实用的高阶函数。</p>
<h3 id="every">every</h3>
<p><code>every()</code>方法可以判断数组的所有元素是否满足测试条件。</p>
<p>例如，给定一个包含若干字符串的数组，判断所有字符串是否满足指定的测试条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;];</span><br><span class="line">console.log(arr.every(function (s) &#123;</span><br><span class="line">    return s.length &gt; 0;</span><br><span class="line">&#125;)); // true, 因为每个元素都满足s.length&gt;0</span><br><span class="line"></span><br><span class="line">console.log(arr.every(function (s) &#123;</span><br><span class="line">    return s.toLowerCase() === s;</span><br><span class="line">&#125;)); // false, 因为不是每个元素都全部是小写</span><br></pre></td></tr></table></figure>
<h3 id="find">find</h3>
<p><code>find()</code>方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回<code>undefined</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;];</span><br><span class="line">console.log(arr.find(function (s) &#123;</span><br><span class="line">    return s.toLowerCase() === s;</span><br><span class="line">&#125;)); // &#x27;pear&#x27;, 因为pear全部是小写</span><br><span class="line"></span><br><span class="line">console.log(arr.find(function (s) &#123;</span><br><span class="line">    return s.toUpperCase() === s;</span><br><span class="line">&#125;)); // undefined, 因为没有全部是大写的元素</span><br></pre></td></tr></table></figure>
<h3 id="findIndex">findIndex</h3>
<p><code>findIndex()</code>和<code>find()</code>类似，也是查找符合条件的第一个元素，不同之处在于<code>findIndex()</code>会返回这个元素的索引，如果没有找到，返回<code>-1</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;];</span><br><span class="line">console.log(arr.findIndex(function (s) &#123;</span><br><span class="line">    return s.toLowerCase() === s;</span><br><span class="line">&#125;)); // 1, 因为&#x27;pear&#x27;的索引是1</span><br><span class="line"></span><br><span class="line">console.log(arr.findIndex(function (s) &#123;</span><br><span class="line">    return s.toUpperCase() === s;</span><br><span class="line">&#125;)); // -1</span><br></pre></td></tr></table></figure>
<h3 id="forEach">forEach</h3>
<p><code>forEach()</code>和<code>map()</code>类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。<code>forEach()</code>常用于遍历数组，因此，传入的函数不需要返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;];</span><br><span class="line">arr.forEach(x=&gt;console.log(x)); // 依次打印每个元素</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<h3 id="函数作为返回值">函数作为返回值</h3>
<p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<p>我们来实现一个对<code>Array</code>的求和。通常情况下，求和的函数是这样定义的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lazy_sum</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="title function_">lazy_sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// function sum()</span></span><br></pre></td></tr></table></figure>
<p>调用函数<code>f</code>时，才真正计算求和的结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">f</span>(); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们在函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。</p>
<p>请再注意一点，当我们调用<code>lazy_sum()</code>时，每次调用都会返回一个新的函数，即使传入相同的参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f1 = <span class="title function_">lazy_sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="keyword">let</span> f2 = <span class="title function_">lazy_sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">f1 === f2; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><code>f1()</code>和<code>f2()</code>的调用结果互不影响。</p>
<h3 id="闭包">闭包</h3>
<p>注意到返回的函数在其定义内部引用了局部变量<code>arr</code>，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。</p>
<p>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了<code>f()</code>才执行。我们来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">        arr.<span class="title function_">push</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i * i;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> results = <span class="title function_">count</span>();</span><br><span class="line"><span class="keyword">let</span> [f1, f2, f3] = results;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个<code>Array</code>中返回了。</p>
<p>你可能认为调用<code>f1()</code>，<code>f2()</code>和<code>f3()</code>结果应该是<code>1</code>，<code>4</code>，<code>9</code>，但实际结果是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">f1</span>(); <span class="comment">// 16</span></span><br><span class="line"><span class="title function_">f2</span>(); <span class="comment">// 16</span></span><br><span class="line"><span class="title function_">f3</span>(); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>
<p>全部都是<code>16</code>！原因就在于返回的函数引用了用<code>var</code>定义的变量<code>i</code>，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量<code>i</code>已经变成了<code>4</code>，因此最终结果为<code>16</code>。</p>
<p>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>
<p>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">        arr.<span class="title function_">push</span>((<span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> n * n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [f1, f2, f3] = <span class="title function_">count</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">f1</span>(); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">f2</span>(); <span class="comment">// 4</span></span><br><span class="line"><span class="title function_">f3</span>(); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<p>注意这里用了一个“创建一个匿名函数并立刻执行”的语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;)(<span class="number">3</span>); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<p>理论上讲，创建一个匿名函数并立刻执行可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params">x</span>) &#123; <span class="keyword">return</span> x * x &#125; (<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>但是由于JavaScript语法解析的问题，会报SyntaxError错误，因此需要用括号把整个函数定义括起来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">x</span>) &#123; <span class="keyword">return</span> x * x &#125;) (<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>通常，一个立即执行的匿名函数可以把函数体拆开，一般这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;)(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>另一个方法是把循环变量<code>i</code>用<code>let</code>定义在<code>for</code>循环体中，<code>let</code>作用域决定了在每次循环时都会绑定新的<code>i</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">        arr.<span class="title function_">push</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i * i;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但如果<code>i</code>定义在<code>for</code>循环外面，则仍然是错误的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">let</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">        arr.<span class="title function_">push</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i * i;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，最好的办法还是返回函数不要引用任何循环变量。</p>
<p>说了这么多，难道闭包就是为了返回一个函数然后延迟执行吗？</p>
<p>当然不是！闭包有非常强大的功能。举个栗子：</p>
<p>在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用<code>private</code>修饰一个成员变量。</p>
<p>在没有<code>class</code>机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">create_counter</span>(<span class="params">initial</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = initial || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">inc</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            x += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它用起来像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c1 = <span class="title function_">create_counter</span>();</span><br><span class="line">c1.<span class="title function_">inc</span>(); <span class="comment">// 1</span></span><br><span class="line">c1.<span class="title function_">inc</span>(); <span class="comment">// 2</span></span><br><span class="line">c1.<span class="title function_">inc</span>(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c2 = <span class="title function_">create_counter</span>(<span class="number">10</span>);</span><br><span class="line">c2.<span class="title function_">inc</span>(); <span class="comment">// 11</span></span><br><span class="line">c2.<span class="title function_">inc</span>(); <span class="comment">// 12</span></span><br><span class="line">c2.<span class="title function_">inc</span>(); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
<p>在返回的对象中，实现了一个闭包，该闭包携带了局部变量<code>x</code>，并且，从外部代码根本无法访问到变量<code>x</code>。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。</p>
<p>闭包还可以把多参数的函数变成单参数的函数。例如，要计算xy可以用<code>Math.pow(x, y)</code>函数，不过考虑到经常计算x2或x3，我们可以利用闭包创建新的函数<code>pow2</code>和<code>pow3</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function make_pow(n) &#123;</span><br><span class="line">    return function (x) &#123;</span><br><span class="line">        return Math.pow(x, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建两个新函数:</span><br><span class="line">let pow2 = make_pow(2);</span><br><span class="line">let pow3 = make_pow(3);</span><br><span class="line"></span><br><span class="line">console.log(pow2(5)); // 25</span><br><span class="line">console.log(pow3(7)); // 343</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://weibo.com/liaoxuefeng"><img src="http://thirdqq.qlogo.cn/ek_qqapp/AQVJKMtqeFCGNEZqicOj7qb7mnpcJiaZNlEOf0iasx2DicuEycbIG9cQktWUBxWR1dFWfLMI2Ilt/100" alt=""></a></p>
<p><a target="_blank" rel="noopener" href="https://weibo.com/liaoxuefeng">廖雪峰</a><a target="_blank" rel="noopener" href="https://github.com/michaelliao"></a><a target="_blank" rel="noopener" href="https://weibo.com/liaoxuefeng"></a><a target="_blank" rel="noopener" href="https://zhihu.com/people/liaoxuefeng"></a><a target="_blank" rel="noopener" href="https://twitter.com/liaoxuefeng"></a><br>
资深软件开发工程师，业余马拉松选手。</p>
<p>ES6标准新增了一种新的函数：箭头函数（Arrow Function）。</p>
<p>为什么叫箭头函数？因为它的定义用的就是一个箭头：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; x * x</span><br></pre></td></tr></table></figure>
<p>上面的箭头函数相当于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在继续学习箭头函数之前，请测试你的浏览器是否支持ES6的Arrow Function：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let fn = x =&gt; x * x;</span><br><span class="line">console.log(&#x27;你的浏览器支持ES6的Arrow Function!&#x27;);</span><br></pre></td></tr></table></figure>
<p>箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连<code>&#123; ... &#125;</code>和<code>return</code>都省略掉了。还有一种可以包含多条语句，这时候就不能省略<code>&#123; ... &#125;</code>和<code>return</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> - x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果参数不是一个，就需要用括号<code>()</code>括起来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个参数:</span></span><br><span class="line">(x, y) =&gt; x * x + y * y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数:</span></span><br><span class="line">() =&gt; <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数:</span></span><br><span class="line">(x, y, ...rest) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i, sum = x + y;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;rest.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        sum += rest[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SyntaxError:</span></span><br><span class="line">x =&gt; &#123; <span class="attr">foo</span>: x &#125;</span><br></pre></td></tr></table></figure>
<p>因为和函数体的<code>&#123; ... &#125;</code>有语法冲突，所以要改为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok:</span></span><br><span class="line">x =&gt; (&#123; <span class="attr">foo</span>: x &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="this">this</h3>
<p>箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的<code>this</code>是词法作用域，由上下文确定。</p>
<p>回顾前面的例子，由于JavaScript函数对<code>this</code>绑定的错误处理，下面的例子无法得到预期结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">getAge</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> b = <span class="variable language_">this</span>.<span class="property">birth</span>; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">let</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>() - <span class="variable language_">this</span>.<span class="property">birth</span>; <span class="comment">// this指向window或undefined</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在，箭头函数完全修复了<code>this</code>的指向，<code>this</code>总是指向词法作用域，也就是外层调用者<code>obj</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">getAge</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> b = <span class="variable language_">this</span>.<span class="property">birth</span>; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>() - <span class="variable language_">this</span>.<span class="property">birth</span>; <span class="comment">// this指向obj对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">getAge</span>(); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<p>如果使用箭头函数，以前的那种hack写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> that = <span class="variable language_">this</span>;</span><br></pre></td></tr></table></figure>
<p>就不再需要了。</p>
<p>由于<code>this</code>在箭头函数中已经按照词法作用域绑定了，所以，用<code>call()</code>或者<code>apply()</code>调用箭头函数时，无法对<code>this</code>进行绑定，即传入的第一个参数被忽略：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">getAge</span>: <span class="keyword">function</span> (<span class="params">year</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> b = <span class="variable language_">this</span>.<span class="property">birth</span>; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params">y</span>) =&gt; y - <span class="variable language_">this</span>.<span class="property">birth</span>; <span class="comment">// this.birth仍是1990</span></span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">call</span>(&#123;<span class="attr">birth</span>:<span class="number">2000</span>&#125;, year);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">getAge</span>(<span class="number">2015</span>); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<h3 id="练习-4">练习</h3>
<p>请使用箭头函数简化排序时传入的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [10, 20, 1, 2];</span><br><span class="line">arr.sort((x, y) =&gt; &#123;</span><br><span class="line">    ???</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr); // [1, 2, 10, 20]</span><br></pre></td></tr></table></figure>
<h2 id="标签函数">标签函数</h2>
<p><a target="_blank" rel="noopener" href="https://weibo.com/liaoxuefeng"><img src="http://thirdqq.qlogo.cn/ek_qqapp/AQVJKMtqeFCGNEZqicOj7qb7mnpcJiaZNlEOf0iasx2DicuEycbIG9cQktWUBxWR1dFWfLMI2Ilt/100" alt=""></a></p>
<p><a target="_blank" rel="noopener" href="https://weibo.com/liaoxuefeng">廖雪峰</a><a target="_blank" rel="noopener" href="https://github.com/michaelliao"></a><a target="_blank" rel="noopener" href="https://weibo.com/liaoxuefeng"></a><a target="_blank" rel="noopener" href="https://zhihu.com/people/liaoxuefeng"></a><a target="_blank" rel="noopener" href="https://twitter.com/liaoxuefeng"></a><br>
资深软件开发工程师，业余马拉松选手。</p>
<p>前面我们介绍了<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/quick-start/string/index.html">模板字符串</a>，它可以非常方便地引用变量，并合并出最终的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let name = &#x27;小明&#x27;;</span><br><span class="line">let age = 20;</span><br><span class="line">let s = `你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`;</span><br><span class="line">console.log(s);</span><br></pre></td></tr></table></figure>
<p>对于模板字符串，除了方便引用变量构造字符串外，还有一种更强大的功能，即可以使用标签函数（Tag Function）。</p>
<p>什么是标签函数？让我们看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const email = &quot;test@example.com&quot;;</span><br><span class="line">const password = &#x27;hello123&#x27;;</span><br><span class="line"></span><br><span class="line">function sql(strings, ...exps) &#123;</span><br><span class="line">    console.log(`SQL: $&#123;strings.join(&#x27;?&#x27;)&#125;`);</span><br><span class="line">    console.log(`SQL parameters: $&#123;JSON.stringify(exps)&#125;`);</span><br><span class="line">    return &#123;</span><br><span class="line">        name: &#x27;小明&#x27;,</span><br><span class="line">        age: 20</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const result = sql`SELECT * FROM users WHERE email=$&#123;email&#125; AND password=$&#123;password&#125;`;</span><br><span class="line"></span><br><span class="line">console.log(JSON.stringify(result));</span><br></pre></td></tr></table></figure>
<p>这里出现了一个奇怪的语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sql<span class="string">`SELECT * FROM users WHERE email=<span class="subst">$&#123;email&#125;</span> AND password=<span class="subst">$&#123;password&#125;</span>`</span></span><br></pre></td></tr></table></figure>
<p>模板字符串前面以<code>sql</code>开头，实际上这是一个标签函数，上述语法会自动转换为对<code>sql()</code>函数的调用。我们关注的是，传入<code>sql()</code>函数的参数是什么。</p>
<p><code>sql()</code>函数实际上接收两个参数：</p>
<p>第一个参数<code>strings</code>是一个字符串数组，它是<code>[&quot;SELECT * FROM users WHERE email=&quot;, &quot; AND password=&quot;, &quot;&quot;]</code>，即除去<code>$&#123;xxx&#125;</code>剩下的字符组成的数组；</p>
<p>第二个参数<code>...exps</code>是一个可变参数，它接收的也是一个数组，但数组的内容是由模板字符串里所有的<code>$&#123;xxx&#125;</code>的实际值组成，即<code>[&quot;test@example.com&quot;, &quot;hello123&quot;]</code>，因为解析<code>$&#123;email&#125;</code>得到<code>&quot;test@example.com&quot;</code>，解析<code>$&#123;password&#125;</code>得到<code>&quot;hello123&quot;</code>。</p>
<p>标签函数<code>sql()</code>实际上是一个普通函数，我们在内部把<code>strings</code>拼接成一个SQL字符串，把<code>...exps</code>作为参数，就可以实现一个安全的SQL查询，并返回查询结果。此处并没有真正的数据库连接，因此返回一个固定的Object。</p>
<p>标签函数和普通函数的定义区别仅仅在于参数，如果我们想对数据库进行修改，完全可以定义一个标签函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">update</span>(<span class="params">strings, ...exps</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sql = strings.<span class="title function_">join</span>(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">    <span class="comment">// 执行数据库更新</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数调用可以简化为带标签的模板字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">let</span> score = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">update<span class="string">`UPDATE users SET age=<span class="subst">$&#123;age&#125;</span>, score=<span class="subst">$&#123;score&#125;</span> WHERE id=<span class="subst">$&#123;id&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
<p>是不是非常简洁？</p>
<hr>
<hr>
<p><a target="_blank" rel="noopener" href="https://weibo.com/liaoxuefeng"><img src="http://thirdqq.qlogo.cn/ek_qqapp/AQVJKMtqeFCGNEZqicOj7qb7mnpcJiaZNlEOf0iasx2DicuEycbIG9cQktWUBxWR1dFWfLMI2Ilt/100" alt=""></a></p>
<p><a target="_blank" rel="noopener" href="https://weibo.com/liaoxuefeng">廖雪峰</a><a target="_blank" rel="noopener" href="https://github.com/michaelliao"></a><a target="_blank" rel="noopener" href="https://weibo.com/liaoxuefeng"></a><a target="_blank" rel="noopener" href="https://zhihu.com/people/liaoxuefeng"></a><a target="_blank" rel="noopener" href="https://twitter.com/liaoxuefeng"></a><br>
资深软件开发工程师，业余马拉松选手。</p>
<p>生成器（generator）是ES6标准引入的新的数据类型。一个生成器看上去像一个函数，但可以返回多次。</p>
<p>ES6定义生成器标准的哥们借鉴了Python的generator的概念和语法，如果你对Python的generator很熟悉，那么ES6的generator就是小菜一碟了。如果你对Python还不熟，赶快恶补<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/index.html">Python教程</a>！。</p>
<p>我们先复习函数的概念。一个函数是一段完整的代码，调用一个函数就是传入参数，然后返回结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r = <span class="title function_">foo</span>(<span class="number">1</span>); <span class="comment">// 调用foo函数</span></span><br></pre></td></tr></table></figure>
<p>函数在执行过程中，如果没有遇到<code>return</code>语句（函数末尾如果没有<code>return</code>，就是隐含的<code>return undefined;</code>），控制权无法交回被调用的代码。</p>
<p>generator跟函数很像，定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>generator和函数不同的是，generator由<code>function*</code>定义（注意多出的<code>*</code>号），并且，除了<code>return</code>语句，还可以用<code>yield</code>返回多次。</p>
<p>大多数同学立刻就晕了，generator就是能够返回多次的“函数”？返回多次有啥用？</p>
<p>还是举个栗子吧。</p>
<p>我们以一个著名的斐波那契数列为例，它由<code>0</code>，<code>1</code>开头：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> ...</span><br></pre></td></tr></table></figure>
<p>要编写一个产生斐波那契数列的函数，可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">max</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span></span><br><span class="line">        t,</span><br><span class="line">        a = <span class="number">0</span>,</span><br><span class="line">        b = <span class="number">1</span>,</span><br><span class="line">        arr = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (arr.<span class="property">length</span> &lt; max) &#123;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">        arr.<span class="title function_">push</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试:</span></span><br><span class="line"><span class="title function_">fib</span>(<span class="number">5</span>); <span class="comment">// [0, 1, 1, 2, 3]</span></span><br><span class="line"><span class="title function_">fib</span>(<span class="number">10</span>); <span class="comment">// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span><br></pre></td></tr></table></figure>
<p>函数只能返回一次，所以必须返回一个<code>Array</code>。但是，如果换成generator，就可以一次返回一个数，不断返回多次。用generator改写如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">fib</span>(<span class="params">max</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span></span><br><span class="line">        t,</span><br><span class="line">        a = <span class="number">0</span>,</span><br><span class="line">        b = <span class="number">1</span>,</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; max) &#123;</span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">        n ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用试试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fib</span>(<span class="number">5</span>); <span class="comment">// fib &#123;[[GeneratorStatus]]: &quot;suspended&quot;, [[GeneratorReceiver]]: Window&#125;</span></span><br></pre></td></tr></table></figure>
<p>直接调用一个generator和调用函数不一样，<code>fib(5)</code>仅仅是创建了一个generator对象，还没有去执行它。</p>
<p>调用generator对象有两个方法，一是不断地调用generator对象的<code>next()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="title function_">fib</span>(<span class="number">5</span>);</span><br><span class="line">f.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 0, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>next()</code>方法会执行generator的代码，然后，每次遇到<code>yield x;</code>就返回一个对象<code>&#123;value: x, done: true/false&#125;</code>，然后“暂停”。返回的<code>value</code>就是<code>yield</code>的返回值，<code>done</code>表示这个generator是否已经执行结束了。如果<code>done</code>为<code>true</code>，则<code>value</code>就是<code>return</code>的返回值。</p>
<p>当执行到<code>done</code>为<code>true</code>时，这个generator对象就已经全部执行完毕，不要再继续调用<code>next()</code>了。</p>
<p>第二个方法是直接用<code>for ... of</code>循环迭代generator对象，这种方式不需要我们自己判断<code>done</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function* fib(max) &#123;</span><br><span class="line">    let</span><br><span class="line">        a = 0,</span><br><span class="line">        b = 1,</span><br><span class="line">        n = 0;</span><br><span class="line">    while (n &lt; max) &#123;</span><br><span class="line">        yield a;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">        n ++;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let x of fib(10)) &#123;</span><br><span class="line">    console.log(x); // 依次输出0, 1, 1, 2, 3, ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>generator和普通函数相比，有什么用？</p>
<p>因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。例如，用一个对象来保存状态，得这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fib = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">n</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">max</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span></span><br><span class="line">            r = <span class="variable language_">this</span>.<span class="property">a</span>,</span><br><span class="line">            t = <span class="variable language_">this</span>.<span class="property">a</span> + <span class="variable language_">this</span>.<span class="property">b</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">a</span> = <span class="variable language_">this</span>.<span class="property">b</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">b</span> = t;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">n</span> &lt; <span class="variable language_">this</span>.<span class="property">max</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">n</span> ++;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用对象的属性来保存状态，相当繁琐。</p>
<p>generator还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。这个好处要等到后面学了AJAX以后才能体会到。</p>
<p>没有generator之前的黑暗时代，用AJAX时需要这么写代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">ajax</span>(<span class="string">&#x27;http://url-1&#x27;</span>, data1, <span class="keyword">function</span> (<span class="params">err, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">handle</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">ajax</span>(<span class="string">&#x27;http://url-2&#x27;</span>, data2, <span class="keyword">function</span> (<span class="params">err, result</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">handle</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">ajax</span>(<span class="string">&#x27;http://url-3&#x27;</span>, data3, <span class="keyword">function</span> (<span class="params">err, result</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">handle</span>(err);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">success</span>(result);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>回调越多，代码越难看。</p>
<p>有了generator的美好时代，用AJAX时可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    r1 = <span class="keyword">yield</span> <span class="title function_">ajax</span>(<span class="string">&#x27;http://url-1&#x27;</span>, data1);</span><br><span class="line">    r2 = <span class="keyword">yield</span> <span class="title function_">ajax</span>(<span class="string">&#x27;http://url-2&#x27;</span>, data2);</span><br><span class="line">    r3 = <span class="keyword">yield</span> <span class="title function_">ajax</span>(<span class="string">&#x27;http://url-3&#x27;</span>, data3);</span><br><span class="line">    <span class="title function_">success</span>(r3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="title function_">handle</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上去是同步的代码，实际执行是异步的。</p>
<h3 id="练习-5">练习</h3>
<p>要生成一个自增的ID，可以编写一个<code>next_id()</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> current_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">next_id</span>(<span class="params"></span>) &#123;</span><br><span class="line">    current_id ++;</span><br><span class="line">    <span class="keyword">return</span> current_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于函数无法保存状态，故需要一个全局变量<code>current_id</code>来保存数字。</p>
<p>不用闭包，试用generator改写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function* next_id() &#123;</span><br><span class="line">    ???</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试:</span><br><span class="line">let</span><br><span class="line">    x,</span><br><span class="line">    pass = true,</span><br><span class="line">    g = next_id();</span><br><span class="line">for (x = 1; x &lt; 100; x ++) &#123;</span><br><span class="line">    if (g.next().value !== x) &#123;</span><br><span class="line">        pass = false;</span><br><span class="line">        console.log(&#x27;测试失败!&#x27;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if (pass) &#123;</span><br><span class="line">    console.log(&#x27;测试通过!&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">標籤</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/JavaScript/" rel="tag">JavaScript</a> <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JavaScript-%E6%A0%87%E5%87%86%E5%AF%B9%E8%B1%A1/"
                    data-tooltip="JavaScript-标准对象"
                    aria-label="上一篇: JavaScript-标准对象"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JavaScript-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"
                    data-tooltip="JavaScript-快速入门"
                    aria-label="下一篇: JavaScript-快速入门"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E5%87%BD%E6%95%B0/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E5%87%BD%E6%95%B0/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E5%87%BD%E6%95%B0/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E5%87%BD%E6%95%B0/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JavaScript-%E6%A0%87%E5%87%86%E5%AF%B9%E8%B1%A1/"
                    data-tooltip="JavaScript-标准对象"
                    aria-label="上一篇: JavaScript-标准对象"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JavaScript-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"
                    data-tooltip="JavaScript-快速入门"
                    aria-label="下一篇: JavaScript-快速入门"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E5%87%BD%E6%95%B0/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E5%87%BD%E6%95%B0/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E5%87%BD%E6%95%B0/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E5%87%BD%E6%95%B0/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E5%87%BD%E6%95%B0/"
                        aria-label="分享到 Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E5%87%BD%E6%95%B0/"
                        aria-label="分享到 Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E5%87%BD%E6%95%B0/"
                        aria-label="global.share_on_linkedin"
                    >
                        <i class="fab fa-linkedin" aria-hidden="true"></i><span>global.share_on_linkedin</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-%E5%87%BD%E6%95%B0/"
                        aria-label="分享到 Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 199 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
