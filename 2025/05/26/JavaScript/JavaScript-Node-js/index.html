
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>JavaScript-Node.js - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg"},"articleBody":"从本章开始，我们就正式开启JavaScript的后端开发之旅。\nNode.js是目前非常火热的技术，但是它的诞生经历却很奇特。\n众所周知，在Netscape设计出JavaScript后的短短几个月，JavaScript事实上已经是前端开发的唯一标准。\n后来，微软通过IE击败了Netscape后一统桌面，结果几年时间，浏览器毫无进步。\n没有竞争就没有发展。微软认为IE6浏览器已经非常完善，几乎没有可改进之处，然后解散了IE6开发团队！而Google却认为支持现代Web应用的新一代浏览器才刚刚起步，尤其是浏览器负责运行JavaScript的引擎性能还可提升10倍。\n先是Mozilla借助已壮烈牺牲的Netscape遗产在2002年推出了Firefox浏览器，紧接着Apple于2003年在开源的KHTML浏览器的基础上推出了WebKit内核的Safari浏览器，不过仅限于Mac平台。\n随后，Google也开始创建自家的浏览器。他们也看中了WebKit内核，于是基于WebKit内核推出了Chrome浏览器。\nChrome浏览器是跨Windows和Mac平台的，并且，Google认为要运行现代Web应用，浏览器必须有一个性能非常强劲的JavaScript引擎，于是Google自己开发了一个高性能JavaScript引擎，名字叫V8，以BSD许可证开源。\n现代浏览器大战让微软的IE浏览器远远地落后了，因为他们解散了最有经验、战斗力最强的浏览器团队！回过头再追赶却发现，支持HTML5的WebKit已经成为手机端的标准了，IE浏览器从此与主流移动端设备绝缘。\n浏览器大战和Node有何关系？\n话说有个叫Ryan Dahl的歪果仁，他的工作是用C/C++写高性能Web服务。对于高性能，异步IO、事件驱动是基本原则，但是用C/C++写就太痛苦了。于是这位仁兄开始设想用高级语言开发Web服务。他评估了很多种高级语言，发现很多语言虽然同时提供了同步IO和异步IO，但是开发人员一旦用了同步IO，他们就再也懒得写异步IO了，所以，最终，Ryan瞄向了JavaScript。\n因为JavaScript是单线程执行，根本不能进行同步IO操作，所以，JavaScript的这一“缺陷”导致了它只能使用异步IO。\n选定了开发语言，还要有运行时引擎。这位仁兄曾考虑过自己写一个，不过明智地放弃了，因为V8就是开源的JavaScript引擎。让Google投资去优化V8，咱只负责改造一下拿来用，还不用付钱，这个买卖很划算。\n于是在2009年，Ryan正式推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为Node.js。虽然名字很土，但是，Node第一次把JavaScript带入到后端服务器开发，加上世界上已经有无数的JavaScript开发人员，所以Node一下子就火了起来。\n在Node上运行的JavaScript相比其他后端开发语言有何优势？\n最大的优势是借助JavaScript天生的事件驱动机制加V8高性能引擎，使编写高性能Web服务轻而易举。\n其次，JavaScript语言本身是完善的函数式语言，在前端开发时，开发人员往往写得比较随意，让人感觉JavaScript就是个“玩具语言”。但是，在Node环境下，通过模块化的JavaScript代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的ECMAScript 6标准，可以完全满足工程上的需求。\n由于Node.js平台是在后端运行JavaScript代码，所以，必须首先在本机安装Node环境。\n安装Node.js\n目前Node.js的最新版本是22.3.0，LTS版本是20.14.0，追求稳定性如服务器上长期运行的Node环境可以选择LTS版本，本地开发和测试可以选择最新版本。\n要安装Node.js，首先，从Node.js官网下载对应平台的安装程序，初学者建议选择Prebuilt Installer，选择版本，再选操作系统，最后选CPU类型后点Download下载：\n\n有经验的开发者可以选择Package Manager，它允许本地安装多个不同版本的Node并切换至不同版本。\n在Windows上安装时务必选择全部组件，包括勾选Add to Path。\n安装完成后，在Windows环境下，请打开命令提示符，然后输入node -v，如果安装正常，你应该看到v22.3.0这样的输出：\n12C:\\Users\\IEUser&gt; node -vv22.3.0\n继续在命令提示符输入node，此刻你将进入Node.js的交互环境。在交互环境下，你可以输入任意JavaScript语句，例如100+200，回车后将得到输出结果。\n要退出Node.js环境，连按两次Ctrl+C。\nnpm\n在正式开始Node.js学习之前，我们先认识一下npm。\nnpm是什么东东？npm其实是Node.js的包管理工具（package manager）。\n为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。\n更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。\n讲了这么多，npm究竟在哪？\n其实npm已经在Node.js安装的时候顺带装好了。我们在命令提示符或者终端输入npm -v，应该看到类似的输出：\n12C:\\&gt;npm -v10.8.0\n如果直接输入npm，你会看到类似下面的输出：\n123456C:\\&gt; npmUsage: npm &lt;command&gt;where &lt;command&gt; is one of:    ...\n上面的一大堆文字告诉你，npm需要跟上命令。现在我们不用关心这些命令，后面会一一讲到。目前，你只需要确保npm正确安装了，能运行就行。\n小结\n请在本机安装Node.js环境，并确保node和npm能正常运行。\n在前面的所有章节中，我们编写的JavaScript代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。\n从本章开始，我们编写的JavaScript代码将不能在浏览器环境中执行了，而是在Node环境中执行，因此，JavaScript代码将直接在你的计算机上以命令行的方式运行，所以，我们要先选择一个文本编辑器来编写JavaScript代码，并且把它保存到本地硬盘的某个目录，才能够执行。\n那么问题来了：文本编辑器到底哪家强？\n首先，请注意，绝对不能用Word和写字板。Word和写字板保存的不是纯文本文件。如果我们要用记事本来编写JavaScript代码，要务必注意，记事本以UTF-8格式保存文件时，会自作聪明地在文件开始的地方加上几个特殊字符（UTF-8 BOM），结果经常会导致程序运行出现莫名其妙的错误。\n所以，用记事本写代码时请注意，保存文件时使用ANSI编码，并且暂时不要输入中文。\n如果你的电脑上已经安装了Visual Studio Code，也可以用来编写JavaScript代码，注意用UTF-8格式保存。\n输入以下代码：\n12&#x27;use strict&#x27;;console.log(&#x27;Hello, world.&#x27;);\n第一行总是写上'use strict';是因为我们总是以严格模式运行JavaScript代码，避免各种潜在陷阱。\n然后，选择一个目录，例如C:\\Workspace，把文件保存为hello.js，就可以打开命令行窗口，把当前目录切换到hello.js所在目录，然后输入以下命令运行这个程序了：\n12C:\\Workspace&gt; node hello.jsHello, world.\n也可以保存为别的名字，比如first.js，但是必须要以.js结尾。此外，文件名只能是英文字母、数字和下划线的组合。\n如果当前目录下没有hello.js这个文件，运行node hello.js就会报错：\n1234567C:\\Workspace&gt; node hello.jsnode:internal/modules/cjs/loader:1227    throw err;          ^Error: Cannot find module &#x27;C:\\Workspace\\hello.js&#x27;    at Module._resolveFilename    ...\n报错的意思就是，没有找到hello.js这个文件，因为文件不存在。这个时候，就要检查一下当前目录下是否有这个文件了。\n命令行模式和Node交互模式\n请注意区分命令行模式和Node交互模式。\n看到类似PS C:\\&gt;是在Windows提供的命令行模式：\n123456789101112┌─────────────────────────────────────────────────────────┐│Windows PowerShell                                 - □ x │├─────────────────────────────────────────────────────────┤│Windows PowerShell                                       ││Copyright (C) Microsoft Corporation. All rights reserved.││                                                         ││PS C:\\Users\\liaoxuefeng&gt; node hello.js                   ││Hello, world.                                            ││                                                         ││PS C:\\Users\\liaoxuefeng&gt;                                 ││                                                         │└─────────────────────────────────────────────────────────┘\n在命令行模式下，可以执行node进入Node交互式环境，也可以执行node hello.js运行一个.js文件。\n看到&gt;是在Node交互式环境下：\n1234567891011┌─────────────────────────────────────────────────────────┐│Windows PowerShell                                 - □ x │├─────────────────────────────────────────────────────────┤│Windows PowerShell                                       ││Copyright (C) Microsoft Corporation. All rights reserved.││                                                         ││PS C:\\Users\\liaoxuefeng&gt; node                            ││Welcome to Node.js v22.x.x.                              ││&gt;                                                        ││                                                         │└─────────────────────────────────────────────────────────┘\n在Node交互式环境下，我们可以输入JavaScript代码并立刻执行。\n此外，在命令行模式运行.js文件和在Node交互式环境下直接运行JavaScript代码有所不同。Node交互式环境会把每一行JavaScript代码的结果自动打印出来，但是，直接运行JavaScript文件却不会。\n例如，在Node交互式环境下，输入：\n12&gt; 100 + 200 + 300;600\n直接可以看到结果600。\n但是，写一个calc.js的文件，内容如下：\n1100 + 200 + 300;\n然后在命令行模式下执行：\n1C:\\Workspace&gt; node calc.js\n发现什么输出都没有。\n这是正常的。想要输出结果，必须自己用console.log()打印出来。把calc.js改造一下：\n1console.log(100 + 200 + 300);\n再执行，就可以看到结果：\n12C:\\Workspace&gt; node calc.js600\n小结\n用文本编辑器写JavaScript程序，然后保存为后缀为.js的文件，就可以用node直接运行这个程序了。\nNode的交互模式和直接运行.js文件有什么区别呢？\n直接输入node进入交互模式，相当于启动了Node解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。\n直接运行node hello.js文件相当于启动了Node解释器，然后一次性把hello.js文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。\n在编写JavaScript代码的时候，完全可以一边在文本编辑器里写代码，一边开一个Node交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍！前提是得有个27’的超大显示器！\n参考源码\nhello.js\ncalc.js\n使用文本编辑器来开发Node程序，最大的缺点是效率太低，运行Node程序还需要在命令行单独敲命令。如果还需要调试程序，就更加麻烦了。\n所以我们需要一个IDE集成开发环境，让我们能在一个环境里编码、运行、调试，这样就可以大大提升开发效率。\nJava的集成开发环境有Eclipse，Intellij idea等，C#的集成开发环境有Visual Studio，那么问题又来了：Node.js的集成开发环境到底哪家强？\n考察Node.js的集成开发环境，重点放在启动速度快，执行简单，调试方便这三点上。当然，免费使用是一个加分项。\n综合考察后，我们隆重向大家推荐Node.js集成开发环境：\nVisual Studio Code\nVisual Studio Code由微软出品，但它不是那个大块头的Visual Studio，它是一个精简版的迷你Visual Studio，并且，Visual Studio Code可以跨！平！台！Windows、Mac和Linux通用。\n安装Visual Studio Code\n可以从Visual Studio Code的官方网站下载并安装最新的版本。\n安装过程中，请务必钩上以下选项“将“通过Code打开”操作添加到Windows资源管理器目录上下文菜单”：\n\n这将大大提升将来的操作快捷度。\n运行和调试JavaScript\n在VS Code中，我们可以非常方便地运行JavaScript文件。\nVS Code以文件夹作为工程目录（Workspace Dir），所有的JavaScript文件都存放在该目录下。\n假设我们在C:\\Work\\目录下创建了一个hello目录作为工程目录，并编写了一个hello.js文件，则该工程目录的结构如下：\n12hello/        &lt;-- workspace dir└── hello.js  &lt;-- JavaScript file\n启动VS Code，选择菜单File - Open Folder…，选择hello目录，就可以直接编辑hello.js文件：\n\n运行JS代码\n确保当前编辑器正在编辑hello.js文件，然后在VS Code中选择左侧调试按钮，直接点击Run And Debug按钮，如果弹出环境选项则选择Node，在右下侧DEBUG CONSOLE可直接看到运行结果。\n\n如果右下侧面板没有显示，左上角有几个按钮可以切换视图。\n调试JS代码\n在VS Code中，可以通过断点调试方便进行JavaScript的开发和测试。我们先在hello.js的编辑器中打一个断点（鼠标点击行号左侧出现小红点即为断点），然后点击Run And Debug按钮，此时进入调试模式，会自动停在断点处，左侧窗口可查看变量，顶部按钮可选择单步执行或继续执行到下一个断点，也可以随时结束程序：\n\n总的来说，使用VS Code，开发和调试JavaScript代码十分方便。\n参考源码\nhello.js\n在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。\n为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Node环境中，一个.js文件就称之为一个模块（module）。\n使用模块有什么好处？\n最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。\n使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。\n在上一节，我们编写了一个hello.js文件，这个hello.js文件就是一个模块，模块的名字就是文件名（去掉.js后缀），所以hello.js文件就是名为hello的模块。\n我们把hello.js改造一下，创建一个函数，这样我们就可以在其他地方调用这个函数：\n123456789&#x27;use strict&#x27;;const s = &#x27;Hello&#x27;;function greet(name) &#123;    console.log(s + &#x27;, &#x27; + name + &#x27;!&#x27;);&#125;module.exports = greet;\n函数greet()是我们在hello模块中定义的，你可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了。\n问题是其他模块怎么使用hello模块的这个greet函数呢？我们再编写一个main.js文件，调用hello模块的greet函数：\n12345678&#x27;use strict&#x27;;// 引入hello模块:const greet = require(&#x27;./hello&#x27;);let s = &#x27;Michael&#x27;;greet(s); // Hello, Michael!\n注意到引入hello模块用Node提供的require函数：\n1const greet = require(&#x27;./hello&#x27;);\n引入的模块作为变量保存在greet变量中，那greet变量到底是什么东西？其实变量greet就是在hello.js中我们用module.exports = greet;输出的greet函数。所以，main.js就成功地引用了hello.js模块中定义的greet()函数，接下来就可以直接使用它了。\n在使用require()引入模块的时候，请注意模块的相对路径。因为main.js和hello.js位于同一个目录，所以我们用了当前目录.：\n1const greet = require(&#x27;./hello&#x27;); // 不要忘了写相对目录!\n如果只写模块名：\n1const greet = require(&#x27;hello&#x27;);\n则Node会依次在内置模块、全局模块和当前模块下查找hello.js，你很可能会得到一个错误：\n123456module.js    throw err;          ^Error: Cannot find module &#x27;hello&#x27;    at Module._resolveFilename    ...\n遇到这个错误，你要检查：\n\n模块名是否写对了；\n模块文件是否存在；\n相对路径是否写对了。\n\nCommonJS规范\n这种模块加载机制被称为CommonJS规范。在这个规范下，每个.js文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，hello.js和main.js都申明了全局变量var s = 'xxx'，但互不影响。\n一个模块想要对外暴露变量（函数也是变量），可以用module.exports = variable;，一个模块要引用其他模块暴露的变量，用var ref = require('module_name');就拿到了引用模块的变量。\n结论\n要在模块中对外输出变量，用：\n1module.exports = variable;\n输出的变量可以是任意对象、函数、数组等等。\n要引入其他模块输出的对象，用：\n1const foo = require(&#x27;other_module&#x27;);\n引入的对象具体是什么，取决于引入模块输出的对象。\n深入了解模块原理\n如果你想详细地了解CommonJS的模块实现原理，请继续往下阅读。如果不想了解，请直接跳到最后做练习。\n当我们编写JavaScript代码时，我们可以申明全局变量：\n1let s = &#x27;global&#x27;;\n在浏览器中，大量使用全局变量可不好。如果你在a.js中使用了全局变量s，那么，在b.js中也使用全局变量s，将造成冲突，b.js中对s赋值会改变a.js的运行逻辑。\n也就是说，在ESM标准之前，JavaScript语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。\n那Node.js是如何实现这一点的？\n其实要实现“模块”这个功能，并不需要语法层面的支持。Node.js也并不会增加任何JavaScript语法。实现“模块”功能的奥妙就在于JavaScript是一种函数式编程语言，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。\n请注意我们编写的hello.js代码是这样的：\n1234let s = &#x27;Hello&#x27;;let name = &#x27;world&#x27;;console.log(s + &#x27; &#x27; + name + &#x27;!&#x27;);\nNode.js加载了hello.js后，它可以把代码包装一下，变成这样执行：\n12345678(function () &#123;    // 读取的hello.js代码:    let s = &#x27;Hello&#x27;;    let name = &#x27;world&#x27;;    console.log(s + &#x27; &#x27; + name + &#x27;!&#x27;);    // hello.js代码结束&#125;)();\n这样一来，原来的全局变量s现在变成了匿名函数内部的局部变量。如果Node.js继续加载其他模块，这些模块中定义的“全局”变量s也互不干扰。\n所以，Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离。\n但是，模块的输出module.exports怎么实现？\n这个也很容易实现，Node可以先准备一个对象module：\n123456789101112131415161718// 准备module对象:let module = &#123;    id: &#x27;hello&#x27;,    exports: &#123;&#125;&#125;;let load = function (module) &#123;    // 读取的hello.js代码:    function greet(name) &#123;        console.log(&#x27;Hello, &#x27; + name + &#x27;!&#x27;);    &#125;        module.exports = greet;    // hello.js代码结束    return module.exports;&#125;;let exported = load(module);// 保存module:save(module, exported);\n可见，变量module是Node在加载js文件前准备的一个变量，并将其传入加载函数，我们在hello.js中可以直接使用变量module原因就在于它实际上是函数的一个参数：\n1module.exports = greet;\n通过把参数module传递给load()函数，hello.js就顺利地把一个变量传递给了Node执行环境，Node会把module变量保存到某个地方。\n由于Node保存了所有导入的module，当我们用require()获取module时，Node找到对应的module，把这个module的exports变量返回，这样，另一个模块就顺利拿到了模块的输出：\n1const greet = require(&#x27;./hello&#x27;);\n以上是Node实现JavaScript模块的一个简单的原理介绍。\nmodule.exports vs exports\n很多时候，你会看到，在Node环境中，有两种方法可以在一个模块中输出变量：\n方法一：对module.exports赋值：\n1234567891011121314// hello.jsfunction hello() &#123;    console.log(&#x27;Hello, world!&#x27;);&#125;function greet(name) &#123;    console.log(&#x27;Hello, &#x27; + name + &#x27;!&#x27;);&#125;module.exports = &#123;    hello: hello,    greet: greet&#125;;\n方法二：直接使用exports：\n12345678910111213141516// hello.jsfunction hello() &#123;    console.log(&#x27;Hello, world!&#x27;);&#125;function greet(name) &#123;    console.log(&#x27;Hello, &#x27; + name + &#x27;!&#x27;);&#125;function hello() &#123;    console.log(&#x27;Hello, world!&#x27;);&#125;exports.hello = hello;exports.greet = greet;\n但是你不可以直接对exports赋值：\n12345// 代码可以执行，但是模块并没有输出任何变量:exports = &#123;    hello: hello,    greet: greet&#125;;\n如果你对上面的写法感到十分困惑，不要着急，我们来分析Node的加载机制：\n首先，Node会把整个待加载的hello.js文件放入一个包装函数load中执行。在执行这个load()函数前，Node准备好了module变量：\n1234let module = &#123;    id: &#x27;hello&#x27;,    exports: &#123;&#125;&#125;;\nload()函数最终返回module.exports：\n12345678let load = function (exports, module) &#123;    // hello.js的文件内容    ...    // load函数返回:    return module.exports;&#125;;let exported = load(module.exports, module);\n也就是说，默认情况下，Node准备的exports变量和module.exports变量实际上是同一个变量，并且初始化为空对象&#123;&#125;，于是，我们可以写：\n12exports.foo = function () &#123; return &#x27;foo&#x27;; &#125;;exports.bar = function () &#123; return &#x27;bar&#x27;; &#125;;\n也可以写：\n12module.exports.foo = function () &#123; return &#x27;foo&#x27;; &#125;;module.exports.bar = function () &#123; return &#x27;bar&#x27;; &#125;;\n换句话说，Node默认给你准备了一个空对象&#123;&#125;，这样你可以直接往里面加东西。\n但是，如果我们要输出的是一个函数或数组，那么，只能给module.exports赋值：\n1module.exports = function () &#123; return &#x27;foo&#x27;; &#125;;\n给exports赋值是无效的，因为赋值后，module.exports仍然是空对象&#123;&#125;。\n结论\n如果要输出一个键值对象&#123;&#125;，可以利用exports这个已存在的空对象&#123;&#125;，并继续在上面添加新的键值；\n如果要输出一个函数或数组，必须直接对module.exports对象赋值。\n所以我们可以得出结论：直接对module.exports赋值，可以应对任何情况：\n123module.exports = &#123;    foo: function () &#123; return &#x27;foo&#x27;; &#125;&#125;;\n或者：\n1module.exports = function () &#123; return &#x27;foo&#x27;; &#125;;\n最终，我们强烈建议使用module.exports = xxx的方式来输出模块变量，这样，你只需要记忆一种方法。\n练习\n编写hello.js，输出一个或多个函数；\n编写main.js，引入hello模块，调用其函数。\n参考源码\nmodule\n虽然Node.js从诞生起就支持模块，但JavaScript语言本身长期以来却一直没有模块功能，只能由CommonJS或其他AMD等模块系统来“模拟”。\n随着ES 6标准的推出，JavaScript语言本身终于也迎来了原生内置的模块支持，称为ECMAScript Modules（简称ESM），不仅可以直接在浏览器中使用模块，也可以在Node.js中使用ESM模块。\n不使用ESM模块时，我们用module.exports导出可供外部使用的JS对象，例如，以下模块导出了两个函数：\n12345678910111213141516171819&#x27;use strict&#x27;;let s = &#x27;Hello&#x27;;function out(prompt, name) &#123;    console.log(`$&#123;prompt&#125;, $&#123;name&#125;!`);&#125;function greet(name) &#123;    out(s, name);&#125;function hi(name) &#123;    out(&#x27;Hi&#x27;, name);&#125;module.exports = &#123;    greet: greet,    hi: hi&#125;;\n要把上述代码改为ESM模块，我们用export标识需要导出的函数：\n12345678910111213141516let s = &#x27;Hello&#x27;;// out是模块内部函数，模块外部不可见:function out(prompt, name) &#123;    console.log(`$&#123;prompt&#125;, $&#123;name&#125;!`);&#125;// greet是导出函数，可被外部调用:export function greet(name) &#123;    out(s, name);&#125;// hi是导出函数，可被外部调用:export function hi(name) &#123;    out(&#x27;Hi&#x27;, name);&#125;\n并将其保存为hello.mjs文件，注意扩展名不是.js，而是.mjs。\n可以再编写一个main.mjs文件来调用hello模块：\n12345import &#123; greet, hi &#125; from &#x27;./hello.mjs&#x27;;let name = &#x27;Bob&#x27;;greet(name);hi(name);\n可见，ESM模块用export关键字导出一个JS对象，用import关键字导入一个模块的导出对象。\n如果要实现类似如下代码的单个函数导出：\n1module.exports = greet;\n则可以用export default导出：\n123export default function greet(name) &#123;    ...&#125;\n相应的，导入代码修改为：\n1import greet from &#x27;./hello.mjs&#x27;;\n细心的同学还注意到ESM模块文件第一行并没有'use strict'，这是因为ESM模块默认启用严格模式，因此无需再手动声明'use strict'。\n浏览器加载ESM\n对于浏览器来说，也可以直接使用ESM模块。当我们加载一个ESM模块时，需要用type=&quot;module&quot;来表示：\n123456789&lt;html&gt;&lt;head&gt;    &lt;script type=&quot;module&quot; src=&quot;./example.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;module&quot;&gt;        greet(&#x27;Bob&#x27;);    &lt;/script&gt;&lt;/head&gt;...&lt;/html&gt;\n或者直接使用import加载一个模块：\n123456789&lt;html&gt;&lt;head&gt;    &lt;script type=&quot;module&quot;&gt;        import &#123; greet &#125; from &#x27;./example.js&#x27;;        greet(&#x27;Bob&#x27;);    &lt;/script&gt;&lt;/head&gt;...&lt;/html&gt;\n练习\n在Node环境中使用ESM模块：\n下载练习\n小结\n使用JavaScript内置的原生模块时，用关键字export和import来实现导出与导入；\nESM模块默认启用strict模式，无需声明'use strict'。\n因为Node.js是运行在服务区端的JavaScript环境，服务器程序和浏览器程序相比，最大的特点是没有浏览器的安全限制了，而且，服务器程序必须能接收网络请求，读写文件，处理二进制内容，所以，Node.js内置的常用模块就是为了实现基本的服务器功能。这些模块在浏览器环境中是无法被执行的，因为它们的底层代码是用C/C++在Node.js运行环境中实现的。\nglobal\n在前面的JavaScript课程中，我们已经知道，JavaScript有且仅有一个全局对象，在浏览器中，叫window对象。而在Node.js环境中，也有唯一的全局对象，但不叫window，而叫global，这个对象的属性和方法也和浏览器环境的window不同。进入Node.js交互环境，可以直接输入：\n12345678&gt; global.consoleObject [console] &#123;  log: [Function: log],  warn: [Function: warn],  dir: [Function: dir],  time: [Function: time],  ...&#125;\nprocess\nprocess也是Node.js提供的一个对象，它代表当前Node.js进程。通过process对象可以拿到许多有用信息：\n1234567891011121314&gt; process === global.process;true&gt; process.version;&#x27;v22.3.0&#x27;&gt; process.platform;&#x27;darwin&#x27;&gt; process.arch;&#x27;x64&#x27;&gt; process.cwd(); //返回当前工作目录&#x27;/Users/michael&#x27;&gt; process.chdir(&#x27;/private/tmp&#x27;); // 切换当前工作目录undefined&gt; process.cwd();&#x27;/private/tmp&#x27;\nJavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。\n如果我们想要在下一次事件响应中执行代码，可以调用process.nextTick()：\n123456// test.js// process.nextTick()将在下一轮事件循环中调用:process.nextTick(function () &#123;    console.log(&#x27;nextTick callback!&#x27;);&#125;);console.log(&#x27;nextTick was set!&#x27;);\n用Node执行上面的代码node test.js，你会看到，打印输出是：\n12nextTick was set!nextTick callback!\n这说明传入process.nextTick()的函数不是立刻执行，而是要等到下一次事件循环。\nNode.js进程本身的事件就由process对象来处理。如果我们响应exit事件，就可以在程序即将退出时执行某个回调函数：\n1234// 程序即将退出时的回调函数:process.on(&#x27;exit&#x27;, function (code) &#123;    console.log(&#x27;about to exit with code: &#x27; + code);&#125;);\n判断JavaScript执行环境\n有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：\n12345if (typeof(window) === &#x27;undefined&#x27;) &#123;    console.log(&#x27;node.js&#x27;);&#125; else &#123;    console.log(&#x27;browser&#x27;);&#125;\n导入Node模块\nNode内置了许多模块，可以从Node.js的在线文档查询所有模块信息。\n以crypto模块的randomInt()函数为例，导入模块有两种方法：\n方法一：使用传统的require()：\n123const &#123; randomInt &#125; = require(&#x27;node:crypto&#x27;);const n = randomInt(0, 100); // 0~100之间的随机数console.log(n);\n方法二：使用import关键字导入ESM模块：\n123import &#123; randomInt &#125; from &#x27;node:crypto&#x27;;const n = randomInt(0, 100); // 0~100之间的随机数console.log(n);\n后面，我们将介绍Node.js的常用内置模块。\nNode.js内置的fs模块就是文件系统模块，负责读写文件。\n和所有其它JavaScript模块不同的是，fs模块同时提供了异步和同步的方法。\n回顾一下什么是异步方法。因为JavaScript的单线程模型，执行IO操作时，JavaScript代码无需等待，而是传入回调函数后，继续执行后续JavaScript代码。比如jQuery提供的getJSON()操作：\n1234$.getJSON(&#x27;http://example.com/ajax&#x27;, function (data) &#123;    console.log(&#x27;IO结果返回后执行...&#x27;);&#125;);console.log(&#x27;不等待IO结果直接执行后续代码...&#x27;);\n而同步的IO操作则需要等待函数返回：\n12// 根据网络耗时，函数将执行几十毫秒~几秒不等:let data = getJSONSync(&#x27;http://example.com/ajax&#x27;);\n同步操作的好处是代码简单，缺点是程序将等待IO操作，在等待时间内，无法响应其它任何事件。而异步读取不用等待IO操作，但代码较麻烦。\n异步读文件\n按照JavaScript的标准，异步读取一个文本文件的代码如下：\n1234567891011121314// read-text-file-async.mjsimport &#123; readFile &#125; from &#x27;node:fs&#x27;;console.log(&#x27;BEGIN&#x27;);readFile(&#x27;sample.txt&#x27;, &#x27;utf-8&#x27;, function (err, data) &#123;    if (err) &#123;        console.log(err);    &#125; else &#123;        console.log(data);    &#125;&#125;);console.log(&#x27;END&#x27;);\n请注意，sample.txt文件必须在当前目录下，且文件编码为utf-8。\n异步读取时，传入的回调函数接收两个参数，当正常读取时，err参数为null，data参数为读取到的String。当读取发生错误时，err参数代表一个错误对象，data为undefined。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。后面我们还会经常编写这种回调函数。\n由于err是否为null就是判断是否出错的标志，所以通常的判断逻辑总是：\n12345if (err) &#123;    // 出错了&#125; else &#123;    // 正常&#125;\n执行上述代码，可以看到打印的内容如下：\n123&gt;&gt;&gt; BEGIN &gt;&gt;&gt;&gt;&gt;&gt; END &gt;&gt;&gt;Sample file content...\n因为异步读取，所以，先打印END后，才会执行回调函数，打印文件内容。\n如果我们要读取的文件不是文本文件，而是二进制文件，怎么办？\n下面的例子演示了如何读取一个图片文件：\n12345678910import &#123; readFile &#125; from &#x27;node:fs&#x27;;readFile(&#x27;sample.png&#x27;, function (err, data) &#123;    if (err) &#123;        console.log(err);    &#125; else &#123;        console.log(data instanceof Buffer); // true        console.log(data); // Buffer(12451) [137, 80, 78, 71, 13, ...]    &#125;&#125;);\n当读取二进制文件时，不传入文件编码时，回调函数的data参数将返回一个Buffer对象。在Node.js中，Buffer对象就是一个包含零个或任意个字节的数组（注意和Array不同）。\nBuffer对象可以和String作转换，例如，把一个Buffer对象转换成String：\n123// Buffer -&gt; Stringlet text = data.toString(&#x27;utf-8&#x27;);console.log(text);\n或者把一个String转换成Buffer：\n123// String -&gt; Bufferlet buf = Buffer.from(text, &#x27;utf-8&#x27;);console.log(buf);\n同步读文件\n除了标准的异步读取模式外，fs也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个Sync后缀，并且不接收回调函数，函数直接返回结果。\n用fs模块同步读取一个文本文件的代码如下：\n123456789101112// read-text-file-sync.mjsimport &#123; readFileSync &#125; from &#x27;node:fs&#x27;;console.log(&#x27;BEGIN&#x27;);try &#123;    let s = readFileSync(&#x27;sample.txt&#x27;, &#x27;utf-8&#x27;);    console.log(s);&#125; catch (err) &#123;    console.log(err);&#125;console.log(&#x27;END&#x27;);\n可见，原异步调用的回调函数的data被函数直接返回，函数名需要改为readFileSync，其它参数不变。\n如果同步读取文件发生错误，则需要用try...catch捕获该错误。\n写文件\n将数据写入文件是通过fs.writeFile()实现的：\n123456789// write-file-async.mjsimport &#123; writeFile &#125; from &#x27;node:fs&#x27;;let data = &#x27;Hello, Node.js&#x27;;writeFile(&#x27;output.txt&#x27;, data, function (err) &#123;    if (err) &#123;        console.log(err);    &#125;&#125;);\nwriteFile()的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是Buffer，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个err参数。\n和readFile()类似，writeFile()也有一个同步方法，叫writeFileSync()。\nstat\n如果我们要获取文件大小，创建时间等信息，可以使用fs.stat()，它返回一个Stat对象，能告诉我们文件或目录的详细信息：\n123456789101112131415161718192021// read-stat-async.mjsimport &#123; stat &#125; from &#x27;node:fs&#x27;;stat(&#x27;sample.png&#x27;, function (err, st) &#123;    if (err) &#123;        console.log(err);    &#125; else &#123;        // 是否是文件:        console.log(&#x27;isFile: &#x27; + st.isFile());        // 是否是目录:        console.log(&#x27;isDirectory: &#x27; + st.isDirectory());        if (st.isFile()) &#123;            // 文件大小:            console.log(&#x27;size: &#x27; + st.size);            // 创建时间, Date对象:            console.log(&#x27;birth time: &#x27; + st.birthtime);            // 修改时间, Date对象:            console.log(&#x27;modified time: &#x27; + st.mtime);        &#125;    &#125;&#125;);\n运行结果如下：\n12345isFile: trueisDirectory: falsesize: 12451birth time: Mon Jun 17 2024 19:37:24 GMT+0800 (China Standard Time)modified time: Mon Jun 17 2024 19:37:24 GMT+0800 (China Standard Time)\nstat()也有一个对应的同步函数statSync()，请试着改写上述异步代码为同步代码。\n使用Promise\n我们在介绍JavaScript的Promise时，讲到通过async函数实现异步逻辑，代码更简单。\n类似的，Node还提供Promise版本的fs，可以用如下代码在async函数中读取文件：\n12345678// async-read.mjsimport &#123; readFile &#125; from &#x27;node:fs/promises&#x27;;async function readTextFile(path) &#123;    return await readFile(path, &#x27;utf-8&#x27;);&#125;readTextFile(&#x27;sample.txt&#x27;).then(s =&gt; console.log(s));\n在async函数中，用await调用fs/promises与同步方法类似，但代码却是异步执行的。\n异步还是同步\n在fs模块中，提供同步方法是为了方便使用。那我们到底是应该用异步方法还是同步方法呢？\n由于Node环境执行的JavaScript代码是服务器端代码，所以，绝大部分需要在服务器运行期反复执行业务逻辑的代码，必须使用异步代码，否则，同步代码在执行时期，服务器将停止响应，因为JavaScript只有一个执行线程。\n服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。\n如果代码中编写了大量的async函数，那么通过await异步调用fs/promises模块更加方便。\n参考源码\nfs\nstream是Node.js提供的又一个仅在服务区端可用的模块，目的是支持“流”这种数据结构。\n什么是流？流是一种抽象的数据结构。想象水流，当在水管中流动时，就可以从某个地方（例如自来水厂）源源不断地到达另一个地方（比如你家的洗手池）。我们也可以把数据看成是数据流，比如你敲键盘的时候，就可以把每个字符依次连起来，看成字符流。这个流是从键盘输入到应用程序，实际上它还对应着一个名字：标准输入流（stdin）。\n如果应用程序把字符一个一个输出到显示器上，这也可以看成是一个流，这个流也有名字：标准输出流（stdout）。流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位。\n\n有些流用来读取数据，比如从文件读取数据时，可以打开一个文件流，然后从文件流中不断地读取数据。有些流用来写入数据，比如向文件写入数据时，只需要把数据不断地往文件流中写进去就可以了。\n在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：data事件表示流的数据已经可以读取了，end事件表示这个流已经到末尾了，没有数据可以读取了，error事件表示出错了。\n下面是一个从文件流读取文本内容的示例：\n1234567891011121314151617181920import &#123; createReadStream &#125; from &#x27;node:fs&#x27;;// 打开流:let rs = createReadStream(&#x27;sample.txt&#x27;, &#x27;utf-8&#x27;);// 读取到数据:rs.on(&#x27;data&#x27;, (chunk) =&gt; &#123;    console.log(&#x27;---- chunk ----&#x27;);    console.log(chunk);&#125;);// 结束读取:rs.on(&#x27;end&#x27;, () =&gt; &#123;    console.log(&#x27;---- end ----&#x27;);&#125;);// 出错:rs.on(&#x27;error&#x27;, err =&gt; &#123;    console.log(err);&#125;);\n要注意，data事件可能会有多次，每次传递的chunk是流的一部分数据。\n要以流的形式写入文件，只需要不断调用write()方法，最后以end()结束：\n1234567891011121314151617import &#123; createWriteStream &#125; from &#x27;node:fs&#x27;;let ws = createWriteStream(&#x27;output.txt&#x27;, &#x27;utf-8&#x27;);ws.write(&#x27;使用Stream写入文本数据...\\n&#x27;);ws.write(&#x27;继续写入...\\n&#x27;);ws.write(&#x27;DONE.\\n&#x27;);ws.end(); // 结束写入// 写入二进制数据:let b64array = [ ... ];let ws2 = createWriteStream(&#x27;output.png&#x27;);for (let b64 of b64array) &#123;    let buf = Buffer.from(b64, &#x27;base64&#x27;);    ws2.write(buf); // 写入Buffer对象&#125;ws2.end(); // 结束写入\n所有可以读取数据的流都继承自stream.Readable，所有可以写入的流都继承自stream.Writable。\npipe\n就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个Readable流和一个Writable流串起来后，所有的数据自动从Readable流进入Writable流，这种操作叫pipe。\n在Node.js中，Readable流有一个pipe()方法，就是用来干这件事的：\n1rs.pipe(ws);\n除了直接使用pipe()方法，Node还提供了pipeline功能，它可以将一个流输出到另一个流。以下是一个复制文件的程序：\n123456789101112import &#123; createReadStream, createWriteStream &#125; from &quot;node:fs&quot;;import &#123; pipeline &#125; from &#x27;node:stream/promises&#x27;;async function copy(src, dest) &#123;    let rs = createReadStream(src);    let ws = createWriteStream(dest);    await pipeline(rs, ws);&#125;copy(&#x27;sample.txt&#x27;, &#x27;output.txt&#x27;)    .then(() =&gt; console.log(&#x27;copied.&#x27;))    .catch(err =&gt; console.log(err));\n使用pipeline的好处是，它可以添加若干个转换器，即输入流经过若干转换后，再进入输出流。如果我们添加的转换器实现了gzip功能，那么实际上就可以把输入流自动压缩后进入输出流。\n参考源码\nstream\nNode.js开发的目的就是为了用JavaScript编写Web服务器程序。因为JavaScript实际上已经统治了浏览器端的脚本，其优势就是有世界上数量最多的前端开发人员。如果已经掌握了JavaScript前端开发，再学习一下如何将JavaScript应用在后端开发，就是名副其实的全栈了。\nHTTP协议\n要理解Web服务器程序的工作原理，首先，我们要对HTTP协议有基本的了解。如果你对HTTP协议不太熟悉，先看一看HTTP协议简介。\nHTTP服务器\n要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的http模块完成了。应用程序并不直接和HTTP协议打交道，而是操作http模块提供的request和response对象。\nrequest对象封装了HTTP请求，我们调用request对象的属性和方法就可以拿到所有HTTP请求的信息；\nresponse对象封装了HTTP响应，我们操作response对象的方法，就可以把HTTP响应返回给浏览器。\n用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序hello.js，它对于所有请求，都返回Hello world!：\n12345678910111213141516171819202122// 导入http模块:import http from &#x27;node:http&#x27;;// 创建http server，并传入回调函数:const server = http.createServer((request, response) =&gt; &#123;    // 回调函数接收request和response对象,    // 获得HTTP请求的method和url:    console.log(request.method + &#x27;: &#x27; + request.url);    // 将HTTP响应200写入response, 同时设置Content-Type: text/html:    response.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/html&#x27;&#125;);    // 将HTTP响应的HTML内容写入response:    response.end(&#x27;&lt;h1&gt;Hello world!&lt;/h1&gt;&#x27;);&#125;);// 出错时返回400:server.on(&#x27;clientError&#x27;, (err, socket) =&gt; &#123;  socket.end(&#x27;HTTP/1.1 400 Bad Request\\r\\n\\r\\n&#x27;);&#125;);// 让服务器监听8080端口:server.listen(8080);console.log(&#x27;Server is running at http://127.0.0.1:8080/&#x27;);\n在命令提示符下运行该程序，可以看到以下输出：\n12$ node simple-server.mjs Server is running at http://127.0.0.1:8080/\n不要关闭命令提示符，直接打开浏览器输入http://localhost:8080，即可看到服务器响应的内容：\n\n同时，在命令提示符窗口，可以看到程序打印的请求信息：\n12GET: /GET: /favicon.ico\n这就是我们编写的第一个HTTP服务器程序！\n文件服务器\n让我们继续扩展一下上面的Web程序。我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析request.url中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。\n观察打印的request.url，它实际上是浏览器请求的路径和参数，如：\n\n/\n/index.html\n/hello?name=bob\n\n解析出path部分可以直接用URL对象：\n123let url = new URL(&#x27;http://localost&#x27; + &#x27;/index.html?v=1&#x27;);let pathname = url.pathname;console.log(pathname); // index.html\n处理本地文件目录需要使用Node.js提供的path模块，它可以方便地构造目录：\n12345678import path from &#x27;node:path&#x27;;// 解析当前目录:let workDir = path.resolve(&#x27;.&#x27;); // &#x27;/Users/michael&#x27;// 组合完整的文件路径:当前目录+&#x27;pub&#x27;+&#x27;index.html&#x27;:let filePath = path.join(workDir, &#x27;pub&#x27;, &#x27;index.html&#x27;);// &#x27;/Users/michael/pub/index.html&#x27;\n使用path模块可以正确处理操作系统相关的文件路径。在Windows系统下，返回的路径类似于C:\\Users\\michael\\static\\index.html，这样，我们就不关心怎么拼接路径了。\n最后，我们实现一个文件服务器simple-file-server.js：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 导入http模块:import http from &#x27;node:http&#x27;;import path from &#x27;node:path&#x27;;import &#123; createReadStream &#125; from &#x27;node:fs&#x27;;import &#123; stat &#125; from &#x27;node:fs/promises&#x27;;// 设定www根目录为当前目录:const wwwRoot = path.resolve(&#x27;.&#x27;);console.log(`set www root: $&#123;wwwRoot&#125;`);// 根据扩展名确定MIME类型:function guessMime(pathname) &#123;    // FIXME:    return &#x27;text/html&#x27;;&#125;// 创建http file server，并传入回调函数:const server = http.createServer((request, response) =&gt; &#123;    // 获得HTTP请求的method和url:    console.log(request.method + &#x27;: &#x27; + request.url);    if (request.method !== &#x27;GET&#x27;) &#123;        response.writeHead(400, &#123; &#x27;Content-Type&#x27;: &#x27;text/html&#x27; &#125;);        response.end(&#x27;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&#x27;);    &#125; else &#123;        // 解析path:         let url = new URL(`http://localhost$&#123;request.url&#125;`);        let pathname = url.pathname;        let filepath = path.join(wwwRoot, pathname);        // TODO: 必要的安全检查        // 检查文件状态:        stat(filepath).then(st =&gt; &#123;            if (st.isFile()) &#123;                console.log(&#x27;200 OK&#x27;);                // 发送200响应:                response.writeHead(200, &#123; &#x27;Content-Type&#x27;: guessMime(pathname) &#125;);                // 将文件流导向response:                createReadStream(filepath).pipe(response);            &#125; else &#123;                console.log(&#x27;404 Not Found&#x27;);                response.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html&#x27; &#125;);                response.end(&#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;);            &#125;        &#125;).catch(err =&gt; &#123;            console.log(&#x27;404 Not Found&#x27;);            response.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html&#x27; &#125;);            response.end(&#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;);        &#125;);    &#125;&#125;);// 出错时返回400:server.on(&#x27;clientError&#x27;, (err, socket) =&gt; &#123;    socket.end(&#x27;HTTP/1.1 400 Bad Request\\r\\n\\r\\n&#x27;);&#125;);// 让服务器监听8080端口:server.listen(8080);console.log(&#x27;Server is running at http://127.0.0.1:8080/&#x27;);\n没有必要手动读取文件内容。由于response对象本身是一个Writable Stream，直接用pipe()方法就实现了自动读取文件内容并输出到HTTP响应。\n在命令行运行node simple-file-server.mjs，然后在浏览器中输入http://localhost:8080/index.html：\n\n只要当前目录下存在文件index.html，服务器就可以把文件内容发送给浏览器。观察控制台输出：\n123456GET: /index.html200 OKGET: /next/hello.png200 OKGET: /favicon.ico200 OK\n第一个请求是浏览器请求/页面，后续请求是浏览器解析HTML后发送的其它资源请求。\n练习\n在浏览器输入http://localhost:8080/时，会返回404，原因是程序识别出HTTP请求的不是文件，而是目录。请修改simple-file-server.mjs，如果遇到请求的路径是目录，则自动在目录下依次搜索index.html、default.html，如果找到了，就返回HTML文件的内容。\n参考源码\n\n简单HTTP服务器\nHTTP文件服务器\n\ncrypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。\nMD5和SHA1\nMD5是一种常用的哈希算法，用于给任意数据一个“签名”。这个签名通常用一个十六进制的字符串表示：\n123456789import crypto from &#x27;node:crypto&#x27;;const hash = crypto.createHash(&#x27;md5&#x27;);// 可任意多次调用update():hash.update(&#x27;Hello, world!&#x27;);hash.update(&#x27;Hello, nodejs!&#x27;);console.log(hash.digest(&#x27;hex&#x27;)); // 7e1977739c748beac0c0fd14fd26a544\nupdate()方法默认字符串编码为UTF-8，也可以传入Buffer。\n如果要计算SHA1，只需要把'md5'改成'sha1'，就可以得到SHA1的结果。还可以使用更安全的sha256和sha512。\nHmac\nHmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。不同的是，Hmac还需要一个密钥：\n12345678import crypto from &#x27;node:crypto&#x27;;const hmac = crypto.createHmac(&#x27;sha256&#x27;, &#x27;secret-key&#x27;);hmac.update(&#x27;Hello, world!&#x27;);hmac.update(&#x27;Hello, nodejs!&#x27;);console.log(hmac.digest(&#x27;hex&#x27;)); // 80f7e22570...\n只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把Hmac理解为用随机数“增强”的哈希算法。\nAES\nAES是一种常用的对称加密算法，加解密都用同一个密钥。crypto模块提供了AES支持，但是需要自己封装好函数，便于使用：\n123456789101112131415161718192021222324252627282930import crypto from &#x27;node:crypto&#x27;;function aes_encrypt(key, iv, msg) &#123;    const cipher = crypto.createCipheriv(&#x27;aes-256-cbc&#x27;, key, iv);    // input encoding: utf8    // output encoding: hex    let encrypted = cipher.update(msg, &#x27;utf8&#x27;, &#x27;hex&#x27;);    encrypted += cipher.final(&#x27;hex&#x27;);    return encrypted;&#125;function aes_decrypt(key, iv, encrypted) &#123;    const decipher = crypto.createDecipheriv(&#x27;aes-256-cbc&#x27;, key, iv);    let decrypted = decipher.update(encrypted, &#x27;hex&#x27;, &#x27;utf8&#x27;);    decrypted += decipher.final(&#x27;utf8&#x27;);    return decrypted;&#125;// key的长度必须为32bytes:let key = &#x27;Passw0rdPassw0rdPassw0rdPassw0rd&#x27;;// iv的长度必须为16bytes:let iv = &#x27;a1b2c3d4e5f6g7h8&#x27;;let msg = &#x27;Hello, world!&#x27;;// 加密:let encrypted_msg = aes_encrypt(key, iv, msg);// 解密:let decrypted_msg = aes_decrypt(key, iv, encrypted_msg);console.log(`AES encrypt: $&#123;encrypted_msg&#125;`);console.log(`AES decrypt: $&#123;decrypted_msg&#125;`);\n运行结果如下：\n12AES encrypt: 11cd65e5fe7e7448b491efabee2f326aAES decrypt: Hello, world!\n可以看出，加密后的字符串通过解密又得到了原始内容。\n注意到AES有很多不同的算法，如aes192，aes-128-ecb，aes-256-cbc等，AES除了密钥外还可以指定IV（Initial Vector），不同的系统只要IV不同，用相同的密钥加密相同的数据得到的加密结果也是不同的。加密结果通常有两种表示方法：hex和base64，这些功能Node.js全部都支持，但是在应用中要注意，如果加解密双方一方用Nodejs，另一方用Java、PHP等其它语言，需要仔细测试。如果无法正确解密，要确认双方是否遵循同样的AES算法，密钥和IV是否相同，加密后的数据是否统一为hex或base64格式。\nDiffie-Hellman\nDH算法是一种密钥交换协议，它可以让双方在不泄漏密钥的情况下协商出一个密钥来。DH算法基于数学原理，比如小明和小红想要协商一个密钥，可以这么做：\n\n小明先选一个素数和一个底数，例如，素数p=97，底数g=5（底数是p的一个原根），再选择一个秘密整数a=123，计算A=g^a mod p=34，然后大声告诉小红：p=97，g=5，A=34；\n小红收到小明发来的p，g，A后，也选一个秘密整数b=456，然后计算B=g^b mod p=75，并大声告诉小明：B=75；\n小明自己计算出s=B^a mod p=22，小红也自己计算出s=A^b mod p=22，因此，最终协商的密钥s为22。\n\n在这个过程中，密钥22并不是小明告诉小红的，也不是小红告诉小明的，而是双方协商计算出来的。第三方只能知道p=97，g=5，A=34，B=75，由于不知道双方选的秘密整数a=123和b=456，因此无法计算出密钥22。\n用crypto模块实现DH算法如下：\n1234567891011121314151617181920212223import crypto from &#x27;node:crypto&#x27;;// xiaoming&#x27;s keys:let ming = crypto.createDiffieHellman(512);let ming_keys = ming.generateKeys();let prime = ming.getPrime();let generator = ming.getGenerator();console.log(&#x27;Prime: &#x27; + prime.toString(&#x27;hex&#x27;));console.log(&#x27;Generator: &#x27; + generator.toString(&#x27;hex&#x27;));// xiaohong&#x27;s keys:let hong = crypto.createDiffieHellman(prime, generator);let hong_keys = hong.generateKeys();// exchange and generate secret:let ming_secret = ming.computeSecret(hong_keys);let hong_secret = hong.computeSecret(ming_keys);// print secret:console.log(&#x27;Secret of Xiao Ming: &#x27; + ming_secret.toString(&#x27;hex&#x27;));console.log(&#x27;Secret of Xiao Hong: &#x27; + hong_secret.toString(&#x27;hex&#x27;));\n运行后，可以得到如下输出：\n1234Prime: a8224c...deead3Generator: 02Secret of Xiao Ming: 695308...d519beSecret of Xiao Hong: 695308...d519be\n注意每次输出都不一样，因为素数的选择是随机的。\nRSA\nRSA算法是一种非对称加密算法，即由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密。\nRSA算法是1977年由Ron Rivest、Adi Shamir和Leonard Adleman共同提出的，所以以他们三人的姓氏的头字母命名。\n当小明给小红发送信息时，可以用小明自己的私钥加密，小红用小明的公钥解密，也可以用小红的公钥加密，小红用她自己的私钥解密，这就是非对称加密。相比对称加密，非对称加密只需要每个人各自持有自己的私钥，同时公开自己的公钥，不需要像AES那样由两个人共享同一个密钥。\n在使用Node进行RSA加密前，我们先要准备好私钥和公钥。\n首先，在命令行执行以下命令以生成一个RSA密钥对：\n1openssl genrsa -aes256 -out rsa-key.pem 2048\n根据提示输入密码，这个密码是用来加密RSA密钥的，加密方式指定为AES256，生成的RSA的密钥长度是2048位。执行成功后，我们获得了加密的rsa-key.pem文件。\n第二步，通过上面的rsa-key.pem加密文件，我们可以导出原始的私钥，命令如下：\n1openssl rsa -in rsa-key.pem -outform PEM -out rsa-prv.pem\n输入第一步的密码，我们获得了解密后的私钥。\n类似的，我们用下面的命令导出原始的公钥：\n1openssl rsa -in rsa-key.pem -outform PEM -pubout -out rsa-pub.pem\n这样，我们就准备好了原始私钥文件rsa-prv.pem和原始公钥文件rsa-pub.pem，编码格式均为PEM。\n下面，使用crypto模块提供的方法，即可实现非对称加解密。\n首先，我们用私钥加密，公钥解密：\n1234567891011121314151617181920import fs from &#x27;node:fs&#x27;;import crypto from &#x27;node:crypto&#x27;;// 从文件加载key:function loadKey(file) &#123;    // key实际上就是PEM编码的字符串:    return fs.readFileSync(file, &#x27;utf8&#x27;);&#125;let    prvKey = loadKey(&#x27;./rsa-prv.pem&#x27;),    pubKey = loadKey(&#x27;./rsa-pub.pem&#x27;),    message = &#x27;Hello, world!&#x27;;// 使用私钥加密:let enc_by_prv = crypto.privateEncrypt(prvKey, Buffer.from(message, &#x27;utf8&#x27;));console.log(enc_by_prv.toString(&#x27;hex&#x27;));let dec_by_pub = crypto.publicDecrypt(pubKey, enc_by_prv);console.log(dec_by_pub.toString(&#x27;utf8&#x27;));\n执行后，可以得到解密后的消息，与原始消息相同。\n接下来我们使用公钥加密，私钥解密：\n1234567// 使用公钥加密:let enc_by_pub = crypto.publicEncrypt(pubKey, Buffer.from(message, &#x27;utf8&#x27;));console.log(enc_by_pub.toString(&#x27;hex&#x27;));// 使用私钥解密:let dec_by_prv = crypto.privateDecrypt(prvKey, enc_by_pub);console.log(dec_by_prv.toString(&#x27;utf8&#x27;));\n执行得到的解密后的消息仍与原始消息相同。\n如果我们把message字符串的长度增加到很长，例如1M，这时，执行RSA加密会得到一个类似这样的错误：data too large for key size，这是因为RSA加密的原始信息必须小于Key的长度。那如何用RSA加密一个很长的消息呢？实际上，RSA并不适合加密大数据，而是先生成一个随机的AES密码，用AES加密原始信息，然后用RSA加密AES口令，这样，实际使用RSA时，给对方传的密文分两部分，一部分是AES加密的密文，另一部分是RSA加密的AES口令。对方用RSA先解密出AES口令，再用AES解密密文，即可获得明文。\n证书\ncrypto模块也可以处理数字证书。数字证书通常用在SSL连接，也就是Web的https连接。一般情况下，https连接只需要处理服务器端的单向认证，如无特殊需求（例如自己作为Root给客户发认证证书），建议用反向代理服务器如Nginx等Web服务器去处理证书。\n参考源码\n\ncrypto常用算法\n\n最早的软件都是运行在大型机上的，软件使用者通过“哑终端”登陆到大型机上去运行软件。后来随着PC机的兴起，软件开始主要运行在桌面上，而数据库这样的软件运行在服务器端，这种Client/Server模式简称CS架构。\n随着互联网的兴起，人们发现，CS架构不适合Web，最大的原因是Web应用程序的修改和升级非常迅速，而CS架构需要每个客户端逐个升级桌面App，因此，Browser/Server模式开始流行，简称BS架构。\n在BS架构下，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web页面，并把Web页面展示给用户即可。\n当然，Web页面也具有极强的交互性。由于Web页面是用HTML编写的，而HTML具备超强的表现力，并且，服务器端升级后，客户端无需任何部署就可以使用到新的版本，因此，BS架构迅速流行起来。\n今天，除了重量级的软件如Office，Photoshop等，大部分软件都以Web形式提供。比如，新浪提供的新闻、博客、微博等服务，均是Web应用。\nWeb应用开发可以说是目前软件开发中最重要的部分。Web开发也经历了好几个阶段：\n静态Web页面：由文本编辑器直接编辑并生成静态的HTML页面，如果要修改Web页面的内容，就需要再次编辑HTML源文件，早期的互联网Web页面就是静态的；\nCGI：由于静态Web页面无法与用户交互，比如用户填写了一个注册表单，静态Web页面就无法处理。要处理用户发送的动态数据，出现了Common Gateway Interface，简称CGI，用C/C++编写。\nASP/JSP/PHP：由于Web应用特点是修改频繁，用C/C++这样的低级语言非常不适合Web开发，而脚本语言由于开发效率高，与HTML结合紧密，因此，迅速取代了CGI模式。ASP是微软推出的用VBScript脚本编程的Web开发技术，而JSP用Java来编写脚本，PHP本身则是开源的脚本语言。\nMVC：为了解决直接用脚本语言嵌入HTML导致的可维护性差的问题，Web应用也引入了Model-View-Controller的模式，来简化Web开发。ASP发展为ASP.Net，JSP和PHP也有一大堆MVC框架。\n目前，Web开发技术仍在快速发展中，异步开发、新的MVVM前端技术层出不穷。\n由于Node.js把JavaScript引入了服务器端，因此，原来必须使用PHP/Java/C#/Python/Ruby等其他语言来开发服务器端程序，现在可以使用Node.js开发了！\n用Node.js开发Web服务器端，有几个显著的优势：\n一是后端语言也是JavaScript，以前掌握了前端JavaScript的开发人员，现在可以同时编写后端代码；\n二是前后端统一使用JavaScript，就没有切换语言的障碍了；\n三是速度快，非常快！这得益于Node.js天生是异步的。\n在Node.js诞生后的短短几年里，出现了无数种Web框架、ORM框架、模版引擎、测试框架、自动化构建工具，数量之多，即使是JavaScript老司机，也不免眼花缭乱。\n常见的Web框架包括：Express，Sails.js，koa，Meteor，DerbyJS，Total.js，restify……\nORM框架比Web框架要少一些：Sequelize，ORM2，Bookshelf.js，Objection.js……\n模版引擎PK：Jade，EJS，Swig，Nunjucks，doT.js……\n测试框架包括：Mocha，Expresso，Unit.js，Karma……\n构建工具有：Grunt，Gulp，Webpack……\n目前，在npm上已发布的开源Node.js模块数量超过了30万个。\n有选择恐惧症的朋友，看到这里可以洗洗睡了。\n好消息是这个教程已经帮你选好了，你只需要跟着教程一条道走到黑就可以了。\nkoa\nkoa是Express的下一代基于Node.js的web框架，目前有1.x和2.0两个版本。\n历史\nExpress\nExpress是第一代最流行的web框架，它对Node.js的http进行了封装，用起来如下：\n12345678910let express = require(&#x27;express&#x27;);let app = express();app.get(&#x27;/&#x27;, function (req, res) &#123;    res.send(&#x27;Hello World!&#x27;);&#125;);app.listen(3000, function () &#123;    console.log(&#x27;Example app listening on port 3000!&#x27;);&#125;);\n虽然Express的API很简单，但是它是基于ES5的语法，要实现异步代码，只有一个方法：回调。如果异步嵌套层次过多，代码写起来就非常难看：\n1234567891011121314app.get(&#x27;/test&#x27;, function (req, res) &#123;    fs.readFile(&#x27;/file1&#x27;, function (err, data) &#123;        if (err) &#123;            res.status(500).send(&#x27;read file1 error&#x27;);        &#125;        fs.readFile(&#x27;/file2&#x27;, function (err, data) &#123;            if (err) &#123;                res.status(500).send(&#x27;read file2 error&#x27;);            &#125;            res.type(&#x27;text/plain&#x27;);            res.send(data);        &#125;);    &#125;);&#125;);\n虽然可以用async这样的库来组织异步代码，但是用回调写异步实在是太痛苦了！\nkoa 1.x\n随着新版Node.js开始支持ES6，Express的团队又基于ES6的generator重新编写了下一代web框架koa。和Express相比，koa 1.x使用generator实现异步，代码看起来像同步的：\n12345678910let koa = require(&#x27;koa&#x27;);let app = koa();app.use(&#x27;/test&#x27;, function *() &#123;    yield doReadFile1();    let data = yield doReadFile2();    this.body = data;&#125;);app.listen(3000);\n用generator实现异步比回调简单了不少，但是generator的本意并不是异步。Promise才是为异步设计的，但是Promise的写法……想想就复杂。为了简化异步代码，JavaScript引入了新的关键字async和await，可以轻松地把一个function变为异步模式：\n123async function () &#123;    let data = await fs.read(&#x27;/file1&#x27;);&#125;\n这是JavaScript标准的异步代码，非常简洁，并且易于使用。\nkoa 2.x\nkoa团队并没有止步于koa 1.x，他们又开发了koa 2，和koa 1相比，koa 2完全使用Promise并配合async来实现异步。\nkoa 2.x的代码看上去像这样：\n123456app.use(async (ctx, next) =&gt; &#123;    await next();    let data = await doReadFile();    ctx.response.type = &#x27;text/plain&#x27;;    ctx.response.body = data;&#125;);\n选择哪个版本？\n为了紧跟时代潮流，教程将使用最新的koa 2.x开发！\n\n\n创建koa工程\n首先，我们创建一个目录hello-koa，作为koa工程根目录。\n在根目录下执行npm install koa，我们就在当前目录下安装好了koa及其依赖项，执行完成后目录结构如下：\n1234hello-koa/├── node_modules/      &lt;-- koa以及所有依赖项├── package-lock.json└── package.json       &lt;-- npm描述文件\npackage.json包含了npm的依赖信息，以及项目描述等信息，package-lock.json是针对当前所有依赖的一个快照，目的是锁定各个依赖项的版本号。\n我们打开package.json，内容如下：\n12345&#123;    &quot;dependencies&quot;: &#123;        &quot;koa&quot;: &quot;^2.15.3&quot;    &#125;&#125;\n它只有一个koa依赖，是由命令npm install koa写入的。\nnode_modules是所有依赖项安装的地方，可以随时删除node_modules目录，然后用npm install重新安装。\n直接运行npm install则根据package.json的dependencies信息下载安装依赖项，运行npm install xyz则将xyz添加到dependencies然后再安装xyz及其依赖项。因此，熟练的开发者可以先自己编辑dependencies内容，然后删除node_modules后重新安装所有依赖项。此外，package.json和package-lock.json应当添加至版本控制系统中，而node_modules则无需添加。\n我们手动添加如下信息至package.json：\n123456789&#123;    &quot;name&quot;: &quot;hello-koa&quot;,    &quot;version&quot;: &quot;1.0&quot;,    &quot;description&quot;: &quot;Hello koa webapp.&quot;,    &quot;type&quot;: &quot;module&quot;,    &quot;dependencies&quot;: &#123;        &quot;koa&quot;: &quot;^2.15.3&quot;    &#125;&#125;\n其中，name、version和description均可任意设置，type为module表示以ESM模块执行。\n紧接着，我们用VS Code打开hello-koa目录，创建app.mjs文件，输入以下代码：\n1234567891011121314151617// 导入koa，注意导入的是大写开头的class:import Koa from &#x27;koa&#x27;;// 创建一个koa实例表示webapp本身:const app = new Koa();// 对于任何请求，app将调用该异步函数处理请求：app.use(async (ctx, next) =&gt; &#123;    await next();    // 设置响应类型和文本:    ctx.response.type = &#x27;text/html&#x27;;    ctx.response.body = &#x27;&lt;h1&gt;Hello Koa!&lt;/h1&gt;&#x27;;&#125;);// 在端口3000监听:app.listen(3000);console.log(&#x27;app started at port 3000...&#x27;);\n对于每一个http请求，koa将调用我们传入的异步函数来处理：\n1234567async (ctx, next) =&gt; &#123;    await next();    // 设置response的Content-Type:    ctx.response.type = &#x27;text/html&#x27;;    // 设置response的内容:    ctx.response.body = &#x27;&lt;h1&gt;Hello Koa!&lt;/h1&gt;&#x27;;&#125;\n其中，参数ctx是由koa传入的封装了request和response的变量，我们可以通过它访问request和response，next是koa传入的将要处理的下一个异步函数。\n上面的异步函数中，我们首先用await next();处理下一个异步函数，然后，设置response的Content-Type和内容。\n现在，我们的工程结构如下：\n12345hello-koa/├── node_modules/├── app.mjs├── package-lock.json└── package.json\n在命令行执行node app.mjs就启动了Web服务器。我们打开浏览器，输入http://localhost:3000，即可看到效果：\n\nkoa middleware\n让我们再仔细看看koa的执行逻辑。核心代码是：\n12345app.use(async (ctx, next) =&gt; &#123;    await next();    ctx.response.type = &#x27;text/html&#x27;;    ctx.response.body = &#x27;&lt;h1&gt;Hello Koa!&lt;/h1&gt;&#x27;;&#125;);\n每收到一个http请求，koa就会调用通过app.use()注册的async函数，并传入ctx和next参数。\n我们可以对ctx操作，并设置返回内容。但是为什么要调用await next()？\n原因是koa把很多async函数组成一个处理链，每个async函数都可以做一些自己的事情，然后用await next()来调用下一个async函数。我们把每个async函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。\n例如，可以用以下3个middleware组成处理链，依次打印日志，记录处理时间，输出HTML：\n1234567891011121314151617app.use(async (ctx, next) =&gt; &#123;    console.log(`$&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`); // 打印URL    await next(); // 调用下一个middleware&#125;);app.use(async (ctx, next) =&gt; &#123;    const start = Date.now(); // 当前时间    await next(); // 调用下一个middleware    const ms = Date.now() - start; // 耗费时间    console.log(`Time: $&#123;ms&#125;ms`); // 打印耗费时间&#125;);app.use(async (ctx, next) =&gt; &#123;    await next();    ctx.response.type = &#x27;text/html&#x27;;    ctx.response.body = &#x27;&lt;h1&gt;Hello Koa!&lt;/h1&gt;&#x27;;&#125;);\nmiddleware的顺序很重要，也就是调用app.use()的顺序决定了middleware的顺序。\n此外，如果一个middleware没有调用await next()，会怎么办？答案是后续的middleware将不再执行了。这种情况也很常见，例如，一个检测用户权限的middleware可以决定是否继续处理请求，还是直接返回403错误：\n1234567app.use(async (ctx, next) =&gt; &#123;    if (await checkUserPermission(ctx)) &#123;        await next();    &#125; else &#123;        ctx.response.status = 403;    &#125;&#125;);\n理解了middleware，我们就已经会用koa了！\n最后注意ctx对象有一些简写的方法，例如ctx.url相当于ctx.request.url，ctx.type相当于ctx.response.type。\n参考源码\nhello-koa\n在hello-koa工程中，我们处理http请求一律返回相同的HTML，这样虽然非常简单，但是用浏览器一测，随便输入任何URL都会返回相同的网页。\n\n正常情况下，我们应该对不同的URL调用不同的处理函数，这样才能返回不同的结果。例如像这样写：\n1234567891011121314151617181920212223app.use(async (ctx, next) =&gt; &#123;    if (ctx.request.path === &#x27;/&#x27;) &#123;        ctx.response.body = &#x27;index page&#x27;;    &#125; else &#123;        await next();    &#125;&#125;);app.use(async (ctx, next) =&gt; &#123;    if (ctx.request.path === &#x27;/test&#x27;) &#123;        ctx.response.body = &#x27;TEST page&#x27;;    &#125; else &#123;        await next();    &#125;&#125;);app.use(async (ctx, next) =&gt; &#123;    if (ctx.request.path === &#x27;/error&#x27;) &#123;        ctx.response.body = &#x27;ERROR page&#x27;;    &#125; else &#123;        await next();    &#125;&#125;);\n这么写是可以运行的，但是好像有点蠢。\n应该有一个能集中处理URL的middleware，它根据不同的URL调用不同的处理函数，这样，我们才能专心为每个URL编写处理函数。\n@koa/router\n为了处理URL，我们需要引入@koa/router这个middleware，让它负责处理URL映射。\n我们把上一节的hello-koa工程复制一份，重命名为url-koa。\n先用命令npm install @koa/router安装并在package.json中添加依赖项，接下来，我们修改app.mjs，使用@koa/router来处理URL：\n12345678910111213141516171819202122232425262728293031323334import Koa from &#x27;koa&#x27;;import Router from &#x27;@koa/router&#x27;;const app = new Koa();const router = new Router();// log url:app.use(async (ctx, next) =&gt; &#123;    console.log(`Process $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;...`);    await next();&#125;);// 解析request.body:app.use(bodyParser());// 设置路由: 处理 /router.get(&#x27;/&#x27;, async (ctx, next) =&gt; &#123;    ctx.response.type = &#x27;text/html&#x27;;    ctx.response.body = &#x27;&lt;h1&gt;Index Page&lt;/h1&gt;&#x27;;&#125;);// 设置路由: 处理 /hello/:namerouter.get(&#x27;/hello/:name&#x27;, async (ctx, next) =&gt; &#123;    // 获取:name参数:    let s = ctx.params.name;    ctx.response.type = &#x27;text/html&#x27;;    ctx.response.body = `&lt;h1&gt;Hello, $&#123;s&#125;&lt;/h1&gt;`;&#125;);// 使用router:app.use(router.routes());app.listen(3000);console.log(&#x27;app started at port 3000...&#x27;);\n我们使用router.get('/path', async fn)来注册一个GET请求。可以在请求路径中使用带变量的/hello/:name，变量可以通过ctx.params.name访问。\n再运行app.mjs，我们就可以测试不同的URL：\n输入首页：http://localhost:3000/\n\n输入：http://localhost:3000/hello/Bob\n\n处理post请求\n用router.get('/path', async fn)处理的是get请求。如果要处理post请求，可以用router.post('/path', async fn)。\n用post请求处理URL时，我们会遇到一个问题：post请求通常会发送一个表单，或者JSON，它作为request的body发送，但无论是Node.js提供的原始request对象，还是koa提供的request对象，都不提供解析request的body的功能！\n所以，我们又需要引入另一个middleware来解析原始request请求，然后，把解析后的参数，绑定到ctx.request.body中。@koa/bodyparser就是用来干这个活的。\n我们用命令npm install @koa/bodyparser安装并在package.json中添加依赖项，然后，修改app.mjs，引入@koa/bodyparser：\n1import &#123; bodyParser &#125; from &#x27;@koa/bodyparser&#x27;;\n在合适的位置加上：\n1app.use(bodyParser());\n由于middleware的顺序很重要，这个@koa/bodyparser必须在router之前被注册到app对象上。\n现在我们就可以处理post请求了。写一个简单的登录表单：\n123456789101112131415161718192021222324router.get(&#x27;/&#x27;, async (ctx, next) =&gt; &#123;    ctx.response.type = &#x27;text/html&#x27;;    ctx.response.body = `&lt;h1&gt;Index Page&lt;/h1&gt;&lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;    &lt;p&gt;Name: &lt;input name=&quot;name&quot; value=&quot;koa&quot;&gt;&lt;/p&gt;    &lt;p&gt;Password: &lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;    &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/p&gt;&lt;/form&gt;`;&#125;);router.post(&#x27;/signin&#x27;, async (ctx, next) =&gt; &#123;    let name = ctx.request.body.name || &#x27;&#x27;;    let password = ctx.request.body.password || &#x27;&#x27;;    console.log(`try signin: $&#123;name&#125;, password: $&#123;password&#125;`);    if (name === &#x27;koa&#x27; &amp;&amp; password === &#x27;12345&#x27;) &#123;        ctx.response.type = &#x27;text/html&#x27;;        ctx.response.body = `&lt;h1&gt;Welcome, $&#123;name&#125;!&lt;/h1&gt;`;    &#125; else &#123;        ctx.response.type = &#x27;text/html&#x27;;        ctx.response.body = &#x27;&lt;h1&gt;Signin failed!&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;/&quot;&gt;Retry&lt;/a&gt;&lt;/p&gt;&#x27;;    &#125;&#125;);\n注意到我们用let name = ctx.request.body.name || ''拿到表单的name字段，如果该字段不存在，默认值设置为''。\n类似的，put、delete、head请求也可以由router处理。\n重构\n现在，我们已经可以处理不同的URL了，但是看看app.mjs，总觉得还是有点不对劲。\n\n所有的URL处理函数都放到app.mjs里显得很乱，而且，每加一个URL，就需要修改app.mjs。随着URL越来越多，app.mjs就会越来越长。\n如果能把URL处理函数集中到某个js文件，或者某几个js文件中就好了，然后让app.mjs自动导入所有处理URL的函数。这样，代码一分离，逻辑就显得清楚了。最好是这样：\n1234567url2-koa/├── controller/│   ├── hello.mjs   &lt;-- 处理/hello/:name│   └── signin.mjs  &lt;-- 处理/signin├── app.mjs├── package-lock.json└── package.json\n于是我们把url-koa复制一份，重命名为url2-koa，准备重构这个项目。\n我们先在controller目录下编写signin.mjs：\n1234567891011121314151617181920212223242526272829303132// GET /async function index(ctx, next) &#123;    ctx.response.type = &#x27;text/html&#x27;;    ctx.response.body = `&lt;h1&gt;Index Page&lt;/h1&gt;&lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;    &lt;p&gt;Name: &lt;input name=&quot;name&quot; value=&quot;koa&quot;&gt;&lt;/p&gt;    &lt;p&gt;Password: &lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;    &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/p&gt;&lt;/form&gt;`;&#125;// POST /signinasync function signin(ctx, next) &#123;    let name = ctx.request.body.name || &#x27;&#x27;;    let password = ctx.request.body.password || &#x27;&#x27;;    console.log(`try signin: $&#123;name&#125;, password: $&#123;password&#125;`);    if (name === &#x27;koa&#x27; &amp;&amp; password === &#x27;12345&#x27;) &#123;        ctx.response.type = &#x27;text/html&#x27;;        ctx.response.body = `&lt;h1&gt;Welcome, $&#123;name&#125;!&lt;/h1&gt;`;    &#125; else &#123;        ctx.response.type = &#x27;text/html&#x27;;        ctx.response.body = &#x27;&lt;h1&gt;Signin failed!&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;/&quot;&gt;Retry&lt;/a&gt;&lt;/p&gt;&#x27;;    &#125;&#125;// 导出处理函数:export default &#123;    &#x27;GET /&#x27;: index,    &#x27;POST /signin&#x27;: signin&#125;;\n这个signin.mjs通过export default把两个URL处理函数暴露出来。\n类似的，hello.mjs把一个URL处理函数暴露出来：\n12345678910async function hello(ctx, next) &#123;    // 获取:name参数:    let s = ctx.params.name;    ctx.response.type = &#x27;text/html&#x27;;    ctx.response.body = `&lt;h1&gt;Hello, $&#123;s&#125;&lt;/h1&gt;`;&#125;export default &#123;    &#x27;GET /hello/:name&#x27;: hello&#125;\n现在，我们修改app.mjs，让它自动扫描controller目录，找到所有js文件，导入，然后注册每个URL：\n1234567891011121314151617181920212223242526// 扫描controller目录:const dirname = path.dirname(fileURLToPath(import.meta.url));console.log(`scan dir $&#123;dirname&#125;...`);// 列举 *.mjs 文件:let files = readdirSync(path.join(dirname, &#x27;controller&#x27;)).filter(f =&gt; f.endsWith(&#x27;.mjs&#x27;));for (let file of files) &#123;    // 导入模块:    console.log(`import controller/$&#123;file&#125;...`);    let &#123; default: mapping &#125; = await import(`./controller/$&#123;file&#125;`);    // 把每个URL映射添加到router:    for (let url in mapping) &#123;        if (url.startsWith(&#x27;GET &#x27;)) &#123;            // 类似 &#x27;GET /hello/:name&#x27;            let p = url.substring(4);            router.get(p, mapping[url]);            console.log(`mapping: GET $&#123;p&#125;`);        &#125; else if (url.startsWith(&#x27;POST &#x27;)) &#123;            // 类似 &#x27;POST /signin&#x27;            let p = url.substring(5);            router.post(p, mapping[url]);            console.log(`mapping: POST $&#123;p&#125;`);        &#125; else &#123;            console.warn(`invalid mapping: $&#123;url&#125;`);        &#125;    &#125;&#125;\nController Middleware\n最后，我们把扫描controller目录和创建router的代码从app.mjs中提取出来，作为一个简单的middleware使用，命名为controller.mjs：\n123456789101112131415161718192021222324252627282930313233// controller.mjs:async function scan(router, controllerDir) &#123;    // 扫描controller目录:    const dirname = path.dirname(fileURLToPath(import.meta.url));    console.log(`scan dir $&#123;dirname&#125;...`);    let files = readdirSync(path.join(dirname, controllerDir)).filter(f =&gt; f.endsWith(&#x27;.mjs&#x27;));    for (let file of files) &#123;        // 导入模块:        console.log(`import controller/$&#123;file&#125;...`);        let &#123; default: mapping &#125; = await import(`./$&#123;controllerDir&#125;/$&#123;file&#125;`);        // 把每个URL映射添加到router:        for (let url in mapping) &#123;            if (url.startsWith(&#x27;GET &#x27;)) &#123;                let p = url.substring(4);                router.get(p, mapping[url]);                console.log(`mapping: GET $&#123;p&#125;`);            &#125; else if (url.startsWith(&#x27;POST &#x27;)) &#123;                let p = url.substring(5);                router.post(p, mapping[url]);                console.log(`mapping: POST $&#123;p&#125;`);            &#125; else &#123;                console.warn(`invalid mapping: $&#123;url&#125;`);            &#125;        &#125;    &#125;&#125;// 默认扫描目录为 controller:export default async function (controllerDir = &#x27;controller&#x27;) &#123;    const router = new Router();    await scan(router, controllerDir);    return router.routes();&#125;\n这样一来，我们在app.mjs的代码又简化了：\n12345import controller from &#x27;./controller.mjs&#x27;;...// 使用controller(), 注意controller模块导出的是async函数，要通过await调用:app.use(await controller());...\n经过重新整理后的工程url2-koa目前具备非常好的模块化，所有处理URL的函数按功能组存放在controller目录，今后我们也只需要不断往这个目录下加东西就可以了，app.mjs保持不变。\n最后我们整理一下koa处理一个HTTP请求的流程：\n1234567891011121314151617181920           │           │           ▼┌─────────────────────┐│log:                 ││async(ctx,next) &#123;...&#125;│└─────────────────────┘           │           ▼┌─────────────────────┐│bodyParser()         │└─────────────────────┘     GET /             ┌─────────────────────┐           │              ┌──────────────────▶│async(ctx,next) &#123;...&#125;│           ▼              │                   └─────────────────────┘┌─────────────────────┐   │ POST /signin      ┌─────────────────────┐│router.routes()      ├───┼──────────────────▶│async(ctx,next) &#123;...&#125;│└─────────────────────┘   │                   └─────────────────────┘                          │ GET /hello/:name  ┌─────────────────────┐                          └──────────────────▶│async(ctx,next) &#123;...&#125;│                                              └─────────────────────┘\n一个HTTP请求是按顺序由一系列注册到koa的middleware处理的，首先由log函数处理，并通过await next()把请求传递到下一个middleware，紧接着是bodyParser处理，最后是router处理。在router的内部，又会根据注册到router的HTTP方法+Path来决定由哪个async函数处理请求。如果URL没有匹配到，则简单返回404。以上就是整个基于koa的webapp处理流程，非常清晰易懂。\n参考源码\nurl\nNunjucks是什么东东？其实它是一个模板引擎。\n那什么是模板引擎？\n模板引擎就是基于模板配合数据构造出字符串输出的一个组件。比如下面的函数就是一个模板引擎：\n123function examResult (data) &#123;    return `$&#123;data.name&#125;同学一年级期末考试语文$&#123;data.chinese&#125;分，数学$&#123;data.math&#125;分，位于年级第$&#123;data.ranking&#125;名。`&#125;\n如果我们输入数据如下：\n123456examResult(&#123;    name: &#x27;小明&#x27;,    chinese: 78,    math: 87,    ranking: 999&#125;);\n该模板引擎把模板字符串里面对应的变量替换以后，就可以得到以下输出：\n1小明同学一年级期末考试语文78分，数学87分，位于年级第999名。\n模板引擎最常见的输出就是输出网页，也就是HTML文本。当然，也可以输出任意格式的文本，比如Text，XML，Markdown等等。\n有同学要问了：既然JavaScript的模板字符串可以实现模板功能，那为什么我们还需要另外的模板引擎？\n因为JavaScript的模板字符串必须写在JavaScript代码中，要想写出新浪首页这样复杂的页面，是非常困难的。\n输出HTML有几个特别重要的问题需要考虑：\n转义\n对特殊字符要转义，避免受到XSS攻击。比如，如果变量name的值不是小明，而是小明&lt;script&gt;...&lt;/script&gt;，模板引擎输出的HTML到了浏览器，就会自动执行恶意JavaScript代码。\n格式化\n对不同类型的变量要格式化，比如，货币需要变成$12,345.00这样的格式，日期需要变成2016-01-01这样的格式。\n简单逻辑\n模板还需要能执行一些简单逻辑，比如，要按条件输出内容，需要if实现如下输出：\n12345678&#123;&#123; name &#125;&#125;同学，&#123;% if score &gt;= 90 %&#125;    成绩优秀，应该奖励&#123;% elif score &gt;=60 %&#125;    成绩良好，继续努力&#123;% else %&#125;    不及格，建议回家打屁股&#123;% endif %&#125;\n所以，我们需要一个功能强大的模板引擎，来完成页面输出的功能。\nNunjucks\n我们选择Nunjucks作为模板引擎。Nunjucks是Mozilla开发的一个纯JavaScript编写的模板引擎，既可以用在Node环境下，又可以运行在浏览器端。但是，主要还是运行在Node环境下，因为浏览器端有更好的模板解决方案，例如MVVM框架。\n如果你使用过Python的模板引擎jinja2，那么使用Nunjucks就非常简单，两者的语法几乎是一模一样的，因为Nunjucks就是用JavaScript重新实现了jinjia2。\n从上面的例子我们可以看到，虽然模板引擎内部可能非常复杂，但是使用一个模板引擎是非常简单的，因为本质上我们只需要构造这样一个函数：\n123function render(view, model) &#123;    // TODO:...&#125;\n其中，view是模板的名称（又称为视图），因为可能存在多个模板，需要选择其中一个。model就是数据，在JavaScript中，它就是一个简单的Object。render函数返回一个字符串，就是模板的输出。\n下面我们来使用Nunjucks这个模板引擎来编写几个HTML模板，并且用实际数据来渲染模板并获得最终的HTML输出。\n我们创建一个use-nunjucks的VS Code工程结构如下：\n12345678use-nunjucks/├── app.mjs├── package-lock.json├── package.json└── view    ├── base.html    &lt;-- HTML模板文件    ├── extend.html  &lt;-- HTML模板文件    └── hello.html   &lt;-- HTML模板文件\n其中，模板文件存放在view目录中。\n我们先用npm install nunjucks安装依赖项并在package.json中添加nunjucks的依赖：\n1&quot;nunjucks&quot;: &quot;^3.2.4&quot;\n注意，模板引擎是可以独立使用的，并不需要依赖koa。\n紧接着，我们要编写使用Nunjucks的函数render。怎么写？方法是查看Nunjucks的官方文档，仔细阅读后，在app.js中编写代码如下：\n123456789101112131415161718192021222324import nunjucks from &#x27;nunjucks&#x27;;function createEnv(path, &#123; autoescape = true, noCache = false, watch = false, throwOnUndefined = false &#125;, filters = &#123;&#125;) &#123;    const loader = new nunjucks.FileSystemLoader(path, &#123;        noCache: noCache,        watch: watch    &#125;);    const env = new nunjucks.Environment(loader, &#123;        autoescape: autoescape,        throwOnUndefined: throwOnUndefined    &#125;);    for (let name in filters) &#123;        env.addFilter(name, filters[name]);    &#125;    return env;&#125;const env = createEnv(&#x27;view&#x27;, &#123;    noCache: true&#125;, &#123;    hex: function (n) &#123;        return &#x27;0x&#x27; + n.toString(16);    &#125;&#125;);\n变量env就表示Nunjucks模板引擎对象，它有一个render(view, model)方法，正好传入view和model两个参数，并返回字符串。\n创建env需要的参数可以查看文档获知。我们用关键字参数作为默认值，最后使用new nunjucks.FileSystemLoader('view')创建一个文件系统加载器，从view目录读取模板。\n我们编写一个hello.html模板文件，放到view目录下，内容如下：\n1&lt;h1&gt;Hello &#123;&#123; name &#125;&#125;&lt;/h1&gt;\n然后，我们就可以用下面的代码来渲染这个模板：\n12const s = env.render(&#x27;hello.html&#x27;, &#123; name: &#x27;小明&#x27; &#125;);console.log(s);\n获得输出如下：\n1&lt;h1&gt;Hello 小明&lt;/h1&gt;\n咋一看，这和使用JavaScript模板字符串没啥区别嘛。不过，试试：\n12const s = env.render(&#x27;hello.html&#x27;, &#123; name: &#x27;&lt;script&gt;alert(&quot;小明&quot;)&lt;/script&gt;&#x27; &#125;);console.log(s);\n获得输出如下：\n1&lt;h1&gt;Hello &amp;lt;script&amp;gt;alert(&quot;小明&quot;)&amp;lt;/script&amp;gt;&lt;/h1&gt;\n这样就避免了输出恶意脚本。\n此外，可以使用Nunjucks提供的功能强大的tag，编写条件判断、循环等功能，例如：\n1234567&lt;!-- 循环输出名字 --&gt;&lt;body&gt;    &lt;h3&gt;Fruits List&lt;/h3&gt;    &#123;% for f in fruits %&#125;    &lt;p&gt;&#123;&#123; f &#125;&#125;&lt;/p&gt;    &#123;% endfor %&#125;&lt;/body&gt;\nNunjucks模板引擎最强大的功能在于模板的继承。仔细观察各种网站可以发现，网站的结构实际上是类似的，头部、尾部都是固定格式，只有中间页面部分内容不同。如果每个模板都重复头尾，一旦要修改头部或尾部，那就需要改动所有模板。\n更好的方式是使用继承。先定义一个基本的网页框架base.html：\n12345&lt;html&gt;&lt;body&gt;&#123;% block header %&#125; &lt;h3&gt;Unnamed&lt;/h3&gt; &#123;% endblock %&#125;&#123;% block body %&#125; &lt;div&gt;No body&lt;/div&gt; &#123;% endblock %&#125;&#123;% block footer %&#125; &lt;div&gt;copyright&lt;/div&gt; &#123;% endblock %&#125;&lt;/body&gt;\nbase.html定义了三个可编辑的块，分别命名为header、body和footer。子模板可以有选择地对块进行重新定义：\n12345&#123;% extends &#x27;base.html&#x27; %&#125;&#123;% block header %&#125;&lt;h1&gt;&#123;&#123; header &#125;&#125;&lt;/h1&gt;&#123;% endblock %&#125;&#123;% block body %&#125;&lt;p&gt;&#123;&#123; body &#125;&#125;&lt;/p&gt;&#123;% endblock %&#125;\n然后，我们对子模板进行渲染：\n1234console.log(env.render(&#x27;extend.html&#x27;, &#123;    header: &#x27;Hello&#x27;,    body: &#x27;bla bla bla...&#x27;&#125;));\n输出HTML如下：\n12345&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;p&gt;bla bla bla...&lt;/p&gt;&lt;div&gt;copyright&lt;/div&gt; &lt;-- footer没有重定义，所以仍使用父模板的内容&lt;/body&gt;\n性能\n最后我们要考虑一下Nunjucks的性能。\n对于模板渲染本身来说，速度是非常非常快的，因为就是拼字符串嘛，纯CPU操作。\n性能问题主要出现在从文件读取模板内容这一步。这是一个IO操作，在Node.js环境中，我们知道，单线程的JavaScript最不能忍受的就是同步IO，但Nunjucks默认就使用同步IO读取模板文件。\n好消息是Nunjucks会缓存已读取的文件内容，也就是说，模板文件最多读取一次，就会放在内存中，后面的请求是不会再次读取文件的，只要我们指定了noCache: false这个参数。\n在开发环境下，可以关闭cache，这样每次重新加载模板，便于实时修改模板。在生产环境下，一定要打开cache，这样就不会有性能问题。\nNunjucks也提供了异步读取的方式，但是这样写起来很麻烦，有简单的写法我们就不会考虑复杂的写法。保持代码简单是可维护性的关键。\n参考源码\nuse-nunjucks\n我们已经可以用koa处理不同的URL，还可以用Nunjucks渲染模板。现在，是时候把这两者结合起来了！\n当用户通过浏览器请求一个URL时，koa将调用某个异步函数处理该URL。在这个异步函数内部，我们用一行代码：\n1ctx.render(&#x27;home.html&#x27;, &#123; name: &#x27;Michael&#x27; &#125;);\n通过Nunjucks把数据用指定的模板渲染成HTML，然后输出给浏览器，用户就可以看到渲染后的页面了：\n12345678910111213141516171819202122232425262728293031323334             ┌─────────────────────────────┐HTTP Request │GET /Bob                     │             └─────────────────────────────┘                            │                            │ name = Bob                            ▼             ┌─────────────────────────────┐     app.mjs │GET /:name                   │             │async (ctx, next) &#123;          │             │    ctx.render(&#x27;home.html&#x27;, &#123;│             │        name: ctx.params.name│             │    &#125;);                      │             │&#125;                            │             └─────────────────────────────┘                            │                            │ &#123;&#123; name &#125;&#125; ─▶ Bob                            ▼             ┌─────────────────────────────┐    Template │&lt;html&gt;                       │             │&lt;body&gt;                       │             │    &lt;p&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;/p&gt;│             │&lt;/body&gt;                      │             │&lt;/html&gt;                      │             └─────────────────────────────┘                            │                            │ Output                            ▼             ┌─────────────────────────────┐        HTML │&lt;html&gt;                       │             │&lt;body&gt;                       │             │    &lt;p&gt;Hello, Bob!&lt;/p&gt;       │             │&lt;/body&gt;                      │             │&lt;/html&gt;                      │             └─────────────────────────────┘\n这就是传说中的MVC：Model-View-Controller，中文名“模型-视图-控制器”。\n异步函数是C：Controller，Controller负责业务逻辑，比如检查用户名是否存在，取出用户信息等等；\n包含变量&#123;&#123; name &#125;&#125;的模板就是V：View，View负责显示逻辑，通过简单地替换一些变量，View最终输出的就是用户看到的HTML。\nMVC中的Model在哪？Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。\n上面的例子中，Model就是一个JavaScript对象：\n1&#123; name: &#x27;Bob&#x27; &#125;\n下面，我们根据原来的url2-koa创建工程view-koa，把koa2、Nunjucks整合起来，然后，把原来直接输出字符串的方式，改为ctx.render(view, model)的方式。\n工程koa-mvc结构如下：\n1234567891011121314151617koa-mvc/├── app.mjs├── controller│   ├── index.mjs│   └── signin.mjs├── controller.mjs├── package-lock.json├── package.json├── static/  &lt;-- 静态资源文件│   ├── bootstrap.css│   └── favicon.ico├── view/  &lt;-- html模板文件│   ├── base.html│   ├── index.html│   ├── signin-failed.html│   └── signin-ok.html└── view.mjs\n在package.json中，我们将要用到的依赖包有：\n123456&quot;@koa/bodyparser&quot;: &quot;^5.1.1&quot;,&quot;@koa/router&quot;: &quot;^12.0.1&quot;,&quot;koa&quot;: &quot;^2.15.3&quot;,&quot;koa-mount&quot;: &quot;^4.0.0&quot;,&quot;koa-static&quot;: &quot;^5.0.0&quot;,&quot;nunjucks&quot;: &quot;^3.2.4&quot;\n先用npm install安装依赖包，然后，我们准备编写以下两个Controller：\n处理首页 GET /\n我们定义一个async函数处理首页URL/：\n12345async function index(ctx, next) &#123;    ctx.render(&#x27;index.html&#x27;, &#123;        title: &#x27;Welcome&#x27;    &#125;);&#125;\n注意到koa并没有在ctx对象上提供render方法，这里我们假设应该这么使用，这样，我们在编写Controller的时候，最后一步调用ctx.render(view, model)就完成了页面输出。\n处理登录请求 POST /signin\n我们再定义一个async函数处理登录请求/signin：\n12345678910111213141516async function signin(ctx, next) &#123;    let email = ctx.request.body.email || &#x27;&#x27;;    let password = ctx.request.body.password || &#x27;&#x27;;    if (email === &#x27;admin@example.com&#x27; &amp;&amp; password === &#x27;123456&#x27;) &#123;        console.log(&#x27;signin ok!&#x27;);        ctx.render(&#x27;signin-ok.html&#x27;, &#123;            title: &#x27;Sign In OK&#x27;,            name: &#x27;Mr Bob&#x27;        &#125;);    &#125; else &#123;        console.log(&#x27;signin failed!&#x27;);        ctx.render(&#x27;signin-failed.html&#x27;, &#123;            title: &#x27;Sign In Failed&#x27;        &#125;);    &#125;&#125;\n由于登录请求是一个POST，我们就用ctx.request.body.&lt;name&gt;拿到POST请求的数据，并给一个默认值。\n登录成功时我们用signin-ok.html渲染，登录失败时我们用signin-failed.html渲染，所以，我们一共需要以下3个View：\n\nindex.html\nsignin-ok.html\nsignin-failed.html\n\n编写View\n在编写View的时候，我们实际上是在编写HTML页。为了让页面看起来美观大方，使用一个现成的CSS框架是非常有必要的。我们用Bootstrap这个CSS框架。从首页下载zip包后解压，我们把所有静态资源文件放到/static目录下，这样我们在编写HTML的时候，可以直接用Bootstrap的CSS，像这样：\n1&lt;link rel=&quot;stylesheet&quot; href=&quot;/static/bootstrap.css&quot;&gt;\n现在，在使用MVC之前，第一个问题来了，如何处理静态文件？\n我们把所有静态资源文件全部放入/static目录，目的就是能统一处理静态文件。在koa中，我们需要编写一个middleware，处理以/static/开头的URL。\n如果不想自己编写处理静态文件的middleware，可以直接使用koa-mount和koa-static组合来处理静态文件：\n12// 处理静态文件:app.use(mount(&#x27;/static&#x27;, serve(&#x27;static&#x27;)));\n上述代码大致相当于自己手写一个middleware：\n12345678910111213141516171819app.use(async (ctx, next) =&gt; &#123;    // 判断是否以指定的url开头:    if (ctx.request.path.startsWith(&#x27;/static/&#x27;)) &#123;        // 获取文件完整路径:        let fp = ctx.request.path;        if (await fs.exists(ctx.request.path)) &#123;            // 根据扩展名设置mime:            ctx.response.type = lookupMime(ctx.request.path);            // 读取文件内容并赋值给response.body:            ctx.response.body = await fs.readFile(fp);        &#125; else &#123;            // 文件不存在:            ctx.response.status = 404;        &#125;    &#125; else &#123;        // 不是指定前缀的URL，继续处理下一个middleware:        await next();    &#125;&#125;);\n集成Nunjucks\n集成Nunjucks实际上也是编写一个middleware，这个middleware的作用是给ctx对象绑定一个render(view, model)的方法，这样，后面的Controller就可以调用这个方法来渲染模板了。\n我们创建一个view.mjs来实现这个middleware：\n12345678910111213import nunjucks from &#x27;nunjucks&#x27;;function createEnv(path, &#123; autoescape = true, noCache = false, watch = false, throwOnUndefined = false &#125;, filters = &#123;&#125;) &#123;    ...    return env;&#125;const env = createEnv(&#x27;view&#x27;, &#123;    noCache: process.env.NODE_ENV !== &#x27;production&#x27;&#125;);// 导出env对象:export default env;\n使用的时候，我们在app.mjs添加如下代码：\n12345678import templateEngine from &#x27;./view.mjs&#x27;;// app.context是每个请求创建的ctx的原型,// 因此把render()方法绑定在原型对象上:app.context.render = function (view, model) &#123;    this.response.type = &#x27;text/html; charset=utf-8&#x27;;    this.response.body = templateEngine.render(view, Object.assign(&#123;&#125;, this.state || &#123;&#125;, model || &#123;&#125;));&#125;;\n注意到createEnv()函数和前面使用Nunjucks时编写的函数是一模一样的。\n这里我们判断当前环境是否是production环境。如果是，就使用缓存，如果不是，就关闭缓存。在开发环境下，关闭缓存后，我们修改View，可以直接刷新浏览器看到效果，否则，每次修改都必须重启Node程序，会极大地降低开发效率。\nNode.js在全局变量process中定义了一个环境变量env.NODE_ENV，为什么要使用该环境变量？因为我们在开发的时候，环境变量应该设置为'development'，而部署到服务器时，环境变量应该设置为'production'。在编写代码的时候，要根据当前环境作不同的判断。\n注意：生产环境上必须配置环境变量NODE_ENV = 'production'，而开发环境不需要配置，实际上NODE_ENV可能是undefined，所以判断的时候，不要用NODE_ENV === 'development'。\n类似的，我们在使用上面编写的处理静态文件的middleware时，也可以根据环境变量判断：\n123if (!isProduction) &#123;    app.use(mount(&#x27;/static&#x27;, serve(&#x27;static&#x27;)));&#125;\n这是因为在生产环境下，静态文件是由部署在最前面的反向代理服务器（如Nginx）处理的，Node程序不需要处理静态文件。而在开发环境下，我们希望koa能顺带处理静态文件，否则，就必须手动配置一个反向代理服务器，这样会导致开发环境非常复杂。\n编写View\n在编写View的时候，非常有必要先编写一个base.html作为骨架，其他模板都继承自base.html，这样，才能大大减少重复工作。\n编写HTML不在本教程的讨论范围之内。这里我们参考Bootstrap的官网简单编写了base.html。\n运行\n一切顺利的话，这个koa-mvc工程应该可以顺利运行。运行前，我们再检查一下app.mjs里的middleware的顺序：\n第一个middleware是记录URL以及页面执行时间：\n1234567app.use(async (ctx, next) =&gt; &#123;    console.log(`Process $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;...`);    const start = Date.now();    await next();    const execTime = Date.now() - start;    ctx.response.set(&#x27;X-Response-Time&#x27;, `$&#123;execTime&#125;ms`);&#125;);\n第二个middleware处理静态文件：\n123if (!isProduction) &#123;    app.use(mount(&#x27;/static&#x27;, serve(&#x27;static&#x27;)));&#125;\n第三个middleware解析POST请求：\n1app.use(bodyParser());\n最后一个middleware处理URL路由：\n1app.use(await controller());\n现在，用node app.mjs运行代码，不出意外的话，在浏览器输入localhost:3000/，可以看到首页内容：\n\n直接在首页登录，如果输入正确的Email和Password，进入登录成功的页面：\n\n如果输入的Email和Password不正确，进入登录失败的页面：\n\n怎么判断正确的Email和Password？目前我们在signin.js中是这么判断的：\n123if (email === &#x27;admin@example.com&#x27; &amp;&amp; password === &#x27;123456&#x27;) &#123;    ...&#125;\n当然，真实的网站会根据用户输入的Email和Password去数据库查询并判断登录是否成功，不过这需要涉及到Node.js环境如何操作数据库，我们后面再讨论。\n如果要以production模式启动app，需要设置环境变量，可以通过以下命令启动：\n1$ NODE_ENV=production node app.mjs\n这样模板缓存将生效，同时不再响应静态文件请求。\n扩展\n注意到ctx.render内部渲染模板时，Model对象并不是传入的model变量，而是：\n1Object.assign(&#123;&#125;, ctx.state || &#123;&#125;, model || &#123;&#125;)\n这个小技巧是为了扩展。\n首先，model || &#123;&#125;确保了即使传入undefined，model也会变为默认值&#123;&#125;。Object.assign()会把除第一个参数外的其他参数的所有属性复制到第一个参数中。第二个参数是ctx.state || &#123;&#125;，这个目的是为了能把一些公共的变量放入ctx.state并传给View。\n例如，某个middleware负责检查用户权限，它可以把当前用户放入ctx.state中：\n123456789app.use(async (ctx, next) =&gt; &#123;    var user = tryGetUserFromCookie(ctx.request);    if (user) &#123;        ctx.state.user = user;        await next();    &#125; else &#123;        ctx.response.status = 403;    &#125;&#125;);\n这样就没有必要在每个Controller的async函数中都把user变量放入model中。\n参考源码\nkoa-mvc\n自从Roy Fielding博士在2000年他的博士论文中提出REST（Representational State Transfer）风格的软件架构模式后，REST就基本上迅速取代了复杂而笨重的SOAP，成为Web API的标准了。\n什么是Web API呢？\n如果我们想要获取某个电商网站的某个商品，输入http://localhost:3000/products/123，就可以看到id为123的商品页面，但这个结果是HTML页面，它同时混合包含了Product的数据和Product的展示两个部分。对于用户来说，阅读起来没有问题，但是，如果机器读取，就很难从HTML中解析出Product的数据。\n如果一个URL返回的不是HTML，而是机器能直接解析的数据，这个URL就可以看成是一个Web API。比如，读取http://localhost:3000/api/products/123，如果能直接返回Product的数据，那么机器就可以直接读取。\nREST就是一种设计API的模式。最常用的数据格式是JSON。由于JSON能直接被JavaScript读取，所以，以JSON格式编写的REST风格的API具有简单、易读、易用的特点。\n编写API有什么好处呢？由于API就是把Web App的功能全部封装了，所以，通过API操作数据，可以极大地把前端和后端的代码隔离，使得后端代码易于测试，前端代码编写更简单。\n此外，如果我们把前端页面看作是一种用于展示的客户端，那么API就是为客户端提供数据、操作数据的接口。这种设计可以获得极高的扩展性。例如，当用户需要在手机上购买商品时，只需要开发针对iOS和Android的两个客户端，通过客户端访问API，就可以完成通过浏览器页面提供的功能，而后端代码基本无需改动。\n当一个Web应用以API的形式对外提供功能时，整个应用的结构就扩展为：\n\n把网页视为一种客户端，是REST架构可扩展的一个关键。\nREST API规范\n编写REST API，实际上就是编写处理HTTP请求的async函数，不过，REST请求和普通的HTTP请求有几个特殊的地方：\n\nREST请求仍然是标准的HTTP请求，但是，除了GET请求外，POST、PUT等请求的body是JSON数据格式，请求的Content-Type为application/json；\nREST响应返回的结果是JSON数据格式，因此，响应的Content-Type也是application/json。\n\nREST规范定义了资源的通用访问格式，虽然它不是一个强制要求，但遵守该规范可以让人易于理解。\n例如，商品Product就是一种资源。获取所有Product的URL如下：\n1GET /api/products\n而获取某个指定的Product，例如，id为123的Product，其URL如下：\n1GET /api/products/123\n新建一个Product使用POST请求，JSON数据包含在body中，URL如下：\n1POST /api/products\n更新一个Product使用PUT请求，例如，更新id为123的Product，其URL如下：\n1PUT /api/products/123\n删除一个Product使用DELETE请求，例如，删除id为123的Product，其URL如下：\n1DELETE /api/products/123\n资源还可以按层次组织。例如，获取某个Product的所有评论，使用：\n1GET /api/products/123/reviews\n当我们只需要获取部分数据时，可通过参数限制返回的结果集，例如，返回第2页评论，每页10项，按时间排序：\n1GET /api/products/123/reviews?page=2&amp;size=10&amp;sort=time\nkoa处理REST\n既然我们已经使用koa作为Web框架处理HTTP请求，因此，我们仍然可以在koa中响应并处理REST请求。\n我们复制上一节的工程，重命名为koa-rest，然后准备添加REST API。\n对于controller来说，我们只要返回如下内容即可视为一个REST API：\n12345ctx.body =  &#123;    id: 12345,    name: &#x27;Bob&#x27;,    description: &#x27;A rest api&#x27;&#125;;\nkoa检测到ctx.body的赋值是一个JavaScript对象时，自动把这个Object变成JSON字符串输出，无需任何额外配置和代码。\n提示\nctx.body是ctx.response.body的引用，两者是等同的。\n我们给signin.mjs添加两个REST API：\n\nGET /api/users/:id：根据id获取用户信息；\nPOST /api/signin：发送一个POST请求，并返回登录结果。\n\n获取用户信息的async函数如下：\n123456789101112131415// /api/users/:idasync function user_info(ctx, next) &#123;    let id = ctx.params.id;    if (id === &#x27;12345&#x27;) &#123;        ctx.body = &#123;            id: 12345,            email: &#x27;admin@example.com&#x27;,            name: &#x27;Bob&#x27;        &#125;;    &#125; else &#123;        ctx.body = &#123;            error: &#x27;USER_NOT_FOUND&#x27;        &#125;;    &#125;&#125;\n处理登录请求的async函数如下：\n1234567891011121314151617async function signin(ctx, next) &#123;    let email = ctx.request.body.email || &#x27;&#x27;;    let password = ctx.request.body.password || &#x27;&#x27;;    if (email === &#x27;admin@example.com&#x27; &amp;&amp; password === &#x27;123456&#x27;) &#123;        console.log(&#x27;signin ok!&#x27;);        ctx.body = &#123;            id: 12345,            email: email,            name: &#x27;Bob&#x27;        &#125;;    &#125; else &#123;        console.log(&#x27;signin failed!&#x27;);        ctx.body = &#123;            error: &#x27;SIGNIN_FAILED&#x27;        &#125;;    &#125;&#125;\n当发生错误时，返回的信息包含error字段，客户端依靠该字段来判断是否出错。\n最后导出URL处理函数：\n1234export default &#123;    &#x27;POST /api/signin&#x27;: signin,    &#x27;GET /api/users/:id&#x27;: user_info&#125;;\n现在，我们可以直接在浏览器测试GET请求：\n\n输入无效的ID，返回错误：\n\n对于POST请求，我们无法直接在浏览器测试，可以用curl命令测试如下：\n12345678$ curl -H &#x27;Content-Type: application/json&#x27; \\-d &#x27;&#123;&quot;email&quot;:&quot;admin@example.com&quot;,&quot;password&quot;:&quot;123456&quot;&#125;&#x27; \\http://localhost:3000/api/signin&#123;  &quot;id&quot;: 12345,  &quot;email&quot;: &quot;admin@example.com&quot;,  &quot;name&quot;: &quot;Bob&quot;&#125;\n输入错误的口令，返回错误信息：\n123456$ curl -H &#x27;Content-Type: application/json&#x27; \\-d &#x27;&#123;&quot;email&quot;:&quot;admin@example.com&quot;,&quot;password&quot;:&quot;invalid&quot;&#125;&#x27; \\http://localhost:3000/api/signin&#123;  &quot;error&quot;: &quot;SIGNIN_FAILED&quot;&#125;\n由于我们把登录从传统的POST表单改成了REST，因此，前端页面需要编写JavaScript代码来发送REST请求，修改HTML如下：\n1234&lt;!-- 给form加上onsubmit回调函数 --&gt;&lt;form id=&quot;signin-form&quot; onsubmit=&quot;return signin()&quot;&gt;    ...&lt;/form&gt;\n用JavaScript发送REST请求如下：\n12345678910111213141516171819202122232425262728293031323334353637function signin() &#123;    // 获取表单输入:    let form = document.querySelector(&#x27;#signin-form&#x27;);    let email = form.querySelector(&#x27;input[name=email]&#x27;).value;    let password = form.querySelector(&#x27;input[name=password]&#x27;).value;    // REST请求的数据:    let data = &#123;        email: email,        password: password    &#125;;    // 发送请求:    fetch(&#x27;/api/signin&#x27;, &#123;        // 以POST方式发送:        method: &#x27;POST&#x27;,        headers: &#123;            // Content-Type设置为JSON:            &#x27;Content-Type&#x27;: &#x27;application/json&#x27;        &#125;,        // 发送数据序列化为JSON:        body: JSON.stringify(data)    &#125;).then(resp =&gt; &#123;        // 收到响应后解析JSON数据:        resp.json().then(result =&gt; &#123;            // 解析后的数据:            console.log(result);            // 判断是否有error字段:            if (result.error) &#123;                alert(`Sign in failed: $&#123;result.error&#125;`);            &#125; else &#123;                // 登录成功,取出name字段:                alert(`Welcome, $&#123;result.name&#125;!`);            &#125;        &#125;);    &#125;);    // 必须返回false以取消浏览器自动提交表单:    return false;&#125;\n可见，在koa中处理REST请求是非常简单的。bodyParser()这个middleware可以解析请求的JSON数据并绑定到ctx.request.body上，输出JSON时我们把JavaScript对象赋值给ctx.response.body就完成了REST请求的处理。\n参考源码\nkoa-rest\n程序运行的时候，数据都是在内存中的。当程序终止的时候，通常都需要将数据保存到磁盘上，无论是保存到本地磁盘，还是通过网络保存到服务器上，最终都会将数据写入磁盘文件。\n而如何定义数据的存储格式就是一个大问题。如果我们自己来定义存储格式，比如保存一个班级所有学生的成绩单：\n\n\n\n名字\n成绩\n\n\n\n\nMichael\n99\n\n\nBob\n85\n\n\nBart\n59\n\n\nLisa\n87\n\n\n\n我们可以用一个文本文件保存，一行保存一个学生，用,隔开：\n1234Michael,99Bob,85Bart,59Lisa,87\n还可以用JSON格式保存，也是文本文件：\n123456[    &#123;&quot;name&quot;:&quot;Michael&quot;,&quot;score&quot;:99&#125;,    &#123;&quot;name&quot;:&quot;Bob&quot;,&quot;score&quot;:85&#125;,    &#123;&quot;name&quot;:&quot;Bart&quot;,&quot;score&quot;:59&#125;,    &#123;&quot;name&quot;:&quot;Lisa&quot;,&quot;score&quot;:87&#125;]\n还可以定义各种保存格式，但是问题来了：\n存储和读取需要自己实现，JSON还是标准，自己定义的格式就各式各样了；\n不能做快速查询，只有把数据全部读到内存中才能自己遍历，但有时候数据的大小远远超过了内存，根本无法全部读入内存。\n为了便于程序保存和读取数据，而且，能直接通过条件快速查询到指定的数据，就出现了数据库（Database）这种专门用于集中存储和查询的软件。\n数据库软件诞生的历史非常久远，早在1950年数据库就诞生了。经历了网状数据库，层次数据库，我们现在广泛使用的关系数据库是20世纪70年代基于关系模型的基础上诞生的。\n关系模型有一套复杂的数学理论，但是从概念上是十分容易理解的。举个学校的例子：\n假设某个XX省YY市ZZ县第一实验小学有3个年级，要表示出这3个年级，可以在Excel中用一个表格画出来：\n\n每个年级又有若干个班级，要把所有班级表示出来，可以在Excel中再画一个表格：\n\n这两个表格有个映射关系，就是根据Grade_ID可以在班级表中查找到对应的所有班级：\n\n也就是Grade表的每一行对应Class表的多行，在关系数据库中，这种基于表（Table）的一对多的关系就是关系数据库的基础。\n根据某个年级的ID就可以查找所有班级的行，这种查询语句在关系数据库中称为SQL语句，可以写成：\n1SELECT * FROM classes WHERE grade_id = &#x27;1&#x27;;\n结果也是一个表：\n\n\n\ngrade_id\nclass_id\nname\n\n\n\n\n1\n11\n一年级一班\n\n\n1\n12\n一年级二班\n\n\n1\n13\n一年级三班\n\n\n\n类似的，Class表的一行记录又可以关联到Student表的多行记录：\n\n由于本教程不涉及到关系数据库的详细内容，如果你想从零学习关系数据库和基本的SQL语句，请参考SQL教程。\nNoSQL\n你也许还听说过NoSQL数据库，很多NoSQL宣传其速度和规模远远超过关系数据库，所以很多同学觉得有了NoSQL是否就不需要SQL了呢？千万不要被他们忽悠了，连SQL都不明白怎么可能搞明白NoSQL呢？\n数据库类别\n既然我们要使用关系数据库，就必须选择一个关系数据库。目前广泛使用的关系数据库也就这么几种：\n付费的商用数据库：\n\nOracle，典型的高富帅；\nSQL Server，微软自家产品，Windows定制专款；\nDB2，IBM的产品，听起来挺高端；\nSybase，曾经跟微软是好基友，后来关系破裂，现在家境惨淡。\n\n这些数据库都是不开源而且付费的，最大的好处是花了钱出了问题可以找厂家解决，不过在Web的世界里，常常需要部署成千上万的数据库服务器，当然不能把大把大把的银子扔给厂家，所以，无论是Google、Facebook，还是国内的BAT，无一例外都选择了免费的开源数据库：\n\nMySQL，大家都在用，一般错不了；\nPostgreSQL，学术气息有点重，其实挺不错，但知名度没有MySQL高；\nSQLite，嵌入式数据库，适合桌面和移动应用。\n\n作为一个JavaScript全栈工程师，选择哪个免费数据库呢？这里我们用SQLite，作为嵌入式数据库，优点是不用安装任何软件，直接能用。当然，在生产环境下，应当选择MySQL或者PostgreSQL。\n在Node.js中，访问不同的数据库需要安装不同的数据库驱动。\n因为我们使用Sqlite，所以需要安装Sqlite的驱动。这里我们选择sqlite3这个驱动，它内置sqlite。\nsqlite3通过如下代码可以创建一个db对象：\n12// 指定模式打开test.db:const db = new sqlite3.Database(&#x27;test.db&#x27;, sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE | sqlite3.OPEN_FULLMUTEX);\n我们传入了OPEN_CREATE参数，表示如果数据库不存在则自动创建，在开发模式下非常方便。\nsqlite3使用回调模式执行查询和更新操作，代码如下：\n123456// query:db.all(&#x27;SELECT * FROM users WHERE id=?&#x27;, [1], function (err, rows) &#123;&#125;);// update:db.run(&#x27;UPDATE users SET name=? WHERE id=?&#x27;, [&#x27;Bob&#x27;, 1], function (err) &#123;&#125;);\n回调模式写起来非常别扭，由于sqlite3没有提供Promise接口，因此无法使用await调用，怎么办？\n答案是我们自己封装一个Promise调用，以便通过await来实现异步查询和更新：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// db.mjs:import sqlite3 from &#x27;sqlite3&#x27;;export function createDatabase(file) &#123;    const db = new sqlite3.Database(file, sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE | sqlite3.OPEN_FULLMUTEX);    const wrapper = &#123;        db: db    &#125;;    // 执行update:    wrapper.update = async function (strs, ...params) &#123;        return new Promise((resolve, reject) =&gt; &#123;            let sql = strs.join(&#x27;?&#x27;);            db.run(sql, ...params, function (err) &#123;                if (err) &#123;                    reject(err);                &#125; else &#123;                    resolve(this.changes);                &#125;            &#125;);        &#125;);    &#125;;    // 执行insert并返回lastID:    wrapper.insert = async function (strs, ...params) &#123;        return new Promise((resolve, reject) =&gt; &#123;            let sql = strs.join(&#x27;?&#x27;);            db.run(sql, ...params, function (err) &#123;                if (err) &#123;                    reject(err);                &#125; else &#123;                    resolve(this.lastID);                &#125;            &#125;);        &#125;);    &#125;;    // 查询数据,返回array:    wrapper.select = async function (strs, ...params) &#123;        return new Promise((resolve, reject) =&gt; &#123;            let sql = strs.join(&#x27;?&#x27;);            if (debug) &#123;                console.log(`sql = $&#123;sql&#125;, params = [$&#123;params.join(&#x27;, &#x27;)&#125;]`);            &#125;            db.all(sql, ...params, function (err, rows) &#123;                if (err) &#123;                    reject(err);                &#125; else &#123;                    resolve(rows);                &#125;            &#125;);        &#125;);    &#125;;    // 查询一行数据,不存在返回null:    wrapper.fetch = async function (strs, ...params) &#123;        ...    &#125;;    return wrapper;&#125;\n我们复制前面的koa-mvc工程，命名为sql，准备用实际数据库替换写死的登录逻辑。工程结构如下：\n1234sql/├── app.mjs├── db.mjs└── ...\n通过npm install sqlite3安装依赖项并添加依赖：\n1&quot;sqlite3&quot;: &quot;^5.1.7&quot;\n增加了db.mjs，实现了对sqlite数据库的操作。\n我们在app.mjs中初始化一个db对象并绑定到app.context中：\n123456789101112131415161718192021import &#123; createDatabase &#125; from &#x27;./db.mjs&#x27;;async function initDb() &#123;    const email = &#x27;admin@example.com&#x27;;    const name = &#x27;Bob&#x27;;    const password = &#x27;123456&#x27;;    // 创建db对象:    const db = createDatabase(&#x27;test.db&#x27;);    // 如果users表不存在则创建表:    await db.update`CREATE TABLE IF NOT EXISTS users(id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, email TEXT NOT NULL UNIQUE, name TEXT NOT NULL, password TEXT NOT NULL)`;    // 查询admin用户:    let user = await db.fetch`SELECT * FROM users WHERE email=$&#123;email&#125;`;    // 用户不存在则自动创建:    if (user === null) &#123;        await db.insert`INSERT INTO users (email, name, password) VALUES ($&#123;email&#125;, $&#123;name&#125;, $&#123;password&#125;)`;    &#125;    return db;&#125;// 绑定db到app.context:app.context.db = await initDb();\n注意到initDb()中自动创建表和用户的代码都是为了便于开发。\n有了数据库支持，我们就可以把signin.mjs写死的代码替换为查询数据库用户：\n12345678910111213141516171819// signin:async function signin(ctx, next) &#123;    let email = ctx.request.body.email || &#x27;&#x27;;    let password = ctx.request.body.password || &#x27;&#x27;;    // 从数据库查询用户:    let user = await ctx.db.fetch`SELECT * FROM users WHERE email=$&#123;email&#125;`;    if (user !== null &amp;&amp; user.password === password) &#123;        console.log(&#x27;signin ok!&#x27;);        ctx.render(&#x27;signin-ok.html&#x27;, &#123;            title: &#x27;Sign In OK&#x27;,            name: user.name        &#125;);    &#125; else &#123;        console.log(&#x27;signin failed!&#x27;);        ctx.render(&#x27;signin-failed.html&#x27;, &#123;            title: &#x27;Sign In Failed&#x27;        &#125;);    &#125;&#125;\n观察上述代码，我们查询数据库中某个用户的代码如下：\n1let user = await ctx.db.fetch`SELECT * FROM users WHERE email=$&#123;email&#125;`;\n这是一个标签函数，它自动将参数变为如下调用：\n1let user = await ctx.db.fetch([&#x27;SELECT * FROM users WHERE email=&#x27;, &#x27;&#x27;], email);\n在函数内部，实际执行的SQL是SELECT * FROM users WHERE email=?，因此，通过标签函数，我们总是以参数化形式执行SQL，避免了SQL注入。\n执行node app.mjs，可以看到页面效果，同时，后台会打印出执行的SQL语句与绑定的参数。\n参考\n参考源码：sql\nsqlite数据库：sqlite\nsqlite3文档：sqlite3\n直接使用sqlite3提供的接口，我们执行数据库操作时必须提供SQL语句，比较底层。\n考虑到数据库表是一个二维表，包含多行多列，例如一个users的表：\n\n\n\nid\nemail\nname\npassword\n\n\n\n\n1\nadmin@example.com\nBob\n123456\n\n\n2\nlucy@example.com\nLucy\nabcdef\n\n\n3\nalice@example.com\nAlice\nhello123\n\n\n\n每一行可以用一个JavaScript对象表示，例如第一行：\n123456&#123;    id: 1,    email: &#x27;admin@example.com&#x27;,    name: &#x27;Bob&#x27;,    password: &#x27;123456&#x27;&#125;\n这就是传说中的ORM技术：Object-Relational Mapping，把关系数据库的表结构映射到对象上。是不是很简单？\n但是由谁来做这个转换呢？所以ORM框架应运而生。\n我们选择Node的ORM框架Sequelize来操作数据库。这样，我们读写的都是JavaScript对象，Sequelize帮我们把对象变成数据库中的行。\n用Sequelize查询users表，代码像这样：\n1let users = await User.findAll();\n根据email查询一个用户，代码像这样：\n12345let user = await User.find(&#123;    where: &#123;        email: &#x27;admin@example.com&#x27;    &#125;&#125;);\nSequelize的所有操作都是Promise，所以我们可以用await实现异步调用。\n实战\n在使用Sequelize操作数据库之前，我们需要告诉Sequelize如何映射数据库中的每一个表。\n以users表为例，我们需要定义如下：\n1234567891011121314151617181920212223242526272829303132// orm.mjs:import &#123; Sequelize, DataTypes &#125; from &#x27;sequelize&#x27;;// 创建sequelize对象表示已连接到数据库:export const sequelize = new Sequelize(&#x27;sqlite:test.db&#x27;);// 定义User:export const User = sequelize.define(&#x27;User&#x27;, &#123;    // 每一列的定义:    id: &#123;        primaryKey: true,        autoIncrement: true,        type: DataTypes.INTEGER,        allowNull: false    &#125;,    email: &#123;        unique: true,        type: DataTypes.STRING,        allowNull: false    &#125;,    name: &#123;        type: DataTypes.STRING,        allowNull: false    &#125;,    password: &#123;        type: DataTypes.STRING,        allowNull: false    &#125;&#125;, &#123;    // 指定表名:    tableName: &#x27;users&#x27;&#125;);\n在定义列的时候，主键以primaryKey: true指定，具有唯一约束的列用unique: true表示，数据类型用DataTypes表示。\n这样Sequelize就有了足够的信息来实现ORM。最后将sequelize和User对象导出。\n我们根据上一节的sql工程结构创建orm工程，结构如下：\n1234sql/├── app.mjs├── orm.mjs└── ...\n删除了db.mjs，增加orm.mjs。\n然后，通过npm install sequelize sqlite3安装依赖项并添加依赖：\n12&quot;sequelize&quot;: &quot;^6.37.3&quot;,&quot;sqlite3&quot;: &quot;^5.1.7&quot;\n在app.mjs中，删除相关SQL操作，改为通过Sequelize初始化数据库：\n1234567891011121314151617181920212223242526import &#123; sequelize, User &#125; from &#x27;./orm.mjs&#x27;;...async function initDb() &#123;    // 自动创建数据库表, 仅限开发模式:    await sequelize.sync();    // 查询admin用户:    const email = &#x27;admin@example.com&#x27;;    let user = await User.findOne(&#123;        where: &#123;            email: email        &#125;    &#125;);    // 不存在则自动创建:    if (user === null) &#123;        await User.create(&#123;            email: email,            name: &#x27;Bob&#x27;,            password: &#x27;123456&#x27;        &#125;);    &#125;&#125;await initDb();...\n使用Sequelize时，无需绑定app.context，因为我们主要通过具体的Model比如User来操作数据库。修改signin.mjs如下：\n12345678910111213141516171819202122232425import &#123; User &#125; from &#x27;../orm.mjs&#x27;;// signin:async function signin(ctx, next) &#123;    let email = ctx.request.body.email || &#x27;&#x27;;    let password = ctx.request.body.password || &#x27;&#x27;;    // 调用Model.findOne()查询一行记录:    let user = await User.findOne(&#123;        where: &#123;            email: email        &#125;    &#125;);    if (user !== null &amp;&amp; user.password === password) &#123;        console.log(&#x27;signin ok!&#x27;);        ctx.render(&#x27;signin-ok.html&#x27;, &#123;            title: &#x27;Sign In OK&#x27;,            name: user.name        &#125;);    &#125; else &#123;        console.log(&#x27;signin failed!&#x27;);        ctx.render(&#x27;signin-failed.html&#x27;, &#123;            title: &#x27;Sign In Failed&#x27;        &#125;);    &#125;&#125;\n运行node app.mjs启动服务器，可以观察到Sequelize访问数据库时打印的SQL语句。这里需要注意的是，Sequelize会为每个Model自动添加一个createdAt和updatedAt字段，用来记录创建和更新时间。因此，创建的users表的SQL语句为：\n12345678CREATE TABLE IF NOT EXISTS `users` (    `id` INTEGER PRIMARY KEY AUTOINCREMENT,    `email` VARCHAR(255) NOT NULL UNIQUE,    `name` VARCHAR(255) NOT NULL,    `password` VARCHAR(255) NOT NULL,    `createdAt` DATETIME NOT NULL,    `updatedAt` DATETIME NOT NULL);\n常用操作\nSequelize提供了findAll()和findOne()两种查询，分别返回多行和一行。\ncreate()操作可以存储一个对象到数据库的一行记录，save()和destroy()分别对应更新和删除操作。\nSequelize还提供了一对多等高级ORM功能，具体可以参考官方文档。\n参考\n参考源码：orm\nSequelize：官方网站\n","dateCreated":"2025-05-26T22:16:57+08:00","dateModified":"2025-05-26T22:27:19+08:00","datePublished":"2025-05-26T22:16:57+08:00","description":"","headline":"JavaScript-Node.js","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://chankein.github.io/2025/05/26/JavaScript/JavaScript-Node-js/"},"publisher":{"@type":"Organization","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg","logo":{"@type":"ImageObject","url":"profile.jpg"}},"url":"https://chankein.github.io/2025/05/26/JavaScript/JavaScript-Node-js/","keywords":"JavaScript, 前端"}</script>
    <meta name="description" content="从本章开始，我们就正式开启JavaScript的后端开发之旅。 Node.js是目前非常火热的技术，但是它的诞生经历却很奇特。 众所周知，在Netscape设计出JavaScript后的短短几个月，JavaScript事实上已经是前端开发的唯一标准。 后来，微软通过IE击败了Netscape后一统桌面，结果几年时间，浏览器毫无进步。 没有竞争就没有发展。微软认为IE6浏览器已经非常完善，几乎没有可">
<meta property="og:type" content="blog">
<meta property="og:title" content="JavaScript-Node.js">
<meta property="og:url" content="https://chankein.github.io/2025/05/26/JavaScript/JavaScript-Node-js/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:description" content="从本章开始，我们就正式开启JavaScript的后端开发之旅。 Node.js是目前非常火热的技术，但是它的诞生经历却很奇特。 众所周知，在Netscape设计出JavaScript后的短短几个月，JavaScript事实上已经是前端开发的唯一标准。 后来，微软通过IE击败了Netscape后一统桌面，结果几年时间，浏览器毫无进步。 没有竞争就没有发展。微软认为IE6浏览器已经非常完善，几乎没有可">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/install/install-node.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/dev-env/install-vscode.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/dev-env/vscode-edit.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/dev-env/vscode-run.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/dev-env/vscode-debug.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/stream/std.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/http/http-page.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/http/http-index.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/basic/hello-koa.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/url/buduijin.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/url/index-page.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/url/hello-bob.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/url/buduijin2.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/mvc/koa-index.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/mvc/koa-signin-ok.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/mvc/koa-signin-failed.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/rest/rest.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/rest/rest-get-ok.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/rest/rest-get-error.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/web/database/table_grade.jpg">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/web/database/table_class.jpg">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/web/database/table_relationship.jpg">
<meta property="og:image" content="https://liaoxuefeng.com/books/javascript/nodejs/web/database/table_relationship2.jpg">
<meta property="article:published_time" content="2025-05-26T14:16:57.000Z">
<meta property="article:modified_time" content="2025-05-26T14:27:19.670Z">
<meta property="article:author" content="Kein Chan">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liaoxuefeng.com/books/javascript/nodejs/install/install-node.png">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../../../#about"
            >
        
        
            <img class="header-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            JavaScript-Node.js
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2025-05-26T22:16:57+08:00">
	
		    2025 年 5 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/">JavaScript</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>从本章开始，我们就正式开启JavaScript的后端开发之旅。</p>
<p>Node.js是目前非常火热的技术，但是它的诞生经历却很奇特。</p>
<p>众所周知，在Netscape设计出JavaScript后的短短几个月，JavaScript事实上已经是前端开发的唯一标准。</p>
<p>后来，微软通过IE击败了Netscape后一统桌面，结果几年时间，浏览器毫无进步。</p>
<p>没有竞争就没有发展。微软认为IE6浏览器已经非常完善，几乎没有可改进之处，然后解散了IE6开发团队！而Google却认为支持现代Web应用的新一代浏览器才刚刚起步，尤其是浏览器负责运行JavaScript的引擎性能还可提升10倍。</p>
<p>先是Mozilla借助已壮烈牺牲的Netscape遗产在2002年推出了<a target="_blank" rel="noopener" href="https://www.mozilla.org/firefox/">Firefox</a>浏览器，紧接着Apple于2003年在开源的KHTML浏览器的基础上推出了WebKit内核的<a target="_blank" rel="noopener" href="https://www.apple.com/safari/">Safari</a>浏览器，不过仅限于Mac平台。</p>
<p>随后，Google也开始创建自家的浏览器。他们也看中了WebKit内核，于是基于WebKit内核推出了<a target="_blank" rel="noopener" href="https://www.google.com/chrome/">Chrome</a>浏览器。</p>
<p>Chrome浏览器是跨Windows和Mac平台的，并且，Google认为要运行现代Web应用，浏览器必须有一个性能非常强劲的JavaScript引擎，于是Google自己开发了一个高性能JavaScript引擎，名字叫V8，以BSD许可证开源。</p>
<p>现代浏览器大战让微软的IE浏览器远远地落后了，因为他们解散了最有经验、战斗力最强的浏览器团队！回过头再追赶却发现，支持HTML5的WebKit已经成为手机端的标准了，IE浏览器从此与主流移动端设备绝缘。</p>
<p>浏览器大战和Node有何关系？</p>
<p>话说有个叫Ryan Dahl的歪果仁，他的工作是用C/C++写高性能Web服务。对于高性能，异步IO、事件驱动是基本原则，但是用C/C++写就太痛苦了。于是这位仁兄开始设想用高级语言开发Web服务。他评估了很多种高级语言，发现很多语言虽然同时提供了同步IO和异步IO，但是开发人员一旦用了同步IO，他们就再也懒得写异步IO了，所以，最终，Ryan瞄向了JavaScript。</p>
<p>因为JavaScript是单线程执行，根本不能进行同步IO操作，所以，JavaScript的这一“缺陷”导致了它只能使用异步IO。</p>
<p>选定了开发语言，还要有运行时引擎。这位仁兄曾考虑过自己写一个，不过明智地放弃了，因为V8就是开源的JavaScript引擎。让Google投资去优化V8，咱只负责改造一下拿来用，还不用付钱，这个买卖很划算。</p>
<p>于是在2009年，Ryan正式推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为<a target="_blank" rel="noopener" href="https://nodejs.org/">Node.js</a>。虽然名字很土，但是，Node第一次把JavaScript带入到后端服务器开发，加上世界上已经有无数的JavaScript开发人员，所以Node一下子就火了起来。</p>
<p>在Node上运行的JavaScript相比其他后端开发语言有何优势？</p>
<p>最大的优势是借助JavaScript天生的事件驱动机制加V8高性能引擎，使编写高性能Web服务轻而易举。</p>
<p>其次，JavaScript语言本身是完善的函数式语言，在前端开发时，开发人员往往写得比较随意，让人感觉JavaScript就是个“玩具语言”。但是，在Node环境下，通过模块化的JavaScript代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的ECMAScript 6标准，可以完全满足工程上的需求。</p>
<p>由于Node.js平台是在后端运行JavaScript代码，所以，必须首先在本机安装Node环境。</p>
<h3 id="安装Node-js">安装Node.js</h3>
<p>目前Node.js的最新版本是22.3.0，LTS版本是20.14.0，追求稳定性如服务器上长期运行的Node环境可以选择LTS版本，本地开发和测试可以选择最新版本。</p>
<p>要安装Node.js，首先，从<a target="_blank" rel="noopener" href="https://nodejs.org/">Node.js官网</a>下载对应平台的安装程序，初学者建议选择Prebuilt Installer，选择版本，再选操作系统，最后选CPU类型后点Download下载：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/install/install-node.png" alt="download"></p>
<p>有经验的开发者可以选择Package Manager，它允许本地安装多个不同版本的Node并切换至不同版本。</p>
<p>在Windows上安装时务必选择全部组件，包括勾选<code>Add to Path</code>。</p>
<p>安装完成后，在Windows环境下，请打开命令提示符，然后输入<code>node -v</code>，如果安装正常，你应该看到<code>v22.3.0</code>这样的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\IEUser&gt; node -v</span><br><span class="line">v22.3.0</span><br></pre></td></tr></table></figure>
<p>继续在命令提示符输入<code>node</code>，此刻你将进入Node.js的交互环境。在交互环境下，你可以输入任意JavaScript语句，例如<code>100+200</code>，回车后将得到输出结果。</p>
<p>要退出Node.js环境，连按两次Ctrl+C。</p>
<h3 id="npm">npm</h3>
<p>在正式开始Node.js学习之前，我们先认识一下npm。</p>
<p>npm是什么东东？npm其实是Node.js的包管理工具（package manager）。</p>
<p>为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。</p>
<p>更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。</p>
<p>讲了这么多，npm究竟在哪？</p>
<p>其实npm已经在Node.js安装的时候顺带装好了。我们在命令提示符或者终端输入<code>npm -v</code>，应该看到类似的输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;npm -v</span><br><span class="line">10.8.0</span><br></pre></td></tr></table></figure>
<p>如果直接输入<code>npm</code>，你会看到类似下面的输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; npm</span><br><span class="line"></span><br><span class="line">Usage: npm &lt;command&gt;</span><br><span class="line"></span><br><span class="line">where &lt;command&gt; is one of:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>上面的一大堆文字告诉你，<code>npm</code>需要跟上命令。现在我们不用关心这些命令，后面会一一讲到。目前，你只需要确保npm正确安装了，能运行就行。</p>
<h3 id="小结">小结</h3>
<p>请在本机安装Node.js环境，并确保<code>node</code>和<code>npm</code>能正常运行。</p>
<p>在前面的所有章节中，我们编写的JavaScript代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。</p>
<p>从本章开始，我们编写的JavaScript代码将<em>不能</em>在浏览器环境中执行了，而是在Node环境中执行，因此，JavaScript代码将直接在你的计算机上以命令行的方式运行，所以，我们要先选择一个文本编辑器来编写JavaScript代码，并且把它保存到本地硬盘的某个目录，才能够执行。</p>
<p>那么问题来了：文本编辑器到底哪家强？</p>
<p>首先，请注意，<strong>绝对不能用Word和写字板</strong>。Word和写字板保存的不是纯文本文件。如果我们要用记事本来编写JavaScript代码，要务必注意，记事本以UTF-8格式保存文件时，会自作聪明地在文件开始的地方加上几个特殊字符（UTF-8 BOM），结果经常会导致程序运行出现莫名其妙的错误。</p>
<p>所以，用记事本写代码时请注意，保存文件时使用ANSI编码，并且暂时不要输入中文。</p>
<p>如果你的电脑上已经安装了<a target="_blank" rel="noopener" href="https://code.visualstudio.com/">Visual Studio Code</a>，也可以用来编写JavaScript代码，注意用UTF-8格式保存。</p>
<p>输入以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world.&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>第一行总是写上<code>'use strict';</code>是因为我们总是以严格模式运行JavaScript代码，避免各种潜在陷阱。</p>
<p>然后，选择一个目录，例如<code>C:\Workspace</code>，把文件保存为<code>hello.js</code>，就可以打开命令行窗口，把当前目录切换到<code>hello.js</code>所在目录，然后输入以下命令运行这个程序了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Workspace&gt; node hello.js</span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure>
<p>也可以保存为别的名字，比如<code>first.js</code>，但是必须要以<code>.js</code>结尾。此外，文件名只能是英文字母、数字和下划线的组合。</p>
<p>如果当前目录下没有<code>hello.js</code>这个文件，运行<code>node hello.js</code>就会报错：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Workspace&gt; node hello.js</span><br><span class="line">node:internal/modules/cjs/loader:1227</span><br><span class="line">    throw err;</span><br><span class="line">          ^</span><br><span class="line">Error: Cannot find module &#x27;C:\Workspace\hello.js&#x27;</span><br><span class="line">    at Module._resolveFilename</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>报错的意思就是，没有找到<code>hello.js</code>这个文件，因为文件不存在。这个时候，就要检查一下当前目录下是否有这个文件了。</p>
<h3 id="命令行模式和Node交互模式">命令行模式和Node交互模式</h3>
<p>请注意区分命令行模式和Node交互模式。</p>
<p>看到类似<code>PS C:\&gt;</code>是在Windows提供的命令行模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────┐</span><br><span class="line">│Windows PowerShell                                 - □ x │</span><br><span class="line">├─────────────────────────────────────────────────────────┤</span><br><span class="line">│Windows PowerShell                                       │</span><br><span class="line">│Copyright (C) Microsoft Corporation. All rights reserved.│</span><br><span class="line">│                                                         │</span><br><span class="line">│PS C:\Users\liaoxuefeng&gt; node hello.js                   │</span><br><span class="line">│Hello, world.                                            │</span><br><span class="line">│                                                         │</span><br><span class="line">│PS C:\Users\liaoxuefeng&gt;                                 │</span><br><span class="line">│                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>在命令行模式下，可以执行<code>node</code>进入Node交互式环境，也可以执行<code>node hello.js</code>运行一个<code>.js</code>文件。</p>
<p>看到<code>&gt;</code>是在Node交互式环境下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────┐</span><br><span class="line">│Windows PowerShell                                 - □ x │</span><br><span class="line">├─────────────────────────────────────────────────────────┤</span><br><span class="line">│Windows PowerShell                                       │</span><br><span class="line">│Copyright (C) Microsoft Corporation. All rights reserved.│</span><br><span class="line">│                                                         │</span><br><span class="line">│PS C:\Users\liaoxuefeng&gt; node                            │</span><br><span class="line">│Welcome to Node.js v22.x.x.                              │</span><br><span class="line">│&gt;                                                        │</span><br><span class="line">│                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>在Node交互式环境下，我们可以输入JavaScript代码并立刻执行。</p>
<p>此外，在命令行模式运行<code>.js</code>文件和在Node交互式环境下直接运行JavaScript代码有所不同。Node交互式环境会把每一行JavaScript代码的结果自动打印出来，但是，直接运行JavaScript文件却不会。</p>
<p>例如，在Node交互式环境下，输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 100 + 200 + 300;</span><br><span class="line">600</span><br></pre></td></tr></table></figure>
<p>直接可以看到结果<code>600</code>。</p>
<p>但是，写一个<code>calc.js</code>的文件，内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> + <span class="number">200</span> + <span class="number">300</span>;</span><br></pre></td></tr></table></figure>
<p>然后在命令行模式下执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Workspace&gt; node calc.js</span><br></pre></td></tr></table></figure>
<p>发现什么输出都没有。</p>
<p>这是正常的。想要输出结果，必须自己用<code>console.log()</code>打印出来。把<code>calc.js</code>改造一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">100</span> + <span class="number">200</span> + <span class="number">300</span>);</span><br></pre></td></tr></table></figure>
<p>再执行，就可以看到结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Workspace&gt; node calc.js</span><br><span class="line">600</span><br></pre></td></tr></table></figure>
<h3 id="小结-2">小结</h3>
<p>用文本编辑器写JavaScript程序，然后保存为后缀为<code>.js</code>的文件，就可以用node直接运行这个程序了。</p>
<p>Node的交互模式和直接运行<code>.js</code>文件有什么区别呢？</p>
<p>直接输入<code>node</code>进入交互模式，相当于启动了Node解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。</p>
<p>直接运行<code>node hello.js</code>文件相当于启动了Node解释器，然后一次性把<code>hello.js</code>文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。</p>
<p>在编写JavaScript代码的时候，完全可以一边在文本编辑器里写代码，一边开一个Node交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍！前提是得有个27’的超大显示器！</p>
<h3 id="参考源码">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/first-node-app/hello.js">hello.js</a></p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/first-node-app/calc.js">calc.js</a></p>
<p>使用文本编辑器来开发Node程序，最大的缺点是效率太低，运行Node程序还需要在命令行单独敲命令。如果还需要调试程序，就更加麻烦了。</p>
<p>所以我们需要一个IDE集成开发环境，让我们能在一个环境里编码、运行、调试，这样就可以大大提升开发效率。</p>
<p>Java的集成开发环境有Eclipse，Intellij idea等，C#的集成开发环境有Visual Studio，那么问题又来了：Node.js的集成开发环境到底哪家强？</p>
<p>考察Node.js的集成开发环境，重点放在启动速度快，执行简单，调试方便这三点上。当然，免费使用是一个加分项。</p>
<p>综合考察后，我们隆重向大家推荐Node.js集成开发环境：</p>
<h2 id="Visual-Studio-Code">Visual Studio Code</h2>
<p>Visual Studio Code由微软出品，但它不是那个大块头的Visual Studio，它是一个精简版的迷你Visual Studio，并且，Visual Studio Code可以跨！平！台！Windows、Mac和Linux通用。</p>
<h3 id="安装Visual-Studio-Code">安装Visual Studio Code</h3>
<p>可以从Visual Studio Code的<a target="_blank" rel="noopener" href="http://code.visualstudio.com/">官方网站</a>下载并安装最新的版本。</p>
<p>安装过程中，请务必钩上以下选项“将“通过Code打开”操作添加到Windows资源管理器目录上下文菜单”：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/dev-env/install-vscode.png" alt="install-vsc"></p>
<p>这将大大提升将来的操作快捷度。</p>
<h3 id="运行和调试JavaScript">运行和调试JavaScript</h3>
<p>在VS Code中，我们可以非常方便地运行JavaScript文件。</p>
<p>VS Code以文件夹作为工程目录（Workspace Dir），所有的JavaScript文件都存放在该目录下。</p>
<p>假设我们在<code>C:\Work\</code>目录下创建了一个<code>hello</code>目录作为工程目录，并编写了一个<code>hello.js</code>文件，则该工程目录的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello/        &lt;-- workspace dir</span><br><span class="line">└── hello.js  &lt;-- JavaScript file</span><br></pre></td></tr></table></figure>
<p>启动VS Code，选择菜单File - Open Folder…，选择<code>hello</code>目录，就可以直接编辑<code>hello.js</code>文件：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/dev-env/vscode-edit.png" alt="vscode-edit"></p>
<h3 id="运行JS代码">运行JS代码</h3>
<p>确保当前编辑器正在编辑<code>hello.js</code>文件，然后在VS Code中选择左侧调试按钮，直接点击<code>Run And Debug</code>按钮，如果弹出环境选项则选择<code>Node</code>，在右下侧<code>DEBUG CONSOLE</code>可直接看到运行结果。</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/dev-env/vscode-run.png" alt="vscode-run"></p>
<p>如果右下侧面板没有显示，左上角有几个按钮可以切换视图。</p>
<h3 id="调试JS代码">调试JS代码</h3>
<p>在VS Code中，可以通过断点调试方便进行JavaScript的开发和测试。我们先在<code>hello.js</code>的编辑器中打一个断点（鼠标点击行号左侧出现小红点即为断点），然后点击<code>Run And Debug</code>按钮，此时进入调试模式，会自动停在断点处，左侧窗口可查看变量，顶部按钮可选择单步执行或继续执行到下一个断点，也可以随时结束程序：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/dev-env/vscode-debug.png" alt="vscode-debug"></p>
<p>总的来说，使用VS Code，开发和调试JavaScript代码十分方便。</p>
<h3 id="参考源码-2">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/dev-env/hello.js">hello.js</a></p>
<p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。</p>
<p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Node环境中，一个.js文件就称之为一个模块（module）。</p>
<p>使用模块有什么好处？</p>
<p>最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。</p>
<p>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。</p>
<p>在上一节，我们编写了一个<code>hello.js</code>文件，这个<code>hello.js</code>文件就是一个模块，模块的名字就是文件名（去掉<code>.js</code>后缀），所以<code>hello.js</code>文件就是名为<code>hello</code>的模块。</p>
<p>我们把<code>hello.js</code>改造一下，创建一个函数，这样我们就可以在其他地方调用这个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(s + <span class="string">&#x27;, &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = greet;</span><br></pre></td></tr></table></figure>
<p>函数<code>greet()</code>是我们在<code>hello</code>模块中定义的，你可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数<code>greet</code>作为模块的输出暴露出去，这样其他模块就可以使用<code>greet</code>函数了。</p>
<p>问题是其他模块怎么使用<code>hello</code>模块的这个<code>greet</code>函数呢？我们再编写一个<code>main.js</code>文件，调用<code>hello</code>模块的<code>greet</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入hello模块:</span></span><br><span class="line"><span class="keyword">const</span> greet = <span class="built_in">require</span>(<span class="string">&#x27;./hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>(s); <span class="comment">// Hello, Michael!</span></span><br></pre></td></tr></table></figure>
<p>注意到引入<code>hello</code>模块用Node提供的<code>require</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = <span class="built_in">require</span>(<span class="string">&#x27;./hello&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>引入的模块作为变量保存在<code>greet</code>变量中，那<code>greet</code>变量到底是什么东西？其实变量<code>greet</code>就是在<code>hello.js</code>中我们用<code>module.exports = greet;</code>输出的<code>greet</code>函数。所以，<code>main.js</code>就成功地引用了<code>hello.js</code>模块中定义的<code>greet()</code>函数，接下来就可以直接使用它了。</p>
<p>在使用<code>require()</code>引入模块的时候，请注意模块的相对路径。因为<code>main.js</code>和<code>hello.js</code>位于同一个目录，所以我们用了当前目录<code>.</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = <span class="built_in">require</span>(<span class="string">&#x27;./hello&#x27;</span>); <span class="comment">// 不要忘了写相对目录!</span></span><br></pre></td></tr></table></figure>
<p>如果只写模块名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = <span class="built_in">require</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>则Node会依次在内置模块、全局模块和当前模块下查找<code>hello.js</code>，你很可能会得到一个错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">js</span></span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">          ^</span><br><span class="line"><span class="title class_">Error</span>: <span class="title class_">Cannot</span> find <span class="variable language_">module</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    at <span class="title class_">Module</span>.<span class="property">_resolveFilename</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>遇到这个错误，你要检查：</p>
<ul>
<li>模块名是否写对了；</li>
<li>模块文件是否存在；</li>
<li>相对路径是否写对了。</li>
</ul>
<h3 id="CommonJS规范">CommonJS规范</h3>
<p>这种模块加载机制被称为CommonJS规范。在这个规范下，每个<code>.js</code>文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，<code>hello.js</code>和<code>main.js</code>都申明了全局变量<code>var s = 'xxx'</code>，但互不影响。</p>
<p>一个模块想要对外暴露变量（函数也是变量），可以用<code>module.exports = variable;</code>，一个模块要引用其他模块暴露的变量，用<code>var ref = require('module_name');</code>就拿到了引用模块的变量。</p>
<h3 id="结论">结论</h3>
<p>要在模块中对外输出变量，用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = variable;</span><br></pre></td></tr></table></figure>
<p>输出的变量可以是任意对象、函数、数组等等。</p>
<p>要引入其他模块输出的对象，用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;other_module&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>引入的对象具体是什么，取决于引入模块输出的对象。</p>
<h3 id="深入了解模块原理">深入了解模块原理</h3>
<p>如果你想详细地了解CommonJS的模块实现原理，请继续往下阅读。如果不想了解，请直接跳到最后做练习。</p>
<p>当我们编写JavaScript代码时，我们可以申明全局变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;global&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>在浏览器中，大量使用全局变量可不好。如果你在<code>a.js</code>中使用了全局变量<code>s</code>，那么，在<code>b.js</code>中也使用全局变量<code>s</code>，将造成冲突，<code>b.js</code>中对<code>s</code>赋值会改变<code>a.js</code>的运行逻辑。</p>
<p>也就是说，在ESM标准之前，JavaScript语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。</p>
<p>那Node.js是如何实现这一点的？</p>
<p>其实要实现“模块”这个功能，并不需要语法层面的支持。Node.js也并不会增加任何JavaScript语法。实现“模块”功能的奥妙就在于JavaScript是一种函数式编程语言，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。</p>
<p>请注意我们编写的<code>hello.js</code>代码是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s + <span class="string">&#x27; &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>Node.js加载了<code>hello.js</code>后，它可以把代码包装一下，变成这样执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 读取的hello.js代码:</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(s + <span class="string">&#x27; &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    <span class="comment">// hello.js代码结束</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>这样一来，原来的全局变量<code>s</code>现在变成了匿名函数内部的局部变量。如果Node.js继续加载其他模块，这些模块中定义的“全局”变量<code>s</code>也互不干扰。</p>
<p>所以，Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离。</p>
<p>但是，模块的输出<code>module.exports</code>怎么实现？</p>
<p>这个也很容易实现，Node可以先准备一个对象<code>module</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备module对象:</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable language_">module</span> = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    <span class="attr">exports</span>: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> load = <span class="keyword">function</span> (<span class="params"><span class="variable language_">module</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 读取的hello.js代码:</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = greet;</span><br><span class="line">    <span class="comment">// hello.js代码结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">module</span>.<span class="property">exports</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> exported = <span class="title function_">load</span>(<span class="variable language_">module</span>);</span><br><span class="line"><span class="comment">// 保存module:</span></span><br><span class="line"><span class="title function_">save</span>(<span class="variable language_">module</span>, exported);</span><br></pre></td></tr></table></figure>
<p>可见，变量<code>module</code>是Node在加载js文件前准备的一个变量，并将其传入加载函数，我们在<code>hello.js</code>中可以直接使用变量<code>module</code>原因就在于它实际上是函数的一个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = greet;</span><br></pre></td></tr></table></figure>
<p>通过把参数<code>module</code>传递给<code>load()</code>函数，<code>hello.js</code>就顺利地把一个变量传递给了Node执行环境，Node会把<code>module</code>变量保存到某个地方。</p>
<p>由于Node保存了所有导入的<code>module</code>，当我们用<code>require()</code>获取module时，Node找到对应的<code>module</code>，把这个<code>module</code>的<code>exports</code>变量返回，这样，另一个模块就顺利拿到了模块的输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = <span class="built_in">require</span>(<span class="string">&#x27;./hello&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>以上是Node实现JavaScript模块的一个简单的原理介绍。</p>
<h3 id="module-exports-vs-exports">module.exports vs exports</h3>
<p>很多时候，你会看到，在Node环境中，有两种方法可以在一个模块中输出变量：</p>
<p>方法一：对module.exports赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">hello</span>: hello,</span><br><span class="line">    <span class="attr">greet</span>: greet</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：直接使用exports：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">hello</span> = hello;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">greet</span> = greet;</span><br></pre></td></tr></table></figure>
<p>但是你不可以直接对<code>exports</code>赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码可以执行，但是模块并没有输出任何变量:</span></span><br><span class="line"><span class="built_in">exports</span> = &#123;</span><br><span class="line">    <span class="attr">hello</span>: hello,</span><br><span class="line">    <span class="attr">greet</span>: greet</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果你对上面的写法感到十分困惑，不要着急，我们来分析Node的加载机制：</p>
<p>首先，Node会把整个待加载的<code>hello.js</code>文件放入一个包装函数<code>load</code>中执行。在执行这个<code>load()</code>函数前，Node准备好了module变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable language_">module</span> = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    <span class="attr">exports</span>: &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>load()</code>函数最终返回<code>module.exports</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> load = <span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">    <span class="comment">// hello.js的文件内容</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// load函数返回:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">module</span>.<span class="property">exports</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> exported = <span class="title function_">load</span>(<span class="variable language_">module</span>.<span class="property">exports</span>, <span class="variable language_">module</span>);</span><br></pre></td></tr></table></figure>
<p>也就是说，默认情况下，Node准备的<code>exports</code>变量和<code>module.exports</code>变量实际上是同一个变量，并且初始化为空对象<code>&#123;&#125;</code>，于是，我们可以写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">foo</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; &#125;;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">bar</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>也可以写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">foo</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; &#125;;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">bar</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>换句话说，Node默认给你准备了一个空对象<code>&#123;&#125;</code>，这样你可以直接往里面加东西。</p>
<p>但是，如果我们要输出的是一个函数或数组，那么，只能给<code>module.exports</code>赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>给<code>exports</code>赋值是无效的，因为赋值后，<code>module.exports</code>仍然是空对象<code>&#123;&#125;</code>。</p>
<h3 id="结论-2">结论</h3>
<p>如果要输出一个键值对象<code>&#123;&#125;</code>，可以利用<code>exports</code>这个已存在的空对象<code>&#123;&#125;</code>，并继续在上面添加新的键值；</p>
<p>如果要输出一个函数或数组，必须直接对<code>module.exports</code>对象赋值。</p>
<p>所以我们可以得出结论：直接对<code>module.exports</code>赋值，可以应对任何情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>最终，我们<em>强烈建议</em>使用<code>module.exports = xxx</code>的方式来输出模块变量，这样，你只需要记忆一种方法。</p>
<h3 id="练习">练习</h3>
<p>编写<code>hello.js</code>，输出一个或多个函数；</p>
<p>编写<code>main.js</code>，引入<code>hello</code>模块，调用其函数。</p>
<h3 id="参考源码-3">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/module/hello.zip">module</a></p>
<p>虽然Node.js从诞生起就支持模块，但JavaScript语言本身长期以来却一直没有模块功能，只能由CommonJS或其他AMD等模块系统来“模拟”。</p>
<p>随着ES 6标准的推出，JavaScript语言本身终于也迎来了原生内置的模块支持，称为ECMAScript Modules（简称ESM），不仅可以直接在浏览器中使用模块，也可以在Node.js中使用ESM模块。</p>
<p>不使用ESM模块时，我们用<code>module.exports</code>导出可供外部使用的JS对象，例如，以下模块导出了两个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">out</span>(<span class="params">prompt, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;prompt&#125;</span>, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title function_">out</span>(s, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hi</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title function_">out</span>(<span class="string">&#x27;Hi&#x27;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">greet</span>: greet,</span><br><span class="line">    <span class="attr">hi</span>: hi</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要把上述代码改为ESM模块，我们用<code>export</code>标识需要导出的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// out是模块内部函数，模块外部不可见:</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">out</span>(<span class="params">prompt, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;prompt&#125;</span>, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// greet是导出函数，可被外部调用:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title function_">out</span>(s, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hi是导出函数，可被外部调用:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">hi</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title function_">out</span>(<span class="string">&#x27;Hi&#x27;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并将其保存为<code>hello.mjs</code>文件，注意扩展名不是<code>.js</code>，而是<code>.mjs</code>。</p>
<p>可以再编写一个<code>main.mjs</code>文件来调用<code>hello</code>模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; greet, hi &#125; <span class="keyword">from</span> <span class="string">&#x27;./hello.mjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"><span class="title function_">greet</span>(name);</span><br><span class="line"><span class="title function_">hi</span>(name);</span><br></pre></td></tr></table></figure>
<p>可见，ESM模块用<code>export</code>关键字导出一个JS对象，用<code>import</code>关键字导入一个模块的导出对象。</p>
<p>如果要实现类似如下代码的单个函数导出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = greet;</span><br></pre></td></tr></table></figure>
<p>则可以用<code>export default</code>导出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的，导入代码修改为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> greet <span class="keyword">from</span> <span class="string">&#x27;./hello.mjs&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>细心的同学还注意到ESM模块文件第一行并没有<code>'use strict'</code>，这是因为ESM模块默认启用严格模式，因此无需再手动声明<code>'use strict'</code>。</p>
<h3 id="浏览器加载ESM">浏览器加载ESM</h3>
<p>对于浏览器来说，也可以直接使用ESM模块。当我们加载一个ESM模块时，需要用<code>type=&quot;module&quot;</code>来表示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./example.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">greet</span>(<span class="string">&#x27;Bob&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者直接使用<code>import</code>加载一个模块：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">import</span> &#123; greet &#125; <span class="keyword">from</span> <span class="string">&#x27;./example.js&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">greet</span>(<span class="string">&#x27;Bob&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="练习-2">练习</h3>
<p>在Node环境中使用ESM模块：</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/esm/esm.zip">下载练习</a></p>
<h3 id="小结-3">小结</h3>
<p>使用JavaScript内置的原生模块时，用关键字<code>export</code>和<code>import</code>来实现导出与导入；</p>
<p>ESM模块默认启用strict模式，无需声明<code>'use strict'</code>。</p>
<p>因为Node.js是运行在服务区端的JavaScript环境，服务器程序和浏览器程序相比，最大的特点是没有浏览器的安全限制了，而且，服务器程序必须能接收网络请求，读写文件，处理二进制内容，所以，Node.js内置的常用模块就是为了实现基本的服务器功能。这些模块在浏览器环境中是无法被执行的，因为它们的底层代码是用C/C++在Node.js运行环境中实现的。</p>
<h3 id="global">global</h3>
<p>在前面的JavaScript课程中，我们已经知道，JavaScript有且仅有一个全局对象，在浏览器中，叫<code>window</code>对象。而在Node.js环境中，也有唯一的全局对象，但不叫<code>window</code>，而叫<code>global</code>，这个对象的属性和方法也和浏览器环境的<code>window</code>不同。进入Node.js交互环境，可以直接输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; global.console</span><br><span class="line">Object [console] &#123;</span><br><span class="line">  log: [Function: log],</span><br><span class="line">  warn: [Function: warn],</span><br><span class="line">  dir: [Function: dir],</span><br><span class="line">  time: [Function: time],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="process">process</h3>
<p><code>process</code>也是Node.js提供的一个对象，它代表当前Node.js进程。通过<code>process</code>对象可以拿到许多有用信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; process === global.process;</span><br><span class="line">true</span><br><span class="line">&gt; process.version;</span><br><span class="line">&#x27;v22.3.0&#x27;</span><br><span class="line">&gt; process.platform;</span><br><span class="line">&#x27;darwin&#x27;</span><br><span class="line">&gt; process.arch;</span><br><span class="line">&#x27;x64&#x27;</span><br><span class="line">&gt; process.cwd(); //返回当前工作目录</span><br><span class="line">&#x27;/Users/michael&#x27;</span><br><span class="line">&gt; process.chdir(&#x27;/private/tmp&#x27;); // 切换当前工作目录</span><br><span class="line">undefined</span><br><span class="line">&gt; process.cwd();</span><br><span class="line">&#x27;/private/tmp&#x27;</span><br></pre></td></tr></table></figure>
<p>JavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。</p>
<p>如果我们想要在下一次事件响应中执行代码，可以调用<code>process.nextTick()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="comment">// process.nextTick()将在下一轮事件循环中调用:</span></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick callback!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick was set!&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>用Node执行上面的代码<code>node test.js</code>，你会看到，打印输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nextTick was set!</span><br><span class="line">nextTick callback!</span><br></pre></td></tr></table></figure>
<p>这说明传入<code>process.nextTick()</code>的函数不是立刻执行，而是要等到下一次事件循环。</p>
<p>Node.js进程本身的事件就由<code>process</code>对象来处理。如果我们响应<code>exit</code>事件，就可以在程序即将退出时执行某个回调函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序即将退出时的回调函数:</span></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;exit&#x27;</span>, <span class="keyword">function</span> (<span class="params">code</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;about to exit with code: &#x27;</span> + code);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="判断JavaScript执行环境">判断JavaScript执行环境</h3>
<p>有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">typeof</span>(<span class="variable language_">window</span>) === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;node.js&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;browser&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="导入Node模块">导入Node模块</h3>
<p>Node内置了许多模块，可以从Node.js的<a target="_blank" rel="noopener" href="https://nodejs.org/api/">在线文档</a>查询所有模块信息。</p>
<p>以<code>crypto</code>模块的<code>randomInt()</code>函数为例，导入模块有两种方法：</p>
<p>方法一：使用传统的<code>require()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; randomInt &#125; = <span class="built_in">require</span>(<span class="string">&#x27;node:crypto&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> n = <span class="title function_">randomInt</span>(<span class="number">0</span>, <span class="number">100</span>); <span class="comment">// 0~100之间的随机数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br></pre></td></tr></table></figure>
<p>方法二：使用<code>import</code>关键字导入ESM模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; randomInt &#125; <span class="keyword">from</span> <span class="string">&#x27;node:crypto&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> n = <span class="title function_">randomInt</span>(<span class="number">0</span>, <span class="number">100</span>); <span class="comment">// 0~100之间的随机数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br></pre></td></tr></table></figure>
<p>后面，我们将介绍Node.js的常用内置模块。</p>
<p>Node.js内置的<code>fs</code>模块就是文件系统模块，负责读写文件。</p>
<p>和所有其它JavaScript模块不同的是，<code>fs</code>模块同时提供了异步和同步的方法。</p>
<p>回顾一下什么是异步方法。因为JavaScript的单线程模型，执行IO操作时，JavaScript代码无需等待，而是传入回调函数后，继续执行后续JavaScript代码。比如jQuery提供的<code>getJSON()</code>操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">getJSON</span>(<span class="string">&#x27;http://example.com/ajax&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;IO结果返回后执行...&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;不等待IO结果直接执行后续代码...&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>而同步的IO操作则需要等待函数返回：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据网络耗时，函数将执行几十毫秒~几秒不等:</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="title function_">getJSONSync</span>(<span class="string">&#x27;http://example.com/ajax&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>同步操作的好处是代码简单，缺点是程序将等待IO操作，在等待时间内，无法响应其它任何事件。而异步读取不用等待IO操作，但代码较麻烦。</p>
<h3 id="异步读文件">异步读文件</h3>
<p>按照JavaScript的标准，异步读取一个文本文件的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read-text-file-async.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;BEGIN&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">readFile</span>(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;END&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>请注意，<code>sample.txt</code>文件必须在当前目录下，且文件编码为<code>utf-8</code>。</p>
<p>异步读取时，传入的回调函数接收两个参数，当正常读取时，<code>err</code>参数为<code>null</code>，<code>data</code>参数为读取到的String。当读取发生错误时，<code>err</code>参数代表一个错误对象，<code>data</code>为<code>undefined</code>。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。后面我们还会经常编写这种回调函数。</p>
<p>由于<code>err</code>是否为<code>null</code>就是判断是否出错的标志，所以通常的判断逻辑总是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 出错了</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上述代码，可以看到打印的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; BEGIN &gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; END &gt;&gt;&gt;</span><br><span class="line">Sample file content...</span><br></pre></td></tr></table></figure>
<p>因为异步读取，所以，先打印<code>END</code>后，才会执行回调函数，打印文件内容。</p>
<p>如果我们要读取的文件不是文本文件，而是二进制文件，怎么办？</p>
<p>下面的例子演示了如何读取一个图片文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">readFile</span>(<span class="string">&#x27;sample.png&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data <span class="keyword">instanceof</span> <span class="title class_">Buffer</span>); <span class="comment">// true</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// Buffer(12451) [137, 80, 78, 71, 13, ...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当读取二进制文件时，不传入文件编码时，回调函数的<code>data</code>参数将返回一个<code>Buffer</code>对象。在Node.js中，<code>Buffer</code>对象就是一个包含零个或任意个字节的数组（注意和Array不同）。</p>
<p><code>Buffer</code>对象可以和String作转换，例如，把一个<code>Buffer</code>对象转换成String：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buffer -&gt; String</span></span><br><span class="line"><span class="keyword">let</span> text = data.<span class="title function_">toString</span>(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span><br></pre></td></tr></table></figure>
<p>或者把一个String转换成<code>Buffer</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String -&gt; Buffer</span></span><br><span class="line"><span class="keyword">let</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(text, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf);</span><br></pre></td></tr></table></figure>
<h3 id="同步读文件">同步读文件</h3>
<p>除了标准的异步读取模式外，<code>fs</code>也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个<code>Sync</code>后缀，并且不接收回调函数，函数直接返回结果。</p>
<p>用<code>fs</code>模块同步读取一个文本文件的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read-text-file-sync.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFileSync &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;BEGIN&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="title function_">readFileSync</span>(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;END&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>可见，原异步调用的回调函数的<code>data</code>被函数直接返回，函数名需要改为<code>readFileSync</code>，其它参数不变。</p>
<p>如果同步读取文件发生错误，则需要用<code>try...catch</code>捕获该错误。</p>
<h3 id="写文件">写文件</h3>
<p>将数据写入文件是通过<code>fs.writeFile()</code>实现的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write-file-async.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; writeFile &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = <span class="string">&#x27;Hello, Node.js&#x27;</span>;</span><br><span class="line"><span class="title function_">writeFile</span>(<span class="string">&#x27;output.txt&#x27;</span>, data, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>writeFile()</code>的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是<code>Buffer</code>，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个<code>err</code>参数。</p>
<p>和<code>readFile()</code>类似，<code>writeFile()</code>也有一个同步方法，叫<code>writeFileSync()</code>。</p>
<h3 id="stat">stat</h3>
<p>如果我们要获取文件大小，创建时间等信息，可以使用<code>fs.stat()</code>，它返回一个<code>Stat</code>对象，能告诉我们文件或目录的详细信息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read-stat-async.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">stat</span>(<span class="string">&#x27;sample.png&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, st</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 是否是文件:</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;isFile: &#x27;</span> + st.<span class="title function_">isFile</span>());</span><br><span class="line">        <span class="comment">// 是否是目录:</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;isDirectory: &#x27;</span> + st.<span class="title function_">isDirectory</span>());</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="title function_">isFile</span>()) &#123;</span><br><span class="line">            <span class="comment">// 文件大小:</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;size: &#x27;</span> + st.<span class="property">size</span>);</span><br><span class="line">            <span class="comment">// 创建时间, Date对象:</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;birth time: &#x27;</span> + st.<span class="property">birthtime</span>);</span><br><span class="line">            <span class="comment">// 修改时间, Date对象:</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;modified time: &#x27;</span> + st.<span class="property">mtime</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isFile: true</span><br><span class="line">isDirectory: false</span><br><span class="line">size: 12451</span><br><span class="line">birth time: Mon Jun 17 2024 19:37:24 GMT+0800 (China Standard Time)</span><br><span class="line">modified time: Mon Jun 17 2024 19:37:24 GMT+0800 (China Standard Time)</span><br></pre></td></tr></table></figure>
<p><code>stat()</code>也有一个对应的同步函数<code>statSync()</code>，请试着改写上述异步代码为同步代码。</p>
<h3 id="使用Promise">使用Promise</h3>
<p>我们在介绍JavaScript的<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/browser/promise/index.html">Promise</a>时，讲到通过<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/browser/async/index.html">async</a>函数实现异步逻辑，代码更简单。</p>
<p>类似的，Node还提供Promise版本的fs，可以用如下代码在async函数中读取文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async-read.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs/promises&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">readTextFile</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">readFile</span>(path, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">readTextFile</span>(<span class="string">&#x27;sample.txt&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">s</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(s));</span><br></pre></td></tr></table></figure>
<p>在async函数中，用await调用<code>fs/promises</code>与同步方法类似，但代码却是异步执行的。</p>
<h3 id="异步还是同步">异步还是同步</h3>
<p>在<code>fs</code>模块中，提供同步方法是为了方便使用。那我们到底是应该用异步方法还是同步方法呢？</p>
<p>由于Node环境执行的JavaScript代码是服务器端代码，所以，绝大部分需要在服务器运行期反复执行业务逻辑的代码，<em>必须使用异步代码</em>，否则，同步代码在执行时期，服务器将停止响应，因为JavaScript只有一个执行线程。</p>
<p>服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。</p>
<p>如果代码中编写了大量的async函数，那么通过await异步调用<code>fs/promises</code>模块更加方便。</p>
<h3 id="参考源码-4">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/fs/fs.zip">fs</a></p>
<p><code>stream</code>是Node.js提供的又一个仅在服务区端可用的模块，目的是支持“流”这种数据结构。</p>
<p>什么是流？流是一种抽象的数据结构。想象水流，当在水管中流动时，就可以从某个地方（例如自来水厂）源源不断地到达另一个地方（比如你家的洗手池）。我们也可以把数据看成是数据流，比如你敲键盘的时候，就可以把每个字符依次连起来，看成字符流。这个流是从键盘输入到应用程序，实际上它还对应着一个名字：标准输入流（stdin）。</p>
<p>如果应用程序把字符一个一个输出到显示器上，这也可以看成是一个流，这个流也有名字：标准输出流（stdout）。流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位。</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/stream/std.png" alt="stream"></p>
<p>有些流用来读取数据，比如从文件读取数据时，可以打开一个文件流，然后从文件流中不断地读取数据。有些流用来写入数据，比如向文件写入数据时，只需要把数据不断地往文件流中写进去就可以了。</p>
<p>在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：<code>data</code>事件表示流的数据已经可以读取了，<code>end</code>事件表示这个流已经到末尾了，没有数据可以读取了，<code>error</code>事件表示出错了。</p>
<p>下面是一个从文件流读取文本内容的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createReadStream &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开流:</span></span><br><span class="line"><span class="keyword">let</span> rs = <span class="title function_">createReadStream</span>(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取到数据:</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---- chunk ----&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(chunk);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束读取:</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---- end ----&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出错:</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>要注意，<code>data</code>事件可能会有多次，每次传递的<code>chunk</code>是流的一部分数据。</p>
<p>要以流的形式写入文件，只需要不断调用<code>write()</code>方法，最后以<code>end()</code>结束：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createWriteStream &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ws = <span class="title function_">createWriteStream</span>(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;使用Stream写入文本数据...\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;继续写入...\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;DONE.\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">end</span>(); <span class="comment">// 结束写入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入二进制数据:</span></span><br><span class="line"><span class="keyword">let</span> b64array = [ ... ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ws2 = <span class="title function_">createWriteStream</span>(<span class="string">&#x27;output.png&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> b64 <span class="keyword">of</span> b64array) &#123;</span><br><span class="line">    <span class="keyword">let</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(b64, <span class="string">&#x27;base64&#x27;</span>);</span><br><span class="line">    ws2.<span class="title function_">write</span>(buf); <span class="comment">// 写入Buffer对象</span></span><br><span class="line">&#125;</span><br><span class="line">ws2.<span class="title function_">end</span>(); <span class="comment">// 结束写入</span></span><br></pre></td></tr></table></figure>
<p>所有可以读取数据的流都继承自<code>stream.Readable</code>，所有可以写入的流都继承自<code>stream.Writable</code>。</p>
<h3 id="pipe">pipe</h3>
<p>就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个<code>Readable</code>流和一个<code>Writable</code>流串起来后，所有的数据自动从<code>Readable</code>流进入<code>Writable</code>流，这种操作叫<code>pipe</code>。</p>
<p>在Node.js中，<code>Readable</code>流有一个<code>pipe()</code>方法，就是用来干这件事的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.<span class="title function_">pipe</span>(ws);</span><br></pre></td></tr></table></figure>
<p>除了直接使用<code>pipe()</code>方法，Node还提供了<code>pipeline</code>功能，它可以将一个流输出到另一个流。以下是一个复制文件的程序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createReadStream, createWriteStream &#125; <span class="keyword">from</span> <span class="string">&quot;node:fs&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; pipeline &#125; <span class="keyword">from</span> <span class="string">&#x27;node:stream/promises&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">copy</span>(<span class="params">src, dest</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> rs = <span class="title function_">createReadStream</span>(src);</span><br><span class="line">    <span class="keyword">let</span> ws = <span class="title function_">createWriteStream</span>(dest);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">pipeline</span>(rs, ws);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">copy</span>(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;output.txt&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;copied.&#x27;</span>))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err));</span><br></pre></td></tr></table></figure>
<p>使用<code>pipeline</code>的好处是，它可以添加若干个转换器，即输入流经过若干转换后，再进入输出流。如果我们添加的转换器实现了gzip功能，那么实际上就可以把输入流自动压缩后进入输出流。</p>
<h3 id="参考源码-5">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/stream/stream.zip">stream</a></p>
<p>Node.js开发的目的就是为了用JavaScript编写Web服务器程序。因为JavaScript实际上已经统治了浏览器端的脚本，其优势就是有世界上数量最多的前端开发人员。如果已经掌握了JavaScript前端开发，再学习一下如何将JavaScript应用在后端开发，就是名副其实的<em>全栈</em>了。</p>
<h3 id="HTTP协议">HTTP协议</h3>
<p>要理解Web服务器程序的工作原理，首先，我们要对HTTP协议有基本的了解。如果你对HTTP协议不太熟悉，先看一看<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/web/http/index.html">HTTP协议简介</a>。</p>
<h3 id="HTTP服务器">HTTP服务器</h3>
<p>要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的<code>http</code>模块完成了。应用程序并不直接和HTTP协议打交道，而是操作<code>http</code>模块提供的<code>request</code>和<code>response</code>对象。</p>
<p><code>request</code>对象封装了HTTP请求，我们调用<code>request</code>对象的属性和方法就可以拿到所有HTTP请求的信息；</p>
<p><code>response</code>对象封装了HTTP响应，我们操作<code>response</code>对象的方法，就可以把HTTP响应返回给浏览器。</p>
<p>用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序<code>hello.js</code>，它对于所有请求，都返回<code>Hello world!</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入http模块:</span></span><br><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">&#x27;node:http&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建http server，并传入回调函数:</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 回调函数接收request和response对象,</span></span><br><span class="line">    <span class="comment">// 获得HTTP请求的method和url:</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">method</span> + <span class="string">&#x27;: &#x27;</span> + request.<span class="property">url</span>);</span><br><span class="line">    <span class="comment">// 将HTTP响应200写入response, 同时设置Content-Type: text/html:</span></span><br><span class="line">    response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span>&#125;);</span><br><span class="line">    <span class="comment">// 将HTTP响应的HTML内容写入response:</span></span><br><span class="line">    response.<span class="title function_">end</span>(<span class="string">&#x27;&lt;h1&gt;Hello world!&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出错时返回400:</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;clientError&#x27;</span>, <span class="function">(<span class="params">err, socket</span>) =&gt;</span> &#123;</span><br><span class="line">  socket.<span class="title function_">end</span>(<span class="string">&#x27;HTTP/1.1 400 Bad Request\r\n\r\n&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让服务器监听8080端口:</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is running at http://127.0.0.1:8080/&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>在命令提示符下运行该程序，可以看到以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node simple-server.mjs </span><br><span class="line">Server is running at http://127.0.0.1:8080/</span><br></pre></td></tr></table></figure>
<p>不要关闭命令提示符，直接打开浏览器输入<code>http://localhost:8080</code>，即可看到服务器响应的内容：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/http/http-page.png" alt="http-page"></p>
<p>同时，在命令提示符窗口，可以看到程序打印的请求信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET: /</span><br><span class="line">GET: /favicon.ico</span><br></pre></td></tr></table></figure>
<p>这就是我们编写的第一个HTTP服务器程序！</p>
<h3 id="文件服务器">文件服务器</h3>
<p>让我们继续扩展一下上面的Web程序。我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析<code>request.url</code>中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。</p>
<p>观察打印的<code>request.url</code>，它实际上是浏览器请求的路径和参数，如：</p>
<ul>
<li><code>/</code></li>
<li><code>/index.html</code></li>
<li><code>/hello?name=bob</code></li>
</ul>
<p>解析出path部分可以直接用URL对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;http://localost&#x27;</span> + <span class="string">&#x27;/index.html?v=1&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> pathname = url.<span class="property">pathname</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pathname); <span class="comment">// index.html</span></span><br></pre></td></tr></table></figure>
<p>处理本地文件目录需要使用Node.js提供的<code>path</code>模块，它可以方便地构造目录：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;node:path&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析当前目录:</span></span><br><span class="line"><span class="keyword">let</span> workDir = path.<span class="title function_">resolve</span>(<span class="string">&#x27;.&#x27;</span>); <span class="comment">// &#x27;/Users/michael&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合完整的文件路径:当前目录+&#x27;pub&#x27;+&#x27;index.html&#x27;:</span></span><br><span class="line"><span class="keyword">let</span> filePath = path.<span class="title function_">join</span>(workDir, <span class="string">&#x27;pub&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>);</span><br><span class="line"><span class="comment">// &#x27;/Users/michael/pub/index.html&#x27;</span></span><br></pre></td></tr></table></figure>
<p>使用<code>path</code>模块可以正确处理操作系统相关的文件路径。在Windows系统下，返回的路径类似于<code>C:\Users\michael\static\index.html</code>，这样，我们就不关心怎么拼接路径了。</p>
<p>最后，我们实现一个文件服务器<code>simple-file-server.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入http模块:</span></span><br><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">&#x27;node:http&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;node:path&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createReadStream &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; stat &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs/promises&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定www根目录为当前目录:</span></span><br><span class="line"><span class="keyword">const</span> wwwRoot = path.<span class="title function_">resolve</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`set www root: <span class="subst">$&#123;wwwRoot&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据扩展名确定MIME类型:</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">guessMime</span>(<span class="params">pathname</span>) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建http file server，并传入回调函数:</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获得HTTP请求的method和url:</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">method</span> + <span class="string">&#x27;: &#x27;</span> + request.<span class="property">url</span>);</span><br><span class="line">    <span class="keyword">if</span> (request.<span class="property">method</span> !== <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">        response.<span class="title function_">writeHead</span>(<span class="number">400</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span> &#125;);</span><br><span class="line">        response.<span class="title function_">end</span>(<span class="string">&#x27;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 解析path: </span></span><br><span class="line">        <span class="keyword">let</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">`http://localhost<span class="subst">$&#123;request.url&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">let</span> pathname = url.<span class="property">pathname</span>;</span><br><span class="line">        <span class="keyword">let</span> filepath = path.<span class="title function_">join</span>(wwwRoot, pathname);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 必要的安全检查</span></span><br><span class="line">        <span class="comment">// 检查文件状态:</span></span><br><span class="line">        <span class="title function_">stat</span>(filepath).<span class="title function_">then</span>(<span class="function"><span class="params">st</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="title function_">isFile</span>()) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;200 OK&#x27;</span>);</span><br><span class="line">                <span class="comment">// 发送200响应:</span></span><br><span class="line">                response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="title function_">guessMime</span>(pathname) &#125;);</span><br><span class="line">                <span class="comment">// 将文件流导向response:</span></span><br><span class="line">                <span class="title function_">createReadStream</span>(filepath).<span class="title function_">pipe</span>(response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;404 Not Found&#x27;</span>);</span><br><span class="line">                response.<span class="title function_">writeHead</span>(<span class="number">404</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span> &#125;);</span><br><span class="line">                response.<span class="title function_">end</span>(<span class="string">&#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;404 Not Found&#x27;</span>);</span><br><span class="line">            response.<span class="title function_">writeHead</span>(<span class="number">404</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span> &#125;);</span><br><span class="line">            response.<span class="title function_">end</span>(<span class="string">&#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出错时返回400:</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;clientError&#x27;</span>, <span class="function">(<span class="params">err, socket</span>) =&gt;</span> &#123;</span><br><span class="line">    socket.<span class="title function_">end</span>(<span class="string">&#x27;HTTP/1.1 400 Bad Request\r\n\r\n&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让服务器监听8080端口:</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is running at http://127.0.0.1:8080/&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>没有必要手动读取文件内容。由于<code>response</code>对象本身是一个<code>Writable Stream</code>，直接用<code>pipe()</code>方法就实现了自动读取文件内容并输出到HTTP响应。</p>
<p>在命令行运行<code>node simple-file-server.mjs</code>，然后在浏览器中输入<code>http://localhost:8080/index.html</code>：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/http/http-index.png" alt="http-index-page"></p>
<p>只要当前目录下存在文件<code>index.html</code>，服务器就可以把文件内容发送给浏览器。观察控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET: /index.html</span><br><span class="line">200 OK</span><br><span class="line">GET: /next/hello.png</span><br><span class="line">200 OK</span><br><span class="line">GET: /favicon.ico</span><br><span class="line">200 OK</span><br></pre></td></tr></table></figure>
<p>第一个请求是浏览器请求<code>/</code>页面，后续请求是浏览器解析HTML后发送的其它资源请求。</p>
<h3 id="练习-3">练习</h3>
<p>在浏览器输入<code>http://localhost:8080/</code>时，会返回404，原因是程序识别出HTTP请求的不是文件，而是目录。请修改<code>simple-file-server.mjs</code>，如果遇到请求的路径是目录，则自动在目录下依次搜索<code>index.html</code>、<code>default.html</code>，如果找到了，就返回HTML文件的内容。</p>
<h3 id="参考源码-6">参考源码</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/http/simple-server.mjs">简单HTTP服务器</a></li>
<li><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/http/simple-file-server.zip">HTTP文件服务器</a></li>
</ul>
<p>crypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。</p>
<h3 id="MD5和SHA1">MD5和SHA1</h3>
<p>MD5是一种常用的哈希算法，用于给任意数据一个“签名”。这个签名通常用一个十六进制的字符串表示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> crypto <span class="keyword">from</span> <span class="string">&#x27;node:crypto&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hash = crypto.<span class="title function_">createHash</span>(<span class="string">&#x27;md5&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可任意多次调用update():</span></span><br><span class="line">hash.<span class="title function_">update</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">hash.<span class="title function_">update</span>(<span class="string">&#x27;Hello, nodejs!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">digest</span>(<span class="string">&#x27;hex&#x27;</span>)); <span class="comment">// 7e1977739c748beac0c0fd14fd26a544</span></span><br></pre></td></tr></table></figure>
<p><code>update()</code>方法默认字符串编码为<code>UTF-8</code>，也可以传入Buffer。</p>
<p>如果要计算SHA1，只需要把<code>'md5'</code>改成<code>'sha1'</code>，就可以得到SHA1的结果。还可以使用更安全的<code>sha256</code>和<code>sha512</code>。</p>
<h3 id="Hmac">Hmac</h3>
<p>Hmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。不同的是，Hmac还需要一个密钥：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> crypto <span class="keyword">from</span> <span class="string">&#x27;node:crypto&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hmac = crypto.<span class="title function_">createHmac</span>(<span class="string">&#x27;sha256&#x27;</span>, <span class="string">&#x27;secret-key&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hmac.<span class="title function_">update</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">hmac.<span class="title function_">update</span>(<span class="string">&#x27;Hello, nodejs!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hmac.<span class="title function_">digest</span>(<span class="string">&#x27;hex&#x27;</span>)); <span class="comment">// 80f7e22570...</span></span><br></pre></td></tr></table></figure>
<p>只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把Hmac理解为用随机数“增强”的哈希算法。</p>
<h3 id="AES">AES</h3>
<p>AES是一种常用的对称加密算法，加解密都用同一个密钥。crypto模块提供了AES支持，但是需要自己封装好函数，便于使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> crypto <span class="keyword">from</span> <span class="string">&#x27;node:crypto&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">aes_encrypt</span>(<span class="params">key, iv, msg</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cipher = crypto.<span class="title function_">createCipheriv</span>(<span class="string">&#x27;aes-256-cbc&#x27;</span>, key, iv);</span><br><span class="line">    <span class="comment">// input encoding: utf8</span></span><br><span class="line">    <span class="comment">// output encoding: hex</span></span><br><span class="line">    <span class="keyword">let</span> encrypted = cipher.<span class="title function_">update</span>(msg, <span class="string">&#x27;utf8&#x27;</span>, <span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">    encrypted += cipher.<span class="title function_">final</span>(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">aes_decrypt</span>(<span class="params">key, iv, encrypted</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> decipher = crypto.<span class="title function_">createDecipheriv</span>(<span class="string">&#x27;aes-256-cbc&#x27;</span>, key, iv);</span><br><span class="line">    <span class="keyword">let</span> decrypted = decipher.<span class="title function_">update</span>(encrypted, <span class="string">&#x27;hex&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">    decrypted += decipher.<span class="title function_">final</span>(<span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> decrypted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key的长度必须为32bytes:</span></span><br><span class="line"><span class="keyword">let</span> key = <span class="string">&#x27;Passw0rdPassw0rdPassw0rdPassw0rd&#x27;</span>;</span><br><span class="line"><span class="comment">// iv的长度必须为16bytes:</span></span><br><span class="line"><span class="keyword">let</span> iv = <span class="string">&#x27;a1b2c3d4e5f6g7h8&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"><span class="comment">// 加密:</span></span><br><span class="line"><span class="keyword">let</span> encrypted_msg = <span class="title function_">aes_encrypt</span>(key, iv, msg);</span><br><span class="line"><span class="comment">// 解密:</span></span><br><span class="line"><span class="keyword">let</span> decrypted_msg = <span class="title function_">aes_decrypt</span>(key, iv, encrypted_msg);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`AES encrypt: <span class="subst">$&#123;encrypted_msg&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`AES decrypt: <span class="subst">$&#123;decrypted_msg&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AES encrypt: 11cd65e5fe7e7448b491efabee2f326a</span><br><span class="line">AES decrypt: Hello, world!</span><br></pre></td></tr></table></figure>
<p>可以看出，加密后的字符串通过解密又得到了原始内容。</p>
<p>注意到AES有很多不同的算法，如<code>aes192</code>，<code>aes-128-ecb</code>，<code>aes-256-cbc</code>等，AES除了密钥外还可以指定IV（Initial Vector），不同的系统只要IV不同，用相同的密钥加密相同的数据得到的加密结果也是不同的。加密结果通常有两种表示方法：hex和base64，这些功能Node.js全部都支持，但是在应用中要注意，如果加解密双方一方用Nodejs，另一方用Java、PHP等其它语言，需要仔细测试。如果无法正确解密，要确认双方是否遵循同样的AES算法，密钥和IV是否相同，加密后的数据是否统一为hex或base64格式。</p>
<h3 id="Diffie-Hellman">Diffie-Hellman</h3>
<p>DH算法是一种密钥交换协议，它可以让双方在不泄漏密钥的情况下协商出一个密钥来。DH算法基于数学原理，比如小明和小红想要协商一个密钥，可以这么做：</p>
<ol>
<li>小明先选一个素数和一个底数，例如，素数<code>p=97</code>，底数<code>g=5</code>（底数是p的一个原根），再选择一个秘密整数<code>a=123</code>，计算<code>A=g^a mod p=34</code>，然后大声告诉小红：<code>p=97，g=5，A=34</code>；</li>
<li>小红收到小明发来的<code>p</code>，<code>g</code>，<code>A</code>后，也选一个秘密整数<code>b=456</code>，然后计算<code>B=g^b mod p=75</code>，并大声告诉小明：<code>B=75</code>；</li>
<li>小明自己计算出<code>s=B^a mod p=22</code>，小红也自己计算出<code>s=A^b mod p=22</code>，因此，最终协商的密钥<code>s</code>为<code>22</code>。</li>
</ol>
<p>在这个过程中，密钥<code>22</code>并不是小明告诉小红的，也不是小红告诉小明的，而是双方协商计算出来的。第三方只能知道<code>p=97</code>，<code>g=5</code>，<code>A=34</code>，<code>B=75</code>，由于不知道双方选的秘密整数<code>a=123</code>和<code>b=456</code>，因此无法计算出密钥<code>22</code>。</p>
<p>用crypto模块实现DH算法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> crypto <span class="keyword">from</span> <span class="string">&#x27;node:crypto&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xiaoming&#x27;s keys:</span></span><br><span class="line"><span class="keyword">let</span> ming = crypto.<span class="title function_">createDiffieHellman</span>(<span class="number">512</span>);</span><br><span class="line"><span class="keyword">let</span> ming_keys = ming.<span class="title function_">generateKeys</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> prime = ming.<span class="title function_">getPrime</span>();</span><br><span class="line"><span class="keyword">let</span> generator = ming.<span class="title function_">getGenerator</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Prime: &#x27;</span> + prime.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Generator: &#x27;</span> + generator.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// xiaohong&#x27;s keys:</span></span><br><span class="line"><span class="keyword">let</span> hong = crypto.<span class="title function_">createDiffieHellman</span>(prime, generator);</span><br><span class="line"><span class="keyword">let</span> hong_keys = hong.<span class="title function_">generateKeys</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// exchange and generate secret:</span></span><br><span class="line"><span class="keyword">let</span> ming_secret = ming.<span class="title function_">computeSecret</span>(hong_keys);</span><br><span class="line"><span class="keyword">let</span> hong_secret = hong.<span class="title function_">computeSecret</span>(ming_keys);</span><br><span class="line"></span><br><span class="line"><span class="comment">// print secret:</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Secret of Xiao Ming: &#x27;</span> + ming_secret.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Secret of Xiao Hong: &#x27;</span> + hong_secret.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>运行后，可以得到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Prime: a8224c...deead3</span><br><span class="line">Generator: 02</span><br><span class="line">Secret of Xiao Ming: 695308...d519be</span><br><span class="line">Secret of Xiao Hong: 695308...d519be</span><br></pre></td></tr></table></figure>
<p>注意每次输出都不一样，因为素数的选择是随机的。</p>
<h3 id="RSA">RSA</h3>
<p>RSA算法是一种非对称加密算法，即由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密。</p>
<p>RSA算法是1977年由Ron Rivest、Adi Shamir和Leonard Adleman共同提出的，所以以他们三人的姓氏的头字母命名。</p>
<p>当小明给小红发送信息时，可以用小明自己的私钥加密，小红用小明的公钥解密，也可以用小红的公钥加密，小红用她自己的私钥解密，这就是非对称加密。相比对称加密，非对称加密只需要每个人各自持有自己的私钥，同时公开自己的公钥，不需要像AES那样由两个人共享同一个密钥。</p>
<p>在使用Node进行RSA加密前，我们先要准备好私钥和公钥。</p>
<p>首先，在命令行执行以下命令以生成一个RSA密钥对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -aes256 -out rsa-key.pem 2048</span><br></pre></td></tr></table></figure>
<p>根据提示输入密码，这个密码是用来加密RSA密钥的，加密方式指定为AES256，生成的RSA的密钥长度是2048位。执行成功后，我们获得了加密的<code>rsa-key.pem</code>文件。</p>
<p>第二步，通过上面的<code>rsa-key.pem</code>加密文件，我们可以导出原始的私钥，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in rsa-key.pem -outform PEM -out rsa-prv.pem</span><br></pre></td></tr></table></figure>
<p>输入第一步的密码，我们获得了解密后的私钥。</p>
<p>类似的，我们用下面的命令导出原始的公钥：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in rsa-key.pem -outform PEM -pubout -out rsa-pub.pem</span><br></pre></td></tr></table></figure>
<p>这样，我们就准备好了原始私钥文件<code>rsa-prv.pem</code>和原始公钥文件<code>rsa-pub.pem</code>，编码格式均为PEM。</p>
<p>下面，使用<code>crypto</code>模块提供的方法，即可实现非对称加解密。</p>
<p>首先，我们用私钥加密，公钥解密：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> crypto <span class="keyword">from</span> <span class="string">&#x27;node:crypto&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件加载key:</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadKey</span>(<span class="params">file</span>) &#123;</span><br><span class="line">    <span class="comment">// key实际上就是PEM编码的字符串:</span></span><br><span class="line">    <span class="keyword">return</span> fs.<span class="title function_">readFileSync</span>(file, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span></span><br><span class="line">    prvKey = <span class="title function_">loadKey</span>(<span class="string">&#x27;./rsa-prv.pem&#x27;</span>),</span><br><span class="line">    pubKey = <span class="title function_">loadKey</span>(<span class="string">&#x27;./rsa-pub.pem&#x27;</span>),</span><br><span class="line">    message = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用私钥加密:</span></span><br><span class="line"><span class="keyword">let</span> enc_by_prv = crypto.<span class="title function_">privateEncrypt</span>(prvKey, <span class="title class_">Buffer</span>.<span class="title function_">from</span>(message, <span class="string">&#x27;utf8&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(enc_by_prv.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dec_by_pub = crypto.<span class="title function_">publicDecrypt</span>(pubKey, enc_by_prv);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dec_by_pub.<span class="title function_">toString</span>(<span class="string">&#x27;utf8&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>执行后，可以得到解密后的消息，与原始消息相同。</p>
<p>接下来我们使用公钥加密，私钥解密：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用公钥加密:</span></span><br><span class="line"><span class="keyword">let</span> enc_by_pub = crypto.<span class="title function_">publicEncrypt</span>(pubKey, <span class="title class_">Buffer</span>.<span class="title function_">from</span>(message, <span class="string">&#x27;utf8&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(enc_by_pub.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用私钥解密:</span></span><br><span class="line"><span class="keyword">let</span> dec_by_prv = crypto.<span class="title function_">privateDecrypt</span>(prvKey, enc_by_pub);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dec_by_prv.<span class="title function_">toString</span>(<span class="string">&#x27;utf8&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>执行得到的解密后的消息仍与原始消息相同。</p>
<p>如果我们把<code>message</code>字符串的长度增加到很长，例如1M，这时，执行RSA加密会得到一个类似这样的错误：<code>data too large for key size</code>，这是因为RSA加密的原始信息必须小于Key的长度。那如何用RSA加密一个很长的消息呢？实际上，RSA并不适合加密大数据，而是先生成一个随机的AES密码，用AES加密原始信息，然后用RSA加密AES口令，这样，实际使用RSA时，给对方传的密文分两部分，一部分是AES加密的密文，另一部分是RSA加密的AES口令。对方用RSA先解密出AES口令，再用AES解密密文，即可获得明文。</p>
<h3 id="证书">证书</h3>
<p>crypto模块也可以处理数字证书。数字证书通常用在SSL连接，也就是Web的https连接。一般情况下，https连接只需要处理服务器端的单向认证，如无特殊需求（例如自己作为Root给客户发认证证书），建议用反向代理服务器如Nginx等Web服务器去处理证书。</p>
<h3 id="参考源码-7">参考源码</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/crypto/crypto.zip">crypto常用算法</a></li>
</ul>
<p>最早的软件都是运行在大型机上的，软件使用者通过“哑终端”登陆到大型机上去运行软件。后来随着PC机的兴起，软件开始主要运行在桌面上，而数据库这样的软件运行在服务器端，这种Client/Server模式简称CS架构。</p>
<p>随着互联网的兴起，人们发现，CS架构不适合Web，最大的原因是Web应用程序的修改和升级非常迅速，而CS架构需要每个客户端逐个升级桌面App，因此，Browser/Server模式开始流行，简称BS架构。</p>
<p>在BS架构下，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web页面，并把Web页面展示给用户即可。</p>
<p>当然，Web页面也具有极强的交互性。由于Web页面是用HTML编写的，而HTML具备超强的表现力，并且，服务器端升级后，客户端无需任何部署就可以使用到新的版本，因此，BS架构迅速流行起来。</p>
<p>今天，除了重量级的软件如Office，Photoshop等，大部分软件都以Web形式提供。比如，新浪提供的新闻、博客、微博等服务，均是Web应用。</p>
<p>Web应用开发可以说是目前软件开发中最重要的部分。Web开发也经历了好几个阶段：</p>
<p>静态Web页面：由文本编辑器直接编辑并生成静态的HTML页面，如果要修改Web页面的内容，就需要再次编辑HTML源文件，早期的互联网Web页面就是静态的；</p>
<p>CGI：由于静态Web页面无法与用户交互，比如用户填写了一个注册表单，静态Web页面就无法处理。要处理用户发送的动态数据，出现了Common Gateway Interface，简称CGI，用C/C++编写。</p>
<p>ASP/JSP/PHP：由于Web应用特点是修改频繁，用C/C++这样的低级语言非常不适合Web开发，而脚本语言由于开发效率高，与HTML结合紧密，因此，迅速取代了CGI模式。ASP是微软推出的用VBScript脚本编程的Web开发技术，而JSP用Java来编写脚本，PHP本身则是开源的脚本语言。</p>
<p>MVC：为了解决直接用脚本语言嵌入HTML导致的可维护性差的问题，Web应用也引入了Model-View-Controller的模式，来简化Web开发。<a target="_blank" rel="noopener" href="http://xn--ASPASP-yy7ir59aujt.Net">ASP发展为ASP.Net</a>，JSP和PHP也有一大堆MVC框架。</p>
<p>目前，Web开发技术仍在快速发展中，异步开发、新的MVVM前端技术层出不穷。</p>
<p>由于Node.js把JavaScript引入了服务器端，因此，原来必须使用PHP/Java/C#/Python/Ruby等其他语言来开发服务器端程序，现在可以使用Node.js开发了！</p>
<p>用Node.js开发Web服务器端，有几个显著的优势：</p>
<p>一是后端语言也是JavaScript，以前掌握了前端JavaScript的开发人员，现在可以同时编写后端代码；</p>
<p>二是前后端统一使用JavaScript，就没有切换语言的障碍了；</p>
<p>三是速度快，非常快！这得益于Node.js天生是异步的。</p>
<p>在Node.js诞生后的短短几年里，出现了无数种Web框架、ORM框架、模版引擎、测试框架、自动化构建工具，数量之多，即使是JavaScript老司机，也不免眼花缭乱。</p>
<p>常见的Web框架包括：<a target="_blank" rel="noopener" href="https://expressjs.com/">Express</a>，<a target="_blank" rel="noopener" href="https://sailsjs.org/">Sails.js</a>，<a target="_blank" rel="noopener" href="https://koajs.com/">koa</a>，<a target="_blank" rel="noopener" href="https://www.meteor.com/">Meteor</a>，<a target="_blank" rel="noopener" href="https://derbyjs.com/">DerbyJS</a>，<a target="_blank" rel="noopener" href="https://www.totaljs.com/">Total.js</a>，<a target="_blank" rel="noopener" href="http://restify.com/">restify</a>……</p>
<p>ORM框架比Web框架要少一些：<a target="_blank" rel="noopener" href="https://www.sequelizejs.com/">Sequelize</a>，<a target="_blank" rel="noopener" href="https://dresende.github.io/node-orm2/">ORM2</a>，<a target="_blank" rel="noopener" href="https://bookshelfjs.org/">Bookshelf.js</a>，<a target="_blank" rel="noopener" href="https://vincit.github.io/objection.js/">Objection.js</a>……</p>
<p>模版引擎PK：<a target="_blank" rel="noopener" href="https://jade-lang.com/">Jade</a>，<a target="_blank" rel="noopener" href="https://ejs.co/">EJS</a>，<a href="httpss://github.com/paularmstrong/swig">Swig</a>，<a target="_blank" rel="noopener" href="https://mozilla.github.io/nunjucks/">Nunjucks</a>，<a target="_blank" rel="noopener" href="https://olado.github.io/doT/">doT.js</a>……</p>
<p>测试框架包括：<a target="_blank" rel="noopener" href="https://mochajs.org/">Mocha</a>，<a target="_blank" rel="noopener" href="https://visionmedia.github.io/expresso/">Expresso</a>，<a target="_blank" rel="noopener" href="https://unitjs.com/">Unit.js</a>，<a target="_blank" rel="noopener" href="https://karma-runner.github.io/">Karma</a>……</p>
<p>构建工具有：<a target="_blank" rel="noopener" href="https://gruntjs.com/">Grunt</a>，<a target="_blank" rel="noopener" href="https://gulpjs.com/">Gulp</a>，<a target="_blank" rel="noopener" href="https://webpack.github.io/">Webpack</a>……</p>
<p>目前，在npm上已发布的开源Node.js模块数量超过了30万个。</p>
<p>有选择恐惧症的朋友，看到这里可以洗洗睡了。</p>
<p>好消息是这个教程已经帮你选好了，你只需要跟着教程一条道走到黑就可以了。</p>
<h2 id="koa">koa</h2>
<p>koa是Express的下一代基于Node.js的web框架，目前有1.x和2.0两个版本。</p>
<h3 id="历史">历史</h3>
<h4 id="Express">Express</h4>
<p>Express是第一代最流行的web框架，它对Node.js的http进行了封装，用起来如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Example app listening on port 3000!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>虽然Express的API很简单，但是它是基于ES5的语法，要实现异步代码，只有一个方法：回调。如果异步嵌套层次过多，代码写起来就非常难看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/test&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(<span class="string">&#x27;/file1&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">send</span>(<span class="string">&#x27;read file1 error&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&#x27;/file2&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">send</span>(<span class="string">&#x27;read file2 error&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="title function_">type</span>(<span class="string">&#x27;text/plain&#x27;</span>);</span><br><span class="line">            res.<span class="title function_">send</span>(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>虽然可以用async这样的库来组织异步代码，但是用回调写异步实在是太痛苦了！</p>
<h4 id="koa-1-x">koa 1.x</h4>
<p>随着新版Node.js开始支持ES6，Express的团队又基于ES6的generator重新编写了下一代web框架koa。和Express相比，koa 1.x使用generator实现异步，代码看起来像同步的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> app = <span class="title function_">koa</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/test&#x27;</span>, <span class="keyword">function</span> *() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">doReadFile1</span>();</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">yield</span> <span class="title function_">doReadFile2</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">body</span> = data;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>用generator实现异步比回调简单了不少，但是generator的本意并不是异步。Promise才是为异步设计的，但是Promise的写法……想想就复杂。为了简化异步代码，JavaScript引入了新的关键字<code>async</code>和<code>await</code>，可以轻松地把一个function变为异步模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> fs.<span class="title function_">read</span>(<span class="string">&#x27;/file1&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是JavaScript标准的异步代码，非常简洁，并且易于使用。</p>
<h4 id="koa-2-x">koa 2.x</h4>
<p>koa团队并没有止步于koa 1.x，他们又开发了koa 2，和koa 1相比，koa 2完全使用Promise并配合<code>async</code>来实现异步。</p>
<p>koa 2.x的代码看上去像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> <span class="title function_">doReadFile</span>();</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/plain&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = data;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="选择哪个版本？">选择哪个版本？</h3>
<p>为了紧跟时代潮流，教程将使用最新的koa 2.x开发！</p>
<hr>
<hr>
<h3 id="创建koa工程">创建koa工程</h3>
<p>首先，我们创建一个目录<code>hello-koa</code>，作为koa工程根目录。</p>
<p>在根目录下执行<code>npm install koa</code>，我们就在当前目录下安装好了koa及其依赖项，执行完成后目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello-koa/</span><br><span class="line">├── node_modules/      &lt;-- koa以及所有依赖项</span><br><span class="line">├── package-lock.json</span><br><span class="line">└── package.json       &lt;-- npm描述文件</span><br></pre></td></tr></table></figure>
<p><code>package.json</code>包含了npm的依赖信息，以及项目描述等信息，<code>package-lock.json</code>是针对当前所有依赖的一个快照，目的是锁定各个依赖项的版本号。</p>
<p>我们打开<code>package.json</code>，内容如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;koa&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.15.3&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>它只有一个koa依赖，是由命令<code>npm install koa</code>写入的。</p>
<p><code>node_modules</code>是所有依赖项安装的地方，可以随时删除<code>node_modules</code>目录，然后用<code>npm install</code>重新安装。</p>
<p>直接运行<code>npm install</code>则根据<code>package.json</code>的<code>dependencies</code>信息下载安装依赖项，运行<code>npm install xyz</code>则将<code>xyz</code>添加到<code>dependencies</code>然后再安装<code>xyz</code>及其依赖项。因此，熟练的开发者可以先自己编辑<code>dependencies</code>内容，然后删除<code>node_modules</code>后重新安装所有依赖项。此外，<code>package.json</code>和<code>package-lock.json</code>应当添加至版本控制系统中，而<code>node_modules</code>则无需添加。</p>
<p>我们手动添加如下信息至<code>package.json</code>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello-koa&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello koa webapp.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;module&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;koa&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.15.3&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>name</code>、<code>version</code>和<code>description</code>均可任意设置，<code>type</code>为<code>module</code>表示以ESM模块执行。</p>
<p>紧接着，我们用VS Code打开<code>hello-koa</code>目录，创建<code>app.mjs</code>文件，输入以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入koa，注意导入的是大写开头的class:</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Koa</span> <span class="keyword">from</span> <span class="string">&#x27;koa&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个koa实例表示webapp本身:</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于任何请求，app将调用该异步函数处理请求：</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    <span class="comment">// 设置响应类型和文本:</span></span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Hello Koa!&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在端口3000监听:</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;app started at port 3000...&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>对于每一个http请求，koa将调用我们传入的异步函数来处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    <span class="comment">// 设置response的Content-Type:</span></span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    <span class="comment">// 设置response的内容:</span></span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Hello Koa!&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，参数<code>ctx</code>是由koa传入的封装了request和response的变量，我们可以通过它访问request和response，<code>next</code>是koa传入的将要处理的下一个异步函数。</p>
<p>上面的异步函数中，我们首先用<code>await next();</code>处理下一个异步函数，然后，设置response的<code>Content-Type</code>和内容。</p>
<p>现在，我们的工程结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello-koa/</span><br><span class="line">├── node_modules/</span><br><span class="line">├── app.mjs</span><br><span class="line">├── package-lock.json</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>
<p>在命令行执行<code>node app.mjs</code>就启动了Web服务器。我们打开浏览器，输入<code>http://localhost:3000</code>，即可看到效果：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/basic/hello-koa.png" alt="koa-browser"></p>
<h3 id="koa-middleware">koa middleware</h3>
<p>让我们再仔细看看koa的执行逻辑。核心代码是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Hello Koa!&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>每收到一个http请求，koa就会调用通过<code>app.use()</code>注册的async函数，并传入<code>ctx</code>和<code>next</code>参数。</p>
<p>我们可以对<code>ctx</code>操作，并设置返回内容。但是为什么要调用<code>await next()</code>？</p>
<p>原因是koa把很多async函数组成一个处理链，每个async函数都可以做一些自己的事情，然后用<code>await next()</code>来调用下一个async函数。我们把每个async函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。</p>
<p>例如，可以用以下3个middleware组成处理链，依次打印日志，记录处理时间，输出HTML：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;ctx.request.method&#125;</span> <span class="subst">$&#123;ctx.request.url&#125;</span>`</span>); <span class="comment">// 打印URL</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>(); <span class="comment">// 调用下一个middleware</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>(); <span class="comment">// 当前时间</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>(); <span class="comment">// 调用下一个middleware</span></span><br><span class="line">    <span class="keyword">const</span> ms = <span class="title class_">Date</span>.<span class="title function_">now</span>() - start; <span class="comment">// 耗费时间</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Time: <span class="subst">$&#123;ms&#125;</span>ms`</span>); <span class="comment">// 打印耗费时间</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Hello Koa!&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>middleware的顺序很重要，也就是调用<code>app.use()</code>的顺序决定了middleware的顺序。</p>
<p>此外，如果一个middleware没有调用<code>await next()</code>，会怎么办？答案是后续的middleware将不再执行了。这种情况也很常见，例如，一个检测用户权限的middleware可以决定是否继续处理请求，还是直接返回403错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">await</span> <span class="title function_">checkUserPermission</span>(ctx)) &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">status</span> = <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>理解了middleware，我们就已经会用koa了！</p>
<p>最后注意<code>ctx</code>对象有一些简写的方法，例如<code>ctx.url</code>相当于<code>ctx.request.url</code>，<code>ctx.type</code>相当于<code>ctx.response.type</code>。</p>
<h3 id="参考源码-8">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/basic/hello-koa.zip">hello-koa</a></p>
<p>在hello-koa工程中，我们处理http请求一律返回相同的HTML，这样虽然非常简单，但是用浏览器一测，随便输入任何URL都会返回相同的网页。</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/url/buduijin.png" alt="buduijin"></p>
<p>正常情况下，我们应该对不同的URL调用不同的处理函数，这样才能返回不同的结果。例如像这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.<span class="property">request</span>.<span class="property">path</span> === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;index page&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.<span class="property">request</span>.<span class="property">path</span> === <span class="string">&#x27;/test&#x27;</span>) &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;TEST page&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.<span class="property">request</span>.<span class="property">path</span> === <span class="string">&#x27;/error&#x27;</span>) &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;ERROR page&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这么写是可以运行的，但是好像有点蠢。</p>
<p>应该有一个能集中处理URL的middleware，它根据不同的URL调用不同的处理函数，这样，我们才能专心为每个URL编写处理函数。</p>
<h3 id="koa-router">@koa/router</h3>
<p>为了处理URL，我们需要引入<code>@koa/router</code>这个middleware，让它负责处理URL映射。</p>
<p>我们把上一节的<code>hello-koa</code>工程复制一份，重命名为<code>url-koa</code>。</p>
<p>先用命令<code>npm install @koa/router</code>安装并在<code>package.json</code>中添加依赖项，接下来，我们修改<code>app.mjs</code>，使用<code>@koa/router</code>来处理URL：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Koa</span> <span class="keyword">from</span> <span class="string">&#x27;koa&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Router</span> <span class="keyword">from</span> <span class="string">&#x27;@koa/router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// log url:</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Process <span class="subst">$&#123;ctx.request.method&#125;</span> <span class="subst">$&#123;ctx.request.url&#125;</span>...`</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析request.body:</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">bodyParser</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置路由: 处理 /</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Index Page&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置路由: 处理 /hello/:name</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/hello/:name&#x27;</span>, <span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取:name参数:</span></span><br><span class="line">    <span class="keyword">let</span> s = ctx.<span class="property">params</span>.<span class="property">name</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">`&lt;h1&gt;Hello, <span class="subst">$&#123;s&#125;</span>&lt;/h1&gt;`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用router:</span></span><br><span class="line">app.<span class="title function_">use</span>(router.<span class="title function_">routes</span>());</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;app started at port 3000...&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>我们使用<code>router.get('/path', async fn)</code>来注册一个GET请求。可以在请求路径中使用带变量的<code>/hello/:name</code>，变量可以通过<code>ctx.params.name</code>访问。</p>
<p>再运行<code>app.mjs</code>，我们就可以测试不同的URL：</p>
<p>输入首页：<a target="_blank" rel="noopener" href="http://localhost:3000/">http://localhost:3000/</a></p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/url/index-page.png" alt="url-index"></p>
<p>输入：<a target="_blank" rel="noopener" href="http://localhost:3000/hello/Bob">http://localhost:3000/hello/Bob</a></p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/url/hello-bob.png" alt="url-hello"></p>
<h3 id="处理post请求">处理post请求</h3>
<p>用<code>router.get('/path', async fn)</code>处理的是get请求。如果要处理post请求，可以用<code>router.post('/path', async fn)</code>。</p>
<p>用post请求处理URL时，我们会遇到一个问题：post请求通常会发送一个表单，或者JSON，它作为request的body发送，但无论是Node.js提供的原始request对象，还是koa提供的request对象，都<em>不提供</em>解析request的body的功能！</p>
<p>所以，我们又需要引入另一个middleware来解析原始request请求，然后，把解析后的参数，绑定到<code>ctx.request.body</code>中。<code>@koa/bodyparser</code>就是用来干这个活的。</p>
<p>我们用命令<code>npm install @koa/bodyparser</code>安装并在<code>package.json</code>中添加依赖项，然后，修改<code>app.mjs</code>，引入<code>@koa/bodyparser</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; bodyParser &#125; <span class="keyword">from</span> <span class="string">&#x27;@koa/bodyparser&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>在合适的位置加上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">bodyParser</span>());</span><br></pre></td></tr></table></figure>
<p>由于middleware的顺序很重要，这个<code>@koa/bodyparser</code>必须在<code>router</code>之前被注册到<code>app</code>对象上。</p>
<p>现在我们就可以处理post请求了。写一个简单的登录表单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;h1&gt;Index Page&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;Name: &lt;input name=&quot;name&quot; value=&quot;koa&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;Password: &lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/signin&#x27;</span>, <span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> name = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">name</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> password = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`try signin: <span class="subst">$&#123;name&#125;</span>, password: <span class="subst">$&#123;password&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">&#x27;koa&#x27;</span> &amp;&amp; password === <span class="string">&#x27;12345&#x27;</span>) &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">`&lt;h1&gt;Welcome, <span class="subst">$&#123;name&#125;</span>!&lt;/h1&gt;`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Signin failed!&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;/&quot;&gt;Retry&lt;/a&gt;&lt;/p&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意到我们用<code>let name = ctx.request.body.name || ''</code>拿到表单的<code>name</code>字段，如果该字段不存在，默认值设置为<code>''</code>。</p>
<p>类似的，put、delete、head请求也可以由router处理。</p>
<h3 id="重构">重构</h3>
<p>现在，我们已经可以处理不同的URL了，但是看看<code>app.mjs</code>，总觉得还是有点不对劲。</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/url/buduijin2.png" alt="still-buduijin"></p>
<p>所有的URL处理函数都放到<code>app.mjs</code>里显得很乱，而且，每加一个URL，就需要修改<code>app.mjs</code>。随着URL越来越多，<code>app.mjs</code>就会越来越长。</p>
<p>如果能把URL处理函数集中到某个js文件，或者某几个js文件中就好了，然后让<code>app.mjs</code>自动导入所有处理URL的函数。这样，代码一分离，逻辑就显得清楚了。最好是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">url2-koa/</span><br><span class="line">├── controller/</span><br><span class="line">│   ├── hello.mjs   &lt;-- 处理/hello/:name</span><br><span class="line">│   └── signin.mjs  &lt;-- 处理/signin</span><br><span class="line">├── app.mjs</span><br><span class="line">├── package-lock.json</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>
<p>于是我们把<code>url-koa</code>复制一份，重命名为<code>url2-koa</code>，准备重构这个项目。</p>
<p>我们先在<code>controller</code>目录下编写<code>signin.mjs</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">index</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;h1&gt;Index Page&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;Name: &lt;input name=&quot;name&quot; value=&quot;koa&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;Password: &lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST /signin</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">signin</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> name = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">name</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> password = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`try signin: <span class="subst">$&#123;name&#125;</span>, password: <span class="subst">$&#123;password&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">&#x27;koa&#x27;</span> &amp;&amp; password === <span class="string">&#x27;12345&#x27;</span>) &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">`&lt;h1&gt;Welcome, <span class="subst">$&#123;name&#125;</span>!&lt;/h1&gt;`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Signin failed!&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;/&quot;&gt;Retry&lt;/a&gt;&lt;/p&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出处理函数:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="string">&#x27;GET /&#x27;</span>: index,</span><br><span class="line">    <span class="string">&#x27;POST /signin&#x27;</span>: signin</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个<code>signin.mjs</code>通过<code>export default</code>把两个URL处理函数暴露出来。</p>
<p>类似的，<code>hello.mjs</code>把一个URL处理函数暴露出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取:name参数:</span></span><br><span class="line">    <span class="keyword">let</span> s = ctx.<span class="property">params</span>.<span class="property">name</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">`&lt;h1&gt;Hello, <span class="subst">$&#123;s&#125;</span>&lt;/h1&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="string">&#x27;GET /hello/:name&#x27;</span>: hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们修改<code>app.mjs</code>，让它自动扫描<code>controller</code>目录，找到所有<code>js</code>文件，导入，然后注册每个URL：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描controller目录:</span></span><br><span class="line"><span class="keyword">const</span> dirname = path.<span class="title function_">dirname</span>(<span class="title function_">fileURLToPath</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`scan dir <span class="subst">$&#123;dirname&#125;</span>...`</span>);</span><br><span class="line"><span class="comment">// 列举 *.mjs 文件:</span></span><br><span class="line"><span class="keyword">let</span> files = <span class="title function_">readdirSync</span>(path.<span class="title function_">join</span>(dirname, <span class="string">&#x27;controller&#x27;</span>)).<span class="title function_">filter</span>(<span class="function"><span class="params">f</span> =&gt;</span> f.<span class="title function_">endsWith</span>(<span class="string">&#x27;.mjs&#x27;</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">    <span class="comment">// 导入模块:</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`import controller/<span class="subst">$&#123;file&#125;</span>...`</span>);</span><br><span class="line">    <span class="keyword">let</span> &#123; <span class="attr">default</span>: mapping &#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">`./controller/<span class="subst">$&#123;file&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// 把每个URL映射添加到router:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> url <span class="keyword">in</span> mapping) &#123;</span><br><span class="line">        <span class="keyword">if</span> (url.<span class="title function_">startsWith</span>(<span class="string">&#x27;GET &#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 类似 &#x27;GET /hello/:name&#x27;</span></span><br><span class="line">            <span class="keyword">let</span> p = url.<span class="title function_">substring</span>(<span class="number">4</span>);</span><br><span class="line">            router.<span class="title function_">get</span>(p, mapping[url]);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`mapping: GET <span class="subst">$&#123;p&#125;</span>`</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.<span class="title function_">startsWith</span>(<span class="string">&#x27;POST &#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 类似 &#x27;POST /signin&#x27;</span></span><br><span class="line">            <span class="keyword">let</span> p = url.<span class="title function_">substring</span>(<span class="number">5</span>);</span><br><span class="line">            router.<span class="title function_">post</span>(p, mapping[url]);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`mapping: POST <span class="subst">$&#123;p&#125;</span>`</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`invalid mapping: <span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Controller-Middleware">Controller Middleware</h3>
<p>最后，我们把扫描<code>controller</code>目录和创建<code>router</code>的代码从<code>app.mjs</code>中提取出来，作为一个简单的middleware使用，命名为<code>controller.mjs</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controller.mjs:</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">scan</span>(<span class="params">router, controllerDir</span>) &#123;</span><br><span class="line">    <span class="comment">// 扫描controller目录:</span></span><br><span class="line">    <span class="keyword">const</span> dirname = path.<span class="title function_">dirname</span>(<span class="title function_">fileURLToPath</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`scan dir <span class="subst">$&#123;dirname&#125;</span>...`</span>);</span><br><span class="line">    <span class="keyword">let</span> files = <span class="title function_">readdirSync</span>(path.<span class="title function_">join</span>(dirname, controllerDir)).<span class="title function_">filter</span>(<span class="function"><span class="params">f</span> =&gt;</span> f.<span class="title function_">endsWith</span>(<span class="string">&#x27;.mjs&#x27;</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">        <span class="comment">// 导入模块:</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`import controller/<span class="subst">$&#123;file&#125;</span>...`</span>);</span><br><span class="line">        <span class="keyword">let</span> &#123; <span class="attr">default</span>: mapping &#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">`./<span class="subst">$&#123;controllerDir&#125;</span>/<span class="subst">$&#123;file&#125;</span>`</span>);</span><br><span class="line">        <span class="comment">// 把每个URL映射添加到router:</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> url <span class="keyword">in</span> mapping) &#123;</span><br><span class="line">            <span class="keyword">if</span> (url.<span class="title function_">startsWith</span>(<span class="string">&#x27;GET &#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">let</span> p = url.<span class="title function_">substring</span>(<span class="number">4</span>);</span><br><span class="line">                router.<span class="title function_">get</span>(p, mapping[url]);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`mapping: GET <span class="subst">$&#123;p&#125;</span>`</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.<span class="title function_">startsWith</span>(<span class="string">&#x27;POST &#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">let</span> p = url.<span class="title function_">substring</span>(<span class="number">5</span>);</span><br><span class="line">                router.<span class="title function_">post</span>(p, mapping[url]);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`mapping: POST <span class="subst">$&#123;p&#125;</span>`</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`invalid mapping: <span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认扫描目录为 controller:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">controllerDir = <span class="string">&#x27;controller&#x27;</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">scan</span>(router, controllerDir);</span><br><span class="line">    <span class="keyword">return</span> router.<span class="title function_">routes</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，我们在<code>app.mjs</code>的代码又简化了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> controller <span class="keyword">from</span> <span class="string">&#x27;./controller.mjs&#x27;</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 使用controller(), 注意controller模块导出的是async函数，要通过await调用:</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">await</span> <span class="title function_">controller</span>());</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>经过重新整理后的工程<code>url2-koa</code>目前具备非常好的模块化，所有处理URL的函数按功能组存放在<code>controller</code>目录，今后我们也只需要不断往这个目录下加东西就可以了，<code>app.mjs</code>保持不变。</p>
<p>最后我们整理一下koa处理一个HTTP请求的流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">           │</span><br><span class="line">           │</span><br><span class="line">           ▼</span><br><span class="line">┌─────────────────────┐</span><br><span class="line">│log:                 │</span><br><span class="line">│async(ctx,next) &#123;...&#125;│</span><br><span class="line">└─────────────────────┘</span><br><span class="line">           │</span><br><span class="line">           ▼</span><br><span class="line">┌─────────────────────┐</span><br><span class="line">│bodyParser()         │</span><br><span class="line">└─────────────────────┘     GET /             ┌─────────────────────┐</span><br><span class="line">           │              ┌──────────────────▶│async(ctx,next) &#123;...&#125;│</span><br><span class="line">           ▼              │                   └─────────────────────┘</span><br><span class="line">┌─────────────────────┐   │ POST /signin      ┌─────────────────────┐</span><br><span class="line">│router.routes()      ├───┼──────────────────▶│async(ctx,next) &#123;...&#125;│</span><br><span class="line">└─────────────────────┘   │                   └─────────────────────┘</span><br><span class="line">                          │ GET /hello/:name  ┌─────────────────────┐</span><br><span class="line">                          └──────────────────▶│async(ctx,next) &#123;...&#125;│</span><br><span class="line">                                              └─────────────────────┘</span><br></pre></td></tr></table></figure>
<p>一个HTTP请求是按顺序由一系列注册到koa的middleware处理的，首先由log函数处理，并通过<code>await next()</code>把请求传递到下一个middleware，紧接着是<code>bodyParser</code>处理，最后是<code>router</code>处理。在router的内部，又会根据注册到router的HTTP方法+Path来决定由哪个async函数处理请求。如果URL没有匹配到，则简单返回404。以上就是整个基于koa的webapp处理流程，非常清晰易懂。</p>
<h3 id="参考源码-9">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/url/url.zip">url</a></p>
<p>Nunjucks是什么东东？其实它是一个模板引擎。</p>
<p>那什么是模板引擎？</p>
<p>模板引擎就是基于模板配合数据构造出字符串输出的一个组件。比如下面的函数就是一个模板引擎：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">examResult</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;data.name&#125;</span>同学一年级期末考试语文<span class="subst">$&#123;data.chinese&#125;</span>分，数学<span class="subst">$&#123;data.math&#125;</span>分，位于年级第<span class="subst">$&#123;data.ranking&#125;</span>名。`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们输入数据如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">examResult</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">chinese</span>: <span class="number">78</span>,</span><br><span class="line">    <span class="attr">math</span>: <span class="number">87</span>,</span><br><span class="line">    <span class="attr">ranking</span>: <span class="number">999</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>该模板引擎把模板字符串里面对应的变量替换以后，就可以得到以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小明同学一年级期末考试语文78分，数学87分，位于年级第999名。</span><br></pre></td></tr></table></figure>
<p>模板引擎最常见的输出就是输出网页，也就是HTML文本。当然，也可以输出任意格式的文本，比如Text，XML，Markdown等等。</p>
<p>有同学要问了：既然JavaScript的模板字符串可以实现模板功能，那为什么我们还需要另外的模板引擎？</p>
<p>因为JavaScript的模板字符串必须写在JavaScript代码中，要想写出新浪首页这样复杂的页面，是非常困难的。</p>
<p>输出HTML有几个特别重要的问题需要考虑：</p>
<h4 id="转义">转义</h4>
<p>对特殊字符要转义，避免受到XSS攻击。比如，如果变量<code>name</code>的值不是<code>小明</code>，而是<code>小明&lt;script&gt;...&lt;/script&gt;</code>，模板引擎输出的HTML到了浏览器，就会自动执行恶意JavaScript代码。</p>
<h4 id="格式化">格式化</h4>
<p>对不同类型的变量要格式化，比如，货币需要变成<code>$12,345.00</code>这样的格式，日期需要变成<code>2016-01-01</code>这样的格式。</p>
<h4 id="简单逻辑">简单逻辑</h4>
<p>模板还需要能执行一些简单逻辑，比如，要按条件输出内容，需要if实现如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; name &#125;&#125;同学，</span><br><span class="line">&#123;% if score &gt;= 90 %&#125;</span><br><span class="line">    成绩优秀，应该奖励</span><br><span class="line">&#123;% elif score &gt;=60 %&#125;</span><br><span class="line">    成绩良好，继续努力</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    不及格，建议回家打屁股</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>所以，我们需要一个功能强大的模板引擎，来完成页面输出的功能。</p>
<h3 id="Nunjucks">Nunjucks</h3>
<p>我们选择Nunjucks作为模板引擎。Nunjucks是Mozilla开发的一个纯JavaScript编写的模板引擎，既可以用在Node环境下，又可以运行在浏览器端。但是，主要还是运行在Node环境下，因为浏览器端有更好的模板解决方案，例如MVVM框架。</p>
<p>如果你使用过Python的模板引擎<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/web/jinja">jinja2</a>，那么使用Nunjucks就非常简单，两者的语法几乎是一模一样的，因为Nunjucks就是用JavaScript重新实现了jinjia2。</p>
<p>从上面的例子我们可以看到，虽然模板引擎内部可能非常复杂，但是使用一个模板引擎是非常简单的，因为本质上我们只需要构造这样一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">view, model</span>) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>view</code>是模板的名称（又称为视图），因为可能存在多个模板，需要选择其中一个。<code>model</code>就是数据，在JavaScript中，它就是一个简单的Object。<code>render</code>函数返回一个字符串，就是模板的输出。</p>
<p>下面我们来使用Nunjucks这个模板引擎来编写几个HTML模板，并且用实际数据来渲染模板并获得最终的HTML输出。</p>
<p>我们创建一个<code>use-nunjucks</code>的VS Code工程结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use-nunjucks/</span><br><span class="line">├── app.mjs</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">└── view</span><br><span class="line">    ├── base.html    &lt;-- HTML模板文件</span><br><span class="line">    ├── extend.html  &lt;-- HTML模板文件</span><br><span class="line">    └── hello.html   &lt;-- HTML模板文件</span><br></pre></td></tr></table></figure>
<p>其中，模板文件存放在<code>view</code>目录中。</p>
<p>我们先用<code>npm install nunjucks</code>安装依赖项并在<code>package.json</code>中添加<code>nunjucks</code>的依赖：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;nunjucks&quot;</span>: <span class="string">&quot;^3.2.4&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，模板引擎是可以独立使用的，并不需要依赖koa。</p>
<p>紧接着，我们要编写使用Nunjucks的函数<code>render</code>。怎么写？方法是查看Nunjucks的<a target="_blank" rel="noopener" href="https://mozilla.github.io/nunjucks/">官方文档</a>，仔细阅读后，在<code>app.js</code>中编写代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nunjucks <span class="keyword">from</span> <span class="string">&#x27;nunjucks&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createEnv</span>(<span class="params">path, &#123; autoescape = <span class="literal">true</span>, noCache = <span class="literal">false</span>, watch = <span class="literal">false</span>, throwOnUndefined = <span class="literal">false</span> &#125;, filters = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> loader = <span class="keyword">new</span> nunjucks.<span class="title class_">FileSystemLoader</span>(path, &#123;</span><br><span class="line">        <span class="attr">noCache</span>: noCache,</span><br><span class="line">        <span class="attr">watch</span>: watch</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> env = <span class="keyword">new</span> nunjucks.<span class="title class_">Environment</span>(loader, &#123;</span><br><span class="line">        <span class="attr">autoescape</span>: autoescape,</span><br><span class="line">        <span class="attr">throwOnUndefined</span>: throwOnUndefined</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> filters) &#123;</span><br><span class="line">        env.<span class="title function_">addFilter</span>(name, filters[name]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> env;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> env = <span class="title function_">createEnv</span>(<span class="string">&#x27;view&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">noCache</span>: <span class="literal">true</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">hex</span>: <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + n.<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>变量<code>env</code>就表示Nunjucks模板引擎对象，它有一个<code>render(view, model)</code>方法，正好传入<code>view</code>和<code>model</code>两个参数，并返回字符串。</p>
<p>创建<code>env</code>需要的参数可以查看文档获知。我们用关键字参数作为默认值，最后使用<code>new nunjucks.FileSystemLoader('view')</code>创建一个文件系统加载器，从<code>view</code>目录读取模板。</p>
<p>我们编写一个<code>hello.html</code>模板文件，放到<code>view</code>目录下，内容如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后，我们就可以用下面的代码来渲染这个模板：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = env.<span class="title function_">render</span>(<span class="string">&#x27;hello.html&#x27;</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br></pre></td></tr></table></figure>
<p>获得输出如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello 小明<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>咋一看，这和使用JavaScript模板字符串没啥区别嘛。不过，试试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = env.<span class="title function_">render</span>(<span class="string">&#x27;hello.html&#x27;</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;&lt;script&gt;alert(&quot;小明&quot;)&lt;/script&gt;&#x27;</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br></pre></td></tr></table></figure>
<p>获得输出如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello <span class="symbol">&amp;lt;</span>script<span class="symbol">&amp;gt;</span>alert(&quot;小明&quot;)<span class="symbol">&amp;lt;</span>/script<span class="symbol">&amp;gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就避免了输出恶意脚本。</p>
<p>此外，可以使用Nunjucks提供的功能强大的tag，编写条件判断、循环等功能，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 循环输出名字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Fruits List<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    &#123;% for f in fruits %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; f &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Nunjucks模板引擎最强大的功能在于模板的继承。仔细观察各种网站可以发现，网站的结构实际上是类似的，头部、尾部都是固定格式，只有中间页面部分内容不同。如果每个模板都重复头尾，一旦要修改头部或尾部，那就需要改动所有模板。</p>
<p>更好的方式是使用继承。先定义一个基本的网页框架<code>base.html</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&#123;% block header %&#125; <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Unnamed<span class="tag">&lt;/<span class="name">h3</span>&gt;</span> &#123;% endblock %&#125;</span><br><span class="line">&#123;% block body %&#125; <span class="tag">&lt;<span class="name">div</span>&gt;</span>No body<span class="tag">&lt;/<span class="name">div</span>&gt;</span> &#123;% endblock %&#125;</span><br><span class="line">&#123;% block footer %&#125; <span class="tag">&lt;<span class="name">div</span>&gt;</span>copyright<span class="tag">&lt;/<span class="name">div</span>&gt;</span> &#123;% endblock %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>base.html</code>定义了三个可编辑的块，分别命名为<code>header</code>、<code>body</code>和<code>footer</code>。子模板可以有选择地对块进行重新定义：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &#x27;base.html&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block header %&#125;<span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; header &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block body %&#125;<span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; body &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们对子模板进行渲染：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(env.<span class="title function_">render</span>(<span class="string">&#x27;extend.html&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">header</span>: <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="string">&#x27;bla bla bla...&#x27;</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>输出HTML如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>bla bla bla...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>copyright<span class="tag">&lt;/<span class="name">div</span>&gt;</span> &lt;-- footer没有重定义，所以仍使用父模板的内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="性能">性能</h3>
<p>最后我们要考虑一下Nunjucks的性能。</p>
<p>对于模板渲染本身来说，速度是非常非常快的，因为就是拼字符串嘛，纯CPU操作。</p>
<p>性能问题主要出现在从文件读取模板内容这一步。这是一个IO操作，在Node.js环境中，我们知道，单线程的JavaScript最不能忍受的就是同步IO，但Nunjucks默认就使用同步IO读取模板文件。</p>
<p>好消息是Nunjucks会缓存已读取的文件内容，也就是说，模板文件最多读取一次，就会放在内存中，后面的请求是不会再次读取文件的，只要我们指定了<code>noCache: false</code>这个参数。</p>
<p>在开发环境下，可以关闭cache，这样每次重新加载模板，便于实时修改模板。在生产环境下，一定要打开cache，这样就不会有性能问题。</p>
<p>Nunjucks也提供了异步读取的方式，但是这样写起来很麻烦，有简单的写法我们就不会考虑复杂的写法。保持代码简单是可维护性的关键。</p>
<h3 id="参考源码-10">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/template/use-nunjucks.zip">use-nunjucks</a></p>
<p>我们已经可以用koa处理不同的URL，还可以用Nunjucks渲染模板。现在，是时候把这两者结合起来了！</p>
<p>当用户通过浏览器请求一个URL时，koa将调用某个异步函数处理该URL。在这个异步函数内部，我们用一行代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">render</span>(<span class="string">&#x27;home.html&#x27;</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;Michael&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>通过Nunjucks把数据用指定的模板渲染成HTML，然后输出给浏览器，用户就可以看到渲染后的页面了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">             ┌─────────────────────────────┐</span><br><span class="line">HTTP Request │GET /Bob                     │</span><br><span class="line">             └─────────────────────────────┘</span><br><span class="line">                            │</span><br><span class="line">                            │ name = Bob</span><br><span class="line">                            ▼</span><br><span class="line">             ┌─────────────────────────────┐</span><br><span class="line">     app.mjs │GET /:name                   │</span><br><span class="line">             │async (ctx, next) &#123;          │</span><br><span class="line">             │    ctx.render(&#x27;home.html&#x27;, &#123;│</span><br><span class="line">             │        name: ctx.params.name│</span><br><span class="line">             │    &#125;);                      │</span><br><span class="line">             │&#125;                            │</span><br><span class="line">             └─────────────────────────────┘</span><br><span class="line">                            │</span><br><span class="line">                            │ &#123;&#123; name &#125;&#125; ─▶ Bob</span><br><span class="line">                            ▼</span><br><span class="line">             ┌─────────────────────────────┐</span><br><span class="line">    Template │&lt;html&gt;                       │</span><br><span class="line">             │&lt;body&gt;                       │</span><br><span class="line">             │    &lt;p&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;/p&gt;│</span><br><span class="line">             │&lt;/body&gt;                      │</span><br><span class="line">             │&lt;/html&gt;                      │</span><br><span class="line">             └─────────────────────────────┘</span><br><span class="line">                            │</span><br><span class="line">                            │ Output</span><br><span class="line">                            ▼</span><br><span class="line">             ┌─────────────────────────────┐</span><br><span class="line">        HTML │&lt;html&gt;                       │</span><br><span class="line">             │&lt;body&gt;                       │</span><br><span class="line">             │    &lt;p&gt;Hello, Bob!&lt;/p&gt;       │</span><br><span class="line">             │&lt;/body&gt;                      │</span><br><span class="line">             │&lt;/html&gt;                      │</span><br><span class="line">             └─────────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>这就是传说中的MVC：Model-View-Controller，中文名“模型-视图-控制器”。</p>
<p>异步函数是C：Controller，Controller负责业务逻辑，比如检查用户名是否存在，取出用户信息等等；</p>
<p>包含变量<code>&#123;&#123; name &#125;&#125;</code>的模板就是V：View，View负责显示逻辑，通过简单地替换一些变量，View最终输出的就是用户看到的HTML。</p>
<p>MVC中的Model在哪？Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。</p>
<p>上面的例子中，Model就是一个JavaScript对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>下面，我们根据原来的<code>url2-koa</code>创建工程<code>view-koa</code>，把koa2、Nunjucks整合起来，然后，把原来直接输出字符串的方式，改为<code>ctx.render(view, model)</code>的方式。</p>
<p>工程<code>koa-mvc</code>结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">koa-mvc/</span><br><span class="line">├── app.mjs</span><br><span class="line">├── controller</span><br><span class="line">│   ├── index.mjs</span><br><span class="line">│   └── signin.mjs</span><br><span class="line">├── controller.mjs</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── static/  &lt;-- 静态资源文件</span><br><span class="line">│   ├── bootstrap.css</span><br><span class="line">│   └── favicon.ico</span><br><span class="line">├── view/  &lt;-- html模板文件</span><br><span class="line">│   ├── base.html</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── signin-failed.html</span><br><span class="line">│   └── signin-ok.html</span><br><span class="line">└── view.mjs</span><br></pre></td></tr></table></figure>
<p>在<code>package.json</code>中，我们将要用到的依赖包有：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;@koa/bodyparser&quot;: &quot;^5.1.1&quot;,</span><br><span class="line">&quot;@koa/router&quot;: &quot;^12.0.1&quot;,</span><br><span class="line">&quot;koa&quot;: &quot;^2.15.3&quot;,</span><br><span class="line">&quot;koa-mount&quot;: &quot;^4.0.0&quot;,</span><br><span class="line">&quot;koa-static&quot;: &quot;^5.0.0&quot;,</span><br><span class="line">&quot;nunjucks&quot;: &quot;^3.2.4&quot;</span><br></pre></td></tr></table></figure>
<p>先用<code>npm install</code>安装依赖包，然后，我们准备编写以下两个Controller：</p>
<h4 id="处理首页-GET">处理首页 GET /</h4>
<p>我们定义一个async函数处理首页URL<code>/</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">index</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    ctx.<span class="title function_">render</span>(<span class="string">&#x27;index.html&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;Welcome&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到koa并没有在<code>ctx</code>对象上提供<code>render</code>方法，这里我们假设应该这么使用，这样，我们在编写Controller的时候，最后一步调用<code>ctx.render(view, model)</code>就完成了页面输出。</p>
<h4 id="处理登录请求-POST-signin">处理登录请求 POST /signin</h4>
<p>我们再定义一个async函数处理登录请求<code>/signin</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">signin</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> email = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">email</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> password = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (email === <span class="string">&#x27;admin@example.com&#x27;</span> &amp;&amp; password === <span class="string">&#x27;123456&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin ok!&#x27;</span>);</span><br><span class="line">        ctx.<span class="title function_">render</span>(<span class="string">&#x27;signin-ok.html&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;Sign In OK&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;Mr Bob&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin failed!&#x27;</span>);</span><br><span class="line">        ctx.<span class="title function_">render</span>(<span class="string">&#x27;signin-failed.html&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;Sign In Failed&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于登录请求是一个POST，我们就用<code>ctx.request.body.&lt;name&gt;</code>拿到POST请求的数据，并给一个默认值。</p>
<p>登录成功时我们用<code>signin-ok.html</code>渲染，登录失败时我们用<code>signin-failed.html</code>渲染，所以，我们一共需要以下3个View：</p>
<ul>
<li>index.html</li>
<li>signin-ok.html</li>
<li>signin-failed.html</li>
</ul>
<h3 id="编写View">编写View</h3>
<p>在编写View的时候，我们实际上是在编写HTML页。为了让页面看起来美观大方，使用一个现成的CSS框架是非常有必要的。我们用<a target="_blank" rel="noopener" href="https://getbootstrap.com/">Bootstrap</a>这个CSS框架。从首页下载zip包后解压，我们把所有静态资源文件放到<code>/static</code>目录下，这样我们在编写HTML的时候，可以直接用Bootstrap的CSS，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;/static/bootstrap.css&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>现在，在使用MVC之前，第一个问题来了，如何处理静态文件？</p>
<p>我们把所有静态资源文件全部放入<code>/static</code>目录，目的就是能统一处理静态文件。在koa中，我们需要编写一个middleware，处理以<code>/static/</code>开头的URL。</p>
<p>如果不想自己编写处理静态文件的middleware，可以直接使用<code>koa-mount</code>和<code>koa-static</code>组合来处理静态文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理静态文件:</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">mount</span>(<span class="string">&#x27;/static&#x27;</span>, <span class="title function_">serve</span>(<span class="string">&#x27;static&#x27;</span>)));</span><br></pre></td></tr></table></figure>
<p>上述代码大致相当于自己手写一个middleware：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 判断是否以指定的url开头:</span></span><br><span class="line">    <span class="keyword">if</span> (ctx.<span class="property">request</span>.<span class="property">path</span>.<span class="title function_">startsWith</span>(<span class="string">&#x27;/static/&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 获取文件完整路径:</span></span><br><span class="line">        <span class="keyword">let</span> fp = ctx.<span class="property">request</span>.<span class="property">path</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">await</span> fs.<span class="title function_">exists</span>(ctx.<span class="property">request</span>.<span class="property">path</span>)) &#123;</span><br><span class="line">            <span class="comment">// 根据扩展名设置mime:</span></span><br><span class="line">            ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="title function_">lookupMime</span>(ctx.<span class="property">request</span>.<span class="property">path</span>);</span><br><span class="line">            <span class="comment">// 读取文件内容并赋值给response.body:</span></span><br><span class="line">            ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="keyword">await</span> fs.<span class="title function_">readFile</span>(fp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 文件不存在:</span></span><br><span class="line">            ctx.<span class="property">response</span>.<span class="property">status</span> = <span class="number">404</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不是指定前缀的URL，继续处理下一个middleware:</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="集成Nunjucks">集成Nunjucks</h3>
<p>集成Nunjucks实际上也是编写一个middleware，这个middleware的作用是给<code>ctx</code>对象绑定一个<code>render(view, model)</code>的方法，这样，后面的Controller就可以调用这个方法来渲染模板了。</p>
<p>我们创建一个<code>view.mjs</code>来实现这个middleware：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nunjucks <span class="keyword">from</span> <span class="string">&#x27;nunjucks&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createEnv</span>(<span class="params">path, &#123; autoescape = <span class="literal">true</span>, noCache = <span class="literal">false</span>, watch = <span class="literal">false</span>, throwOnUndefined = <span class="literal">false</span> &#125;, filters = &#123;&#125;</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> env;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> env = <span class="title function_">createEnv</span>(<span class="string">&#x27;view&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">noCache</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出env对象:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> env;</span><br></pre></td></tr></table></figure>
<p>使用的时候，我们在<code>app.mjs</code>添加如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> templateEngine <span class="keyword">from</span> <span class="string">&#x27;./view.mjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.context是每个请求创建的ctx的原型,</span></span><br><span class="line"><span class="comment">// 因此把render()方法绑定在原型对象上:</span></span><br><span class="line">app.<span class="property">context</span>.<span class="property">render</span> = <span class="keyword">function</span> (<span class="params">view, model</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">response</span>.<span class="property">body</span> = templateEngine.<span class="title function_">render</span>(view, <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, <span class="variable language_">this</span>.<span class="property">state</span> || &#123;&#125;, model || &#123;&#125;));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意到<code>createEnv()</code>函数和前面使用Nunjucks时编写的函数是一模一样的。</p>
<p>这里我们判断当前环境是否是production环境。如果是，就使用缓存，如果不是，就关闭缓存。在开发环境下，关闭缓存后，我们修改View，可以直接刷新浏览器看到效果，否则，每次修改都必须重启Node程序，会极大地降低开发效率。</p>
<p>Node.js在全局变量<code>process</code>中定义了一个环境变量<code>env.NODE_ENV</code>，为什么要使用该环境变量？因为我们在开发的时候，环境变量应该设置为<code>'development'</code>，而部署到服务器时，环境变量应该设置为<code>'production'</code>。在编写代码的时候，要根据当前环境作不同的判断。</p>
<p><em>注意</em>：生产环境上必须配置环境变量<code>NODE_ENV = 'production'</code>，而开发环境不需要配置，实际上<code>NODE_ENV</code>可能是<code>undefined</code>，所以判断的时候，不要用<code>NODE_ENV === 'development'</code>。</p>
<p>类似的，我们在使用上面编写的处理静态文件的middleware时，也可以根据环境变量判断：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isProduction) &#123;</span><br><span class="line">    app.<span class="title function_">use</span>(<span class="title function_">mount</span>(<span class="string">&#x27;/static&#x27;</span>, <span class="title function_">serve</span>(<span class="string">&#x27;static&#x27;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为在生产环境下，静态文件是由部署在最前面的反向代理服务器（如Nginx）处理的，Node程序不需要处理静态文件。而在开发环境下，我们希望koa能顺带处理静态文件，否则，就必须手动配置一个反向代理服务器，这样会导致开发环境非常复杂。</p>
<h3 id="编写View-2">编写View</h3>
<p>在编写View的时候，非常有必要先编写一个<code>base.html</code>作为骨架，其他模板都继承自<code>base.html</code>，这样，才能大大减少重复工作。</p>
<p>编写HTML不在本教程的讨论范围之内。这里我们参考Bootstrap的官网简单编写了<code>base.html</code>。</p>
<h3 id="运行">运行</h3>
<p>一切顺利的话，这个<code>koa-mvc</code>工程应该可以顺利运行。运行前，我们再检查一下<code>app.mjs</code>里的middleware的顺序：</p>
<p>第一个middleware是记录URL以及页面执行时间：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Process <span class="subst">$&#123;ctx.request.method&#125;</span> <span class="subst">$&#123;ctx.request.url&#125;</span>...`</span>);</span><br><span class="line">    <span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    <span class="keyword">const</span> execTime = <span class="title class_">Date</span>.<span class="title function_">now</span>() - start;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="title function_">set</span>(<span class="string">&#x27;X-Response-Time&#x27;</span>, <span class="string">`<span class="subst">$&#123;execTime&#125;</span>ms`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第二个middleware处理静态文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isProduction) &#123;</span><br><span class="line">    app.<span class="title function_">use</span>(<span class="title function_">mount</span>(<span class="string">&#x27;/static&#x27;</span>, <span class="title function_">serve</span>(<span class="string">&#x27;static&#x27;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三个middleware解析POST请求：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">bodyParser</span>());</span><br></pre></td></tr></table></figure>
<p>最后一个middleware处理URL路由：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">await</span> <span class="title function_">controller</span>());</span><br></pre></td></tr></table></figure>
<p>现在，用<code>node app.mjs</code>运行代码，不出意外的话，在浏览器输入<code>localhost:3000/</code>，可以看到首页内容：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/mvc/koa-index.png" alt="koa-index"></p>
<p>直接在首页登录，如果输入正确的Email和Password，进入登录成功的页面：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/mvc/koa-signin-ok.png" alt="koa-signin-ok"></p>
<p>如果输入的Email和Password不正确，进入登录失败的页面：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/mvc/koa-signin-failed.png" alt="koa-signin-failed"></p>
<p>怎么判断正确的Email和Password？目前我们在<code>signin.js</code>中是这么判断的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (email === <span class="string">&#x27;admin@example.com&#x27;</span> &amp;&amp; password === <span class="string">&#x27;123456&#x27;</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，真实的网站会根据用户输入的Email和Password去数据库查询并判断登录是否成功，不过这需要涉及到Node.js环境如何操作数据库，我们后面再讨论。</p>
<p>如果要以<code>production</code>模式启动app，需要设置环境变量，可以通过以下命令启动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ NODE_ENV=production node app.mjs</span><br></pre></td></tr></table></figure>
<p>这样模板缓存将生效，同时不再响应静态文件请求。</p>
<h3 id="扩展">扩展</h3>
<p>注意到<code>ctx.render</code>内部渲染模板时，Model对象并不是传入的model变量，而是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, ctx.<span class="property">state</span> || &#123;&#125;, model || &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>这个小技巧是为了扩展。</p>
<p>首先，<code>model || &#123;&#125;</code>确保了即使传入<code>undefined</code>，model也会变为默认值<code>&#123;&#125;</code>。<code>Object.assign()</code>会把除第一个参数外的其他参数的所有属性复制到第一个参数中。第二个参数是<code>ctx.state || &#123;&#125;</code>，这个目的是为了能把一些公共的变量放入<code>ctx.state</code>并传给View。</p>
<p>例如，某个middleware负责检查用户权限，它可以把当前用户放入<code>ctx.state</code>中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> user = <span class="title function_">tryGetUserFromCookie</span>(ctx.<span class="property">request</span>);</span><br><span class="line">    <span class="keyword">if</span> (user) &#123;</span><br><span class="line">        ctx.<span class="property">state</span>.<span class="property">user</span> = user;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">status</span> = <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样就没有必要在每个Controller的async函数中都把user变量放入model中。</p>
<h3 id="参考源码-11">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/mvc/koa-mvc.zip">koa-mvc</a></p>
<p>自从Roy Fielding博士在2000年他的博士论文中提出<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/REST">REST</a>（Representational State Transfer）风格的软件架构模式后，REST就基本上迅速取代了复杂而笨重的SOAP，成为Web API的标准了。</p>
<p>什么是Web API呢？</p>
<p>如果我们想要获取某个电商网站的某个商品，输入<code>http://localhost:3000/products/123</code>，就可以看到id为123的商品页面，但这个结果是HTML页面，它同时混合包含了Product的数据和Product的展示两个部分。对于用户来说，阅读起来没有问题，但是，如果机器读取，就很难从HTML中解析出Product的数据。</p>
<p>如果一个URL返回的不是HTML，而是机器能直接解析的数据，这个URL就可以看成是一个Web API。比如，读取<code>http://localhost:3000/api/products/123</code>，如果能直接返回Product的数据，那么机器就可以直接读取。</p>
<p>REST就是一种设计API的模式。最常用的数据格式是JSON。由于JSON能直接被JavaScript读取，所以，以JSON格式编写的REST风格的API具有简单、易读、易用的特点。</p>
<p>编写API有什么好处呢？由于API就是把Web App的功能全部封装了，所以，通过API操作数据，可以极大地把前端和后端的代码隔离，使得后端代码易于测试，前端代码编写更简单。</p>
<p>此外，如果我们把前端页面看作是一种用于展示的客户端，那么API就是为客户端提供数据、操作数据的接口。这种设计可以获得极高的扩展性。例如，当用户需要在手机上购买商品时，只需要开发针对iOS和Android的两个客户端，通过客户端访问API，就可以完成通过浏览器页面提供的功能，而后端代码基本无需改动。</p>
<p>当一个Web应用以API的形式对外提供功能时，整个应用的结构就扩展为：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/rest/rest.png" alt="REST-arch"></p>
<p>把网页视为一种客户端，是REST架构可扩展的一个关键。</p>
<h3 id="REST-API规范">REST API规范</h3>
<p>编写REST API，实际上就是编写处理HTTP请求的async函数，不过，REST请求和普通的HTTP请求有几个特殊的地方：</p>
<ol>
<li>REST请求仍然是标准的HTTP请求，但是，除了GET请求外，POST、PUT等请求的body是JSON数据格式，请求的<code>Content-Type</code>为<code>application/json</code>；</li>
<li>REST响应返回的结果是JSON数据格式，因此，响应的<code>Content-Type</code>也是<code>application/json</code>。</li>
</ol>
<p>REST规范定义了资源的通用访问格式，虽然它不是一个强制要求，但遵守该规范可以让人易于理解。</p>
<p>例如，商品Product就是一种资源。获取所有Product的URL如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/products</span><br></pre></td></tr></table></figure>
<p>而获取某个指定的Product，例如，id为<code>123</code>的Product，其URL如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/products/123</span><br></pre></td></tr></table></figure>
<p>新建一个Product使用POST请求，JSON数据包含在body中，URL如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /api/products</span><br></pre></td></tr></table></figure>
<p>更新一个Product使用PUT请求，例如，更新id为<code>123</code>的Product，其URL如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT /api/products/123</span><br></pre></td></tr></table></figure>
<p>删除一个Product使用DELETE请求，例如，删除id为<code>123</code>的Product，其URL如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /api/products/123</span><br></pre></td></tr></table></figure>
<p>资源还可以按层次组织。例如，获取某个Product的所有评论，使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/products/123/reviews</span><br></pre></td></tr></table></figure>
<p>当我们只需要获取部分数据时，可通过参数限制返回的结果集，例如，返回第2页评论，每页10项，按时间排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/products/123/reviews?page=2&amp;size=10&amp;sort=time</span><br></pre></td></tr></table></figure>
<h3 id="koa处理REST">koa处理REST</h3>
<p>既然我们已经使用koa作为Web框架处理HTTP请求，因此，我们仍然可以在koa中响应并处理REST请求。</p>
<p>我们复制上一节的工程，重命名为<code>koa-rest</code>，然后准备添加REST API。</p>
<p>对于controller来说，我们只要返回如下内容即可视为一个REST API：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="property">body</span> =  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">12345</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    <span class="attr">description</span>: <span class="string">&#x27;A rest api&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>koa检测到<code>ctx.body</code>的赋值是一个JavaScript对象时，自动把这个Object变成JSON字符串输出，无需任何额外配置和代码。</p>
<p>提示</p>
<p>ctx.body是ctx.response.body的引用，两者是等同的。</p>
<p>我们给<code>signin.mjs</code>添加两个REST API：</p>
<ul>
<li><code>GET /api/users/:id</code>：根据id获取用户信息；</li>
<li><code>POST /api/signin</code>：发送一个POST请求，并返回登录结果。</li>
</ul>
<p>获取用户信息的async函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /api/users/:id</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">user_info</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> id = ctx.<span class="property">params</span>.<span class="property">id</span>;</span><br><span class="line">    <span class="keyword">if</span> (id === <span class="string">&#x27;12345&#x27;</span>) &#123;</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">12345</span>,</span><br><span class="line">            <span class="attr">email</span>: <span class="string">&#x27;admin@example.com&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">error</span>: <span class="string">&#x27;USER_NOT_FOUND&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理登录请求的async函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">signin</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> email = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">email</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> password = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (email === <span class="string">&#x27;admin@example.com&#x27;</span> &amp;&amp; password === <span class="string">&#x27;123456&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin ok!&#x27;</span>);</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">12345</span>,</span><br><span class="line">            <span class="attr">email</span>: email,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin failed!&#x27;</span>);</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">error</span>: <span class="string">&#x27;SIGNIN_FAILED&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当发生错误时，返回的信息包含<code>error</code>字段，客户端依靠该字段来判断是否出错。</p>
<p>最后导出URL处理函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="string">&#x27;POST /api/signin&#x27;</span>: signin,</span><br><span class="line">    <span class="string">&#x27;GET /api/users/:id&#x27;</span>: user_info</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在，我们可以直接在浏览器测试GET请求：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/rest/rest-get-ok.png" alt="GET OK"></p>
<p>输入无效的ID，返回错误：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/rest/rest-get-error.png" alt="GET ERROR"></p>
<p>对于POST请求，我们无法直接在浏览器测试，可以用<code>curl</code>命令测试如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl -H &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">-d &#x27;&#123;&quot;email&quot;:&quot;admin@example.com&quot;,&quot;password&quot;:&quot;123456&quot;&#125;&#x27; \</span><br><span class="line">http://localhost:3000/api/signin</span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 12345,</span><br><span class="line">  &quot;email&quot;: &quot;admin@example.com&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;Bob&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入错误的口令，返回错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl -H &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">-d &#x27;&#123;&quot;email&quot;:&quot;admin@example.com&quot;,&quot;password&quot;:&quot;invalid&quot;&#125;&#x27; \</span><br><span class="line">http://localhost:3000/api/signin</span><br><span class="line">&#123;</span><br><span class="line">  &quot;error&quot;: &quot;SIGNIN_FAILED&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们把登录从传统的POST表单改成了REST，因此，前端页面需要编写JavaScript代码来发送REST请求，修改HTML如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 给form加上onsubmit回调函数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;signin-form&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return signin()&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>用JavaScript发送REST请求如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">signin</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取表单输入:</span></span><br><span class="line">    <span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#signin-form&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> email = form.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[name=email]&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">let</span> password = form.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[name=password]&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="comment">// REST请求的数据:</span></span><br><span class="line">    <span class="keyword">let</span> data = &#123;</span><br><span class="line">        <span class="attr">email</span>: email,</span><br><span class="line">        <span class="attr">password</span>: password</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 发送请求:</span></span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;/api/signin&#x27;</span>, &#123;</span><br><span class="line">        <span class="comment">// 以POST方式发送:</span></span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        <span class="attr">headers</span>: &#123;</span><br><span class="line">            <span class="comment">// Content-Type设置为JSON:</span></span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 发送数据序列化为JSON:</span></span><br><span class="line">        <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 收到响应后解析JSON数据:</span></span><br><span class="line">        resp.<span class="title function_">json</span>().<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 解析后的数据:</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">            <span class="comment">// 判断是否有error字段:</span></span><br><span class="line">            <span class="keyword">if</span> (result.<span class="property">error</span>) &#123;</span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">`Sign in failed: <span class="subst">$&#123;result.error&#125;</span>`</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 登录成功,取出name字段:</span></span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">`Welcome, <span class="subst">$&#123;result.name&#125;</span>!`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 必须返回false以取消浏览器自动提交表单:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，在koa中处理REST请求是非常简单的。<code>bodyParser()</code>这个middleware可以解析请求的JSON数据并绑定到<code>ctx.request.body</code>上，输出JSON时我们把JavaScript对象赋值给<code>ctx.response.body</code>就完成了REST请求的处理。</p>
<h3 id="参考源码-12">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/rest/koa-rest.zip">koa-rest</a></p>
<p>程序运行的时候，数据都是在内存中的。当程序终止的时候，通常都需要将数据保存到磁盘上，无论是保存到本地磁盘，还是通过网络保存到服务器上，最终都会将数据写入磁盘文件。</p>
<p>而如何定义数据的存储格式就是一个大问题。如果我们自己来定义存储格式，比如保存一个班级所有学生的成绩单：</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>成绩</th>
</tr>
</thead>
<tbody>
<tr>
<td>Michael</td>
<td>99</td>
</tr>
<tr>
<td>Bob</td>
<td>85</td>
</tr>
<tr>
<td>Bart</td>
<td>59</td>
</tr>
<tr>
<td>Lisa</td>
<td>87</td>
</tr>
</tbody>
</table>
<p>我们可以用一个文本文件保存，一行保存一个学生，用<code>,</code>隔开：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Michael,99</span><br><span class="line">Bob,85</span><br><span class="line">Bart,59</span><br><span class="line">Lisa,87</span><br></pre></td></tr></table></figure>
<p>还可以用JSON格式保存，也是文本文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Michael&quot;</span><span class="punctuation">,</span><span class="attr">&quot;score&quot;</span><span class="punctuation">:</span><span class="number">99</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Bob&quot;</span><span class="punctuation">,</span><span class="attr">&quot;score&quot;</span><span class="punctuation">:</span><span class="number">85</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Bart&quot;</span><span class="punctuation">,</span><span class="attr">&quot;score&quot;</span><span class="punctuation">:</span><span class="number">59</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Lisa&quot;</span><span class="punctuation">,</span><span class="attr">&quot;score&quot;</span><span class="punctuation">:</span><span class="number">87</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>还可以定义各种保存格式，但是问题来了：</p>
<p>存储和读取需要自己实现，JSON还是标准，自己定义的格式就各式各样了；</p>
<p>不能做快速查询，只有把数据全部读到内存中才能自己遍历，但有时候数据的大小远远超过了内存，根本无法全部读入内存。</p>
<p>为了便于程序保存和读取数据，而且，能直接通过条件快速查询到指定的数据，就出现了数据库（Database）这种专门用于集中存储和查询的软件。</p>
<p>数据库软件诞生的历史非常久远，早在1950年数据库就诞生了。经历了网状数据库，层次数据库，我们现在广泛使用的关系数据库是20世纪70年代基于关系模型的基础上诞生的。</p>
<p>关系模型有一套复杂的数学理论，但是从概念上是十分容易理解的。举个学校的例子：</p>
<p>假设某个XX省YY市ZZ县第一实验小学有3个年级，要表示出这3个年级，可以在Excel中用一个表格画出来：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/database/table_grade.jpg" alt="grade"></p>
<p>每个年级又有若干个班级，要把所有班级表示出来，可以在Excel中再画一个表格：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/database/table_class.jpg" alt="class"></p>
<p>这两个表格有个映射关系，就是根据Grade_ID可以在班级表中查找到对应的所有班级：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/database/table_relationship.jpg" alt="grade-classes"></p>
<p>也就是Grade表的每一行对应Class表的多行，在关系数据库中，这种基于表（Table）的一对多的关系就是关系数据库的基础。</p>
<p>根据某个年级的ID就可以查找所有班级的行，这种查询语句在关系数据库中称为SQL语句，可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> classes <span class="keyword">WHERE</span> grade_id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果也是一个表：</p>
<table>
<thead>
<tr>
<th>grade_id</th>
<th>class_id</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>11</td>
<td>一年级一班</td>
</tr>
<tr>
<td>1</td>
<td>12</td>
<td>一年级二班</td>
</tr>
<tr>
<td>1</td>
<td>13</td>
<td>一年级三班</td>
</tr>
</tbody>
</table>
<p>类似的，Class表的一行记录又可以关联到Student表的多行记录：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/database/table_relationship2.jpg" alt="class-students"></p>
<p>由于本教程不涉及到关系数据库的详细内容，如果你想从零学习关系数据库和基本的SQL语句，请参考<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/sql/index.html">SQL教程</a>。</p>
<h3 id="NoSQL">NoSQL</h3>
<p>你也许还听说过NoSQL数据库，很多NoSQL宣传其速度和规模远远超过关系数据库，所以很多同学觉得有了NoSQL是否就不需要SQL了呢？千万不要被他们忽悠了，连SQL都不明白怎么可能搞明白NoSQL呢？</p>
<h3 id="数据库类别">数据库类别</h3>
<p>既然我们要使用关系数据库，就必须选择一个关系数据库。目前广泛使用的关系数据库也就这么几种：</p>
<p>付费的商用数据库：</p>
<ul>
<li>Oracle，典型的高富帅；</li>
<li>SQL Server，微软自家产品，Windows定制专款；</li>
<li>DB2，IBM的产品，听起来挺高端；</li>
<li>Sybase，曾经跟微软是好基友，后来关系破裂，现在家境惨淡。</li>
</ul>
<p>这些数据库都是不开源而且付费的，最大的好处是花了钱出了问题可以找厂家解决，不过在Web的世界里，常常需要部署成千上万的数据库服务器，当然不能把大把大把的银子扔给厂家，所以，无论是Google、Facebook，还是国内的BAT，无一例外都选择了免费的开源数据库：</p>
<ul>
<li>MySQL，大家都在用，一般错不了；</li>
<li>PostgreSQL，学术气息有点重，其实挺不错，但知名度没有MySQL高；</li>
<li>SQLite，嵌入式数据库，适合桌面和移动应用。</li>
</ul>
<p>作为一个JavaScript全栈工程师，选择哪个免费数据库呢？这里我们用SQLite，作为嵌入式数据库，优点是不用安装任何软件，直接能用。当然，在生产环境下，应当选择MySQL或者PostgreSQL。</p>
<p>在Node.js中，访问不同的数据库需要安装不同的数据库驱动。</p>
<p>因为我们使用Sqlite，所以需要安装Sqlite的驱动。这里我们选择<code>sqlite3</code>这个驱动，它内置sqlite。</p>
<p><code>sqlite3</code>通过如下代码可以创建一个<code>db</code>对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定模式打开test.db:</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="keyword">new</span> sqlite3.<span class="title class_">Database</span>(<span class="string">&#x27;test.db&#x27;</span>, sqlite3.<span class="property">OPEN_READWRITE</span> | sqlite3.<span class="property">OPEN_CREATE</span> | sqlite3.<span class="property">OPEN_FULLMUTEX</span>);</span><br></pre></td></tr></table></figure>
<p>我们传入了<code>OPEN_CREATE</code>参数，表示如果数据库不存在则自动创建，在开发模式下非常方便。</p>
<p><code>sqlite3</code>使用回调模式执行查询和更新操作，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// query:</span></span><br><span class="line">db.<span class="title function_">all</span>(<span class="string">&#x27;SELECT * FROM users WHERE id=?&#x27;</span>, [<span class="number">1</span>], <span class="keyword">function</span> (<span class="params">err, rows</span>) &#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// update:</span></span><br><span class="line">db.<span class="title function_">run</span>(<span class="string">&#x27;UPDATE users SET name=? WHERE id=?&#x27;</span>, [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">1</span>], <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>回调模式写起来非常别扭，由于<code>sqlite3</code>没有提供Promise接口，因此无法使用await调用，怎么办？</p>
<p>答案是我们自己封装一个Promise调用，以便通过await来实现异步查询和更新：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.mjs:</span></span><br><span class="line"><span class="keyword">import</span> sqlite3 <span class="keyword">from</span> <span class="string">&#x27;sqlite3&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createDatabase</span>(<span class="params">file</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> db = <span class="keyword">new</span> sqlite3.<span class="title class_">Database</span>(file, sqlite3.<span class="property">OPEN_READWRITE</span> | sqlite3.<span class="property">OPEN_CREATE</span> | sqlite3.<span class="property">OPEN_FULLMUTEX</span>);</span><br><span class="line">    <span class="keyword">const</span> wrapper = &#123;</span><br><span class="line">        <span class="attr">db</span>: db</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 执行update:</span></span><br><span class="line">    wrapper.<span class="property">update</span> = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">strs, ...params</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> sql = strs.<span class="title function_">join</span>(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">            db.<span class="title function_">run</span>(sql, ...params, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(err);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">changes</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 执行insert并返回lastID:</span></span><br><span class="line">    wrapper.<span class="property">insert</span> = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">strs, ...params</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> sql = strs.<span class="title function_">join</span>(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">            db.<span class="title function_">run</span>(sql, ...params, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(err);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">lastID</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 查询数据,返回array:</span></span><br><span class="line">    wrapper.<span class="property">select</span> = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">strs, ...params</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> sql = strs.<span class="title function_">join</span>(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`sql = <span class="subst">$&#123;sql&#125;</span>, params = [<span class="subst">$&#123;params.join(<span class="string">&#x27;, &#x27;</span>)&#125;</span>]`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            db.<span class="title function_">all</span>(sql, ...params, <span class="keyword">function</span> (<span class="params">err, rows</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(err);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(rows);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 查询一行数据,不存在返回null:</span></span><br><span class="line">    wrapper.<span class="property">fetch</span> = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">strs, ...params</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们复制前面的<code>koa-mvc</code>工程，命名为<code>sql</code>，准备用实际数据库替换写死的登录逻辑。工程结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sql/</span><br><span class="line">├── app.mjs</span><br><span class="line">├── db.mjs</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure>
<p>通过<code>npm install sqlite3</code>安装依赖项并添加依赖：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;sqlite3&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.1.7&quot;</span></span><br></pre></td></tr></table></figure>
<p>增加了<code>db.mjs</code>，实现了对sqlite数据库的操作。</p>
<p>我们在<code>app.mjs</code>中初始化一个<code>db</code>对象并绑定到<code>app.context</code>中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createDatabase &#125; <span class="keyword">from</span> <span class="string">&#x27;./db.mjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">initDb</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> email = <span class="string">&#x27;admin@example.com&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> password = <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">    <span class="comment">// 创建db对象:</span></span><br><span class="line">    <span class="keyword">const</span> db = <span class="title function_">createDatabase</span>(<span class="string">&#x27;test.db&#x27;</span>);</span><br><span class="line">    <span class="comment">// 如果users表不存在则创建表:</span></span><br><span class="line">    <span class="keyword">await</span> db.<span class="property">update</span><span class="string">`CREATE TABLE IF NOT EXISTS users(id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, email TEXT NOT NULL UNIQUE, name TEXT NOT NULL, password TEXT NOT NULL)`</span>;</span><br><span class="line">    <span class="comment">// 查询admin用户:</span></span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> db.<span class="property">fetch</span><span class="string">`SELECT * FROM users WHERE email=<span class="subst">$&#123;email&#125;</span>`</span>;</span><br><span class="line">    <span class="comment">// 用户不存在则自动创建:</span></span><br><span class="line">    <span class="keyword">if</span> (user === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">await</span> db.<span class="property">insert</span><span class="string">`INSERT INTO users (email, name, password) VALUES (<span class="subst">$&#123;email&#125;</span>, <span class="subst">$&#123;name&#125;</span>, <span class="subst">$&#123;password&#125;</span>)`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> db;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定db到app.context:</span></span><br><span class="line">app.<span class="property">context</span>.<span class="property">db</span> = <span class="keyword">await</span> <span class="title function_">initDb</span>();</span><br></pre></td></tr></table></figure>
<p>注意到<code>initDb()</code>中自动创建表和用户的代码都是为了便于开发。</p>
<p>有了数据库支持，我们就可以把<code>signin.mjs</code>写死的代码替换为查询数据库用户：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// signin:</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">signin</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> email = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">email</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> password = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 从数据库查询用户:</span></span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> ctx.<span class="property">db</span>.<span class="property">fetch</span><span class="string">`SELECT * FROM users WHERE email=<span class="subst">$&#123;email&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">if</span> (user !== <span class="literal">null</span> &amp;&amp; user.<span class="property">password</span> === password) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin ok!&#x27;</span>);</span><br><span class="line">        ctx.<span class="title function_">render</span>(<span class="string">&#x27;signin-ok.html&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;Sign In OK&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: user.<span class="property">name</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin failed!&#x27;</span>);</span><br><span class="line">        ctx.<span class="title function_">render</span>(<span class="string">&#x27;signin-failed.html&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;Sign In Failed&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察上述代码，我们查询数据库中某个用户的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">await</span> ctx.<span class="property">db</span>.<span class="property">fetch</span><span class="string">`SELECT * FROM users WHERE email=<span class="subst">$&#123;email&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
<p>这是一个<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/function/tag-function/index.html">标签函数</a>，它自动将参数变为如下调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">await</span> ctx.<span class="property">db</span>.<span class="title function_">fetch</span>([<span class="string">&#x27;SELECT * FROM users WHERE email=&#x27;</span>, <span class="string">&#x27;&#x27;</span>], email);</span><br></pre></td></tr></table></figure>
<p>在函数内部，实际执行的SQL是<code>SELECT * FROM users WHERE email=?</code>，因此，通过标签函数，我们总是以参数化形式执行SQL，避免了SQL注入。</p>
<p>执行<code>node app.mjs</code>，可以看到页面效果，同时，后台会打印出执行的SQL语句与绑定的参数。</p>
<h3 id="参考">参考</h3>
<p>参考源码：<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/web/database/sql/sql.zip">sql</a></p>
<p>sqlite数据库：<a target="_blank" rel="noopener" href="https://www.sqlite.org/">sqlite</a></p>
<p>sqlite3文档：<a target="_blank" rel="noopener" href="https://github.com/TryGhost/node-sqlite3">sqlite3</a></p>
<p>直接使用<code>sqlite3</code>提供的接口，我们执行数据库操作时必须提供SQL语句，比较底层。</p>
<p>考虑到数据库表是一个二维表，包含多行多列，例如一个<code>users</code>的表：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>email</th>
<th>name</th>
<th>password</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><a href="mailto:admin@example.com">admin@example.com</a></td>
<td>Bob</td>
<td>123456</td>
</tr>
<tr>
<td>2</td>
<td><a href="mailto:lucy@example.com">lucy@example.com</a></td>
<td>Lucy</td>
<td>abcdef</td>
</tr>
<tr>
<td>3</td>
<td><a href="mailto:alice@example.com">alice@example.com</a></td>
<td>Alice</td>
<td>hello123</td>
</tr>
</tbody>
</table>
<p>每一行可以用一个JavaScript对象表示，例如第一行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">email</span>: <span class="string">&#x27;admin@example.com&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是传说中的ORM技术：Object-Relational Mapping，把关系数据库的表结构映射到对象上。是不是很简单？</p>
<p>但是由谁来做这个转换呢？所以ORM框架应运而生。</p>
<p>我们选择Node的ORM框架Sequelize来操作数据库。这样，我们读写的都是JavaScript对象，Sequelize帮我们把对象变成数据库中的行。</p>
<p>用Sequelize查询<code>users</code>表，代码像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> users = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">findAll</span>();</span><br></pre></td></tr></table></figure>
<p>根据<code>email</code>查询一个用户，代码像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">find</span>(&#123;</span><br><span class="line">    <span class="attr">where</span>: &#123;</span><br><span class="line">        <span class="attr">email</span>: <span class="string">&#x27;admin@example.com&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Sequelize的所有操作都是Promise，所以我们可以用await实现异步调用。</p>
<h3 id="实战">实战</h3>
<p>在使用Sequelize操作数据库之前，我们需要告诉Sequelize如何映射数据库中的每一个表。</p>
<p>以<code>users</code>表为例，我们需要定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orm.mjs:</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Sequelize</span>, <span class="title class_">DataTypes</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;sequelize&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建sequelize对象表示已连接到数据库:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sequelize = <span class="keyword">new</span> <span class="title class_">Sequelize</span>(<span class="string">&#x27;sqlite:test.db&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义User:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">User</span> = sequelize.<span class="title function_">define</span>(<span class="string">&#x27;User&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// 每一列的定义:</span></span><br><span class="line">    <span class="attr">id</span>: &#123;</span><br><span class="line">        <span class="attr">primaryKey</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">autoIncrement</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">DataTypes</span>.<span class="property">INTEGER</span>,</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">email</span>: &#123;</span><br><span class="line">        <span class="attr">unique</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">DataTypes</span>.<span class="property">STRING</span>,</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">DataTypes</span>.<span class="property">STRING</span>,</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">password</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">DataTypes</span>.<span class="property">STRING</span>,</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="comment">// 指定表名:</span></span><br><span class="line">    <span class="attr">tableName</span>: <span class="string">&#x27;users&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在定义列的时候，主键以<code>primaryKey: true</code>指定，具有唯一约束的列用<code>unique: true</code>表示，数据类型用<code>DataTypes</code>表示。</p>
<p>这样Sequelize就有了足够的信息来实现ORM。最后将<code>sequelize</code>和<code>User</code>对象导出。</p>
<p>我们根据上一节的<code>sql</code>工程结构创建<code>orm</code>工程，结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sql/</span><br><span class="line">├── app.mjs</span><br><span class="line">├── orm.mjs</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure>
<p>删除了<code>db.mjs</code>，增加<code>orm.mjs</code>。</p>
<p>然后，通过<code>npm install sequelize sqlite3</code>安装依赖项并添加依赖：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;sequelize&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^6.37.3&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sqlite3&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.1.7&quot;</span></span><br></pre></td></tr></table></figure>
<p>在<code>app.mjs</code>中，删除相关SQL操作，改为通过Sequelize初始化数据库：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sequelize, <span class="title class_">User</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./orm.mjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">initDb</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 自动创建数据库表, 仅限开发模式:</span></span><br><span class="line">    <span class="keyword">await</span> sequelize.<span class="title function_">sync</span>();</span><br><span class="line">    <span class="comment">// 查询admin用户:</span></span><br><span class="line">    <span class="keyword">const</span> email = <span class="string">&#x27;admin@example.com&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">findOne</span>(&#123;</span><br><span class="line">        <span class="attr">where</span>: &#123;</span><br><span class="line">            <span class="attr">email</span>: email</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 不存在则自动创建:</span></span><br><span class="line">    <span class="keyword">if</span> (user === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">            <span class="attr">email</span>: email,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">            <span class="attr">password</span>: <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">await</span> <span class="title function_">initDb</span>();</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>使用Sequelize时，无需绑定<code>app.context</code>，因为我们主要通过具体的Model比如<code>User</code>来操作数据库。修改<code>signin.mjs</code>如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">User</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../orm.mjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// signin:</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">signin</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> email = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">email</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> password = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 调用Model.findOne()查询一行记录:</span></span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">findOne</span>(&#123;</span><br><span class="line">        <span class="attr">where</span>: &#123;</span><br><span class="line">            <span class="attr">email</span>: email</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (user !== <span class="literal">null</span> &amp;&amp; user.<span class="property">password</span> === password) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin ok!&#x27;</span>);</span><br><span class="line">        ctx.<span class="title function_">render</span>(<span class="string">&#x27;signin-ok.html&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;Sign In OK&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: user.<span class="property">name</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin failed!&#x27;</span>);</span><br><span class="line">        ctx.<span class="title function_">render</span>(<span class="string">&#x27;signin-failed.html&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;Sign In Failed&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>node app.mjs</code>启动服务器，可以观察到Sequelize访问数据库时打印的SQL语句。这里需要注意的是，Sequelize会为每个Model自动添加一个<code>createdAt</code>和<code>updatedAt</code>字段，用来记录创建和更新时间。因此，创建的<code>users</code>表的SQL语句为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `users` (</span><br><span class="line">    `id` <span class="type">INTEGER</span> <span class="keyword">PRIMARY KEY</span> AUTOINCREMENT,</span><br><span class="line">    `email` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    `name` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `password` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `createdAt` DATETIME <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `updatedAt` DATETIME <span class="keyword">NOT NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="常用操作">常用操作</h3>
<p>Sequelize提供了<code>findAll()</code>和<code>findOne()</code>两种查询，分别返回多行和一行。</p>
<p><code>create()</code>操作可以存储一个对象到数据库的一行记录，<code>save()</code>和<code>destroy()</code>分别对应更新和删除操作。</p>
<p>Sequelize还提供了一对多等高级ORM功能，具体可以参考官方文档。</p>
<h3 id="参考-2">参考</h3>
<p>参考源码：<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/web/database/orm/orm.zip">orm</a></p>
<p>Sequelize：<a target="_blank" rel="noopener" href="https://sequelize.org/">官方网站</a></p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">標籤</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/JavaScript/" rel="tag">JavaScript</a> <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../28/%E5%88%9D%E5%BF%83%E8%80%85%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%83%80%E3%82%A4%E3%82%AF%E3%82%B9%E3%83%88%E3%83%A9%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/"
                    data-tooltip="初心者のためのダイクストラアルゴリズム"
                    aria-label="上一篇: 初心者のためのダイクストラアルゴリズム"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JavaScript-underscore/"
                    data-tooltip="JavaScript-underscore"
                    aria-label="下一篇: JavaScript-underscore"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-Node-js/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-Node-js/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-Node-js/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-Node-js/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../28/%E5%88%9D%E5%BF%83%E8%80%85%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%83%80%E3%82%A4%E3%82%AF%E3%82%B9%E3%83%88%E3%83%A9%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/"
                    data-tooltip="初心者のためのダイクストラアルゴリズム"
                    aria-label="上一篇: 初心者のためのダイクストラアルゴリズム"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JavaScript-underscore/"
                    data-tooltip="JavaScript-underscore"
                    aria-label="下一篇: JavaScript-underscore"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-Node-js/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-Node-js/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-Node-js/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-Node-js/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-Node-js/"
                        aria-label="分享到 Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-Node-js/"
                        aria-label="分享到 Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-Node-js/"
                        aria-label="global.share_on_linkedin"
                    >
                        <i class="fab fa-linkedin" aria-hidden="true"></i><span>global.share_on_linkedin</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/26/JavaScript/JavaScript-Node-js/"
                        aria-label="分享到 Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 199 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
