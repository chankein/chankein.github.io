
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>JAVA-网络编程 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg"},"articleBody":"在学习Java网络编程之前，我们先来了解什么是计算机网络。\n计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。\n那什么是互联网呢？互联网是网络的网络（Internet），即把很多计算机网络连接起来，形成一个全球统一的互联网。\n对某个特定的计算机网络来说，它可能使用网络协议ABC，而另一个计算机网络可能使用网络协议XYZ。如果计算机网络各自的通讯协议不统一，就没法把不同的网络连接起来形成互联网。因此，为了把计算机网络接入互联网，就必须使用TCP/IP协议。\nTCP/IP协议泛指互联网协议，其中最重要的两个协议是TCP协议和IP协议。只有使用TCP/IP协议的计算机才能够联入互联网，使用其他网络协议（例如NetBIOS、AppleTalk协议等）是无法联入互联网的。\nIP地址\n在互联网中，一个IP地址用于唯一标识一个网络接口（Network Interface）。一台联入互联网的计算机肯定有一个IP地址，但也可能有多个IP地址。\nIP地址分为IPv4和IPv6两种。IPv4采用32位地址，类似101.202.99.12，而IPv6采用128位地址，类似2001:0DA8:100A:0000:0000:1020:F2F3:1428。IPv4地址总共有232个（大约42亿），而IPv6地址则总共有2128个（大约340万亿亿亿亿），IPv4的地址目前已耗尽，而IPv6的地址是根本用不完的。\nIP地址又分为公网IP地址和内网IP地址。公网IP地址可以直接被访问，内网IP地址只能在内网访问。内网IP地址类似于：\n\n192.168.x.x\n10.x.x.x\n\n有一个特殊的IP地址，称之为本机地址，它总是127.0.0.1。\nIPv4地址实际上是一个32位整数。例如：\n1231707762444 = 0x65ca630c           = 65  ca  63 0c           = 101.202.99.12\n如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址127.0.0.1，还有一个IP地址，例如101.202.99.12，可以通过这个IP地址接入网络。\n如果一台计算机有两块网卡，那么除了本机地址，它可以有两个IP地址，可以分别接入两个网络。通常连接两个网络的设备是路由器或者交换机，它至少有两个IP地址，分别接入不同的网络，让网络之间连接起来。\n如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的IP地址前段是相同的，也就是网络号是相同的。网络号是IP地址通过子网掩码过滤后得到的。例如：\n某台计算机的IP是101.202.99.2，子网掩码是255.255.255.0，那么计算该计算机的网络号是：\n123IP = 101.202.99.2Mask = 255.255.255.0Network = IP &amp; Mask = 101.202.99.0\n每台计算机都需要正确配置IP地址和子网掩码，根据这两个就可以计算网络号，如果两台计算机计算出的网络号相同，说明两台计算机在同一个网络，可以直接通信。如果两台计算机计算出的网络号不同，那么两台计算机不在同一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备间接通信，我们把这种设备称为网关。\n网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫路由。\n所以，一台计算机的一个网卡会有3个关键配置：\n\n\nIP地址，例如：10.0.2.15\n子网掩码，例如：255.255.255.0\n网关的IP地址，例如：10.0.2.2\n\n域名\n因为直接记忆IP地址非常困难，所以我们通常使用域名访问某个特定的服务。域名解析服务器DNS负责把域名翻译成对应的IP，客户端再根据IP地址访问服务器。\n用nslookup可以查看域名对应的IP地址：\n1234567$ nslookup liaoxuefeng.comServer:  xxx.xxx.xxx.xxxAddress: xxx.xxx.xxx.xxx#53Non-authoritative answer:Name:    liaoxuefeng.comAddress: xxx.xxx.xxx.xxx\n有一个特殊的本机域名localhost，它对应的IP地址总是本机地址127.0.0.1。\n网络模型\n由于计算机网络从底层的传输到高层的软件设计十分复杂，要合理地设计计算机网络模型，必须采用分层模型，每一层负责处理自己的操作。OSI（Open System Interconnect）网络模型是ISO组织定义的一个计算机互联的标准模型，注意它只是一个定义，目的是为了简化网络各层的操作，提供标准接口便于实现和维护。这个模型从上到下依次是：\n\n应用层，提供应用程序之间的通信；\n表示层：处理数据格式，加解密等等；\n会话层：负责建立和维护会话；\n传输层：负责提供端到端的可靠传输；\n网络层：负责根据目标地址选择路由来传输数据；\n链路层和物理层负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等。\n\n互联网实际使用的TCP/IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型：\n\n\n\nOSI\nTCP/IP\n\n\n\n\n应用层\n应用层\n\n\n表示层\n\n\n\n会话层\n\n\n\n传输层\n传输层\n\n\n网络层\nIP层\n\n\n链路层\n网络接口层\n\n\n物理层\n\n\n\n\n常用协议\nIP协议是一个分组交换，它不保证可靠传输。而TCP协议是传输控制协议，它是面向连接的协议，支持可靠传输和双向通信。TCP协议是建立在IP协议之上的，简单地说，IP协议只负责发数据包，不保证顺序和正确性，而TCP协议负责控制数据包传输，它在传输数据之前需要先建立连接，建立连接后才能传输数据，传输完后还需要断开连接。TCP协议之所以能保证数据的可靠传输，是通过接收确认、超时重传这些机制实现的。并且，TCP协议允许双向通信，即通信双方可以同时发送和接收数据。\nTCP协议也是应用最广泛的协议，许多高级协议都是建立在TCP协议之上的，例如HTTP、SMTP等。\nUDP协议（User Datagram Protocol）是一种数据报文协议，它是无连接协议，不保证可靠传输。因为UDP协议在通信前不需要建立连接，因此它的传输效率比TCP高，而且UDP协议比TCP协议要简单得多。\n选择UDP协议时，传输的数据通常是能容忍丢失的，例如，一些语音视频通信的应用会选择UDP协议。\n小结\n计算机网络的基本概念主要有：\n\n计算机网络：由两台或更多计算机组成的网络；\n互联网：连接网络的网络；\nIP地址：计算机的网络接口（通常是网卡）在网络中的唯一标识；\n网关：负责连接多个网络，并在多个网络之间转发数据的计算机，通常是路由器或交换机；\n网络协议：互联网使用TCP/IP协议，它泛指互联网协议簇；\nIP协议：一种分组交换传输协议；\nTCP协议：一种面向连接，可靠传输的协议；\nUDP协议：一种无连接，不可靠传输的协议。\n\n在开发网络应用程序的时候，我们又会遇到Socket这个概念。Socket是一个抽象概念，一个应用程序通过一个Socket来建立一个远程连接，而Socket内部通过TCP/IP协议把数据传输到网络：\n123456789┌───────────┐                                ┌───────────┐│Application│                                │Application│├───────────┤                                ├───────────┤│  Socket   │                                │  Socket   │├───────────┤                                ├───────────┤│    TCP    │                                │    TCP    │├───────────┤     ┌──────┐      ┌──────┐     ├───────────┤│    IP     │◀───▶│Router│◀────▶│Router│◀───▶│    IP     │└───────────┘     └──────┘      └──────┘     └───────────┘\nSocket、TCP和部分IP的功能都是由操作系统提供的，不同的编程语言只是提供了对操作系统调用的简单的封装。例如，Java提供的几个Socket相关的类就封装了操作系统提供的接口。\n为什么需要Socket进行网络通信？因为仅仅通过IP地址进行通信是不够的，同一台计算机同一时间会运行多个网络应用程序，例如浏览器、QQ、邮件客户端等。当操作系统接收到一个数据包的时候，如果只有IP地址，它没法判断应该发给哪个应用程序，所以，操作系统抽象出Socket接口，每个应用程序需要各自对应到不同的Socket，数据包才能根据Socket正确地发到对应的应用程序。\n一个Socket就是由IP地址和端口号（范围是0～65535）组成，可以把Socket简单理解为IP地址加端口号。端口号总是由操作系统分配，它是一个0～65535之间的数字，其中，小于1024的端口属于特权端口，需要管理员权限，大于1024的端口可以由任意用户的应用程序打开。\n\nBrowser: 101.202.99.2:1201\nQQ: 101.202.99.2:1304\nEmail: 101.202.99.2:15000\n\n使用Socket进行网络编程时，本质上就是两个进程之间的网络通信。其中一个进程必须充当服务器端，它会主动监听某个指定的端口，另一个进程必须充当客户端，它必须主动连接服务器的IP地址和指定端口，如果连接成功，服务器端和客户端就成功地建立了一个TCP连接，双方后续就可以随时发送和接收数据。\n因此，当Socket连接成功地在服务器端和客户端之间建立后：\n\n对服务器端来说，它的Socket是指定的IP地址和指定的端口号；\n对客户端来说，它的Socket是它所在计算机的IP地址和一个由操作系统分配的随机端口号。\n\n服务器端\n要使用Socket编程，我们首先要编写服务器端程序。Java标准库提供了ServerSocket来实现对指定IP和指定端口的监听。ServerSocket的典型实现代码如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Server &#123;    public static void main(String[] args) throws IOException &#123;        ServerSocket ss = new ServerSocket(6666); // 监听指定端口        System.out.println(&quot;server is running...&quot;);        for (;;) &#123;            Socket sock = ss.accept();            System.out.println(&quot;connected from &quot; + sock.getRemoteSocketAddress());            Thread t = new Handler(sock);            t.start();        &#125;    &#125;&#125;class Handler extends Thread &#123;    Socket sock;    public Handler(Socket sock) &#123;        this.sock = sock;    &#125;    @Override    public void run() &#123;        try (InputStream input = this.sock.getInputStream()) &#123;            try (OutputStream output = this.sock.getOutputStream()) &#123;                handle(input, output);            &#125;        &#125; catch (Exception e) &#123;            try &#123;                this.sock.close();            &#125; catch (IOException ioe) &#123;            &#125;            System.out.println(&quot;client disconnected.&quot;);        &#125;    &#125;    private void handle(InputStream input, OutputStream output) throws IOException &#123;        var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));        var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));        writer.write(&quot;hello\\n&quot;);        writer.flush();        for (;;) &#123;            String s = reader.readLine();            if (s.equals(&quot;bye&quot;)) &#123;                writer.write(&quot;bye\\n&quot;);                writer.flush();                break;            &#125;            writer.write(&quot;ok: &quot; + s + &quot;\\n&quot;);            writer.flush();        &#125;    &#125;&#125;\n服务器端通过代码：\n1ServerSocket ss = new ServerSocket(6666);\n在指定端口6666监听。这里我们没有指定IP地址，表示在计算机的所有网络接口上进行监听。\n如果ServerSocket监听成功，我们就使用一个无限循环来处理客户端的连接：\n12345for (;;) &#123;    Socket sock = ss.accept();    Thread t = new Handler(sock);    t.start();&#125;\n注意到代码ss.accept()表示每当有新的客户端连接进来后，就返回一个Socket实例，这个Socket实例就是用来和刚连接的客户端进行通信的。由于客户端很多，要实现并发处理，我们就必须为每个新的Socket创建一个新线程来处理，这样，主线程的作用就是接收新的连接，每当收到新连接后，就创建一个新线程进行处理。\n我们在多线程编程的章节中介绍过线程池，这里也完全可以利用线程池来处理客户端连接，能大大提高运行效率。\n如果没有客户端连接进来，accept()方法会阻塞并一直等待。如果有多个客户端同时连接进来，ServerSocket会把连接扔到队列里，然后一个一个处理。对于Java程序而言，只需要通过循环不断调用accept()就可以获取新的连接。\n客户端\n相比服务器端，客户端程序就要简单很多。一个典型的客户端程序如下：\n12345678910111213141516171819202122232425262728293031public class Client &#123;    public static void main(String[] args) throws IOException &#123;        Socket sock = new Socket(&quot;localhost&quot;, 6666); // 连接指定服务器和端口        try (InputStream input = sock.getInputStream()) &#123;            try (OutputStream output = sock.getOutputStream()) &#123;                handle(input, output);            &#125;        &#125;        sock.close();        System.out.println(&quot;disconnected.&quot;);    &#125;    private static void handle(InputStream input, OutputStream output) throws IOException &#123;        var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));        var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;[server] &quot; + reader.readLine());        for (;;) &#123;            System.out.print(&quot;&gt;&gt;&gt; &quot;); // 打印提示            String s = scanner.nextLine(); // 读取一行输入            writer.write(s);            writer.newLine();            writer.flush();            String resp = reader.readLine();            System.out.println(&quot;&lt;&lt;&lt; &quot; + resp);            if (resp.equals(&quot;bye&quot;)) &#123;                break;            &#125;        &#125;    &#125;&#125;\n客户端程序通过：\n1Socket sock = new Socket(&quot;localhost&quot;, 6666);\n连接到服务器端，注意上述代码的服务器地址是&quot;localhost&quot;，表示本机地址，端口号是6666。如果连接成功，将返回一个Socket实例，用于后续通信。\nSocket流\n当Socket连接创建成功后，无论是服务器端，还是客户端，我们都使用Socket实例进行网络通信。因为TCP是一种基于流的协议，因此，Java标准库使用InputStream和OutputStream来封装Socket的数据流，这样我们使用Socket的流，和普通IO流类似：\n1234// 用于读取网络数据:InputStream in = sock.getInputStream();// 用于写入网络数据:OutputStream out = sock.getOutputStream();\n最后我们重点来看看，为什么写入网络数据时，要调用flush()方法。\n如果不调用flush()，我们很可能会发现，客户端和服务器都收不到数据，这并不是Java标准库的设计问题，而是我们以流的形式写入数据的时候，并不是一写入就立刻发送到网络，而是先写入内存缓冲区，直到缓冲区满了以后，才会一次性真正发送到网络，这样设计的目的是为了提高传输效率。如果缓冲区的数据很少，而我们又想强制把这些数据发送到网络，就必须调用flush()强制把缓冲区数据发送出去。\n练习\n使用Socket实现服务器和客户端通信。\n下载练习\n小结\n使用Java进行TCP编程时，需要使用Socket模型：\n\n服务器端用ServerSocket监听指定端口；\n客户端使用Socket(InetAddress, port)连接服务器；\n服务器端用accept()接收连接并返回Socket；\n双方通过Socket打开InputStream/OutputStream读写数据；\n服务器端通常使用多线程同时处理多个客户端连接，利用线程池可大幅提升效率；\nflush()用于强制输出缓冲区到网络。\n\n和TCP编程相比，UDP编程就简单得多，因为UDP没有创建连接，数据包也是一次收发一个，所以没有流的概念。\n在Java中使用UDP编程，仍然需要使用Socket，因为应用程序在使用UDP时必须指定网络接口（IP）和端口号。注意：UDP端口和TCP端口虽然都使用0~65535，但他们是两套独立的端口，即一个应用程序用TCP占用了端口1234，不影响另一个应用程序用UDP占用端口1234。\n服务器端\n在服务器端，使用UDP也需要监听指定的端口。Java提供了DatagramSocket来实现这个功能，代码如下：\n1234567891011121314DatagramSocket ds = new DatagramSocket(6666); // 监听指定端口for (;;) &#123; // 无限循环    // 数据缓冲区:    byte[] buffer = new byte[1024];    DatagramPacket packet = new DatagramPacket(buffer, buffer.length);    ds.receive(packet); // 收取一个UDP数据包    // 收取到的数据存储在buffer中，由packet.getOffset(), packet.getLength()指定起始位置和长度    // 将其按UTF-8编码转换为String:    String s = new String(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8);    // 发送数据:    byte[] data = &quot;ACK&quot;.getBytes(StandardCharsets.UTF_8);    packet.setData(data);    ds.send(packet);&#125;\n服务器端首先使用如下语句在指定的端口监听UDP数据包：\n1DatagramSocket ds = new DatagramSocket(6666);\n如果没有其他应用程序占据这个端口，那么监听成功，我们就使用一个无限循环来处理收到的UDP数据包：\n123for (;;) &#123;    ...&#125;\n要接收一个UDP数据包，需要准备一个byte[]缓冲区，并通过DatagramPacket实现接收：\n123byte[] buffer = new byte[1024];DatagramPacket packet = new DatagramPacket(buffer, buffer.length);ds.receive(packet);\n假设我们收取到的是一个String，那么，通过DatagramPacket返回的packet.getOffset()和packet.getLength()确定数据在缓冲区的起止位置：\n1String s = new String(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8);\n当服务器收到一个DatagramPacket后，通常必须立刻回复一个或多个UDP包，因为客户端地址在DatagramPacket中，每次收到的DatagramPacket可能是不同的客户端，如果不回复，客户端就收不到任何UDP包。\n发送UDP包也是通过DatagramPacket实现的，发送代码非常简单：\n123byte[] data = ...packet.setData(data);ds.send(packet);\n客户端\n和服务器端相比，客户端使用UDP时，只需要直接向服务器端发送UDP包，然后接收返回的UDP包：\n123456789101112131415DatagramSocket ds = new DatagramSocket();ds.setSoTimeout(1000);ds.connect(InetAddress.getByName(&quot;localhost&quot;), 6666); // 连接指定服务器和端口// 发送:byte[] data = &quot;Hello&quot;.getBytes();DatagramPacket packet = new DatagramPacket(data, data.length);ds.send(packet);// 接收:byte[] buffer = new byte[1024];packet = new DatagramPacket(buffer, buffer.length);ds.receive(packet);String resp = new String(packet.getData(), packet.getOffset(), packet.getLength());ds.disconnect();// 关闭:ds.close();\n客户端打开一个DatagramSocket使用以下代码：\n123DatagramSocket ds = new DatagramSocket();ds.setSoTimeout(1000);ds.connect(InetAddress.getByName(&quot;localhost&quot;), 6666);\n客户端创建DatagramSocket实例时并不需要指定端口，而是由操作系统自动指定一个当前未使用的端口。紧接着，调用setSoTimeout(1000)设定超时1秒，意思是后续接收UDP包时，等待时间最多不会超过1秒，否则在没有收到UDP包时，客户端会无限等待下去。这一点和服务器端不一样，服务器端可以无限等待，因为它本来就被设计成长时间运行。\n注意到客户端的DatagramSocket还调用了一个connect()方法“连接”到指定的服务器端。不是说UDP是无连接的协议吗？为啥这里需要connect()？\n这个connect()方法不是真连接，它是为了在客户端的DatagramSocket实例中保存服务器端的IP和端口号，确保这个DatagramSocket实例只能往指定的地址和端口发送UDP包，不能往其他地址和端口发送。这么做不是UDP的限制，而是Java内置了安全检查。\n后续的收发数据和服务器端是一致的。通常来说，客户端必须先发UDP包，因为客户端不发UDP包，服务器端就根本不知道客户端的地址和端口号。\n如果客户端认为通信结束，就可以调用disconnect()断开连接：\n1ds.disconnect();\n注意到disconnect()也不是真正地断开连接，它只是清除了客户端DatagramSocket实例记录的远程服务器地址和端口号，这样，DatagramSocket实例就可以连接另一个服务器端。\n如果客户端希望向两个不同的服务器发送UDP包，有两种方法：\n\n客户端可以创建两个DatagramSocket实例，用connect()连接到不同的服务器；\n客户端也可以不调用connect()方法，而是在创建DatagramPacket的时候指定服务器地址，这样可以用一个DatagramSocket实例发送DatagramPacket到不同的服务器。\n\n不调用connect()方法的代码如下：\n123456789101112DatagramSocket ds = new DatagramSocket();ds.setSoTimeout(1000);// 发送到localhost:6666:byte[] data1 = &quot;Hello&quot;.getBytes();var packet1 = new DatagramPacket(data1, data1.length, InetAddress.getByName(&quot;localhost&quot;), 6666);ds.send(packet1);// 发送到localhost:8888:byte[] data2 = &quot;Hi&quot;.getBytes();var packet2 = new DatagramPacket(data2, data2.length, InetAddress.getByName(&quot;localhost&quot;), 8888);ds.send(packet2);// 关闭:ds.close();\n练习\n使用UDP实现服务器和客户端通信。\n下载练习\n小结\n使用UDP协议通信时，服务器和客户端双方无需建立连接：\n\n服务器端用DatagramSocket(port)监听端口；\n客户端使用DatagramSocket.connect()指定远程地址和端口；\n双方通过receive()和send()读写数据；\nDatagramSocket没有IO流接口，数据被直接写入byte[]缓冲区。\n\nEmail就是电子邮件。电子邮件的应用已经有几十年的历史了，我们熟悉的邮箱地址比如abc@example.com，邮件软件比如Outlook都是用来收发邮件的。\n使用Java程序也可以收发电子邮件。我们先来看一下传统的邮件是如何发送的。\n传统的邮件是通过邮局投递，然后从一个邮局到另一个邮局，最终到达用户的邮箱：\n123456           ┌──────────┐    ┌──────────┐           │PostOffice│    │PostOffice│     .───.┌─────┐    ├──────────┤    ├──────────┤    (   ( )│═══ ░│───▶│ ┌─┐ ┌┐┌┐ │───▶│ ┌─┐ ┌┐┌┐ │───▶ `─┬─&#x27;└─────┘    │ │░│ └┘└┘ │    │ │░│ └┘└┘ │       │           └─┴─┴──────┘    └─┴─┴──────┘       │\n电子邮件的发送过程也是类似的，只不过是电子邮件是从用户电脑的邮件软件，例如Outlook，发送到邮件服务器上，可能经过若干个邮件服务器的中转，最终到达对方邮件服务器上，收件方就可以用软件接收邮件：\n12345678             ┌─────────┐    ┌─────────┐    ┌─────────┐             │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│┌───────┐    ├─────────┤    ├─────────┤    ├─────────┤    ┌───────┐│░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░│├───────┤    ├─────────┤    ├─────────┤    ├─────────┤    ├───────┤│       │───▶│O ░░░░░░░│───▶│O ░░░░░░░│───▶│O ░░░░░░░│◀───│       │└───────┘    └─────────┘    └─────────┘    └─────────┘    └───────┘   MUA           MTA            MTA            MDA           MUA\n我们把类似Outlook这样的邮件软件称为MUA：Mail User Agent，意思是给用户服务的邮件代理；邮件服务器则称为MTA：Mail Transfer Agent，意思是邮件中转的代理；最终到达的邮件服务器称为MDA：Mail Delivery Agent，意思是邮件到达的代理。电子邮件一旦到达MDA，就不再动了。实际上，电子邮件通常就存储在MDA服务器的硬盘上，然后等收件人通过软件或者登陆浏览器查看邮件。\nMTA和MDA这样的服务器软件通常是现成的，我们不关心这些服务器内部是如何运行的。要发送邮件，我们关心的是如何编写一个MUA的软件，把邮件发送到MTA上。\nMUA到MTA发送邮件的协议就是SMTP协议，它是Simple Mail Transport Protocol的缩写，使用标准端口25，也可以使用加密端口465或587。\nSMTP协议是一个建立在TCP之上的协议，任何程序发送邮件都必须遵守SMTP协议。使用Java程序发送邮件时，我们无需关心SMTP协议的底层原理，只需要使用JavaMail这个标准API就可以直接发送邮件。\n准备SMTP登录信息\n假设我们准备使用自己的邮件地址me@example.com给小明发送邮件，已知小明的邮件地址是xiaoming@somewhere.com，发送邮件前，我们首先要确定作为MTA的邮件服务器地址和端口号。邮件服务器地址通常是smtp.example.com，端口号由邮件服务商确定使用25、465还是587。以下是一些常用邮件服务商的SMTP信息：\n\nQQ邮箱：SMTP服务器是smtp.qq.com，端口是465/587；\n163邮箱：SMTP服务器是smtp.163.com，端口是465；\nGmail邮箱：SMTP服务器是smtp.gmail.com，端口是465/587。\n\n有了SMTP服务器的域名和端口号，我们还需要SMTP服务器的登录信息，通常是使用自己的邮件地址作为用户名，登录口令是用户口令或者一个独立设置的SMTP口令。\n我们来看看如何使用JavaMail发送邮件。\n首先，我们需要创建一个Maven工程，并把JavaMail相关的两个依赖加入进来：\n\njakarta.mail:javax.mail-api:2.0.1\ncom.sun.mail:jakarta.mail:2.0.1\n\n这两个包一个是接口定义，一个是具体实现。如果使用早期的1.x版本，则需注意引入的包名有所不同：\n\njavax.mail:javax.mail-api:1.6.2\ncom.sun.mail:javax.mail:1.6.2\n\n并且代码引用的jakarta.mail需替换为javax.mail。\n然后，我们通过JavaMail API连接到SMTP服务器上：\n1234567891011121314151617181920// 服务器地址:String smtp = &quot;smtp.office365.com&quot;;// 登录用户名:String username = &quot;jxsmtp101@outlook.com&quot;;// 登录口令:String password = &quot;********&quot;;// 连接到SMTP服务器587端口:Properties props = new Properties();props.put(&quot;mail.smtp.host&quot;, smtp); // SMTP主机名props.put(&quot;mail.smtp.port&quot;, &quot;587&quot;); // 主机端口号props.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;); // 是否需要用户认证props.put(&quot;mail.smtp.starttls.enable&quot;, &quot;true&quot;); // 启用TLS加密// 获取Session实例:Session session = Session.getInstance(props, new Authenticator() &#123;    protected PasswordAuthentication getPasswordAuthentication() &#123;        return new PasswordAuthentication(username, password);    &#125;&#125;);// 设置debug模式便于调试:session.setDebug(true);\n以587端口为例，连接SMTP服务器时，需要准备一个Properties对象，填入相关信息。最后获取Session实例时，如果服务器需要认证，还需要传入一个Authenticator对象，并返回指定的用户名和口令。\n当我们获取到Session实例后，打开调试模式可以看到SMTP通信的详细内容，便于调试。\n发送邮件\n发送邮件时，我们需要构造一个Message对象，然后调用Transport.send(Message)即可完成发送：\n1234567891011MimeMessage message = new MimeMessage(session);// 设置发送方地址:message.setFrom(new InternetAddress(&quot;me@example.com&quot;));// 设置接收方地址:message.setRecipient(Message.RecipientType.TO, new InternetAddress(&quot;xiaoming@somewhere.com&quot;));// 设置邮件主题:message.setSubject(&quot;Hello&quot;, &quot;UTF-8&quot;);// 设置邮件正文:message.setText(&quot;Hi Xiaoming...&quot;, &quot;UTF-8&quot;);// 发送:Transport.send(message);\n绝大多数邮件服务器要求发送方地址和登录用户名必须一致，否则发送将失败。\n填入真实的地址，运行上述代码，我们可以在控制台看到JavaMail打印的调试信息：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566这是JavaMail打印的调试信息:DEBUG: setDebug: JavaMail version 1.6.2DEBUG: getProvider() returning javax.mail.Provider[TRANSPORT,smtp,com.sun.mail.smtp.SMTPTransport,Oracle]DEBUG SMTP: need username and password for authenticationDEBUG SMTP: protocolConnect returning false, host=smtp.office365.com, ...DEBUG SMTP: useEhlo true, useAuth true开始尝试连接smtp.office365.com:DEBUG SMTP: trying to connect to host &quot;smtp.office365.com&quot;, port 587, ...DEBUG SMTP: connected to host &quot;smtp.office365.com&quot;, port: 587发送命令EHLO:EHLO localhostSMTP服务器响应250:250-SG3P274CA0024.outlook.office365.com Hello250-SIZE 157286400...DEBUG SMTP: Found extension &quot;SIZE&quot;, arg &quot;157286400&quot;发送命令STARTTLS:STARTTLSSMTP服务器响应220:220 2.0.0 SMTP server readyEHLO localhost250-SG3P274CA0024.outlook.office365.com Hello [111.196.164.63]250-SIZE 157286400250-PIPELINING250-...DEBUG SMTP: Found extension &quot;SIZE&quot;, arg &quot;157286400&quot;...尝试登录:DEBUG SMTP: protocolConnect login, host=smtp.office365.com, user=********, password=********DEBUG SMTP: Attempt to authenticate using mechanisms: LOGIN PLAIN DIGEST-MD5 NTLM XOAUTH2 DEBUG SMTP: Using mechanism LOGINDEBUG SMTP: AUTH LOGIN command trace suppressed登录成功:DEBUG SMTP: AUTH LOGIN succeededDEBUG SMTP: use8bit false开发发送邮件，设置FROM:MAIL FROM:&lt;********@outlook.com&gt;250 2.1.0 Sender OK设置TO:RCPT TO:&lt;********@sina.com&gt;250 2.1.5 Recipient OK发送邮件数据:DATA服务器响应354:354 Start mail input; end with &lt;CRLF&gt;.&lt;CRLF&gt;真正的邮件数据:Date: Mon, 2 Dec 2019 09:37:52 +0800 (CST)From: ********@outlook.comTo: ********001@sina.comMessage-ID: &lt;1617791695.0.1575250672483@localhost&gt;邮件主题是编码后的文本:Subject: =?UTF-8?Q?JavaMail=E9=82=AE=E4=BB=B6?=MIME-Version: 1.0Content-Type: text/plain; charset=UTF-8Content-Transfer-Encoding: base64邮件正文是Base64编码的文本:SGVsbG8sIOi/meaYr+S4gOWwgeadpeiHqmphdmFtYWls55qE6YKu5Lu277yB.邮件数据发送完成后，以\\r\\n.\\r\\n结束，服务器响应250表示发送成功:250 2.0.0 OK &lt;HK0PR03MB4961.apcprd03.prod.outlook.com&gt; [Hostname=HK0PR03MB4961.apcprd03.prod.outlook.com]DEBUG SMTP: message successfully delivered to mail server发送QUIT命令:QUIT服务器响应221结束TCP连接:221 2.0.0 Service closing transmission channel\n从上面的调试信息可以看出，SMTP协议是一个请求-响应协议，客户端总是发送命令，然后等待服务器响应。服务器响应总是以数字开头，后面的信息才是用于调试的文本。这些响应码已经被定义在SMTP协议中了，查看具体的响应码就可以知道出错原因。\n如果一切顺利，对方将收到一封文本格式的电子邮件：\n\n发送HTML邮件\n发送HTML邮件和文本邮件是类似的，只需要把：\n1message.setText(body, &quot;UTF-8&quot;);\n改为：\n1message.setText(body, &quot;UTF-8&quot;, &quot;html&quot;);\n传入的body是类似&lt;h1&gt;Hello&lt;/h1&gt;&lt;p&gt;Hi, xxx&lt;/p&gt;这样的HTML字符串即可。\nHTML邮件可以在邮件客户端直接显示为网页格式：\n\n发送附件\n要在电子邮件中携带附件，我们就不能直接调用message.setText()方法，而是要构造一个Multipart对象：\n123456789101112Multipart multipart = new MimeMultipart();// 添加text:BodyPart textpart = new MimeBodyPart();textpart.setContent(body, &quot;text/html;charset=utf-8&quot;);multipart.addBodyPart(textpart);// 添加image:BodyPart imagepart = new MimeBodyPart();imagepart.setFileName(fileName);imagepart.setDataHandler(new DataHandler(new ByteArrayDataSource(input, &quot;application/octet-stream&quot;)));multipart.addBodyPart(imagepart);// 设置邮件内容为multipart:message.setContent(multipart);\n一个Multipart对象可以添加若干个BodyPart，其中第一个BodyPart是文本，即邮件正文，后面的BodyPart是附件。BodyPart依靠setContent()决定添加的内容，如果添加文本，用setContent(&quot;...&quot;, &quot;text/plain;charset=utf-8&quot;)添加纯文本，或者用setContent(&quot;...&quot;, &quot;text/html;charset=utf-8&quot;)添加HTML文本。如果添加附件，需要设置文件名（不一定和真实文件名一致），并且添加一个DataHandler()，传入文件的MIME类型。二进制文件可以用application/octet-stream，Word文档则是application/msword。\n最后，通过setContent()把Multipart添加到Message中，即可发送。\n带附件的邮件在客户端会被提示下载：\n\n发送内嵌图片的HTML邮件\n有些童鞋可能注意到，HTML邮件中可以内嵌图片，这是怎么做到的？\n如果给一个&lt;img src=&quot;http://example.com/test.jpg&quot;&gt;，这样的外部图片链接通常会被邮件客户端过滤，并提示用户显示图片并不安全。只有内嵌的图片才能正常在邮件中显示。\n内嵌图片实际上也是一个附件，即邮件本身也是Multipart，但需要做一点额外的处理：\n123456789101112Multipart multipart = new MimeMultipart();// 添加text:BodyPart textpart = new MimeBodyPart();textpart.setContent(&quot;&lt;h1&gt;Hello&lt;/h1&gt;&lt;p&gt;&lt;img src=\\&quot;cid:img01\\&quot;&gt;&lt;/p&gt;&quot;, &quot;text/html;charset=utf-8&quot;);multipart.addBodyPart(textpart);// 添加image:BodyPart imagepart = new MimeBodyPart();imagepart.setFileName(fileName);imagepart.setDataHandler(new DataHandler(new ByteArrayDataSource(input, &quot;image/jpeg&quot;)));// 与HTML的&lt;img src=&quot;cid:img01&quot;&gt;关联:imagepart.setHeader(&quot;Content-ID&quot;, &quot;&lt;img01&gt;&quot;);multipart.addBodyPart(imagepart);\n在HTML邮件中引用图片时，需要设定一个ID，用类似&lt;img src=\\&quot;cid:img01\\&quot;&gt;引用，然后，在添加图片作为BodyPart时，除了要正确设置MIME类型（根据图片类型使用image/jpeg或image/png），还需要设置一个Header：\n1imagepart.setHeader(&quot;Content-ID&quot;, &quot;&lt;img01&gt;&quot;);\n这个ID和HTML中引用的ID对应起来，邮件客户端就可以正常显示内嵌图片：\n\n常见问题\n如果用户名或口令错误，会导致535登录失败：\n12DEBUG SMTP: AUTH LOGIN failedException in thread &quot;main&quot; javax.mail.AuthenticationFailedException: 535 5.7.3 Authentication unsuccessful [HK0PR03CA0105.apcprd03.prod.outlook.com]\n如果登录用户和发件人不一致，会导致554拒绝发送错误：\n12DEBUG SMTP: MessagingException while sending, THROW: com.sun.mail.smtp.SMTPSendFailedException: 554 5.2.0 STOREDRV.Submission.Exception:SendAsDeniedException.MapiExceptionSendAsDenied;\n有些时候，如果邮件主题和正文过于简单，会导致554被识别为垃圾邮件的错误：\n12DEBUG SMTP: MessagingException while sending, THROW: com.sun.mail.smtp.SMTPSendFailedException: 554 DT:SPM\n总之，出错时，需要查看DEBUG信息，找到服务器返回的错误码和描述信息来定位错误原因。\n练习\n使用SMTP发送邮件。\n下载练习\n小结\n使用JavaMail API发送邮件本质上是一个MUA软件通过SMTP协议发送邮件至MTA服务器；\n打开调试模式可以看到详细的SMTP交互信息；\n某些邮件服务商需要开启SMTP，并需要独立的SMTP登录密码。\n发送Email的过程我们在上一节已经讲过了，客户端总是通过SMTP协议把邮件发送给MTA。\n接收Email则相反，因为邮件最终到达收件人的MDA服务器，所以，接收邮件是收件人用自己的客户端把邮件从MDA服务器上抓取到本地的过程。\n接收邮件使用最广泛的协议是POP3：Post Office Protocol version 3，它也是一个建立在TCP连接之上的协议。POP3服务器的标准端口是110，如果整个会话需要加密，那么使用加密端口995。\n另一种接收邮件的协议是IMAP：Internet Mail Access Protocol，它使用标准端口143和加密端口993。IMAP和POP3的主要区别是，IMAP协议在本地的所有操作都会自动同步到服务器上，并且，IMAP可以允许用户在邮件服务器的收件箱中创建文件夹。\nJavaMail也提供了IMAP协议的支持。因为POP3和IMAP的使用方式非常类似，这里我们只介绍POP3的用法。\n使用POP3收取Email时，我们无需关心POP3协议底层，因为JavaMail提供了高层接口。首先需要连接到Store对象：\n1234567891011121314151617181920// 准备登录信息:String host = &quot;pop3.example.com&quot;;int port = 995;String username = &quot;bob@example.com&quot;;String password = &quot;password&quot;;Properties props = new Properties();props.setProperty(&quot;mail.store.protocol&quot;, &quot;pop3&quot;); // 协议名称props.setProperty(&quot;mail.pop3.host&quot;, host);// POP3主机名props.setProperty(&quot;mail.pop3.port&quot;, String.valueOf(port)); // 端口号// 启动SSL:props.put(&quot;mail.smtp.socketFactory.class&quot;, &quot;javax.net.ssl.SSLSocketFactory&quot;);props.put(&quot;mail.smtp.socketFactory.port&quot;, String.valueOf(port));// 连接到Store:URLName url = new URLName(&quot;pop3&quot;, host, post, &quot;&quot;, username, password);Session session = Session.getInstance(props, null);session.setDebug(true); // 显示调试信息Store store = new POP3SSLStore(session, url);store.connect();\n一个Store对象表示整个邮箱的存储，要收取邮件，我们需要通过Store访问指定的Folder（文件夹），通常是INBOX表示收件箱：\n123456789101112131415// 获取收件箱:Folder folder = store.getFolder(&quot;INBOX&quot;);// 以读写方式打开:folder.open(Folder.READ_WRITE);// 打印邮件总数/新邮件数量/未读数量/已删除数量:System.out.println(&quot;Total messages: &quot; + folder.getMessageCount());System.out.println(&quot;New messages: &quot; + folder.getNewMessageCount());System.out.println(&quot;Unread messages: &quot; + folder.getUnreadMessageCount());System.out.println(&quot;Deleted messages: &quot; + folder.getDeletedMessageCount());// 获取每一封邮件:Message[] messages = folder.getMessages();for (Message message : messages) &#123;    // 打印每一封邮件:    printMessage((MimeMessage) message);&#125;\n当我们获取到一个Message对象时，可以强制转型为MimeMessage，然后打印出邮件主题、发件人、收件人等信息：\n123456789101112void printMessage(MimeMessage msg) throws IOException, MessagingException &#123;    // 邮件主题:    System.out.println(&quot;Subject: &quot; + MimeUtility.decodeText(msg.getSubject()));    // 发件人:    Address[] froms = msg.getFrom();    InternetAddress address = (InternetAddress) froms[0];    String personal = address.getPersonal();    String from = personal == null ? address.getAddress() : (MimeUtility.decodeText(personal) + &quot; &lt;&quot; + address.getAddress() + &quot;&gt;&quot;);    System.out.println(&quot;From: &quot; + from);    // 继续打印收件人:    ...&#125;\n比较麻烦的是获取邮件的正文。一个MimeMessage对象也是一个Part对象，它可能只包含一个文本，也可能是一个Multipart对象，即由几个Part构成，因此，需要递归地解析出完整的正文：\n12345678910111213141516171819String getBody(Part part) throws MessagingException, IOException &#123;    if (part.isMimeType(&quot;text/*&quot;)) &#123;        // Part是文本:        return part.getContent().toString();    &#125;    if (part.isMimeType(&quot;multipart/*&quot;)) &#123;        // Part是一个Multipart对象:        Multipart multipart = (Multipart) part.getContent();        // 循环解析每个子Part:        for (int i = 0; i &lt; multipart.getCount(); i++) &#123;            BodyPart bodyPart = multipart.getBodyPart(i);            String body = getBody(bodyPart);            if (!body.isEmpty()) &#123;                return body;            &#125;        &#125;    &#125;    return &quot;&quot;;&#125;\n最后记得关闭Folder和Store：\n12folder.close(true); // 传入true表示删除操作会同步到服务器上（即删除服务器收件箱的邮件）store.close();\n练习\n使用POP3接收邮件。\n下载练习\n小结\n使用Java接收Email时，可以用POP3协议或IMAP协议。\n使用POP3协议时，需要用Maven引入JavaMail依赖，并确定POP3服务器的域名／端口／是否使用SSL等，然后，调用相关API接收Email。\n设置debug模式可以查看通信详细内容，便于排查错误。\n什么是HTTP？HTTP就是目前使用最广泛的Web应用程序使用的基础协议，例如，浏览器访问网站，手机App访问后台服务器，都是通过HTTP协议实现的。\nHTTP是HyperText Transfer Protocol的缩写，翻译为超文本传输协议，它是基于TCP协议之上的一种请求-响应协议。\n我们来看一下浏览器请求访问某个网站时发送的HTTP请求-响应。当浏览器希望访问某个网站时，浏览器和网站服务器之间首先建立TCP连接，且服务器总是使用80端口和加密端口443，然后，浏览器向服务器发送一个HTTP请求，服务器收到后，返回一个HTTP响应，并且在响应中包含了HTML的网页内容，这样，浏览器解析HTML后就可以给用户显示网页了。一个完整的HTTP请求-响应如下：\n1234567891011121314            GET / HTTP/1.1            Host: www.sina.com.cn            User-Agent: Mozilla/5 MSIE            Accept: */*                ┌────────┐┌─────────┐ Accept-Language: zh-CN,en  │░░░░░░░░││O ░░░░░░░│───────────────────────────▶├────────┤├─────────┤◀───────────────────────────│░░░░░░░░││         │ HTTP/1.1 200 OK            ├────────┤│         │ Content-Type: text/html    │░░░░░░░░│└─────────┘ Content-Length: 133251     └────────┘  Browser   &lt;!DOCTYPE html&gt;              Server            &lt;html&gt;&lt;body&gt;            &lt;h1&gt;Hello&lt;/h1&gt;            ...\nHTTP请求的格式是固定的，它由HTTP Header和HTTP Body两部分构成。第一行总是请求方法 路径 HTTP版本，例如，GET / HTTP/1.1表示使用GET请求，路径是/，版本是HTTP/1.1。\n后续的每一行都是固定的Header: Value格式，我们称为HTTP Header，服务器依靠某些特定的Header来识别客户端请求，例如：\n\nHost：表示请求的域名，因为一台服务器上可能有多个网站，因此有必要依靠Host来识别请求是发给哪个网站的；\nUser-Agent：表示客户端自身标识信息，不同的浏览器有不同的标识，服务器依靠User-Agent判断客户端类型是IE还是Chrome，是Firefox还是一个Python爬虫；\nAccept：表示客户端能处理的HTTP响应格式，*/*表示任意格式，text/*表示任意文本，image/png表示PNG格式的图片；\nAccept-Language：表示客户端接收的语言，多种语言按优先级排序，服务器依靠该字段给用户返回特定语言的网页版本。\n\n如果是GET请求，那么该HTTP请求只有HTTP Header，没有HTTP Body。如果是POST请求，那么该HTTP请求带有Body，以一个空行分隔。一个典型的带Body的HTTP请求如下：\n123456POST /login HTTP/1.1Host: www.example.comContent-Type: application/x-www-form-urlencodedContent-Length: 30username=hello&amp;password=123456\nPOST请求通常要设置Content-Type表示Body的类型，Content-Length表示Body的长度，这样服务器就可以根据请求的Header和Body做出正确的响应。\n此外，GET请求的参数必须附加在URL上，并以URLEncode方式编码，例如：http://www.example.com/?a=1&amp;b=K%26R，参数分别是a=1和b=K&amp;R。因为URL的长度限制，GET请求的参数不能太多，而POST请求的参数就没有长度限制，因为POST请求的参数必须放到Body中。并且，POST请求的参数不一定是URL编码，可以按任意格式编码，只需要在Content-Type中正确设置即可。常见的发送JSON的POST请求如下：\n12345POST /login HTTP/1.1Content-Type: application/jsonContent-Length: 38&#123;&quot;username&quot;:&quot;bob&quot;,&quot;password&quot;:&quot;123456&quot;&#125;\nHTTP响应也是由Header和Body两部分组成，一个典型的HTTP响应如下：\n12345678HTTP/1.1 200 OKContent-Type: text/htmlContent-Length: 133251&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\n响应的第一行总是HTTP版本 响应代码 响应说明，例如，HTTP/1.1 200 OK表示版本是HTTP/1.1，响应代码是200，响应说明是OK。客户端只依赖响应代码判断HTTP响应是否成功。HTTP有固定的响应代码：\n\n1xx：表示一个提示性响应，例如101表示将切换协议，常见于WebSocket连接；\n2xx：表示一个成功的响应，例如200表示成功，206表示只发送了部分内容；\n3xx：表示一个重定向的响应，例如301表示永久重定向，303表示客户端应该按指定路径重新发送请求；\n4xx：表示一个因为客户端问题导致的错误响应，例如400表示因为Content-Type等各种原因导致的无效请求，404表示指定的路径不存在；\n5xx：表示一个因为服务器问题导致的错误响应，例如500表示服务器内部故障，503表示服务器暂时无法响应。\n\n当浏览器收到第一个HTTP响应后，它解析HTML后，又会发送一系列HTTP请求，例如，GET /logo.jpg HTTP/1.1请求一个图片，服务器响应图片请求后，会直接把二进制内容的图片发送给浏览器：\n12345HTTP/1.1 200 OKContent-Type: image/jpegContent-Length: 18391????JFIFHH??XExifMM?i&amp;??X?...(二进制的JPEG图片)\n因此，服务器总是被动地接收客户端的一个HTTP请求，然后响应它。客户端则根据需要发送若干个HTTP请求。\n对于最早期的HTTP/1.0协议，每次发送一个HTTP请求，客户端都需要先创建一个新的TCP连接，然后，收到服务器响应后，关闭这个TCP连接。由于建立TCP连接就比较耗时，因此，为了提高效率，HTTP/1.1协议允许在一个TCP连接中反复发送-响应，这样就能大大提高效率：\n1234567891011121314151617181920                       ┌─────────┐┌─────────┐            │░░░░░░░░░││O ░░░░░░░│            ├─────────┤├─────────┤            │░░░░░░░░░││         │            ├─────────┤│         │            │░░░░░░░░░│└─────────┘            └─────────┘     │      request 1       │     │─────────────────────▶│     │      response 1      │     │◀─────────────────────│     │      request 2       │     │─────────────────────▶│     │      response 2      │     │◀─────────────────────│     │      request 3       │     │─────────────────────▶│     │      response 3      │     │◀─────────────────────│     ▼                      ▼\n因为HTTP协议是一个请求-响应协议，客户端在发送了一个HTTP请求后，必须等待服务器响应后，才能发送下一个请求，这样一来，如果某个响应太慢，它就会堵住后面的请求。\n所以，为了进一步提速，HTTP/2.0允许客户端在没有收到响应的时候，发送多个HTTP请求，服务器返回响应的时候，不一定按顺序返回，只要双方能识别出哪个响应对应哪个请求，就可以做到并行发送和接收：\n1234567891011121314151617181920                       ┌─────────┐┌─────────┐            │░░░░░░░░░││O ░░░░░░░│            ├─────────┤├─────────┤            │░░░░░░░░░││         │            ├─────────┤│         │            │░░░░░░░░░│└─────────┘            └─────────┘     │      request 1       │     │─────────────────────▶│     │      request 2       │     │─────────────────────▶│     │      response 1      │     │◀─────────────────────│     │      request 3       │     │─────────────────────▶│     │      response 3      │     │◀─────────────────────│     │      response 2      │     │◀─────────────────────│     ▼                      ▼\n可见，HTTP/2.0进一步提高了效率。\nHTTP编程\n既然HTTP涉及到客户端和服务器端，和TCP类似，我们也需要针对客户端编程和针对服务器端编程。\n本节我们不讨论服务器端的HTTP编程，因为服务器端的HTTP编程本质上就是编写Web服务器，这是一个非常复杂的体系，也是JavaEE开发的核心内容，我们在后面的章节再仔细研究。\n本节我们只讨论作为客户端的HTTP编程。\n因为浏览器也是一种HTTP客户端，所以，客户端的HTTP编程，它的行为本质上和浏览器是一样的，即发送一个HTTP请求，接收服务器响应后，获得响应内容。只不过浏览器进一步把响应内容解析后渲染并展示给了用户，而我们使用Java进行HTTP客户端编程仅限于获得响应内容。\n我们来看一下Java如何使用HTTP客户端编程。\nJava标准库提供了基于HTTP的包，但是要注意，早期的JDK版本是通过HttpURLConnection访问HTTP，典型代码如下：\n12345678910111213141516171819202122URL url = new URL(&quot;http://www.example.com/path/to/target?a=1&amp;b=2&quot;);HttpURLConnection conn = (HttpURLConnection) url.openConnection();conn.setRequestMethod(&quot;GET&quot;);conn.setUseCaches(false);conn.setConnectTimeout(5000); // 请求超时5秒// 设置HTTP头:conn.setRequestProperty(&quot;Accept&quot;, &quot;*/*&quot;);conn.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (compatible; MSIE 11; Windows NT 5.1)&quot;);// 连接并发送HTTP请求:conn.connect();// 判断HTTP响应是否200:if (conn.getResponseCode() != 200) &#123;    throw new RuntimeException(&quot;bad response&quot;);&#125;\t\t// 获取所有响应Header:Map&lt;String, List&lt;String&gt;&gt; map = conn.getHeaderFields();for (String key : map.keySet()) &#123;    System.out.println(key + &quot;: &quot; + map.get(key));&#125;// 获取响应内容:InputStream input = conn.getInputStream();...\n上述代码编写比较繁琐，并且需要手动处理InputStream，所以用起来很麻烦。\n从Java 11开始，引入了新的HttpClient，它使用链式调用的API，能大大简化HTTP的处理。\n我们来看一下如何使用新版的HttpClient。首先需要创建一个全局HttpClient实例，因为HttpClient内部使用线程池优化多个HTTP连接，可以复用：\n1static HttpClient httpClient = HttpClient.newBuilder().build();\n使用GET请求获取文本内容代码如下：\n12345678910111213141516171819202122232425262728import java.net.URI;import java.net.http.*;import java.net.http.HttpClient.Version;import java.time.Duration;import java.util.*;public class Main &#123;    // 全局HttpClient:    static HttpClient httpClient = HttpClient.newBuilder().build();    public static void main(String[] args) throws Exception &#123;        String url = &quot;https://www.sina.com.cn/&quot;;        HttpRequest request = HttpRequest.newBuilder(new URI(url))            // 设置Header:            .header(&quot;User-Agent&quot;, &quot;Java HttpClient&quot;).header(&quot;Accept&quot;, &quot;*/*&quot;)            // 设置超时:            .timeout(Duration.ofSeconds(5))            // 设置版本:            .version(Version.HTTP_2).build();        HttpResponse&lt;String&gt; response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());        // HTTP允许重复的Header，因此一个Header可对应多个Value:        Map&lt;String, List&lt;String&gt;&gt; headers = response.headers().map();        for (String header : headers.keySet()) &#123;            System.out.println(header + &quot;: &quot; + headers.get(header).get(0));        &#125;        System.out.println(response.body().substring(0, 1024) + &quot;...&quot;);    &#125;&#125;\n如果我们要获取图片这样的二进制内容，只需要把HttpResponse.BodyHandlers.ofString()换成HttpResponse.BodyHandlers.ofByteArray()，就可以获得一个HttpResponse&lt;byte[]&gt;对象。如果响应的内容很大，不希望一次性全部加载到内存，可以使用HttpResponse.BodyHandlers.ofInputStream()获取一个InputStream流。\n要使用POST请求，我们要准备好发送的Body数据并正确设置Content-Type：\n1234567891011121314String url = &quot;http://www.example.com/login&quot;;String body = &quot;username=bob&amp;password=123456&quot;;HttpRequest request = HttpRequest.newBuilder(new URI(url))    // 设置Header:    .header(&quot;Accept&quot;, &quot;*/*&quot;)    .header(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)    // 设置超时:    .timeout(Duration.ofSeconds(5))    // 设置版本:    .version(Version.HTTP_2)    // 使用POST并设置Body:    .POST(BodyPublishers.ofString(body, StandardCharsets.UTF_8)).build();HttpResponse&lt;String&gt; response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());String s = response.body();\n可见发送POST数据也十分简单。\n练习\n使用HttpClient。\n下载练习\n小结\nJava提供了HttpClient作为新的HTTP客户端编程接口用于取代老的HttpURLConnection接口；\nHttpClient使用链式调用并通过内置的BodyPublishers和BodyHandlers来更方便地处理数据。\nJava的RMI远程调用是指，一个JVM中的代码可以通过网络实现远程调用另一个JVM的某个方法。RMI是Remote Method Invocation的缩写。\n提供服务的一方我们称之为服务器，而实现远程调用的一方我们称之为客户端。\n我们先来实现一个最简单的RMI：服务器会提供一个WorldClock服务，允许客户端获取指定时区的时间，即允许客户端调用下面的方法：\n1LocalDateTime getLocalDateTime(String zoneId);\n要实现RMI，服务器和客户端必须共享同一个接口。我们定义一个WorldClock接口，代码如下：\n123public interface WorldClock extends Remote &#123;    LocalDateTime getLocalDateTime(String zoneId) throws RemoteException;&#125;\nJava的RMI规定此接口必须派生自java.rmi.Remote，并在每个方法声明抛出RemoteException。\n下一步是编写服务器的实现类，因为客户端请求的调用方法getLocalDateTime()最终会通过这个实现类返回结果。实现类WorldClockService代码如下：\n123456public class WorldClockService implements WorldClock &#123;    @Override    public LocalDateTime getLocalDateTime(String zoneId) throws RemoteException &#123;        return LocalDateTime.now(ZoneId.of(zoneId)).withNano(0);    &#125;&#125;\n现在，服务器端的服务相关代码就编写完毕。我们需要通过Java RMI提供的一系列底层支持接口，把上面编写的服务以RMI的形式暴露在网络上，客户端才能调用：\n12345678910111213public class Server &#123;    public static void main(String[] args) throws RemoteException &#123;        System.out.println(&quot;create World clock remote service...&quot;);        // 实例化一个WorldClock:        WorldClock worldClock = new WorldClockService();        // 将此服务转换为远程服务接口:        WorldClock skeleton = (WorldClock) UnicastRemoteObject.exportObject(worldClock, 0);        // 将RMI服务注册到1099端口:        Registry registry = LocateRegistry.createRegistry(1099);        // 注册此服务，服务名为&quot;WorldClock&quot;:        registry.rebind(&quot;WorldClock&quot;, skeleton);    &#125;&#125;\n上述代码主要目的是通过RMI提供的相关类，将我们自己的WorldClock实例注册到RMI服务上。RMI的默认端口是1099，最后一步注册服务时通过rebind()指定服务名称为&quot;WorldClock&quot;。\n下一步我们就可以编写客户端代码。RMI要求服务器和客户端共享同一个接口，因此我们要把WorldClock.java这个接口文件复制到客户端，然后在客户端实现RMI调用：\n123456789101112public class Client &#123;    public static void main(String[] args) throws RemoteException, NotBoundException &#123;        // 连接到服务器localhost，端口1099:        Registry registry = LocateRegistry.getRegistry(&quot;localhost&quot;, 1099);        // 查找名称为&quot;WorldClock&quot;的服务并强制转型为WorldClock接口:        WorldClock worldClock = (WorldClock) registry.lookup(&quot;WorldClock&quot;);        // 正常调用接口方法:        LocalDateTime now = worldClock.getLocalDateTime(&quot;Asia/Shanghai&quot;);        // 打印调用结果:        System.out.println(now);    &#125;&#125;\n先运行服务器，再运行客户端。从运行结果可知，因为客户端只有接口，并没有实现类，因此，客户端获得的接口方法返回值实际上是通过网络从服务器端获取的。整个过程实际上非常简单，对客户端来说，客户端持有的WorldClock接口实际上对应了一个“实现类”，它是由Registry内部动态生成的，并负责把方法调用通过网络传递到服务器端。而服务器端接收网络调用的服务并不是我们自己编写的WorldClockService，而是Registry自动生成的代码。我们把客户端的“实现类”称为stub，而服务器端的网络服务类称为skeleton，它会真正调用服务器端的WorldClockService，获取结果，然后把结果通过网络传递给客户端。整个过程由RMI底层负责实现序列化和反序列化：\n1234567891011┌ ─ ─ ─ ─ ─ ─ ─ ─ ┐         ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐  ┌─────────────┐                                  ┌────────────┐│ │   Service   │ │         │                      │  Service   │ │  └─────────────┘                                  └────────────┘│        ▲        │         │                            ▲        │         │                                               ││        │        │         │                            │        │  ┌─────────────┐   Network    ┌───────────────┐   ┌────────────┐│ │ Client Stub ├─┼─────────┼─▶│Server Skeleton│──▶│Service Impl│ │  └─────────────┘              └───────────────┘   └────────────┘└ ─ ─ ─ ─ ─ ─ ─ ─ ┘         └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘\nJava的RMI严重依赖序列化和反序列化，而这种情况下可能会造成严重的安全漏洞，因为Java的序列化和反序列化不但涉及到数据，还涉及到二进制的字节码，即使使用白名单机制也很难保证100%排除恶意构造的字节码。因此，使用RMI时，双方必须是内网互相信任的机器，不要把1099端口暴露在公网上作为对外服务。\n此外，Java的RMI调用机制决定了双方必须是Java程序，其他语言很难调用Java的RMI。如果要使用不同语言进行RPC调用，可以选择更通用的协议，例如gRPC。\n练习\n使用RMI实现远程调用。\n下载练习\n小结\nJava提供了RMI实现远程方法调用：\nRMI通过自动生成stub和skeleton实现网络调用，客户端只需要查找服务并获得接口实例，服务器端只需要编写实现类并注册为服务；\nRMI的序列化和反序列化可能会造成安全漏洞，因此调用双方必须是内网互相信任的机器，不要把1099端口暴露在公网上作为对外服务。\n","dateCreated":"2025-05-24T17:16:36+08:00","dateModified":"2025-05-24T17:23:07+08:00","datePublished":"2025-05-24T17:16:36+08:00","description":"","headline":"JAVA-网络编程","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://chankein.github.io/2025/05/24/java/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},"publisher":{"@type":"Organization","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg","logo":{"@type":"ImageObject","url":"profile.jpg"}},"url":"https://chankein.github.io/2025/05/24/java/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","keywords":"Java"}</script>
    <meta name="description" content="在学习Java网络编程之前，我们先来了解什么是计算机网络。 计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。 那什么是互联网呢？互联网是网络的网络（Internet），即把很多计算机网络连接起来，形成一个全球统一的互联网。 对某个特定的计算机网络来说，它可能使用网络协议ABC，而另一个计算机网络可能使用网络协议XYZ">
<meta property="og:type" content="blog">
<meta property="og:title" content="JAVA-网络编程">
<meta property="og:url" content="https://chankein.github.io/2025/05/24/java/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:description" content="在学习Java网络编程之前，我们先来了解什么是计算机网络。 计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。 那什么是互联网呢？互联网是网络的网络（Internet），即把很多计算机网络连接起来，形成一个全球统一的互联网。 对某个特定的计算机网络来说，它可能使用网络协议ABC，而另一个计算机网络可能使用网络协议XYZ">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/network/basic/network-config.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/network/send-email/mail-text.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/network/send-email/mail-html.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/network/send-email/mail-attachment.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/network/send-email/mail-image.png">
<meta property="article:published_time" content="2025-05-24T09:16:36.000Z">
<meta property="article:modified_time" content="2025-05-24T09:23:07.247Z">
<meta property="article:author" content="Kein Chan">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liaoxuefeng.com/books/java/network/basic/network-config.png">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../../../#about"
            >
        
        
            <img class="header-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            JAVA-网络编程
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2025-05-24T17:16:36+08:00">
	
		    2025 年 5 月 24 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/">Java</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>在学习Java网络编程之前，我们先来了解什么是计算机网络。</p>
<p>计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。</p>
<p>那什么是互联网呢？互联网是网络的网络（Internet），即把很多计算机网络连接起来，形成一个全球统一的互联网。</p>
<p>对某个特定的计算机网络来说，它可能使用网络协议ABC，而另一个计算机网络可能使用网络协议XYZ。如果计算机网络各自的通讯协议不统一，就没法把不同的网络连接起来形成互联网。因此，为了把计算机网络接入互联网，就必须使用TCP/IP协议。</p>
<p>TCP/IP协议泛指互联网协议，其中最重要的两个协议是TCP协议和IP协议。只有使用TCP/IP协议的计算机才能够联入互联网，使用其他网络协议（例如NetBIOS、AppleTalk协议等）是无法联入互联网的。</p>
<h3 id="IP地址">IP地址</h3>
<p>在互联网中，一个IP地址用于唯一标识一个网络接口（Network Interface）。一台联入互联网的计算机肯定有一个IP地址，但也可能有多个IP地址。</p>
<p>IP地址分为IPv4和IPv6两种。IPv4采用32位地址，类似<code>101.202.99.12</code>，而IPv6采用128位地址，类似<code>2001:0DA8:100A:0000:0000:1020:F2F3:1428</code>。IPv4地址总共有232个（大约42亿），而IPv6地址则总共有2128个（大约340万亿亿亿亿），IPv4的地址目前已耗尽，而IPv6的地址是根本用不完的。</p>
<p>IP地址又分为公网IP地址和内网IP地址。公网IP地址可以直接被访问，内网IP地址只能在内网访问。内网IP地址类似于：</p>
<ul>
<li>192.168.x.x</li>
<li>10.x.x.x</li>
</ul>
<p>有一个特殊的IP地址，称之为本机地址，它总是<code>127.0.0.1</code>。</p>
<p>IPv4地址实际上是一个32位整数。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1707762444 = 0x65ca630c</span><br><span class="line">           = 65  ca  63 0c</span><br><span class="line">           = 101.202.99.12</span><br></pre></td></tr></table></figure>
<p>如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址<code>127.0.0.1</code>，还有一个IP地址，例如<code>101.202.99.12</code>，可以通过这个IP地址接入网络。</p>
<p>如果一台计算机有两块网卡，那么除了本机地址，它可以有两个IP地址，可以分别接入两个网络。通常连接两个网络的设备是路由器或者交换机，它至少有两个IP地址，分别接入不同的网络，让网络之间连接起来。</p>
<p>如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的IP地址前段是相同的，也就是网络号是相同的。网络号是IP地址通过子网掩码过滤后得到的。例如：</p>
<p>某台计算机的IP是<code>101.202.99.2</code>，子网掩码是<code>255.255.255.0</code>，那么计算该计算机的网络号是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP = 101.202.99.2</span><br><span class="line">Mask = 255.255.255.0</span><br><span class="line">Network = IP &amp; Mask = 101.202.99.0</span><br></pre></td></tr></table></figure>
<p>每台计算机都需要正确配置IP地址和子网掩码，根据这两个就可以计算网络号，如果两台计算机计算出的网络号相同，说明两台计算机在同一个网络，可以直接通信。如果两台计算机计算出的网络号不同，那么两台计算机不在同一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备间接通信，我们把这种设备称为网关。</p>
<p>网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫路由。</p>
<p>所以，一台计算机的一个网卡会有3个关键配置：</p>
<p><img src="https://liaoxuefeng.com/books/java/network/basic/network-config.png" alt="network"></p>
<ul>
<li>IP地址，例如：<code>10.0.2.15</code></li>
<li>子网掩码，例如：<code>255.255.255.0</code></li>
<li>网关的IP地址，例如：<code>10.0.2.2</code></li>
</ul>
<h3 id="域名">域名</h3>
<p>因为直接记忆IP地址非常困难，所以我们通常使用域名访问某个特定的服务。域名解析服务器DNS负责把域名翻译成对应的IP，客户端再根据IP地址访问服务器。</p>
<p>用<code>nslookup</code>可以查看域名对应的IP地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup liaoxuefeng.com</span><br><span class="line">Server:  xxx.xxx.xxx.xxx</span><br><span class="line">Address: xxx.xxx.xxx.xxx#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:    liaoxuefeng.com</span><br><span class="line">Address: xxx.xxx.xxx.xxx</span><br></pre></td></tr></table></figure>
<p>有一个特殊的本机域名<code>localhost</code>，它对应的IP地址总是本机地址<code>127.0.0.1</code>。</p>
<h3 id="网络模型">网络模型</h3>
<p>由于计算机网络从底层的传输到高层的软件设计十分复杂，要合理地设计计算机网络模型，必须采用分层模型，每一层负责处理自己的操作。OSI（Open System Interconnect）网络模型是ISO组织定义的一个计算机互联的标准模型，注意它只是一个定义，目的是为了简化网络各层的操作，提供标准接口便于实现和维护。这个模型从上到下依次是：</p>
<ul>
<li>应用层，提供应用程序之间的通信；</li>
<li>表示层：处理数据格式，加解密等等；</li>
<li>会话层：负责建立和维护会话；</li>
<li>传输层：负责提供端到端的可靠传输；</li>
<li>网络层：负责根据目标地址选择路由来传输数据；</li>
<li>链路层和物理层负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等。</li>
</ul>
<p>互联网实际使用的TCP/IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型：</p>
<table>
<thead>
<tr>
<th>OSI</th>
<th>TCP/IP</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>应用层</td>
</tr>
<tr>
<td>表示层</td>
<td></td>
</tr>
<tr>
<td>会话层</td>
<td></td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
<td>IP层</td>
</tr>
<tr>
<td>链路层</td>
<td>网络接口层</td>
</tr>
<tr>
<td>物理层</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="常用协议">常用协议</h3>
<p>IP协议是一个分组交换，它不保证可靠传输。而TCP协议是传输控制协议，它是面向连接的协议，支持可靠传输和双向通信。TCP协议是建立在IP协议之上的，简单地说，IP协议只负责发数据包，不保证顺序和正确性，而TCP协议负责控制数据包传输，它在传输数据之前需要先建立连接，建立连接后才能传输数据，传输完后还需要断开连接。TCP协议之所以能保证数据的可靠传输，是通过接收确认、超时重传这些机制实现的。并且，TCP协议允许双向通信，即通信双方可以同时发送和接收数据。</p>
<p>TCP协议也是应用最广泛的协议，许多高级协议都是建立在TCP协议之上的，例如HTTP、SMTP等。</p>
<p>UDP协议（User Datagram Protocol）是一种数据报文协议，它是无连接协议，不保证可靠传输。因为UDP协议在通信前不需要建立连接，因此它的传输效率比TCP高，而且UDP协议比TCP协议要简单得多。</p>
<p>选择UDP协议时，传输的数据通常是能容忍丢失的，例如，一些语音视频通信的应用会选择UDP协议。</p>
<h3 id="小结">小结</h3>
<p>计算机网络的基本概念主要有：</p>
<ul>
<li>计算机网络：由两台或更多计算机组成的网络；</li>
<li>互联网：连接网络的网络；</li>
<li>IP地址：计算机的网络接口（通常是网卡）在网络中的唯一标识；</li>
<li>网关：负责连接多个网络，并在多个网络之间转发数据的计算机，通常是路由器或交换机；</li>
<li>网络协议：互联网使用TCP/IP协议，它泛指互联网协议簇；</li>
<li>IP协议：一种分组交换传输协议；</li>
<li>TCP协议：一种面向连接，可靠传输的协议；</li>
<li>UDP协议：一种无连接，不可靠传输的协议。</li>
</ul>
<p>在开发网络应用程序的时候，我们又会遇到Socket这个概念。Socket是一个抽象概念，一个应用程序通过一个Socket来建立一个远程连接，而Socket内部通过TCP/IP协议把数据传输到网络：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌───────────┐                                ┌───────────┐</span><br><span class="line">│Application│                                │Application│</span><br><span class="line">├───────────┤                                ├───────────┤</span><br><span class="line">│  Socket   │                                │  Socket   │</span><br><span class="line">├───────────┤                                ├───────────┤</span><br><span class="line">│    TCP    │                                │    TCP    │</span><br><span class="line">├───────────┤     ┌──────┐      ┌──────┐     ├───────────┤</span><br><span class="line">│    IP     │◀───▶│Router│◀────▶│Router│◀───▶│    IP     │</span><br><span class="line">└───────────┘     └──────┘      └──────┘     └───────────┘</span><br></pre></td></tr></table></figure>
<p>Socket、TCP和部分IP的功能都是由操作系统提供的，不同的编程语言只是提供了对操作系统调用的简单的封装。例如，Java提供的几个Socket相关的类就封装了操作系统提供的接口。</p>
<p>为什么需要Socket进行网络通信？因为仅仅通过IP地址进行通信是不够的，同一台计算机同一时间会运行多个网络应用程序，例如浏览器、QQ、邮件客户端等。当操作系统接收到一个数据包的时候，如果只有IP地址，它没法判断应该发给哪个应用程序，所以，操作系统抽象出Socket接口，每个应用程序需要各自对应到不同的Socket，数据包才能根据Socket正确地发到对应的应用程序。</p>
<p>一个Socket就是由IP地址和端口号（范围是0～65535）组成，可以把Socket简单理解为IP地址加端口号。端口号总是由操作系统分配，它是一个0～65535之间的数字，其中，小于1024的端口属于<em>特权端口</em>，需要管理员权限，大于1024的端口可以由任意用户的应用程序打开。</p>
<ul>
<li>Browser: 101.202.99.2:1201</li>
<li>QQ: 101.202.99.2:1304</li>
<li>Email: 101.202.99.2:15000</li>
</ul>
<p>使用Socket进行网络编程时，本质上就是两个进程之间的网络通信。其中一个进程必须充当服务器端，它会主动监听某个指定的端口，另一个进程必须充当客户端，它必须主动连接服务器的IP地址和指定端口，如果连接成功，服务器端和客户端就成功地建立了一个TCP连接，双方后续就可以随时发送和接收数据。</p>
<p>因此，当Socket连接成功地在服务器端和客户端之间建立后：</p>
<ul>
<li>对服务器端来说，它的Socket是指定的IP地址和指定的端口号；</li>
<li>对客户端来说，它的Socket是它所在计算机的IP地址和一个由操作系统分配的随机端口号。</li>
</ul>
<h3 id="服务器端">服务器端</h3>
<p>要使用Socket编程，我们首先要编写服务器端程序。Java标准库提供了<code>ServerSocket</code>来实现对指定IP和指定端口的监听。<code>ServerSocket</code>的典型实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>); <span class="comment">// 监听指定端口</span></span><br><span class="line">        System.out.println(<span class="string">&quot;server is running...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;connected from &quot;</span> + sock.getRemoteSocketAddress());</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(sock);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Socket sock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(Socket sock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sock = sock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="built_in">this</span>.sock.getInputStream()) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="built_in">this</span>.sock.getOutputStream()) &#123;</span><br><span class="line">                handle(input, output);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.sock.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;client disconnected.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(InputStream input, OutputStream output)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(output, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="type">var</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(input, StandardCharsets.UTF_8));</span><br><span class="line">        writer.write(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;bye&quot;</span>)) &#123;</span><br><span class="line">                writer.write(<span class="string">&quot;bye\n&quot;</span>);</span><br><span class="line">                writer.flush();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            writer.write(<span class="string">&quot;ok: &quot;</span> + s + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器端通过代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure>
<p>在指定端口<code>6666</code>监听。这里我们没有指定IP地址，表示在计算机的所有网络接口上进行监听。</p>
<p>如果<code>ServerSocket</code>监听成功，我们就使用一个无限循环来处理客户端的连接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(sock);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到代码<code>ss.accept()</code>表示每当有新的客户端连接进来后，就返回一个<code>Socket</code>实例，这个<code>Socket</code>实例就是用来和刚连接的客户端进行通信的。由于客户端很多，要实现并发处理，我们就必须为每个新的<code>Socket</code>创建一个新线程来处理，这样，主线程的作用就是接收新的连接，每当收到新连接后，就创建一个新线程进行处理。</p>
<p>我们在多线程编程的章节中介绍过线程池，这里也完全可以利用线程池来处理客户端连接，能大大提高运行效率。</p>
<p>如果没有客户端连接进来，<code>accept()</code>方法会阻塞并一直等待。如果有多个客户端同时连接进来，<code>ServerSocket</code>会把连接扔到队列里，然后一个一个处理。对于Java程序而言，只需要通过循环不断调用<code>accept()</code>就可以获取新的连接。</p>
<h3 id="客户端">客户端</h3>
<p>相比服务器端，客户端程序就要简单很多。一个典型的客户端程序如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>); <span class="comment">// 连接指定服务器和端口</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> sock.getInputStream()) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> sock.getOutputStream()) &#123;</span><br><span class="line">                handle(input, output);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sock.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;disconnected.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(InputStream input, OutputStream output)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(output, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="type">var</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(input, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;[server] &quot;</span> + reader.readLine());</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine(); <span class="comment">// 读取一行输入</span></span><br><span class="line">            writer.write(s);</span><br><span class="line">            writer.newLine();</span><br><span class="line">            writer.flush();</span><br><span class="line">            <span class="type">String</span> <span class="variable">resp</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;&lt;&lt;&lt; &quot;</span> + resp);</span><br><span class="line">            <span class="keyword">if</span> (resp.equals(<span class="string">&quot;bye&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端程序通过：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br></pre></td></tr></table></figure>
<p>连接到服务器端，注意上述代码的服务器地址是<code>&quot;localhost&quot;</code>，表示本机地址，端口号是<code>6666</code>。如果连接成功，将返回一个<code>Socket</code>实例，用于后续通信。</p>
<h3 id="Socket流">Socket流</h3>
<p>当Socket连接创建成功后，无论是服务器端，还是客户端，我们都使用<code>Socket</code>实例进行网络通信。因为TCP是一种基于流的协议，因此，Java标准库使用<code>InputStream</code>和<code>OutputStream</code>来封装Socket的数据流，这样我们使用Socket的流，和普通IO流类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于读取网络数据:</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> sock.getInputStream();</span><br><span class="line"><span class="comment">// 用于写入网络数据:</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> sock.getOutputStream();</span><br></pre></td></tr></table></figure>
<p>最后我们重点来看看，为什么写入网络数据时，要调用<code>flush()</code>方法。</p>
<p>如果不调用<code>flush()</code>，我们很可能会发现，客户端和服务器都收不到数据，这并不是Java标准库的设计问题，而是我们以流的形式写入数据的时候，并不是一写入就立刻发送到网络，而是先写入内存缓冲区，直到缓冲区满了以后，才会一次性真正发送到网络，这样设计的目的是为了提高传输效率。如果缓冲区的数据很少，而我们又想强制把这些数据发送到网络，就必须调用<code>flush()</code>强制把缓冲区数据发送出去。</p>
<h3 id="练习">练习</h3>
<p>使用Socket实现服务器和客户端通信。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/network/tcp/network-socket.zip">下载练习</a></p>
<h3 id="小结-2">小结</h3>
<p>使用Java进行TCP编程时，需要使用Socket模型：</p>
<ul>
<li>服务器端用<code>ServerSocket</code>监听指定端口；</li>
<li>客户端使用<code>Socket(InetAddress, port)</code>连接服务器；</li>
<li>服务器端用<code>accept()</code>接收连接并返回<code>Socket</code>；</li>
<li>双方通过<code>Socket</code>打开<code>InputStream</code>/<code>OutputStream</code>读写数据；</li>
<li>服务器端通常使用多线程同时处理多个客户端连接，利用线程池可大幅提升效率；</li>
<li><code>flush()</code>用于强制输出缓冲区到网络。</li>
</ul>
<p>和TCP编程相比，UDP编程就简单得多，因为UDP没有创建连接，数据包也是一次收发一个，所以没有流的概念。</p>
<p>在Java中使用UDP编程，仍然需要使用Socket，因为应用程序在使用UDP时必须指定网络接口（IP）和端口号。注意：UDP端口和TCP端口虽然都使用0~65535，但他们是两套独立的端口，即一个应用程序用TCP占用了端口1234，不影响另一个应用程序用UDP占用端口1234。</p>
<h3 id="服务器端-2">服务器端</h3>
<p>在服务器端，使用UDP也需要监听指定的端口。Java提供了<code>DatagramSocket</code>来实现这个功能，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">6666</span>); <span class="comment">// 监听指定端口</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">    <span class="comment">// 数据缓冲区:</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line">    ds.receive(packet); <span class="comment">// 收取一个UDP数据包</span></span><br><span class="line">    <span class="comment">// 收取到的数据存储在buffer中，由packet.getOffset(), packet.getLength()指定起始位置和长度</span></span><br><span class="line">    <span class="comment">// 将其按UTF-8编码转换为String:</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8);</span><br><span class="line">    <span class="comment">// 发送数据:</span></span><br><span class="line">    <span class="type">byte</span>[] data = <span class="string">&quot;ACK&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    packet.setData(data);</span><br><span class="line">    ds.send(packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器端首先使用如下语句在指定的端口监听UDP数据包：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure>
<p>如果没有其他应用程序占据这个端口，那么监听成功，我们就使用一个无限循环来处理收到的UDP数据包：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要接收一个UDP数据包，需要准备一个<code>byte[]</code>缓冲区，并通过<code>DatagramPacket</code>实现接收：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line">ds.receive(packet);</span><br></pre></td></tr></table></figure>
<p>假设我们收取到的是一个<code>String</code>，那么，通过<code>DatagramPacket</code>返回的<code>packet.getOffset()</code>和<code>packet.getLength()</code>确定数据在缓冲区的起止位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>
<p>当服务器收到一个DatagramPacket后，通常必须立刻回复一个或多个UDP包，因为客户端地址在DatagramPacket中，每次收到的DatagramPacket可能是不同的客户端，如果不回复，客户端就收不到任何UDP包。</p>
<p>发送UDP包也是通过<code>DatagramPacket</code>实现的，发送代码非常简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] data = ...</span><br><span class="line">packet.setData(data);</span><br><span class="line">ds.send(packet);</span><br></pre></td></tr></table></figure>
<h3 id="客户端-2">客户端</h3>
<p>和服务器端相比，客户端使用UDP时，只需要直接向服务器端发送UDP包，然后接收返回的UDP包：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">ds.setSoTimeout(<span class="number">1000</span>);</span><br><span class="line">ds.connect(InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">6666</span>); <span class="comment">// 连接指定服务器和端口</span></span><br><span class="line"><span class="comment">// 发送:</span></span><br><span class="line"><span class="type">byte</span>[] data = <span class="string">&quot;Hello&quot;</span>.getBytes();</span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data, data.length);</span><br><span class="line">ds.send(packet);</span><br><span class="line"><span class="comment">// 接收:</span></span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">packet = <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line">ds.receive(packet);</span><br><span class="line"><span class="type">String</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), packet.getOffset(), packet.getLength());</span><br><span class="line">ds.disconnect();</span><br><span class="line"><span class="comment">// 关闭:</span></span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure>
<p>客户端打开一个<code>DatagramSocket</code>使用以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">ds.setSoTimeout(<span class="number">1000</span>);</span><br><span class="line">ds.connect(InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">6666</span>);</span><br></pre></td></tr></table></figure>
<p>客户端创建<code>DatagramSocket</code>实例时并不需要指定端口，而是由操作系统自动指定一个当前未使用的端口。紧接着，调用<code>setSoTimeout(1000)</code>设定超时1秒，意思是后续接收UDP包时，等待时间最多不会超过1秒，否则在没有收到UDP包时，客户端会无限等待下去。这一点和服务器端不一样，服务器端可以无限等待，因为它本来就被设计成长时间运行。</p>
<p>注意到客户端的<code>DatagramSocket</code>还调用了一个<code>connect()</code>方法“连接”到指定的服务器端。不是说UDP是无连接的协议吗？为啥这里需要<code>connect()</code>？</p>
<p>这个<code>connect()</code>方法不是真连接，它是为了在客户端的<code>DatagramSocket</code>实例中保存服务器端的IP和端口号，确保这个<code>DatagramSocket</code>实例只能往指定的地址和端口发送UDP包，不能往其他地址和端口发送。这么做不是UDP的限制，而是Java内置了安全检查。</p>
<p>后续的收发数据和服务器端是一致的。通常来说，客户端必须先发UDP包，因为客户端不发UDP包，服务器端就根本不知道客户端的地址和端口号。</p>
<p>如果客户端认为通信结束，就可以调用<code>disconnect()</code>断开连接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds.disconnect();</span><br></pre></td></tr></table></figure>
<p>注意到<code>disconnect()</code>也不是真正地断开连接，它只是清除了客户端<code>DatagramSocket</code>实例记录的远程服务器地址和端口号，这样，<code>DatagramSocket</code>实例就可以连接另一个服务器端。</p>
<p>如果客户端希望向两个不同的服务器发送UDP包，有两种方法：</p>
<ol>
<li>客户端可以创建两个<code>DatagramSocket</code>实例，用<code>connect()</code>连接到不同的服务器；</li>
<li>客户端也可以不调用<code>connect()</code>方法，而是在创建<code>DatagramPacket</code>的时候指定服务器地址，这样可以用一个<code>DatagramSocket</code>实例发送<code>DatagramPacket</code>到不同的服务器。</li>
</ol>
<p>不调用<code>connect()</code>方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">ds.setSoTimeout(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 发送到localhost:6666:</span></span><br><span class="line"><span class="type">byte</span>[] data1 = <span class="string">&quot;Hello&quot;</span>.getBytes();</span><br><span class="line"><span class="type">var</span> <span class="variable">packet1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data1, data1.length, InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">6666</span>);</span><br><span class="line">ds.send(packet1);</span><br><span class="line"><span class="comment">// 发送到localhost:8888:</span></span><br><span class="line"><span class="type">byte</span>[] data2 = <span class="string">&quot;Hi&quot;</span>.getBytes();</span><br><span class="line"><span class="type">var</span> <span class="variable">packet2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data2, data2.length, InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">8888</span>);</span><br><span class="line">ds.send(packet2);</span><br><span class="line"><span class="comment">// 关闭:</span></span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure>
<h3 id="练习-2">练习</h3>
<p>使用UDP实现服务器和客户端通信。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/network/udp/network-datagram.zip">下载练习</a></p>
<h3 id="小结-3">小结</h3>
<p>使用UDP协议通信时，服务器和客户端双方无需建立连接：</p>
<ul>
<li>服务器端用<code>DatagramSocket(port)</code>监听端口；</li>
<li>客户端使用<code>DatagramSocket.connect()</code>指定远程地址和端口；</li>
<li>双方通过<code>receive()</code>和<code>send()</code>读写数据；</li>
<li><code>DatagramSocket</code>没有IO流接口，数据被直接写入<code>byte[]</code>缓冲区。</li>
</ul>
<p>Email就是电子邮件。电子邮件的应用已经有几十年的历史了，我们熟悉的邮箱地址比如<code>abc@example.com</code>，邮件软件比如Outlook都是用来收发邮件的。</p>
<p>使用Java程序也可以收发电子邮件。我们先来看一下传统的邮件是如何发送的。</p>
<p>传统的邮件是通过邮局投递，然后从一个邮局到另一个邮局，最终到达用户的邮箱：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">           ┌──────────┐    ┌──────────┐</span><br><span class="line">           │PostOffice│    │PostOffice│     .───.</span><br><span class="line">┌─────┐    ├──────────┤    ├──────────┤    (   ( )</span><br><span class="line">│═══ ░│───▶│ ┌─┐ ┌┐┌┐ │───▶│ ┌─┐ ┌┐┌┐ │───▶ `─┬─&#x27;</span><br><span class="line">└─────┘    │ │░│ └┘└┘ │    │ │░│ └┘└┘ │       │</span><br><span class="line">           └─┴─┴──────┘    └─┴─┴──────┘       │</span><br></pre></td></tr></table></figure>
<p>电子邮件的发送过程也是类似的，只不过是电子邮件是从用户电脑的邮件软件，例如Outlook，发送到邮件服务器上，可能经过若干个邮件服务器的中转，最终到达对方邮件服务器上，收件方就可以用软件接收邮件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">             ┌─────────┐    ┌─────────┐    ┌─────────┐</span><br><span class="line">             │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│</span><br><span class="line">┌───────┐    ├─────────┤    ├─────────┤    ├─────────┤    ┌───────┐</span><br><span class="line">│░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░│</span><br><span class="line">├───────┤    ├─────────┤    ├─────────┤    ├─────────┤    ├───────┤</span><br><span class="line">│       │───▶│O ░░░░░░░│───▶│O ░░░░░░░│───▶│O ░░░░░░░│◀───│       │</span><br><span class="line">└───────┘    └─────────┘    └─────────┘    └─────────┘    └───────┘</span><br><span class="line">   MUA           MTA            MTA            MDA           MUA</span><br></pre></td></tr></table></figure>
<p>我们把类似Outlook这样的邮件软件称为MUA：Mail User Agent，意思是给用户服务的邮件代理；邮件服务器则称为MTA：Mail Transfer Agent，意思是邮件中转的代理；最终到达的邮件服务器称为MDA：Mail Delivery Agent，意思是邮件到达的代理。电子邮件一旦到达MDA，就不再动了。实际上，电子邮件通常就存储在MDA服务器的硬盘上，然后等收件人通过软件或者登陆浏览器查看邮件。</p>
<p>MTA和MDA这样的服务器软件通常是现成的，我们不关心这些服务器内部是如何运行的。要发送邮件，我们关心的是如何编写一个MUA的软件，把邮件发送到MTA上。</p>
<p>MUA到MTA发送邮件的协议就是SMTP协议，它是Simple Mail Transport Protocol的缩写，使用标准端口<code>25</code>，也可以使用加密端口<code>465</code>或<code>587</code>。</p>
<p>SMTP协议是一个建立在TCP之上的协议，任何程序发送邮件都必须遵守SMTP协议。使用Java程序发送邮件时，我们无需关心SMTP协议的底层原理，只需要使用JavaMail这个标准API就可以直接发送邮件。</p>
<h3 id="准备SMTP登录信息">准备SMTP登录信息</h3>
<p>假设我们准备使用自己的邮件地址<code>me@example.com</code>给小明发送邮件，已知小明的邮件地址是<code>xiaoming@somewhere.com</code>，发送邮件前，我们首先要确定作为MTA的邮件服务器地址和端口号。邮件服务器地址通常是<code>smtp.example.com</code>，端口号由邮件服务商确定使用25、465还是587。以下是一些常用邮件服务商的SMTP信息：</p>
<ul>
<li>QQ邮箱：SMTP服务器是<code>smtp.qq.com</code>，端口是465/587；</li>
<li>163邮箱：SMTP服务器是<code>smtp.163.com</code>，端口是465；</li>
<li>Gmail邮箱：SMTP服务器是<code>smtp.gmail.com</code>，端口是465/587。</li>
</ul>
<p>有了SMTP服务器的域名和端口号，我们还需要SMTP服务器的登录信息，通常是使用自己的邮件地址作为用户名，登录口令是用户口令或者一个独立设置的SMTP口令。</p>
<p>我们来看看如何使用JavaMail发送邮件。</p>
<p>首先，我们需要创建一个Maven工程，并把JavaMail相关的两个依赖加入进来：</p>
<ul>
<li>jakarta.mail:javax.mail-api:2.0.1</li>
<li>com.sun.mail:jakarta.mail:2.0.1</li>
</ul>
<p>这两个包一个是接口定义，一个是具体实现。如果使用早期的1.x版本，则需注意引入的包名有所不同：</p>
<ul>
<li>javax.mail:javax.mail-api:1.6.2</li>
<li>com.sun.mail:javax.mail:1.6.2</li>
</ul>
<p>并且代码引用的<code>jakarta.mail</code>需替换为<code>javax.mail</code>。</p>
<p>然后，我们通过JavaMail API连接到SMTP服务器上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器地址:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">smtp</span> <span class="operator">=</span> <span class="string">&quot;smtp.office365.com&quot;</span>;</span><br><span class="line"><span class="comment">// 登录用户名:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;jxsmtp101@outlook.com&quot;</span>;</span><br><span class="line"><span class="comment">// 登录口令:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;********&quot;</span>;</span><br><span class="line"><span class="comment">// 连接到SMTP服务器587端口:</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.host&quot;</span>, smtp); <span class="comment">// SMTP主机名</span></span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.port&quot;</span>, <span class="string">&quot;587&quot;</span>); <span class="comment">// 主机端口号</span></span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.auth&quot;</span>, <span class="string">&quot;true&quot;</span>); <span class="comment">// 是否需要用户认证</span></span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.starttls.enable&quot;</span>, <span class="string">&quot;true&quot;</span>); <span class="comment">// 启用TLS加密</span></span><br><span class="line"><span class="comment">// 获取Session实例:</span></span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> Session.getInstance(props, <span class="keyword">new</span> <span class="title class_">Authenticator</span>() &#123;</span><br><span class="line">    <span class="keyword">protected</span> PasswordAuthentication <span class="title function_">getPasswordAuthentication</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PasswordAuthentication</span>(username, password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 设置debug模式便于调试:</span></span><br><span class="line">session.setDebug(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>以587端口为例，连接SMTP服务器时，需要准备一个<code>Properties</code>对象，填入相关信息。最后获取<code>Session</code>实例时，如果服务器需要认证，还需要传入一个<code>Authenticator</code>对象，并返回指定的用户名和口令。</p>
<p>当我们获取到<code>Session</code>实例后，打开调试模式可以看到SMTP通信的详细内容，便于调试。</p>
<h3 id="发送邮件">发送邮件</h3>
<p>发送邮件时，我们需要构造一个<code>Message</code>对象，然后调用<code>Transport.send(Message)</code>即可完成发送：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessage</span>(session);</span><br><span class="line"><span class="comment">// 设置发送方地址:</span></span><br><span class="line">message.setFrom(<span class="keyword">new</span> <span class="title class_">InternetAddress</span>(<span class="string">&quot;me@example.com&quot;</span>));</span><br><span class="line"><span class="comment">// 设置接收方地址:</span></span><br><span class="line">message.setRecipient(Message.RecipientType.TO, <span class="keyword">new</span> <span class="title class_">InternetAddress</span>(<span class="string">&quot;xiaoming@somewhere.com&quot;</span>));</span><br><span class="line"><span class="comment">// 设置邮件主题:</span></span><br><span class="line">message.setSubject(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// 设置邮件正文:</span></span><br><span class="line">message.setText(<span class="string">&quot;Hi Xiaoming...&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// 发送:</span></span><br><span class="line">Transport.send(message);</span><br></pre></td></tr></table></figure>
<p>绝大多数邮件服务器要求发送方地址和登录用户名必须一致，否则发送将失败。</p>
<p>填入真实的地址，运行上述代码，我们可以在控制台看到JavaMail打印的调试信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">这是JavaMail打印的调试信息:</span><br><span class="line">DEBUG: setDebug: JavaMail version 1.6.2</span><br><span class="line">DEBUG: getProvider() returning javax.mail.Provider[TRANSPORT,smtp,com.sun.mail.smtp.SMTPTransport,Oracle]</span><br><span class="line">DEBUG SMTP: need username and password for authentication</span><br><span class="line">DEBUG SMTP: protocolConnect returning false, host=smtp.office365.com, ...</span><br><span class="line">DEBUG SMTP: useEhlo true, useAuth true</span><br><span class="line">开始尝试连接smtp.office365.com:</span><br><span class="line">DEBUG SMTP: trying to connect to host &quot;smtp.office365.com&quot;, port 587, ...</span><br><span class="line">DEBUG SMTP: connected to host &quot;smtp.office365.com&quot;, port: 587</span><br><span class="line">发送命令EHLO:</span><br><span class="line">EHLO localhost</span><br><span class="line">SMTP服务器响应250:</span><br><span class="line">250-SG3P274CA0024.outlook.office365.com Hello</span><br><span class="line">250-SIZE 157286400</span><br><span class="line">...</span><br><span class="line">DEBUG SMTP: Found extension &quot;SIZE&quot;, arg &quot;157286400&quot;</span><br><span class="line">发送命令STARTTLS:</span><br><span class="line">STARTTLS</span><br><span class="line">SMTP服务器响应220:</span><br><span class="line">220 2.0.0 SMTP server ready</span><br><span class="line">EHLO localhost</span><br><span class="line">250-SG3P274CA0024.outlook.office365.com Hello [111.196.164.63]</span><br><span class="line">250-SIZE 157286400</span><br><span class="line">250-PIPELINING</span><br><span class="line">250-...</span><br><span class="line">DEBUG SMTP: Found extension &quot;SIZE&quot;, arg &quot;157286400&quot;</span><br><span class="line">...</span><br><span class="line">尝试登录:</span><br><span class="line">DEBUG SMTP: protocolConnect login, host=smtp.office365.com, user=********, password=********</span><br><span class="line">DEBUG SMTP: Attempt to authenticate using mechanisms: LOGIN PLAIN DIGEST-MD5 NTLM XOAUTH2 </span><br><span class="line">DEBUG SMTP: Using mechanism LOGIN</span><br><span class="line">DEBUG SMTP: AUTH LOGIN command trace suppressed</span><br><span class="line">登录成功:</span><br><span class="line">DEBUG SMTP: AUTH LOGIN succeeded</span><br><span class="line">DEBUG SMTP: use8bit false</span><br><span class="line">开发发送邮件，设置FROM:</span><br><span class="line">MAIL FROM:&lt;********@outlook.com&gt;</span><br><span class="line">250 2.1.0 Sender OK</span><br><span class="line">设置TO:</span><br><span class="line">RCPT TO:&lt;********@sina.com&gt;</span><br><span class="line">250 2.1.5 Recipient OK</span><br><span class="line">发送邮件数据:</span><br><span class="line">DATA</span><br><span class="line">服务器响应354:</span><br><span class="line">354 Start mail input; end with &lt;CRLF&gt;.&lt;CRLF&gt;</span><br><span class="line">真正的邮件数据:</span><br><span class="line">Date: Mon, 2 Dec 2019 09:37:52 +0800 (CST)</span><br><span class="line">From: ********@outlook.com</span><br><span class="line">To: ********001@sina.com</span><br><span class="line">Message-ID: &lt;1617791695.0.1575250672483@localhost&gt;</span><br><span class="line">邮件主题是编码后的文本:</span><br><span class="line">Subject: =?UTF-8?Q?JavaMail=E9=82=AE=E4=BB=B6?=</span><br><span class="line">MIME-Version: 1.0</span><br><span class="line">Content-Type: text/plain; charset=UTF-8</span><br><span class="line">Content-Transfer-Encoding: base64</span><br><span class="line"></span><br><span class="line">邮件正文是Base64编码的文本:</span><br><span class="line">SGVsbG8sIOi/meaYr+S4gOWwgeadpeiHqmphdmFtYWls55qE6YKu5Lu277yB</span><br><span class="line">.</span><br><span class="line">邮件数据发送完成后，以\r\n.\r\n结束，服务器响应250表示发送成功:</span><br><span class="line">250 2.0.0 OK &lt;HK0PR03MB4961.apcprd03.prod.outlook.com&gt; [Hostname=HK0PR03MB4961.apcprd03.prod.outlook.com]</span><br><span class="line">DEBUG SMTP: message successfully delivered to mail server</span><br><span class="line">发送QUIT命令:</span><br><span class="line">QUIT</span><br><span class="line">服务器响应221结束TCP连接:</span><br><span class="line">221 2.0.0 Service closing transmission channel</span><br></pre></td></tr></table></figure>
<p>从上面的调试信息可以看出，SMTP协议是一个请求-响应协议，客户端总是发送命令，然后等待服务器响应。服务器响应总是以数字开头，后面的信息才是用于调试的文本。这些响应码已经被定义在<a target="_blank" rel="noopener" href="https://www.iana.org/assignments/smtp-enhanced-status-codes/smtp-enhanced-status-codes.txt">SMTP协议</a>中了，查看具体的响应码就可以知道出错原因。</p>
<p>如果一切顺利，对方将收到一封文本格式的电子邮件：</p>
<p><img src="https://liaoxuefeng.com/books/java/network/send-email/mail-text.png" alt="mail-text"></p>
<h3 id="发送HTML邮件">发送HTML邮件</h3>
<p>发送HTML邮件和文本邮件是类似的，只需要把：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message.setText(body, <span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message.setText(body, <span class="string">&quot;UTF-8&quot;</span>, <span class="string">&quot;html&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>传入的<code>body</code>是类似<code>&lt;h1&gt;Hello&lt;/h1&gt;&lt;p&gt;Hi, xxx&lt;/p&gt;</code>这样的HTML字符串即可。</p>
<p>HTML邮件可以在邮件客户端直接显示为网页格式：</p>
<p><img src="https://liaoxuefeng.com/books/java/network/send-email/mail-html.png" alt="mail-html"></p>
<h3 id="发送附件">发送附件</h3>
<p>要在电子邮件中携带附件，我们就不能直接调用<code>message.setText()</code>方法，而是要构造一个<code>Multipart</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Multipart</span> <span class="variable">multipart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMultipart</span>();</span><br><span class="line"><span class="comment">// 添加text:</span></span><br><span class="line"><span class="type">BodyPart</span> <span class="variable">textpart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeBodyPart</span>();</span><br><span class="line">textpart.setContent(body, <span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">multipart.addBodyPart(textpart);</span><br><span class="line"><span class="comment">// 添加image:</span></span><br><span class="line"><span class="type">BodyPart</span> <span class="variable">imagepart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeBodyPart</span>();</span><br><span class="line">imagepart.setFileName(fileName);</span><br><span class="line">imagepart.setDataHandler(<span class="keyword">new</span> <span class="title class_">DataHandler</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayDataSource</span>(input, <span class="string">&quot;application/octet-stream&quot;</span>)));</span><br><span class="line">multipart.addBodyPart(imagepart);</span><br><span class="line"><span class="comment">// 设置邮件内容为multipart:</span></span><br><span class="line">message.setContent(multipart);</span><br></pre></td></tr></table></figure>
<p>一个<code>Multipart</code>对象可以添加若干个<code>BodyPart</code>，其中第一个<code>BodyPart</code>是文本，即邮件正文，后面的BodyPart是附件。<code>BodyPart</code>依靠<code>setContent()</code>决定添加的内容，如果添加文本，用<code>setContent(&quot;...&quot;, &quot;text/plain;charset=utf-8&quot;)</code>添加纯文本，或者用<code>setContent(&quot;...&quot;, &quot;text/html;charset=utf-8&quot;)</code>添加HTML文本。如果添加附件，需要设置文件名（不一定和真实文件名一致），并且添加一个<code>DataHandler()</code>，传入文件的MIME类型。二进制文件可以用<code>application/octet-stream</code>，Word文档则是<code>application/msword</code>。</p>
<p>最后，通过<code>setContent()</code>把<code>Multipart</code>添加到<code>Message</code>中，即可发送。</p>
<p>带附件的邮件在客户端会被提示下载：</p>
<p><img src="https://liaoxuefeng.com/books/java/network/send-email/mail-attachment.png" alt="mail-attachment"></p>
<h3 id="发送内嵌图片的HTML邮件">发送内嵌图片的HTML邮件</h3>
<p>有些童鞋可能注意到，HTML邮件中可以内嵌图片，这是怎么做到的？</p>
<p>如果给一个<code>&lt;img src=&quot;http://example.com/test.jpg&quot;&gt;</code>，这样的外部图片链接通常会被邮件客户端过滤，并提示用户显示图片并不安全。只有内嵌的图片才能正常在邮件中显示。</p>
<p>内嵌图片实际上也是一个附件，即邮件本身也是<code>Multipart</code>，但需要做一点额外的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Multipart</span> <span class="variable">multipart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMultipart</span>();</span><br><span class="line"><span class="comment">// 添加text:</span></span><br><span class="line"><span class="type">BodyPart</span> <span class="variable">textpart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeBodyPart</span>();</span><br><span class="line">textpart.setContent(<span class="string">&quot;&lt;h1&gt;Hello&lt;/h1&gt;&lt;p&gt;&lt;img src=\&quot;cid:img01\&quot;&gt;&lt;/p&gt;&quot;</span>, <span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">multipart.addBodyPart(textpart);</span><br><span class="line"><span class="comment">// 添加image:</span></span><br><span class="line"><span class="type">BodyPart</span> <span class="variable">imagepart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeBodyPart</span>();</span><br><span class="line">imagepart.setFileName(fileName);</span><br><span class="line">imagepart.setDataHandler(<span class="keyword">new</span> <span class="title class_">DataHandler</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayDataSource</span>(input, <span class="string">&quot;image/jpeg&quot;</span>)));</span><br><span class="line"><span class="comment">// 与HTML的&lt;img src=&quot;cid:img01&quot;&gt;关联:</span></span><br><span class="line">imagepart.setHeader(<span class="string">&quot;Content-ID&quot;</span>, <span class="string">&quot;&lt;img01&gt;&quot;</span>);</span><br><span class="line">multipart.addBodyPart(imagepart);</span><br></pre></td></tr></table></figure>
<p>在HTML邮件中引用图片时，需要设定一个ID，用类似<code>&lt;img src=\&quot;cid:img01\&quot;&gt;</code>引用，然后，在添加图片作为BodyPart时，除了要正确设置MIME类型（根据图片类型使用<code>image/jpeg</code>或<code>image/png</code>），还需要设置一个Header：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imagepart.setHeader(<span class="string">&quot;Content-ID&quot;</span>, <span class="string">&quot;&lt;img01&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这个ID和HTML中引用的ID对应起来，邮件客户端就可以正常显示内嵌图片：</p>
<p><img src="https://liaoxuefeng.com/books/java/network/send-email/mail-image.png" alt="mail-image"></p>
<h3 id="常见问题">常见问题</h3>
<p>如果用户名或口令错误，会导致<code>535</code>登录失败：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEBUG SMTP: AUTH LOGIN failed</span><br><span class="line">Exception in thread &quot;main&quot; javax.mail.AuthenticationFailedException: 535 5.7.3 Authentication unsuccessful [HK0PR03CA0105.apcprd03.prod.outlook.com]</span><br></pre></td></tr></table></figure>
<p>如果登录用户和发件人不一致，会导致<code>554</code>拒绝发送错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEBUG SMTP: MessagingException while sending, THROW: </span><br><span class="line">com.sun.mail.smtp.SMTPSendFailedException: 554 5.2.0 STOREDRV.Submission.Exception:SendAsDeniedException.MapiExceptionSendAsDenied;</span><br></pre></td></tr></table></figure>
<p>有些时候，如果邮件主题和正文过于简单，会导致<code>554</code>被识别为垃圾邮件的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEBUG SMTP: MessagingException while sending, THROW: </span><br><span class="line">com.sun.mail.smtp.SMTPSendFailedException: 554 DT:SPM</span><br></pre></td></tr></table></figure>
<p>总之，出错时，需要查看DEBUG信息，找到服务器返回的错误码和描述信息来定位错误原因。</p>
<h3 id="练习-3">练习</h3>
<p>使用SMTP发送邮件。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/network/send-email/network-smtp.zip">下载练习</a></p>
<h3 id="小结-4">小结</h3>
<p>使用JavaMail API发送邮件本质上是一个MUA软件通过SMTP协议发送邮件至MTA服务器；</p>
<p>打开调试模式可以看到详细的SMTP交互信息；</p>
<p>某些邮件服务商需要开启SMTP，并需要独立的SMTP登录密码。</p>
<p>发送Email的过程我们在上一节已经讲过了，客户端总是通过SMTP协议把邮件发送给MTA。</p>
<p>接收Email则相反，因为邮件最终到达收件人的MDA服务器，所以，接收邮件是收件人用自己的客户端把邮件从MDA服务器上抓取到本地的过程。</p>
<p>接收邮件使用最广泛的协议是POP3：Post Office Protocol version 3，它也是一个建立在TCP连接之上的协议。POP3服务器的标准端口是<code>110</code>，如果整个会话需要加密，那么使用加密端口<code>995</code>。</p>
<p>另一种接收邮件的协议是IMAP：Internet Mail Access Protocol，它使用标准端口<code>143</code>和加密端口<code>993</code>。IMAP和POP3的主要区别是，IMAP协议在本地的所有操作都会自动同步到服务器上，并且，IMAP可以允许用户在邮件服务器的收件箱中创建文件夹。</p>
<p>JavaMail也提供了IMAP协议的支持。因为POP3和IMAP的使用方式非常类似，这里我们只介绍POP3的用法。</p>
<p>使用POP3收取Email时，我们无需关心POP3协议底层，因为JavaMail提供了高层接口。首先需要连接到Store对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备登录信息:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;pop3.example.com&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">995</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;bob@example.com&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;password&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.setProperty(<span class="string">&quot;mail.store.protocol&quot;</span>, <span class="string">&quot;pop3&quot;</span>); <span class="comment">// 协议名称</span></span><br><span class="line">props.setProperty(<span class="string">&quot;mail.pop3.host&quot;</span>, host);<span class="comment">// POP3主机名</span></span><br><span class="line">props.setProperty(<span class="string">&quot;mail.pop3.port&quot;</span>, String.valueOf(port)); <span class="comment">// 端口号</span></span><br><span class="line"><span class="comment">// 启动SSL:</span></span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.socketFactory.class&quot;</span>, <span class="string">&quot;javax.net.ssl.SSLSocketFactory&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.socketFactory.port&quot;</span>, String.valueOf(port));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接到Store:</span></span><br><span class="line"><span class="type">URLName</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLName</span>(<span class="string">&quot;pop3&quot;</span>, host, post, <span class="string">&quot;&quot;</span>, username, password);</span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> Session.getInstance(props, <span class="literal">null</span>);</span><br><span class="line">session.setDebug(<span class="literal">true</span>); <span class="comment">// 显示调试信息</span></span><br><span class="line"><span class="type">Store</span> <span class="variable">store</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">POP3SSLStore</span>(session, url);</span><br><span class="line">store.connect();</span><br></pre></td></tr></table></figure>
<p>一个<code>Store</code>对象表示整个邮箱的存储，要收取邮件，我们需要通过<code>Store</code>访问指定的<code>Folder</code>（文件夹），通常是<code>INBOX</code>表示收件箱：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取收件箱:</span></span><br><span class="line"><span class="type">Folder</span> <span class="variable">folder</span> <span class="operator">=</span> store.getFolder(<span class="string">&quot;INBOX&quot;</span>);</span><br><span class="line"><span class="comment">// 以读写方式打开:</span></span><br><span class="line">folder.open(Folder.READ_WRITE);</span><br><span class="line"><span class="comment">// 打印邮件总数/新邮件数量/未读数量/已删除数量:</span></span><br><span class="line">System.out.println(<span class="string">&quot;Total messages: &quot;</span> + folder.getMessageCount());</span><br><span class="line">System.out.println(<span class="string">&quot;New messages: &quot;</span> + folder.getNewMessageCount());</span><br><span class="line">System.out.println(<span class="string">&quot;Unread messages: &quot;</span> + folder.getUnreadMessageCount());</span><br><span class="line">System.out.println(<span class="string">&quot;Deleted messages: &quot;</span> + folder.getDeletedMessageCount());</span><br><span class="line"><span class="comment">// 获取每一封邮件:</span></span><br><span class="line">Message[] messages = folder.getMessages();</span><br><span class="line"><span class="keyword">for</span> (Message message : messages) &#123;</span><br><span class="line">    <span class="comment">// 打印每一封邮件:</span></span><br><span class="line">    printMessage((MimeMessage) message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们获取到一个<code>Message</code>对象时，可以强制转型为MimeMessage，然后打印出邮件主题、发件人、收件人等信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(MimeMessage msg)</span> <span class="keyword">throws</span> IOException, MessagingException &#123;</span><br><span class="line">    <span class="comment">// 邮件主题:</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Subject: &quot;</span> + MimeUtility.decodeText(msg.getSubject()));</span><br><span class="line">    <span class="comment">// 发件人:</span></span><br><span class="line">    Address[] froms = msg.getFrom();</span><br><span class="line">    <span class="type">InternetAddress</span> <span class="variable">address</span> <span class="operator">=</span> (InternetAddress) froms[<span class="number">0</span>];</span><br><span class="line">    <span class="type">String</span> <span class="variable">personal</span> <span class="operator">=</span> address.getPersonal();</span><br><span class="line">    <span class="type">String</span> <span class="variable">from</span> <span class="operator">=</span> personal == <span class="literal">null</span> ? address.getAddress() : (MimeUtility.decodeText(personal) + <span class="string">&quot; &lt;&quot;</span> + address.getAddress() + <span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;From: &quot;</span> + from);</span><br><span class="line">    <span class="comment">// 继续打印收件人:</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较麻烦的是获取邮件的正文。一个<code>MimeMessage</code>对象也是一个<code>Part</code>对象，它可能只包含一个文本，也可能是一个<code>Multipart</code>对象，即由几个<code>Part</code>构成，因此，需要递归地解析出完整的正文：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getBody</span><span class="params">(Part part)</span> <span class="keyword">throws</span> MessagingException, IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (part.isMimeType(<span class="string">&quot;text/*&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// Part是文本:</span></span><br><span class="line">        <span class="keyword">return</span> part.getContent().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (part.isMimeType(<span class="string">&quot;multipart/*&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// Part是一个Multipart对象:</span></span><br><span class="line">        <span class="type">Multipart</span> <span class="variable">multipart</span> <span class="operator">=</span> (Multipart) part.getContent();</span><br><span class="line">        <span class="comment">// 循环解析每个子Part:</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; multipart.getCount(); i++) &#123;</span><br><span class="line">            <span class="type">BodyPart</span> <span class="variable">bodyPart</span> <span class="operator">=</span> multipart.getBodyPart(i);</span><br><span class="line">            <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> getBody(bodyPart);</span><br><span class="line">            <span class="keyword">if</span> (!body.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> body;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后记得关闭<code>Folder</code>和<code>Store</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">folder.close(<span class="literal">true</span>); <span class="comment">// 传入true表示删除操作会同步到服务器上（即删除服务器收件箱的邮件）</span></span><br><span class="line">store.close();</span><br></pre></td></tr></table></figure>
<h3 id="练习-4">练习</h3>
<p>使用POP3接收邮件。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/network/receive-email/network-pop3.zip">下载练习</a></p>
<h3 id="小结-5">小结</h3>
<p>使用Java接收Email时，可以用POP3协议或IMAP协议。</p>
<p>使用POP3协议时，需要用Maven引入JavaMail依赖，并确定POP3服务器的域名／端口／是否使用SSL等，然后，调用相关API接收Email。</p>
<p>设置debug模式可以查看通信详细内容，便于排查错误。</p>
<p>什么是HTTP？HTTP就是目前使用最广泛的Web应用程序使用的基础协议，例如，浏览器访问网站，手机App访问后台服务器，都是通过HTTP协议实现的。</p>
<p>HTTP是HyperText Transfer Protocol的缩写，翻译为超文本传输协议，它是基于TCP协议之上的一种请求-响应协议。</p>
<p>我们来看一下浏览器请求访问某个网站时发送的HTTP请求-响应。当浏览器希望访问某个网站时，浏览器和网站服务器之间首先建立TCP连接，且服务器总是使用<code>80</code>端口和加密端口<code>443</code>，然后，浏览器向服务器发送一个HTTP请求，服务器收到后，返回一个HTTP响应，并且在响应中包含了HTML的网页内容，这样，浏览器解析HTML后就可以给用户显示网页了。一个完整的HTTP请求-响应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">            GET / HTTP/1.1</span><br><span class="line">            Host: www.sina.com.cn</span><br><span class="line">            User-Agent: Mozilla/5 MSIE</span><br><span class="line">            Accept: */*                ┌────────┐</span><br><span class="line">┌─────────┐ Accept-Language: zh-CN,en  │░░░░░░░░│</span><br><span class="line">│O ░░░░░░░│───────────────────────────▶├────────┤</span><br><span class="line">├─────────┤◀───────────────────────────│░░░░░░░░│</span><br><span class="line">│         │ HTTP/1.1 200 OK            ├────────┤</span><br><span class="line">│         │ Content-Type: text/html    │░░░░░░░░│</span><br><span class="line">└─────────┘ Content-Length: 133251     └────────┘</span><br><span class="line">  Browser   &lt;!DOCTYPE html&gt;              Server</span><br><span class="line">            &lt;html&gt;&lt;body&gt;</span><br><span class="line">            &lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>
<p>HTTP请求的格式是固定的，它由HTTP Header和HTTP Body两部分构成。第一行总是<code>请求方法 路径 HTTP版本</code>，例如，<code>GET / HTTP/1.1</code>表示使用<code>GET</code>请求，路径是<code>/</code>，版本是<code>HTTP/1.1</code>。</p>
<p>后续的每一行都是固定的<code>Header: Value</code>格式，我们称为HTTP Header，服务器依靠某些特定的Header来识别客户端请求，例如：</p>
<ul>
<li>Host：表示请求的域名，因为一台服务器上可能有多个网站，因此有必要依靠Host来识别请求是发给哪个网站的；</li>
<li>User-Agent：表示客户端自身标识信息，不同的浏览器有不同的标识，服务器依靠User-Agent判断客户端类型是IE还是Chrome，是Firefox还是一个Python爬虫；</li>
<li>Accept：表示客户端能处理的HTTP响应格式，<code>*/*</code>表示任意格式，<code>text/*</code>表示任意文本，<code>image/png</code>表示PNG格式的图片；</li>
<li>Accept-Language：表示客户端接收的语言，多种语言按优先级排序，服务器依靠该字段给用户返回特定语言的网页版本。</li>
</ul>
<p>如果是<code>GET</code>请求，那么该HTTP请求只有HTTP Header，没有HTTP Body。如果是<code>POST</code>请求，那么该HTTP请求带有Body，以一个空行分隔。一个典型的带Body的HTTP请求如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /login HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 30</span><br><span class="line"></span><br><span class="line">username=hello&amp;password=123456</span><br></pre></td></tr></table></figure>
<p><code>POST</code>请求通常要设置<code>Content-Type</code>表示Body的类型，<code>Content-Length</code>表示Body的长度，这样服务器就可以根据请求的Header和Body做出正确的响应。</p>
<p>此外，<code>GET</code>请求的参数必须附加在URL上，并以URLEncode方式编码，例如：<code>http://www.example.com/?a=1&amp;b=K%26R</code>，参数分别是<code>a=1</code>和<code>b=K&amp;R</code>。因为URL的长度限制，<code>GET</code>请求的参数不能太多，而<code>POST</code>请求的参数就没有长度限制，因为<code>POST</code>请求的参数必须放到Body中。并且，<code>POST</code>请求的参数不一定是URL编码，可以按任意格式编码，只需要在<code>Content-Type</code>中正确设置即可。常见的发送JSON的<code>POST</code>请求如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /login HTTP/1.1</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 38</span><br><span class="line"></span><br><span class="line">&#123;&quot;username&quot;:&quot;bob&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>HTTP响应也是由Header和Body两部分组成，一个典型的HTTP响应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 133251</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>响应的第一行总是<code>HTTP版本 响应代码 响应说明</code>，例如，<code>HTTP/1.1 200 OK</code>表示版本是<code>HTTP/1.1</code>，响应代码是<code>200</code>，响应说明是<code>OK</code>。客户端只依赖响应代码判断HTTP响应是否成功。HTTP有固定的响应代码：</p>
<ul>
<li>1xx：表示一个提示性响应，例如101表示将切换协议，常见于WebSocket连接；</li>
<li>2xx：表示一个成功的响应，例如200表示成功，206表示只发送了部分内容；</li>
<li>3xx：表示一个重定向的响应，例如301表示永久重定向，303表示客户端应该按指定路径重新发送请求；</li>
<li>4xx：表示一个因为客户端问题导致的错误响应，例如400表示因为Content-Type等各种原因导致的无效请求，404表示指定的路径不存在；</li>
<li>5xx：表示一个因为服务器问题导致的错误响应，例如500表示服务器内部故障，503表示服务器暂时无法响应。</li>
</ul>
<p>当浏览器收到第一个HTTP响应后，它解析HTML后，又会发送一系列HTTP请求，例如，<code>GET /logo.jpg HTTP/1.1</code>请求一个图片，服务器响应图片请求后，会直接把二进制内容的图片发送给浏览器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line">Content-Length: 18391</span><br><span class="line"></span><br><span class="line">????JFIFHH??XExifMM?i&amp;??X?...(二进制的JPEG图片)</span><br></pre></td></tr></table></figure>
<p>因此，服务器总是被动地接收客户端的一个HTTP请求，然后响应它。客户端则根据需要发送若干个HTTP请求。</p>
<p>对于最早期的HTTP/1.0协议，每次发送一个HTTP请求，客户端都需要先创建一个新的TCP连接，然后，收到服务器响应后，关闭这个TCP连接。由于建立TCP连接就比较耗时，因此，为了提高效率，HTTP/1.1协议允许在一个TCP连接中反复发送-响应，这样就能大大提高效率：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">                       ┌─────────┐</span><br><span class="line">┌─────────┐            │░░░░░░░░░│</span><br><span class="line">│O ░░░░░░░│            ├─────────┤</span><br><span class="line">├─────────┤            │░░░░░░░░░│</span><br><span class="line">│         │            ├─────────┤</span><br><span class="line">│         │            │░░░░░░░░░│</span><br><span class="line">└─────────┘            └─────────┘</span><br><span class="line">     │      request 1       │</span><br><span class="line">     │─────────────────────▶│</span><br><span class="line">     │      response 1      │</span><br><span class="line">     │◀─────────────────────│</span><br><span class="line">     │      request 2       │</span><br><span class="line">     │─────────────────────▶│</span><br><span class="line">     │      response 2      │</span><br><span class="line">     │◀─────────────────────│</span><br><span class="line">     │      request 3       │</span><br><span class="line">     │─────────────────────▶│</span><br><span class="line">     │      response 3      │</span><br><span class="line">     │◀─────────────────────│</span><br><span class="line">     ▼                      ▼</span><br></pre></td></tr></table></figure>
<p>因为HTTP协议是一个请求-响应协议，客户端在发送了一个HTTP请求后，必须等待服务器响应后，才能发送下一个请求，这样一来，如果某个响应太慢，它就会堵住后面的请求。</p>
<p>所以，为了进一步提速，HTTP/2.0允许客户端在没有收到响应的时候，发送多个HTTP请求，服务器返回响应的时候，不一定按顺序返回，只要双方能识别出哪个响应对应哪个请求，就可以做到并行发送和接收：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">                       ┌─────────┐</span><br><span class="line">┌─────────┐            │░░░░░░░░░│</span><br><span class="line">│O ░░░░░░░│            ├─────────┤</span><br><span class="line">├─────────┤            │░░░░░░░░░│</span><br><span class="line">│         │            ├─────────┤</span><br><span class="line">│         │            │░░░░░░░░░│</span><br><span class="line">└─────────┘            └─────────┘</span><br><span class="line">     │      request 1       │</span><br><span class="line">     │─────────────────────▶│</span><br><span class="line">     │      request 2       │</span><br><span class="line">     │─────────────────────▶│</span><br><span class="line">     │      response 1      │</span><br><span class="line">     │◀─────────────────────│</span><br><span class="line">     │      request 3       │</span><br><span class="line">     │─────────────────────▶│</span><br><span class="line">     │      response 3      │</span><br><span class="line">     │◀─────────────────────│</span><br><span class="line">     │      response 2      │</span><br><span class="line">     │◀─────────────────────│</span><br><span class="line">     ▼                      ▼</span><br></pre></td></tr></table></figure>
<p>可见，HTTP/2.0进一步提高了效率。</p>
<h3 id="HTTP编程">HTTP编程</h3>
<p>既然HTTP涉及到客户端和服务器端，和TCP类似，我们也需要针对客户端编程和针对服务器端编程。</p>
<p>本节我们不讨论服务器端的HTTP编程，因为服务器端的HTTP编程本质上就是编写Web服务器，这是一个非常复杂的体系，也是JavaEE开发的核心内容，我们在后面的章节再仔细研究。</p>
<p>本节我们只讨论作为客户端的HTTP编程。</p>
<p>因为浏览器也是一种HTTP客户端，所以，客户端的HTTP编程，它的行为本质上和浏览器是一样的，即发送一个HTTP请求，接收服务器响应后，获得响应内容。只不过浏览器进一步把响应内容解析后渲染并展示给了用户，而我们使用Java进行HTTP客户端编程仅限于获得响应内容。</p>
<p>我们来看一下Java如何使用HTTP客户端编程。</p>
<p>Java标准库提供了基于HTTP的包，但是要注意，早期的JDK版本是通过<code>HttpURLConnection</code>访问HTTP，典型代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://www.example.com/path/to/target?a=1&amp;b=2&quot;</span>);</span><br><span class="line"><span class="type">HttpURLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">conn.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">conn.setUseCaches(<span class="literal">false</span>);</span><br><span class="line">conn.setConnectTimeout(<span class="number">5000</span>); <span class="comment">// 请求超时5秒</span></span><br><span class="line"><span class="comment">// 设置HTTP头:</span></span><br><span class="line">conn.setRequestProperty(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;*/*&quot;</span>);</span><br><span class="line">conn.setRequestProperty(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (compatible; MSIE 11; Windows NT 5.1)&quot;</span>);</span><br><span class="line"><span class="comment">// 连接并发送HTTP请求:</span></span><br><span class="line">conn.connect();</span><br><span class="line"><span class="comment">// 判断HTTP响应是否200:</span></span><br><span class="line"><span class="keyword">if</span> (conn.getResponseCode() != <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;bad response&quot;</span>);</span><br><span class="line">&#125;		</span><br><span class="line"><span class="comment">// 获取所有响应Header:</span></span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; map = conn.getHeaderFields();</span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(key + <span class="string">&quot;: &quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取响应内容:</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> conn.getInputStream();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>上述代码编写比较繁琐，并且需要手动处理<code>InputStream</code>，所以用起来很麻烦。</p>
<p>从Java 11开始，引入了新的<code>HttpClient</code>，它使用链式调用的API，能大大简化HTTP的处理。</p>
<p>我们来看一下如何使用新版的<code>HttpClient</code>。首先需要创建一个全局<code>HttpClient</code>实例，因为<code>HttpClient</code>内部使用线程池优化多个HTTP连接，可以复用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">HttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClient.newBuilder().build();</span><br></pre></td></tr></table></figure>
<p>使用<code>GET</code>请求获取文本内容代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.http.*;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpClient.Version;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// 全局HttpClient:</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">HttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClient.newBuilder().build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://www.sina.com.cn/&quot;</span>;</span><br><span class="line">        <span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpRequest.newBuilder(<span class="keyword">new</span> <span class="title class_">URI</span>(url))</span><br><span class="line">            <span class="comment">// 设置Header:</span></span><br><span class="line">            .header(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Java HttpClient&quot;</span>).header(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;*/*&quot;</span>)</span><br><span class="line">            <span class="comment">// 设置超时:</span></span><br><span class="line">            .timeout(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">            <span class="comment">// 设置版本:</span></span><br><span class="line">            .version(Version.HTTP_2).build();</span><br><span class="line">        HttpResponse&lt;String&gt; response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">        <span class="comment">// HTTP允许重复的Header，因此一个Header可对应多个Value:</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; headers = response.headers().map();</span><br><span class="line">        <span class="keyword">for</span> (String header : headers.keySet()) &#123;</span><br><span class="line">            System.out.println(header + <span class="string">&quot;: &quot;</span> + headers.get(header).get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(response.body().substring(<span class="number">0</span>, <span class="number">1024</span>) + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们要获取图片这样的二进制内容，只需要把<code>HttpResponse.BodyHandlers.ofString()</code>换成<code>HttpResponse.BodyHandlers.ofByteArray()</code>，就可以获得一个<code>HttpResponse&lt;byte[]&gt;</code>对象。如果响应的内容很大，不希望一次性全部加载到内存，可以使用<code>HttpResponse.BodyHandlers.ofInputStream()</code>获取一个<code>InputStream</code>流。</p>
<p>要使用<code>POST</code>请求，我们要准备好发送的Body数据并正确设置<code>Content-Type</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://www.example.com/login&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot;username=bob&amp;password=123456&quot;</span>;</span><br><span class="line"><span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpRequest.newBuilder(<span class="keyword">new</span> <span class="title class_">URI</span>(url))</span><br><span class="line">    <span class="comment">// 设置Header:</span></span><br><span class="line">    .header(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;*/*&quot;</span>)</span><br><span class="line">    .header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)</span><br><span class="line">    <span class="comment">// 设置超时:</span></span><br><span class="line">    .timeout(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">    <span class="comment">// 设置版本:</span></span><br><span class="line">    .version(Version.HTTP_2)</span><br><span class="line">    <span class="comment">// 使用POST并设置Body:</span></span><br><span class="line">    .POST(BodyPublishers.ofString(body, StandardCharsets.UTF_8)).build();</span><br><span class="line">HttpResponse&lt;String&gt; response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> response.body();</span><br></pre></td></tr></table></figure>
<p>可见发送<code>POST</code>数据也十分简单。</p>
<h3 id="练习-5">练习</h3>
<p>使用HttpClient。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/network/http/network-http.zip">下载练习</a></p>
<h3 id="小结-6">小结</h3>
<p>Java提供了<code>HttpClient</code>作为新的HTTP客户端编程接口用于取代老的<code>HttpURLConnection</code>接口；</p>
<p><code>HttpClient</code>使用链式调用并通过内置的<code>BodyPublishers</code>和<code>BodyHandlers</code>来更方便地处理数据。</p>
<p>Java的RMI远程调用是指，一个JVM中的代码可以通过网络实现远程调用另一个JVM的某个方法。RMI是Remote Method Invocation的缩写。</p>
<p>提供服务的一方我们称之为服务器，而实现远程调用的一方我们称之为客户端。</p>
<p>我们先来实现一个最简单的RMI：服务器会提供一个<code>WorldClock</code>服务，允许客户端获取指定时区的时间，即允许客户端调用下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime <span class="title function_">getLocalDateTime</span><span class="params">(String zoneId)</span>;</span><br></pre></td></tr></table></figure>
<p>要实现RMI，服务器和客户端必须共享同一个接口。我们定义一个<code>WorldClock</code>接口，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WorldClock</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    LocalDateTime <span class="title function_">getLocalDateTime</span><span class="params">(String zoneId)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java的RMI规定此接口必须派生自<code>java.rmi.Remote</code>，并在每个方法声明抛出<code>RemoteException</code>。</p>
<p>下一步是编写服务器的实现类，因为客户端请求的调用方法<code>getLocalDateTime()</code>最终会通过这个实现类返回结果。实现类<code>WorldClockService</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorldClockService</span> <span class="keyword">implements</span> <span class="title class_">WorldClock</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalDateTime <span class="title function_">getLocalDateTime</span><span class="params">(String zoneId)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now(ZoneId.of(zoneId)).withNano(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，服务器端的服务相关代码就编写完毕。我们需要通过Java RMI提供的一系列底层支持接口，把上面编写的服务以RMI的形式暴露在网络上，客户端才能调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;create World clock remote service...&quot;</span>);</span><br><span class="line">        <span class="comment">// 实例化一个WorldClock:</span></span><br><span class="line">        <span class="type">WorldClock</span> <span class="variable">worldClock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorldClockService</span>();</span><br><span class="line">        <span class="comment">// 将此服务转换为远程服务接口:</span></span><br><span class="line">        <span class="type">WorldClock</span> <span class="variable">skeleton</span> <span class="operator">=</span> (WorldClock) UnicastRemoteObject.exportObject(worldClock, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 将RMI服务注册到1099端口:</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="comment">// 注册此服务，服务名为&quot;WorldClock&quot;:</span></span><br><span class="line">        registry.rebind(<span class="string">&quot;WorldClock&quot;</span>, skeleton);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码主要目的是通过RMI提供的相关类，将我们自己的<code>WorldClock</code>实例注册到RMI服务上。RMI的默认端口是<code>1099</code>，最后一步注册服务时通过<code>rebind()</code>指定服务名称为<code>&quot;WorldClock&quot;</code>。</p>
<p>下一步我们就可以编写客户端代码。RMI要求服务器和客户端共享同一个接口，因此我们要把<code>WorldClock.java</code>这个接口文件复制到客户端，然后在客户端实现RMI调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException &#123;</span><br><span class="line">        <span class="comment">// 连接到服务器localhost，端口1099:</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;localhost&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="comment">// 查找名称为&quot;WorldClock&quot;的服务并强制转型为WorldClock接口:</span></span><br><span class="line">        <span class="type">WorldClock</span> <span class="variable">worldClock</span> <span class="operator">=</span> (WorldClock) registry.lookup(<span class="string">&quot;WorldClock&quot;</span>);</span><br><span class="line">        <span class="comment">// 正常调用接口方法:</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> worldClock.getLocalDateTime(<span class="string">&quot;Asia/Shanghai&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先运行服务器，再运行客户端。从运行结果可知，因为客户端只有接口，并没有实现类，因此，客户端获得的接口方法返回值实际上是通过网络从服务器端获取的。整个过程实际上非常简单，对客户端来说，客户端持有的<code>WorldClock</code>接口实际上对应了一个“实现类”，它是由<code>Registry</code>内部动态生成的，并负责把方法调用通过网络传递到服务器端。而服务器端接收网络调用的服务并不是我们自己编写的<code>WorldClockService</code>，而是<code>Registry</code>自动生成的代码。我们把客户端的“实现类”称为<code>stub</code>，而服务器端的网络服务类称为<code>skeleton</code>，它会真正调用服务器端的<code>WorldClockService</code>，获取结果，然后把结果通过网络传递给客户端。整个过程由RMI底层负责实现序列化和反序列化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌ ─ ─ ─ ─ ─ ─ ─ ─ ┐         ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line">  ┌─────────────┐                                  ┌────────────┐</span><br><span class="line">│ │   Service   │ │         │                      │  Service   │ │</span><br><span class="line">  └─────────────┘                                  └────────────┘</span><br><span class="line">│        ▲        │         │                            ▲        │</span><br><span class="line">         │                                               │</span><br><span class="line">│        │        │         │                            │        │</span><br><span class="line">  ┌─────────────┐   Network    ┌───────────────┐   ┌────────────┐</span><br><span class="line">│ │ Client Stub ├─┼─────────┼─▶│Server Skeleton│──▶│Service Impl│ │</span><br><span class="line">  └─────────────┘              └───────────────┘   └────────────┘</span><br><span class="line">└ ─ ─ ─ ─ ─ ─ ─ ─ ┘         └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>
<p>Java的RMI严重依赖序列化和反序列化，而这种情况下可能会造成严重的安全漏洞，因为Java的序列化和反序列化不但涉及到数据，还涉及到二进制的字节码，即使使用白名单机制也很难保证100%排除恶意构造的字节码。因此，使用RMI时，双方必须是内网互相信任的机器，不要把1099端口暴露在公网上作为对外服务。</p>
<p>此外，Java的RMI调用机制决定了双方必须是Java程序，其他语言很难调用Java的RMI。如果要使用不同语言进行RPC调用，可以选择更通用的协议，例如<a target="_blank" rel="noopener" href="https://grpc.io/">gRPC</a>。</p>
<h3 id="练习-6">练习</h3>
<p>使用RMI实现远程调用。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/network/rmi/network-rmi.zip">下载练习</a></p>
<h3 id="小结-7">小结</h3>
<p>Java提供了RMI实现远程方法调用：</p>
<p>RMI通过自动生成stub和skeleton实现网络调用，客户端只需要查找服务并获得接口实例，服务器端只需要编写实现类并注册为服务；</p>
<p>RMI的序列化和反序列化可能会造成安全漏洞，因此调用双方必须是内网互相信任的机器，不要把1099端口暴露在公网上作为对外服务。</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">標籤</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/Java/" rel="tag">Java</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JAVA-XML%E4%B8%8EJSON/"
                    data-tooltip="JAVA-XML与JSON"
                    aria-label="上一篇: JAVA-XML与JSON"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JAVA-Maven%E5%9F%BA%E7%A1%80/"
                    data-tooltip="JAVA-Maven基础"
                    aria-label="下一篇: JAVA-Maven基础"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/24/java/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/24/java/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/24/java/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/24/java/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JAVA-XML%E4%B8%8EJSON/"
                    data-tooltip="JAVA-XML与JSON"
                    aria-label="上一篇: JAVA-XML与JSON"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JAVA-Maven%E5%9F%BA%E7%A1%80/"
                    data-tooltip="JAVA-Maven基础"
                    aria-label="下一篇: JAVA-Maven基础"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/24/java/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/24/java/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/24/java/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/24/java/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/24/java/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
                        aria-label="分享到 Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/24/java/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
                        aria-label="分享到 Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/24/java/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
                        aria-label="global.share_on_linkedin"
                    >
                        <i class="fab fa-linkedin" aria-hidden="true"></i><span>global.share_on_linkedin</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/24/java/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
                        aria-label="分享到 Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 135 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
