
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>JAVA-设计模式-行为型模式 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg"},"articleBody":"行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。\n行为型模式有：\n\n责任链\n命令\n解释器\n迭代器\n中介\n备忘录\n观察者\n状态\n策略\n模板方法\n访问者\n\n\n使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n责任链模式（Chain of Responsibility）是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递：\n1234567891011121314151617181920212223     ┌─────────┐     │ Request │     └─────────┘          │┌ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┐          ▼│  ┌─────────────┐  │   │ ProcessorA  ││  └─────────────┘  │          ││         ▼         │   ┌─────────────┐│  │ ProcessorB  │  │   └─────────────┘│         │         │          ▼│  ┌─────────────┐  │   │ ProcessorC  ││  └─────────────┘  │          │└ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┘          │          ▼\n在实际场景中，财务审批就是一个责任链模式。假设某个员工需要报销一笔费用，审核者可以分为：\n\nManager：只能审核1000元以下的报销；\nDirector：只能审核10000元以下的报销；\nCEO：可以审核任意额度。\n\n用责任链模式设计此报销流程时，每个审核者只关心自己责任范围内的请求，并且处理它。对于超出自己责任范围的，扔给下一个审核者处理，这样，将来继续添加审核者的时候，不用改动现有逻辑。\n我们来看看如何实现责任链模式。\n首先，我们要抽象出请求对象，它将在责任链上传递：\n1234567891011121314151617public class Request &#123;    private String name;    private BigDecimal amount;    public Request(String name, BigDecimal amount) &#123;        this.name = name;        this.amount = amount;    &#125;    public String getName() &#123;        return name;    &#125;    public BigDecimal getAmount() &#123;        return amount;    &#125;&#125;\n其次，我们要抽象出处理器：\n123456public interface Handler &#123;    // 返回Boolean.TRUE = 成功    // 返回Boolean.FALSE = 拒绝    // 返回null = 交下一个处理\tBoolean process(Request request);&#125;\n并且做好约定：如果返回Boolean.TRUE，表示处理成功，如果返回Boolean.FALSE，表示处理失败（请求被拒绝），如果返回null，则交由下一个Handler处理。\n然后，依次编写ManagerHandler、DirectorHandler和CEOHandler。以ManagerHandler为例：\n12345678910public class ManagerHandler implements Handler &#123;    public Boolean process(Request request) &#123;        // 如果超过1000元，处理不了，交下一个处理:        if (request.getAmount().compareTo(BigDecimal.valueOf(1000)) &gt; 0) &#123;            return null;        &#125;        // 对Bob有偏见:        return !request.getName().equalsIgnoreCase(&quot;bob&quot;);    &#125;&#125;\n有了不同的Handler后，我们还要把这些Handler组合起来，变成一个链，并通过一个统一入口处理：\n123456789101112131415161718192021public class HandlerChain &#123;    // 持有所有Handler:    private List&lt;Handler&gt; handlers = new ArrayList&lt;&gt;();    public void addHandler(Handler handler) &#123;        this.handlers.add(handler);    &#125;    public boolean process(Request request) &#123;        // 依次调用每个Handler:        for (Handler handler : handlers) &#123;            Boolean r = handler.process(request);            if (r != null) &#123;                // 如果返回TRUE或FALSE，处理结束:                System.out.println(request + &quot; &quot; + (r ? &quot;Approved by &quot; : &quot;Denied by &quot;) + handler.getClass().getSimpleName());                return r;            &#125;        &#125;        throw new RuntimeException(&quot;Could not handle request: &quot; + request);    &#125;&#125;\n现在，我们就可以在客户端组装出责任链，然后用责任链来处理请求：\n12345678910// 构造责任链:HandlerChain chain = new HandlerChain();chain.addHandler(new ManagerHandler());chain.addHandler(new DirectorHandler());chain.addHandler(new CEOHandler());// 处理请求:chain.process(new Request(&quot;Bob&quot;, new BigDecimal(&quot;123.45&quot;)));chain.process(new Request(&quot;Alice&quot;, new BigDecimal(&quot;1234.56&quot;)));chain.process(new Request(&quot;Bill&quot;, new BigDecimal(&quot;12345.67&quot;)));chain.process(new Request(&quot;John&quot;, new BigDecimal(&quot;123456.78&quot;)));\n责任链模式本身很容易理解，需要注意的是，Handler添加的顺序很重要，如果顺序不对，处理的结果可能就不是符合要求的。\n此外，责任链模式有很多变种。有些责任链的实现方式是通过某个Handler手动调用下一个Handler来传递Request，例如：\n1234567891011public class AHandler implements Handler &#123;    private Handler next;    public void process(Request request) &#123;        if (!canProcess(request)) &#123;            // 手动交给下一个Handler处理:            next.process(request);        &#125; else &#123;            ...        &#125;    &#125;&#125;\n还有一些责任链模式，每个Handler都有机会处理Request，通常这种责任链被称为拦截器（Interceptor）或者过滤器（Filter），它的目的不是找到某个Handler处理掉Request，而是每个Handler都做一些工作，比如：\n\n记录日志；\n检查权限；\n准备相关资源；\n…\n\n例如，JavaEE的Servlet规范定义的Filter就是一种责任链模式，它不但允许每个Filter都有机会处理请求，还允许每个Filter决定是否将请求“放行”给下一个Filter：\n123456789101112public class AuditFilter implements Filter &#123;    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException &#123;        log(req);        if (check(req)) &#123;            // 放行:            chain.doFilter(req, resp);        &#125; else &#123;            // 拒绝:            sendError(resp);        &#125;    &#125;&#125;\n这种模式不但允许一个Filter自行决定处理ServletRequest和ServletResponse，还可以“伪造”ServletRequest和ServletResponse以便让下一个Filter处理，能实现非常复杂的功能。\n练习\n使用责任链模式实现审批。\n下载练习\n小结\n责任链模式是一种把多个处理器组合在一起，依次处理请求的模式；\n责任链模式的好处是添加新的处理器或者重新排列处理器非常容易；\n责任链模式经常用在拦截、预处理请求等。\n\n将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。\n\n命令模式（Command）是指，把请求封装成一个命令，然后执行该命令。\n在使用命令模式前，我们先以一个编辑器为例子，看看如何实现简单的编辑操作：\n1234567891011121314151617181920212223242526public class TextEditor &#123;    private StringBuilder buffer = new StringBuilder();    public void copy() &#123;        ...    &#125;    public void paste() &#123;        String text = getFromClipBoard();        add(text);    &#125;    public void add(String s) &#123;        buffer.append(s);    &#125;    public void delete() &#123;        if (buffer.length() &gt; 0) &#123;            buffer.deleteCharAt(buffer.length() - 1);        &#125;    &#125;    public String getState() &#123;        return buffer.toString();    &#125;&#125;\n我们用一个StringBuilder模拟一个文本编辑器，它支持copy()、paste()、add()、delete()等方法。\n正常情况，我们像这样调用TextEditor：\n12345TextEditor editor = new TextEditor();editor.add(&quot;Command pattern in text editor.\\n&quot;);editor.copy();editor.paste();System.out.println(editor.getState());\n这是直接调用方法，调用方需要了解TextEditor的所有接口信息。\n如果改用命令模式，我们就要把调用方发送命令和执行方执行命令分开。怎么分？\n解决方案是引入一个Command接口：\n123public interface Command &#123;    void execute();&#125;\n调用方创建一个对应的Command，然后执行，并不关心内部是如何具体执行的。\n为了支持CopyCommand和PasteCommand这两个命令，我们从Command接口派生：\n123456789101112131415161718192021222324public class CopyCommand implements Command &#123;    // 持有执行者对象:    private TextEditor receiver;    public CopyCommand(TextEditor receiver) &#123;        this.receiver = receiver;    &#125;    public void execute() &#123;        receiver.copy();    &#125;&#125;public class PasteCommand implements Command &#123;    private TextEditor receiver;    public PasteCommand(TextEditor receiver) &#123;        this.receiver = receiver;    &#125;    public void execute() &#123;        receiver.paste();    &#125;&#125;\n最后我们把Command和TextEditor组装一下，客户端这么写：\n12345678910TextEditor editor = new TextEditor();editor.add(&quot;Command pattern in text editor.\\n&quot;);// 执行一个CopyCommand:Command copy = new CopyCommand(editor);copy.execute();editor.add(&quot;----\\n&quot;);// 执行一个PasteCommand:Command paste = new PasteCommand(editor);paste.execute();System.out.println(editor.getState());\n这就是命令模式的结构：\n1234567891011121314┌──────┐      ┌───────┐│Client│─ ─ ─▶│Command│└──────┘      └───────┘                  │  ┌──────────────┐                  ├─▶│ CopyCommand  │                  │  ├──────────────┤                  │  │editor.copy() │─ ┐                  │  └──────────────┘                  │                    │  ┌────────────┐                  │  ┌──────────────┐   ─▶│ TextEditor │                  └─▶│ PasteCommand │  │  └────────────┘                     ├──────────────┤                     │editor.paste()│─ ┘                     └──────────────┘\n有的童鞋会有疑问：搞了一大堆Command，多了好几个类，还不如直接这么写简单：\n1234TextEditor editor = new TextEditor();editor.add(&quot;Command pattern in text editor.\\n&quot;);editor.copy();editor.paste();\n实际上，使用命令模式，确实增加了系统的复杂度。如果需求很简单，那么直接调用显然更直观而且更简单。\n那么我们还需要命令模式吗？\n答案是视需求而定。如果TextEditor复杂到一定程度，并且需要支持Undo、Redo的功能时，就需要使用命令模式，因为我们可以给每个命令增加undo()：\n1234public interface Command &#123;    void execute();    void undo();&#125;\n然后把执行的一系列命令用List保存起来，就既能支持Undo，又能支持Redo。这个时候，我们又需要一个Invoker对象，负责执行命令并保存历史命令：\n1234567891011121314151617181920212223┌─────────────┐│   Client    │└─────────────┘       │       │       ▼┌─────────────┐│   Invoker   │├─────────────┤    ┌───────┐│List commands│─ ─▶│Command││invoke(c)    │    └───────┘│undo()       │        │  ┌──────────────┐└─────────────┘        ├─▶│ CopyCommand  │                       │  ├──────────────┤                       │  │editor.copy() │─ ┐                       │  └──────────────┘                       │                    │  ┌────────────┐                       │  ┌──────────────┐   ─▶│ TextEditor │                       └─▶│ PasteCommand │  │  └────────────┘                          ├──────────────┤                          │editor.paste()│─ ┘                          └──────────────┘\n可见，模式带来的设计复杂度的增加是随着需求而增加的，它减少的是系统各组件的耦合度。\n练习\n给命令模式新增Add和Delete命令并支持Undo、Redo操作。\n下载练习\n小结\n命令模式的设计思想是把命令的创建和执行分离，使得调用者无需关心具体的执行过程。\n通过封装Command对象，命令模式可以保存已执行的命令，从而支持撤销、重做等操作。\n解释器\n\n给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。\n\n解释器模式（Interpreter）是一种针对特定问题设计的一种解决方案。例如，匹配字符串的时候，由于匹配条件非常灵活，使得通过代码来实现非常不灵活。举个例子，针对以下的匹配条件：\n\n以+开头的数字表示的区号和电话号码，如+861012345678；\n以英文开头，后接英文和数字，并以.分隔的域名，如www.liaoxuefeng.com；\n以/开头的文件路径，如/path/to/file.txt；\n…\n\n因此，需要一种通用的表示方法——正则表达式来进行匹配。正则表达式就是一个字符串，但要把正则表达式解析为语法树，然后再匹配指定的字符串，就需要一个解释器。\n实现一个完整的正则表达式的解释器非常复杂，但是使用解释器模式却很简单：\n12String s = &quot;+861012345678&quot;;System.out.println(s.matches(&quot;^\\\\+\\\\d+$&quot;));\n类似的，当我们使用JDBC时，执行的SQL语句虽然是字符串，但最终需要数据库服务器的SQL解释器来把SQL“翻译”成数据库服务器能执行的代码，这个执行引擎也非常复杂，但对于使用者来说，仅仅需要写出SQL字符串即可。\n练习\n请实现一个简单的解释器，它可以以SLF4J的日志格式输出字符串：\n12log(&quot;[&#123;&#125;] start &#123;&#125; at &#123;&#125;...&quot;, LocalTime.now().withNano(0), &quot;engine&quot;, LocalDate.now());// [11:02:18] start engine at 2020-02-21...\n下载练习\n小结\n解释器模式通过抽象语法树实现对用户输入的解释执行。\n解释器模式的实现通常非常复杂，且一般只能解决一类特定问题。\n\n\n迭代器\n\n提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。\n\n迭代器模式（Iterator）实际上在Java的集合类中已经广泛使用了。我们以List为例，要遍历ArrayList，即使我们知道它的内部存储了一个Object[]数组，也不应该直接使用数组索引去遍历，因为这样需要了解集合内部的存储结构。如果使用Iterator遍历，那么，ArrayList和LinkedList都可以以一种统一的接口来遍历：\n1234List&lt;String&gt; list = ...for (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;    String s = it.next();&#125;\n实际上，因为Iterator模式十分有用，因此，Java允许我们直接把任何支持Iterator的集合对象用foreach循环写出来：\n1234List&lt;String&gt; list = ...for (String s : list) &#123;&#125;\n然后由Java编译器完成Iterator模式的所有循环代码。\n虽然我们对如何使用Iterator有了一定了解，但如何实现一个Iterator模式呢？我们以一个自定义的集合为例，通过Iterator模式实现倒序遍历：\n123456789101112public class ReverseArrayCollection&lt;T&gt; implements Iterable&lt;T&gt; &#123;    // 以数组形式持有集合:    private T[] array;    public ReverseArrayCollection(T... objs) &#123;        this.array = Arrays.copyOfRange(objs, 0, objs.length);    &#125;    public Iterator&lt;T&gt; iterator() &#123;        return ???;    &#125;&#125;\n实现Iterator模式的关键是返回一个Iterator对象，该对象知道集合的内部结构，因为它可以实现倒序遍历。我们使用Java的内部类实现这个Iterator：\n1234567891011121314151617181920212223242526272829303132public class ReverseArrayCollection&lt;T&gt; implements Iterable&lt;T&gt; &#123;    private T[] array;    public ReverseArrayCollection(T... objs) &#123;        this.array = Arrays.copyOfRange(objs, 0, objs.length);    &#125;    public Iterator&lt;T&gt; iterator() &#123;        return new ReverseIterator();    &#125;    class ReverseIterator implements Iterator&lt;T&gt; &#123;        // 索引位置:        int index;        public ReverseIterator() &#123;            // 创建Iterator时,索引在数组末尾:            this.index = ReverseArrayCollection.this.array.length;        &#125;        public boolean hasNext() &#123;            // 如果索引大于0,那么可以移动到下一个元素(倒序往前移动):            return index &gt; 0;        &#125;        public T next() &#123;            // 将索引移动到下一个元素并返回(倒序往前移动):            index--;            return array[index];        &#125;    &#125;&#125;\n使用内部类的好处是内部类隐含地持有一个它所在对象的this引用，可以通过ReverseArrayCollection.this引用到它所在的集合。上述代码实现的逻辑非常简单，但是实际应用时，如果考虑到多线程访问，当一个线程正在迭代某个集合，而另一个线程修改了集合的内容时，是否能继续安全地迭代，还是抛出ConcurrentModificationException，就需要更仔细地设计。\n练习\n使用Iterator模式实现集合的倒序遍历。\n下载练习\n小结\nIterator模式常用于遍历集合，它允许集合提供一个统一的Iterator接口来遍历元素，同时保证调用者对集合内部的数据结构一无所知，从而使得调用者总是以相同的接口遍历各种不同类型的集合。\n\n\n中介\n\n用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n\n中介模式（Mediator）又称调停者模式，它的目的是把多方会谈变成双方会谈，从而实现多方的松耦合。\n有些童鞋听到中介立刻想到房产中介，立刻气不打一处来。这个中介模式与房产中介还真有点像，所以消消气，先看例子。\n考虑一个简单的点餐输入：\n\n这个小系统有4个参与对象：\n\n多选框；\n“选择全部”按钮；\n“取消所有”按钮；\n“反选”按钮。\n\n它的复杂性在于，当多选框变化时，它会影响“选择全部”和“取消所有”按钮的状态（是否可点击），当用户点击某个按钮时，例如“反选”，除了会影响多选框的状态，它又可能影响“选择全部”和“取消所有”按钮的状态。\n所以这是一个多方会谈，逻辑写起来很复杂：\n123456789┌─────────────────┐     ┌─────────────────┐│  CheckBox List  │◀───▶│SelectAll Button │└─────────────────┘     └─────────────────┘         ▲ ▲                     ▲         │ └─────────────────────┤         ▼                       │┌─────────────────┐     ┌────────┴────────┐│SelectNone Button│◀────│ Inverse Button  │└─────────────────┘     └─────────────────┘\n如果我们引入一个中介，把多方会谈变成多个双方会谈，虽然多了一个对象，但对象之间的关系就变简单了：\n123456789101112131415            ┌─────────────────┐     ┌─────▶│  CheckBox List  │     │      └─────────────────┘     │      ┌─────────────────┐     │ ┌───▶│SelectAll Button │     ▼ ▼    └─────────────────┘┌─────────┐│Mediator │└─────────┘     ▲ ▲    ┌─────────────────┐     │ └───▶│SelectNone Button│     │      └─────────────────┘     │      ┌─────────────────┐     └─────▶│ Inverse Button  │            └─────────────────┘\n下面我们用中介模式来实现各个UI组件的交互。首先把UI组件给画出来：\n123456789101112131415161718192021222324252627282930313233343536373839404142public class Main &#123;    public static void main(String[] args) &#123;        new OrderFrame(&quot;Hanburger&quot;, &quot;Nugget&quot;, &quot;Chip&quot;, &quot;Coffee&quot;);    &#125;&#125;class OrderFrame extends JFrame &#123;    public OrderFrame(String... names) &#123;        setTitle(&quot;Order&quot;);        setSize(460, 200);        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        Container c = getContentPane();        c.setLayout(new FlowLayout(FlowLayout.LEADING, 20, 20));        c.add(new JLabel(&quot;Use Mediator Pattern&quot;));        List&lt;JCheckBox&gt; checkboxList = addCheckBox(names);        JButton selectAll = addButton(&quot;Select All&quot;);        JButton selectNone = addButton(&quot;Select None&quot;);        selectNone.setEnabled(false);        JButton selectInverse = addButton(&quot;Inverse Select&quot;);        new Mediator(checkBoxList, selectAll, selectNone, selectInverse);        setVisible(true);    &#125;    private List&lt;JCheckBox&gt; addCheckBox(String... names) &#123;        JPanel panel = new JPanel();        panel.add(new JLabel(&quot;Menu:&quot;));        List&lt;JCheckBox&gt; list = new ArrayList&lt;&gt;();        for (String name : names) &#123;            JCheckBox checkbox = new JCheckBox(name);            list.add(checkbox);            panel.add(checkbox);        &#125;        getContentPane().add(panel);        return list;    &#125;    private JButton addButton(String label) &#123;        JButton button = new JButton(label);        getContentPane().add(button);        return button;    &#125;&#125;\n然后，我们设计一个Mediator类，它引用4个UI组件，并负责跟它们交互：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Mediator &#123;    // 引用UI组件:    private List&lt;JCheckBox&gt; checkBoxList;    private JButton selectAll;    private JButton selectNone;    private JButton selectInverse;    public Mediator(List&lt;JCheckBox&gt; checkBoxList, JButton selectAll, JButton selectNone, JButton selectInverse) &#123;        this.checkBoxList = checkBoxList;        this.selectAll = selectAll;        this.selectNone = selectNone;        this.selectInverse = selectInverse;        // 绑定事件:        this.checkBoxList.forEach(checkBox -&gt; &#123;            checkBox.addChangeListener(this::onCheckBoxChanged);        &#125;);        this.selectAll.addActionListener(this::onSelectAllClicked);        this.selectNone.addActionListener(this::onSelectNoneClicked);        this.selectInverse.addActionListener(this::onSelectInverseClicked);    &#125;    // 当checkbox有变化时:    public void onCheckBoxChanged(ChangeEvent event) &#123;        boolean allChecked = true;        boolean allUnchecked = true;        for (var checkBox : checkBoxList) &#123;            if (checkBox.isSelected()) &#123;                allUnchecked = false;            &#125; else &#123;                allChecked = false;            &#125;        &#125;        selectAll.setEnabled(!allChecked);        selectNone.setEnabled(!allUnchecked);    &#125;    // 当点击select all:    public void onSelectAllClicked(ActionEvent event) &#123;        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(true));        selectAll.setEnabled(false);        selectNone.setEnabled(true);    &#125;    // 当点击select none:    public void onSelectNoneClicked(ActionEvent event) &#123;        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(false));        selectAll.setEnabled(true);        selectNone.setEnabled(false);    &#125;    // 当点击select inverse:    public void onSelectInverseClicked(ActionEvent event) &#123;        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(!checkBox.isSelected()));        onCheckBoxChanged(null);    &#125;&#125;\n运行一下看看效果：\n\n使用Mediator模式后，我们得到了以下好处：\n\n各个UI组件互不引用，这样就减少了组件之间的耦合关系；\nMediator用于当一个组件发生状态变化时，根据当前所有组件的状态决定更新某些组件；\n如果新增一个UI组件，我们只需要修改Mediator更新状态的逻辑，现有的其他UI组件代码不变。\n\nMediator模式经常用在有众多交互组件的UI上。为了简化UI程序，MVC模式以及MVVM模式都可以看作是Mediator模式的扩展。\n练习\n使用Mediator模式。\n下载练习\n小结\n中介模式是通过引入一个中介对象，把多边关系变成多个双边关系，从而简化系统组件的交互耦合度。\n\n\n备忘录\n\n在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。\n\n备忘录模式（Memento），主要用于捕获一个对象的内部状态，以便在将来的某个时候恢复此状态。\n其实我们使用的几乎所有软件都用到了备忘录模式。最简单的备忘录模式就是保存到文件，打开文件。对于文本编辑器来说，保存就是把TextEditor类的字符串存储到文件，打开就是恢复TextEditor类的状态。对于图像编辑器来说，原理是一样的，只是保存和恢复的数据格式比较复杂而已。Java的序列化也可以看作是备忘录模式。\n在使用文本编辑器的时候，我们还经常使用Undo、Redo这些功能。这些其实也可以用备忘录模式实现，即不定期地把TextEditor类的字符串复制一份存起来，这样就可以Undo或Redo。\n标准的备忘录模式有这么几种角色：\n\nMemento：存储的内部状态；\nOriginator：创建一个备忘录并设置其状态；\nCaretaker：负责保存备忘录。\n\n实际上我们在使用备忘录模式的时候，不必设计得这么复杂，只需要对类似TextEditor的类，增加getState()和setState()就可以了。\n我们以一个文本编辑器TextEditor为例，它内部使用StringBuilder允许用户增删字符：\n1234567891011121314151617public class TextEditor &#123;    private StringBuilder buffer = new StringBuilder();    public void add(char ch) &#123;        buffer.append(ch);    &#125;    public void add(String s) &#123;        buffer.append(s);    &#125;    public void delete() &#123;        if (buffer.length() &gt; 0) &#123;            buffer.deleteCharAt(buffer.length() - 1);        &#125;    &#125;&#125;\n为了支持这个TextEditor能保存和恢复状态，我们增加getState()和setState()两个方法：\n1234567891011121314public class TextEditor &#123;    ...    // 获取状态:    public String getState() &#123;        return buffer.toString();    &#125;    // 恢复状态:    public void setState(String state) &#123;        this.buffer.delete(0, this.buffer.length());        this.buffer.append(state);    &#125;&#125;\n对这个简单的文本编辑器，用一个String就可以表示其状态，对于复杂的对象模型，通常我们会使用JSON、XML等复杂格式。\n练习\n给TextEditor添加备忘录模式。\n下载练习\n小结\n备忘录模式是为了保存对象的内部状态，并在将来恢复，大多数软件提供的保存、打开，以及编辑过程中的Undo、Redo都是备忘录模式的应用。\n\n\n\n定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n\n观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub/Sub）。它是一种通知机制，让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。\n要理解观察者模式，我们还是看例子。\n假设一个电商网站，有多种Product（商品），同时，Customer（消费者）和Admin（管理员）对商品上架、价格改变都感兴趣，希望能第一时间获得通知。于是，Store（商场）可以这么写：\n123456789101112131415161718192021222324public class Store &#123;    Customer customer;    Admin admin;    private Map&lt;String, Product&gt; products = new HashMap&lt;&gt;();    public void addNewProduct(String name, double price) &#123;        Product p = new Product(name, price);        products.put(p.getName(), p);        // 通知用户:        customer.onPublished(p);        // 通知管理员:        admin.onPublished(p);    &#125;    public void setProductPrice(String name, double price) &#123;        Product p = products.get(name);        p.setPrice(price);        // 通知用户:        customer.onPriceChanged(p);        // 通知管理员:        admin.onPriceChanged(p);    &#125;&#125;\n我们观察上述Store类的问题：它直接引用了Customer和Admin。先不考虑多个Customer或多个Admin的问题，上述Store类最大的问题是，如果要加一个新的观察者类型，例如工商局管理员，Store类就必须继续改动。\n因此，上述问题的本质是Store希望发送通知给那些关心Product的对象，但Store并不想知道这些人是谁。观察者模式就是要分离被观察者和观察者之间的耦合关系。\n要实现这一目标也很简单，Store不能直接引用Customer和Admin，相反，它引用一个ProductObserver接口，任何人想要观察Store，只要实现该接口，并且把自己注册到Store即可：\n12345678910111213141516171819202122232425262728public class Store &#123;    private List&lt;ProductObserver&gt; observers = new ArrayList&lt;&gt;();    private Map&lt;String, Product&gt; products = new HashMap&lt;&gt;();    // 注册观察者:    public void addObserver(ProductObserver observer) &#123;        this.observers.add(observer);    &#125;    // 取消注册:    public void removeObserver(ProductObserver observer) &#123;        this.observers.remove(observer);    &#125;    public void addNewProduct(String name, double price) &#123;        Product p = new Product(name, price);        products.put(p.getName(), p);        // 通知观察者:        observers.forEach(o -&gt; o.onPublished(p));    &#125;    public void setProductPrice(String name, double price) &#123;        Product p = products.get(name);        p.setPrice(price);        // 通知观察者:        observers.forEach(o -&gt; o.onPriceChanged(p));    &#125;&#125;\n就是这么一个小小的改动，使得观察者类型就可以无限扩充，而且，观察者的定义可以放到客户端：\n12345678// observer:Admin a = new Admin();Customer c = new Customer();// store:Store store = new Store();// 注册观察者:store.addObserver(a);store.addObserver(c);\n甚至可以注册匿名观察者：\n123456789store.addObserver(new ProductObserver() &#123;    public void onPublished(Product product) &#123;        System.out.println(&quot;[Log] on product published: &quot; + product);    &#125;    public void onPriceChanged(Product product) &#123;        System.out.println(&quot;[Log] on product price changed: &quot; + product);    &#125;&#125;);\n用一张图画出观察者模式：\n12345678910┌─────────┐      ┌───────────────┐│  Store  │─ ─ ─▶│ProductObserver│└─────────┘      └───────────────┘     │                   ▲                         │     │             ┌─────┴─────┐     ▼             │           │┌─────────┐   ┌─────────┐ ┌─────────┐│ Product │   │  Admin  │ │Customer │ ...└─────────┘   └─────────┘ └─────────┘\n观察者模式也有很多变体形式。有的观察者模式把被观察者也抽象出接口：\n1234public interface ProductObservable &#123; // 注意此处拼写是Observable不是Observer!    void addObserver(ProductObserver observer);    void removeObserver(ProductObserver observer);&#125;\n对应的实体被观察者就要实现该接口：\n123public class Store implements ProductObservable &#123;    ...&#125;\n有些观察者模式把通知变成一个Event对象，从而不再有多种方法通知，而是统一成一种：\n123public interface ProductObserver &#123;    void onEvent(ProductEvent event);&#125;\n让观察者自己从Event对象中读取通知类型和通知数据。\n广义的观察者模式包括所有消息系统。所谓消息系统，就是把观察者和被观察者完全分离，通过消息系统本身来通知：\n12345678910111213                 ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐                   Messaging System                 │                       │                    ┌──────────────────┐              ┌──┼─▶│Topic:newProduct  │─┼─┐   ┌─────────┐              │     └──────────────────┘   ├──▶│ConsumerA│┌─────────┐   │  │  ┌──────────────────┐ │ │   └─────────┘│Producer │───┼────▶│Topic:priceChanged│───┘└─────────┘   │  │  └──────────────────┘ │              │     ┌──────────────────┐       ┌─────────┐              └──┼─▶│Topic:soldOut     │─┼────▶│ConsumerB│                    └──────────────────┘       └─────────┘                 └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘\n消息发送方称为Producer，消息接收方称为Consumer，Producer发送消息的时候，必须选择发送到哪个Topic。Consumer可以订阅自己感兴趣的Topic，从而只获得特定类型的消息。\n使用消息系统实现观察者模式时，Producer和Consumer甚至经常不在同一台机器上，并且双方对对方完全一无所知，因为注册观察者这个动作本身都在消息系统中完成，而不是在Producer内部完成。\n此外，注意到我们在编写观察者模式的时候，通知Observer是依靠语句：\n1observers.forEach(o -&gt; o.onPublished(p));\n这说明各个观察者是依次获得的同步通知，如果上一个观察者处理太慢，会导致下一个观察者不能及时获得通知。此外，如果观察者在处理通知的时候，发生了异常，还需要被观察者处理异常，才能保证继续通知下一个观察者。\n思考：如何改成异步通知，使得所有观察者可以并发同时处理？\n有的童鞋可能发现Java标准库有个java.util.Observable类和一个Observer接口，用来帮助我们实现观察者模式。但是，这个类非常不！好！用！实现观察者模式的时候，也不推荐借助这两个东东。\n练习\n给Store增加一种类型的观察者，并把通知改为异步。\n下载练习\n小结\n观察者模式，又称发布-订阅模式，是一种一对多的通知机制，使得双方无需关心对方，只关心通知本身。\n状态\n\n允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。\n\n状态模式（State）经常用在带有状态的对象中。\n什么是状态？我们以QQ聊天为例，一个用户的QQ有几种状态：\n\n离线状态（尚未登录）；\n正在登录状态；\n在线状态；\n忙状态（暂时离开）。\n\n如何表示状态？我们定义一个enum就可以表示不同的状态。但不同的状态需要对应不同的行为，比如收到消息时：\n12345if (state == ONLINE) &#123;    // 闪烁图标&#125; else if (state == BUSY) &#123;    reply(&quot;现在忙，稍后回复&quot;);&#125; else if ...\n状态模式的目的是为了把上述一大串if...else...的逻辑给分拆到不同的状态类中，使得将来增加状态比较容易。\n例如，我们设计一个聊天机器人，它有两个状态：\n\n未连线；\n已连线。\n\n对于未连线状态，我们收到消息也不回复：\n123456789public class DisconnectedState implements State &#123;    public String init() &#123;        return &quot;Bye!&quot;;    &#125;    public String reply(String input) &#123;        return &quot;&quot;;    &#125;&#125;\n对于已连线状态，我们回应收到的消息：\n123456789101112131415public class ConnectedState implements State &#123;    public String init() &#123;        return &quot;Hello, I&#x27;m Bob.&quot;;    &#125;    public String reply(String input) &#123;        if (input.endsWith(&quot;?&quot;)) &#123;            return &quot;Yes. &quot; + input.substring(0, input.length() - 1) + &quot;!&quot;;        &#125;        if (input.endsWith(&quot;.&quot;)) &#123;            return input.substring(0, input.length() - 1) + &quot;!&quot;;        &#125;        return input.substring(0, input.length() - 1) + &quot;?&quot;;    &#125;&#125;\n状态模式的关键设计思想在于状态切换，我们引入一个BotContext完成状态切换：\n12345678910111213141516public class BotContext &#123;\tprivate State state = new DisconnectedState();\tpublic String chat(String input) &#123;\t\tif (&quot;hello&quot;.equalsIgnoreCase(input)) &#123;            // 收到hello切换到在线状态:\t\t\tstate = new ConnectedState();\t\t\treturn state.init();\t\t&#125; else if (&quot;bye&quot;.equalsIgnoreCase(input)) &#123;            /  收到bye切换到离线状态:\t\t\tstate = new DisconnectedState();\t\t\treturn state.init();\t\t&#125;\t\treturn state.reply(input);\t&#125;&#125;\n这样，一个价值千万的AI聊天机器人就诞生了：\n12345678Scanner scanner = new Scanner(System.in);BotContext bot = new BotContext();for (;;) &#123;    System.out.print(&quot;&gt; &quot;);    String input = scanner.nextLine();    String output = bot.chat(input);    System.out.println(output.isEmpty() ? &quot;(no reply)&quot; : &quot;&lt; &quot; + output);&#125;\n试试效果：\n12345678&gt; hello&lt; Hello, I&#x27;m Bob.&gt; Nice to meet you.&lt; Nice to meet you!&gt; Today is cold?&lt; Yes. Today is cold!&gt; bye&lt; Bye!\n练习\n新增BusyState状态表示忙碌。\n下载练习\n小结\n状态模式的设计思想是把不同状态的逻辑分离到不同的状态类中，从而使得增加新状态更容易；\n状态模式的实现关键在于状态转换。简单的状态转换可以直接由调用方指定，复杂的状态转换可以在内部根据条件触发完成。\n\n\n\n定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。\n\n策略模式：Strategy，是指，定义一组算法，并把其封装到一个对象中。然后在运行时，可以灵活的使用其中的一个算法。\n策略模式在Java标准库中应用非常广泛，我们以排序为例，看看如何通过Arrays.sort()实现忽略大小写排序：\n123456789import java.util.Arrays;public class Main &#123;    public static void main(String[] args) throws InterruptedException &#123;        String[] array = &#123; &quot;apple&quot;, &quot;Pear&quot;, &quot;Banana&quot;, &quot;orange&quot; &#125;;        Arrays.sort(array, String::compareToIgnoreCase);        System.out.println(Arrays.toString(array));    &#125;&#125;\n如果我们想忽略大小写排序，就传入String::compareToIgnoreCase，如果我们想倒序排序，就传入(s1, s2) -&gt; -s1.compareTo(s2)，这个比较两个元素大小的算法就是策略。\n我们观察Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)这个排序方法，它在内部实现了TimSort排序，但是，排序算法在比较两个元素大小的时候，需要借助我们传入的Comparator对象，才能完成比较。因此，这里的策略是指比较两个元素大小的策略，可以是忽略大小写比较，可以是倒序比较，也可以根据字符串长度比较。\n因此，上述排序使用到了策略模式，它实际上指，在一个方法中，流程是确定的，但是，某些关键步骤的算法依赖调用方传入的策略，这样，传入不同的策略，即可获得不同的结果，大大增强了系统的灵活性。\n如果我们自己实现策略模式的排序，用冒泡法编写如下：\n123456789101112131415161718192021import java.util.*;public class Main &#123;    public static void main(String[] args) throws InterruptedException &#123;        String[] array = &#123; &quot;apple&quot;, &quot;Pear&quot;, &quot;Banana&quot;, &quot;orange&quot; &#125;;        sort(array, String::compareToIgnoreCase);        System.out.println(Arrays.toString(array));    &#125;    static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123;        for (int i = 0; i &lt; a.length - 1; i++) &#123;            for (int j = 0; j &lt; a.length - 1 - i; j++) &#123;                if (c.compare(a[j], a[j + 1]) &gt; 0) &#123; // 注意这里比较两个元素的大小依赖传入的策略                    T temp = a[j];                    a[j] = a[j + 1];                    a[j + 1] = temp;                &#125;            &#125;        &#125;    &#125;&#125;\n一个完整的策略模式要定义策略以及使用策略的上下文。我们以购物车结算为例，假设网站针对普通会员、Prime会员有不同的折扣，同时活动期间还有一个满100减20的活动，这些就可以作为策略实现。先定义打折策略接口：\n1234public interface DiscountStrategy &#123;    // 计算折扣额度:    BigDecimal getDiscount(BigDecimal total);&#125;\n接下来，就是实现各种策略。普通用户策略如下：\n123456public class UserDiscountStrategy implements DiscountStrategy &#123;    public BigDecimal getDiscount(BigDecimal total) &#123;        // 普通会员打九折:        return total.multiply(new BigDecimal(&quot;0.1&quot;)).setScale(2, RoundingMode.DOWN);    &#125;&#125;\n满减策略如下：\n123456public class OverDiscountStrategy implements DiscountStrategy &#123;    public BigDecimal getDiscount(BigDecimal total) &#123;        // 满100减20优惠:        return total.compareTo(BigDecimal.valueOf(100)) &gt;= 0 ? BigDecimal.valueOf(20) : BigDecimal.ZERO;    &#125;&#125;\n最后，要应用策略，我们需要一个DiscountContext：\n12345678910111213public class DiscountContext &#123;    // 持有某个策略:    private DiscountStrategy strategy = new UserDiscountStrategy();    // 允许客户端设置新策略:    public void setStrategy(DiscountStrategy strategy) &#123;        this.strategy = strategy;    &#125;    public BigDecimal calculatePrice(BigDecimal total) &#123;        return total.subtract(this.strategy.getDiscount(total)).setScale(2);    &#125;&#125;\n调用方必须首先创建一个DiscountContext，并指定一个策略（或者使用默认策略），即可获得折扣后的价格：\n123456789101112131415DiscountContext ctx = new DiscountContext();// 默认使用普通会员折扣:BigDecimal pay1 = ctx.calculatePrice(BigDecimal.valueOf(105));System.out.println(pay1);// 使用满减折扣:ctx.setStrategy(new OverDiscountStrategy());BigDecimal pay2 = ctx.calculatePrice(BigDecimal.valueOf(105));System.out.println(pay2);// 使用Prime会员折扣:ctx.setStrategy(new PrimeDiscountStrategy());BigDecimal pay3 = ctx.calculatePrice(BigDecimal.valueOf(105));System.out.println(pay3);\n上述完整的策略模式如下图所示：\n12345678910111213┌───────────────┐      ┌─────────────────┐│DiscountContext│─ ─ ─▶│DiscountStrategy │└───────────────┘      └─────────────────┘                                ▲                                │ ┌─────────────────────┐                                ├─│UserDiscountStrategy │                                │ └─────────────────────┘                                │ ┌─────────────────────┐                                ├─│PrimeDiscountStrategy│                                │ └─────────────────────┘                                │ ┌─────────────────────┐                                └─│OverDiscountStrategy │                                  └─────────────────────┘\n策略模式的核心思想是在一个计算方法中把容易变化的算法抽出来作为“策略”参数传进去，从而使得新增策略不必修改原有逻辑。\n练习\n使用策略模式新增一种策略，允许在满100减20的基础上对Prime会员再打七折。\n下载练习\n小结\n策略模式是为了允许调用方选择一个算法，从而通过不同策略实现不同的计算结果。\n通过扩展策略，不必修改主逻辑，即可获得新策略的结果。\n\n定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n模板方法（Template Method）是一个比较简单的模式。它的主要思想是，定义一个操作的一系列步骤，对于某些暂时确定不下来的步骤，就留给子类去实现好了，这样不同的子类就可以定义出不同的步骤。\n因此，模板方法的核心在于定义一个“骨架”。我们还是举例说明。\n假设我们开发了一个从数据库读取设置的类：\n12345678910public class Setting &#123;    public final String getSetting(String key) &#123;        String value = readFromDatabase(key);        return value;    &#125;\tprivate String readFromDatabase(String key) &#123;        // TODO: 从数据库读取    &#125;&#125;\n由于从数据库读取数据较慢，我们可以考虑把读取的设置缓存起来，这样下一次读取同样的key就不必再访问数据库了。但是怎么实现缓存，暂时没想好，但不妨碍我们先写出使用缓存的代码：\n12345678910111213141516public class Setting &#123;    public final String getSetting(String key) &#123;        // 先从缓存读取:        String value = lookupCache(key);        if (value == null) &#123;            // 在缓存中未找到,从数据库读取:            value = readFromDatabase(key);            System.out.println(&quot;[DEBUG] load from db: &quot; + key + &quot; = &quot; + value);            // 放入缓存:            putIntoCache(key, value);        &#125; else &#123;            System.out.println(&quot;[DEBUG] load from cache: &quot; + key + &quot; = &quot; + value);        &#125;        return value;    &#125;&#125;\n整个流程没有问题，但是，lookupCache(key)和putIntoCache(key, value)这两个方法还根本没实现，怎么编译通过？这个不要紧，我们声明抽象方法就可以：\n1234567891011121314public abstract class AbstractSetting &#123;    public final String getSetting(String key) &#123;        String value = lookupCache(key);        if (value == null) &#123;            value = readFromDatabase(key);            putIntoCache(key, value);        &#125;        return value;    &#125;    protected abstract String lookupCache(String key);    protected abstract void putIntoCache(String key, String value);&#125;\n因为声明了抽象方法，自然整个类也必须是抽象类。如何实现lookupCache(key)和putIntoCache(key, value)这两个方法就交给子类了。子类其实并不关心核心代码getSetting(key)的逻辑，它只需要关心如何完成两个小小的子任务就可以了。\n假设我们希望用一个Map做缓存，那么可以写一个LocalSetting：\n1234567891011public class LocalSetting extends AbstractSetting &#123;    private Map&lt;String, String&gt; cache = new HashMap&lt;&gt;();    protected String lookupCache(String key) &#123;        return cache.get(key);    &#125;    protected void putIntoCache(String key, String value) &#123;        cache.put(key, value);    &#125;&#125;\n如果我们要使用Redis做缓存，那么可以再写一个RedisSetting：\n1234567891011121314151617public class RedisSetting extends AbstractSetting &#123;    private RedisClient client = RedisClient.create(&quot;redis://localhost:6379&quot;);    protected String lookupCache(String key) &#123;        try (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;            RedisCommands&lt;String, String&gt; commands = connection.sync();            return commands.get(key);        &#125;    &#125;    protected void putIntoCache(String key, String value) &#123;        try (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;            RedisCommands&lt;String, String&gt; commands = connection.sync();            commands.set(key, value);        &#125;    &#125;&#125;\n客户端代码使用本地缓存的代码这么写：\n123AbstractSetting setting1 = new LocalSetting();System.out.println(&quot;test = &quot; + setting1.getSetting(&quot;test&quot;));System.out.println(&quot;test = &quot; + setting1.getSetting(&quot;test&quot;));\n要改成Redis缓存，只需要把LocalSetting替换为RedisSetting：\n123AbstractSetting setting2 = new RedisSetting();System.out.println(&quot;autosave = &quot; + setting2.getSetting(&quot;autosave&quot;));System.out.println(&quot;autosave = &quot; + setting2.getSetting(&quot;autosave&quot;));\n可见，模板方法的核心思想是：父类定义骨架，子类实现某些细节。\n为了防止子类重写父类的骨架方法，可以在父类中对骨架方法使用final。对于需要子类实现的抽象方法，一般声明为protected，使得这些方法对外部客户端不可见。\nJava标准库也有很多模板方法的应用。在集合类中，AbstractList和AbstractQueuedSynchronizer都定义了很多通用操作，子类只需要实现某些必要方法。\n练习\n使用模板方法增加一个使用Guava Cache的子类。\n下载练习\n思考：能否将readFromDatabase()作为模板方法，使得子类可以选择从数据库读取还是从文件读取。\n再思考如果既可以扩展缓存，又可以扩展底层存储，会不会出现子类数量爆炸的情况？如何解决？\n小结\n模板方法是一种高层定义骨架，底层实现细节的设计模式，适用于流程固定，但某些步骤不确定或可替换的情况。\n\n表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。\n\n访问者模式（Visitor）是一种操作一组对象的操作，它的目的是不改变对象的定义，但允许新增不同的访问者，来定义新的操作。\n访问者模式的设计比较复杂，如果我们查看GoF原始的访问者模式，它是这么设计的：\n123456789101112131415161718192021222324252627   ┌─────────┐       ┌───────────────────────┐   │ Client  │─ ─ ─ ▶│        Visitor        │   └─────────┘       ├───────────────────────┤        │            │visitElementA(ElementA)│                     │visitElementB(ElementB)│        │            └───────────────────────┘                                 ▲        │                ┌───────┴───────┐                         │               │        │         ┌─────────────┐ ┌─────────────┐                  │  VisitorA   │ │  VisitorB   │        │         └─────────────┘ └─────────────┘        ▼┌───────────────┐        ┌───────────────┐│ObjectStructure│─ ─ ─ ─▶│    Element    │├───────────────┤        ├───────────────┤│handle(Visitor)│        │accept(Visitor)│└───────────────┘        └───────────────┘                                 ▲                        ┌────────┴────────┐                        │                 │                ┌───────────────┐ ┌───────────────┐                │   ElementA    │ │   ElementB    │                ├───────────────┤ ├───────────────┤                │accept(Visitor)│ │accept(Visitor)│                │doA()          │ │doB()          │                └───────────────┘ └───────────────┘\n上述模式的复杂之处在于上述访问者模式为了实现所谓的“双重分派”，设计了一个回调再回调的机制。因为Java只支持基于多态的单分派模式，这里强行模拟出“双重分派”反而加大了代码的复杂性。\n这里我们只介绍简化的访问者模式。假设我们要递归遍历某个文件夹的所有子文件夹和文件，然后找出.java文件，正常的做法是写个递归：\n12345678910void scan(File dir, List&lt;File&gt; collector) &#123;    for (File file : dir.listFiles()) &#123;        if (file.isFile() &amp;&amp; file.getName().endsWith(&quot;.java&quot;)) &#123;            collector.add(file);        &#125; else if (file.isDir()) &#123;            // 递归调用:            scan(file, collector);        &#125;    &#125;&#125;\n上述代码的问题在于，扫描目录的逻辑和处理.java文件的逻辑混在了一起。如果下次需要增加一个清理.class文件的功能，就必须再重复写扫描逻辑。\n因此，访问者模式先把数据结构（这里是文件夹和文件构成的树型结构）和对其的操作（查找文件）分离开，以后如果要新增操作（例如清理.class文件），只需要新增访问者，不需要改变现有逻辑。\n用访问者模式改写上述代码步骤如下：\n首先，我们需要定义访问者接口，即该访问者能够干的事情：\n123456public interface Visitor &#123;    // 访问文件夹:    void visitDir(File dir);    // 访问文件:    void visitFile(File file);&#125;\n紧接着，我们要定义能持有文件夹和文件的数据结构FileStructure：\n1234567public class FileStructure &#123;    // 根目录:    private File path;    public FileStructure(File path) &#123;        this.path = path;    &#125;&#125;\n然后，我们给FileStructure增加一个handle()方法，传入一个访问者：\n123456789101112131415161718192021public class FileStructure &#123;    ...    public void handle(Visitor visitor) &#123;\t\tscan(this.path, visitor);\t&#125;\tprivate void scan(File file, Visitor visitor) &#123;\t\tif (file.isDirectory()) &#123;            // 让访问者处理文件夹:\t\t\tvisitor.visitDir(file);\t\t\tfor (File sub : file.listFiles()) &#123;                // 递归处理子文件夹:\t\t\t\tscan(sub, visitor);\t\t\t&#125;\t\t&#125; else if (file.isFile()) &#123;            // 让访问者处理文件:\t\t\tvisitor.visitFile(file);\t\t&#125;\t&#125;&#125;\n这样，我们就把访问者的行为抽象出来了。如果我们要实现一种操作，例如，查找.java文件，就传入JavaFileVisitor：\n12FileStructure fs = new FileStructure(new File(&quot;.&quot;));fs.handle(new JavaFileVisitor());\n这个JavaFileVisitor实现如下：\n1234567891011public class JavaFileVisitor implements Visitor &#123;    public void visitDir(File dir) &#123;        System.out.println(&quot;Visit dir: &quot; + dir);    &#125;    public void visitFile(File file) &#123;        if (file.getName().endsWith(&quot;.java&quot;)) &#123;            System.out.println(&quot;Found java file: &quot; + file);        &#125;    &#125;&#125;\n类似的，如果要清理.class文件，可以再写一个ClassFileClearnerVisitor：\n12345678910public class ClassFileCleanerVisitor implements Visitor &#123;\tpublic void visitDir(File dir) &#123;\t&#125;\tpublic void visitFile(File file) &#123;\t\tif (file.getName().endsWith(&quot;.class&quot;)) &#123;\t\t\tSystem.out.println(&quot;Will clean class file: &quot; + file);\t\t&#125;\t&#125;&#125;\n可见，访问者模式的核心思想是为了访问比较复杂的数据结构，不去改变数据结构，而是把对数据的操作抽象出来，在“访问”的过程中以回调形式在访问者中处理操作逻辑。如果要新增一组操作，那么只需要增加一个新的访问者。\n实际上，Java标准库提供的Files.walkFileTree()已经实现了一个访问者模式：\n1234567891011121314151617181920212223242526import java.io.*;import java.nio.file.*;import java.nio.file.attribute.*;public class Main &#123;    public static void main(String[] args) throws IOException &#123;        Files.walkFileTree(Paths.get(&quot;.&quot;), new MyFileVisitor());    &#125;&#125;// 实现一个FileVisitor:class MyFileVisitor extends SimpleFileVisitor&lt;Path&gt; &#123;    // 处理Directory:    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException &#123;        System.out.println(&quot;pre visit dir: &quot; + dir);        // 返回CONTINUE表示继续访问:        return FileVisitResult.CONTINUE;    &#125;    // 处理File:    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;        System.out.println(&quot;visit file: &quot; + file);        // 返回CONTINUE表示继续访问:        return FileVisitResult.CONTINUE;    &#125;&#125;\nFiles.walkFileTree()允许访问者返回FileVisitResult.CONTINUE以便继续访问，或者返回FileVisitResult.TERMINATE停止访问。\n类似的，对XML的SAX处理也是一个访问者模式，我们需要提供一个SAX Handler作为访问者处理XML的各个节点。\n练习\n使用访问者模式递归遍历文件夹。\n下载练习\n小结\n访问者模式是为了抽象出作用于一组复杂对象的操作，并且后续可以新增操作而不必对现有的对象结构做任何改动。\n","dateCreated":"2025-05-24T18:29:15+08:00","dateModified":"2025-05-24T18:41:15+08:00","datePublished":"2025-05-24T18:29:15+08:00","description":"","headline":"JAVA-设计模式-行为型模式","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://chankein.github.io/2025/05/24/Java/JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},"publisher":{"@type":"Organization","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg","logo":{"@type":"ImageObject","url":"profile.jpg"}},"url":"https://chankein.github.io/2025/05/24/Java/JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/","keywords":"Java"}</script>
    <meta name="description" content="行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。 行为型模式有：  责任链 命令 解释器 迭代器 中介 备忘录 观察者 状态 策略 模板方法 访问者   使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。  责任链模式（Chain of">
<meta property="og:type" content="blog">
<meta property="og:title" content="JAVA-设计模式-行为型模式">
<meta property="og:url" content="https://chankein.github.io/2025/05/24/Java/JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:description" content="行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。 行为型模式有：  责任链 命令 解释器 迭代器 中介 备忘录 观察者 状态 策略 模板方法 访问者   使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。  责任链模式（Chain of">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/design-patterns/behavioral/mediator/order.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/design-patterns/behavioral/mediator/mediator.png">
<meta property="article:published_time" content="2025-05-24T10:29:15.000Z">
<meta property="article:modified_time" content="2025-05-24T10:41:15.404Z">
<meta property="article:author" content="Kein Chan">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liaoxuefeng.com/books/java/design-patterns/behavioral/mediator/order.png">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../../../#about"
            >
        
        
            <img class="header-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            JAVA-设计模式-行为型模式
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2025-05-24T18:29:15+08:00">
	
		    2025 年 5 月 24 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/">Java</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。</p>
<p>行为型模式有：</p>
<ul>
<li>责任链</li>
<li>命令</li>
<li>解释器</li>
<li>迭代器</li>
<li>中介</li>
<li>备忘录</li>
<li>观察者</li>
<li>状态</li>
<li>策略</li>
<li>模板方法</li>
<li>访问者</li>
</ul>
<blockquote>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>
</blockquote>
<p>责任链模式（Chain of Responsibility）是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">     ┌─────────┐</span><br><span class="line">     │ Request │</span><br><span class="line">     └─────────┘</span><br><span class="line">          │</span><br><span class="line">┌ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┐</span><br><span class="line">          ▼</span><br><span class="line">│  ┌─────────────┐  │</span><br><span class="line">   │ ProcessorA  │</span><br><span class="line">│  └─────────────┘  │</span><br><span class="line">          │</span><br><span class="line">│         ▼         │</span><br><span class="line">   ┌─────────────┐</span><br><span class="line">│  │ ProcessorB  │  │</span><br><span class="line">   └─────────────┘</span><br><span class="line">│         │         │</span><br><span class="line">          ▼</span><br><span class="line">│  ┌─────────────┐  │</span><br><span class="line">   │ ProcessorC  │</span><br><span class="line">│  └─────────────┘  │</span><br><span class="line">          │</span><br><span class="line">└ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┘</span><br><span class="line">          │</span><br><span class="line">          ▼</span><br></pre></td></tr></table></figure>
<p>在实际场景中，财务审批就是一个责任链模式。假设某个员工需要报销一笔费用，审核者可以分为：</p>
<ul>
<li>Manager：只能审核1000元以下的报销；</li>
<li>Director：只能审核10000元以下的报销；</li>
<li>CEO：可以审核任意额度。</li>
</ul>
<p>用责任链模式设计此报销流程时，每个审核者只关心自己责任范围内的请求，并且处理它。对于超出自己责任范围的，扔给下一个审核者处理，这样，将来继续添加审核者的时候，不用改动现有逻辑。</p>
<p>我们来看看如何实现责任链模式。</p>
<p>首先，我们要抽象出请求对象，它将在责任链上传递：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Request</span><span class="params">(String name, BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getAmount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，我们要抽象出处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="comment">// 返回Boolean.TRUE = 成功</span></span><br><span class="line">    <span class="comment">// 返回Boolean.FALSE = 拒绝</span></span><br><span class="line">    <span class="comment">// 返回null = 交下一个处理</span></span><br><span class="line">	Boolean <span class="title function_">process</span><span class="params">(Request request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且做好约定：如果返回<code>Boolean.TRUE</code>，表示处理成功，如果返回<code>Boolean.FALSE</code>，表示处理失败（请求被拒绝），如果返回<code>null</code>，则交由下一个<code>Handler</code>处理。</p>
<p>然后，依次编写ManagerHandler、DirectorHandler和CEOHandler。以ManagerHandler为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManagerHandler</span> <span class="keyword">implements</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">process</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果超过1000元，处理不了，交下一个处理:</span></span><br><span class="line">        <span class="keyword">if</span> (request.getAmount().compareTo(BigDecimal.valueOf(<span class="number">1000</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对Bob有偏见:</span></span><br><span class="line">        <span class="keyword">return</span> !request.getName().equalsIgnoreCase(<span class="string">&quot;bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了不同的<code>Handler</code>后，我们还要把这些<code>Handler</code>组合起来，变成一个链，并通过一个统一入口处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerChain</span> &#123;</span><br><span class="line">    <span class="comment">// 持有所有Handler:</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Handler&gt; handlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHandler</span><span class="params">(Handler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.handlers.add(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="comment">// 依次调用每个Handler:</span></span><br><span class="line">        <span class="keyword">for</span> (Handler handler : handlers) &#123;</span><br><span class="line">            <span class="type">Boolean</span> <span class="variable">r</span> <span class="operator">=</span> handler.process(request);</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果返回TRUE或FALSE，处理结束:</span></span><br><span class="line">                System.out.println(request + <span class="string">&quot; &quot;</span> + (r ? <span class="string">&quot;Approved by &quot;</span> : <span class="string">&quot;Denied by &quot;</span>) + handler.getClass().getSimpleName());</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Could not handle request: &quot;</span> + request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们就可以在客户端组装出责任链，然后用责任链来处理请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造责任链:</span></span><br><span class="line"><span class="type">HandlerChain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerChain</span>();</span><br><span class="line">chain.addHandler(<span class="keyword">new</span> <span class="title class_">ManagerHandler</span>());</span><br><span class="line">chain.addHandler(<span class="keyword">new</span> <span class="title class_">DirectorHandler</span>());</span><br><span class="line">chain.addHandler(<span class="keyword">new</span> <span class="title class_">CEOHandler</span>());</span><br><span class="line"><span class="comment">// 处理请求:</span></span><br><span class="line">chain.process(<span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&quot;Bob&quot;</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.45&quot;</span>)));</span><br><span class="line">chain.process(<span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&quot;Alice&quot;</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1234.56&quot;</span>)));</span><br><span class="line">chain.process(<span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&quot;Bill&quot;</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;12345.67&quot;</span>)));</span><br><span class="line">chain.process(<span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&quot;John&quot;</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123456.78&quot;</span>)));</span><br></pre></td></tr></table></figure>
<p>责任链模式本身很容易理解，需要注意的是，<code>Handler</code>添加的顺序很重要，如果顺序不对，处理的结果可能就不是符合要求的。</p>
<p>此外，责任链模式有很多变种。有些责任链的实现方式是通过某个<code>Handler</code>手动调用下一个<code>Handler</code>来传递<code>Request</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AHandler</span> <span class="keyword">implements</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Handler next;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!canProcess(request)) &#123;</span><br><span class="line">            <span class="comment">// 手动交给下一个Handler处理:</span></span><br><span class="line">            next.process(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一些责任链模式，每个<code>Handler</code>都有机会处理<code>Request</code>，通常这种责任链被称为拦截器（Interceptor）或者过滤器（Filter），它的目的不是找到某个<code>Handler</code>处理掉<code>Request</code>，而是每个<code>Handler</code>都做一些工作，比如：</p>
<ul>
<li>记录日志；</li>
<li>检查权限；</li>
<li>准备相关资源；</li>
<li>…</li>
</ul>
<p>例如，JavaEE的Servlet规范定义的<code>Filter</code>就是一种责任链模式，它不但允许每个<code>Filter</code>都有机会处理请求，还允许每个<code>Filter</code>决定是否将请求“放行”给下一个<code>Filter</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuditFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        log(req);</span><br><span class="line">        <span class="keyword">if</span> (check(req)) &#123;</span><br><span class="line">            <span class="comment">// 放行:</span></span><br><span class="line">            chain.doFilter(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拒绝:</span></span><br><span class="line">            sendError(resp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种模式不但允许一个<code>Filter</code>自行决定处理<code>ServletRequest</code>和<code>ServletResponse</code>，还可以“伪造”<code>ServletRequest</code>和<code>ServletResponse</code>以便让下一个<code>Filter</code>处理，能实现非常复杂的功能。</p>
<h3 id="练习">练习</h3>
<p>使用责任链模式实现审批。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/chain-of-responsibility/pattern-chain-of-responsibility.zip">下载练习</a></p>
<h3 id="小结">小结</h3>
<p>责任链模式是一种把多个处理器组合在一起，依次处理请求的模式；</p>
<p>责任链模式的好处是添加新的处理器或者重新排列处理器非常容易；</p>
<p>责任链模式经常用在拦截、预处理请求等。</p>
<blockquote>
<p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p>
</blockquote>
<p>命令模式（Command）是指，把请求封装成一个命令，然后执行该命令。</p>
<p>在使用命令模式前，我们先以一个编辑器为例子，看看如何实现简单的编辑操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paste</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> getFromClipBoard();</span><br><span class="line">        add(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        buffer.append(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.deleteCharAt(buffer.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用一个<code>StringBuilder</code>模拟一个文本编辑器，它支持<code>copy()</code>、<code>paste()</code>、<code>add()</code>、<code>delete()</code>等方法。</p>
<p>正常情况，我们像这样调用<code>TextEditor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TextEditor</span> <span class="variable">editor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextEditor</span>();</span><br><span class="line">editor.add(<span class="string">&quot;Command pattern in text editor.\n&quot;</span>);</span><br><span class="line">editor.copy();</span><br><span class="line">editor.paste();</span><br><span class="line">System.out.println(editor.getState());</span><br></pre></td></tr></table></figure>
<p>这是直接调用方法，调用方需要了解<code>TextEditor</code>的所有接口信息。</p>
<p>如果改用命令模式，我们就要把调用方发送命令和执行方执行命令分开。怎么分？</p>
<p>解决方案是引入一个<code>Command</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方创建一个对应的<code>Command</code>，然后执行，并不关心内部是如何具体执行的。</p>
<p>为了支持<code>CopyCommand</code>和<code>PasteCommand</code>这两个命令，我们从<code>Command</code>接口派生：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="comment">// 持有执行者对象:</span></span><br><span class="line">    <span class="keyword">private</span> TextEditor receiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CopyCommand</span><span class="params">(TextEditor receiver)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.copy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PasteCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TextEditor receiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PasteCommand</span><span class="params">(TextEditor receiver)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.paste();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们把<code>Command</code>和<code>TextEditor</code>组装一下，客户端这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TextEditor</span> <span class="variable">editor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextEditor</span>();</span><br><span class="line">editor.add(<span class="string">&quot;Command pattern in text editor.\n&quot;</span>);</span><br><span class="line"><span class="comment">// 执行一个CopyCommand:</span></span><br><span class="line"><span class="type">Command</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CopyCommand</span>(editor);</span><br><span class="line">copy.execute();</span><br><span class="line">editor.add(<span class="string">&quot;----\n&quot;</span>);</span><br><span class="line"><span class="comment">// 执行一个PasteCommand:</span></span><br><span class="line"><span class="type">Command</span> <span class="variable">paste</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PasteCommand</span>(editor);</span><br><span class="line">paste.execute();</span><br><span class="line">System.out.println(editor.getState());</span><br></pre></td></tr></table></figure>
<p>这就是命令模式的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌──────┐      ┌───────┐</span><br><span class="line">│Client│─ ─ ─▶│Command│</span><br><span class="line">└──────┘      └───────┘</span><br><span class="line">                  │  ┌──────────────┐</span><br><span class="line">                  ├─▶│ CopyCommand  │</span><br><span class="line">                  │  ├──────────────┤</span><br><span class="line">                  │  │editor.copy() │─ ┐</span><br><span class="line">                  │  └──────────────┘</span><br><span class="line">                  │                    │  ┌────────────┐</span><br><span class="line">                  │  ┌──────────────┐   ─▶│ TextEditor │</span><br><span class="line">                  └─▶│ PasteCommand │  │  └────────────┘</span><br><span class="line">                     ├──────────────┤</span><br><span class="line">                     │editor.paste()│─ ┘</span><br><span class="line">                     └──────────────┘</span><br></pre></td></tr></table></figure>
<p>有的童鞋会有疑问：搞了一大堆<code>Command</code>，多了好几个类，还不如直接这么写简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TextEditor</span> <span class="variable">editor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextEditor</span>();</span><br><span class="line">editor.add(<span class="string">&quot;Command pattern in text editor.\n&quot;</span>);</span><br><span class="line">editor.copy();</span><br><span class="line">editor.paste();</span><br></pre></td></tr></table></figure>
<p>实际上，使用命令模式，确实增加了系统的复杂度。如果需求很简单，那么直接调用显然更直观而且更简单。</p>
<p>那么我们还需要命令模式吗？</p>
<p>答案是视需求而定。如果<code>TextEditor</code>复杂到一定程度，并且需要支持Undo、Redo的功能时，就需要使用命令模式，因为我们可以给每个命令增加<code>undo()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后把执行的一系列命令用<code>List</code>保存起来，就既能支持Undo，又能支持Redo。这个时候，我们又需要一个<code>Invoker</code>对象，负责执行命令并保存历史命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐</span><br><span class="line">│   Client    │</span><br><span class="line">└─────────────┘</span><br><span class="line">       │</span><br><span class="line"></span><br><span class="line">       │</span><br><span class="line">       ▼</span><br><span class="line">┌─────────────┐</span><br><span class="line">│   Invoker   │</span><br><span class="line">├─────────────┤    ┌───────┐</span><br><span class="line">│List commands│─ ─▶│Command│</span><br><span class="line">│invoke(c)    │    └───────┘</span><br><span class="line">│undo()       │        │  ┌──────────────┐</span><br><span class="line">└─────────────┘        ├─▶│ CopyCommand  │</span><br><span class="line">                       │  ├──────────────┤</span><br><span class="line">                       │  │editor.copy() │─ ┐</span><br><span class="line">                       │  └──────────────┘</span><br><span class="line">                       │                    │  ┌────────────┐</span><br><span class="line">                       │  ┌──────────────┐   ─▶│ TextEditor │</span><br><span class="line">                       └─▶│ PasteCommand │  │  └────────────┘</span><br><span class="line">                          ├──────────────┤</span><br><span class="line">                          │editor.paste()│─ ┘</span><br><span class="line">                          └──────────────┘</span><br></pre></td></tr></table></figure>
<p>可见，模式带来的设计复杂度的增加是随着需求而增加的，它减少的是系统各组件的耦合度。</p>
<h3 id="练习-2">练习</h3>
<p>给命令模式新增Add和Delete命令并支持Undo、Redo操作。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/command/pattern-command.zip">下载练习</a></p>
<h3 id="小结-2">小结</h3>
<p>命令模式的设计思想是把命令的创建和执行分离，使得调用者无需关心具体的执行过程。</p>
<p>通过封装<code>Command</code>对象，命令模式可以保存已执行的命令，从而支持撤销、重做等操作。</p>
<h2 id="解释器">解释器</h2>
<blockquote>
<p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>
</blockquote>
<p>解释器模式（Interpreter）是一种针对特定问题设计的一种解决方案。例如，匹配字符串的时候，由于匹配条件非常灵活，使得通过代码来实现非常不灵活。举个例子，针对以下的匹配条件：</p>
<ul>
<li>以<code>+</code>开头的数字表示的区号和电话号码，如<code>+861012345678</code>；</li>
<li>以英文开头，后接英文和数字，并以.分隔的域名，如<code>www.liaoxuefeng.com</code>；</li>
<li>以<code>/</code>开头的文件路径，如<code>/path/to/file.txt</code>；</li>
<li>…</li>
</ul>
<p>因此，需要一种通用的表示方法——正则表达式来进行匹配。正则表达式就是一个字符串，但要把正则表达式解析为语法树，然后再匹配指定的字符串，就需要一个解释器。</p>
<p>实现一个完整的正则表达式的解释器非常复杂，但是使用解释器模式却很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;+861012345678&quot;</span>;</span><br><span class="line">System.out.println(s.matches(<span class="string">&quot;^\\+\\d+$&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>类似的，当我们使用JDBC时，执行的SQL语句虽然是字符串，但最终需要数据库服务器的SQL解释器来把SQL“翻译”成数据库服务器能执行的代码，这个执行引擎也非常复杂，但对于使用者来说，仅仅需要写出SQL字符串即可。</p>
<h3 id="练习-3">练习</h3>
<p>请实现一个简单的解释器，它可以以SLF4J的日志格式输出字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="string">&quot;[&#123;&#125;] start &#123;&#125; at &#123;&#125;...&quot;</span>, LocalTime.now().withNano(<span class="number">0</span>), <span class="string">&quot;engine&quot;</span>, LocalDate.now());</span><br><span class="line"><span class="comment">// [11:02:18] start engine at 2020-02-21...</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/interpreter/pattern-interpreter.zip">下载练习</a></p>
<h3 id="小结-3">小结</h3>
<p>解释器模式通过抽象语法树实现对用户输入的解释执行。</p>
<p>解释器模式的实现通常非常复杂，且一般只能解决一类特定问题。</p>
<hr>
<hr>
<h2 id="迭代器">迭代器</h2>
<blockquote>
<p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p>
</blockquote>
<p>迭代器模式（Iterator）实际上在Java的集合类中已经广泛使用了。我们以<code>List</code>为例，要遍历<code>ArrayList</code>，即使我们知道它的内部存储了一个<code>Object[]</code>数组，也不应该直接使用数组索引去遍历，因为这样需要了解集合内部的存储结构。如果使用<code>Iterator</code>遍历，那么，<code>ArrayList</code>和<code>LinkedList</code>都可以以一种统一的接口来遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = ...</span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，因为Iterator模式十分有用，因此，Java允许我们直接把任何支持<code>Iterator</code>的集合对象用<code>foreach</code>循环写出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = ...</span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后由Java编译器完成Iterator模式的所有循环代码。</p>
<p>虽然我们对如何使用Iterator有了一定了解，但如何实现一个Iterator模式呢？我们以一个自定义的集合为例，通过Iterator模式实现倒序遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseArrayCollection</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 以数组形式持有集合:</span></span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReverseArrayCollection</span><span class="params">(T... objs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = Arrays.copyOfRange(objs, <span class="number">0</span>, objs.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ???;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现Iterator模式的关键是返回一个<code>Iterator</code>对象，该对象知道集合的内部结构，因为它可以实现倒序遍历。我们使用Java的内部类实现这个<code>Iterator</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseArrayCollection</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReverseArrayCollection</span><span class="params">(T... objs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = Arrays.copyOfRange(objs, <span class="number">0</span>, objs.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReverseIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ReverseIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="comment">// 索引位置:</span></span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ReverseIterator</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 创建Iterator时,索引在数组末尾:</span></span><br><span class="line">            <span class="built_in">this</span>.index = ReverseArrayCollection.<span class="built_in">this</span>.array.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 如果索引大于0,那么可以移动到下一个元素(倒序往前移动):</span></span><br><span class="line">            <span class="keyword">return</span> index &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 将索引移动到下一个元素并返回(倒序往前移动):</span></span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">return</span> array[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用内部类的好处是内部类隐含地持有一个它所在对象的<code>this</code>引用，可以通过<code>ReverseArrayCollection.this</code>引用到它所在的集合。上述代码实现的逻辑非常简单，但是实际应用时，如果考虑到多线程访问，当一个线程正在迭代某个集合，而另一个线程修改了集合的内容时，是否能继续安全地迭代，还是抛出<code>ConcurrentModificationException</code>，就需要更仔细地设计。</p>
<h3 id="练习-4">练习</h3>
<p>使用Iterator模式实现集合的倒序遍历。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/iterator/pattern-iterator.zip">下载练习</a></p>
<h3 id="小结-4">小结</h3>
<p>Iterator模式常用于遍历集合，它允许集合提供一个统一的<code>Iterator</code>接口来遍历元素，同时保证调用者对集合内部的数据结构一无所知，从而使得调用者总是以相同的接口遍历各种不同类型的集合。</p>
<hr>
<hr>
<h2 id="中介">中介</h2>
<blockquote>
<p>用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
</blockquote>
<p>中介模式（Mediator）又称调停者模式，它的目的是把多方会谈变成双方会谈，从而实现多方的松耦合。</p>
<p>有些童鞋听到中介立刻想到房产中介，立刻气不打一处来。这个中介模式与房产中介还真有点像，所以消消气，先看例子。</p>
<p>考虑一个简单的点餐输入：</p>
<p><img src="https://liaoxuefeng.com/books/java/design-patterns/behavioral/mediator/order.png" alt="order"></p>
<p>这个小系统有4个参与对象：</p>
<ul>
<li>多选框；</li>
<li>“选择全部”按钮；</li>
<li>“取消所有”按钮；</li>
<li>“反选”按钮。</li>
</ul>
<p>它的复杂性在于，当多选框变化时，它会影响“选择全部”和“取消所有”按钮的状态（是否可点击），当用户点击某个按钮时，例如“反选”，除了会影响多选框的状态，它又可能影响“选择全部”和“取消所有”按钮的状态。</p>
<p>所以这是一个多方会谈，逻辑写起来很复杂：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────┐     ┌─────────────────┐</span><br><span class="line">│  CheckBox List  │◀───▶│SelectAll Button │</span><br><span class="line">└─────────────────┘     └─────────────────┘</span><br><span class="line">         ▲ ▲                     ▲</span><br><span class="line">         │ └─────────────────────┤</span><br><span class="line">         ▼                       │</span><br><span class="line">┌─────────────────┐     ┌────────┴────────┐</span><br><span class="line">│SelectNone Button│◀────│ Inverse Button  │</span><br><span class="line">└─────────────────┘     └─────────────────┘</span><br></pre></td></tr></table></figure>
<p>如果我们引入一个中介，把多方会谈变成多个双方会谈，虽然多了一个对象，但对象之间的关系就变简单了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">            ┌─────────────────┐</span><br><span class="line">     ┌─────▶│  CheckBox List  │</span><br><span class="line">     │      └─────────────────┘</span><br><span class="line">     │      ┌─────────────────┐</span><br><span class="line">     │ ┌───▶│SelectAll Button │</span><br><span class="line">     ▼ ▼    └─────────────────┘</span><br><span class="line">┌─────────┐</span><br><span class="line">│Mediator │</span><br><span class="line">└─────────┘</span><br><span class="line">     ▲ ▲    ┌─────────────────┐</span><br><span class="line">     │ └───▶│SelectNone Button│</span><br><span class="line">     │      └─────────────────┘</span><br><span class="line">     │      ┌─────────────────┐</span><br><span class="line">     └─────▶│ Inverse Button  │</span><br><span class="line">            └─────────────────┘</span><br></pre></td></tr></table></figure>
<p>下面我们用中介模式来实现各个UI组件的交互。首先把UI组件给画出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">OrderFrame</span>(<span class="string">&quot;Hanburger&quot;</span>, <span class="string">&quot;Nugget&quot;</span>, <span class="string">&quot;Chip&quot;</span>, <span class="string">&quot;Coffee&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderFrame</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderFrame</span><span class="params">(String... names)</span> &#123;</span><br><span class="line">        setTitle(<span class="string">&quot;Order&quot;</span>);</span><br><span class="line">        setSize(<span class="number">460</span>, <span class="number">200</span>);</span><br><span class="line">        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        <span class="type">Container</span> <span class="variable">c</span> <span class="operator">=</span> getContentPane();</span><br><span class="line">        c.setLayout(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>(FlowLayout.LEADING, <span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line">        c.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;Use Mediator Pattern&quot;</span>));</span><br><span class="line">        List&lt;JCheckBox&gt; checkboxList = addCheckBox(names);</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">selectAll</span> <span class="operator">=</span> addButton(<span class="string">&quot;Select All&quot;</span>);</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">selectNone</span> <span class="operator">=</span> addButton(<span class="string">&quot;Select None&quot;</span>);</span><br><span class="line">        selectNone.setEnabled(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">selectInverse</span> <span class="operator">=</span> addButton(<span class="string">&quot;Inverse Select&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Mediator</span>(checkBoxList, selectAll, selectNone, selectInverse);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;JCheckBox&gt; <span class="title function_">addCheckBox</span><span class="params">(String... names)</span> &#123;</span><br><span class="line">        <span class="type">JPanel</span> <span class="variable">panel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;Menu:&quot;</span>));</span><br><span class="line">        List&lt;JCheckBox&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            <span class="type">JCheckBox</span> <span class="variable">checkbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JCheckBox</span>(name);</span><br><span class="line">            list.add(checkbox);</span><br><span class="line">            panel.add(checkbox);</span><br><span class="line">        &#125;</span><br><span class="line">        getContentPane().add(panel);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JButton <span class="title function_">addButton</span><span class="params">(String label)</span> &#123;</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(label);</span><br><span class="line">        getContentPane().add(button);</span><br><span class="line">        <span class="keyword">return</span> button;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们设计一个Mediator类，它引用4个UI组件，并负责跟它们交互：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="comment">// 引用UI组件:</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;JCheckBox&gt; checkBoxList;</span><br><span class="line">    <span class="keyword">private</span> JButton selectAll;</span><br><span class="line">    <span class="keyword">private</span> JButton selectNone;</span><br><span class="line">    <span class="keyword">private</span> JButton selectInverse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mediator</span><span class="params">(List&lt;JCheckBox&gt; checkBoxList, JButton selectAll, JButton selectNone, JButton selectInverse)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.checkBoxList = checkBoxList;</span><br><span class="line">        <span class="built_in">this</span>.selectAll = selectAll;</span><br><span class="line">        <span class="built_in">this</span>.selectNone = selectNone;</span><br><span class="line">        <span class="built_in">this</span>.selectInverse = selectInverse;</span><br><span class="line">        <span class="comment">// 绑定事件:</span></span><br><span class="line">        <span class="built_in">this</span>.checkBoxList.forEach(checkBox -&gt; &#123;</span><br><span class="line">            checkBox.addChangeListener(<span class="built_in">this</span>::onCheckBoxChanged);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.selectAll.addActionListener(<span class="built_in">this</span>::onSelectAllClicked);</span><br><span class="line">        <span class="built_in">this</span>.selectNone.addActionListener(<span class="built_in">this</span>::onSelectNoneClicked);</span><br><span class="line">        <span class="built_in">this</span>.selectInverse.addActionListener(<span class="built_in">this</span>::onSelectInverseClicked);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当checkbox有变化时:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCheckBoxChanged</span><span class="params">(ChangeEvent event)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allChecked</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allUnchecked</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> checkBox : checkBoxList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (checkBox.isSelected()) &#123;</span><br><span class="line">                allUnchecked = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                allChecked = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        selectAll.setEnabled(!allChecked);</span><br><span class="line">        selectNone.setEnabled(!allUnchecked);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当点击select all:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSelectAllClicked</span><span class="params">(ActionEvent event)</span> &#123;</span><br><span class="line">        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(<span class="literal">true</span>));</span><br><span class="line">        selectAll.setEnabled(<span class="literal">false</span>);</span><br><span class="line">        selectNone.setEnabled(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当点击select none:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSelectNoneClicked</span><span class="params">(ActionEvent event)</span> &#123;</span><br><span class="line">        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(<span class="literal">false</span>));</span><br><span class="line">        selectAll.setEnabled(<span class="literal">true</span>);</span><br><span class="line">        selectNone.setEnabled(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当点击select inverse:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSelectInverseClicked</span><span class="params">(ActionEvent event)</span> &#123;</span><br><span class="line">        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(!checkBox.isSelected()));</span><br><span class="line">        onCheckBoxChanged(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下看看效果：</p>
<p><img src="https://liaoxuefeng.com/books/java/design-patterns/behavioral/mediator/mediator.png" alt="mediator"></p>
<p>使用Mediator模式后，我们得到了以下好处：</p>
<ul>
<li>各个UI组件互不引用，这样就减少了组件之间的耦合关系；</li>
<li>Mediator用于当一个组件发生状态变化时，根据当前所有组件的状态决定更新某些组件；</li>
<li>如果新增一个UI组件，我们只需要修改Mediator更新状态的逻辑，现有的其他UI组件代码不变。</li>
</ul>
<p>Mediator模式经常用在有众多交互组件的UI上。为了简化UI程序，MVC模式以及MVVM模式都可以看作是Mediator模式的扩展。</p>
<h3 id="练习-5">练习</h3>
<p>使用Mediator模式。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/mediator/pattern-mediator.zip">下载练习</a></p>
<h3 id="小结-5">小结</h3>
<p>中介模式是通过引入一个中介对象，把多边关系变成多个双边关系，从而简化系统组件的交互耦合度。</p>
<hr>
<hr>
<h2 id="备忘录">备忘录</h2>
<blockquote>
<p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
</blockquote>
<p>备忘录模式（Memento），主要用于捕获一个对象的内部状态，以便在将来的某个时候恢复此状态。</p>
<p>其实我们使用的几乎所有软件都用到了备忘录模式。最简单的备忘录模式就是保存到文件，打开文件。对于文本编辑器来说，保存就是把<code>TextEditor</code>类的字符串存储到文件，打开就是恢复<code>TextEditor</code>类的状态。对于图像编辑器来说，原理是一样的，只是保存和恢复的数据格式比较复杂而已。Java的序列化也可以看作是备忘录模式。</p>
<p>在使用文本编辑器的时候，我们还经常使用Undo、Redo这些功能。这些其实也可以用备忘录模式实现，即不定期地把<code>TextEditor</code>类的字符串复制一份存起来，这样就可以Undo或Redo。</p>
<p>标准的备忘录模式有这么几种角色：</p>
<ul>
<li>Memento：存储的内部状态；</li>
<li>Originator：创建一个备忘录并设置其状态；</li>
<li>Caretaker：负责保存备忘录。</li>
</ul>
<p>实际上我们在使用备忘录模式的时候，不必设计得这么复杂，只需要对类似<code>TextEditor</code>的类，增加<code>getState()</code>和<code>setState()</code>就可以了。</p>
<p>我们以一个文本编辑器<code>TextEditor</code>为例，它内部使用<code>StringBuilder</code>允许用户增删字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        buffer.append(ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        buffer.append(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.deleteCharAt(buffer.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了支持这个<code>TextEditor</code>能保存和恢复状态，我们增加<code>getState()</code>和<code>setState()</code>两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取状态:</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复状态:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.buffer.delete(<span class="number">0</span>, <span class="built_in">this</span>.buffer.length());</span><br><span class="line">        <span class="built_in">this</span>.buffer.append(state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对这个简单的文本编辑器，用一个<code>String</code>就可以表示其状态，对于复杂的对象模型，通常我们会使用JSON、XML等复杂格式。</p>
<h3 id="练习-6">练习</h3>
<p>给TextEditor添加备忘录模式。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/memento/pattern-memento.zip">下载练习</a></p>
<h3 id="小结-6">小结</h3>
<p>备忘录模式是为了保存对象的内部状态，并在将来恢复，大多数软件提供的保存、打开，以及编辑过程中的Undo、Redo都是备忘录模式的应用。</p>
<hr>
<hr>
<blockquote>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
</blockquote>
<p>观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub/Sub）。它是一种通知机制，让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。</p>
<p>要理解观察者模式，我们还是看例子。</p>
<p>假设一个电商网站，有多种<code>Product</code>（商品），同时，<code>Customer</code>（消费者）和<code>Admin</code>（管理员）对商品上架、价格改变都感兴趣，希望能第一时间获得通知。于是，<code>Store</code>（商场）可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">    Customer customer;</span><br><span class="line">    Admin admin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Product&gt; products = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNewProduct</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>(name, price);</span><br><span class="line">        products.put(p.getName(), p);</span><br><span class="line">        <span class="comment">// 通知用户:</span></span><br><span class="line">        customer.onPublished(p);</span><br><span class="line">        <span class="comment">// 通知管理员:</span></span><br><span class="line">        admin.onPublished(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProductPrice</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">p</span> <span class="operator">=</span> products.get(name);</span><br><span class="line">        p.setPrice(price);</span><br><span class="line">        <span class="comment">// 通知用户:</span></span><br><span class="line">        customer.onPriceChanged(p);</span><br><span class="line">        <span class="comment">// 通知管理员:</span></span><br><span class="line">        admin.onPriceChanged(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们观察上述<code>Store</code>类的问题：它直接引用了<code>Customer</code>和<code>Admin</code>。先不考虑多个<code>Customer</code>或多个<code>Admin</code>的问题，上述<code>Store</code>类最大的问题是，如果要加一个新的观察者类型，例如工商局管理员，<code>Store</code>类就必须继续改动。</p>
<p>因此，上述问题的本质是<code>Store</code>希望发送通知给那些关心<code>Product</code>的对象，但<code>Store</code>并不想知道这些人是谁。观察者模式就是要分离被观察者和观察者之间的耦合关系。</p>
<p>要实现这一目标也很简单，<code>Store</code>不能直接引用<code>Customer</code>和<code>Admin</code>，相反，它引用一个<code>ProductObserver</code>接口，任何人想要观察<code>Store</code>，只要实现该接口，并且把自己注册到<code>Store</code>即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ProductObserver&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Product&gt; products = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册观察者:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(ProductObserver observer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消注册:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(ProductObserver observer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNewProduct</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>(name, price);</span><br><span class="line">        products.put(p.getName(), p);</span><br><span class="line">        <span class="comment">// 通知观察者:</span></span><br><span class="line">        observers.forEach(o -&gt; o.onPublished(p));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProductPrice</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">p</span> <span class="operator">=</span> products.get(name);</span><br><span class="line">        p.setPrice(price);</span><br><span class="line">        <span class="comment">// 通知观察者:</span></span><br><span class="line">        observers.forEach(o -&gt; o.onPriceChanged(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是这么一个小小的改动，使得观察者类型就可以无限扩充，而且，观察者的定义可以放到客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observer:</span></span><br><span class="line"><span class="type">Admin</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Admin</span>();</span><br><span class="line"><span class="type">Customer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line"><span class="comment">// store:</span></span><br><span class="line"><span class="type">Store</span> <span class="variable">store</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Store</span>();</span><br><span class="line"><span class="comment">// 注册观察者:</span></span><br><span class="line">store.addObserver(a);</span><br><span class="line">store.addObserver(c);</span><br></pre></td></tr></table></figure>
<p>甚至可以注册匿名观察者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">store.addObserver(<span class="keyword">new</span> <span class="title class_">ProductObserver</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPublished</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Log] on product published: &quot;</span> + product);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPriceChanged</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Log] on product price changed: &quot;</span> + product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>用一张图画出观察者模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌─────────┐      ┌───────────────┐</span><br><span class="line">│  Store  │─ ─ ─▶│ProductObserver│</span><br><span class="line">└─────────┘      └───────────────┘</span><br><span class="line">     │                   ▲</span><br><span class="line">                         │</span><br><span class="line">     │             ┌─────┴─────┐</span><br><span class="line">     ▼             │           │</span><br><span class="line">┌─────────┐   ┌─────────┐ ┌─────────┐</span><br><span class="line">│ Product │   │  Admin  │ │Customer │ ...</span><br><span class="line">└─────────┘   └─────────┘ └─────────┘</span><br></pre></td></tr></table></figure>
<p>观察者模式也有很多变体形式。有的观察者模式把被观察者也抽象出接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductObservable</span> &#123; <span class="comment">// 注意此处拼写是Observable不是Observer!</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(ProductObserver observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(ProductObserver observer)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的实体被观察者就要实现该接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Store</span> <span class="keyword">implements</span> <span class="title class_">ProductObservable</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有些观察者模式把通知变成一个Event对象，从而不再有多种方法通知，而是统一成一种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductObserver</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(ProductEvent event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让观察者自己从Event对象中读取通知类型和通知数据。</p>
<p>广义的观察者模式包括所有消息系统。所谓消息系统，就是把观察者和被观察者完全分离，通过消息系统本身来通知：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                 ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line">                   Messaging System</span><br><span class="line">                 │                       │</span><br><span class="line">                    ┌──────────────────┐</span><br><span class="line">              ┌──┼─▶│Topic:newProduct  │─┼─┐   ┌─────────┐</span><br><span class="line">              │     └──────────────────┘   ├──▶│ConsumerA│</span><br><span class="line">┌─────────┐   │  │  ┌──────────────────┐ │ │   └─────────┘</span><br><span class="line">│Producer │───┼────▶│Topic:priceChanged│───┘</span><br><span class="line">└─────────┘   │  │  └──────────────────┘ │</span><br><span class="line">              │     ┌──────────────────┐       ┌─────────┐</span><br><span class="line">              └──┼─▶│Topic:soldOut     │─┼────▶│ConsumerB│</span><br><span class="line">                    └──────────────────┘       └─────────┘</span><br><span class="line">                 └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>
<p>消息发送方称为Producer，消息接收方称为Consumer，Producer发送消息的时候，必须选择发送到哪个Topic。Consumer可以订阅自己感兴趣的Topic，从而只获得特定类型的消息。</p>
<p>使用消息系统实现观察者模式时，Producer和Consumer甚至经常不在同一台机器上，并且双方对对方完全一无所知，因为注册观察者这个动作本身都在消息系统中完成，而不是在Producer内部完成。</p>
<p>此外，注意到我们在编写观察者模式的时候，通知Observer是依靠语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observers.forEach(o -&gt; o.onPublished(p));</span><br></pre></td></tr></table></figure>
<p>这说明各个观察者是依次获得的同步通知，如果上一个观察者处理太慢，会导致下一个观察者不能及时获得通知。此外，如果观察者在处理通知的时候，发生了异常，还需要被观察者处理异常，才能保证继续通知下一个观察者。</p>
<p>思考：如何改成异步通知，使得所有观察者可以并发同时处理？</p>
<p>有的童鞋可能发现Java标准库有个<code>java.util.Observable</code>类和一个<code>Observer</code>接口，用来帮助我们实现观察者模式。但是，这个类非常不！好！用！实现观察者模式的时候，也不推荐借助这两个东东。</p>
<h3 id="练习-7">练习</h3>
<p>给<code>Store</code>增加一种类型的观察者，并把通知改为异步。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/observer/pattern-observer.zip">下载练习</a></p>
<h3 id="小结-7">小结</h3>
<p>观察者模式，又称发布-订阅模式，是一种一对多的通知机制，使得双方无需关心对方，只关心通知本身。</p>
<h2 id="状态">状态</h2>
<blockquote>
<p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p>
</blockquote>
<p>状态模式（State）经常用在带有状态的对象中。</p>
<p>什么是状态？我们以QQ聊天为例，一个用户的QQ有几种状态：</p>
<ul>
<li>离线状态（尚未登录）；</li>
<li>正在登录状态；</li>
<li>在线状态；</li>
<li>忙状态（暂时离开）。</li>
</ul>
<p>如何表示状态？我们定义一个<code>enum</code>就可以表示不同的状态。但不同的状态需要对应不同的行为，比如收到消息时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (state == ONLINE) &#123;</span><br><span class="line">    <span class="comment">// 闪烁图标</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == BUSY) &#123;</span><br><span class="line">    reply(<span class="string">&quot;现在忙，稍后回复&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ...</span><br></pre></td></tr></table></figure>
<p>状态模式的目的是为了把上述一大串<code>if...else...</code>的逻辑给分拆到不同的状态类中，使得将来增加状态比较容易。</p>
<p>例如，我们设计一个聊天机器人，它有两个状态：</p>
<ul>
<li>未连线；</li>
<li>已连线。</li>
</ul>
<p>对于未连线状态，我们收到消息也不回复：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DisconnectedState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bye!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reply</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于已连线状态，我们回应收到的消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectedState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, I&#x27;m Bob.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reply</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input.endsWith(<span class="string">&quot;?&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Yes. &quot;</span> + input.substring(<span class="number">0</span>, input.length() - <span class="number">1</span>) + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (input.endsWith(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> input.substring(<span class="number">0</span>, input.length() - <span class="number">1</span>) + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> input.substring(<span class="number">0</span>, input.length() - <span class="number">1</span>) + <span class="string">&quot;?&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>状态模式的关键设计思想在于状态切换，我们引入一个<code>BotContext</code>完成状态切换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BotContext</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DisconnectedState</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">chat</span><span class="params">(String input)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&quot;hello&quot;</span>.equalsIgnoreCase(input)) &#123;</span><br><span class="line">            <span class="comment">// 收到hello切换到在线状态:</span></span><br><span class="line">			state = <span class="keyword">new</span> <span class="title class_">ConnectedState</span>();</span><br><span class="line">			<span class="keyword">return</span> state.init();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;bye&quot;</span>.equalsIgnoreCase(input)) &#123;</span><br><span class="line">            /  收到bye切换到离线状态:</span><br><span class="line">			state = <span class="keyword">new</span> <span class="title class_">DisconnectedState</span>();</span><br><span class="line">			<span class="keyword">return</span> state.init();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> state.reply(input);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，一个价值千万的AI聊天机器人就诞生了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">BotContext</span> <span class="variable">bot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BotContext</span>();</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">    <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> bot.chat(input);</span><br><span class="line">    System.out.println(output.isEmpty() ? <span class="string">&quot;(no reply)&quot;</span> : <span class="string">&quot;&lt; &quot;</span> + output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>试试效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello</span><br><span class="line">&lt; Hello, I&#x27;m Bob.</span><br><span class="line">&gt; Nice to meet you.</span><br><span class="line">&lt; Nice to meet you!</span><br><span class="line">&gt; Today is cold?</span><br><span class="line">&lt; Yes. Today is cold!</span><br><span class="line">&gt; bye</span><br><span class="line">&lt; Bye!</span><br></pre></td></tr></table></figure>
<h3 id="练习-8">练习</h3>
<p>新增BusyState状态表示忙碌。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/state/pattern-state.zip">下载练习</a></p>
<h3 id="小结-8">小结</h3>
<p>状态模式的设计思想是把不同状态的逻辑分离到不同的状态类中，从而使得增加新状态更容易；</p>
<p>状态模式的实现关键在于状态转换。简单的状态转换可以直接由调用方指定，复杂的状态转换可以在内部根据条件触发完成。</p>
<hr>
<hr>
<blockquote>
<p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p>
</blockquote>
<p>策略模式：Strategy，是指，定义一组算法，并把其封装到一个对象中。然后在运行时，可以灵活的使用其中的一个算法。</p>
<p>策略模式在Java标准库中应用非常广泛，我们以排序为例，看看如何通过<code>Arrays.sort()</code>实现忽略大小写排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        String[] array = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;orange&quot;</span> &#125;;</span><br><span class="line">        Arrays.sort(array, String::compareToIgnoreCase);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们想忽略大小写排序，就传入<code>String::compareToIgnoreCase</code>，如果我们想倒序排序，就传入<code>(s1, s2) -&gt; -s1.compareTo(s2)</code>，这个比较两个元素大小的算法就是策略。</p>
<p>我们观察<code>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)</code>这个排序方法，它在内部实现了TimSort排序，但是，排序算法在比较两个元素大小的时候，需要借助我们传入的<code>Comparator</code>对象，才能完成比较。因此，这里的策略是指比较两个元素大小的策略，可以是忽略大小写比较，可以是倒序比较，也可以根据字符串长度比较。</p>
<p>因此，上述排序使用到了策略模式，它实际上指，在一个方法中，流程是确定的，但是，某些关键步骤的算法依赖调用方传入的策略，这样，传入不同的策略，即可获得不同的结果，大大增强了系统的灵活性。</p>
<p>如果我们自己实现策略模式的排序，用冒泡法编写如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        String[] array = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;orange&quot;</span> &#125;;</span><br><span class="line">        sort(array, String::compareToIgnoreCase);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c.compare(a[j], a[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123; <span class="comment">// 注意这里比较两个元素的大小依赖传入的策略</span></span><br><span class="line">                    <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">                    a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                    a[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个完整的策略模式要定义策略以及使用策略的上下文。我们以购物车结算为例，假设网站针对普通会员、Prime会员有不同的折扣，同时活动期间还有一个满100减20的活动，这些就可以作为策略实现。先定义打折策略接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DiscountStrategy</span> &#123;</span><br><span class="line">    <span class="comment">// 计算折扣额度:</span></span><br><span class="line">    BigDecimal <span class="title function_">getDiscount</span><span class="params">(BigDecimal total)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，就是实现各种策略。普通用户策略如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDiscountStrategy</span> <span class="keyword">implements</span> <span class="title class_">DiscountStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getDiscount</span><span class="params">(BigDecimal total)</span> &#123;</span><br><span class="line">        <span class="comment">// 普通会员打九折:</span></span><br><span class="line">        <span class="keyword">return</span> total.multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.1&quot;</span>)).setScale(<span class="number">2</span>, RoundingMode.DOWN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>满减策略如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverDiscountStrategy</span> <span class="keyword">implements</span> <span class="title class_">DiscountStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getDiscount</span><span class="params">(BigDecimal total)</span> &#123;</span><br><span class="line">        <span class="comment">// 满100减20优惠:</span></span><br><span class="line">        <span class="keyword">return</span> total.compareTo(BigDecimal.valueOf(<span class="number">100</span>)) &gt;= <span class="number">0</span> ? BigDecimal.valueOf(<span class="number">20</span>) : BigDecimal.ZERO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，要应用策略，我们需要一个<code>DiscountContext</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscountContext</span> &#123;</span><br><span class="line">    <span class="comment">// 持有某个策略:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">DiscountStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDiscountStrategy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许客户端设置新策略:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(DiscountStrategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">calculatePrice</span><span class="params">(BigDecimal total)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> total.subtract(<span class="built_in">this</span>.strategy.getDiscount(total)).setScale(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方必须首先创建一个DiscountContext，并指定一个策略（或者使用默认策略），即可获得折扣后的价格：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DiscountContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DiscountContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认使用普通会员折扣:</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">pay1</span> <span class="operator">=</span> ctx.calculatePrice(BigDecimal.valueOf(<span class="number">105</span>));</span><br><span class="line">System.out.println(pay1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用满减折扣:</span></span><br><span class="line">ctx.setStrategy(<span class="keyword">new</span> <span class="title class_">OverDiscountStrategy</span>());</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">pay2</span> <span class="operator">=</span> ctx.calculatePrice(BigDecimal.valueOf(<span class="number">105</span>));</span><br><span class="line">System.out.println(pay2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Prime会员折扣:</span></span><br><span class="line">ctx.setStrategy(<span class="keyword">new</span> <span class="title class_">PrimeDiscountStrategy</span>());</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">pay3</span> <span class="operator">=</span> ctx.calculatePrice(BigDecimal.valueOf(<span class="number">105</span>));</span><br><span class="line">System.out.println(pay3);</span><br></pre></td></tr></table></figure>
<p>上述完整的策略模式如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────┐      ┌─────────────────┐</span><br><span class="line">│DiscountContext│─ ─ ─▶│DiscountStrategy │</span><br><span class="line">└───────────────┘      └─────────────────┘</span><br><span class="line">                                ▲</span><br><span class="line">                                │ ┌─────────────────────┐</span><br><span class="line">                                ├─│UserDiscountStrategy │</span><br><span class="line">                                │ └─────────────────────┘</span><br><span class="line">                                │ ┌─────────────────────┐</span><br><span class="line">                                ├─│PrimeDiscountStrategy│</span><br><span class="line">                                │ └─────────────────────┘</span><br><span class="line">                                │ ┌─────────────────────┐</span><br><span class="line">                                └─│OverDiscountStrategy │</span><br><span class="line">                                  └─────────────────────┘</span><br></pre></td></tr></table></figure>
<p>策略模式的核心思想是在一个计算方法中把容易变化的算法抽出来作为“策略”参数传进去，从而使得新增策略不必修改原有逻辑。</p>
<h3 id="练习-9">练习</h3>
<p>使用策略模式新增一种策略，允许在满100减20的基础上对Prime会员再打七折。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/strategy/pattern-strategy.zip">下载练习</a></p>
<h3 id="小结-9">小结</h3>
<p>策略模式是为了允许调用方选择一个算法，从而通过不同策略实现不同的计算结果。</p>
<p>通过扩展策略，不必修改主逻辑，即可获得新策略的结果。</p>
<blockquote>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
</blockquote>
<p>模板方法（Template Method）是一个比较简单的模式。它的主要思想是，定义一个操作的一系列步骤，对于某些暂时确定不下来的步骤，就留给子类去实现好了，这样不同的子类就可以定义出不同的步骤。</p>
<p>因此，模板方法的核心在于定义一个“骨架”。我们还是举例说明。</p>
<p>假设我们开发了一个从数据库读取设置的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Setting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getSetting</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> readFromDatabase(key);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String <span class="title function_">readFromDatabase</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 从数据库读取</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于从数据库读取数据较慢，我们可以考虑把读取的设置缓存起来，这样下一次读取同样的key就不必再访问数据库了。但是怎么实现缓存，暂时没想好，但不妨碍我们先写出使用缓存的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Setting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getSetting</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// 先从缓存读取:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> lookupCache(key);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在缓存中未找到,从数据库读取:</span></span><br><span class="line">            value = readFromDatabase(key);</span><br><span class="line">            System.out.println(<span class="string">&quot;[DEBUG] load from db: &quot;</span> + key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">            <span class="comment">// 放入缓存:</span></span><br><span class="line">            putIntoCache(key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[DEBUG] load from cache: &quot;</span> + key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个流程没有问题，但是，<code>lookupCache(key)</code>和<code>putIntoCache(key, value)</code>这两个方法还根本没实现，怎么编译通过？这个不要紧，我们声明抽象方法就可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSetting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getSetting</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> lookupCache(key);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            value = readFromDatabase(key);</span><br><span class="line">            putIntoCache(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title function_">lookupCache</span><span class="params">(String key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">putIntoCache</span><span class="params">(String key, String value)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为声明了抽象方法，自然整个类也必须是抽象类。如何实现<code>lookupCache(key)</code>和<code>putIntoCache(key, value)</code>这两个方法就交给子类了。子类其实并不关心核心代码<code>getSetting(key)</code>的逻辑，它只需要关心如何完成两个小小的子任务就可以了。</p>
<p>假设我们希望用一个<code>Map</code>做缓存，那么可以写一个<code>LocalSetting</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalSetting</span> <span class="keyword">extends</span> <span class="title class_">AbstractSetting</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">lookupCache</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">putIntoCache</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们要使用Redis做缓存，那么可以再写一个<code>RedisSetting</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisSetting</span> <span class="keyword">extends</span> <span class="title class_">AbstractSetting</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">RedisClient</span> <span class="variable">client</span> <span class="operator">=</span> RedisClient.create(<span class="string">&quot;redis://localhost:6379&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">lookupCache</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;</span><br><span class="line">            RedisCommands&lt;String, String&gt; commands = connection.sync();</span><br><span class="line">            <span class="keyword">return</span> commands.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">putIntoCache</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;</span><br><span class="line">            RedisCommands&lt;String, String&gt; commands = connection.sync();</span><br><span class="line">            commands.set(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码使用本地缓存的代码这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AbstractSetting</span> <span class="variable">setting1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalSetting</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;test = &quot;</span> + setting1.getSetting(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;test = &quot;</span> + setting1.getSetting(<span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>要改成Redis缓存，只需要把<code>LocalSetting</code>替换为<code>RedisSetting</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AbstractSetting</span> <span class="variable">setting2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisSetting</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;autosave = &quot;</span> + setting2.getSetting(<span class="string">&quot;autosave&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;autosave = &quot;</span> + setting2.getSetting(<span class="string">&quot;autosave&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>可见，模板方法的核心思想是：父类定义骨架，子类实现某些细节。</p>
<p>为了防止子类重写父类的骨架方法，可以在父类中对骨架方法使用<code>final</code>。对于需要子类实现的抽象方法，一般声明为<code>protected</code>，使得这些方法对外部客户端不可见。</p>
<p>Java标准库也有很多模板方法的应用。在集合类中，<code>AbstractList</code>和<code>AbstractQueuedSynchronizer</code>都定义了很多通用操作，子类只需要实现某些必要方法。</p>
<h3 id="练习-10">练习</h3>
<p>使用模板方法增加一个使用Guava Cache的子类。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/template-method/pattern-template-method.zip">下载练习</a></p>
<p>思考：能否将<code>readFromDatabase()</code>作为模板方法，使得子类可以选择从数据库读取还是从文件读取。</p>
<p>再思考如果既可以扩展缓存，又可以扩展底层存储，会不会出现子类数量爆炸的情况？如何解决？</p>
<h3 id="小结-10">小结</h3>
<p>模板方法是一种高层定义骨架，底层实现细节的设计模式，适用于流程固定，但某些步骤不确定或可替换的情况。</p>
<blockquote>
<p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
</blockquote>
<p>访问者模式（Visitor）是一种操作一组对象的操作，它的目的是不改变对象的定义，但允许新增不同的访问者，来定义新的操作。</p>
<p>访问者模式的设计比较复杂，如果我们查看GoF原始的访问者模式，它是这么设计的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   ┌─────────┐       ┌───────────────────────┐</span><br><span class="line">   │ Client  │─ ─ ─ ▶│        Visitor        │</span><br><span class="line">   └─────────┘       ├───────────────────────┤</span><br><span class="line">        │            │visitElementA(ElementA)│</span><br><span class="line">                     │visitElementB(ElementB)│</span><br><span class="line">        │            └───────────────────────┘</span><br><span class="line">                                 ▲</span><br><span class="line">        │                ┌───────┴───────┐</span><br><span class="line">                         │               │</span><br><span class="line">        │         ┌─────────────┐ ┌─────────────┐</span><br><span class="line">                  │  VisitorA   │ │  VisitorB   │</span><br><span class="line">        │         └─────────────┘ └─────────────┘</span><br><span class="line">        ▼</span><br><span class="line">┌───────────────┐        ┌───────────────┐</span><br><span class="line">│ObjectStructure│─ ─ ─ ─▶│    Element    │</span><br><span class="line">├───────────────┤        ├───────────────┤</span><br><span class="line">│handle(Visitor)│        │accept(Visitor)│</span><br><span class="line">└───────────────┘        └───────────────┘</span><br><span class="line">                                 ▲</span><br><span class="line">                        ┌────────┴────────┐</span><br><span class="line">                        │                 │</span><br><span class="line">                ┌───────────────┐ ┌───────────────┐</span><br><span class="line">                │   ElementA    │ │   ElementB    │</span><br><span class="line">                ├───────────────┤ ├───────────────┤</span><br><span class="line">                │accept(Visitor)│ │accept(Visitor)│</span><br><span class="line">                │doA()          │ │doB()          │</span><br><span class="line">                └───────────────┘ └───────────────┘</span><br></pre></td></tr></table></figure>
<p>上述模式的复杂之处在于上述访问者模式为了实现所谓的“双重分派”，设计了一个回调再回调的机制。因为Java只支持基于多态的单分派模式，这里强行模拟出“双重分派”反而加大了代码的复杂性。</p>
<p>这里我们只介绍简化的访问者模式。假设我们要递归遍历某个文件夹的所有子文件夹和文件，然后找出<code>.java</code>文件，正常的做法是写个递归：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">scan</span><span class="params">(File dir, List&lt;File&gt; collector)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (File file : dir.listFiles()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isFile() &amp;&amp; file.getName().endsWith(<span class="string">&quot;.java&quot;</span>)) &#123;</span><br><span class="line">            collector.add(file);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isDir()) &#123;</span><br><span class="line">            <span class="comment">// 递归调用:</span></span><br><span class="line">            scan(file, collector);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的问题在于，扫描目录的逻辑和处理.java文件的逻辑混在了一起。如果下次需要增加一个清理<code>.class</code>文件的功能，就必须再重复写扫描逻辑。</p>
<p>因此，访问者模式先把数据结构（这里是文件夹和文件构成的树型结构）和对其的操作（查找文件）分离开，以后如果要新增操作（例如清理<code>.class</code>文件），只需要新增访问者，不需要改变现有逻辑。</p>
<p>用访问者模式改写上述代码步骤如下：</p>
<p>首先，我们需要定义访问者接口，即该访问者能够干的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="comment">// 访问文件夹:</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visitDir</span><span class="params">(File dir)</span>;</span><br><span class="line">    <span class="comment">// 访问文件:</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visitFile</span><span class="params">(File file)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着，我们要定义能持有文件夹和文件的数据结构<code>FileStructure</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileStructure</span> &#123;</span><br><span class="line">    <span class="comment">// 根目录:</span></span><br><span class="line">    <span class="keyword">private</span> File path;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileStructure</span><span class="params">(File path)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们给<code>FileStructure</code>增加一个<code>handle()</code>方法，传入一个访问者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileStructure</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">		scan(<span class="built_in">this</span>.path, visitor);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scan</span><span class="params">(File file, Visitor visitor)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// 让访问者处理文件夹:</span></span><br><span class="line">			visitor.visitDir(file);</span><br><span class="line">			<span class="keyword">for</span> (File sub : file.listFiles()) &#123;</span><br><span class="line">                <span class="comment">// 递归处理子文件夹:</span></span><br><span class="line">				scan(sub, visitor);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            <span class="comment">// 让访问者处理文件:</span></span><br><span class="line">			visitor.visitFile(file);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就把访问者的行为抽象出来了。如果我们要实现一种操作，例如，查找<code>.java</code>文件，就传入<code>JavaFileVisitor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileStructure</span> <span class="variable">fs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileStructure</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">fs.handle(<span class="keyword">new</span> <span class="title class_">JavaFileVisitor</span>());</span><br></pre></td></tr></table></figure>
<p>这个<code>JavaFileVisitor</code>实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaFileVisitor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitDir</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Visit dir: &quot;</span> + dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.getName().endsWith(<span class="string">&quot;.java&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Found java file: &quot;</span> + file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，如果要清理<code>.class</code>文件，可以再写一个<code>ClassFileClearnerVisitor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassFileCleanerVisitor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitDir</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (file.getName().endsWith(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Will clean class file: &quot;</span> + file);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，访问者模式的核心思想是为了访问比较复杂的数据结构，不去改变数据结构，而是把对数据的操作抽象出来，在“访问”的过程中以回调形式在访问者中处理操作逻辑。如果要新增一组操作，那么只需要增加一个新的访问者。</p>
<p>实际上，Java标准库提供的<code>Files.walkFileTree()</code>已经实现了一个访问者模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Files.walkFileTree(Paths.get(<span class="string">&quot;.&quot;</span>), <span class="keyword">new</span> <span class="title class_">MyFileVisitor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个FileVisitor:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFileVisitor</span> <span class="keyword">extends</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理Directory:</span></span><br><span class="line">    <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;pre visit dir: &quot;</span> + dir);</span><br><span class="line">        <span class="comment">// 返回CONTINUE表示继续访问:</span></span><br><span class="line">        <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理File:</span></span><br><span class="line">    <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;visit file: &quot;</span> + file);</span><br><span class="line">        <span class="comment">// 返回CONTINUE表示继续访问:</span></span><br><span class="line">        <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Files.walkFileTree()</code>允许访问者返回<code>FileVisitResult.CONTINUE</code>以便继续访问，或者返回<code>FileVisitResult.TERMINATE</code>停止访问。</p>
<p>类似的，对XML的SAX处理也是一个访问者模式，我们需要提供一个SAX Handler作为访问者处理XML的各个节点。</p>
<h3 id="练习-11">练习</h3>
<p>使用访问者模式递归遍历文件夹。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/visitor/pattern-visitor.zip">下载练习</a></p>
<h3 id="小结-11">小结</h3>
<p>访问者模式是为了抽象出作用于一组复杂对象的操作，并且后续可以新增操作而不必对现有的对象结构做任何改动。</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">標籤</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/Java/" rel="tag">Java</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JAVA-Spring%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E5%8E%9F%E7%90%86/"
                    data-tooltip="JAVA-Spring主从数据库的配置和动态数据源切换原理"
                    aria-label="上一篇: JAVA-Spring主从数据库的配置和动态数据源切换原理"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"
                    data-tooltip="JAVA-设计模式-结构型模式"
                    aria-label="下一篇: JAVA-设计模式-结构型模式"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/24/Java/JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/24/Java/JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/24/Java/JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/24/Java/JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JAVA-Spring%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E5%8E%9F%E7%90%86/"
                    data-tooltip="JAVA-Spring主从数据库的配置和动态数据源切换原理"
                    aria-label="上一篇: JAVA-Spring主从数据库的配置和动态数据源切换原理"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"
                    data-tooltip="JAVA-设计模式-结构型模式"
                    aria-label="下一篇: JAVA-设计模式-结构型模式"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/24/Java/JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/24/Java/JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/24/Java/JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/24/Java/JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2025/05/24/Java/JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"
                        aria-label="分享到 Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2025/05/24/Java/JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"
                        aria-label="分享到 Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2025/05/24/Java/JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"
                        aria-label="global.share_on_linkedin"
                    >
                        <i class="fab fa-linkedin" aria-hidden="true"></i><span>global.share_on_linkedin</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2025/05/24/Java/JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"
                        aria-label="分享到 Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 134 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
