
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>12.python常用内建模块 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg"},"articleBody":"Python之所以自称“batteries included”，就是因为内置了许多非常有用的模块，无需额外安装和配置，即可直接使用。\n本章将介绍一些常用的内建模块。\ndatetime是Python处理日期和时间的标准库。\n获取当前日期和时间\n我们先看如何获取当前日期和时间：\n123456&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; now = datetime.now() # 获取当前datetime&gt;&gt;&gt; print(now)2015-05-18 16:28:07.198690&gt;&gt;&gt; print(type(now))&lt;class &#x27;datetime.datetime&#x27;&gt;\n注意到datetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类。\n如果仅导入import datetime，则必须引用全名datetime.datetime。\ndatetime.now()返回当前日期和时间，其类型是datetime。\n获取指定日期和时间\n要指定某个日期和时间，我们直接用参数构造一个datetime：\n1234&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime&gt;&gt;&gt; print(dt)2015-04-19 12:20:00\ndatetime转换为timestamp\n在计算机中，时间实际上是用数字表示的。我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为0（1970年以前的时间timestamp为负数），当前时间就是相对于epoch time的秒数，称为timestamp。\n你可以认为：\n1timestamp = 0 = 1970-1-1 00:00:00 UTC+0:00\n对应的北京时间是：\n1timestamp = 0 = 1970-1-1 08:00:00 UTC+8:00\n可见timestamp的值与时区毫无关系，因为timestamp一旦确定，其UTC时间就确定了，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）。\n把一个datetime类型转换为timestamp只需要简单调用timestamp()方法：\n1234&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime&gt;&gt;&gt; dt.timestamp() # 把datetime转换为timestamp1429417200.0\n注意Python的timestamp是一个浮点数，整数位表示秒。\n某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法。\ntimestamp转换为datetime\n要把timestamp转换为datetime，使用datetime提供的fromtimestamp()方法：\n1234&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; t = 1429417200.0&gt;&gt;&gt; print(datetime.fromtimestamp(t))2015-04-19 12:20:00\n注意到timestamp是一个浮点数，它没有时区的概念，而datetime是有时区的。上述转换是在timestamp和本地时间做转换。\n本地时间是指当前操作系统设定的时区。例如北京时区是东8区，则本地时间：\n12015-04-19 12:20:00\n实际上就是UTC+8:00时区的时间：\n12015-04-19 12:20:00 UTC+8:00\n而此刻的格林威治标准时间与北京时间差了8小时，也就是UTC+0:00时区的时间应该是：\n12015-04-19 04:20:00 UTC+0:00\ntimestamp也可以直接被转换到UTC标准时区的时间：\n123456&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; t = 1429417200.0&gt;&gt;&gt; print(datetime.fromtimestamp(t)) # 本地时间2015-04-19 12:20:00&gt;&gt;&gt; print(datetime.utcfromtimestamp(t)) # UTC时间2015-04-19 04:20:00\nstr转换为datetime\n很多时候，用户输入的日期和时间是字符串，要处理日期和时间，首先必须把str转换为datetime。转换方法是通过datetime.strptime()实现，需要一个日期和时间的格式化字符串：\n1234&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; cday = datetime.strptime(&#x27;2015-6-1 18:19:59&#x27;, &#x27;%Y-%m-%d %H:%M:%S&#x27;)&gt;&gt;&gt; print(cday)2015-06-01 18:19:59\n字符串'%Y-%m-%d %H:%M:%S'规定了日期和时间部分的格式。详细的说明请参考Python文档。\n注意转换后的datetime是没有时区信息的。\ndatetime转换为str\n如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过strftime()实现的，同样需要一个日期和时间的格式化字符串：\n1234&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; now = datetime.now()&gt;&gt;&gt; print(now.strftime(&#x27;%a, %b %d %H:%M&#x27;))Mon, May 05 16:28\ndatetime加减\n对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类：\n12345678910&gt;&gt;&gt; from datetime import datetime, timedelta&gt;&gt;&gt; now = datetime.now()&gt;&gt;&gt; nowdatetime.datetime(2015, 5, 18, 16, 57, 3, 540997)&gt;&gt;&gt; now + timedelta(hours=10)datetime.datetime(2015, 5, 19, 2, 57, 3, 540997)&gt;&gt;&gt; now - timedelta(days=1)datetime.datetime(2015, 5, 17, 16, 57, 3, 540997)&gt;&gt;&gt; now + timedelta(days=2, hours=12)datetime.datetime(2015, 5, 21, 4, 57, 3, 540997)\n可见，使用timedelta你可以很容易地算出前几天和后几天的时刻。\n本地时间转换为UTC时间\n本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。\n一个datetime类型有一个时区属性tzinfo，但是默认为None，所以无法区分这个datetime到底是哪个时区，除非强行给datetime设置一个时区：\n12345678&gt;&gt;&gt; from datetime import datetime, timedelta, timezone&gt;&gt;&gt; tz_utc_8 = timezone(timedelta(hours=8)) # 创建时区UTC+8:00&gt;&gt;&gt; now = datetime.now()&gt;&gt;&gt; nowdatetime.datetime(2015, 5, 18, 17, 2, 10, 871012)&gt;&gt;&gt; dt = now.replace(tzinfo=tz_utc_8) # 强制设置为UTC+8:00&gt;&gt;&gt; dtdatetime.datetime(2015, 5, 18, 17, 2, 10, 871012, tzinfo=datetime.timezone(datetime.timedelta(0, 28800)))\n如果系统时区恰好是UTC+8:00，那么上述代码就是正确的，否则，不能强制设置为UTC+8:00时区。\n时区转换\n我们可以先通过utcnow()拿到当前的UTC时间，再转换为任意时区的时间：\n12345678910111213141516# 拿到UTC时间，并强制设置时区为UTC+0:00:&gt;&gt;&gt; utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)&gt;&gt;&gt; print(utc_dt)2015-05-18 09:05:12.377316+00:00# astimezone()将转换时区为北京时间:&gt;&gt;&gt; bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))&gt;&gt;&gt; print(bj_dt)2015-05-18 17:05:12.377316+08:00# astimezone()将转换时区为东京时间:&gt;&gt;&gt; tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours=9)))&gt;&gt;&gt; print(tokyo_dt)2015-05-18 18:05:12.377316+09:00# astimezone()将bj_dt转换时区为东京时间:&gt;&gt;&gt; tokyo_dt2 = bj_dt.astimezone(timezone(timedelta(hours=9)))&gt;&gt;&gt; print(tokyo_dt2)2015-05-18 18:05:12.377316+09:00\n时区转换的关键在于，拿到一个datetime时，要获知其正确的时区，然后强制设置时区，作为基准时间。\n利用带时区的datetime，通过astimezone()方法，可以转换到任意时区。\n注：不是必须从UTC+0:00时区转换到其他时区，任何带时区的datetime都可以正确转换，例如上述bj_dt到tokyo_dt的转换。\n小结\ndatetime表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。\n如果要存储datetime，最佳方法是将其转换为timestamp再存储，因为timestamp的值与时区完全无关。\n练习\n假设你获取了用户输入的日期和时间如2015-1-21 9:01:30，以及一个时区信息如UTC+5:00，均是str，请编写一个函数将其转换为timestamp：\n12345678910111213141516# -*- coding:utf-8 -*-import refrom datetime import datetime, timezone, timedeltadef to_timestamp(dt_str, tz_str):    pass# 测试:t1 = to_timestamp(&#x27;2015-6-1 08:10:30&#x27;, &#x27;UTC+7:00&#x27;)assert t1 == 1433121030.0, t1t2 = to_timestamp(&#x27;2015-5-31 16:10:30&#x27;, &#x27;UTC-09:00&#x27;)assert t2 == 1433121030.0, t2print(&#x27;ok&#x27;)\n参考源码\nuse_datetime.py\ncollections是Python内建的一个集合模块，提供了许多有用的集合类。\nnamedtuple\n我们知道tuple可以表示不变集合，例如，一个点的二维坐标就可以表示成：\n1&gt;&gt;&gt; p = (1, 2)\n但是，看到(1, 2)，很难看出这个tuple是用来表示一个坐标的。\n定义一个class又小题大做了，这时，namedtuple就派上了用场：\n1234567&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt; Point = namedtuple(&#x27;Point&#x27;, [&#x27;x&#x27;, &#x27;y&#x27;])&gt;&gt;&gt; p = Point(1, 2)&gt;&gt;&gt; p.x1&gt;&gt;&gt; p.y2\nnamedtuple是一个函数，它用来创建一个自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素。\n这样一来，我们用namedtuple可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用，使用十分方便。\n可以验证创建的Point对象是tuple的一种子类：\n1234&gt;&gt;&gt; isinstance(p, Point)True&gt;&gt;&gt; isinstance(p, tuple)True\n类似的，如果要用坐标和半径表示一个圆，也可以用namedtuple定义：\n12# namedtuple(&#x27;名称&#x27;, [属性list]):Circle = namedtuple(&#x27;Circle&#x27;, [&#x27;x&#x27;, &#x27;y&#x27;, &#x27;r&#x27;])\ndeque\n使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。\ndeque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：\n123456&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; q = deque([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])&gt;&gt;&gt; q.append(&#x27;x&#x27;)&gt;&gt;&gt; q.appendleft(&#x27;y&#x27;)&gt;&gt;&gt; qdeque([&#x27;y&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;x&#x27;])\ndeque除了实现list的append()和pop()外，还支持appendleft()和popleft()，这样就可以非常高效地往头部添加或删除元素。\ndefaultdict\n使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用defaultdict：\n1234567&gt;&gt;&gt; from collections import defaultdict&gt;&gt;&gt; dd = defaultdict(lambda: &#x27;N/A&#x27;)&gt;&gt;&gt; dd[&#x27;key1&#x27;] = &#x27;abc&#x27;&gt;&gt;&gt; dd[&#x27;key1&#x27;] # key1存在&#x27;abc&#x27;&gt;&gt;&gt; dd[&#x27;key2&#x27;] # key2不存在，返回默认值&#x27;N/A&#x27;\n注意默认值是调用函数返回的，而函数在创建defaultdict对象时传入。\n除了在Key不存在时返回默认值，defaultdict的其他行为跟dict是完全一样的。\nOrderedDict\n使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。\n如果要保持Key的顺序，可以用OrderedDict：\n1234567&gt;&gt;&gt; from collections import OrderedDict&gt;&gt;&gt; d = dict([(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 3)])&gt;&gt;&gt; d # dict的Key是无序的&#123;&#x27;a&#x27;: 1, &#x27;c&#x27;: 3, &#x27;b&#x27;: 2&#125;&gt;&gt;&gt; od = OrderedDict([(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 3)])&gt;&gt;&gt; od # OrderedDict的Key是有序的OrderedDict([(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 3)])\n注意，OrderedDict的Key会按照插入的顺序排列，不是Key本身排序：\n123456&gt;&gt;&gt; od = OrderedDict()&gt;&gt;&gt; od[&#x27;z&#x27;] = 1&gt;&gt;&gt; od[&#x27;y&#x27;] = 2&gt;&gt;&gt; od[&#x27;x&#x27;] = 3&gt;&gt;&gt; list(od.keys()) # 按照插入的Key的顺序返回[&#x27;z&#x27;, &#x27;y&#x27;, &#x27;x&#x27;]\nOrderedDict可以实现一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的Key：\n12345678910111213141516171819from collections import OrderedDictclass LastUpdatedOrderedDict(OrderedDict):    def __init__(self, capacity):        super(LastUpdatedOrderedDict, self).__init__()        self._capacity = capacity    def __setitem__(self, key, value):        containsKey = 1 if key in self else 0        if len(self) - containsKey &gt;= self._capacity:            last = self.popitem(last=False)            print(&#x27;remove:&#x27;, last)        if containsKey:            del self[key]            print(&#x27;set:&#x27;, (key, value))        else:            print(&#x27;add:&#x27;, (key, value))        OrderedDict.__setitem__(self, key, value)\nChainMap\nChainMap可以把一组dict串起来并组成一个逻辑上的dict。ChainMap本身也是一个dict，但是查找的时候，会按照顺序在内部的dict依次查找。\n什么时候使用ChainMap最合适？举个例子：应用程序往往都需要传入参数，参数可以通过命令行传入，可以通过环境变量传入，还可以有默认参数。我们可以用ChainMap实现参数的优先级查找，即先查命令行参数，如果没有传入，再查环境变量，如果没有，就使用默认参数。\n下面的代码演示了如何查找user和color这两个参数：\n12345678910111213141516171819202122from collections import ChainMapimport os, argparse# 构造缺省参数:defaults = &#123;    &#x27;color&#x27;: &#x27;red&#x27;,    &#x27;user&#x27;: &#x27;guest&#x27;&#125;# 构造命令行参数:parser = argparse.ArgumentParser()parser.add_argument(&#x27;-u&#x27;, &#x27;--user&#x27;)parser.add_argument(&#x27;-c&#x27;, &#x27;--color&#x27;)namespace = parser.parse_args()command_line_args = &#123; k: v for k, v in vars(namespace).items() if v &#125;# 组合成ChainMap:combined = ChainMap(command_line_args, os.environ, defaults)# 打印参数:print(&#x27;color=%s&#x27; % combined[&#x27;color&#x27;])print(&#x27;user=%s&#x27; % combined[&#x27;user&#x27;])\n没有任何参数时，打印出默认参数：\n123$ python3 use_chainmap.py color=reduser=guest\n当传入命令行参数时，优先使用命令行参数：\n123$ python3 use_chainmap.py -u bobcolor=reduser=bob\n同时传入命令行参数和环境变量，命令行参数的优先级较高：\n123$ user=admin color=green python3 use_chainmap.py -u bobcolor=greenuser=bob\nCounter\nCounter是一个简单的计数器，例如，统计字符出现的个数：\n12345678910&gt;&gt;&gt; from collections import Counter&gt;&gt;&gt; c = Counter(&#x27;programming&#x27;)&gt;&gt;&gt; for ch in &#x27;programming&#x27;:...     c[ch] = c[ch] + 1...&gt;&gt;&gt; cCounter(&#123;&#x27;g&#x27;: 2, &#x27;m&#x27;: 2, &#x27;r&#x27;: 2, &#x27;a&#x27;: 1, &#x27;i&#x27;: 1, &#x27;o&#x27;: 1, &#x27;n&#x27;: 1, &#x27;p&#x27;: 1&#125;)&gt;&gt;&gt; c.update(&#x27;hello&#x27;) # 也可以一次性update&gt;&gt;&gt; cCounter(&#123;&#x27;r&#x27;: 2, &#x27;o&#x27;: 2, &#x27;g&#x27;: 2, &#x27;m&#x27;: 2, &#x27;l&#x27;: 2, &#x27;p&#x27;: 1, &#x27;a&#x27;: 1, &#x27;i&#x27;: 1, &#x27;n&#x27;: 1, &#x27;h&#x27;: 1, &#x27;e&#x27;: 1&#125;)\nCounter实际上也是dict的一个子类，上面的结果可以看出每个字符出现的次数。\n小结\ncollections模块提供了一些有用的集合类，可以根据需要选用。\n参考源码\nuse_collections.py\n在命令行程序中，经常需要获取命令行参数。Python内置的sys.argv保存了完整的参数列表，我们可以从中解析出需要的参数：\n123456# copy.pyimport sysprint(sys.argv)source = sys.argv[1]target = sys.argv[2]# TODO...\n运行上述copy.py，并传入参数，打印如下：\n1[&#x27;copy.py&#x27;, &#x27;source.txt&#x27;, &#x27;copy.txt&#x27;]\n这种方式能应付简单的参数，但参数稍微复杂点，比如可以使用-d复制目录，使用--filename *.py过滤文件名等，解析起来就非常麻烦。\n为了简化参数解析，我们可以使用内置的argparse库，定义好各个参数类型后，它能直接返回有效的参数。\n假设我们想编写一个备份MySQL数据库的命令行程序，需要输入的参数如下：\n\nhost参数：表示MySQL主机名或IP，不输入则默认为localhost；\nport参数：表示MySQL的端口号，int类型，不输入则默认为3306；\nuser参数：表示登录MySQL的用户名，必须输入；\npassword参数：表示登录MySQL的口令，必须输入；\ngz参数：表示是否压缩备份文件，不输入则默认为False；\noutfile参数：表示备份文件保存在哪，必须输入。\n\n其中，outfile是位置参数，而其他则是类似--user root这样的“关键字”参数。\n用argparse来解析参数，一个完整的示例如下：\n12345678910111213141516171819202122232425262728293031323334353637383940# backup.pyimport argparsedef main():    # 定义一个ArgumentParser实例:    parser = argparse.ArgumentParser(        prog=&#x27;backup&#x27;, # 程序名        description=&#x27;Backup MySQL database.&#x27;, # 描述        epilog=&#x27;Copyright(r), 2023&#x27; # 说明信息    )    # 定义位置参数:    parser.add_argument(&#x27;outfile&#x27;)    # 定义关键字参数:    parser.add_argument(&#x27;--host&#x27;, default=&#x27;localhost&#x27;)    # 此参数必须为int类型:    parser.add_argument(&#x27;--port&#x27;, default=&#x27;3306&#x27;, type=int)    # 允许用户输入简写的-u:    parser.add_argument(&#x27;-u&#x27;, &#x27;--user&#x27;, required=True)    parser.add_argument(&#x27;-p&#x27;, &#x27;--password&#x27;, required=True)    parser.add_argument(&#x27;--database&#x27;, required=True)    # gz参数不跟参数值，因此指定action=&#x27;store_true&#x27;，意思是出现-gz表示True:    parser.add_argument(&#x27;-gz&#x27;, &#x27;--gzcompress&#x27;, action=&#x27;store_true&#x27;, required=False, help=&#x27;Compress backup files by gz.&#x27;)    # 解析参数:    args = parser.parse_args()    # 打印参数:    print(&#x27;parsed args:&#x27;)    print(f&#x27;outfile = &#123;args.outfile&#125;&#x27;)    print(f&#x27;host = &#123;args.host&#125;&#x27;)    print(f&#x27;port = &#123;args.port&#125;&#x27;)    print(f&#x27;user = &#123;args.user&#125;&#x27;)    print(f&#x27;password = &#123;args.password&#125;&#x27;)    print(f&#x27;database = &#123;args.database&#125;&#x27;)    print(f&#x27;gzcompress = &#123;args.gzcompress&#125;&#x27;)if __name__ == &#x27;__main__&#x27;:    main()\n输入有效的参数，则程序能解析出所需的所有参数：\n123456789$ ./backup.py -u root -p hello --database testdb backup.sqlparsed args:outfile = backup.sqlhost = localhostport = 3306user = rootpassword = hellodatabase = testdbgzcompress = False\n缺少必要的参数，或者参数不对，将报告详细的错误信息：\n123$ ./backup.py --database testdb backup.sqlusage: backup [-h] [--host HOST] [--port PORT] -u USER -p PASSWORD --database DATABASE outfilebackup: error: the following arguments are required: -u/--user, -p/--password\n更神奇的是，如果输入-h，则打印帮助信息：\n123456789101112131415161718$ ./backup.py -h                          usage: backup [-h] [--host HOST] [--port PORT] -u USER -p PASSWORD --database DATABASE outfileBackup MySQL database.positional arguments:  outfileoptional arguments:  -h, --help            show this help message and exit  --host HOST  --port PORT  -u USER, --user USER  -p PASSWORD, --password PASSWORD  --database DATABASE  -gz, --gzcompress     Compress backup files by gz.Copyright(r), 2023\n获取有效参数的代码实际上是这一行：\n1args = parser.parse_args()\n我们不必捕获异常，parse_args()非常方便的一点在于，如果参数有问题，则它打印出错误信息后，结束进程；如果参数是-h，则它打印帮助信息后，结束进程。只有当参数全部有效时，才会返回一个NameSpace对象，获取对应的参数就把参数名当作属性获取，非常方便。\n可见，使用argparse后，解析参数的工作被大大简化了，我们可以专注于定义参数，然后直接获取到有效的参数输入。\n小结\n使用argparse解析参数，只需定义好参数类型，就可以获得有效的参数输入，能大大简化获取命令行参数的工作。\nBase64是一种用64个字符来表示任意二进制数据的方法。\n用记事本打开exe、jpg、pdf这些文件时，我们都会看到一大堆乱码，因为二进制文件包含很多无法显示和打印的字符，所以，如果要让记事本这样的文本处理软件能处理二进制数据，就需要一个二进制到字符串的转换方法。Base64是一种最常见的二进制编码方法。\nBase64的原理很简单，首先，准备一个包含64个字符的数组：\n1[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, ... &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, ... &#x27;0&#x27;, &#x27;1&#x27;, ... &#x27;+&#x27;, &#x27;/&#x27;]\n然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit：\n1234567┌───────────────┬───────────────┬───────────────┐│      b1       │      b2       │      b3       │├─┬─┬─┬─┬─┬─┬─┬─┼─┬─┬─┬─┬─┬─┬─┬─┼─┬─┬─┬─┬─┬─┬─┬─┤│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │├─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─┴─┤│    n1     │    n2     │    n3     │    n4     │└───────────┴───────────┴───────────┴───────────┘\n这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。\n所以，Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。\n如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用\\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。\nPython内置的base64可以直接进行base64的编解码：\n12345&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64encode(b&#x27;binary\\x00string&#x27;)b&#x27;YmluYXJ5AHN0cmluZw==&#x27;&gt;&gt;&gt; base64.b64decode(b&#x27;YmluYXJ5AHN0cmluZw==&#x27;)b&#x27;binary\\x00string&#x27;\n由于标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数，所以又有一种&quot;url safe&quot;的base64编码，其实就是把字符+和/分别变成-和_：\n123456&gt;&gt;&gt; base64.b64encode(b&#x27;i\\xb7\\x1d\\xfb\\xef\\xff&#x27;)b&#x27;abcd++//&#x27;&gt;&gt;&gt; base64.urlsafe_b64encode(b&#x27;i\\xb7\\x1d\\xfb\\xef\\xff&#x27;)b&#x27;abcd--__&#x27;&gt;&gt;&gt; base64.urlsafe_b64decode(&#x27;abcd--__&#x27;)b&#x27;i\\xb7\\x1d\\xfb\\xef\\xff&#x27;\n还可以自己定义64个字符的排列顺序，这样就可以自定义Base64编码，不过，通常情况下完全没有必要。\nBase64是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行。\nBase64适用于小段内容的编码，比如数字证书签名、Cookie的内容等。\n由于=字符也可能出现在Base64编码中，但=用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把=去掉：\n1234# 标准Base64:&#x27;abcd&#x27; -&gt; &#x27;YWJjZA==&#x27;# 自动去掉=:&#x27;abcd&#x27; -&gt; &#x27;YWJjZA&#x27;\n去掉=后怎么解码呢？因为Base64是把3个字节变为4个字节，所以，Base64编码的长度永远是4的倍数，因此，需要加上=把Base64字符串的长度变为4的倍数，就可以正常解码了。\n小结\nBase64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。\n练习\n请写一个能处理去掉=的base64解码函数：\n123456789import base64def safe_base64_decode(s):    pass# 测试:assert b&#x27;abcd&#x27; == safe_base64_decode(&#x27;YWJjZA==&#x27;), safe_base64_decode(&#x27;YWJjZA==&#x27;)assert b&#x27;abcd&#x27; == safe_base64_decode(&#x27;YWJjZA&#x27;), safe_base64_decode(&#x27;YWJjZA&#x27;)print(&#x27;ok&#x27;)\n参考源码\ndo_base64.py\n准确地讲，Python没有专门处理字节的数据类型。但由于b'str'可以表示字节，所以，字节数组＝二进制str。而在C语言中，我们可以很方便地用struct、union来处理字节，以及字节和int，float的转换。\n在Python中，比方说要把一个32位无符号整数变成字节，也就是4个长度的bytes，你得配合位运算符这么写：\n12345678&gt;&gt;&gt; n = 10240099&gt;&gt;&gt; b1 = (n &amp; 0xff000000) &gt;&gt; 24&gt;&gt;&gt; b2 = (n &amp; 0xff0000) &gt;&gt; 16&gt;&gt;&gt; b3 = (n &amp; 0xff00) &gt;&gt; 8&gt;&gt;&gt; b4 = n &amp; 0xff&gt;&gt;&gt; bs = bytes([b1, b2, b3, b4])&gt;&gt;&gt; bsb&#x27;\\x00\\x9c@c&#x27;\n非常麻烦。如果换成浮点数就无能为力了。\n好在Python提供了一个struct模块来解决bytes和其他二进制数据类型的转换。\nstruct的pack函数把任意数据类型变成bytes：\n123&gt;&gt;&gt; import struct&gt;&gt;&gt; struct.pack(&#x27;&gt;I&#x27;, 10240099)b&#x27;\\x00\\x9c@c&#x27;\npack的第一个参数是处理指令，'&gt;I'的意思是：\n&gt;表示字节顺序是big-endian，也就是网络序，I表示4字节无符号整数。\n后面的参数个数要和处理指令一致。\nunpack把bytes变成相应的数据类型：\n12&gt;&gt;&gt; struct.unpack(&#x27;&gt;IH&#x27;, b&#x27;\\xf0\\xf0\\xf0\\xf0\\x80\\x80&#x27;)(4042322160, 32896)\n根据&gt;IH的说明，后面的bytes依次变为I：4字节无符号整数和H：2字节无符号整数。\n所以，尽管Python不适合编写底层操作字节流的代码，但在对性能要求不高的地方，利用struct就方便多了。\nstruct模块定义的数据类型可以参考Python官方文档：\nhttps://docs.python.org/3/library/struct.html#format-characters\nWindows的位图文件（.bmp）是一种非常简单的文件格式，我们来用struct分析一下。\n首先找一个bmp文件，没有的话用“画图”画一个。\n读入前30个字节来分析：\n1&gt;&gt;&gt; s = b&#x27;\\x42\\x4d\\x38\\x8c\\x0a\\x00\\x00\\x00\\x00\\x00\\x36\\x00\\x00\\x00\\x28\\x00\\x00\\x00\\x80\\x02\\x00\\x00\\x68\\x01\\x00\\x00\\x01\\x00\\x18\\x00&#x27;\nBMP格式采用小端方式存储数据，文件头的结构按顺序如下：\n两个字节：'BM'表示Windows位图，'BA'表示OS/2位图； 一个4字节整数：表示位图大小； 一个4字节整数：保留位，始终为0； 一个4字节整数：实际图像的偏移量； 一个4字节整数：Header的字节数； 一个4字节整数：图像宽度； 一个4字节整数：图像高度； 一个2字节整数：始终为1； 一个2字节整数：颜色数。\n所以，组合起来用unpack读取：\n12&gt;&gt;&gt; struct.unpack(&#x27;&lt;ccIIIIIIHH&#x27;, s)(b&#x27;B&#x27;, b&#x27;M&#x27;, 691256, 0, 54, 40, 640, 360, 1, 24)\n结果显示，b'B'、b'M'说明是Windows位图，位图大小为640x360，颜色数为24。\n请编写一个bmpinfo.py，可以检查任意文件是否是位图文件，如果是，打印出图片大小和颜色数。\n123456789101112131415161718192021222324252627import base64, structbmp_data = base64.b64decode(&#x27;Qk1oAgAAAAAAADYAAAAoAAAAHAAAAAoAAAABABAAAAAAADICAAASCwAAEgsAA&#x27; +                   &#x27;AAAAAAAAAAA/3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3/&#x27; +                   &#x27;/f/9//3//f/9//3//f/9/AHwAfAB8AHwAfAB8AHwAfP9//3//fwB8AHwAfAB8/3//f/9/A&#x27; +                   &#x27;HwAfAB8AHz/f/9//3//f/9//38AfAB8AHwAfAB8AHwAfAB8AHz/f/9//38AfAB8/3//f/9&#x27; +                   &#x27;//3//fwB8AHz/f/9//3//f/9//3//f/9/AHwAfP9//3//f/9/AHwAfP9//3//fwB8AHz/f&#x27; +                   &#x27;/9//3//f/9/AHwAfP9//3//f/9//3//f/9//38AfAB8AHwAfAB8AHwAfP9//3//f/9/AHw&#x27; +                   &#x27;AfP9//3//f/9//38AfAB8/3//f/9//3//f/9//3//fwB8AHwAfAB8AHwAfAB8/3//f/9//&#x27; +                   &#x27;38AfAB8/3//f/9//3//fwB8AHz/f/9//3//f/9//3//f/9/AHwAfP9//3//f/9/AHwAfP9&#x27; +                   &#x27;//3//fwB8AHz/f/9/AHz/f/9/AHwAfP9//38AfP9//3//f/9/AHwAfAB8AHwAfAB8AHwAf&#x27; +                   &#x27;AB8/3//f/9/AHwAfP9//38AfAB8AHwAfAB8AHwAfAB8/3//f/9//38AfAB8AHwAfAB8AHw&#x27; +                   &#x27;AfAB8/3//f/9/AHwAfAB8AHz/fwB8AHwAfAB8AHwAfAB8AHz/f/9//3//f/9//3//f/9//&#x27; +                   &#x27;3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//38AAA==&#x27;)def bmp_info(data):    return &#123;        &#x27;width&#x27;: 200,        &#x27;height&#x27;: 100,        &#x27;color&#x27;: 24    &#125;# 测试bi = bmp_info(bmp_data)assert bi[&#x27;width&#x27;] == 28assert bi[&#x27;height&#x27;] == 10assert bi[&#x27;color&#x27;] == 16print(&#x27;ok&#x27;)\n参考源码\ncheck_bmp.py\n哈希算法简介\nPython的hashlib提供了常见的哈希算法，如MD5，SHA1等等。\n什么是哈希算法呢？哈希算法又称摘要算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。\n举个例子，你写了一篇文章，内容是一个字符串'how to use python hashlib - by Michael'，并附上这篇文章的哈希是'2d73d4f15c0db7f5ecb321b6a65e5d6d'。如果有人篡改了你的文章，并发表为'how to use python hashlib - by Bob'，你可以一下子指出Bob篡改了你的文章，因为根据'how to use python hashlib - by Bob'计算出的哈希不同于原始文章的哈希。\n可见，哈希算法就是通过哈希函数hash(data)对任意长度的数据data计算出固定长度的哈希digest，目的是为了发现原始数据是否被人篡改过。\n哈希算法之所以能指出数据是否被篡改过，就是因为哈希函数是一个单向函数，计算digest=hash(data)很容易，但通过digest反推data却非常困难。而且，对原始数据做一个bit的修改，都会导致计算出的哈希完全不同。\n我们以常见的哈希算法MD5为例，计算出一个字符串的MD5值：\n12345import hashlibmd5 = hashlib.md5()md5.update(&#x27;how to use md5 in python hashlib?&#x27;.encode(&#x27;utf-8&#x27;))print(md5.hexdigest())\n计算结果如下：\n1d26a53750bc40b38b65a520292f69306\n如果数据量很大，可以分块多次调用update()，最后计算的结果是一样的：\n123456import hashlibmd5 = hashlib.md5()md5.update(&#x27;how to use md5 in &#x27;.encode(&#x27;utf-8&#x27;))md5.update(&#x27;python hashlib?&#x27;.encode(&#x27;utf-8&#x27;))print(md5.hexdigest())\n试试改动一个字母，看看计算的结果是否完全不同。\nMD5是最常见的哈希算法，速度很快，生成结果是固定的128 bit/16字节，通常用一个32位的16进制字符串表示。\n另一种常见的哈希算法是SHA1，调用SHA1和调用MD5完全类似：\n123456import hashlibsha1 = hashlib.sha1()sha1.update(&#x27;how to use sha1 in &#x27;.encode(&#x27;utf-8&#x27;))sha1.update(&#x27;python hashlib?&#x27;.encode(&#x27;utf-8&#x27;))print(sha1.hexdigest())\nSHA1的结果是160 bit/20字节，通常用一个40位的16进制字符串表示。\n比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法不仅越慢，而且哈希长度更长。\n有没有可能两个不同的数据通过某个哈希算法得到了相同的哈希？完全有可能，因为任何哈希算法都是把无限多的数据集合映射到一个有限的集合中。这种情况称为碰撞，比如Bob试图根据你的哈希反推出一篇文章'how to learn hashlib in python - by Bob'，并且这篇文章的哈希恰好和你的文章完全一致，这种情况也并非不可能出现，但是非常非常困难。\n哈希算法应用\n哈希算法能应用到什么地方？举个常用例子：\n任何允许用户登录的网站都会存储用户登录的用户名和口令。如何存储用户名和口令呢？方法是存到数据库表中：\n\n\n\nname\npassword\n\n\n\n\nmichael\n123456\n\n\nbob\nabc999\n\n\nalice\nalice2008\n\n\n\n如果以明文保存用户口令，如果数据库泄露，所有用户的口令就落入黑客的手里。此外，网站运维人员是可以访问数据库的，也就是能获取到所有用户的口令。\n正确的保存口令的方式是不存储用户的明文口令，而是存储用户口令的哈希，比如MD5：\n\n\n\nusername\npassword\n\n\n\n\nmichael\ne10adc3949ba59abbe56e057f20f883e\n\n\nbob\n878ef96e86145580c38c87f0410ad153\n\n\nalice\n99b1c2188db85afee403b1536010c2c9\n\n\n\n当用户登录时，首先计算用户输入的明文口令的MD5，然后和数据库存储的MD5对比，如果一致，说明口令输入正确，如果不一致，口令肯定错误。\n练习\n根据用户输入的口令，计算出存储在数据库中的MD5口令：\n12def calc_md5(password):    pass\n存储MD5的好处是即使运维人员能访问数据库，也无法获知用户的明文口令。\n设计一个验证用户登录的函数，根据用户输入的口令是否正确，返回True或False：\n1234567891011121314151617db = &#123;    &#x27;michael&#x27;: &#x27;e10adc3949ba59abbe56e057f20f883e&#x27;,    &#x27;bob&#x27;: &#x27;878ef96e86145580c38c87f0410ad153&#x27;,    &#x27;alice&#x27;: &#x27;99b1c2188db85afee403b1536010c2c9&#x27;&#125;def login(user, password):    pass# 测试:assert login(&#x27;michael&#x27;, &#x27;123456&#x27;)assert login(&#x27;bob&#x27;, &#x27;abc999&#x27;)assert login(&#x27;alice&#x27;, &#x27;alice2008&#x27;)assert not login(&#x27;michael&#x27;, &#x27;1234567&#x27;)assert not login(&#x27;bob&#x27;, &#x27;123456&#x27;)assert not login(&#x27;alice&#x27;, &#x27;Alice2008&#x27;)print(&#x27;ok&#x27;)\n采用MD5存储口令是否就一定安全呢？也不一定。假设你是一个黑客，已经拿到了存储MD5口令的数据库，如何通过MD5反推用户的明文口令呢？暴力破解费事费力，真正的黑客不会这么干。\n考虑这么个情况，很多用户喜欢用123456，888888，password这些简单的口令，于是，黑客可以事先计算出这些常用口令的MD5值，得到一个反推表：\n123456hash_to_plain = &#123;    &#x27;e10adc3949ba59abbe56e057f20f883e&#x27;: &#x27;123456&#x27;,    &#x27;21218cca77804d2ba1922c33e0151105&#x27;: &#x27;888888&#x27;,    &#x27;5f4dcc3b5aa765d61d8327deb882cf99&#x27;: &#x27;password&#x27;,    &#x27;...&#x27;: &#x27;...&#x27;&#125;\n这样，无需破解，只需要对比数据库的MD5，黑客就获得了使用常用口令的用户账号。\n对于用户来讲，当然不要使用过于简单的口令。但是，我们能否在程序设计上对简单口令加强保护呢？\n由于常用口令的MD5值很容易被计算出来，所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，这一方法通过对原始口令加一个复杂字符串来实现，俗称“加盐”：\n12def calc_md5(password):    return get_md5(password + &#x27;the-Salt&#x27;)\n经过Salt处理的MD5口令，只要Salt不被黑客知道，即使用户输入简单口令，也很难通过MD5反推明文口令。\n但是如果有两个用户都使用了相同的简单口令比如123456，在数据库中，将存储两条相同的MD5值，这说明这两个用户的口令是一样的。有没有办法让使用相同口令的用户存储不同的MD5呢？\n如果假定用户无法修改登录名，就可以通过把登录名作为Salt的一部分来计算MD5，从而实现相同口令的用户也存储不同的MD5。\n练习\n根据用户输入的登录名和口令模拟用户注册，计算更安全的MD5：\n1234db = &#123;&#125;def register(username, password):    db[username] = get_md5(password + username + &#x27;the-Salt&#x27;)\n然后，根据修改后的MD5算法实现用户登录的验证：\n1234567891011121314151617181920212223242526272829import hashlib, randomclass User(object):    def __init__(self, username, password):        self.username = username        self.salt = &#x27;&#x27;.join([chr(random.randint(48, 122)) for i in range(20)])        self.password = get_md5(password + self.salt)db = &#123;    &#x27;michael&#x27;: User(&#x27;michael&#x27;, &#x27;123456&#x27;),    &#x27;bob&#x27;: User(&#x27;bob&#x27;, &#x27;abc999&#x27;),    &#x27;alice&#x27;: User(&#x27;alice&#x27;, &#x27;alice2008&#x27;)&#125;def get_md5(user, pws):    return ???def login(username, password):    user = db[username]    return user.password == get_md5(user, password)# 测试:assert login(&#x27;michael&#x27;, &#x27;123456&#x27;)assert login(&#x27;bob&#x27;, &#x27;abc999&#x27;)assert login(&#x27;alice&#x27;, &#x27;alice2008&#x27;)assert not login(&#x27;michael&#x27;, &#x27;1234567&#x27;)assert not login(&#x27;bob&#x27;, &#x27;123456&#x27;)assert not login(&#x27;alice&#x27;, &#x27;Alice2008&#x27;)print(&#x27;ok&#x27;)\n小结\n哈希算法在很多地方都有广泛的应用。要注意哈希算法不是加密算法，不能用于加密（因为无法通过哈希反推明文），只能用于防篡改，但是它的单向计算特性决定了可以在不存储明文口令的情况下验证用户口令。\n参考源码\nuse_hashlib.py\n通过哈希算法，我们可以验证一段数据是否有效，方法就是对比该数据的哈希值，例如，判断用户口令是否正确，我们用保存在数据库中的password_md5对比计算md5(password)的结果，如果一致，用户输入的口令就是正确的。\n为了防止黑客通过彩虹表根据哈希值反推原始口令，在计算哈希的时候，不能仅针对原始输入计算，需要增加一个salt来使得相同的输入也能得到不同的哈希，这样，大大增加了黑客破解的难度。\n如果salt是我们自己随机生成的，通常我们计算MD5时采用md5(message + salt)。但实际上，把salt看做一个“口令”，加salt的哈希就是：计算一段message的哈希时，根据不同口令计算出不同的哈希。要验证哈希值，必须同时提供正确的口令。\n这实际上就是Hmac算法：Keyed-Hashing for Message Authentication。它通过一个标准算法，在计算哈希的过程中，把key混入计算过程中。\n和我们自定义的加salt算法不同，Hmac算法针对所有哈希算法都通用，无论是MD5还是SHA-1。采用Hmac替代我们自己的salt算法，可以使程序算法更标准化，也更安全。\nPython自带的hmac模块实现了标准的Hmac算法。我们来看看如何使用hmac实现带key的哈希。\n我们首先需要准备待计算的原始消息message，随机key，哈希算法，这里采用MD5，使用hmac的代码如下：\n1234567&gt;&gt;&gt; import hmac&gt;&gt;&gt; message = b&#x27;Hello, world!&#x27;&gt;&gt;&gt; key = b&#x27;secret&#x27;&gt;&gt;&gt; h = hmac.new(key, message, digestmod=&#x27;MD5&#x27;)&gt;&gt;&gt; # 如果消息很长，可以多次调用h.update(msg)&gt;&gt;&gt; h.hexdigest()&#x27;fa4ee7d173f2d97ee79022d1a7355bcf&#x27;\n可见使用hmac和普通hash算法非常类似。hmac输出的长度和原始哈希算法的长度一致。需要注意传入的key和message都是bytes类型，str类型需要首先编码为bytes。\n练习\n将上一节的salt改为标准的hmac算法，验证用户口令：\n1234567891011121314151617181920212223242526272829import hmac, randomdef hmac_md5(key, s):    return hmac.new(key.encode(&#x27;utf-8&#x27;), s.encode(&#x27;utf-8&#x27;), &#x27;MD5&#x27;).hexdigest()class User(object):    def __init__(self, username, password):        self.username = username        self.key = &#x27;&#x27;.join([chr(random.randint(48, 122)) for i in range(20)])        self.password = hmac_md5(self.key, password)db = &#123;    &#x27;michael&#x27;: User(&#x27;michael&#x27;, &#x27;123456&#x27;),    &#x27;bob&#x27;: User(&#x27;bob&#x27;, &#x27;abc999&#x27;),    &#x27;alice&#x27;: User(&#x27;alice&#x27;, &#x27;alice2008&#x27;)&#125;def login(username, password):    user = db[username]    return user.password == hmac_md5(user.key, password)# 测试:assert login(&#x27;michael&#x27;, &#x27;123456&#x27;)assert login(&#x27;bob&#x27;, &#x27;abc999&#x27;)assert login(&#x27;alice&#x27;, &#x27;alice2008&#x27;)assert not login(&#x27;michael&#x27;, &#x27;1234567&#x27;)assert not login(&#x27;bob&#x27;, &#x27;123456&#x27;)assert not login(&#x27;alice&#x27;, &#x27;Alice2008&#x27;)print(&#x27;ok&#x27;)\n小结\nPython内置的hmac模块实现了标准的Hmac算法，它利用一个key对message计算“杂凑”后的hash，使用hmac算法比标准hash算法更安全，因为针对相同的message，不同的key会产生不同的hash。\nPython的内建模块itertools提供了非常有用的用于操作迭代对象的函数。\n首先，我们看看itertools提供的几个“无限”迭代器：\n123456789&gt;&gt;&gt; import itertools&gt;&gt;&gt; natuals = itertools.count(1)&gt;&gt;&gt; for n in natuals:...     print(n)...123...\n因为count()会创建一个无限的迭代器，所以上述代码会打印出自然数序列，根本停不下来，只能按Ctrl+C退出。\ncycle()会把传入的一个序列无限重复下去：\n123456789101112&gt;&gt;&gt; import itertools&gt;&gt;&gt; cs = itertools.cycle(&#x27;ABC&#x27;) # 注意字符串也是序列的一种&gt;&gt;&gt; for c in cs:...     print(c)...&#x27;A&#x27;&#x27;B&#x27;&#x27;C&#x27;&#x27;A&#x27;&#x27;B&#x27;&#x27;C&#x27;...\n同样停不下来。\nrepeat()负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数：\n1234567&gt;&gt;&gt; ns = itertools.repeat(&#x27;A&#x27;, 3)&gt;&gt;&gt; for n in ns:...     print(n)...AAA\n无限序列只有在for迭代时才会无限地迭代下去，如果只是创建了一个迭代对象，它不会事先把无限个元素生成出来，事实上也不可能在内存中创建无限多个元素。\n无限序列虽然可以无限迭代下去，但是通常我们会通过takewhile()等函数根据条件判断来截取出一个有限的序列：\n1234&gt;&gt;&gt; natuals = itertools.count(1)&gt;&gt;&gt; ns = itertools.takewhile(lambda x: x &lt;= 10, natuals)&gt;&gt;&gt; list(ns)[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nitertools提供的几个迭代器操作函数更加有用：\nchain()\nchain()可以把一组迭代对象串联起来，形成一个更大的迭代器：\n123&gt;&gt;&gt; for c in itertools.chain(&#x27;ABC&#x27;, &#x27;XYZ&#x27;):...     print(c)# 迭代效果：&#x27;A&#x27; &#x27;B&#x27; &#x27;C&#x27; &#x27;X&#x27; &#x27;Y&#x27; &#x27;Z&#x27;\ngroupby()\ngroupby()把迭代器中相邻的重复元素挑出来放在一起：\n1234567&gt;&gt;&gt; for key, group in itertools.groupby(&#x27;AAABBBCCAAA&#x27;):...     print(key, list(group))...A [&#x27;A&#x27;, &#x27;A&#x27;, &#x27;A&#x27;]B [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;]C [&#x27;C&#x27;, &#x27;C&#x27;]A [&#x27;A&#x27;, &#x27;A&#x27;, &#x27;A&#x27;]\n实际上挑选规则是通过函数完成的，只要作用于函数的两个元素返回的值相等，这两个元素就被认为是在一组的，而函数返回值作为组的key。如果我们要忽略大小写分组，就可以让元素'A'和'a'都返回相同的key：\n1234567&gt;&gt;&gt; for key, group in itertools.groupby(&#x27;AaaBBbcCAAa&#x27;, lambda c: c.upper()):...     print(key, list(group))...A [&#x27;A&#x27;, &#x27;a&#x27;, &#x27;a&#x27;]B [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;b&#x27;]C [&#x27;c&#x27;, &#x27;C&#x27;]A [&#x27;A&#x27;, &#x27;A&#x27;, &#x27;a&#x27;]\n练习\n计算圆周率可以根据公式：\n利用Python提供的itertools模块，我们来计算这个序列的前N项和：\n1234567891011121314151617181920212223import itertoolsdef pi(N):    &#x27; 计算pi的值 &#x27;    # step 1: 创建一个奇数序列: 1, 3, 5, 7, 9, ...    # step 2: 取该序列的前N项: 1, 3, 5, 7, 9, ..., 2*N-1.    # step 3: 添加正负符号并用4除: 4/1, -4/3, 4/5, -4/7, 4/9, ...    # step 4: 求和:    return 3.14# 测试:print(pi(10))print(pi(100))print(pi(1000))print(pi(10000))assert 3.04 &lt; pi(10) &lt; 3.05assert 3.13 &lt; pi(100) &lt; 3.14assert 3.140 &lt; pi(1000) &lt; 3.141assert 3.1414 &lt; pi(10000) &lt; 3.1415print(&#x27;ok&#x27;)\n小结\nitertools模块提供的全部是处理迭代功能的函数，它们的返回值不是list，而是Iterator，只有用for循环迭代的时候才真正计算。\n参考源码\nuse_itertools.py\n在Python中，读写文件这样的资源要特别注意，必须在使用完毕后正确关闭它们。正确关闭文件资源的一个方法是使用try...finally：\n123456try:    f = open(&#x27;/path/to/file&#x27;, &#x27;r&#x27;)    f.read()finally:    if f:        f.close()\n写try...finally非常繁琐。Python的with语句允许我们非常方便地使用资源，而不必担心资源没有关闭，所以上面的代码可以简化为：\n12with open(&#x27;/path/to/file&#x27;, &#x27;r&#x27;) as f:    f.read()\n并不是只有open()函数返回的fp对象才能使用with语句。实际上，任何对象，只要正确实现了上下文管理，就可以用于with语句。\n实现上下文管理是通过__enter__和__exit__这两个方法实现的。例如，下面的class实现了这两个方法：\n12345678910111213141516class Query(object):    def __init__(self, name):        self.name = name    def __enter__(self):        print(&#x27;Begin&#x27;)        return self        def __exit__(self, exc_type, exc_value, traceback):        if exc_type:            print(&#x27;Error&#x27;)        else:            print(&#x27;End&#x27;)        def query(self):        print(&#x27;Query info about %s...&#x27; % self.name)\n这样我们就可以把自己写的资源对象用于with语句：\n12with Query(&#x27;Bob&#x27;) as q:    q.query()\n@contextmanager\n编写__enter__和__exit__仍然很繁琐，因此Python的标准库contextlib提供了更简单的写法，上面的代码可以改写如下：\n123456789101112131415from contextlib import contextmanagerclass Query(object):    def __init__(self, name):        self.name = name    def query(self):        print(&#x27;Query info about %s...&#x27; % self.name)@contextmanagerdef create_query(name):    print(&#x27;Begin&#x27;)    q = Query(name)    yield q    print(&#x27;End&#x27;)\n@contextmanager这个decorator接受一个generator，用yield语句把with ... as var把变量输出出去，然后，with语句就可以正常地工作了：\n12with create_query(&#x27;Bob&#x27;) as q:    q.query()\n很多时候，我们希望在某段代码执行前后自动执行特定代码，也可以用@contextmanager实现。例如：\n123456789@contextmanagerdef tag(name):    print(&quot;&lt;%s&gt;&quot; % name)    yield    print(&quot;&lt;/%s&gt;&quot; % name)with tag(&quot;h1&quot;):    print(&quot;hello&quot;)    print(&quot;world&quot;)\n上述代码执行结果为：\n1234&lt;h1&gt;helloworld&lt;/h1&gt;\n代码的执行顺序是：\n\nwith语句首先执行yield之前的语句，因此打印出&lt;h1&gt;；\nyield调用会执行with语句内部的所有语句，因此打印出hello和world；\n最后执行yield之后的语句，打印出&lt;/h1&gt;。\n\n因此，@contextmanager让我们通过编写generator来简化上下文管理。\n@closing\n如果一个对象没有实现上下文，我们就不能把它用于with语句。这个时候，可以用closing()来把该对象变为上下文对象。例如，用with语句使用urlopen()：\n123456from contextlib import closingfrom urllib.request import urlopenwith closing(urlopen(&#x27;https://www.python.org&#x27;)) as page:    for line in page:        print(line)\nclosing也是一个经过@contextmanager装饰的generator，这个generator编写起来其实非常简单：\n123456@contextmanagerdef closing(thing):    try:        yield thing    finally:        thing.close()\n它的作用就是把任意对象变为上下文对象，并支持with语句。\n@contextlib还有一些其他decorator，便于我们编写更简洁的代码。\nurllib提供了一系列用于操作URL的功能。\nGet\nurllib的request模块可以非常方便地抓取URL内容，也就是发送一个GET请求到指定的页面，然后返回HTTP的响应：\n例如，对豆瓣的一个URLhttps://api.douban.com/v2/book/2129650进行抓取，并返回响应：\n12345678from urllib import requestwith request.urlopen(&#x27;https://api.douban.com/v2/book/2129650&#x27;) as f:    data = f.read()    print(&#x27;Status:&#x27;, f.status, f.reason)    for k, v in f.getheaders():        print(&#x27;%s: %s&#x27; % (k, v))    print(&#x27;Data:&#x27;, data.decode(&#x27;utf-8&#x27;))\n可以看到HTTP响应的头和JSON数据：\n1234567891011Status: 200 OKServer: nginxDate: Tue, 26 May 2015 10:02:27 GMTContent-Type: application/json; charset=utf-8Content-Length: 2049Connection: closeExpires: Sun, 1 Jan 2006 01:00:00 GMTPragma: no-cacheCache-Control: must-revalidate, no-cache, privateX-DAE-Node: pidl1Data: &#123;&quot;rating&quot;:&#123;&quot;max&quot;:10,&quot;numRaters&quot;:16,&quot;average&quot;:&quot;7.4&quot;,&quot;min&quot;:0&#125;,&quot;subtitle&quot;:&quot;&quot;,&quot;author&quot;:[&quot;廖雪峰编著&quot;],&quot;pubdate&quot;:&quot;2007-6&quot;,...&#125;\n如果我们要想模拟浏览器发送GET请求，就需要使用Request对象，通过往Request对象添加HTTP头，我们就可以把请求伪装成浏览器。例如，模拟iPhone去请求豆瓣首页：\n123456789from urllib import requestreq = request.Request(&#x27;http://www.douban.com/&#x27;)req.add_header(&#x27;User-Agent&#x27;, &#x27;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&#x27;)with request.urlopen(req) as f:    print(&#x27;Status:&#x27;, f.status, f.reason)    for k, v in f.getheaders():        print(&#x27;%s: %s&#x27; % (k, v))    print(&#x27;Data:&#x27;, f.read().decode(&#x27;utf-8&#x27;))\n这样豆瓣会返回适合iPhone的移动版网页：\n12345...    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0&quot;&gt;    &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;    &lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;57x57&quot; href=&quot;http://img4.douban.com/pics/cardkit/launcher/57.png&quot; /&gt;...\nPost\n如果要以POST发送一个请求，只需要把参数data以bytes形式传入。\n我们模拟一个微博登录，先读取登录的邮箱和口令，然后按照weibo.cn的登录页的格式以username=xxx&amp;password=xxx的编码传入：\n12345678910111213141516171819202122232425from urllib import request, parseprint(&#x27;Login to weibo.cn...&#x27;)email = input(&#x27;Email: &#x27;)passwd = input(&#x27;Password: &#x27;)login_data = parse.urlencode([    (&#x27;username&#x27;, email),    (&#x27;password&#x27;, passwd),    (&#x27;entry&#x27;, &#x27;mweibo&#x27;),    (&#x27;client_id&#x27;, &#x27;&#x27;),    (&#x27;savestate&#x27;, &#x27;1&#x27;),    (&#x27;ec&#x27;, &#x27;&#x27;),    (&#x27;pagerefer&#x27;, &#x27;https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F&#x27;)])req = request.Request(&#x27;https://passport.weibo.cn/sso/login&#x27;)req.add_header(&#x27;Origin&#x27;, &#x27;https://passport.weibo.cn&#x27;)req.add_header(&#x27;User-Agent&#x27;, &#x27;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&#x27;)req.add_header(&#x27;Referer&#x27;, &#x27;https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F&#x27;)with request.urlopen(req, data=login_data.encode(&#x27;utf-8&#x27;)) as f:    print(&#x27;Status:&#x27;, f.status, f.reason)    for k, v in f.getheaders():        print(&#x27;%s: %s&#x27; % (k, v))    print(&#x27;Data:&#x27;, f.read().decode(&#x27;utf-8&#x27;))\n如果登录成功，我们获得的响应如下：\n123456Status: 200 OKServer: nginx/1.2.0...Set-Cookie: SSOLoginState=1432620126; path=/; domain=weibo.cn...Data: &#123;&quot;retcode&quot;:20000000,&quot;msg&quot;:&quot;&quot;,&quot;data&quot;:&#123;...,&quot;uid&quot;:&quot;1658384301&quot;&#125;&#125;\n如果登录失败，我们获得的响应如下：\n12...Data: &#123;&quot;retcode&quot;:50011015,&quot;msg&quot;:&quot;\\u7528\\u6237\\u540d\\u6216\\u5bc6\\u7801\\u9519\\u8bef&quot;,&quot;data&quot;:&#123;&quot;username&quot;:&quot;example@python.org&quot;,&quot;errline&quot;:536&#125;&#125;\nHandler\n如果还需要更复杂的控制，比如通过一个Proxy去访问网站，我们需要利用ProxyHandler来处理，示例代码如下：\n123456proxy_handler = urllib.request.ProxyHandler(&#123;&#x27;http&#x27;: &#x27;http://www.example.com:3128/&#x27;&#125;)proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()proxy_auth_handler.add_password(&#x27;realm&#x27;, &#x27;host&#x27;, &#x27;username&#x27;, &#x27;password&#x27;)opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)with opener.open(&#x27;http://www.example.com/login.html&#x27;) as f:    pass\n小结\nurllib提供的功能就是利用程序去执行各种HTTP请求。如果要模拟浏览器完成特定功能，需要把请求伪装成浏览器。伪装的方法是先监控浏览器发出的请求，再根据浏览器的请求头来伪装，User-Agent头就是用来标识浏览器的。\n练习\n利用urllib读取JSON，然后将JSON解析为Python对象：\n1234567891011from urllib import requestdef fetch_data(url):    return &#x27;&#x27;# 测试URL = &#x27;https://api.weatherapi.com/v1/current.json?key=b4e8f86b44654e6b86885330242207&amp;q=Beijing&amp;aqi=no&#x27;data = fetch_data(URL)print(data)assert data[&#x27;location&#x27;][&#x27;name&#x27;] == &#x27;Beijing&#x27;print(&#x27;ok&#x27;)\n参考源码\nuse_urllib.py\nXML\nXML虽然比JSON复杂，在Web中应用也不如以前多了，不过仍有很多地方在用，所以，有必要了解如何操作XML。\nDOM vs SAX\n操作XML有两种方法：DOM和SAX。DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。\n正常情况下，优先考虑SAX，因为DOM实在太占内存。\n在Python中使用SAX解析XML非常简洁，通常我们关心的事件是start_element，end_element和char_data，准备好这3个函数，然后就可以解析xml了。\n举个例子，当SAX解析器读到一个节点时：\n1&lt;a href=&quot;/&quot;&gt;python&lt;/a&gt;\n会产生3个事件：\n\nstart_element事件，在读取&lt;a href=&quot;/&quot;&gt;时；\nchar_data事件，在读取python时；\nend_element事件，在读取&lt;/a&gt;时。\n\n用代码实验一下：\n12345678910111213141516171819202122232425from xml.parsers.expat import ParserCreateclass DefaultSaxHandler(object):    def start_element(self, name, attrs):        print(&#x27;sax:start_element: %s, attrs: %s&#x27; % (name, str(attrs)))    def end_element(self, name):        print(&#x27;sax:end_element: %s&#x27; % name)    def char_data(self, text):        print(&#x27;sax:char_data: %s&#x27; % text)xml = r&#x27;&#x27;&#x27;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;ol&gt;    &lt;li&gt;&lt;a href=&quot;/python&quot;&gt;Python&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;/ruby&quot;&gt;Ruby&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&#x27;&#x27;&#x27;handler = DefaultSaxHandler()parser = ParserCreate()parser.StartElementHandler = handler.start_elementparser.EndElementHandler = handler.end_elementparser.CharacterDataHandler = handler.char_dataparser.Parse(xml)\n需要注意的是读取一大段字符串时，CharacterDataHandler可能被多次调用，所以需要自己保存起来，在EndElementHandler里面再合并。\n除了解析XML外，如何生成XML呢？99%的情况下需要生成的XML结构都是非常简单的，因此，最简单也是最有效的生成XML的方法是拼接字符串：\n123456L = []L.append(r&#x27;&lt;?xml version=&quot;1.0&quot;?&gt;&#x27;)L.append(r&#x27;&lt;root&gt;&#x27;)L.append(encode(&#x27;some &amp; data&#x27;))L.append(r&#x27;&lt;/root&gt;&#x27;)return &#x27;&#x27;.join(L)\n如果要生成复杂的XML呢？建议你不要用XML，改成JSON。\n小结\n解析XML时，注意找出自己感兴趣的节点，响应事件时，把节点数据保存起来。解析完毕后，就可以处理数据。\n练习\n请利用SAX编写程序解析WeatherAPI的XML格式的天气预报，获取天气预报：\n12345678910111213141516171819202122from xml.parsers.expat import ParserCreatefrom urllib import requestdef parseXml(xml_str):    print(xml_str)    return &#123;        &#x27;city&#x27;: &#x27;?&#x27;,        &#x27;weather&#x27;: &#123;            &#x27;condition&#x27;: &#x27;Sunny&#x27;,            &#x27;temperature&#x27;: 37.2,            &#x27;wind&#x27;: 9.7        &#125;    &#125;# 测试:URL = &#x27;https://api.weatherapi.com/v1/current.xml?key=b4e8f86b44654e6b86885330242207&amp;q=Beijing&amp;aqi=no&#x27;with request.urlopen(URL, timeout=4) as f:    data = f.read()result = parseXml(data.decode(&#x27;utf-8&#x27;))assert result[&#x27;city&#x27;] == &#x27;Beijing&#x27;\n参考源码\nuse_sax.py\nHTMLParser\n如果我们要编写一个搜索引擎，第一步是用爬虫把目标网站的页面抓下来，第二步就是解析该HTML页面，看看里面的内容到底是新闻、图片还是视频。\n假设第一步已经完成了，第二步应该如何解析HTML呢？\nHTML本质上是XML的子集，但是HTML的语法没有XML那么严格，所以不能用标准的DOM或SAX来解析HTML。\n好在Python提供了HTMLParser来非常方便地解析HTML，只需简单几行代码：\n1234567891011121314151617181920212223242526272829303132from html.parser import HTMLParserfrom html.entities import name2codepointclass MyHTMLParser(HTMLParser):    def handle_starttag(self, tag, attrs):        print(&#x27;&lt;%s&gt;&#x27; % tag)    def handle_endtag(self, tag):        print(&#x27;&lt;/%s&gt;&#x27; % tag)    def handle_startendtag(self, tag, attrs):        print(&#x27;&lt;%s/&gt;&#x27; % tag)    def handle_data(self, data):        print(data)    def handle_comment(self, data):        print(&#x27;&lt;!--&#x27;, data, &#x27;--&gt;&#x27;)    def handle_entityref(self, name):        print(&#x27;&amp;%s;&#x27; % name)    def handle_charref(self, name):        print(&#x27;&amp;#%s;&#x27; % name)parser = MyHTMLParser()parser.feed(&#x27;&#x27;&#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- test html parser --&gt;    &lt;p&gt;Some &lt;a href=\\&quot;#\\&quot;&gt;html&lt;/a&gt; HTML&amp;nbsp;tutorial...&lt;br&gt;END&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;&#x27;&#x27;)\nfeed()方法可以多次调用，也就是不一定一次把整个HTML字符串都塞进去，可以一部分一部分塞进去。\n特殊字符有两种，一种是英文表示的&amp;nbsp;，一种是数字表示的&amp;#1234;，这两种字符都可以通过Parser解析出来。\n小结\n利用HTMLParser，可以把网页中的文本、图像等解析出来。\n练习\n找一个网页，例如https://www.python.org/events/python-events/，用浏览器查看源码并复制，然后尝试解析一下HTML，输出Python官网发布的会议时间、名称和地点。\n参考源码\nuse_htmlparser.py\n在开发Python应用程序的时候，系统安装的Python3只有一个版本：3.x。所有第三方的包都会被pip安装到Python3的site-packages目录下。\n如果我们要同时开发多个应用程序，那这些应用程序都会共用一个Python，就是安装在系统的Python 3。如果应用A需要jinja 2.7，而应用B需要jinja 2.6怎么办？\n这种情况下，每个应用可能需要各自拥有一套“独立”的Python运行环境。venv就是用来为一个应用创建一套“隔离”的Python运行环境。\n首先，我们假定要开发一个新的项目project101，需要一套独立的Python运行环境，可以这么做：\n第一步，创建目录，这里把Python虚拟运行环境命名为proj101env，因此目录名为proj101env：\n123$ mkdir proj101env$ cd proj101env/proj101env$\n第二步，创建一个独立的Python运行环境：\n1proj101env$ python3 -m venv .\n查看当前目录，可以发现有几个文件夹和一个pyvenv.cfg文件：\n12proj101env$ lsbin  include  lib  pyvenv.cfg\n命令python3 -m venv &lt;目录&gt;就可以创建一个独立的Python运行环境。观察bin目录的内容，里面有python3、pip3等可执行文件，实际上是链接到Python系统目录的软链接。\n继续进入bin目录，Linux/Mac用source activate，Windows用activate.bat激活该venv环境：\n123proj101env$ cd binbin$ source activate(proj101env) bin$\n注意到命令提示符变了，有个(proj101env)前缀，表示当前环境是一个名为proj101env的Python环境。\n下面正常安装各种第三方包，并运行python命令：\n1234567(proj101env) bin$ pip3 install jinja2...Successfully installed jinja2-xxx(proj101env) bin$ python3&gt;&gt;&gt; import jinja2&gt;&gt;&gt; exit()\n在venv环境下，用pip安装的包都被安装到proj101env这个环境下，具体目录是proj101env/lib/python3.x/site-packages，因此，系统Python环境不受任何影响。也就是说，proj101env环境是专门针对project101这个应用创建的。\n退出当前的proj101env环境，使用deactivate命令：\n12(proj101env) bin$ deactivatebin$\n此时就回到了正常的环境，现在pip或python均是在系统Python环境下执行。\n完全可以针对每个应用创建独立的Python运行环境，这样就可以对每个应用的Python环境进行隔离。\nvenv是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python链接或复制一份到venv的环境，用命令source activate进入一个venv环境时，venv会修改相关环境变量，让命令python和pip均指向当前的venv环境。\n如果不再使用某个venv，例如proj101env，删除它也很简单。首先确认该venv没有处于“激活”状态，然后直接把整个目录proj101env删掉就行。\n小结\nvenv为应用提供了隔离的Python运行环境，解决了不同应用间安装多版本的冲突问题。\n","dateCreated":"2016-04-25T23:10:34+08:00","dateModified":"2025-06-18T11:28:38+08:00","datePublished":"2016-04-25T23:10:34+08:00","description":"","headline":"12.python常用内建模块","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://keinchan.com/2016/04/25/python/12.python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97/"},"publisher":{"@type":"Organization","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg","logo":{"@type":"ImageObject","url":"profile.jpg"}},"url":"https://keinchan.com/2016/04/25/python/12.python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97/","keywords":"python"}</script>
    <meta name="description" content="Python之所以自称“batteries included”，就是因为内置了许多非常有用的模块，无需额外安装和配置，即可直接使用。 本章将介绍一些常用的内建模块。 datetime是Python处理日期和时间的标准库。 获取当前日期和时间 我们先看如何获取当前日期和时间： 123456&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; n">
<meta property="og:type" content="blog">
<meta property="og:title" content="12.python常用内建模块">
<meta property="og:url" content="https://keinchan.com/2016/04/25/python/12.python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:description" content="Python之所以自称“batteries included”，就是因为内置了许多非常有用的模块，无需额外安装和配置，即可直接使用。 本章将介绍一些常用的内建模块。 datetime是Python处理日期和时间的标准库。 获取当前日期和时间 我们先看如何获取当前日期和时间： 123456&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; n">
<meta property="og:locale" content="zh_TW">
<meta property="article:published_time" content="2016-04-25T15:10:34.000Z">
<meta property="article:modified_time" content="2025-06-18T03:28:38.332Z">
<meta property="article:author" content="Kein Chan">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://keinchan.com../../../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../../../#about"
            >
        
        
            <img class="header-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            12.python常用内建模块
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2016-04-25T23:10:34+08:00">
	
		    2016 年 4 月 25 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/">python</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>Python之所以自称“batteries included”，就是因为内置了许多非常有用的模块，无需额外安装和配置，即可直接使用。</p>
<p>本章将介绍一些常用的内建模块。</p>
<p><code>datetime</code>是Python处理日期和时间的标准库。</p>
<h3 id="获取当前日期和时间">获取当前日期和时间</h3>
<p>我们先看如何获取当前日期和时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime</span><br><span class="line">&gt;&gt;&gt; now = datetime.now() # 获取当前datetime</span><br><span class="line">&gt;&gt;&gt; print(now)</span><br><span class="line">2015-05-18 16:28:07.198690</span><br><span class="line">&gt;&gt;&gt; print(type(now))</span><br><span class="line">&lt;class &#x27;datetime.datetime&#x27;&gt;</span><br></pre></td></tr></table></figure>
<p>注意到<code>datetime</code>是模块，<code>datetime</code>模块还包含一个<code>datetime</code>类，通过<code>from datetime import datetime</code>导入的才是<code>datetime</code>这个类。</p>
<p>如果仅导入<code>import datetime</code>，则必须引用全名<code>datetime.datetime</code>。</p>
<p><code>datetime.now()</code>返回当前日期和时间，其类型是<code>datetime</code>。</p>
<h3 id="获取指定日期和时间">获取指定日期和时间</h3>
<p>要指定某个日期和时间，我们直接用参数构造一个<code>datetime</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime</span><br><span class="line">&gt;&gt;&gt; dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime</span><br><span class="line">&gt;&gt;&gt; print(dt)</span><br><span class="line">2015-04-19 12:20:00</span><br></pre></td></tr></table></figure>
<h3 id="datetime转换为timestamp">datetime转换为timestamp</h3>
<p>在计算机中，时间实际上是用数字表示的。我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为<code>0</code>（1970年以前的时间timestamp为负数），当前时间就是相对于epoch time的秒数，称为timestamp。</p>
<p>你可以认为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timestamp = 0 = 1970-1-1 00:00:00 UTC+0:00</span><br></pre></td></tr></table></figure>
<p>对应的北京时间是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timestamp = 0 = 1970-1-1 08:00:00 UTC+8:00</span><br></pre></td></tr></table></figure>
<p>可见timestamp的值与时区毫无关系，因为timestamp一旦确定，其UTC时间就确定了，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）。</p>
<p>把一个<code>datetime</code>类型转换为timestamp只需要简单调用<code>timestamp()</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime</span><br><span class="line">&gt;&gt;&gt; dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime</span><br><span class="line">&gt;&gt;&gt; dt.timestamp() # 把datetime转换为timestamp</span><br><span class="line">1429417200.0</span><br></pre></td></tr></table></figure>
<p>注意Python的timestamp是一个浮点数，整数位表示秒。</p>
<p>某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法。</p>
<h3 id="timestamp转换为datetime">timestamp转换为datetime</h3>
<p>要把timestamp转换为<code>datetime</code>，使用<code>datetime</code>提供的<code>fromtimestamp()</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime</span><br><span class="line">&gt;&gt;&gt; t = 1429417200.0</span><br><span class="line">&gt;&gt;&gt; print(datetime.fromtimestamp(t))</span><br><span class="line">2015-04-19 12:20:00</span><br></pre></td></tr></table></figure>
<p>注意到timestamp是一个浮点数，它没有时区的概念，而datetime是有时区的。上述转换是在timestamp和本地时间做转换。</p>
<p>本地时间是指当前操作系统设定的时区。例如北京时区是东8区，则本地时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2015-04-19 12:20:00</span><br></pre></td></tr></table></figure>
<p>实际上就是UTC+8:00时区的时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2015-04-19 12:20:00 UTC+8:00</span><br></pre></td></tr></table></figure>
<p>而此刻的格林威治标准时间与北京时间差了8小时，也就是UTC+0:00时区的时间应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2015-04-19 04:20:00 UTC+0:00</span><br></pre></td></tr></table></figure>
<p>timestamp也可以直接被转换到UTC标准时区的时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime</span><br><span class="line">&gt;&gt;&gt; t = 1429417200.0</span><br><span class="line">&gt;&gt;&gt; print(datetime.fromtimestamp(t)) # 本地时间</span><br><span class="line">2015-04-19 12:20:00</span><br><span class="line">&gt;&gt;&gt; print(datetime.utcfromtimestamp(t)) # UTC时间</span><br><span class="line">2015-04-19 04:20:00</span><br></pre></td></tr></table></figure>
<h3 id="str转换为datetime">str转换为datetime</h3>
<p>很多时候，用户输入的日期和时间是字符串，要处理日期和时间，首先必须把str转换为datetime。转换方法是通过<code>datetime.strptime()</code>实现，需要一个日期和时间的格式化字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime</span><br><span class="line">&gt;&gt;&gt; cday = datetime.strptime(&#x27;2015-6-1 18:19:59&#x27;, &#x27;%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">&gt;&gt;&gt; print(cday)</span><br><span class="line">2015-06-01 18:19:59</span><br></pre></td></tr></table></figure>
<p>字符串<code>'%Y-%m-%d %H:%M:%S'</code>规定了日期和时间部分的格式。详细的说明请参考<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior">Python文档</a>。</p>
<p>注意转换后的datetime是没有时区信息的。</p>
<h3 id="datetime转换为str">datetime转换为str</h3>
<p>如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过<code>strftime()</code>实现的，同样需要一个日期和时间的格式化字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime</span><br><span class="line">&gt;&gt;&gt; now = datetime.now()</span><br><span class="line">&gt;&gt;&gt; print(now.strftime(&#x27;%a, %b %d %H:%M&#x27;))</span><br><span class="line">Mon, May 05 16:28</span><br></pre></td></tr></table></figure>
<h3 id="datetime加减">datetime加减</h3>
<p>对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用<code>+</code>和<code>-</code>运算符，不过需要导入<code>timedelta</code>这个类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime, timedelta</span><br><span class="line">&gt;&gt;&gt; now = datetime.now()</span><br><span class="line">&gt;&gt;&gt; now</span><br><span class="line">datetime.datetime(2015, 5, 18, 16, 57, 3, 540997)</span><br><span class="line">&gt;&gt;&gt; now + timedelta(hours=10)</span><br><span class="line">datetime.datetime(2015, 5, 19, 2, 57, 3, 540997)</span><br><span class="line">&gt;&gt;&gt; now - timedelta(days=1)</span><br><span class="line">datetime.datetime(2015, 5, 17, 16, 57, 3, 540997)</span><br><span class="line">&gt;&gt;&gt; now + timedelta(days=2, hours=12)</span><br><span class="line">datetime.datetime(2015, 5, 21, 4, 57, 3, 540997)</span><br></pre></td></tr></table></figure>
<p>可见，使用<code>timedelta</code>你可以很容易地算出前几天和后几天的时刻。</p>
<h3 id="本地时间转换为UTC时间">本地时间转换为UTC时间</h3>
<p>本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。</p>
<p>一个<code>datetime</code>类型有一个时区属性<code>tzinfo</code>，但是默认为<code>None</code>，所以无法区分这个<code>datetime</code>到底是哪个时区，除非强行给<code>datetime</code>设置一个时区：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime, timedelta, timezone</span><br><span class="line">&gt;&gt;&gt; tz_utc_8 = timezone(timedelta(hours=8)) # 创建时区UTC+8:00</span><br><span class="line">&gt;&gt;&gt; now = datetime.now()</span><br><span class="line">&gt;&gt;&gt; now</span><br><span class="line">datetime.datetime(2015, 5, 18, 17, 2, 10, 871012)</span><br><span class="line">&gt;&gt;&gt; dt = now.replace(tzinfo=tz_utc_8) # 强制设置为UTC+8:00</span><br><span class="line">&gt;&gt;&gt; dt</span><br><span class="line">datetime.datetime(2015, 5, 18, 17, 2, 10, 871012, tzinfo=datetime.timezone(datetime.timedelta(0, 28800)))</span><br></pre></td></tr></table></figure>
<p>如果系统时区恰好是UTC+8:00，那么上述代码就是正确的，否则，不能强制设置为UTC+8:00时区。</p>
<h3 id="时区转换">时区转换</h3>
<p>我们可以先通过<code>utcnow()</code>拿到当前的UTC时间，再转换为任意时区的时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 拿到UTC时间，并强制设置时区为UTC+0:00:</span><br><span class="line">&gt;&gt;&gt; utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)</span><br><span class="line">&gt;&gt;&gt; print(utc_dt)</span><br><span class="line">2015-05-18 09:05:12.377316+00:00</span><br><span class="line"># astimezone()将转换时区为北京时间:</span><br><span class="line">&gt;&gt;&gt; bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))</span><br><span class="line">&gt;&gt;&gt; print(bj_dt)</span><br><span class="line">2015-05-18 17:05:12.377316+08:00</span><br><span class="line"># astimezone()将转换时区为东京时间:</span><br><span class="line">&gt;&gt;&gt; tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours=9)))</span><br><span class="line">&gt;&gt;&gt; print(tokyo_dt)</span><br><span class="line">2015-05-18 18:05:12.377316+09:00</span><br><span class="line"># astimezone()将bj_dt转换时区为东京时间:</span><br><span class="line">&gt;&gt;&gt; tokyo_dt2 = bj_dt.astimezone(timezone(timedelta(hours=9)))</span><br><span class="line">&gt;&gt;&gt; print(tokyo_dt2)</span><br><span class="line">2015-05-18 18:05:12.377316+09:00</span><br></pre></td></tr></table></figure>
<p>时区转换的关键在于，拿到一个<code>datetime</code>时，要获知其正确的时区，然后强制设置时区，作为基准时间。</p>
<p>利用带时区的<code>datetime</code>，通过<code>astimezone()</code>方法，可以转换到任意时区。</p>
<p>注：不是必须从UTC+0:00时区转换到其他时区，任何带时区的<code>datetime</code>都可以正确转换，例如上述<code>bj_dt</code>到<code>tokyo_dt</code>的转换。</p>
<h3 id="小结">小结</h3>
<p><code>datetime</code>表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。</p>
<p>如果要存储<code>datetime</code>，最佳方法是将其转换为timestamp再存储，因为timestamp的值与时区完全无关。</p>
<h3 id="练习">练习</h3>
<p>假设你获取了用户输入的日期和时间如<code>2015-1-21 9:01:30</code>，以及一个时区信息如<code>UTC+5:00</code>，均是<code>str</code>，请编写一个函数将其转换为timestamp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timezone, timedelta</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_timestamp</span>(<span class="params">dt_str, tz_str</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试:</span></span><br><span class="line">t1 = to_timestamp(<span class="string">&#x27;2015-6-1 08:10:30&#x27;</span>, <span class="string">&#x27;UTC+7:00&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> t1 == <span class="number">1433121030.0</span>, t1</span><br><span class="line"></span><br><span class="line">t2 = to_timestamp(<span class="string">&#x27;2015-5-31 16:10:30&#x27;</span>, <span class="string">&#x27;UTC-09:00&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> t2 == <span class="number">1433121030.0</span>, t2</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="参考源码">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/built-in-modules/datetime/use_datetime.py">use_datetime.py</a></p>
<p><code>collections</code>是Python内建的一个集合模块，提供了许多有用的集合类。</p>
<h3 id="namedtuple">namedtuple</h3>
<p>我们知道<code>tuple</code>可以表示不变集合，例如，一个点的二维坐标就可以表示成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p = (1, 2)</span><br></pre></td></tr></table></figure>
<p>但是，看到<code>(1, 2)</code>，很难看出这个<code>tuple</code>是用来表示一个坐标的。</p>
<p>定义一个<code>class</code>又小题大做了，这时，<code>namedtuple</code>就派上了用场：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import namedtuple</span><br><span class="line">&gt;&gt;&gt; Point = namedtuple(&#x27;Point&#x27;, [&#x27;x&#x27;, &#x27;y&#x27;])</span><br><span class="line">&gt;&gt;&gt; p = Point(1, 2)</span><br><span class="line">&gt;&gt;&gt; p.x</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; p.y</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p><code>namedtuple</code>是一个函数，它用来创建一个自定义的<code>tuple</code>对象，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。</p>
<p>这样一来，我们用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用，使用十分方便。</p>
<p>可以验证创建的<code>Point</code>对象是<code>tuple</code>的一种子类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(p, Point)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(p, tuple)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>类似的，如果要用坐标和半径表示一个圆，也可以用<code>namedtuple</code>定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># namedtuple(&#x27;名称&#x27;, [属性list]):</span></span><br><span class="line">Circle = namedtuple(<span class="string">&#x27;Circle&#x27;</span>, [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;r&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h3 id="deque">deque</h3>
<p>使用<code>list</code>存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为<code>list</code>是线性存储，数据量大的时候，插入和删除效率很低。</p>
<p><code>deque</code>是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import deque</span><br><span class="line">&gt;&gt;&gt; q = deque([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])</span><br><span class="line">&gt;&gt;&gt; q.append(&#x27;x&#x27;)</span><br><span class="line">&gt;&gt;&gt; q.appendleft(&#x27;y&#x27;)</span><br><span class="line">&gt;&gt;&gt; q</span><br><span class="line">deque([&#x27;y&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;x&#x27;])</span><br></pre></td></tr></table></figure>
<p><code>deque</code>除了实现list的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p>
<h3 id="defaultdict">defaultdict</h3>
<p>使用<code>dict</code>时，如果引用的Key不存在，就会抛出<code>KeyError</code>。如果希望key不存在时，返回一个默认值，就可以用<code>defaultdict</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import defaultdict</span><br><span class="line">&gt;&gt;&gt; dd = defaultdict(lambda: &#x27;N/A&#x27;)</span><br><span class="line">&gt;&gt;&gt; dd[&#x27;key1&#x27;] = &#x27;abc&#x27;</span><br><span class="line">&gt;&gt;&gt; dd[&#x27;key1&#x27;] # key1存在</span><br><span class="line">&#x27;abc&#x27;</span><br><span class="line">&gt;&gt;&gt; dd[&#x27;key2&#x27;] # key2不存在，返回默认值</span><br><span class="line">&#x27;N/A&#x27;</span><br></pre></td></tr></table></figure>
<p>注意默认值是调用函数返回的，而函数在创建<code>defaultdict</code>对象时传入。</p>
<p>除了在Key不存在时返回默认值，<code>defaultdict</code>的其他行为跟<code>dict</code>是完全一样的。</p>
<h3 id="OrderedDict">OrderedDict</h3>
<p>使用<code>dict</code>时，Key是无序的。在对<code>dict</code>做迭代时，我们无法确定Key的顺序。</p>
<p>如果要保持Key的顺序，可以用<code>OrderedDict</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import OrderedDict</span><br><span class="line">&gt;&gt;&gt; d = dict([(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 3)])</span><br><span class="line">&gt;&gt;&gt; d # dict的Key是无序的</span><br><span class="line">&#123;&#x27;a&#x27;: 1, &#x27;c&#x27;: 3, &#x27;b&#x27;: 2&#125;</span><br><span class="line">&gt;&gt;&gt; od = OrderedDict([(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 3)])</span><br><span class="line">&gt;&gt;&gt; od # OrderedDict的Key是有序的</span><br><span class="line">OrderedDict([(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 3)])</span><br></pre></td></tr></table></figure>
<p>注意，<code>OrderedDict</code>的Key会按照插入的顺序排列，不是Key本身排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; od = OrderedDict()</span><br><span class="line">&gt;&gt;&gt; od[&#x27;z&#x27;] = 1</span><br><span class="line">&gt;&gt;&gt; od[&#x27;y&#x27;] = 2</span><br><span class="line">&gt;&gt;&gt; od[&#x27;x&#x27;] = 3</span><br><span class="line">&gt;&gt;&gt; list(od.keys()) # 按照插入的Key的顺序返回</span><br><span class="line">[&#x27;z&#x27;, &#x27;y&#x27;, &#x27;x&#x27;]</span><br></pre></td></tr></table></figure>
<p><code>OrderedDict</code>可以实现一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的Key：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LastUpdatedOrderedDict</span>(<span class="title class_ inherited__">OrderedDict</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity</span>):</span><br><span class="line">        <span class="built_in">super</span>(LastUpdatedOrderedDict, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>._capacity = capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        containsKey = <span class="number">1</span> <span class="keyword">if</span> key <span class="keyword">in</span> <span class="variable language_">self</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>) - containsKey &gt;= <span class="variable language_">self</span>._capacity:</span><br><span class="line">            last = <span class="variable language_">self</span>.popitem(last=<span class="literal">False</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;remove:&#x27;</span>, last)</span><br><span class="line">        <span class="keyword">if</span> containsKey:</span><br><span class="line">            <span class="keyword">del</span> <span class="variable language_">self</span>[key]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;set:&#x27;</span>, (key, value))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;add:&#x27;</span>, (key, value))</span><br><span class="line">        OrderedDict.__setitem__(<span class="variable language_">self</span>, key, value)</span><br></pre></td></tr></table></figure>
<h3 id="ChainMap">ChainMap</h3>
<p><code>ChainMap</code>可以把一组<code>dict</code>串起来并组成一个逻辑上的<code>dict</code>。<code>ChainMap</code>本身也是一个dict，但是查找的时候，会按照顺序在内部的dict依次查找。</p>
<p>什么时候使用<code>ChainMap</code>最合适？举个例子：应用程序往往都需要传入参数，参数可以通过命令行传入，可以通过环境变量传入，还可以有默认参数。我们可以用<code>ChainMap</code>实现参数的优先级查找，即先查命令行参数，如果没有传入，再查环境变量，如果没有，就使用默认参数。</p>
<p>下面的代码演示了如何查找<code>user</code>和<code>color</code>这两个参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line"><span class="keyword">import</span> os, argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造缺省参数:</span></span><br><span class="line">defaults = &#123;</span><br><span class="line">    <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;guest&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造命令行参数:</span></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-u&#x27;</span>, <span class="string">&#x27;--user&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;--color&#x27;</span>)</span><br><span class="line">namespace = parser.parse_args()</span><br><span class="line">command_line_args = &#123; k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">vars</span>(namespace).items() <span class="keyword">if</span> v &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合成ChainMap:</span></span><br><span class="line">combined = ChainMap(command_line_args, os.environ, defaults)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印参数:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;color=%s&#x27;</span> % combined[<span class="string">&#x27;color&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;user=%s&#x27;</span> % combined[<span class="string">&#x27;user&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>没有任何参数时，打印出默认参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python3 use_chainmap.py </span><br><span class="line">color=red</span><br><span class="line">user=guest</span><br></pre></td></tr></table></figure>
<p>当传入命令行参数时，优先使用命令行参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python3 use_chainmap.py -u bob</span><br><span class="line">color=red</span><br><span class="line">user=bob</span><br></pre></td></tr></table></figure>
<p>同时传入命令行参数和环境变量，命令行参数的优先级较高：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ user=admin color=green python3 use_chainmap.py -u bob</span><br><span class="line">color=green</span><br><span class="line">user=bob</span><br></pre></td></tr></table></figure>
<h3 id="Counter">Counter</h3>
<p><code>Counter</code>是一个简单的计数器，例如，统计字符出现的个数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Counter</span><br><span class="line">&gt;&gt;&gt; c = Counter(&#x27;programming&#x27;)</span><br><span class="line">&gt;&gt;&gt; for ch in &#x27;programming&#x27;:</span><br><span class="line">...     c[ch] = c[ch] + 1</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">Counter(&#123;&#x27;g&#x27;: 2, &#x27;m&#x27;: 2, &#x27;r&#x27;: 2, &#x27;a&#x27;: 1, &#x27;i&#x27;: 1, &#x27;o&#x27;: 1, &#x27;n&#x27;: 1, &#x27;p&#x27;: 1&#125;)</span><br><span class="line">&gt;&gt;&gt; c.update(&#x27;hello&#x27;) # 也可以一次性update</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">Counter(&#123;&#x27;r&#x27;: 2, &#x27;o&#x27;: 2, &#x27;g&#x27;: 2, &#x27;m&#x27;: 2, &#x27;l&#x27;: 2, &#x27;p&#x27;: 1, &#x27;a&#x27;: 1, &#x27;i&#x27;: 1, &#x27;n&#x27;: 1, &#x27;h&#x27;: 1, &#x27;e&#x27;: 1&#125;)</span><br></pre></td></tr></table></figure>
<p><code>Counter</code>实际上也是<code>dict</code>的一个子类，上面的结果可以看出每个字符出现的次数。</p>
<h3 id="小结-2">小结</h3>
<p><code>collections</code>模块提供了一些有用的集合类，可以根据需要选用。</p>
<h3 id="参考源码-2">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/built-in-modules/collections/use_collections.py">use_collections.py</a></p>
<p>在命令行程序中，经常需要获取命令行参数。Python内置的<code>sys.argv</code>保存了完整的参数列表，我们可以从中解析出需要的参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># copy.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.argv)</span><br><span class="line">source = sys.argv[<span class="number">1</span>]</span><br><span class="line">target = sys.argv[<span class="number">2</span>]</span><br><span class="line"><span class="comment"># TODO...</span></span><br></pre></td></tr></table></figure>
<p>运行上述<code>copy.py</code>，并传入参数，打印如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;copy.py&#x27;, &#x27;source.txt&#x27;, &#x27;copy.txt&#x27;]</span><br></pre></td></tr></table></figure>
<p>这种方式能应付简单的参数，但参数稍微复杂点，比如可以使用<code>-d</code>复制目录，使用<code>--filename *.py</code>过滤文件名等，解析起来就非常麻烦。</p>
<p>为了简化参数解析，我们可以使用内置的<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/argparse.html">argparse</a>库，定义好各个参数类型后，它能直接返回有效的参数。</p>
<p>假设我们想编写一个备份MySQL数据库的命令行程序，需要输入的参数如下：</p>
<ul>
<li>host参数：表示MySQL主机名或IP，不输入则默认为<code>localhost</code>；</li>
<li>port参数：表示MySQL的端口号，int类型，不输入则默认为<code>3306</code>；</li>
<li>user参数：表示登录MySQL的用户名，必须输入；</li>
<li>password参数：表示登录MySQL的口令，必须输入；</li>
<li>gz参数：表示是否压缩备份文件，不输入则默认为<code>False</code>；</li>
<li>outfile参数：表示备份文件保存在哪，必须输入。</li>
</ul>
<p>其中，<code>outfile</code>是位置参数，而其他则是类似<code>--user root</code>这样的“关键字”参数。</p>
<p>用<code>argparse</code>来解析参数，一个完整的示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># backup.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 定义一个ArgumentParser实例:</span></span><br><span class="line">    parser = argparse.ArgumentParser(</span><br><span class="line">        prog=<span class="string">&#x27;backup&#x27;</span>, <span class="comment"># 程序名</span></span><br><span class="line">        description=<span class="string">&#x27;Backup MySQL database.&#x27;</span>, <span class="comment"># 描述</span></span><br><span class="line">        epilog=<span class="string">&#x27;Copyright(r), 2023&#x27;</span> <span class="comment"># 说明信息</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 定义位置参数:</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;outfile&#x27;</span>)</span><br><span class="line">    <span class="comment"># 定义关键字参数:</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--host&#x27;</span>, default=<span class="string">&#x27;localhost&#x27;</span>)</span><br><span class="line">    <span class="comment"># 此参数必须为int类型:</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--port&#x27;</span>, default=<span class="string">&#x27;3306&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line">    <span class="comment"># 允许用户输入简写的-u:</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-u&#x27;</span>, <span class="string">&#x27;--user&#x27;</span>, required=<span class="literal">True</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-p&#x27;</span>, <span class="string">&#x27;--password&#x27;</span>, required=<span class="literal">True</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--database&#x27;</span>, required=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># gz参数不跟参数值，因此指定action=&#x27;store_true&#x27;，意思是出现-gz表示True:</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-gz&#x27;</span>, <span class="string">&#x27;--gzcompress&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, required=<span class="literal">False</span>, <span class="built_in">help</span>=<span class="string">&#x27;Compress backup files by gz.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析参数:</span></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印参数:</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;parsed args:&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;outfile = <span class="subst">&#123;args.outfile&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;host = <span class="subst">&#123;args.host&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;port = <span class="subst">&#123;args.port&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;user = <span class="subst">&#123;args.user&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;password = <span class="subst">&#123;args.password&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;database = <span class="subst">&#123;args.database&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;gzcompress = <span class="subst">&#123;args.gzcompress&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>输入有效的参数，则程序能解析出所需的所有参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./backup.py -u root -p hello --database testdb backup.sql</span><br><span class="line">parsed args:</span><br><span class="line">outfile = backup.sql</span><br><span class="line">host = localhost</span><br><span class="line">port = 3306</span><br><span class="line">user = root</span><br><span class="line">password = hello</span><br><span class="line">database = testdb</span><br><span class="line">gzcompress = False</span><br></pre></td></tr></table></figure>
<p>缺少必要的参数，或者参数不对，将报告详细的错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./backup.py --database testdb backup.sql</span><br><span class="line">usage: backup [-h] [--host HOST] [--port PORT] -u USER -p PASSWORD --database DATABASE outfile</span><br><span class="line">backup: error: the following arguments are required: -u/--user, -p/--password</span><br></pre></td></tr></table></figure>
<p>更神奇的是，如果输入<code>-h</code>，则打印帮助信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ./backup.py -h                          </span><br><span class="line">usage: backup [-h] [--host HOST] [--port PORT] -u USER -p PASSWORD --database DATABASE outfile</span><br><span class="line"></span><br><span class="line">Backup MySQL database.</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  outfile</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  --host HOST</span><br><span class="line">  --port PORT</span><br><span class="line">  -u USER, --user USER</span><br><span class="line">  -p PASSWORD, --password PASSWORD</span><br><span class="line">  --database DATABASE</span><br><span class="line">  -gz, --gzcompress     Compress backup files by gz.</span><br><span class="line"></span><br><span class="line">Copyright(r), 2023</span><br></pre></td></tr></table></figure>
<p>获取有效参数的代码实际上是这一行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure>
<p>我们不必捕获异常，<code>parse_args()</code>非常方便的一点在于，如果参数有问题，则它打印出错误信息后，结束进程；如果参数是<code>-h</code>，则它打印帮助信息后，结束进程。只有当参数全部有效时，才会返回一个<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/argparse.html#argparse.Namespace">NameSpace</a>对象，获取对应的参数就把参数名当作属性获取，非常方便。</p>
<p>可见，使用<code>argparse</code>后，解析参数的工作被大大简化了，我们可以专注于定义参数，然后直接获取到有效的参数输入。</p>
<h3 id="小结-3">小结</h3>
<p>使用<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/argparse.html">argparse</a>解析参数，只需定义好参数类型，就可以获得有效的参数输入，能大大简化获取命令行参数的工作。</p>
<p>Base64是一种用64个字符来表示任意二进制数据的方法。</p>
<p>用记事本打开<code>exe</code>、<code>jpg</code>、<code>pdf</code>这些文件时，我们都会看到一大堆乱码，因为二进制文件包含很多无法显示和打印的字符，所以，如果要让记事本这样的文本处理软件能处理二进制数据，就需要一个二进制到字符串的转换方法。Base64是一种最常见的二进制编码方法。</p>
<p>Base64的原理很简单，首先，准备一个包含64个字符的数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, ... <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, ... <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, ... <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;/&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>然后，对二进制数据进行处理，每3个字节一组，一共是<code>3x8=24</code>bit，划为4组，每组正好6个bit：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────┬───────────────┬───────────────┐</span><br><span class="line">│      b1       │      b2       │      b3       │</span><br><span class="line">├─┬─┬─┬─┬─┬─┬─┬─┼─┬─┬─┬─┬─┬─┬─┬─┼─┬─┬─┬─┬─┬─┬─┬─┤</span><br><span class="line">│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │</span><br><span class="line">├─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─┴─┤</span><br><span class="line">│    n1     │    n2     │    n3     │    n4     │</span><br><span class="line">└───────────┴───────────┴───────────┴───────────┘</span><br></pre></td></tr></table></figure>
<p>这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。</p>
<p>所以，Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。</p>
<p>如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用<code>\x00</code>字节在末尾补足后，再在编码的末尾加上1个或2个<code>=</code>号，表示补了多少字节，解码的时候，会自动去掉。</p>
<p>Python内置的<code>base64</code>可以直接进行base64的编解码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import base64</span><br><span class="line">&gt;&gt;&gt; base64.b64encode(b&#x27;binary\x00string&#x27;)</span><br><span class="line">b&#x27;YmluYXJ5AHN0cmluZw==&#x27;</span><br><span class="line">&gt;&gt;&gt; base64.b64decode(b&#x27;YmluYXJ5AHN0cmluZw==&#x27;)</span><br><span class="line">b&#x27;binary\x00string&#x27;</span><br></pre></td></tr></table></figure>
<p>由于标准的Base64编码后可能出现字符<code>+</code>和<code>/</code>，在URL中就不能直接作为参数，所以又有一种&quot;url safe&quot;的base64编码，其实就是把字符<code>+</code>和<code>/</code>分别变成<code>-</code>和<code>_</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; base64.b64encode(b&#x27;i\xb7\x1d\xfb\xef\xff&#x27;)</span><br><span class="line">b&#x27;abcd++//&#x27;</span><br><span class="line">&gt;&gt;&gt; base64.urlsafe_b64encode(b&#x27;i\xb7\x1d\xfb\xef\xff&#x27;)</span><br><span class="line">b&#x27;abcd--__&#x27;</span><br><span class="line">&gt;&gt;&gt; base64.urlsafe_b64decode(&#x27;abcd--__&#x27;)</span><br><span class="line">b&#x27;i\xb7\x1d\xfb\xef\xff&#x27;</span><br></pre></td></tr></table></figure>
<p>还可以自己定义64个字符的排列顺序，这样就可以自定义Base64编码，不过，通常情况下完全没有必要。</p>
<p>Base64是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行。</p>
<p>Base64适用于小段内容的编码，比如数字证书签名、Cookie的内容等。</p>
<p>由于<code>=</code>字符也可能出现在Base64编码中，但<code>=</code>用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把<code>=</code>去掉：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 标准Base64:</span><br><span class="line">&#x27;abcd&#x27; -&gt; &#x27;YWJjZA==&#x27;</span><br><span class="line"># 自动去掉=:</span><br><span class="line">&#x27;abcd&#x27; -&gt; &#x27;YWJjZA&#x27;</span><br></pre></td></tr></table></figure>
<p>去掉<code>=</code>后怎么解码呢？因为Base64是把3个字节变为4个字节，所以，Base64编码的长度永远是4的倍数，因此，需要加上<code>=</code>把Base64字符串的长度变为4的倍数，就可以正常解码了。</p>
<h3 id="小结-4">小结</h3>
<p>Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。</p>
<h3 id="练习-2">练习</h3>
<p>请写一个能处理去掉<code>=</code>的base64解码函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">safe_base64_decode</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试:</span></span><br><span class="line"><span class="keyword">assert</span> <span class="string">b&#x27;abcd&#x27;</span> == safe_base64_decode(<span class="string">&#x27;YWJjZA==&#x27;</span>), safe_base64_decode(<span class="string">&#x27;YWJjZA==&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="string">b&#x27;abcd&#x27;</span> == safe_base64_decode(<span class="string">&#x27;YWJjZA&#x27;</span>), safe_base64_decode(<span class="string">&#x27;YWJjZA&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="参考源码-3">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/built-in-modules/base64/do_base64.py">do_base64.py</a></p>
<p>准确地讲，Python没有专门处理字节的数据类型。但由于<code>b'str'</code>可以表示字节，所以，字节数组＝二进制<code>str</code>。而在C语言中，我们可以很方便地用<code>struct</code>、<code>union</code>来处理字节，以及字节和<code>int</code>，<code>float</code>的转换。</p>
<p>在Python中，比方说要把一个32位无符号整数变成字节，也就是4个长度的<code>bytes</code>，你得配合位运算符这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n = 10240099</span><br><span class="line">&gt;&gt;&gt; b1 = (n &amp; 0xff000000) &gt;&gt; 24</span><br><span class="line">&gt;&gt;&gt; b2 = (n &amp; 0xff0000) &gt;&gt; 16</span><br><span class="line">&gt;&gt;&gt; b3 = (n &amp; 0xff00) &gt;&gt; 8</span><br><span class="line">&gt;&gt;&gt; b4 = n &amp; 0xff</span><br><span class="line">&gt;&gt;&gt; bs = bytes([b1, b2, b3, b4])</span><br><span class="line">&gt;&gt;&gt; bs</span><br><span class="line">b&#x27;\x00\x9c@c&#x27;</span><br></pre></td></tr></table></figure>
<p>非常麻烦。如果换成浮点数就无能为力了。</p>
<p>好在Python提供了一个<code>struct</code>模块来解决<code>bytes</code>和其他二进制数据类型的转换。</p>
<p><code>struct</code>的<code>pack</code>函数把任意数据类型变成<code>bytes</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import struct</span><br><span class="line">&gt;&gt;&gt; struct.pack(&#x27;&gt;I&#x27;, 10240099)</span><br><span class="line">b&#x27;\x00\x9c@c&#x27;</span><br></pre></td></tr></table></figure>
<p><code>pack</code>的第一个参数是处理指令，<code>'&gt;I'</code>的意思是：</p>
<p><code>&gt;</code>表示字节顺序是big-endian，也就是网络序，<code>I</code>表示4字节无符号整数。</p>
<p>后面的参数个数要和处理指令一致。</p>
<p><code>unpack</code>把<code>bytes</code>变成相应的数据类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; struct.unpack(&#x27;&gt;IH&#x27;, b&#x27;\xf0\xf0\xf0\xf0\x80\x80&#x27;)</span><br><span class="line">(4042322160, 32896)</span><br></pre></td></tr></table></figure>
<p>根据<code>&gt;IH</code>的说明，后面的<code>bytes</code>依次变为<code>I</code>：4字节无符号整数和<code>H</code>：2字节无符号整数。</p>
<p>所以，尽管Python不适合编写底层操作字节流的代码，但在对性能要求不高的地方，利用<code>struct</code>就方便多了。</p>
<p><code>struct</code>模块定义的数据类型可以参考Python官方文档：</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/struct.html#format-characters">https://docs.python.org/3/library/struct.html#format-characters</a></p>
<p>Windows的位图文件（.bmp）是一种非常简单的文件格式，我们来用<code>struct</code>分析一下。</p>
<p>首先找一个bmp文件，没有的话用“画图”画一个。</p>
<p>读入前30个字节来分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = b&#x27;\x42\x4d\x38\x8c\x0a\x00\x00\x00\x00\x00\x36\x00\x00\x00\x28\x00\x00\x00\x80\x02\x00\x00\x68\x01\x00\x00\x01\x00\x18\x00&#x27;</span><br></pre></td></tr></table></figure>
<p>BMP格式采用小端方式存储数据，文件头的结构按顺序如下：</p>
<p>两个字节：<code>'BM'</code>表示Windows位图，<code>'BA'</code>表示OS/2位图； 一个4字节整数：表示位图大小； 一个4字节整数：保留位，始终为0； 一个4字节整数：实际图像的偏移量； 一个4字节整数：Header的字节数； 一个4字节整数：图像宽度； 一个4字节整数：图像高度； 一个2字节整数：始终为1； 一个2字节整数：颜色数。</p>
<p>所以，组合起来用<code>unpack</code>读取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; struct.unpack(&#x27;&lt;ccIIIIIIHH&#x27;, s)</span><br><span class="line">(b&#x27;B&#x27;, b&#x27;M&#x27;, 691256, 0, 54, 40, 640, 360, 1, 24)</span><br></pre></td></tr></table></figure>
<p>结果显示，<code>b'B'</code>、<code>b'M'</code>说明是Windows位图，位图大小为640x360，颜色数为24。</p>
<p>请编写一个<code>bmpinfo.py</code>，可以检查任意文件是否是位图文件，如果是，打印出图片大小和颜色数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64, struct</span><br><span class="line">bmp_data = base64.b64decode(<span class="string">&#x27;Qk1oAgAAAAAAADYAAAAoAAAAHAAAAAoAAAABABAAAAAAADICAAASCwAAEgsAA&#x27;</span> +</span><br><span class="line">                   <span class="string">&#x27;AAAAAAAAAAA/3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3/&#x27;</span> +</span><br><span class="line">                   <span class="string">&#x27;/f/9//3//f/9//3//f/9/AHwAfAB8AHwAfAB8AHwAfP9//3//fwB8AHwAfAB8/3//f/9/A&#x27;</span> +</span><br><span class="line">                   <span class="string">&#x27;HwAfAB8AHz/f/9//3//f/9//38AfAB8AHwAfAB8AHwAfAB8AHz/f/9//38AfAB8/3//f/9&#x27;</span> +</span><br><span class="line">                   <span class="string">&#x27;//3//fwB8AHz/f/9//3//f/9//3//f/9/AHwAfP9//3//f/9/AHwAfP9//3//fwB8AHz/f&#x27;</span> +</span><br><span class="line">                   <span class="string">&#x27;/9//3//f/9/AHwAfP9//3//f/9//3//f/9//38AfAB8AHwAfAB8AHwAfP9//3//f/9/AHw&#x27;</span> +</span><br><span class="line">                   <span class="string">&#x27;AfP9//3//f/9//38AfAB8/3//f/9//3//f/9//3//fwB8AHwAfAB8AHwAfAB8/3//f/9//&#x27;</span> +</span><br><span class="line">                   <span class="string">&#x27;38AfAB8/3//f/9//3//fwB8AHz/f/9//3//f/9//3//f/9/AHwAfP9//3//f/9/AHwAfP9&#x27;</span> +</span><br><span class="line">                   <span class="string">&#x27;//3//fwB8AHz/f/9/AHz/f/9/AHwAfP9//38AfP9//3//f/9/AHwAfAB8AHwAfAB8AHwAf&#x27;</span> +</span><br><span class="line">                   <span class="string">&#x27;AB8/3//f/9/AHwAfP9//38AfAB8AHwAfAB8AHwAfAB8/3//f/9//38AfAB8AHwAfAB8AHw&#x27;</span> +</span><br><span class="line">                   <span class="string">&#x27;AfAB8/3//f/9/AHwAfAB8AHz/fwB8AHwAfAB8AHwAfAB8AHz/f/9//3//f/9//3//f/9//&#x27;</span> +</span><br><span class="line">                   <span class="string">&#x27;3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//38AAA==&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bmp_info</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;width&#x27;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&#x27;height&#x27;</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="string">&#x27;color&#x27;</span>: <span class="number">24</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">bi = bmp_info(bmp_data)</span><br><span class="line"><span class="keyword">assert</span> bi[<span class="string">&#x27;width&#x27;</span>] == <span class="number">28</span></span><br><span class="line"><span class="keyword">assert</span> bi[<span class="string">&#x27;height&#x27;</span>] == <span class="number">10</span></span><br><span class="line"><span class="keyword">assert</span> bi[<span class="string">&#x27;color&#x27;</span>] == <span class="number">16</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="参考源码-4">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/built-in-modules/struct/check_bmp.py">check_bmp.py</a></p>
<h3 id="哈希算法简介">哈希算法简介</h3>
<p>Python的<code>hashlib</code>提供了常见的哈希算法，如MD5，SHA1等等。</p>
<p>什么是哈希算法呢？哈希算法又称摘要算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。</p>
<p>举个例子，你写了一篇文章，内容是一个字符串<code>'how to use python hashlib - by Michael'</code>，并附上这篇文章的哈希是<code>'2d73d4f15c0db7f5ecb321b6a65e5d6d'</code>。如果有人篡改了你的文章，并发表为<code>'how to use python hashlib - by Bob'</code>，你可以一下子指出Bob篡改了你的文章，因为根据<code>'how to use python hashlib - by Bob'</code>计算出的哈希不同于原始文章的哈希。</p>
<p>可见，哈希算法就是通过哈希函数<code>hash(data)</code>对任意长度的数据<code>data</code>计算出固定长度的哈希<code>digest</code>，目的是为了发现原始数据是否被人篡改过。</p>
<p>哈希算法之所以能指出数据是否被篡改过，就是因为哈希函数是一个单向函数，计算<code>digest=hash(data)</code>很容易，但通过<code>digest</code>反推<code>data</code>却非常困难。而且，对原始数据做一个bit的修改，都会导致计算出的哈希完全不同。</p>
<p>我们以常见的哈希算法MD5为例，计算出一个字符串的MD5值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line">md5.update(<span class="string">&#x27;how to use md5 in python hashlib?&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(md5.hexdigest())</span><br></pre></td></tr></table></figure>
<p>计算结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d26a53750bc40b38b65a520292f69306</span><br></pre></td></tr></table></figure>
<p>如果数据量很大，可以分块多次调用<code>update()</code>，最后计算的结果是一样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line">md5.update(<span class="string">&#x27;how to use md5 in &#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">md5.update(<span class="string">&#x27;python hashlib?&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(md5.hexdigest())</span><br></pre></td></tr></table></figure>
<p>试试改动一个字母，看看计算的结果是否完全不同。</p>
<p>MD5是最常见的哈希算法，速度很快，生成结果是固定的128 bit/16字节，通常用一个32位的16进制字符串表示。</p>
<p>另一种常见的哈希算法是SHA1，调用SHA1和调用MD5完全类似：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">sha1 = hashlib.sha1()</span><br><span class="line">sha1.update(<span class="string">&#x27;how to use sha1 in &#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">sha1.update(<span class="string">&#x27;python hashlib?&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(sha1.hexdigest())</span><br></pre></td></tr></table></figure>
<p>SHA1的结果是160 bit/20字节，通常用一个40位的16进制字符串表示。</p>
<p>比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法不仅越慢，而且哈希长度更长。</p>
<p>有没有可能两个不同的数据通过某个哈希算法得到了相同的哈希？完全有可能，因为任何哈希算法都是把无限多的数据集合映射到一个有限的集合中。这种情况称为碰撞，比如Bob试图根据你的哈希反推出一篇文章<code>'how to learn hashlib in python - by Bob'</code>，并且这篇文章的哈希恰好和你的文章完全一致，这种情况也并非不可能出现，但是非常非常困难。</p>
<h3 id="哈希算法应用">哈希算法应用</h3>
<p>哈希算法能应用到什么地方？举个常用例子：</p>
<p>任何允许用户登录的网站都会存储用户登录的用户名和口令。如何存储用户名和口令呢？方法是存到数据库表中：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>password</th>
</tr>
</thead>
<tbody>
<tr>
<td>michael</td>
<td>123456</td>
</tr>
<tr>
<td>bob</td>
<td>abc999</td>
</tr>
<tr>
<td>alice</td>
<td>alice2008</td>
</tr>
</tbody>
</table>
<p>如果以明文保存用户口令，如果数据库泄露，所有用户的口令就落入黑客的手里。此外，网站运维人员是可以访问数据库的，也就是能获取到所有用户的口令。</p>
<p>正确的保存口令的方式是不存储用户的明文口令，而是存储用户口令的哈希，比如MD5：</p>
<table>
<thead>
<tr>
<th>username</th>
<th>password</th>
</tr>
</thead>
<tbody>
<tr>
<td>michael</td>
<td>e10adc3949ba59abbe56e057f20f883e</td>
</tr>
<tr>
<td>bob</td>
<td>878ef96e86145580c38c87f0410ad153</td>
</tr>
<tr>
<td>alice</td>
<td>99b1c2188db85afee403b1536010c2c9</td>
</tr>
</tbody>
</table>
<p>当用户登录时，首先计算用户输入的明文口令的MD5，然后和数据库存储的MD5对比，如果一致，说明口令输入正确，如果不一致，口令肯定错误。</p>
<h3 id="练习-3">练习</h3>
<p>根据用户输入的口令，计算出存储在数据库中的MD5口令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc_md5</span>(<span class="params">password</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>存储MD5的好处是即使运维人员能访问数据库，也无法获知用户的明文口令。</p>
<p>设计一个验证用户登录的函数，根据用户输入的口令是否正确，返回True或False：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">db = &#123;</span><br><span class="line">    <span class="string">&#x27;michael&#x27;</span>: <span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;bob&#x27;</span>: <span class="string">&#x27;878ef96e86145580c38c87f0410ad153&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;alice&#x27;</span>: <span class="string">&#x27;99b1c2188db85afee403b1536010c2c9&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">user, password</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试:</span></span><br><span class="line"><span class="keyword">assert</span> login(<span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> login(<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;abc999&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> login(<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;alice2008&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> login(<span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;1234567&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> login(<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> login(<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;Alice2008&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>采用MD5存储口令是否就一定安全呢？也不一定。假设你是一个黑客，已经拿到了存储MD5口令的数据库，如何通过MD5反推用户的明文口令呢？暴力破解费事费力，真正的黑客不会这么干。</p>
<p>考虑这么个情况，很多用户喜欢用<code>123456</code>，<code>888888</code>，<code>password</code>这些简单的口令，于是，黑客可以事先计算出这些常用口令的MD5值，得到一个反推表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hash_to_plain = &#123;</span><br><span class="line">    <span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>: <span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;21218cca77804d2ba1922c33e0151105&#x27;</span>: <span class="string">&#x27;888888&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;5f4dcc3b5aa765d61d8327deb882cf99&#x27;</span>: <span class="string">&#x27;password&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;...&#x27;</span>: <span class="string">&#x27;...&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，无需破解，只需要对比数据库的MD5，黑客就获得了使用常用口令的用户账号。</p>
<p>对于用户来讲，当然不要使用过于简单的口令。但是，我们能否在程序设计上对简单口令加强保护呢？</p>
<p>由于常用口令的MD5值很容易被计算出来，所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，这一方法通过对原始口令加一个复杂字符串来实现，俗称“加盐”：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc_md5</span>(<span class="params">password</span>):</span><br><span class="line">    <span class="keyword">return</span> get_md5(password + <span class="string">&#x27;the-Salt&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>经过Salt处理的MD5口令，只要Salt不被黑客知道，即使用户输入简单口令，也很难通过MD5反推明文口令。</p>
<p>但是如果有两个用户都使用了相同的简单口令比如<code>123456</code>，在数据库中，将存储两条相同的MD5值，这说明这两个用户的口令是一样的。有没有办法让使用相同口令的用户存储不同的MD5呢？</p>
<p>如果假定用户无法修改登录名，就可以通过把登录名作为Salt的一部分来计算MD5，从而实现相同口令的用户也存储不同的MD5。</p>
<h3 id="练习-4">练习</h3>
<p>根据用户输入的登录名和口令模拟用户注册，计算更安全的MD5：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>(<span class="params">username, password</span>):</span><br><span class="line">    db[username] = get_md5(password + username + <span class="string">&#x27;the-Salt&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>然后，根据修改后的MD5算法实现用户登录的验证：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib, random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, username, password</span>):</span><br><span class="line">        <span class="variable language_">self</span>.username = username</span><br><span class="line">        <span class="variable language_">self</span>.salt = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(random.randint(<span class="number">48</span>, <span class="number">122</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)])</span><br><span class="line">        <span class="variable language_">self</span>.password = get_md5(password + <span class="variable language_">self</span>.salt)</span><br><span class="line"></span><br><span class="line">db = &#123;</span><br><span class="line">    <span class="string">&#x27;michael&#x27;</span>: User(<span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;bob&#x27;</span>: User(<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;abc999&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;alice&#x27;</span>: User(<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;alice2008&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_md5</span>(<span class="params">user, pws</span>):</span><br><span class="line">    <span class="keyword">return</span> ???</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">username, password</span>):</span><br><span class="line">    user = db[username]</span><br><span class="line">    <span class="keyword">return</span> user.password == get_md5(user, password)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试:</span></span><br><span class="line"><span class="keyword">assert</span> login(<span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> login(<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;abc999&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> login(<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;alice2008&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> login(<span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;1234567&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> login(<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> login(<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;Alice2008&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="小结-5">小结</h3>
<p>哈希算法在很多地方都有广泛的应用。要注意哈希算法不是加密算法，不能用于加密（因为无法通过哈希反推明文），只能用于防篡改，但是它的单向计算特性决定了可以在不存储明文口令的情况下验证用户口令。</p>
<h3 id="参考源码-5">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/built-in-modules/hashlib/use_hashlib.py">use_hashlib.py</a></p>
<p>通过哈希算法，我们可以验证一段数据是否有效，方法就是对比该数据的哈希值，例如，判断用户口令是否正确，我们用保存在数据库中的<code>password_md5</code>对比计算<code>md5(password)</code>的结果，如果一致，用户输入的口令就是正确的。</p>
<p>为了防止黑客通过彩虹表根据哈希值反推原始口令，在计算哈希的时候，不能仅针对原始输入计算，需要增加一个salt来使得相同的输入也能得到不同的哈希，这样，大大增加了黑客破解的难度。</p>
<p>如果salt是我们自己随机生成的，通常我们计算MD5时采用<code>md5(message + salt)</code>。但实际上，把salt看做一个“口令”，加salt的哈希就是：计算一段message的哈希时，根据不同口令计算出不同的哈希。要验证哈希值，必须同时提供正确的口令。</p>
<p>这实际上就是Hmac算法：Keyed-Hashing for Message Authentication。它通过一个标准算法，在计算哈希的过程中，把key混入计算过程中。</p>
<p>和我们自定义的加salt算法不同，Hmac算法针对所有哈希算法都通用，无论是MD5还是SHA-1。采用Hmac替代我们自己的salt算法，可以使程序算法更标准化，也更安全。</p>
<p>Python自带的hmac模块实现了标准的Hmac算法。我们来看看如何使用hmac实现带key的哈希。</p>
<p>我们首先需要准备待计算的原始消息message，随机key，哈希算法，这里采用MD5，使用hmac的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import hmac</span><br><span class="line">&gt;&gt;&gt; message = b&#x27;Hello, world!&#x27;</span><br><span class="line">&gt;&gt;&gt; key = b&#x27;secret&#x27;</span><br><span class="line">&gt;&gt;&gt; h = hmac.new(key, message, digestmod=&#x27;MD5&#x27;)</span><br><span class="line">&gt;&gt;&gt; # 如果消息很长，可以多次调用h.update(msg)</span><br><span class="line">&gt;&gt;&gt; h.hexdigest()</span><br><span class="line">&#x27;fa4ee7d173f2d97ee79022d1a7355bcf&#x27;</span><br></pre></td></tr></table></figure>
<p>可见使用<code>hmac</code>和普通hash算法非常类似。<code>hmac</code>输出的长度和原始哈希算法的长度一致。需要注意传入的key和message都是<code>bytes</code>类型，<code>str</code>类型需要首先编码为<code>bytes</code>。</p>
<h3 id="练习-5">练习</h3>
<p>将上一节的salt改为标准的hmac算法，验证用户口令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hmac, random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hmac_md5</span>(<span class="params">key, s</span>):</span><br><span class="line">    <span class="keyword">return</span> hmac.new(key.encode(<span class="string">&#x27;utf-8&#x27;</span>), s.encode(<span class="string">&#x27;utf-8&#x27;</span>), <span class="string">&#x27;MD5&#x27;</span>).hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, username, password</span>):</span><br><span class="line">        <span class="variable language_">self</span>.username = username</span><br><span class="line">        <span class="variable language_">self</span>.key = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(random.randint(<span class="number">48</span>, <span class="number">122</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)])</span><br><span class="line">        <span class="variable language_">self</span>.password = hmac_md5(<span class="variable language_">self</span>.key, password)</span><br><span class="line"></span><br><span class="line">db = &#123;</span><br><span class="line">    <span class="string">&#x27;michael&#x27;</span>: User(<span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;bob&#x27;</span>: User(<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;abc999&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;alice&#x27;</span>: User(<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;alice2008&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">username, password</span>):</span><br><span class="line">    user = db[username]</span><br><span class="line">    <span class="keyword">return</span> user.password == hmac_md5(user.key, password)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试:</span></span><br><span class="line"><span class="keyword">assert</span> login(<span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> login(<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;abc999&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> login(<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;alice2008&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> login(<span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;1234567&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> login(<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> login(<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;Alice2008&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="小结-6">小结</h3>
<p>Python内置的hmac模块实现了标准的Hmac算法，它利用一个key对message计算“杂凑”后的hash，使用hmac算法比标准hash算法更安全，因为针对相同的message，不同的key会产生不同的hash。</p>
<p>Python的内建模块<code>itertools</code>提供了非常有用的用于操作迭代对象的函数。</p>
<p>首先，我们看看<code>itertools</code>提供的几个“无限”迭代器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import itertools</span><br><span class="line">&gt;&gt;&gt; natuals = itertools.count(1)</span><br><span class="line">&gt;&gt;&gt; for n in natuals:</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>因为<code>count()</code>会创建一个无限的迭代器，所以上述代码会打印出自然数序列，根本停不下来，只能按<code>Ctrl+C</code>退出。</p>
<p><code>cycle()</code>会把传入的一个序列无限重复下去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import itertools</span><br><span class="line">&gt;&gt;&gt; cs = itertools.cycle(&#x27;ABC&#x27;) # 注意字符串也是序列的一种</span><br><span class="line">&gt;&gt;&gt; for c in cs:</span><br><span class="line">...     print(c)</span><br><span class="line">...</span><br><span class="line">&#x27;A&#x27;</span><br><span class="line">&#x27;B&#x27;</span><br><span class="line">&#x27;C&#x27;</span><br><span class="line">&#x27;A&#x27;</span><br><span class="line">&#x27;B&#x27;</span><br><span class="line">&#x27;C&#x27;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>同样停不下来。</p>
<p><code>repeat()</code>负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ns = itertools.repeat(&#x27;A&#x27;, 3)</span><br><span class="line">&gt;&gt;&gt; for n in ns:</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<p>无限序列只有在<code>for</code>迭代时才会无限地迭代下去，如果只是创建了一个迭代对象，它不会事先把无限个元素生成出来，事实上也不可能在内存中创建无限多个元素。</p>
<p>无限序列虽然可以无限迭代下去，但是通常我们会通过<code>takewhile()</code>等函数根据条件判断来截取出一个有限的序列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; natuals = itertools.count(1)</span><br><span class="line">&gt;&gt;&gt; ns = itertools.takewhile(lambda x: x &lt;= 10, natuals)</span><br><span class="line">&gt;&gt;&gt; list(ns)</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure>
<p><code>itertools</code>提供的几个迭代器操作函数更加有用：</p>
<h3 id="chain">chain()</h3>
<p><code>chain()</code>可以把一组迭代对象串联起来，形成一个更大的迭代器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for c in itertools.chain(&#x27;ABC&#x27;, &#x27;XYZ&#x27;):</span><br><span class="line">...     print(c)</span><br><span class="line"># 迭代效果：&#x27;A&#x27; &#x27;B&#x27; &#x27;C&#x27; &#x27;X&#x27; &#x27;Y&#x27; &#x27;Z&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="groupby">groupby()</h3>
<p><code>groupby()</code>把迭代器中相邻的重复元素挑出来放在一起：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for key, group in itertools.groupby(&#x27;AAABBBCCAAA&#x27;):</span><br><span class="line">...     print(key, list(group))</span><br><span class="line">...</span><br><span class="line">A [&#x27;A&#x27;, &#x27;A&#x27;, &#x27;A&#x27;]</span><br><span class="line">B [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;]</span><br><span class="line">C [&#x27;C&#x27;, &#x27;C&#x27;]</span><br><span class="line">A [&#x27;A&#x27;, &#x27;A&#x27;, &#x27;A&#x27;]</span><br></pre></td></tr></table></figure>
<p>实际上挑选规则是通过函数完成的，只要作用于函数的两个元素返回的值相等，这两个元素就被认为是在一组的，而函数返回值作为组的key。如果我们要忽略大小写分组，就可以让元素<code>'A'</code>和<code>'a'</code>都返回相同的key：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for key, group in itertools.groupby(&#x27;AaaBBbcCAAa&#x27;, lambda c: c.upper()):</span><br><span class="line">...     print(key, list(group))</span><br><span class="line">...</span><br><span class="line">A [&#x27;A&#x27;, &#x27;a&#x27;, &#x27;a&#x27;]</span><br><span class="line">B [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;b&#x27;]</span><br><span class="line">C [&#x27;c&#x27;, &#x27;C&#x27;]</span><br><span class="line">A [&#x27;A&#x27;, &#x27;A&#x27;, &#x27;a&#x27;]</span><br></pre></td></tr></table></figure>
<h3 id="练习-6">练习</h3>
<p>计算圆周率可以根据公式：</p>
<p>利用Python提供的itertools模块，我们来计算这个序列的前N项和：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pi</span>(<span class="params">N</span>):</span><br><span class="line">    <span class="string">&#x27; 计算pi的值 &#x27;</span></span><br><span class="line">    <span class="comment"># step 1: 创建一个奇数序列: 1, 3, 5, 7, 9, ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 2: 取该序列的前N项: 1, 3, 5, 7, 9, ..., 2*N-1.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 3: 添加正负符号并用4除: 4/1, -4/3, 4/5, -4/7, 4/9, ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 4: 求和:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试:</span></span><br><span class="line"><span class="built_in">print</span>(pi(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(pi(<span class="number">100</span>))</span><br><span class="line"><span class="built_in">print</span>(pi(<span class="number">1000</span>))</span><br><span class="line"><span class="built_in">print</span>(pi(<span class="number">10000</span>))</span><br><span class="line"><span class="keyword">assert</span> <span class="number">3.04</span> &lt; pi(<span class="number">10</span>) &lt; <span class="number">3.05</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">3.13</span> &lt; pi(<span class="number">100</span>) &lt; <span class="number">3.14</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">3.140</span> &lt; pi(<span class="number">1000</span>) &lt; <span class="number">3.141</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">3.1414</span> &lt; pi(<span class="number">10000</span>) &lt; <span class="number">3.1415</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="小结-7">小结</h3>
<p><code>itertools</code>模块提供的全部是处理迭代功能的函数，它们的返回值不是list，而是<code>Iterator</code>，只有用<code>for</code>循环迭代的时候才真正计算。</p>
<h3 id="参考源码-6">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/built-in-modules/itertools/use_itertools.py">use_itertools.py</a></p>
<p>在Python中，读写文件这样的资源要特别注意，必须在使用完毕后正确关闭它们。正确关闭文件资源的一个方法是使用<code>try...finally</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    f.read()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure>
<p>写<code>try...finally</code>非常繁琐。Python的<code>with</code>语句允许我们非常方便地使用资源，而不必担心资源没有关闭，所以上面的代码可以简化为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.read()</span><br></pre></td></tr></table></figure>
<p>并不是只有<code>open()</code>函数返回的fp对象才能使用<code>with</code>语句。实际上，任何对象，只要正确实现了上下文管理，就可以用于<code>with</code>语句。</p>
<p>实现上下文管理是通过<code>__enter__</code>和<code>__exit__</code>这两个方法实现的。例如，下面的class实现了这两个方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Query</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Begin&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>):</span><br><span class="line">        <span class="keyword">if</span> exc_type:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;End&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Query info about %s...&#x27;</span> % <span class="variable language_">self</span>.name)</span><br></pre></td></tr></table></figure>
<p>这样我们就可以把自己写的资源对象用于<code>with</code>语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> Query(<span class="string">&#x27;Bob&#x27;</span>) <span class="keyword">as</span> q:</span><br><span class="line">    q.query()</span><br></pre></td></tr></table></figure>
<h3 id="contextmanager">@contextmanager</h3>
<p>编写<code>__enter__</code>和<code>__exit__</code>仍然很繁琐，因此Python的标准库<code>contextlib</code>提供了更简单的写法，上面的代码可以改写如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Query</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Query info about %s...&#x27;</span> % <span class="variable language_">self</span>.name)</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_query</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Begin&#x27;</span>)</span><br><span class="line">    q = Query(name)</span><br><span class="line">    <span class="keyword">yield</span> q</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;End&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><code>@contextmanager</code>这个decorator接受一个generator，用<code>yield</code>语句把<code>with ... as var</code>把变量输出出去，然后，<code>with</code>语句就可以正常地工作了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> create_query(<span class="string">&#x27;Bob&#x27;</span>) <span class="keyword">as</span> q:</span><br><span class="line">    q.query()</span><br></pre></td></tr></table></figure>
<p>很多时候，我们希望在某段代码执行前后自动执行特定代码，也可以用<code>@contextmanager</code>实现。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tag</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&lt;%s&gt;&quot;</span> % name)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&lt;/%s&gt;&quot;</span> % name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tag(<span class="string">&quot;h1&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;world&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>上述代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<p>代码的执行顺序是：</p>
<ol>
<li><code>with</code>语句首先执行<code>yield</code>之前的语句，因此打印出<code>&lt;h1&gt;</code>；</li>
<li><code>yield</code>调用会执行<code>with</code>语句内部的所有语句，因此打印出<code>hello</code>和<code>world</code>；</li>
<li>最后执行<code>yield</code>之后的语句，打印出<code>&lt;/h1&gt;</code>。</li>
</ol>
<p>因此，<code>@contextmanager</code>让我们通过编写generator来简化上下文管理。</p>
<h3 id="closing">@closing</h3>
<p>如果一个对象没有实现上下文，我们就不能把它用于<code>with</code>语句。这个时候，可以用<code>closing()</code>来把该对象变为上下文对象。例如，用<code>with</code>语句使用<code>urlopen()</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> closing</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> closing(urlopen(<span class="string">&#x27;https://www.python.org&#x27;</span>)) <span class="keyword">as</span> page:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> page:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure>
<p><code>closing</code>也是一个经过@contextmanager装饰的generator，这个generator编写起来其实非常简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">closing</span>(<span class="params">thing</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> thing</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        thing.close()</span><br></pre></td></tr></table></figure>
<p>它的作用就是把任意对象变为上下文对象，并支持<code>with</code>语句。</p>
<p><code>@contextlib</code>还有一些其他decorator，便于我们编写更简洁的代码。</p>
<p><code>urllib</code>提供了一系列用于操作URL的功能。</p>
<h3 id="Get">Get</h3>
<p><code>urllib</code>的<code>request</code>模块可以非常方便地抓取URL内容，也就是发送一个GET请求到指定的页面，然后返回HTTP的响应：</p>
<p>例如，对豆瓣的一个URL<code>https://api.douban.com/v2/book/2129650</code>进行抓取，并返回响应：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> request.urlopen(<span class="string">&#x27;https://api.douban.com/v2/book/2129650&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Status:&#x27;</span>, f.status, f.reason)</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> f.getheaders():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (k, v))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Data:&#x27;</span>, data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>可以看到HTTP响应的头和JSON数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Status: 200 OK</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Tue, 26 May 2015 10:02:27 GMT</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Content-Length: 2049</span><br><span class="line">Connection: close</span><br><span class="line">Expires: Sun, 1 Jan 2006 01:00:00 GMT</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: must-revalidate, no-cache, private</span><br><span class="line">X-DAE-Node: pidl1</span><br><span class="line">Data: &#123;&quot;rating&quot;:&#123;&quot;max&quot;:10,&quot;numRaters&quot;:16,&quot;average&quot;:&quot;7.4&quot;,&quot;min&quot;:0&#125;,&quot;subtitle&quot;:&quot;&quot;,&quot;author&quot;:[&quot;廖雪峰编著&quot;],&quot;pubdate&quot;:&quot;2007-6&quot;,...&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们要想模拟浏览器发送GET请求，就需要使用<code>Request</code>对象，通过往<code>Request</code>对象添加HTTP头，我们就可以把请求伪装成浏览器。例如，模拟iPhone去请求豆瓣首页：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">req = request.Request(<span class="string">&#x27;http://www.douban.com/&#x27;</span>)</span><br><span class="line">req.add_header(<span class="string">&#x27;User-Agent&#x27;</span>, <span class="string">&#x27;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> request.urlopen(req) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Status:&#x27;</span>, f.status, f.reason)</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> f.getheaders():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (k, v))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Data:&#x27;</span>, f.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>这样豆瓣会返回适合iPhone的移动版网页：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;57x57&quot; href=&quot;http://img4.douban.com/pics/cardkit/launcher/57.png&quot; /&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="Post">Post</h3>
<p>如果要以POST发送一个请求，只需要把参数<code>data</code>以bytes形式传入。</p>
<p>我们模拟一个微博登录，先读取登录的邮箱和口令，然后按照weibo.cn的登录页的格式以<code>username=xxx&amp;password=xxx</code>的编码传入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Login to weibo.cn...&#x27;</span>)</span><br><span class="line">email = <span class="built_in">input</span>(<span class="string">&#x27;Email: &#x27;</span>)</span><br><span class="line">passwd = <span class="built_in">input</span>(<span class="string">&#x27;Password: &#x27;</span>)</span><br><span class="line">login_data = parse.urlencode([</span><br><span class="line">    (<span class="string">&#x27;username&#x27;</span>, email),</span><br><span class="line">    (<span class="string">&#x27;password&#x27;</span>, passwd),</span><br><span class="line">    (<span class="string">&#x27;entry&#x27;</span>, <span class="string">&#x27;mweibo&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;client_id&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;savestate&#x27;</span>, <span class="string">&#x27;1&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;ec&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;pagerefer&#x27;</span>, <span class="string">&#x27;https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">req = request.Request(<span class="string">&#x27;https://passport.weibo.cn/sso/login&#x27;</span>)</span><br><span class="line">req.add_header(<span class="string">&#x27;Origin&#x27;</span>, <span class="string">&#x27;https://passport.weibo.cn&#x27;</span>)</span><br><span class="line">req.add_header(<span class="string">&#x27;User-Agent&#x27;</span>, <span class="string">&#x27;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&#x27;</span>)</span><br><span class="line">req.add_header(<span class="string">&#x27;Referer&#x27;</span>, <span class="string">&#x27;https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> request.urlopen(req, data=login_data.encode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Status:&#x27;</span>, f.status, f.reason)</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> f.getheaders():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (k, v))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Data:&#x27;</span>, f.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>如果登录成功，我们获得的响应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status: 200 OK</span><br><span class="line">Server: nginx/1.2.0</span><br><span class="line">...</span><br><span class="line">Set-Cookie: SSOLoginState=1432620126; path=/; domain=weibo.cn</span><br><span class="line">...</span><br><span class="line">Data: &#123;&quot;retcode&quot;:20000000,&quot;msg&quot;:&quot;&quot;,&quot;data&quot;:&#123;...,&quot;uid&quot;:&quot;1658384301&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>如果登录失败，我们获得的响应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Data: &#123;&quot;retcode&quot;:50011015,&quot;msg&quot;:&quot;\u7528\u6237\u540d\u6216\u5bc6\u7801\u9519\u8bef&quot;,&quot;data&quot;:&#123;&quot;username&quot;:&quot;example@python.org&quot;,&quot;errline&quot;:536&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Handler">Handler</h3>
<p>如果还需要更复杂的控制，比如通过一个Proxy去访问网站，我们需要利用<code>ProxyHandler</code>来处理，示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proxy_handler = urllib.request.ProxyHandler(&#123;<span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://www.example.com:3128/&#x27;</span>&#125;)</span><br><span class="line">proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()</span><br><span class="line">proxy_auth_handler.add_password(<span class="string">&#x27;realm&#x27;</span>, <span class="string">&#x27;host&#x27;</span>, <span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)</span><br><span class="line"><span class="keyword">with</span> opener.<span class="built_in">open</span>(<span class="string">&#x27;http://www.example.com/login.html&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="小结-8">小结</h3>
<p><code>urllib</code>提供的功能就是利用程序去执行各种HTTP请求。如果要模拟浏览器完成特定功能，需要把请求伪装成浏览器。伪装的方法是先监控浏览器发出的请求，再根据浏览器的请求头来伪装，<code>User-Agent</code>头就是用来标识浏览器的。</p>
<h3 id="练习-7">练习</h3>
<p>利用<code>urllib</code>读取JSON，然后将JSON解析为Python对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_data</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">URL = <span class="string">&#x27;https://api.weatherapi.com/v1/current.json?key=b4e8f86b44654e6b86885330242207&amp;q=Beijing&amp;aqi=no&#x27;</span></span><br><span class="line">data = fetch_data(URL)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="keyword">assert</span> data[<span class="string">&#x27;location&#x27;</span>][<span class="string">&#x27;name&#x27;</span>] == <span class="string">&#x27;Beijing&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="参考源码-7">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/built-in-modules/urllib/use_urllib.py">use_urllib.py</a></p>
<h2 id="XML">XML</h2>
<p>XML虽然比JSON复杂，在Web中应用也不如以前多了，不过仍有很多地方在用，所以，有必要了解如何操作XML。</p>
<h3 id="DOM-vs-SAX">DOM vs SAX</h3>
<p>操作XML有两种方法：DOM和SAX。DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。</p>
<p>正常情况下，优先考虑SAX，因为DOM实在太占内存。</p>
<p>在Python中使用SAX解析XML非常简洁，通常我们关心的事件是<code>start_element</code>，<code>end_element</code>和<code>char_data</code>，准备好这3个函数，然后就可以解析xml了。</p>
<p>举个例子，当SAX解析器读到一个节点时：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span>python<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>会产生3个事件：</p>
<ol>
<li><code>start_element</code>事件，在读取<code>&lt;a href=&quot;/&quot;&gt;</code>时；</li>
<li><code>char_data</code>事件，在读取<code>python</code>时；</li>
<li><code>end_element</code>事件，在读取<code>&lt;/a&gt;</code>时。</li>
</ol>
<p>用代码实验一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.parsers.expat <span class="keyword">import</span> ParserCreate</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DefaultSaxHandler</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_element</span>(<span class="params">self, name, attrs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;sax:start_element: %s, attrs: %s&#x27;</span> % (name, <span class="built_in">str</span>(attrs)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">end_element</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;sax:end_element: %s&#x27;</span> % name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">char_data</span>(<span class="params">self, text</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;sax:char_data: %s&#x27;</span> % text)</span><br><span class="line"></span><br><span class="line">xml = <span class="string">r&#x27;&#x27;&#x27;&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="string">&lt;ol&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;&lt;a href=&quot;/python&quot;&gt;Python&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;&lt;a href=&quot;/ruby&quot;&gt;Ruby&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ol&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">handler = DefaultSaxHandler()</span><br><span class="line">parser = ParserCreate()</span><br><span class="line">parser.StartElementHandler = handler.start_element</span><br><span class="line">parser.EndElementHandler = handler.end_element</span><br><span class="line">parser.CharacterDataHandler = handler.char_data</span><br><span class="line">parser.Parse(xml)</span><br></pre></td></tr></table></figure>
<p>需要注意的是读取一大段字符串时，<code>CharacterDataHandler</code>可能被多次调用，所以需要自己保存起来，在<code>EndElementHandler</code>里面再合并。</p>
<p>除了解析XML外，如何生成XML呢？99%的情况下需要生成的XML结构都是非常简单的，因此，最简单也是最有效的生成XML的方法是拼接字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L = []</span><br><span class="line">L.append(<span class="string">r&#x27;&lt;?xml version=&quot;1.0&quot;?&gt;&#x27;</span>)</span><br><span class="line">L.append(<span class="string">r&#x27;&lt;root&gt;&#x27;</span>)</span><br><span class="line">L.append(encode(<span class="string">&#x27;some &amp; data&#x27;</span>))</span><br><span class="line">L.append(<span class="string">r&#x27;&lt;/root&gt;&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(L)</span><br></pre></td></tr></table></figure>
<p>如果要生成复杂的XML呢？建议你不要用XML，改成JSON。</p>
<h3 id="小结-9">小结</h3>
<p>解析XML时，注意找出自己感兴趣的节点，响应事件时，把节点数据保存起来。解析完毕后，就可以处理数据。</p>
<h3 id="练习-8">练习</h3>
<p>请利用SAX编写程序解析WeatherAPI的XML格式的天气预报，获取天气预报：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.parsers.expat <span class="keyword">import</span> ParserCreate</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parseXml</span>(<span class="params">xml_str</span>):</span><br><span class="line">    <span class="built_in">print</span>(xml_str)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;?&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;weather&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;condition&#x27;</span>: <span class="string">&#x27;Sunny&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;temperature&#x27;</span>: <span class="number">37.2</span>,</span><br><span class="line">            <span class="string">&#x27;wind&#x27;</span>: <span class="number">9.7</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试:</span></span><br><span class="line">URL = <span class="string">&#x27;https://api.weatherapi.com/v1/current.xml?key=b4e8f86b44654e6b86885330242207&amp;q=Beijing&amp;aqi=no&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> request.urlopen(URL, timeout=<span class="number">4</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line"></span><br><span class="line">result = parseXml(data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="keyword">assert</span> result[<span class="string">&#x27;city&#x27;</span>] == <span class="string">&#x27;Beijing&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="参考源码-8">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/built-in-modules/xml/use_sax.py">use_sax.py</a></p>
<h2 id="HTMLParser">HTMLParser</h2>
<p>如果我们要编写一个搜索引擎，第一步是用爬虫把目标网站的页面抓下来，第二步就是解析该HTML页面，看看里面的内容到底是新闻、图片还是视频。</p>
<p>假设第一步已经完成了，第二步应该如何解析HTML呢？</p>
<p>HTML本质上是XML的子集，但是HTML的语法没有XML那么严格，所以不能用标准的DOM或SAX来解析HTML。</p>
<p>好在Python提供了<code>HTMLParser</code>来非常方便地解析HTML，只需简单几行代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> html.parser <span class="keyword">import</span> HTMLParser</span><br><span class="line"><span class="keyword">from</span> html.entities <span class="keyword">import</span> name2codepoint</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyHTMLParser</span>(<span class="title class_ inherited__">HTMLParser</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_starttag</span>(<span class="params">self, tag, attrs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&lt;%s&gt;&#x27;</span> % tag)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_endtag</span>(<span class="params">self, tag</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&lt;/%s&gt;&#x27;</span> % tag)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_startendtag</span>(<span class="params">self, tag, attrs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&lt;%s/&gt;&#x27;</span> % tag)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_data</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_comment</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&lt;!--&#x27;</span>, data, <span class="string">&#x27;--&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_entityref</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&amp;%s;&#x27;</span> % name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_charref</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&amp;#%s;&#x27;</span> % name)</span><br><span class="line"></span><br><span class="line">parser = MyHTMLParser()</span><br><span class="line">parser.feed(<span class="string">&#x27;&#x27;&#x27;&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;!-- test html parser --&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;Some &lt;a href=\&quot;#\&quot;&gt;html&lt;/a&gt; HTML&amp;nbsp;tutorial...&lt;br&gt;END&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;&lt;/html&gt;&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><code>feed()</code>方法可以多次调用，也就是不一定一次把整个HTML字符串都塞进去，可以一部分一部分塞进去。</p>
<p>特殊字符有两种，一种是英文表示的<code>&amp;nbsp;</code>，一种是数字表示的<code>&amp;#1234;</code>，这两种字符都可以通过Parser解析出来。</p>
<h3 id="小结-10">小结</h3>
<p>利用HTMLParser，可以把网页中的文本、图像等解析出来。</p>
<h3 id="练习-9">练习</h3>
<p>找一个网页，例如<a target="_blank" rel="noopener" href="https://www.python.org/events/python-events/">https://www.python.org/events/python-events/</a>，用浏览器查看源码并复制，然后尝试解析一下HTML，输出Python官网发布的会议时间、名称和地点。</p>
<h3 id="参考源码-9">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/built-in-modules/htmlparser/use_htmlparser.py">use_htmlparser.py</a></p>
<p>在开发Python应用程序的时候，系统安装的Python3只有一个版本：3.x。所有第三方的包都会被<code>pip</code>安装到Python3的<code>site-packages</code>目录下。</p>
<p>如果我们要同时开发多个应用程序，那这些应用程序都会共用一个Python，就是安装在系统的Python 3。如果应用A需要jinja 2.7，而应用B需要jinja 2.6怎么办？</p>
<p>这种情况下，每个应用可能需要各自拥有一套“独立”的Python运行环境。<code>venv</code>就是用来为一个应用创建一套“隔离”的Python运行环境。</p>
<p>首先，我们假定要开发一个新的项目<code>project101</code>，需要一套独立的Python运行环境，可以这么做：</p>
<p>第一步，创建目录，这里把Python虚拟运行环境命名为<code>proj101env</code>，因此目录名为<code>proj101env</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir proj101env</span><br><span class="line">$ cd proj101env/</span><br><span class="line">proj101env$</span><br></pre></td></tr></table></figure>
<p>第二步，创建一个独立的Python运行环境：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proj101env$ python3 -m venv .</span><br></pre></td></tr></table></figure>
<p>查看当前目录，可以发现有几个文件夹和一个<code>pyvenv.cfg</code>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proj101env$ ls</span><br><span class="line">bin  include  lib  pyvenv.cfg</span><br></pre></td></tr></table></figure>
<p>命令<code>python3 -m venv &lt;目录&gt;</code>就可以创建一个独立的Python运行环境。观察<code>bin</code>目录的内容，里面有<code>python3</code>、<code>pip3</code>等可执行文件，实际上是链接到Python系统目录的软链接。</p>
<p>继续进入<code>bin</code>目录，Linux/Mac用<code>source activate</code>，Windows用<code>activate.bat</code>激活该venv环境：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proj101env$ cd bin</span><br><span class="line">bin$ source activate</span><br><span class="line">(proj101env) bin$</span><br></pre></td></tr></table></figure>
<p>注意到命令提示符变了，有个<code>(proj101env)</code>前缀，表示当前环境是一个名为<code>proj101env</code>的Python环境。</p>
<p>下面正常安装各种第三方包，并运行<code>python</code>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(proj101env) bin$ pip3 install jinja2</span><br><span class="line">...</span><br><span class="line">Successfully installed jinja2-xxx</span><br><span class="line"></span><br><span class="line">(proj101env) bin$ python3</span><br><span class="line">&gt;&gt;&gt; import jinja2</span><br><span class="line">&gt;&gt;&gt; exit()</span><br></pre></td></tr></table></figure>
<p>在<code>venv</code>环境下，用<code>pip</code>安装的包都被安装到<code>proj101env</code>这个环境下，具体目录是<code>proj101env/lib/python3.x/site-packages</code>，因此，系统Python环境不受任何影响。也就是说，<code>proj101env</code>环境是专门针对<code>project101</code>这个应用创建的。</p>
<p>退出当前的<code>proj101env</code>环境，使用<code>deactivate</code>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(proj101env) bin$ deactivate</span><br><span class="line">bin$</span><br></pre></td></tr></table></figure>
<p>此时就回到了正常的环境，现在<code>pip</code>或<code>python</code>均是在系统Python环境下执行。</p>
<p>完全可以针对每个应用创建独立的Python运行环境，这样就可以对每个应用的Python环境进行隔离。</p>
<p><code>venv</code>是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python链接或复制一份到<code>venv</code>的环境，用命令<code>source activate</code>进入一个<code>venv</code>环境时，<code>venv</code>会修改相关环境变量，让命令<code>python</code>和<code>pip</code>均指向当前的<code>venv</code>环境。</p>
<p>如果不再使用某个<code>venv</code>，例如<code>proj101env</code>，删除它也很简单。首先确认该<code>venv</code>没有处于“激活”状态，然后直接把整个目录<code>proj101env</code>删掉就行。</p>
<h3 id="小结-11">小结</h3>
<p><code>venv</code>为应用提供了隔离的Python运行环境，解决了不同应用间安装多版本的冲突问题。</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">標籤</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/python/" rel="tag">python</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../26/python/13.python%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/"
                    data-tooltip="13.python常用第三方模块"
                    aria-label="上一篇: 13.python常用第三方模块"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../24/python/11.python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"
                    data-tooltip="11.python正则表达式"
                    aria-label="下一篇: 11.python正则表达式"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://keinchan.com/2016/04/25/python/12.python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://keinchan.com/2016/04/25/python/12.python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://keinchan.com/2016/04/25/python/12.python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://keinchan.com/2016/04/25/python/12.python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../26/python/13.python%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/"
                    data-tooltip="13.python常用第三方模块"
                    aria-label="上一篇: 13.python常用第三方模块"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../24/python/11.python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"
                    data-tooltip="11.python正则表达式"
                    aria-label="下一篇: 11.python正则表达式"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://keinchan.com/2016/04/25/python/12.python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://keinchan.com/2016/04/25/python/12.python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://keinchan.com/2016/04/25/python/12.python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://keinchan.com/2016/04/25/python/12.python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://keinchan.com/2016/04/25/python/12.python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97/"
                        aria-label="分享到 Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://keinchan.com/2016/04/25/python/12.python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97/"
                        aria-label="分享到 Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://keinchan.com/2016/04/25/python/12.python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97/"
                        aria-label="global.share_on_linkedin"
                    >
                        <i class="fab fa-linkedin" aria-hidden="true"></i><span>global.share_on_linkedin</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=https://keinchan.com/2016/04/25/python/12.python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97/"
                        aria-label="分享到 Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 235 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
