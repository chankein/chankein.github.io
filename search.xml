<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一文搞懂贝叶斯定理（应用篇）</title>
      <link href="/2025/05/23/%E6%95%B0%E5%AD%A6/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%88%E5%BA%94%E7%94%A8%E7%AF%87%EF%BC%89/"/>
      <url>/2025/05/23/%E6%95%B0%E5%AD%A6/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%88%E5%BA%94%E7%94%A8%E7%AF%87%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在统计学里，长期以来，有频率学派和贝叶斯学派两大学派，他们互相鄙视对方，就像华山派的气宗与剑宗之争。</p><p>这两大学派最根本的观点在于看待世界的方式不同：</p><ul><li>频率学派认为世界是客观的，必须通过大量独立采样来获得统计均值，不能先给出一个主观的先验概率（假设）；</li><li>贝叶斯学派则认为概率是一种信念度，可以有非常主观的先验概率，然后，通过一次次采样结果修正先验概率，使之逼近客观事实。</li></ul><p>这两大学派哪个才是正确的？其实都对，只是看待世界的角度不同。但是在现实世界中，除了抛硬币、掷骰子、玩老虎机等少数符合理想数学模型的场景，频率学派才能发挥作用。大多数需要我们估算概率的现实场景，只能用贝叶斯理论来指导实践。</p><p>举个例子，假设我住在市区，希望赶上飞机的概率不低于90%，那么我应该提前多久出发呢？我必须试验至少100次，看看样本空间，才能获得一个比较准确的统计均值。然而这是不现实的，因为我一年可能就坐几次飞机。我只能拍脑袋先估一个提前30分钟就够了，结果第三次就没赶上，这说明我必须修正我的先验概率，后续改为提前45分钟，才能提升赶上飞机的概率。</p><p>我们再以《狼来了》的故事为例，当小孩第一次喊狼来了，村民听到后可以根据先验概率，比如P(小孩是诚实的)=90%判断赶紧去帮忙，结果发现被骗了，于是大家根据“被骗了”这一证据把后验概率P(小孩是诚实的)调整为60%，第二次又被骗了，于是再次把后验概率调整为20%，等到第三次听见小孩求救时，大家根据P(小孩是诚实的)=20%判断，他大概率还是在说谎，于是没有人去帮忙了。</p><p>有的同学会问，你说的这些，都是定性分析，没有定量计算啊！</p><p>要把贝叶斯定理用到定量计算，必须得借助计算机。</p><p>以吴军老师在中文分词领域举的一个例子来说，对于一个句子：南京市长江大桥，可以有两种划分：</p><ul><li>南京市 / 长江大桥</li><li>南京市长 / 江大桥</li></ul><p>到底哪一种更合理？我们可以计算条件概率：</p><ul><li>P(长江大桥|南京市) = 出现“南京市”时，出现“长江大桥”的概率；</li><li>P(江大桥|南京市长) = 出现“南京市长”时，出现“江大桥”的概率。</li></ul><p>提前准备好大量的中文语料，计算出任意两个词的条件概率，我们就可以得出哪种分词更合理。</p><p>在互联网领域，凡是遇到“当出现xyz时应该推荐什么”这样的条件概率时，也总是能应用贝叶斯理论。</p><p>例如，我们在搜索引擎中输入<code>elon</code>这个单词后，搜索框自动给出了联想补全：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-29-bayes-use/elon.png" alt="elon"></p><p>怎么实现这个功能？把用户最近搜索的所有可能的单词列出来，然后计算条件概率：</p><ul><li>P(mask|elon)=0.5</li><li>P(jerk|elon)=0.1</li><li>P(university|elon)=0.2</li><li>…</li></ul><p>把它们排个序，选出条件概率最大的几个，就是搜索建议。</p><p>诸如反垃圾邮件、电商推荐系统等，都是贝叶斯理论在机器学习中的应用。由于需要大量的计算，贝叶斯理论也只有在计算机时代才能广泛应用。</p><h3 id="关于信念">关于信念</h3><p>我们再回顾一下贝叶斯定理：</p><p>稍微改一下，变为：</p><p>P(H)是先验概率，P(H|E)是后验概率，P(E|H)/P(E)被称为调整因子，先验概率乘以调整因子就得到后验概率。</p><p>我们发现，如果P(H)=0，则P(H|E)=0；如果P(H)=1，则P(E|H)=P(E)，P(H|E)=1。</p><p>也就是说，如果先验概率为0%或100%，那么，无论出现任何证据E，都无法改变后验概率P(H|E)。这对我们看待世界的认知有重大指导意义，因为贝叶斯概率的本质是信念，通过一次次事件，我们可能加强某种信念，也可能减弱某种信念，但如果信念保持100%或0%，则可以做到对外界输入完全“免疫”。</p><p>举个例子，十年前许多人都认为比特币是庞氏骗局，如果100%坚定地持有这种信念，那么他将无视用户越来越多、价格上涨、交易量扩大、机构入市等诸多证据，至今仍然会坚信比特币是骗局而错过无数次机会。（注：此处示例不构成任何投资建议）</p><p>对于新生事物，每个人都可以有非常主观的先验概率，但只要我们不把先验概率定死为0或100%，就有机会改变自己的信念，从而更有可能接近客观事实，这也是贝叶斯定理的精髓：</p><blockquote><p>你相信什么并不重要，重要的是你别完全相信它。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文搞懂贝叶斯定理（原理篇）</title>
      <link href="/2025/05/23/%E6%95%B0%E5%AD%A6/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/"/>
      <url>/2025/05/23/%E6%95%B0%E5%AD%A6/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>托马斯·贝叶斯（Thomas Bayes）是18世纪的英国数学家，也是一位虔诚的牧师。据说他为了反驳对上帝的质疑而推导出贝叶斯定理。贝叶斯定理是一个由结果倒推原因的概率算法，在贝叶斯提出这个条件概率公式后，很长一段时间，大家并没有觉得它有什么作用，并一直受到主流统计学派的排斥。直到计算机诞生后，人们发现，贝叶斯定理可以广泛应用在数据分析、模式识别、统计决策，以及最火的人工智能中，结果，贝叶斯定理是如此有用，以至于不仅应用在计算机上，还广泛应用在经济学、心理学、博弈论等各种领域，可以说，掌握并应用贝叶斯定理，是每个人必备的技能。</p><p>这里推荐两个视频，深入浅出地解释了贝叶斯定理：</p><p><a href="https://www.youtube.com/watch?v=Pu675cHJ7bg">Bayes’ Theorem 贝叶斯定理</a></p><p><a href="https://www.youtube.com/watch?v=HZGCoVF3YvM">Bayes theorem, the geometry of changing beliefs</a></p><p>如果你不想花太多时间看视频，可以继续阅读，我把视频内容编译成文字，以便快速学习贝叶斯定理。</p><p>为了搞明白贝叶斯定理究竟要解决什么问题，我们先看一个现实生活的例子：</p><p>已知有一种疾病，发病率是0.1%。针对这种疾病的测试非常准确：</p><ul><li>如果有病，则准确率是99%（即有1%未检出阳性）；</li><li>如果没有病，则误报率是2%（即有2%误报为阳性）。</li></ul><p>现在，如果一个人测试显示阳性，请问他患病的概率是多少？</p><p>如果我们从大街上随便找一个人，那么他患病的概率就是0.1%，因为这个概率是基于历史统计数据的先验概率。</p><p>现在，他做了一次测试，结果为阳性，我们要计算他患病的概率，就是计算条件概率，即：在测试为阳性这一条件下，患病的概率是多少。</p><p>从直觉上这个人患病的概率大于0.1%，但也肯定小于99%。究竟是多少，怎么计算，我们先放一放。</p><p>为了理解条件概率，我们换一个更简单的例子：掷两次骰子，一共可能出现的结果有6x6=36种：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/sample-all.png" alt="sample space"></p><p>这就是所谓的样本空间，每个样本的概率均为1/36，这个很好理解。</p><p>如果我们定义事件A为：至少有一个骰子是2，那么事件A的样本空间如下图红色部分所示：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/sample-a.png" alt="Event A"></p><p>事件A一共有11种情况，我们计算事件A的概率P(A)：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/pa.png" alt="P(A)"></p><p>我们再定义事件B：两个骰子之和为7，那么事件B的样本空间如下图绿色部分所示：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/sample-b.png" alt="Event B"></p><p>事件B一共有6种情况，我们计算事件B的概率P(B)：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/pb.png" alt="P(B)"></p><p>接下来我们用P(A∩B)表示A和B同时发生的概率，A∩B就是A和B的交集，如下图蓝色部分所示：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/sample-p-a-and-b.png" alt="P(A∩B)"></p><p>显然A∩B只有两种情况，因此，计算P(A∩B)：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/p-a-and-b.png" alt="P(A∩B)"></p><p>接下来我们就可以讨论条件概率了。我们用P(A|B)表示在B发生的条件下，A发生的概率。由于B已经发生，所以，样本空间就是B的样本数量6，而要发生A则只能是A、B同时发生，即A∩B，有两种情况。</p><p>因此，计算P(A|B)如下：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/p-a-b.png" alt="P(A|B)"></p><p>同理，我们用P(B|A)表示在A发生的条件下，B发生的概率。此时，分子仍然是A∩B的样本数量，但分母变成A的样本数量：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/p-b-a.png" alt="P(B|A)"></p><p>可见，条件概率P(A|B)和P(B|A)是不同的。</p><p>我们再回到A、B同时发生的概率，观察P(A∩B)可以改写为：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/p-a-and-b-2.png" alt="P(B|A)xP(A)"></p><p>同理，P(A∩B)还可以改写为：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/p-a-and-b-3.png" alt="P(A|B)xP(B)"></p><p>因此，根据上述两个等式，我们推导出下面的等式：</p><p>把左边的<code>P(A∩B)</code>去掉，我们得到等式：</p><p>最后，整理一下等式，我们推导出贝叶斯定理如下：</p><p>这就是著名的贝叶斯定理，它表示，当出现B时，如何计算A的概率。</p><p>很多时候，我们把<code>A</code>改写为<code>H</code>，把<code>B</code>改写为<code>E</code>：</p><p>H表示Hypothesis（假设），E表示Evidence（证据），贝叶斯定理的意义就在于，给定一个先验概率P(H)，在出现了证据E的情况下，计算后验概率P(H|E)。</p><h3 id="计算">计算</h3><p>有了贝叶斯定理，我们就可以回到开头的问题：</p><p>已知有一种疾病，发病率是0.1%。针对这种疾病的测试非常准确：</p><ul><li>如果有病，则准确率是99%（即有1%未检出阳性）；</li><li>如果没有病，则误报率是2%（即有2%误报为阳性）。</li></ul><p>现在，如果一个人测试显示阳性，请问他患病的概率是多少？</p><p>用H表示患病，E表示测试为阳性，那么，我们要计算在测试为阳性的条件下，一个人患病的概率，就是计算P(H|E)。根据贝叶斯定理，计算如下：</p><p>P(H)表示患病的概率，根据发病率可知，P(H)=0.1%；</p><p>P(E|H)表示在患病的情况下，测试为阳性的概率，根据“如果有病，则准确率是99%”可知，P(E|H)=99%；</p><p>P(E)表示测试为阳性的概率。这个概率就稍微复杂点，因为它是指对所有人（包含病人和健康人）进行测试，结果阳性的概率。</p><p>我们可以把检测人数放大，例如放大到10万人，对10万人进行检测，根据发病率可知：</p><ul><li>有100人是病人，另外99900是健康人；</li><li>对100个病人进行测试，有99人显示阳性，另有1人未检出（阴性）；</li><li>对99900个健康人进行测试，有2%=1998人显示阳性（误报），另有98%=97902人为阴性。</li></ul><p>下图显示了检测为阳性的结果的分布：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">           ┌───────┐</span><br><span class="line">           │100000 │</span><br><span class="line">           └───────┘</span><br><span class="line">               │</span><br><span class="line">       ┌───────┴───────┐</span><br><span class="line">       ▼               ▼</span><br><span class="line">   ┌───────┐       ┌───────┐</span><br><span class="line">   │  100  │       │ 99900 │</span><br><span class="line">   └───────┘       └───────┘</span><br><span class="line">       │               │</span><br><span class="line">   ┌───┴───┐       ┌───┴───┐</span><br><span class="line">   ▼       ▼       ▼       ▼</span><br><span class="line">┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐</span><br><span class="line">│ 99  │ │  1  │ │1998 │ │97902│</span><br><span class="line">└─────┘ └─────┘ └─────┘ └─────┘</span><br><span class="line">   │               │</span><br><span class="line">   ▼               ▼</span><br><span class="line">   +               +</span><br></pre></td></tr></table></figure><p>所以，对于10万人的样本空间来说，事件E=显示阳性的概率为(99+1998)/100000=2.097%。</p><p>带入贝叶斯定理，计算P(H|E)：</p><p>计算结果为患病的概率为4.721%，这个概率远小于99%，且与大多数人的直觉不同，原因在于庞大的健康人群导致的误报数量远多于病人，当出现“检测阳性”的证据时，患病的概率从先验概率0.1%提升到4.721%，还远不足以确诊。</p><h3 id="贝叶斯定理的另一种表示">贝叶斯定理的另一种表示</h3><p>在上述计算中，我们发现计算P(E)是比较困难的，很多时候，甚至无法知道P(E)。此时，我们需要贝叶斯定理的另一种表示形式。</p><p>我们用P(H)表示H发生的概率，用H表示H不发生，P(H)表示H不发生的概率。显然P(H)=1-P(H)。</p><p>下图红色部分表示H，红色部分以外则表示H：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/ph.png" alt="P(H)"></p><p>事件E用绿色表示：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/pe.png" alt="P(E)"></p><p>可见，P(E)可以分为两部分，一部分是E和H的交集，另一部分是E和H的交集：</p><p>根据上文的公式P(A∩B)=P(A|B)xP(B)，代入可得：</p><p>把P(E)替换掉，我们得到贝叶斯定理的另一种写法：</p><p>用这个公式来计算，我们就不必计算P(E)了。再次回到开头的问题：</p><p>已知有一种疾病，发病率是0.1%。针对这种疾病的测试非常准确：</p><ul><li>如果有病，则准确率是99%（即有1%未检出阳性）；</li><li>如果没有病，则误报率是2%（即有2%误报为阳性）。</li></ul><p>现在，如果一个人测试显示阳性，请问他患病的概率是多少？</p><ul><li>P(E|H)表示患病时检测阳性的概率=99%；</li><li>P(H)表示患病的概率=0.1%；</li><li>P(E|H)表示没有患病但检测阳性的概率=2%；</li><li>P(H)表示没有患病的概率=1-P(H)=99.9%。</li></ul><p>代入公式，计算：</p><p>检测为阳性这一证据使得患病的概率从0.1%提升到4.721%。假设这个人又做了一次检测，结果仍然是阳性，那么他患病的概率是多少？</p><p>我们仍然使用贝叶斯定理计算，只不过现在先验概率P(H)不再是0.1%，而是4.721%，P(E|H)和P(E|H)仍保持不变，计算新的P(H|E)：</p><p>结果为71%，两次检测为阳性的结果使得先验概率从0.1%提升到4.721%再提升到71%，继续第三次检测如果为阳性则概率将提升至99.18%。</p><p>可见，贝叶斯定理的核心思想就是不断根据新的证据，将先验概率调整为后验概率，使之更接近客观事实。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile教程</title>
      <link href="/2025/05/23/makefile%E6%95%99%E7%A8%8B/"/>
      <url>/2025/05/23/makefile%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>Linux的<code>make</code>程序用来自动化编译大型源码，很多时候，我们在Linux下编译安装软件，只需要敲一个<code>make</code>就可以全自动完成，非常方便。</p><p><code>make</code>能自动化完成这些工作，是因为项目提供了一个<code>Makefile</code>文件，它负责告诉<code>make</code>，应该如何编译和链接程序。</p><p><code>Makefile</code>相当于Java项目的<code>pom.xml</code>，Node工程的<code>package.json</code>，Rust项目的<code>Cargo.toml</code>，不同之处在于，<code>make</code>虽然最初是针对C语言开发，但它实际上并不限定C语言，而是可以应用到任意项目，甚至不是编程语言。此外，<code>make</code>主要用于Unix/Linux环境的自动化开发，掌握<code>Makefile</code>的写法，可以更好地在Linux环境下做开发，也可以为后续开发Linux内核做好准备。</p><p>在本教程中，我们将由浅入深，一步一步学习如何编写<code>Makefile</code>，完全针对零基础小白，只需要提前掌握如何使用Linux命令。</p><hr><hr><p>在Linux环境下，当我们输入<code>make</code>命令时，它就在当前目录查找一个名为<code>Makefile</code>的文件，然后，根据这个文件定义的规则，自动化地执行任意命令，包括编译命令。</p><p><code>Makefile</code>这个单词，顾名思义，就是指如何生成文件。</p><p>我们举个例子：在当前目录下，有3个文本文件：<code>a.txt</code>，<code>b.txt</code>和<code>c.txt</code>。</p><p>现在，我们要合并<code>a.txt</code>与<code>b.txt</code>，生成中间文件<code>m.txt</code>，再用中间文件<code>m.txt</code>与<code>c.txt</code>合并，生成最终的目标文件<code>x.txt</code>，整个逻辑如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌─────┐ ┌─────┐ ┌─────┐</span><br><span class="line">│a.txt│ │b.txt│ │c.txt│</span><br><span class="line">└─────┘ └─────┘ └─────┘</span><br><span class="line">   │       │       │</span><br><span class="line">   └───┬───┘       │</span><br><span class="line">       │           │</span><br><span class="line">       ▼           │</span><br><span class="line">    ┌─────┐        │</span><br><span class="line">    │m.txt│        │</span><br><span class="line">    └─────┘        │</span><br><span class="line">       │           │</span><br><span class="line">       └─────┬─────┘</span><br><span class="line">             │</span><br><span class="line">             ▼</span><br><span class="line">          ┌─────┐</span><br><span class="line">          │x.txt│</span><br><span class="line">          └─────┘</span><br></pre></td></tr></table></figure><p>根据上述逻辑，我们来编写<code>Makefile</code>。</p><h3 id="规则">规则</h3><p><code>Makefile</code>由若干条规则（Rule）构成，每一条规则指出一个目标文件（Target），若干依赖文件（prerequisites），以及生成目标文件的命令。</p><p>例如，要生成<code>m.txt</code>，依赖<code>a.txt</code>与<code>b.txt</code>，规则如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 目标文件: 依赖文件1 依赖文件2</span><br><span class="line">m.txt: a.txt b.txt</span><br><span class="line">cat a.txt b.txt &gt; m.txt</span><br></pre></td></tr></table></figure><p>一条规则的格式为<code>目标文件: 依赖文件1 依赖文件2 ...</code>，紧接着，以Tab开头的是命令，用来生成目标文件。上述规则使用<code>cat</code>命令合并了<code>a.txt</code>与<code>b.txt</code>，并写入到<code>m.txt</code>。用什么方式生成目标文件<code>make</code>并不关心，因为命令完全是我们自己写的，可以是编译命令，也可以是<code>cp</code>、<code>mv</code>等任何命令。</p><p>以<code>#</code>开头的是注释，会被<code>make</code>命令忽略。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：Makefile的规则中，命令必须以Tab开头，不能是空格。</span><br></pre></td></tr></table></figure><p>类似的，我们写出生成<code>x.txt</code>的规则如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x.txt: m.txt c.txt</span><br><span class="line">cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure><p>由于<code>make</code>执行时，默认执行第一条规则，所以，我们把规则<code>x.txt</code>放到前面。完整的<code>Makefile</code>如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x.txt: m.txt c.txt</span><br><span class="line">cat m.txt c.txt &gt; x.txt</span><br><span class="line"></span><br><span class="line">m.txt: a.txt b.txt</span><br><span class="line">cat a.txt b.txt &gt; m.txt</span><br></pre></td></tr></table></figure><p>在当前目录创建<code>a.txt</code>、<code>b.txt</code>和<code>c.txt</code>，输入一些内容，执行<code>make</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cat a.txt b.txt &gt; m.txt</span><br><span class="line">cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure><p><code>make</code>默认执行第一条规则，也就是创建<code>x.txt</code>，但是由于<code>x.txt</code>依赖的文件<code>m.txt</code>不存在（另一个依赖<code>c.txt</code>已存在），故需要先执行规则<code>m.txt</code>创建出<code>m.txt</code>文件，再执行规则<code>x.txt</code>。执行完成后，当前目录下生成了两个文件<code>m.txt</code>和<code>x.txt</code>。</p><p>可见，<code>Makefile</code>定义了一系列规则，每个规则在满足依赖文件的前提下执行命令，就能创建出一个目标文件，这就是英文Make file的意思。</p><p>把默认执行的规则放第一条，其他规则的顺序是无关紧要的，因为<code>make</code>执行时自动判断依赖。</p><p>此外，<code>make</code>会打印出执行的每一条命令，便于我们观察执行顺序以便调试。</p><p>如果我们再次运行<code>make</code>，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">make: `x.txt&#x27; is up to date.</span><br></pre></td></tr></table></figure><p><code>make</code>检测到<code>x.txt</code>已经是最新版本，无需再次执行，因为<code>x.txt</code>的创建时间晚于它依赖的<code>m.txt</code>和<code>c.txt</code>的最后修改时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make使用文件的创建和修改时间来判断是否应该更新一个目标文件。</span><br></pre></td></tr></table></figure><p>修改<code>c.txt</code>后，运行<code>make</code>，会触发<code>x.txt</code>的更新：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure><p>但并不会触发<code>m.txt</code>的更新，原因是<code>m.txt</code>的依赖<code>a.txt</code>与<code>b.txt</code>并未更新，所以，<code>make</code>只会根据<code>Makefile</code>去执行那些必要的规则，并不会把所有规则都无脑执行一遍。</p><p>在编译大型程序时，全量编译往往需要几十分钟甚至几个小时。全量编译完成后，如果仅修改了几个文件，再全部重新编译完全没有必要，用<code>Makefile</code>实现增量编译就十分节省时间。</p><p>当然，是否能正确地实现增量更新，取决于我们的规则写得对不对，<code>make</code>本身并不会检查规则逻辑是否正确。</p><h3 id="伪目标">伪目标</h3><p>因为<code>m.txt</code>与<code>x.txt</code>都是自动生成的文件，所以，可以安全地删除。</p><p>删除时，我们也不希望手动删除，而是编写一个<code>clean</code>规则来删除它们：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">rm -f m.txt</span><br><span class="line">rm -f x.txt</span><br></pre></td></tr></table></figure><p><code>clean</code>规则与我们前面编写的规则有所不同，它没有依赖文件，因此，要执行<code>clean</code>，必须用命令<code>make clean</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make clean</span><br><span class="line">rm -f m.txt</span><br><span class="line">rm -f x.txt</span><br></pre></td></tr></table></figure><p>然而，在执行<code>clean</code>时，我们并没有创建一个名为<code>clean</code>的文件，所以，因为目标文件<code>clean</code>不存在，每次运行<code>make clean</code>，都会执行这个规则的命令。</p><p>如果我们手动创建一个<code>clean</code>的文件，这个<code>clean</code>规则就不会执行了！</p><p>如果我们希望<code>make</code>把<code>clean</code>不要视为文件，可以添加一个标识：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f m.txt</span><br><span class="line">rm -f x.txt</span><br></pre></td></tr></table></figure><p>此时，<code>clean</code>就不被视为一个文件，而是伪目标（Phony Target）。</p><p>大型项目通常会提供<code>clean</code>、<code>install</code>这些约定俗成的伪目标名称，方便用户快速执行特定任务。</p><p>一般来说，并不需要用<code>.PHONY</code>标识<code>clean</code>等约定俗成的伪目标名称，除非有人故意搞破坏，手动创建名字叫<code>clean</code>的文件。</p><h3 id="执行多条命令">执行多条命令</h3><p>一个规则可以有多条命令，例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd:</span></span><br><span class="line">pwd</span><br><span class="line">cd ..</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure><p>执行<code>cd</code>规则：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make cd</span><br><span class="line">pwd</span><br><span class="line">/home/ubuntu/makefile-tutorial/v1</span><br><span class="line">cd ..</span><br><span class="line">pwd</span><br><span class="line">/home/ubuntu/makefile-tutorial/v1</span><br></pre></td></tr></table></figure><p>观察输出，发现<code>cd ..</code>命令执行后，并未改变当前目录，两次输出的<code>pwd</code>是一样的，这是因为<code>make</code>针对每条命令，都会创建一个独立的Shell环境，类似<code>cd ..</code>这样的命令，并不会影响当前目录。</p><p>解决办法是把多条命令以<code>;</code>分隔，写到一行：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">pwd; cd ..; pwd;</span><br></pre></td></tr></table></figure><p>再执行<code>cd_ok</code>目标就得到了预期结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make cd_ok</span><br><span class="line">pwd; cd ..; pwd</span><br><span class="line">/home/ubuntu/makefile-tutorial/v1</span><br><span class="line">/home/ubuntu/makefile-tutorial</span><br></pre></td></tr></table></figure><p>可以使用<code>\</code>把一行语句拆成多行，便于浏览：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">pwd; \</span><br><span class="line">cd ..; \</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure><p>另一种执行多条命令的语法是用<code>&amp;&amp;</code>，它的好处是当某条命令失败时，后续命令不会继续执行：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">cd .. &amp;&amp; pwd</span><br></pre></td></tr></table></figure><h3 id="控制打印">控制打印</h3><p>默认情况下，<code>make</code>会打印出它执行的每一条命令。如果我们不想打印某一条命令，可以在命令前加上<code>@</code>，表示不打印命令（但是仍然会执行）：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">no_output:</span></span><br><span class="line">@echo &#x27;not display&#x27;</span><br><span class="line">echo &#x27;will display&#x27;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make no_output</span><br><span class="line">not display</span><br><span class="line">echo &#x27;will display&#x27;</span><br><span class="line">will display</span><br></pre></td></tr></table></figure><p>注意命令<code>echo 'not display'</code>本身没有打印，但命令仍然会执行，并且执行的结果仍然正常打印。</p><h3 id="控制错误">控制错误</h3><p><code>make</code>在执行命令时，会检查每一条命令的返回值，如果返回错误（非0值），就会中断执行。</p><p>例如，不使用<code>-f</code>删除一个不存在的文件会报错：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">has_error:</span></span><br><span class="line">rm zzz.txt</span><br><span class="line">echo &#x27;ok&#x27;</span><br></pre></td></tr></table></figure><p>执行上述目标，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make has_error</span><br><span class="line">rm zzz.txt</span><br><span class="line">rm: zzz.txt: No such file or directory</span><br><span class="line">make: *** [has_error] Error 1</span><br></pre></td></tr></table></figure><p>由于命令<code>rm zzz.txt</code>报错，导致后面的命令<code>echo 'ok'</code>并不会执行，<code>make</code>打印出错误，然后退出。</p><p>有些时候，我们想忽略错误，继续执行后续命令，可以在需要忽略错误的命令前加上<code>-</code>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ignore_error:</span></span><br><span class="line">-rm zzz.txt</span><br><span class="line">echo &#x27;ok&#x27;</span><br></pre></td></tr></table></figure><p>执行上述目标，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make ignore_error</span><br><span class="line">rm zzz.txt</span><br><span class="line">rm: zzz.txt: No such file or directory</span><br><span class="line">make: [ignore_error] Error 1 (ignored)</span><br><span class="line">echo &#x27;ok&#x27;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p><code>make</code>检测到<code>rm zzz.txt</code>报错，并打印错误，但显示<code>(ignored)</code>，然后继续执行后续命令。</p><p>对于执行可能出错，但不影响逻辑的命令，可以用<code>-</code>忽略。</p><h3 id="参考源码">参考源码</h3><p>可以从<a href="https://github.com/michaelliao/makefile-tutorial/tree/main/v1">GitHub</a>下载源码。</p><p><a href="https://github.com/michaelliao/makefile-tutorial/tree/main/v1">GitHub</a></p><h3 id="小结">小结</h3><p>编写<code>Makefile</code>就是编写一系列规则，用来告诉<code>make</code>如何执行这些规则，最终生成我们期望的目标文件。</p><p>查看官方手册：</p><ul><li><a href="https://www.gnu.org/software/make/manual/html_node/Rules.html">编写规则</a></li><li><a href="https://www.gnu.org/software/make/manual/html_node/Execution.html">执行命令</a></li><li><a href="https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html">伪目标</a></li></ul><h2 id="编译C程序">编译C程序</h2><p>C程序的编译通常分两步：</p><ol><li>将每个<code>.c</code>文件编译为<code>.o</code>文件；</li><li>将所有<code>.o</code>文件链接为最终的可执行文件。</li></ol><p>我们假设如下的一个C项目，包含<code>hello.c</code>、<code>hello.h</code>和<code>main.c</code>。</p><p><code>hello.c</code>内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hello.h</code>内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p><code>main.c</code>内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start...\n&quot;</span>);</span><br><span class="line">    hello();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>main.c</code>引用了头文件<code>hello.h</code>。我们很容易梳理出需要生成的文件，逻辑如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌───────┐ ┌───────┐ ┌───────┐</span><br><span class="line">│hello.c│ │main.c │ │hello.h│</span><br><span class="line">└───────┘ └───────┘ └───────┘</span><br><span class="line">    │         │         │</span><br><span class="line">    │         └────┬────┘</span><br><span class="line">    │              │</span><br><span class="line">    ▼              ▼</span><br><span class="line">┌───────┐      ┌───────┐</span><br><span class="line">│hello.o│      │main.o │</span><br><span class="line">└───────┘      └───────┘</span><br><span class="line">    │              │</span><br><span class="line">    └───────┬──────┘</span><br><span class="line">            │</span><br><span class="line">            ▼</span><br><span class="line">       ┌─────────┐</span><br><span class="line">       │world.out│</span><br><span class="line">       └─────────┘</span><br></pre></td></tr></table></figure><p>假定最终生成的可执行文件是<code>world.out</code>，中间步骤还需要生成<code>hello.o</code>和<code>main.o</code>两个文件。根据上述依赖关系，我们可以很容易地写出<code>Makefile</code>如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成可执行文件:</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 hello.c:</span></span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">cc -c hello.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 main.c:</span></span><br><span class="line"><span class="section">main.o: main.c hello.h</span></span><br><span class="line">cc -c main.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o world.out</span><br></pre></td></tr></table></figure><p>执行<code>make</code>，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -c main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><p>在当前目录下可以看到<code>hello.o</code>、<code>main.o</code>以及最终的可执行程序<code>world.out</code>。执行<code>world.out</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./world.out </span><br><span class="line">start...</span><br><span class="line">hello, world!</span><br><span class="line">exit.</span><br></pre></td></tr></table></figure><p>与我们预期相符。</p><p>修改<code>hello.c</code>，把输出改为<code>&quot;hello, bob!\n&quot;</code>，再执行<code>make</code>，观察输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><p>仅重新编译了<code>hello.c</code>，并未编译<code>main.c</code>。由于<code>hello.o</code>已更新，所以，仍然要重新生成<code>world.out</code>。执行<code>world.out</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./world.out </span><br><span class="line">start...</span><br><span class="line">hello, bob!</span><br><span class="line">exit.</span><br></pre></td></tr></table></figure><p>与我们预期相符。</p><p>修改<code>hello.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int 变为 void:</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>以及<code>hello.c</code>，再次执行<code>make</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -c main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><p>会触发<code>main.c</code>的编译，因为<code>main.c</code>依赖<code>hello.h</code>。</p><p>执行<code>make clean</code>会删除所有的<code>.o</code>文件，以及可执行文件<code>world.out</code>，再次执行<code>make</code>就会强制全量编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make clean &amp;&amp; make</span><br><span class="line">rm -f *.o world.out</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -c main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><p>这个简单的<code>Makefile</code>使我们能自动化编译C程序，十分方便。</p><p>不过，随着越来越多的<code>.c</code>文件被添加进来，如何高效维护<code>Makefile</code>的规则？我们后面继续讲解。</p><h3 id="参考源码-2">参考源码</h3><p>可以从<a href="https://github.com/michaelliao/makefile-tutorial/tree/main/v2">GitHub</a>下载源码。</p><p><a href="https://github.com/michaelliao/makefile-tutorial/tree/main/v2">GitHub</a></p><h3 id="小结-2">小结</h3><p>在<code>Makefile</code>正确定义规则后，我们就能用<code>make</code>自动化编译C程序。</p><hr><hr><h2 id="使用隐式规则">使用隐式规则</h2><p>我们仍然以上一节的C项目为例，当我们添加越来越多的<code>.c</code>文件时，就需要编写越来越多的规则来生成<code>.o</code>文件。</p><p>实际上，有的同学可能发现了，即使我们把<code>.o</code>的规则删掉，也能正常编译：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只保留生成 world.out 的规则:</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o world.out</span><br></pre></td></tr></table></figure><p>执行<code>make</code>，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc    -c -o hello.o hello.c</span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><p>我们没有定义<code>hello.o</code>和<code>main.o</code>的规则，为什么<code>make</code>也能正常创建这两个文件？</p><p>因为<code>make</code>最初就是为了编译C程序而设计的，为了免去重复创建编译<code>.o</code>文件的规则，<code>make</code>内置了隐式规则（Implicit Rule），即遇到一个<code>xyz.o</code>时，如果没有找到对应的规则，就自动应用一个隐式规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">xyz.o: xyz.c</span></span><br><span class="line">cc -c -o xyz.o xyz.c</span><br></pre></td></tr></table></figure><p><code>make</code>针对C、C++、ASM、Fortran等程序内置了一系列隐式规则，可以参考官方手册查看。</p><p>对于C程序来说，使用隐式规则有一个潜在问题，那就是无法跟踪<code>.h</code>文件的修改。如果我们修改了<code>hello.h</code>的定义，由于隐式规则<code>main.o: main.c</code>并不会跟踪<code>hello.h</code>的修改，导致<code>main.c</code>不会被重新编译，这个问题我们放到后面解决。</p><h3 id="参考源码-3">参考源码</h3><p>可以从<a href="https://github.com/michaelliao/makefile-tutorial/tree/main/v3">GitHub</a>下载源码。</p><p><a href="https://github.com/michaelliao/makefile-tutorial/tree/main/v3">GitHub</a></p><h3 id="小结-3">小结</h3><p>针对C、C++、ASM、Fortran等程序，<code>make</code>内置了一系列隐式规则，使用隐式规则可减少大量重复的通用编译规则。</p><p>查看官方手册：</p><ul><li><a href="https://www.gnu.org/software/make/manual/html_node/Using-Implicit.html">使用隐式规则</a></li></ul><hr><hr><p>当我们在<code>Makefile</code>中重复写很多文件名时，一来容易写错，二来如果要改名，要全部替换，费时费力。</p><p>编程语言使用变量（Variable）来解决反复引用的问题，类似的，在<code>Makefile</code>中，也可以使用变量来解决重复问题。</p><p>以上一节的<code>Makefile</code>为例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o world.out</span><br></pre></td></tr></table></figure><p>编译的最终文件<code>world.out</code>重复出现了3次，因此，完全可以定义一个变量来替换它：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: hello.o main.o</span><br><span class="line">cc -o <span class="variable">$(TARGET)</span> hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><p>变量定义用<code>变量名 = 值</code>或者<code>变量名 := 值</code>，通常变量名全大写。引用变量用<code>$(变量名)</code>，非常简单。</p><p>注意到<code>hello.o main.o</code>这个“列表”也重复了，我们也可以用变量来替换：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OBJS = hello.o main.o</span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><p>如果有一种方式能让<code>make</code>自动生成<code>hello.o main.o</code>这个“列表”，就更好了。注意到每个<code>.o</code>文件是由对应的<code>.c</code>文件编译产生的，因此，可以让<code>make</code>先获取<code>.c</code>文件列表，再替换，得到<code>.o</code>文件列表：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $(wildcard *.c) 列出当前目录下的所有 .c 文件: hello.c main.c</span></span><br><span class="line"><span class="comment"># 用函数 patsubst 进行模式替换得到: hello.o main.o</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><p>这样，我们每添加一个<code>.c</code>文件，不需要修改<code>Makefile</code>，变量<code>OBJS</code>会自动更新。</p><p>思考：为什么我们不能直接定义<code>OBJS = $(wildcard *.o)</code>让<code>make</code>列出所有<code>.o</code>文件？</p><h3 id="内置变量">内置变量</h3><p>我们还可以用变量<code>$(CC)</code>替换命令<code>cc</code>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line"><span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure><p>没有定义变量<code>CC</code>也可以引用它，因为它是<code>make</code>的内置变量（Builtin Variables），表示C编译器的名字，默认值是<code>cc</code>，我们也可以修改它，例如使用交叉编译时，指定编译器：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC = riscv64-linux-gnu-gcc</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="自动变量">自动变量</h3><p>在<code>Makefile</code>中，经常可以看到<code>$@</code>、<code>$&lt;</code>这样的变量，这种变量称为自动变量（Automatic Variable），它们在一个规则中自动指向某个值。</p><p>例如，<code>$@</code>表示目标文件，<code>$^</code>表示所有依赖文件，因此，我们可以这么写：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">cc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure><p>在没有歧义时可以写<code>$@</code>，也可以写<code>$(@)</code>，有歧义时必须用括号，例如<code>$(@D)</code>。</p><p>为了更好地调试，我们还可以把变量打印出来：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">@echo &#x27;$<span class="variable">$@</span> = <span class="variable">$@</span>&#x27; <span class="comment"># 变量 $@ 表示target</span></span><br><span class="line">@echo &#x27;$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>&#x27; <span class="comment"># 变量 $&lt; 表示第一个依赖项</span></span><br><span class="line">@echo &#x27;$<span class="variable">$^</span> = <span class="variable">$^</span>&#x27; <span class="comment"># 变量 $^ 表示所有依赖项</span></span><br><span class="line">cc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure><p>执行结果输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$@ = world.out</span><br><span class="line">$&lt; = hello.o</span><br><span class="line">$^ = hello.o main.o</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><h3 id="参考源码-4">参考源码</h3><p>可以从<a href="https://github.com/michaelliao/makefile-tutorial/tree/main/v4">GitHub</a>下载源码。</p><p><a href="https://github.com/michaelliao/makefile-tutorial/tree/main/v4">GitHub</a></p><h3 id="小结-4">小结</h3><p>使用变量可以让<code>Makefile</code>更加容易维护。</p><p>查看官方手册：</p><ul><li><a href="https://www.gnu.org/software/make/manual/html_node/Using-Variables.html">如何使用变量</a></li><li><a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">自动变量</a></li></ul><h2 id="使用模式规则">使用模式规则</h2><p>前面我们讲了使用隐式规则可以让<code>make</code>在必要时自动创建<code>.o</code>文件的规则，但<code>make</code>的隐式规则的命令是固定的，对于<code>xyz.o: xyz.c</code>，它实际上是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure><p>能修改的只有变量<code>$(CC)</code>和<code>$(CFLAGS)</code>。如果要执行多条命令，使用隐式规则就不行了。</p><p>这时，我们可以自定义模式规则（Pattern Rules），它允许<code>make</code>匹配模式规则，如果匹配上了，就自动创建一条模式规则。</p><p>我们修改上一节的<code>Makefile</code>如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式匹配规则：当make需要目标 xyz.o 时，自动生成一条 xyz.o: xyz.c 规则:</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">@echo &#x27;compiling <span class="variable">$&lt;</span>...&#x27;</span><br><span class="line">cc -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><p>当<code>make</code>执行<code>world.out: hello.o main.o</code>时，发现没有<code>hello.o</code>文件，于是需要查找以<code>hello.o</code>为目标的规则，结果匹配到模式规则<code>%.o: %.c</code>，于是<code>make</code>自动根据模式规则为我们动态创建了如下规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">@echo &#x27;compiling <span class="variable">$&lt;</span>...&#x27;</span><br><span class="line">cc -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure><p>查找<code>main.o</code>也是类似的匹配过程，于是我们执行<code>make</code>，就可以用模式规则完成编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">compiling hello.c...</span><br><span class="line">cc -c -o hello.o hello.c</span><br><span class="line">compiling main.c...</span><br><span class="line">cc -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><p>模式规则的命令完全由我们自己定义，因此，它比隐式规则更灵活。</p><p>但是，模式规则仍然没有解决修改<code>hello.h</code>头文件不会触发<code>main.c</code>重新编译的问题，这个依赖问题我们继续放到后面解决。</p><p>最后注意，模式规则是按需生成，如果我们在当前目录创建一个<code>zzz.o</code>文件，因为<code>make</code>并不会在执行过程中用到它，所以并不会自动生成<code>zzz.o: zzz.c</code>这个规则。</p><h3 id="参考源码-5">参考源码</h3><p>可以从<a href="https://github.com/michaelliao/makefile-tutorial/tree/main/v5">GitHub</a>下载源码。</p><p><a href="https://github.com/michaelliao/makefile-tutorial/tree/main/v5">GitHub</a></p><h3 id="小结-5">小结</h3><p>使用模式规则可以灵活地按需动态创建规则，它比隐式规则更灵活。</p><p>查看官方手册：</p><ul><li><a href="https://www.gnu.org/software/make/manual/html_node/Pattern-Intro.html">模式规则</a></li></ul><hr><hr><p>前面我们讲了隐式规则和模式规则，这两种规则都可以解决自动把<code>.c</code>文件编译成<code>.o</code>文件，但都无法解决<code>.c</code>文件依赖<code>.h</code>文件的问题。</p><p>因为一个<code>.c</code>文件依赖哪个<code>.h</code>文件必须要分析文件内容才能确定，没有一个简单的文件名映射规则。</p><p>但是，要识别出<code>.c</code>文件的头文件依赖，可以用GCC提供的<code>-MM</code>参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cc -MM main.c</span><br><span class="line">main.o: main.c hello.h</span><br></pre></td></tr></table></figure><p>上述输出告诉我们，编译<code>main.o</code>依赖<code>main.c</code>和<code>hello.h</code>两个文件。</p><p>因此，我们可以利用GCC的这个功能，对每个<code>.c</code>文件都生成一个依赖项，通常我们把它保存到<code>.d</code>文件中，再用<code>include</code>引入到<code>Makefile</code>，就相当于自动化完成了每个<code>.c</code>文件的精准依赖。</p><p>我们改写上一节的<code>Makefile</code>如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有 .c 文件:</span></span><br><span class="line">SRCS = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据SRCS生成 .o 文件列表:</span></span><br><span class="line">OBJS = $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据SRCS生成 .d 文件列表:</span></span><br><span class="line">DEPS = $(SRCS:.c=.d)</span><br><span class="line"></span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标:</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line"><span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># xyz.d 的规则由 xyz.c 生成:</span></span><br><span class="line"><span class="section">%.d: %.c</span></span><br><span class="line">rm -f <span class="variable">$@</span>; \</span><br><span class="line"><span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> &gt;<span class="variable">$@</span>.tmp; \</span><br><span class="line">sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.tmp &gt; <span class="variable">$@</span>; \</span><br><span class="line">rm -f <span class="variable">$@</span>.tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式规则:</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line"><span class="variable">$(CC)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.o *.d <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入所有 .d 文件:</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(DEPS)</span></span><br></pre></td></tr></table></figure><p>变量<code>$(SRCS)</code>通过扫描目录可以确定为<code>hello.c main.c</code>，因此，变量<code>$(OBJS)</code>赋值为<code>hello.o main.o</code>，变量<code>$(DEPS)</code>赋值为<code>hello.d main.d</code>。</p><p>通过<code>include $(DEPS)</code>我们引入<code>hello.d</code>和<code>main.d</code>文件，但是这两个文件一开始并不存在，不过，<code>make</code>通过模式规则匹配到<code>%.d: %.c</code>，这就给了我们一个机会，在这个模式规则内部，用<code>cc -MM</code>命令外加<code>sed</code>把<code>.d</code>文件创建出来。</p><p>运行<code>make</code>，首次输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">Makefile:31: hello.d: No such file or directory</span><br><span class="line">Makefile:31: main.d: No such file or directory</span><br><span class="line">rm -f main.d; \</span><br><span class="line">        cc -MM main.c &gt;main.d.tmp; \</span><br><span class="line">        sed &#x27;s,\(main\)\.o[ :]*,\1.o main.d : ,g&#x27; &lt; main.d.tmp &gt; main.d; \</span><br><span class="line">        rm -f main.d.tmp</span><br><span class="line">rm -f hello.d; \</span><br><span class="line">        cc -MM hello.c &gt;hello.d.tmp; \</span><br><span class="line">        sed &#x27;s,\(hello\)\.o[ :]*,\1.o hello.d : ,g&#x27; &lt; hello.d.tmp &gt; hello.d; \</span><br><span class="line">        rm -f hello.d.tmp</span><br><span class="line">cc -c -o hello.o hello.c</span><br><span class="line">cc -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><p><code>make</code>会提示找不到<code>hello.d</code>和<code>main.d</code>，不过随后自动创建出<code>hello.d</code>和<code>main.d</code>。<code>hello.d</code>内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello.o hello.d : hello.c</span><br></pre></td></tr></table></figure><p>上述规则有两个目标文件，实际上相当于如下两条规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello.o : hello.c</span><br><span class="line">hello.d : hello.c</span><br></pre></td></tr></table></figure><p><code>main.d</code>内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o main.d : main.c hello.h</span><br></pre></td></tr></table></figure><p>因此，<code>main.o</code>依赖于<code>main.c</code>和<code>hello.h</code>，这个依赖关系就和我们手动指定的一致。</p><p>改动<code>hello.h</code>，再次运行<code>make</code>，可以触发<code>main.c</code>的编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">rm -f main.d; \</span><br><span class="line">        cc -MM main.c &gt;main.d.tmp; \</span><br><span class="line">        sed &#x27;s,\(main\)\.o[ :]*,\1.o main.d : ,g&#x27; &lt; main.d.tmp &gt; main.d; \</span><br><span class="line">        rm -f main.d.tmp</span><br><span class="line">cc -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><p>在实际项目中，对每个<code>.c</code>文件都可以生成一个对应的<code>.d</code>文件表示依赖关系，再通过<code>include</code>引入到<code>Makefile</code>，同时又能让<code>make</code>自动更新<code>.d</code>文件，有点蛋生鸡和鸡生蛋的关系，不过，这种机制能正常工作，除了<code>.d</code>文件不存在时会打印错误，有强迫症的同学肯定感觉不满意，这个问题我们后面解决。</p><h3 id="参考源码-6">参考源码</h3><p>可以从<a href="https://github.com/michaelliao/makefile-tutorial/tree/main/v6">GitHub</a>下载源码。</p><p><a href="https://github.com/michaelliao/makefile-tutorial/tree/main/v6">GitHub</a></p><h3 id="小结-6">小结</h3><p>利用GCC生成<code>.d</code>文件，再用<code>include</code>引入<code>Makefile</code>，可解决一个<code>.c</code>文件应该如何正确触发编译的问题。</p><p>查看官方手册：</p><ul><li><a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Prerequisites.html">自动生成依赖</a></li></ul><h2 id="完善Makefile">完善Makefile</h2><p>上一节我们解决了自动生成依赖的问题，这一节我们对项目目录进行整理，把所有源码放入<code>src</code>目录，所有编译生成的文件放入<code>build</code>目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">├── Makefile</span><br><span class="line">├── build</span><br><span class="line">└── src</span><br><span class="line">    ├── hello.c</span><br><span class="line">    ├── hello.h</span><br><span class="line">    └── main.c</span><br></pre></td></tr></table></figure><p>整理<code>Makefile</code>，内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">SRC_DIR = ./src</span><br><span class="line">BUILD_DIR = ./build</span><br><span class="line">TARGET = <span class="variable">$(BUILD_DIR)</span>/world.out</span><br><span class="line"></span><br><span class="line">CC = cc</span><br><span class="line">CFLAGS = -Wall</span><br><span class="line"></span><br><span class="line"><span class="comment"># ./src/*.c</span></span><br><span class="line">SRCS = <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(SRC_DIR)</span> -name &#x27;*.c&#x27;)</span></span><br><span class="line"><span class="comment"># ./src/*.c =&gt; ./build/*.o</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c,<span class="variable">$(BUILD_DIR)</span>/%.o,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line"><span class="comment"># ./src/*.c =&gt; ./build/*.d</span></span><br><span class="line">DEPS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c,<span class="variable">$(BUILD_DIR)</span>/%.d,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标:</span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build/xyz.d 的规则由 src/xyz.c 生成:</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.d: <span class="variable">$(SRC_DIR)</span>/%.c</span><br><span class="line">@mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>; \</span><br><span class="line">rm -f <span class="variable">$@</span>; \</span><br><span class="line"><span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> &gt;<span class="variable">$@</span>.tmp; \</span><br><span class="line">sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,<span class="variable">$(BUILD_DIR)</span>/\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.tmp &gt; <span class="variable">$@</span>; \</span><br><span class="line">rm -f <span class="variable">$@</span>.tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># build/xyz.o 的规则由 src/xyz.c 生成:</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.o: <span class="variable">$(SRC_DIR)</span>/%.c</span><br><span class="line">@mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接:</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">@echo <span class="string">&quot;buiding <span class="variable">$@</span>...&quot;</span></span><br><span class="line">@mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line"><span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理 build 目录:</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">@echo <span class="string">&quot;clean...&quot;</span></span><br><span class="line">rm -rf <span class="variable">$(BUILD_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入所有 .d 文件:</span></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br></pre></td></tr></table></figure><p>这个<code>Makefile</code>定义了源码目录<code>SRC_DIR</code>、生成目录<code>BUILD_DIR</code>，以及其他变量，同时用<code>-include</code>消除了<code>.d</code>文件不存在的错误。执行<code>make</code>，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -Wall -c -o build/hello.o src/hello.c</span><br><span class="line">cc -Wall -c -o build/main.o src/main.c</span><br><span class="line">buiding build/world.out...</span><br><span class="line">cc -o ./build/world.out ./build/hello.o ./build/main.o</span><br></pre></td></tr></table></figure><p>可以说基本满足编译需求，收工！</p><h3 id="参考源码-7">参考源码</h3><p>可以从<a href="https://github.com/michaelliao/makefile-tutorial/tree/main/v7">GitHub</a>下载源码。</p><p><a href="https://github.com/michaelliao/makefile-tutorial/tree/main/v7">GitHub</a></p><h3 id="小结-7">小结</h3><p>除了基础的用法外，<code>Makefile</code>还支持条件判断，环境变量，嵌套执行，变量展开等各种功能，需要用到时可以查询<a href="https://www.gnu.org/software/make/manual/html_node/index.html">官方手册</a>。</p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> make </category>
          
      </categories>
      
      
        <tags>
            
            <tag> make </tag>
            
            <tag> devops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ansible教程-hands-on</title>
      <link href="/2025/05/22/ansible/ansible%E6%95%99%E7%A8%8B-hands-on/"/>
      <url>/2025/05/22/ansible/ansible%E6%95%99%E7%A8%8B-hands-on/</url>
      
        <content type="html"><![CDATA[<h1>Ansible 学习笔记</h1><h2 id="简介">简介</h2><ul><li>基于Python开发的自动化运维工具</li><li>集合了众多运维工具(puppet、cfengine、chef、func、fabric)的优点</li><li>基于模块工作，本身没有批量部署能力，批量部署由运行的模块实现</li><li>提供自动化运维框架</li></ul><h2 id="作用">作用</h2><ul><li>批量系统配置</li><li>批量程序部署</li><li>批量运行命令</li></ul><h2 id="框架组成">框架组成</h2><ul><li><strong>Connection Plugins</strong>：负责和被监控端实现通信</li><li><strong>Host Inventory</strong>：定义监控主机的配置文件</li><li><strong>模块</strong>：<ul><li>核心模块</li><li>command模块</li><li>自定义模块</li></ul></li><li><strong>插件</strong>：完成记录日志邮件等功能</li><li><strong>Playbook</strong>：剧本，非必需，可让节点一次性运行多个任务</li></ul><h2 id="架构图">架构图</h2><p><img src="/assets/images/ansible1.png" alt="Ansible架构图"></p><h2 id="架构字段解释">架构字段解释</h2><ul><li><strong>Ansible</strong>：核心程序</li><li><strong>Host Inventory</strong>：主机清单(可定义主机组和主机)</li><li><strong>模块</strong>：实际执行任务的组件</li><li><strong>Playbook</strong>：Yaml定义的剧本文件(类似shell脚本)</li><li><strong>Connect Plugin</strong>：连接插件</li></ul><h2 id="工作原理">工作原理</h2><ol><li>控制端通过inventory定义主机组</li><li>通过编写playbook或AD-HOC命令</li><li>使用SSH将模块推送到被控端</li><li>被控端执行任务(要求被控端有Python2环境)</li><li>任务完成后返回结果</li></ol><h2 id="命令执行过程">命令执行过程</h2><ol><li>加载配置文件(/etc/ansible/ansible.cfg)</li><li>查找主机配置文件</li><li>加载对应模块文件</li><li>生成临时Python脚本并传输到远程主机</li><li>存储在远程主机的<code>~/.ansible/tmp/</code>目录</li><li>添加执行权限</li><li>执行并返回结果</li><li>删除临时文件</li></ol><h2 id="执行流程理解图">执行流程理解图</h2><p><img src="/assets/images/ansible2.png" alt="执行流程"></p><h2 id="特性">特性</h2><ul><li><strong>No Agents</strong>：无需在被控端安装客户端</li><li><strong>No Server</strong>：无服务端架构</li><li><strong>Modules in Any Languages</strong>：支持任意语言开发模块</li><li><strong>YAML</strong>：使用YAML语言编写playbook</li><li><strong>SSH by Default</strong>：默认基于SSH工作</li><li><strong>Multi-tier Solution</strong>：支持多级指挥</li></ul><h2 id="配置文件">配置文件</h2><p>配置文件优先级(从高到低)：</p><ol><li>项目目录下的<code>ansible.cfg</code></li><li>用户家目录下的<code>.ansible.cfg</code></li><li>默认的<code>/etc/ansible/ansible.cfg</code></li></ol><h3 id="主要配置项">主要配置项</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#inventory = /etc/ansible/hosts      # 主机列表</span></span><br><span class="line"><span class="comment">#library = /usr/share/my_modules/     # 模块库目录</span></span><br><span class="line"><span class="comment">#remote_tmp = ~/.ansible/tmp          # 远程临时目录</span></span><br><span class="line"><span class="comment">#local_tmp = ~/.ansible/tmp           # 本地临时目录</span></span><br><span class="line"><span class="comment">#forks = 5                            # 并发数</span></span><br><span class="line"><span class="comment">#sudo_user = root                     # 默认sudo用户</span></span><br><span class="line"><span class="comment">#ask_sudo_pass = True                 # 是否询问sudo密码</span></span><br><span class="line"><span class="comment">#ask_pass = True                      # 是否询问SSH密码</span></span><br><span class="line"><span class="comment">#remote_port = 22                     # 远程端口</span></span><br><span class="line"><span class="attr">host_key_checking</span> = <span class="literal">False</span>             <span class="comment"># 跳过主机指纹检查</span></span><br><span class="line"><span class="attr">log_path</span> = /var/log/ansible.log       <span class="comment"># 日志路径</span></span><br></pre></td></tr></table></figure><h2 id="优点">优点</h2><ul><li>轻量级，客户端无需安装agent</li><li>批量任务可写成脚本且无需分发</li><li>基于Python，维护简单</li><li>支持sudo</li></ul><h2 id="环境搭建">环境搭建</h2><h3 id="主机规划">主机规划</h3><table><thead><tr><th>主机</th><th>IP</th><th>角色</th></tr></thead><tbody><tr><td>h1</td><td>192.168.50.60</td><td>master</td></tr><tr><td>h2</td><td>192.168.50.61</td><td>host1</td></tr><tr><td>h3</td><td>192.168.50.62</td><td>host2</td></tr><tr><td>h4</td><td>192.168.50.63</td><td>host3</td></tr></tbody></table><h3 id="SSH免密登录配置">SSH免密登录配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t dsa -f ~/.ssh/id_dsa -P <span class="string">&quot;&quot;</span></span><br><span class="line">ssh-copy-id -i ~/.ssh/id_dsa.pub root@192.168.50.61</span><br></pre></td></tr></table></figure><h3 id="安装">安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y ansible</span><br></pre></td></tr></table></figure><h3 id="主机清单配置">主机清单配置</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[hosts]</span></span><br><span class="line">192.168.50.61</span><br><span class="line">192.168.50.62</span><br><span class="line">192.168.50.63</span><br><span class="line"></span><br><span class="line"><span class="section">[local]</span></span><br><span class="line">127.0.0.1</span><br></pre></td></tr></table></figure><h3 id="测试">测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ansible webservers -m <span class="built_in">command</span> -a <span class="string">&#x27;uptime&#x27;</span></span><br><span class="line">ansible all -m ping</span><br></pre></td></tr></table></figure><h2 id="常用模块">常用模块</h2><h3 id="setup模块">setup模块</h3><p>查看远程主机基本信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible webservers -m setup</span><br></pre></td></tr></table></figure><h3 id="fetch模块">fetch模块</h3><p>从主机获取文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible 192.168.50.61 -m fetch -a <span class="string">&#x27;src=/root/t2 dest=/root&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="file模块">file模块</h3><p>设置文件属性</p><p><strong>选项</strong>:</p><ul><li><code>force</code>: 强制创建软链接(yes|no)</li><li><code>group</code>: 文件属组</li><li><code>mode</code>: 文件权限</li><li><code>owner</code>: 文件属主</li><li><code>path</code>: 文件路径(必选)</li><li><code>recurse</code>: 递归设置属性(仅目录)</li><li><code>src</code>: 源文件路径(仅state=link时)</li><li><code>dest</code>: 链接目标路径(仅state=link时)</li><li><code>state</code>:<ul><li><code>directory</code>: 创建目录</li><li><code>file</code>: 不创建文件</li><li><code>link</code>: 创建软链接</li><li><code>hard</code>: 创建硬链接</li><li><code>touch</code>: 创建空文件或更新修改时间</li><li><code>absent</code>: 删除文件/目录</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建符号链接</span></span><br><span class="line">ansible hosts -m file -a <span class="string">&quot;src=/etc/resolv.conf dest=/root/resolv.conf state=link&quot;</span></span><br></pre></td></tr></table></figure><h3 id="copy模块">copy模块</h3><p>复制文件到远程主机</p><p><strong>选项</strong>:</p><ul><li><code>backup</code>: 覆盖前备份(yes|no)</li><li><code>content</code>: 直接设置文件内容(替代src)</li><li><code>dest</code>: 目标绝对路径(必选)</li><li><code>directory_mode</code>: 递归设置目录权限</li><li><code>force</code>: 强制覆盖(yes|no)</li><li><code>src</code>: 本地源文件路径</li></ul><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible hosts -m copy -a <span class="string">&quot;src=/etc/ansible/ansible.cfg dest=/tmp/ansible.cfg owner=root group=root mode=0755&quot;</span></span><br></pre></td></tr></table></figure><h3 id="command模块">command模块</h3><p>在远程主机执行命令</p><p><strong>选项</strong>:</p><ul><li><code>creates</code>: 文件存在时不执行</li><li><code>free_form</code>: Linux命令</li><li><code>chdir</code>: 执行前切换目录</li><li><code>removes</code>: 文件不存在时不执行</li><li><code>executable</code>: 指定shell路径</li></ul><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ansible webservers -m <span class="built_in">command</span> -a <span class="string">&quot;ls -al /tmp&quot;</span></span><br><span class="line">ansible webservers -m <span class="built_in">command</span> -a <span class="string">&#x27;useradd abc&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="shell模块">shell模块</h3><p>支持管道操作的命令执行</p><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行远程脚本</span></span><br><span class="line">ansible hosts -m shell -a <span class="string">&quot;/root/test.sh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量添加用户密码</span></span><br><span class="line">ansible hosts -m shell -a <span class="string">&#x27;useradd abc &amp;&amp; echo 123 |passwd --stdin abc&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="cron模块">cron模块</h3><p>管理计划任务</p><p><strong>选项</strong>:</p><ul><li><code>minute/hour/day/month/weekday</code>: 时间设置</li><li><code>job</code>: 任务命令</li><li><code>name</code>: 任务名称</li><li><code>user</code>: 执行用户</li><li><code>state</code>: present(添加)|absent(删除)</li></ul><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建任务</span></span><br><span class="line">ansible all -m cron -a <span class="string">&quot;minute=&#x27;*/5&#x27; job=&#x27;/usr/sbin/ntpdate 192.168.50.60 &amp;&gt;/dev/null&#x27; name=&#x27;sync time&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除任务</span></span><br><span class="line">ansible all -m cron -a <span class="string">&quot;name=&#x27;sync time&#x27; state=absent&quot;</span></span><br></pre></td></tr></table></figure><h3 id="hostname模块">hostname模块</h3><p>管理主机名</p><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改主机名</span></span><br><span class="line">ansible 192.168.50.63 -m hostname -a <span class="string">&quot;name=t4&quot;</span></span><br></pre></td></tr></table></figure><h3 id="yum模块">yum模块</h3><p>软件包管理</p><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装tree</span></span><br><span class="line">ansible all -m yum -a <span class="string">&quot;name=tree&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">ansible all -m yum -a <span class="string">&#x27;name=tree state=absent&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="service模块">service模块</h3><p>服务管理</p><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动ntpdate服务</span></span><br><span class="line">ansible all -m service -a <span class="string">&quot;name=ntpdate state=started enabled=true&quot;</span></span><br></pre></td></tr></table></figure><h3 id="group模块">group模块</h3><p>用户组管理</p><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加系统组</span></span><br><span class="line">ansible all -m group -a <span class="string">&quot;name=gansible system=true&quot;</span></span><br></pre></td></tr></table></figure><h3 id="user模块">user模块</h3><p>用户管理</p><p><strong>选项</strong>:</p><ul><li><code>name</code>: 用户名</li><li><code>state</code>: present(新增)|absent(删除)</li><li><code>force</code>: 删除时是否删除家目录</li><li><code>system</code>: 是否系统用户</li><li><code>uid</code>: 指定UID</li><li><code>shell</code>: 指定shell</li><li><code>home</code>: 指定家目录</li></ul><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加系统用户</span></span><br><span class="line">ansible all -m user -a <span class="string">&quot;name=ccc system=true&quot;</span></span><br></pre></td></tr></table></figure><h2 id="YAML语法">YAML语法</h2><ul><li>数据序列化格式</li><li>基本结构:<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">key:</span> <span class="string">value</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">item1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">item2</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">item3</span></span><br></pre></td></tr></table></figure>例如: <code>&#123;name: jerry, age: 21&#125;</code></li></ul><h2 id="Playbook">Playbook</h2><h3 id="核心元素">核心元素</h3><ul><li>Tasks: 任务列表</li><li>Variables: 变量</li><li>Templates: 模板文件</li><li>Handlers: 条件触发任务</li><li>Roles: 角色</li></ul><h3 id="基础组件">基础组件</h3><ul><li><code>Hosts</code>: 目标主机</li><li><code>remote_user</code>: 执行用户</li><li><code>sudo_user</code>: sudo用户</li><li><code>tasks</code>: 任务列表</li></ul><h3 id="运行Playbook">运行Playbook</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法检查</span></span><br><span class="line">ansible-playbook --syntax-check playbook.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试运行</span></span><br><span class="line">ansible-playbook -C playbook.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际运行</span></span><br><span class="line">ansible-playbook playbook.yaml</span><br></pre></td></tr></table></figure><h3 id="示例">示例</h3><h4 id="1-添加用户和组">1. 添加用户和组</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">a</span> <span class="string">group</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">name=test</span> <span class="string">system=test</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">a</span> <span class="string">user</span></span><br><span class="line">      <span class="attr">user:</span> <span class="string">name=test</span> <span class="string">group=test</span> <span class="string">system=true</span></span><br></pre></td></tr></table></figure><h4 id="2-配置HTTP服务">2. 配置HTTP服务</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">hosts</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">yum:</span> <span class="string">name=httpd</span> <span class="string">state=latest</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">conf</span></span><br><span class="line">      <span class="attr">copy:</span> <span class="string">src=/root/httpd.conf</span> <span class="string">dest=/etc/httpd/conf/httpd.conf.bak</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">start</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=reloaded</span> <span class="string">enabled=true</span></span><br></pre></td></tr></table></figure><h2 id="更多模块">更多模块</h2><ul><li><code>synchronize</code>: 使用rsync同步文件</li><li><code>raw</code>: 直接执行命令(类似shell)</li></ul><h2 id="模块帮助">模块帮助</h2><pre><code class="language-bash"># 列出所有模块ansible-doc -l# 查看模块帮助ansible-doc -s MOD_NAME</code></pre>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ansible </tag>
            
            <tag> 简明教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ansible教程-概念</title>
      <link href="/2025/05/22/ansible/ansible%E6%95%99%E7%A8%8B-%E6%A6%82%E5%BF%B5/"/>
      <url>/2025/05/22/ansible/ansible%E6%95%99%E7%A8%8B-%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="Ansible-概念">Ansible 概念</h2><p>这些概念适用于 Ansible 的所有用途。在使用 Ansible 或阅读文档之前，您应该了解它们。</p><ul><li><p>[控制节点]</p></li><li><p>[被管理节点]</p></li><li><p>[清单]</p></li><li><p>[剧本]</p><ul><li><p>[剧集]</p><ul><li><p>[角色]</p></li><li><p>[任务]</p></li><li><p>[处理器]</p></li></ul></li></ul></li><li><p>[模块]</p></li><li><p>[插件]</p></li><li><p>[集合]</p></li></ul><h2 id="控制节点">[控制节点]</h2><p>运行 Ansible CLI 工具（<code>ansible-playbook</code>、<code>ansible</code>、<code>ansible-vault</code> 等）的机器。您可以使用任何满足软件要求的计算机作为控制节点——笔记本电脑、共享桌面和服务器都可以运行 Ansible。您也可以在称为<a href="https://docs.ansible.org.cn/ansible/latest/getting_started_ee/index.html#getting-started-ee-index">执行环境</a>的容器中运行 Ansible。</p><p>可以使用多个控制节点，但 Ansible 本身并不协调它们之间的工作，有关此类功能，请参见<code>AAP</code>。</p><h2 id="被管理节点">[被管理节点]</h2><p>也称为“主机”，这些是您旨在用 Ansible 管理的目标设备（服务器、网络设备或任何计算机）。</p><p>除非您使用<code>ansible-pull</code>，否则通常不会在被管理节点上安装 Ansible，但这很少见，也不是推荐的设置。</p><h2 id="清单">[清单]</h2><p>由一个或多个“清单源”提供的被管理节点列表。您的清单可以指定每个节点的特定信息，例如 IP 地址。它还用于分配组，这既允许在剧集中选择节点，也允许批量分配变量。</p><p>要了解有关清单的更多信息，请参阅<a href="https://docs.ansible.org.cn/ansible/latest/inventory_guide/intro_inventory.html#intro-inventory">使用清单</a>部分。有时，清单源文件也称为“主机文件”。</p><h2 id="剧本">[剧本]</h2><p>它们包含剧集（这是 Ansible 执行的基本单元）。这既是“执行概念”，也是我们用来描述<code>ansible-playbook</code>操作的文件的方式。</p><p>剧本是用 YAML 编写的，易于阅读、编写、共享和理解。要了解有关剧本的更多信息，请参阅<a href="https://docs.ansible.org.cn/ansible/latest/playbook_guide/playbooks_intro.html#about-playbooks">Ansible 剧本</a>。</p><h3 id="剧集">[剧集]</h3><p>Ansible 执行的主要上下文，此剧本对象将被管理节点（主机）映射到任务。剧集包含变量、角色和已排序的任务列表，并且可以重复运行。它基本上由对映射的主机和任务的隐式循环组成，并定义如何迭代它们。</p><h4 id="角色">[角色]</h4><p>可在剧集内部使用的可重用 Ansible 内容（任务、处理器、变量、插件、模板和文件）的有限分发。</p><p>要使用任何角色资源，必须将角色本身导入剧集。</p><h4 id="任务">[任务]</h4><p>应用于被管理主机的“操作”的定义。您可以使用<code>ansible</code>或<code>ansible-console</code>（两者都会创建一个虚拟剧集）一次执行单个任务。</p><h4 id="处理器">[处理器]</h4><p>任务的一种特殊形式，仅在之前的任务发出通知并且导致“已更改”状态时才执行。</p><h2 id="模块">[模块]</h2><p>Ansible 复制到并在每个被管理节点上执行（如有需要）的代码或二进制文件，以完成每个任务中定义的操作。</p><p>每个模块都有其特定的用途，从管理特定类型数据库上的用户到管理特定类型网络设备上的 VLAN 接口。</p><p>您可以使用任务调用单个模块，也可以在剧本中调用多个不同的模块。Ansible 模块分组在集合中。要了解 Ansible 包含多少集合，请参阅<a href="https://docs.ansible.org.cn/ansible/latest/collections/index.html#list-of-collections">集合索引</a>。</p><h2 id="插件">[插件]</h2><p>扩展 Ansible 核心功能的代码片段。插件可以控制您如何连接到被管理节点（连接插件）、操作数据（过滤器插件），甚至控制在控制台中显示的内容（回调插件）。</p><p>有关详细信息，请参阅<a href="https://docs.ansible.org.cn/ansible/latest/plugins/plugins.html#working-with-plugins">使用插件</a>。</p><h2 id="集合">[集合]</h2><p>Ansible 内容的分发格式，可以包含剧本、角色、模块和插件。您可以通过<a href="https://galaxy.ansible.com/">Ansible Galaxy</a>安装和使用集合。</p><p>要了解有关集合的更多信息，请参阅<a href="https://docs.ansible.org.cn/ansible/latest/collections_guide/index.html#collections">使用 Ansible 集合</a>。</p><p>集合资源可以彼此独立且离散地使用。</p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ansible </tag>
            
            <tag> 简明教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ansible教程-入门篇</title>
      <link href="/2025/05/22/ansible/ansible%E6%95%99%E7%A8%8B-%E5%85%A5%E9%97%A8%E7%AF%87/"/>
      <url>/2025/05/22/ansible/ansible%E6%95%99%E7%A8%8B-%E5%85%A5%E9%97%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="Ansible-简介">Ansible 简介</h2><p>Ansible 提供开源自动化，可降低复杂性并在任何地方运行。使用 Ansible 可以自动执行几乎任何任务。以下是 Ansible 的一些常见用例</p><ul><li><p>消除重复并简化工作流程</p></li><li><p>管理和维护系统配置</p></li><li><p>持续部署复杂的软件</p></li><li><p>执行零停机滚动更新</p></li></ul><p>Ansible 使用简单的、人类可读的脚本（称为剧本）来自动化您的任务。您在剧本中声明本地或远程系统的期望状态。Ansible 确保系统保持在该状态。</p><p>作为自动化技术，Ansible 围绕以下原则设计</p><p>无代理架构</p><p>通过避免在 IT 基础设施上安装额外软件来降低维护开销。</p><p>简单性</p><p>自动化剧本使用简单的 YAML 语法，代码就像文档一样易于阅读。Ansible 也是分散式的，使用 SSH 和现有的操作系统凭据来访问远程机器。</p><p>可扩展性和灵活性</p><p>通过模块化设计轻松快速地扩展您自动化的系统，该设计支持各种操作系统、云平台和网络设备。</p><p>幂等性和可预测性</p><p>当系统处于您的剧本描述的状态时，即使多次运行剧本，Ansible 也不会更改任何内容。</p><h2 id="使用-Ansible-开始自动化">使用 Ansible 开始自动化</h2><p>通过创建自动化项目、构建清单和创建“Hello World”剧本开始使用 Ansible。</p><ol><li><p>安装 Ansible。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install ansible</span><br></pre></td></tr></table></figure></li><li><p>在您的文件系统上创建一个项目文件夹。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ansible_quickstart &amp;&amp; cd ansible_quickstart</span><br></pre></td></tr></table></figure><p>使用单一目录结构可以更轻松地添加到源代码管理，以及重用和共享自动化内容。</p></li></ol><h2 id="构建清单">构建清单</h2><p>清单将受管节点组织在集中式文件中，这些文件为 Ansible 提供系统信息和网络位置。使用清单文件，Ansible 可以使用单个命令管理大量主机。</p><p>要完成以下步骤，您需要至少一个主机系统的 IP 地址或完全限定域名 (FQDN)。出于演示目的，主机可以在容器或虚拟机中本地运行。您还必须确保您的公共 SSH 密钥已添加到每个主机上的 <code>authorized_keys</code> 文件中。</p><p>继续 Ansible 入门并按如下步骤构建清单</p><ol><li><p>在您在 上一步中创建的 <code>ansible_quickstart</code> 目录中创建一个名为 <code>inventory.ini</code> 的文件。</p></li><li><p>向 <code>inventory.ini</code> 文件添加一个新的 <code>[myhosts]</code> 组，并指定每个主机系统的 IP 地址或完全限定域名 (FQDN)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[myhosts]</span><br><span class="line">192.0.2.50</span><br><span class="line">192.0.2.51</span><br><span class="line">192.0.2.52</span><br></pre></td></tr></table></figure></li><li><p>验证您的清单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-inventory -i inventory.ini --list</span><br></pre></td></tr></table></figure></li><li><p>Ping 清单中的 <code>myhosts</code> 组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible myhosts -m ping -i inventory.ini</span><br></pre></td></tr></table></figure><p>注意</p><p>如果控制节点和受管节点上的用户名不同，请使用 <code>ansible</code> 命令传递 <code>-u</code> 选项。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">192.0.2.50 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python3&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line">192.0.2.51 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python3&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line">192.0.2.52 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python3&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="INI-或-YAML-格式的清单">INI 或 YAML 格式的清单</h2><p>您可以使用 <code>INI</code> 文件或 <code>YAML</code> 创建清单。在大多数情况下，例如上一步中的示例，对于少量受管节点，<code>INI</code> 文件简单易读。</p><p>随着受管节点数量的增加，使用 <code>YAML</code> 格式创建清单变得更合理。例如，以下是 <code>inventory.ini</code> 的等效项，它声明受管节点的唯一名称并使用 <code>ansible_host</code> 字段</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">myhosts:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="attr">my_host_01:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.50</span></span><br><span class="line">    <span class="attr">my_host_02:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.51</span></span><br><span class="line">    <span class="attr">my_host_03:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.52</span></span><br></pre></td></tr></table></figure><h2 id="构建清单的技巧">构建清单的技巧</h2><ul><li><p>确保组名有意义且唯一。组名也区分大小写。</p></li><li><p>避免在组名中使用空格、连字符和前导数字（使用 <code>floor_19</code>，而不是 <code>19th_floor</code>）。</p></li><li><p>根据主机的**什么**、**哪里**和**何时**逻辑地将主机分组到您的清单中。</p><p>什么</p><p>根据拓扑结构对主机分组，例如：db、web、leaf、spine。</p><p>哪里</p><p>按地理位置对主机分组，例如：数据中心、区域、楼层、建筑物。</p><p>何时</p><p>按阶段对主机分组，例如：开发、测试、过渡、生产。</p></li></ul><h3 id="使用元组">使用元组</h3><p>使用以下语法创建一个元组来组织清单中的多个组</p><p>以下清单说明了数据中心的结构基础。此示例清单包含一个 <code>network</code> 元组，其中包括所有网络设备，以及一个 <code>datacenter</code> 元组，其中包括 <code>network</code> 组和所有 Web 服务器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">leafs:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="attr">leaf01:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.100</span></span><br><span class="line">    <span class="attr">leaf02:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.110</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spines:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="attr">spine01:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.120</span></span><br><span class="line">    <span class="attr">spine02:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.130</span></span><br><span class="line"></span><br><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">children:</span></span><br><span class="line">    <span class="attr">leafs:</span></span><br><span class="line">    <span class="attr">spines:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">webservers:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="attr">webserver01:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.140</span></span><br><span class="line">    <span class="attr">webserver02:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.150</span></span><br><span class="line"></span><br><span class="line"><span class="attr">datacenter:</span></span><br><span class="line">  <span class="attr">children:</span></span><br><span class="line">    <span class="attr">network:</span></span><br><span class="line">    <span class="attr">webservers:</span></span><br></pre></td></tr></table></figure><h3 id="创建变量">创建变量</h3><p>变量设置受管节点的值，例如 IP 地址、FQDN、操作系统和 SSH 用户，因此您无需在运行 Ansible 命令时传递它们。</p><p>变量可以应用于特定主机。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">webservers:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="attr">webserver01:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.140</span></span><br><span class="line">      <span class="attr">http_port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">webserver02:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.150</span></span><br><span class="line">      <span class="attr">http_port:</span> <span class="number">443</span></span><br></pre></td></tr></table></figure><p>变量也可以应用于组中的所有主机。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">webservers:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="attr">webserver01:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.140</span></span><br><span class="line">      <span class="attr">http_port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">webserver02:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.150</span></span><br><span class="line">      <span class="attr">http_port:</span> <span class="number">443</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">ansible_user:</span> <span class="string">my_server_user</span></span><br></pre></td></tr></table></figure><hr><h2 id="创建剧本">创建剧本</h2><p>剧本是 Ansible 用于部署和配置受管节点的自动化蓝图，采用 <code>YAML</code> 格式。</p><p>剧本</p><p>一系列定义 Ansible 执行操作顺序的剧目，自上而下，以实现总体目标。</p><p>剧目</p><p>一个有序的任务列表，映射到清单中的受管节点。</p><p>任务</p><p>对单个模块的引用，定义 Ansible 执行的操作。</p><p>模块</p><p>Ansible 在受管节点上运行的代码或二进制单元。Ansible 模块按集合分组，每个模块都有一个<a href="https://docs.ansible.org.cn/ansible/latest/reference_appendices/glossary.html#term-Fully-Qualified-Collection-Name-FQCN">完全限定的集合名称 (FQCN)</a>。</p><p>完成以下步骤以创建用于 ping 主机并打印“Hello world”消息的剧本</p><ol><li><p>在您之前创建的 <code>ansible_quickstart</code> 目录中创建一个名为 <code>playbook.yaml</code> 的文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">My</span> <span class="string">first</span> <span class="string">play</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">myhosts</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Ping</span> <span class="string">my</span> <span class="string">hosts</span></span><br><span class="line">     <span class="attr">ansible.builtin.ping:</span></span><br><span class="line"></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Print</span> <span class="string">message</span></span><br><span class="line">     <span class="attr">ansible.builtin.debug:</span></span><br><span class="line">       <span class="attr">msg:</span> <span class="string">Hello</span> <span class="string">world</span></span><br></pre></td></tr></table></figure></li><li><p>运行您的剧本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook -i inventory.ini playbook.yaml</span><br></pre></td></tr></table></figure></li></ol><p>Ansible 返回以下输出</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">PLAY [My first play] ****************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [Gathering Facts] **************************************************************************</span><br><span class="line">ok: [192.0.2.50]</span><br><span class="line">ok: [192.0.2.51]</span><br><span class="line">ok: [192.0.2.52]</span><br><span class="line"></span><br><span class="line">TASK [Ping my hosts] ****************************************************************************</span><br><span class="line">ok: [192.0.2.50]</span><br><span class="line">ok: [192.0.2.51]</span><br><span class="line">ok: [192.0.2.52]</span><br><span class="line"></span><br><span class="line">TASK [Print message] ****************************************************************************</span><br><span class="line">ok: [192.0.2.50] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;Hello world&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [192.0.2.51] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;Hello world&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [192.0.2.52] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;Hello world&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP **************************************************************************************</span><br><span class="line">192.0.2.50: ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br><span class="line">192.0.2.51: ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br><span class="line">192.0.2.52: ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure><p>在此输出中，您可以看到</p><ul><li><p>您为剧目和每个任务指定的名称。您应始终使用易于验证和排查剧本问题的描述性名称。</p></li><li><p>“收集事实”任务隐式运行。默认情况下，Ansible 会收集有关您的清单的信息，以便在剧本中使用。</p></li><li><p>每个任务的状态。每个任务的状态为 <code>ok</code>，表示它已成功运行。</p></li><li><p>剧目摘要，总结了每个主机上所有任务的结果。在此示例中，共有三个任务，因此 <code>ok=3</code> 表示每个任务都已成功运行。</p></li></ul><p>恭喜，您已开始使用 Ansible！</p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ansible </tag>
            
            <tag> 简明教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas cheat sheet</title>
      <link href="/2025/05/21/cheat-sheet/pandas-cheat-sheet/"/>
      <url>/2025/05/21/cheat-sheet/pandas-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="pandas">pandas:</h3><div class="row">    <embed src="/assets/pdf/pandas-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> data </category>
          
          <category> python </category>
          
          <category> pandas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cheat sheet </tag>
            
            <tag> python </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-framework cheat sheet</title>
      <link href="/2025/05/21/cheat-sheet/spring-framework-cheat-sheet/"/>
      <url>/2025/05/21/cheat-sheet/spring-framework-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="java">java:</h3><div class="row">    <embed src="/assets/pdf/spring-framework-4-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> 服务端 </category>
          
          <category> java </category>
          
          <category> spring-framework-4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> cheat sheet </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java fundamentals cheat sheet</title>
      <link href="/2025/05/21/java-fundamentals-cheat-sheet/"/>
      <url>/2025/05/21/java-fundamentals-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="java">java:</h3><div class="row">    <embed src="/assets/pdf/java-fundamentals-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> cheat sheet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>postgresql cheat sheet</title>
      <link href="/2025/05/20/cheat-sheet/postgresql-cheat-sheet/"/>
      <url>/2025/05/20/cheat-sheet/postgresql-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="postgresql">postgresql:</h3><div class="row">    <embed src="/assets/pdf/postgresql-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div><div class="row">    <embed src="/assets/pdf/postgresql-cheat-sheet2.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cheat sheet </tag>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django cheat sheet</title>
      <link href="/2025/05/20/cheat-sheet/django-cheat-sheet/"/>
      <url>/2025/05/20/cheat-sheet/django-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="django">django:</h3><div class="row">    <embed src="/assets/pdf/django-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> 服务端 </category>
          
          <category> python </category>
          
          <category> django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cheat sheet </tag>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python cheat sheet</title>
      <link href="/2025/05/20/cheat-sheet/python-cheat-sheet/"/>
      <url>/2025/05/20/cheat-sheet/python-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="python">python:</h3><div class="row">    <embed src="/assets/pdf/python-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cheat sheet </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql cheat sheet</title>
      <link href="/2025/05/20/cheat-sheet/mysql-cheat-sheet/"/>
      <url>/2025/05/20/cheat-sheet/mysql-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="mysql">mysql:</h3><div class="row">    <embed src="/assets/pdf/mysql-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cheat sheet </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim cheat sheet</title>
      <link href="/2025/05/20/cheat-sheet/vim-cheat-sheet/"/>
      <url>/2025/05/20/cheat-sheet/vim-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="python">python:</h3><div class="row">    <embed src="/assets/pdf/vim-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cheat sheet </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ansible cheat sheet</title>
      <link href="/2025/05/20/cheat-sheet/ansible-cheat-sheet/"/>
      <url>/2025/05/20/cheat-sheet/ansible-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="ansible-command">ansible command:</h3><div class="row">    <embed src="/assets/pdf/ansible-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="playbook">playbook:</h3><div class="row">    <embed src="/assets/pdf/ansible-playbook.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cheat sheet </tag>
            
            <tag> ansible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>curl cheat sheet</title>
      <link href="/2025/05/20/cheat-sheet/curl-cheat-sheet/"/>
      <url>/2025/05/20/cheat-sheet/curl-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="curl-command">curl command:</h3><div class="row">    <embed src="/assets/pdf/curl-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> curl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cheat sheet </tag>
            
            <tag> curl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker cheat sheet</title>
      <link href="/2025/05/20/cheat-sheet/docker-cheat-sheet/"/>
      <url>/2025/05/20/cheat-sheet/docker-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="docker">docker:</h3><p><img src="/assets/images/docker-cheat-sheet.webp" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cheat sheet </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux cheat sheet</title>
      <link href="/2025/05/15/cheat-sheet/Linux-cheat-sheet/"/>
      <url>/2025/05/15/cheat-sheet/Linux-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="linux">linux:</h3><p><img src="/assets/images/Linux-Commands_Cheat-Sheet.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> cheat sheet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git cheat sheet</title>
      <link href="/2025/05/14/git/git-cheat-sheet/"/>
      <url>/2025/05/14/git/git-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/images/gitcheatsheet.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim教程</title>
      <link href="/2025/05/12/vim%E6%95%99%E7%A8%8B/"/>
      <url>/2025/05/12/vim%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1>Vim 编辑器使用笔记整理</h1><h2 id="1-退出-Vim">1. 退出 Vim</h2><h3 id="命令行模式退出方式">命令行模式退出方式</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:wq</code></td><td>保存并退出</td></tr><tr><td><code>:q!</code></td><td>强制退出，不保存</td></tr><tr><td><code>:q</code></td><td>退出(未修改时)</td></tr><tr><td><code>:wq!</code></td><td>强制保存并退出</td></tr><tr><td><code>:w &lt;文件路径&gt;</code></td><td>另存为指定文件</td></tr><tr><td><code>:saveas 文件路径</code></td><td>另存为指定文件</td></tr><tr><td><code>:x</code></td><td>保存并退出(类似:wq)</td></tr></tbody></table><h3 id="普通模式退出方式">普通模式退出方式</h3><ul><li>输入 <code>Shift+zz</code> 即可保存退出</li></ul><h2 id="2-删除文本">2. 删除文本</h2><h3 id="普通模式删除命令">普通模式删除命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>x</code></td><td>删除游标所在字符</td></tr><tr><td><code>X</code></td><td>删除游标前一个字符</td></tr><tr><td><code>Delete</code></td><td>同 <code>x</code></td></tr><tr><td><code>dd</code></td><td>删除整行</td></tr><tr><td><code>dw</code></td><td>删除一个单词(不适用中文)</td></tr><tr><td><code>d$</code> 或 <code>D</code></td><td>删除至行尾</td></tr><tr><td><code>d^</code></td><td>删除至行首</td></tr><tr><td><code>dG</code></td><td>删除到文档结尾</td></tr><tr><td><code>d1G</code></td><td>删除至文档开头</td></tr><tr><td><code>:%d</code></td><td>清空整个文档内容（删除所有行）</td></tr><tr><td><code>:1,$d</code></td><td>同 <code>:%d</code>，删除从第一行到最后一行</td></tr><tr><td><code>ggdG</code></td><td>普通模式下清空文档的快捷方式（先跳转到首行，然后删除到末尾）</td></tr></tbody></table><p>注意：这些命令会立即生效且不可撤销，使用前请确保已保存重要内容</p><h3 id="数字前缀用法">数字前缀用法</h3><ul><li><code>2dd</code> 表示一次删除2行</li><li><code>3dw</code> 表示删除3个单词</li></ul><h2 id="3-重复执行命令">3. 重复执行命令</h2><ul><li>普通模式下 <code>.</code> (小数点)表示重复上一次命令</li><li>数字前缀：<code>10x</code> 删除10个连续字符</li></ul><h2 id="4-游标跳转">4. 游标跳转</h2><h3 id="行间跳转">行间跳转</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>nG</code></td><td>跳转到第n行(需先<code>:set nu</code>显示行号)</td></tr><tr><td><code>gg</code></td><td>跳转到第一行</td></tr><tr><td><code>G</code></td><td>跳转到最后一行</td></tr></tbody></table><h3 id="行内跳转">行内跳转</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>w</code></td><td>到下一个单词开头</td></tr><tr><td><code>e</code></td><td>到当前单词结尾</td></tr><tr><td><code>b</code></td><td>到前一个单词开头</td></tr><tr><td><code>ge</code></td><td>到前一个单词结尾</td></tr><tr><td><code>0</code> 或 <code>^</code></td><td>到行头</td></tr><tr><td><code>$</code></td><td>到行尾</td></tr><tr><td><code>f&lt;字母&gt;</code></td><td>向后搜索字母并跳转</td></tr><tr><td><code>F&lt;字母&gt;</code></td><td>向前搜索字母并跳转</td></tr><tr><td><code>t&lt;字母&gt;</code></td><td>向后搜索字母并跳转到匹配前</td></tr><tr><td><code>T&lt;字母&gt;</code></td><td>向前搜索字母并跳转到匹配后</td></tr></tbody></table><h2 id="5-复制粘贴和剪切">5. 复制粘贴和剪切</h2><h3 id="复制命令-yank">复制命令(yank)</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>yy</code></td><td>复制整行(3yy复制3行)</td></tr><tr><td><code>y^</code></td><td>复制至行首</td></tr><tr><td><code>y$</code></td><td>复制至行尾</td></tr><tr><td><code>yw</code></td><td>复制一个单词</td></tr><tr><td><code>yG</code></td><td>复制至文本末</td></tr><tr><td><code>y1G</code></td><td>复制至文本开头</td></tr></tbody></table><h3 id="粘贴命令">粘贴命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>p</code></td><td>粘贴至光标后</td></tr><tr><td><code>P</code></td><td>粘贴至光标前</td></tr></tbody></table><h2 id="6-替换和撤销">6. 替换和撤销</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>r+&lt;字母&gt;</code></td><td>替换游标所在字母</td></tr><tr><td><code>R</code></td><td>连续替换(按Esc结束)</td></tr><tr><td><code>cc</code></td><td>替换整行</td></tr><tr><td><code>cw</code></td><td>替换一个单词</td></tr><tr><td><code>C</code></td><td>替换至行末</td></tr><tr><td><code>~</code></td><td>反转字母大小写</td></tr><tr><td><code>u</code></td><td>撤销操作</td></tr><tr><td><code>U</code></td><td>撤销当前行所有修改</td></tr><tr><td><code>Ctrl+r</code></td><td>重做(redo)</td></tr></tbody></table><h2 id="7-缩进调整">7. 缩进调整</h2><h3 id="缩进命令">缩进命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>&gt;&gt;</code></td><td>整行向右缩进</td></tr><tr><td><code>&lt;&lt;</code></td><td>整行向左回退</td></tr><tr><td><code>:set shiftwidth=n</code></td><td>设置缩进字符数</td></tr></tbody></table><h3 id="文本位置调整">文本位置调整</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:ce</code></td><td>本行内容居中</td></tr><tr><td><code>:ri</code></td><td>本行文本靠右</td></tr><tr><td><code>:le</code></td><td>本行内容靠左</td></tr></tbody></table><h2 id="8-查找功能">8. 查找功能</h2><h3 id="基本查找">基本查找</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>/字符串</code></td><td>向下查找</td></tr><tr><td><code>?字符串</code></td><td>向上查找</td></tr><tr><td><code>n</code></td><td>继续查找</td></tr><tr><td><code>N</code></td><td>反向查找</td></tr></tbody></table><h3 id="高级查找">高级查找</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>*</code></td><td>向后查找当前单词</td></tr><tr><td><code>#</code></td><td>向前查找当前单词</td></tr><tr><td><code>g*</code></td><td>向后查找部分匹配单词</td></tr><tr><td><code>g#</code></td><td>向前查找部分匹配单词</td></tr></tbody></table><h2 id="9-多文件编辑">9. 多文件编辑</h2><h3 id="多文件操作">多文件操作</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:n</code></td><td>编辑下一个文件</td></tr><tr><td><code>:N</code></td><td>编辑上一个文件</td></tr><tr><td><code>:e 文件名</code></td><td>打开新文件</td></tr><tr><td><code>:e#</code></td><td>回到前一个文件</td></tr><tr><td><code>:ls</code></td><td>列出编辑过的文档</td></tr><tr><td><code>:b 文件名/编号</code></td><td>切换到指定文件</td></tr><tr><td><code>:bd 文件名/编号</code></td><td>从列表删除文件</td></tr><tr><td><code>:f</code></td><td>显示当前文件名</td></tr></tbody></table><h3 id="文件恢复">文件恢复</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim -r 文件名</span><br><span class="line">:ewcover 文件名</span><br></pre></td></tr></table></figure><h2 id="10-可视模式">10. 可视模式</h2><h3 id="进入可视模式">进入可视模式</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>v</code></td><td>字符选择模式</td></tr><tr><td><code>V</code></td><td>行选择模式</td></tr><tr><td><code>Ctrl+v</code></td><td>区域选择模式</td></tr></tbody></table><h3 id="可视模式操作">可视模式操作</h3><ul><li><code>d</code> 删除选中区域</li><li><code>y</code> 复制选中区域</li></ul><h2 id="11-视窗操作">11. 视窗操作</h2><h3 id="窗口分割">窗口分割</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:new</code></td><td>新建窗口</td></tr><tr><td><code>:sp 文件名</code></td><td>水平分割窗口</td></tr><tr><td><code>:vsp 文件名</code></td><td>垂直分割窗口</td></tr><tr><td><code>Ctrl+w s</code></td><td>水平分割当前窗口</td></tr><tr><td><code>Ctrl+w v</code></td><td>垂直分割当前窗口</td></tr></tbody></table><h3 id="窗口切换">窗口切换</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>Ctrl+w j/k/h/l</code></td><td>向下/上/左/右切换窗口</td></tr><tr><td><code>Ctrl+w q</code></td><td>关闭当前窗口</td></tr><tr><td><code>Ctrl+w o</code></td><td>只保留当前窗口</td></tr></tbody></table><h2 id="12-其他功能">12. 其他功能</h2><h3 id="文档加密">文档加密</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -x 文件名</span><br></pre></td></tr></table></figure><h3 id="执行外部命令">执行外部命令</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:!命令</span><br><span class="line">:<span class="keyword">w</span> 文件名  # 另存为</span><br></pre></td></tr></table></figure><h3 id="帮助系统">帮助系统</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:F1        # 打开帮助</span><br><span class="line">:h 主题    # 查看特定帮助</span><br><span class="line">:ver       # 显示版本</span><br></pre></td></tr></table></figure><h3 id="功能设定">功能设定</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">set</span> <span class="keyword">nu</span>    # 显示行号</span><br><span class="line">:<span class="keyword">set</span> ai    # 自动缩进</span><br><span class="line">:<span class="keyword">set</span> aw    # 自动保存</span><br><span class="line">:<span class="keyword">set</span> cin   # C语言风格缩进</span><br></pre></td></tr></table></figure><blockquote><p>提示：所有设置可通过修改 <code>~/.vimrc</code> 文件永久保存</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> devops </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracelBD基础</title>
      <link href="/2021/05/09/oracelBD%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/05/09/oracelBD%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1>OracleDB 笔记整理</h1><h2 id="1-SQL-分类">1. SQL 分类</h2><table><thead><tr><th>分类</th><th>说明</th><th>关键字</th></tr></thead><tbody><tr><td><strong>DML</strong> (Data Manipulation Language)</td><td>数据操作语言</td><td><code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>MERGE</code></td></tr><tr><td><strong>DDL</strong> (Data Definition Language)</td><td>数据定义语言</td><td><code>CREATE</code>, <code>ALTER</code>, <code>DROP</code>, <code>RENAME</code>, <code>TRUNCATE</code>, <code>COMMENT</code></td></tr><tr><td><strong>DCL</strong> (Data Control Language)</td><td>数据控制语言</td><td><code>GRANT</code>, <code>REVOKE</code></td></tr><tr><td><strong>事务</strong> (Transaction)</td><td>事务控制</td><td><code>COMMIT</code>, <code>ROLLBACK</code>, <code>SAVEPOINT</code></td></tr></tbody></table><h2 id="2-OracleDB-构成">2. OracleDB 构成</h2><h3 id="2-1-基本构成">2.1 基本构成</h3><p>OracleDB 由 <strong>Oracle实例(instance)</strong> 和 <strong>Database</strong> 构成：</p><ul><li><strong>实例(Instance)</strong> 由：<ul><li><strong>SGA(System Global Area)</strong>：内存区域</li><li><strong>Background Process</strong>：后台进程</li></ul></li><li><strong>Database</strong> 由：<ul><li>控制文件（制御ファイル）</li><li>REDO 文件（REDO ログ）</li><li>数据文件（データファイル）</li></ul></li></ul><h3 id="2-2-进程视角">2.2 进程视角</h3><p>除了实例中的 <strong>Background Process</strong>，还包括：</p><ul><li>用户进程</li><li>服务器进程</li><li>监听进程</li></ul><h3 id="2-3-工具列表">2.3 工具列表</h3><h4 id="安装和升级相关工具">安装和升级相关工具</h4><table><thead><tr><th>工具名</th><th>用途</th></tr></thead><tbody><tr><td>Oracle Universal Installer (OUI)</td><td>安装 Oracle 软件</td></tr><tr><td>Oracle Database Configuration Assistant (DBCA)</td><td>创建数据库</td></tr><tr><td>Oracle Database Upgrade Assistant (DBUA)</td><td>升级现有数据库到新版本</td></tr></tbody></table><h4 id="网络相关工具">网络相关工具</h4><table><thead><tr><th>工具名</th><th>用途</th></tr></thead><tbody><tr><td>Oracle Net Manager (netmgr)</td><td>配置 Oracle 网络</td></tr><tr><td>Oracle Net Configuration Assistant (netca)</td><td>配置 Oracle 网络</td></tr></tbody></table><h4 id="实例和数据库管理工具">实例和数据库管理工具</h4><table><thead><tr><th>工具名</th><th>用途</th></tr></thead><tbody><tr><td>Oracle Enterprise Manager (EM)</td><td>管理 Oracle DB</td></tr><tr><td>SQL*Plus</td><td>SQL 命令行工具</td></tr><tr><td>SQL Developer</td><td>图形化数据库管理工具</td></tr><tr><td>Recovery Manager (RMAN)</td><td>数据库备份、恢复、复原</td></tr><tr><td>Oracle Secure Backup</td><td>备份管理</td></tr><tr><td>Data Pump</td><td>数据库间高速数据传输</td></tr><tr><td>SQL*Loader</td><td>外部文件数据批量导入</td></tr></tbody></table><h2 id="3-安装">3. 安装</h2><h3 id="3-1-OUI-功能">3.1 OUI 功能</h3><ul><li>显示已安装的 Oracle 软件</li><li>安装新软件</li><li>删除软件</li><li>查看在线帮助</li><li>检查安装需求</li></ul><h3 id="3-2-系统要求">3.2 系统要求</h3><ul><li><strong>内存</strong>：1GB</li><li><strong>SWAP</strong>：1.5GB</li><li><strong>硬盘空间</strong>：<ul><li>最小 1GB</li><li>一般需要 6.1GB</li></ul></li></ul><h3 id="3-3-创建用户和组">3.3 创建用户和组</h3><ul><li><strong>软件所有者</strong>：Oracle 用户</li><li><strong>Oracle Inventory Group</strong>：用于管理 Oracle 软件</li><li><strong>DB 管理组</strong>：<ul><li><code>OSDBA</code>：数据库管理员组</li><li><code>OSOPER</code>：受限制的数据库管理员组</li></ul></li></ul><h3 id="3-4-环境变量">3.4 环境变量</h3><table><thead><tr><th>变量名</th><th>说明</th></tr></thead><tbody><tr><td><code>ORACLE_BASE</code></td><td>Oracle 主目录</td></tr><tr><td><code>ORACLE_HOME</code></td><td>Oracle 软件安装位置</td></tr><tr><td><code>ORACLE_SID</code></td><td>系统标识（实例名）</td></tr><tr><td><code>LD_LIBRARY_PATH</code></td><td>共享库路径（如 <code>$ORACLE_HOME/lib</code>）</td></tr></tbody></table><h3 id="3-5-安装脚本">3.5 安装脚本</h3><table><thead><tr><th>脚本名</th><th>用途</th></tr></thead><tbody><tr><td><code>orainstRoot.sh</code></td><td>生成 inventory pointer 文件</td></tr><tr><td><code>root.sh</code></td><td>生成 <code>oratab</code> 并设置环境变量 (<code>oraenv</code> 和 <code>coraenv</code>)，指定 <code>dbstart</code> 和 <code>dbshut</code> 脚本</td></tr></tbody></table><h3 id="3-6-创建数据库（DBCA）">3.6 创建数据库（DBCA）</h3><h4 id="3-6-1-指定-Global-DB-名">3.6.1 指定 Global DB 名</h4><p>格式：<code>database_name.domain_name</code></p><h4 id="3-6-2-Enterprise-Manager-选项">3.6.2 Enterprise Manager 选项</h4><ul><li><strong>Database Express</strong>：单数据库管理</li><li><strong>Cloud Control</strong>：集中管理多个数据库（需预先安装 Cloud Control）</li></ul><h4 id="3-6-3-存储类型">3.6.3 存储类型</h4><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>文件系统</td><td>使用操作系统文件</td></tr><tr><td>ASM (Automatic Storage Management)</td><td>文件存储在 ASM 磁盘组，需额外实例</td></tr></tbody></table><h4 id="3-6-4-数据库文件位置">3.6.4 数据库文件位置</h4><ul><li><strong>使用模板的文件位置</strong></li><li><strong>所有数据库文件共享文件夹</strong></li><li><strong>Oracle Managed Files</strong>：由 Oracle 直接管理文件</li></ul><h4 id="3-6-5-模板">3.6.5 模板</h4><p>模板包含以下信息：</p><ul><li>数据库选项</li><li>初始化参数</li><li>存储属性（数据文件、表空间、控制文件、REDO 日志属性）</li></ul><h5 id="模板分类">模板分类</h5><table><thead><tr><th>模板类型</th><th>说明</th></tr></thead><tbody><tr><td>通用事务处理（默认）</td><td>适用于 OLTP 场景</td></tr><tr><td>数据仓库 (Data Warehouse)</td><td>适用于复杂查询和大数据处理</td></tr><tr><td>自定义模板</td><td>用户自定义配置</td></tr></tbody></table><h5 id="模板形式">模板形式</h5><table><thead><tr><th>形式</th><th>说明</th></tr></thead><tbody><tr><td>Sheet Template</td><td>包含现有数据库结构和物理文件</td></tr><tr><td>Non-Sheet Template</td><td>仅包含数据库特性</td></tr></tbody></table><h2 id="4-EM-Express">4. EM Express</h2><h3 id="4-1-功能">4.1 功能</h3><ul><li>提供数据库管理功能（<strong>不包括启动/停止数据库</strong>）</li><li>如需启动/停止数据库，需使用 <strong>Oracle Enterprise Manager Cloud Control</strong></li></ul><h3 id="4-2-手动配置-EM-Express">4.2 手动配置 EM Express</h3><ol><li><strong>启动监听进程</strong></li><li><strong>初始化 <code>DISPATCHERS</code> 参数</strong>（设置 <code>PROTOCOL=TCP</code>）：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatchers<span class="operator">=</span>&quot;(PROTOCOL=TCP)(SERVICE=&lt;sid&gt;XDB)&quot;</span><br></pre></td></tr></table></figure></li><li><strong>设置端口</strong>（需 <code>SYSDBA</code> 权限）：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> DBMS_XDB_CONFIG.setHTTPSPORT(<span class="number">5500</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-3-使用-EM-Express">4.3 使用 EM Express</h3><h4 id="4-3-1-查询-EM-Express-端口">4.3.1 查询 EM Express 端口</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DBMS_XDB_CONFIG.getHTTPSPort <span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure><h4 id="4-3-2-权限分配">4.3.2 权限分配</h4><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td><code>EM_EXPRESS_BASIC</code></td><td>只读模式</td></tr><tr><td><code>EM_EXPRESS_ALL</code></td><td>完全权限</td></tr></tbody></table><h3 id="4-4-连接数据库">4.4 连接数据库</h3><h4 id="4-4-1-SQL-Plus-连接方式">4.4.1 SQL*Plus 连接方式</h4><ol><li>运行 <code>oraenv</code> 设置环境变量：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. oraenv</span><br></pre></td></tr></table></figure></li><li>启动 SQL*Plus（<code>/nolog</code> 表示不登录数据库）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlplus /nolog</span><br></pre></td></tr></table></figure></li><li>连接数据库：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span><span class="operator">/</span><span class="operator">&lt;</span>密码<span class="operator">&gt;</span> [<span class="keyword">AS</span> SYSDBA <span class="operator">|</span> <span class="keyword">AS</span> SYSOPER]</span><br></pre></td></tr></table></figure></li><li>其他功能：<ul><li>执行 SQL 脚本：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="operator">&lt;</span><span class="keyword">sql</span>文件名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li><li>执行操作系统命令：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOST <span class="operator">&lt;</span>命令<span class="operator">&gt;</span>  # 例如：HOST ls</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="4-4-2-SQL-Developer-连接方式">4.4.2 SQL Developer 连接方式</h4><ol><li>运行 <code>oraenv</code> 设置环境变量：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. oraenv</span><br></pre></td></tr></table></figure></li><li>启动 SQL Developer：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$ORACLE_HOME</span>/sqldeveloper</span><br><span class="line">sh sqldeveloper.sh</span><br></pre></td></tr></table></figure></li><li>功能：<ul><li><strong>普通模式</strong>：查看、创建、编辑、删除表、视图等对象</li><li><strong>DBA Navigator</strong>：连接 DBA 用户后可启动/停止数据库</li></ul></li></ol><h2 id="5-Oracle-网络构成">5. Oracle 网络构成</h2><h3 id="5-1-Oracle-Net-概述">5.1 Oracle Net 概述</h3><ul><li><strong>功能</strong>：提供网络服务</li><li><strong>安装方式</strong>：随 Oracle 数据库软件或客户端一同安装</li><li><strong>通信模式</strong>：<ul><li><strong>客户端-服务端模式</strong>：两端均需安装 Oracle Net</li><li><strong>客户端-Web 服务器-DB 服务器模式</strong>：客户端和 Web 服务器需安装 Oracle Net</li></ul></li></ul><h3 id="5-2-通信条件">5.2 通信条件</h3><table><thead><tr><th><strong>角色</strong></th><th><strong>要求</strong></th></tr></thead><tbody><tr><td><strong>DB 服务端</strong></td><td>1. 网络服务器在线<br>2. 已安装 Oracle DB<br>3. 支持 TCP/IP 协议<br>4. 监听进程已启动</td></tr><tr><td><strong>客户端</strong></td><td>1. 网络服务器在线<br>2. 已安装 Oracle 客户端<br>3. 支持 TCP/IP 协议</td></tr></tbody></table><h3 id="5-3-监听进程">5.3 监听进程</h3><ul><li><p><strong>自动安装</strong>：通过 OUI 初始化 DB 时，NetCA 会默认安装监听进程</p></li><li><p><strong>作用</strong>：处理客户端连接请求（连接建立后不再参与通信）</p></li><li><p><strong>关键命令</strong>：</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>lsnrctl start &lt;监听进程名&gt;</code></td><td>启动监听进程</td></tr><tr><td><code>lsnrctl stop &lt;监听进程名&gt;</code></td><td>停止监听进程</td></tr><tr><td><code>lsnrctl status &lt;监听进程名&gt;</code></td><td>查看状态</td></tr><tr><td><code>lsnrctl services &lt;监听进程名&gt;</code></td><td>查看支持的服务</td></tr><tr><td><code>LSNRCTL&gt; set current_listener &lt;名称&gt;</code></td><td>切换监听进程（需交互模式）</td></tr></tbody></table></li></ul><h3 id="5-4-客户端构成">5.4 客户端构成</h3><ul><li><strong>数据库连接示例</strong>：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> hr@(DESCRIPTION <span class="operator">=</span> </span><br><span class="line">  (ADDRESS <span class="operator">=</span> (PROTOCOL <span class="operator">=</span> TCP)(HOST <span class="operator">=</span> proj1<span class="operator">-</span>sv)(PORT <span class="operator">=</span> <span class="number">1521</span>))</span><br><span class="line">  (CONNECT_DATA <span class="operator">=</span> (SERVICE_NAME <span class="operator">=</span> sales.edifist.com)))</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-5-命名方法">5.5 命名方法</h3><table><thead><tr><th><strong>类型</strong></th><th><strong>存储位置</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>本地命名</strong></td><td>客户端 <code>tnsnames.ora</code></td><td>网络服务名映射存储在本地文件</td></tr><tr><td><strong>LDAP 基准</strong></td><td>LDAP 服务器</td><td>集中管理服务名映射</td></tr><tr><td><strong>简易连接命名</strong></td><td>无</td><td>直接使用 TCP/IP 连接字符串（如 <code>connect scott@host名/服务名</code>）</td></tr><tr><td><strong>外部命名</strong></td><td>第三方命名服务（如 NIS）</td><td>依赖非 Oracle 服务</td></tr></tbody></table><h4 id="本地命名配置方法">本地命名配置方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netca  <span class="comment"># 启动图形化配置工具</span></span><br></pre></td></tr></table></figure><h4 id="简易连接示例">简易连接示例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlplus <span class="operator">/</span>nolog</span><br><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">CONNECT</span> hr<span class="operator">/</span>hr<span class="variable">@oracle_sv</span><span class="operator">/</span>orcl.edifist.com</span><br></pre></td></tr></table></figure><hr><h2 id="6-数据库服务器架构概要">6. 数据库服务器架构概要</h2><h3 id="6-1-核心组件">6.1 核心组件</h3><ul><li><strong>Oracle 实例</strong>：内存结构（SGA） + 后台进程</li><li><strong>Oracle 数据库</strong>：物理文件集合</li></ul><h3 id="6-2-SGA-System-Global-Area-构成">6.2 SGA (System Global Area) 构成</h3><table><thead><tr><th><strong>组件</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td><strong>数据库缓存</strong></td><td>存储数据块（Buffer Cache）</td></tr><tr><td><strong>REDO 日志 Buffer</strong></td><td>记录数据变更历史</td></tr><tr><td><strong>共享池</strong></td><td>缓存 SQL/PLSQL 解析结果、执行计划、数据字典</td></tr><tr><td><strong>Large Pool</strong></td><td>可选，用于共享服务器模式、并行查询、RMAN 备份等</td></tr><tr><td><strong>Java Pool</strong></td><td>支持 Java 虚拟机（JVM）</td></tr><tr><td><strong>Stream Pool</strong></td><td>支持 Oracle Stream 数据复制</td></tr></tbody></table><h3 id="6-3-关键后台进程">6.3 关键后台进程</h3><table><thead><tr><th><strong>进程</strong></th><th><strong>名称</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td><strong>SMON</strong></td><td>System Monitor</td><td>实例恢复（如崩溃后自动修复）</td></tr><tr><td><strong>PMON</strong></td><td>Process Monitor</td><td>清理异常终止的用户进程资源</td></tr><tr><td><strong>DBWn</strong></td><td>Database Writer</td><td>将脏缓冲区写入数据文件</td></tr><tr><td><strong>CKPT</strong></td><td>Checkpoint</td><td>触发 DBWn 写入，更新控制文件（用于灾难恢复）</td></tr><tr><td><strong>LGWR</strong></td><td>Log Writer</td><td>将 REDO 日志缓冲区写入磁盘</td></tr><tr><td><strong>ARCn</strong></td><td>Archiver</td><td>归档 REDO 日志</td></tr><tr><td><strong>MMON</strong></td><td>Manageability Monitor</td><td>执行 AWR（自动工作负载仓库）相关任务</td></tr></tbody></table><h3 id="6-4-用户与服务器进程">6.4 用户与服务器进程</h3><ul><li><strong>用户进程</strong>：运行应用程序（如 SQL*Plus）</li><li><strong>服务器进程</strong>：处理用户提交的 SQL 查询</li></ul><h3 id="6-5-PGA-Program-Global-Area">6.5 PGA (Program Global Area)</h3><ul><li><strong>特点</strong>：非共享内存，仅限单个进程访问</li><li><strong>用途</strong>：存储 SQL 执行时的排序区、会话信息等</li></ul><hr><h2 id="7-实例启停">7. 实例启停</h2><h3 id="7-1-启动方法">7.1 启动方法</h3><ul><li>SQL*Plus（<code>STARTUP</code> 命令）</li><li>Windows 服务管理器</li><li>SQL Developer</li><li>Enterprise Manager Cloud Control</li></ul><h3 id="7-2-启动状态迁移">7.2 启动状态迁移</h3><table><thead><tr><th><strong>状态</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>NOMOUNT</strong></td><td>读取参数文件，分配 SGA，启动后台进程（控制文件未打开）</td></tr><tr><td><strong>MOUNT</strong></td><td>打开控制文件（获知数据文件/日志文件路径，但未打开文件）</td></tr><tr><td><strong>OPEN</strong></td><td>打开所有数据文件和 REDO 日志，数据库可用</td></tr></tbody></table><h3 id="7-3-权限要求">7.3 权限要求</h3><table><thead><tr><th><strong>权限</strong></th><th><strong>能力</strong></th></tr></thead><tbody><tr><td><strong>SYSDBA</strong></td><td>完全控制（包括启停实例、用户授权）</td></tr><tr><td><strong>SYSOPER</strong></td><td>仅限启停实例（无权管理用户对象）</td></tr></tbody></table><h4 id="连接示例">连接示例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> 用户名<span class="operator">/</span>密码 <span class="keyword">AS</span> &#123;SYSOPER <span class="operator">|</span> SYSDBA&#125;</span><br><span class="line">sqlplus <span class="operator">/</span>nolog</span><br><span class="line"><span class="keyword">CONNECT</span> sys <span class="keyword">AS</span> sysdba</span><br><span class="line">STARTUP</span><br></pre></td></tr></table></figure><h3 id="7-4-停止流程">7.4 停止流程</h3><ol><li><strong>关闭数据库</strong>（OPEN → CLOSED）<ul><li>执行 Checkpoint，写入数据文件和 REDO 日志</li><li>关闭数据文件和 REDO 日志（控制文件仍打开）</li></ul></li><li><strong>卸载数据库</strong>（CLOSED → DISMOUNT）<ul><li>实例与数据库分离</li></ul></li><li><strong>停止实例</strong>（DISMOUNT → SHUTDOWN）<ul><li>终止后台进程，释放 SGA 内存</li></ul></li></ol><h3 id="7-5-停止模式对比">7.5 停止模式对比</h3><table><thead><tr><th><strong>行为</strong></th><th>NORMAL</th><th>TRANSACTIONAL</th><th>IMMEDIATE</th><th>ABORT</th></tr></thead><tbody><tr><td>接受新连接</td><td>×</td><td>×</td><td>×</td><td>×</td></tr><tr><td>等待当前会话结束</td><td>✓</td><td>✓</td><td>×</td><td>×</td></tr><tr><td>等待当前事务结束</td><td>✓</td><td>✓</td><td>✓</td><td>×</td></tr><tr><td>执行 Checkpoint 后关闭</td><td>✓</td><td>✓</td><td>✓</td><td>×</td></tr></tbody></table><h3 id="7-6-初始化参数文件">7.6 初始化参数文件</h3><table><thead><tr><th><strong>类型</strong></th><th><strong>名称</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>静态</strong></td><td>PFILE（文本文件）</td><td>手动编辑，需重启生效</td></tr><tr><td><strong>动态</strong></td><td>SPFILE（二进制文件）</td><td>支持在线修改（<code>ALTER SYSTEM</code>），优先使用</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
          <category> oracleDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracleDB </tag>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPC</title>
      <link href="/2021/01/12/VPC/"/>
      <url>/2021/01/12/VPC/</url>
      
        <content type="html"><![CDATA[<ol><li><p>Security Group(SG):</p><ol><li>所有设定默认是拒绝，只可以设定许可规则，拒否ルールは指定できません。</li><li>特征是不单可以指定CIDR等IP,还可以指定SG</li><li>安全组是有状态的 — 如果您从实例发送一个请求，则无论入站安全组规则如何，都将允许该请求的响应流量流入。如果是为响应已允许的入站流量，则该响应可以出站，此时可忽略出站规则。セキュリティグループはステートフルです。</li></ol></li><li><p>Access Control List(ACL):</p><ol><li>VPC 自动带有可修改的默认网络 ACL。默认情况下，它允许所有入站和出站 IPv4 流量以及 IPv6 流量 (如果适用)。</li><li>可以创建自定义网络 ACL 并将其与子网相关联。默认情况下，每个自定义网络 ACL 都拒绝所有入站和出站流量，直至您添加规则。</li><li>VPC 中的每个子网都必须与一个网络 ACL 相关联。如果您没有明确地将子网与网络 ACL 相关联，则子网将自动与默认网络 ACL 关联。</li><li>可以将网络 ACL 与多个子网关联。但是，一个子网一次只能与一个网络 ACL 关联。当您将一个网络 ACL 与一个子网关联时，将删除之前的关联。</li><li>网络 ACL 包含规则的编号列表。我们按顺序评估（从编号最小的规则开始）规则，以判断是否允许流量进入或离开任何与网络 ACL 关联的子网。您可以使用的最高规则编号为 32766。我们建议您开始先以增量方式创建规则（例如，以 10 或 100 的增量增加），这样您可以在稍后需要时插入新的规则。</li><li>网络 ACL 有单独的入站和出站规则，每项规则都或是允许或是拒绝数据流。</li><li>网络 ACL 没有任何状态，这意味着对允许入站数据流的响应会随着出站数据流规则的变化而改变（反之亦然）。(ネットワーク ACL はステートレスです。許可されているインバウンドトラフィックに対する応答は、アウトバウンドトラフィックのルールに従います（その逆の場合も同様です）。)</li><li>ルール番号。ルールは、最も低い番号のルールから評価されます。ルールがトラフィックに一致すると、それと相反するより高い数値のルールの有無にかかわらず、すぐに適用されます。</li><li>タイプ。トラフィックのタイプ（SSH など）。また、すべてのトラフィックまたはカスタム範囲を指定することもできます。</li></ol></li></ol><p>セキュリティグループはステートフルです。（レスポンスでも明示する必要なしで許可。）<br>ACLはステートレスです。（レスポンスでも明示する必要ある。）</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> AWS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17.系统维护</title>
      <link href="/2020/11/17/linux/17-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4/"/>
      <url>/2020/11/17/linux/17-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<h1>从源代码安装软件笔记整理</h1><h2 id="1-安装C语言开源软件的三个主要步骤">1. 安装C语言开源软件的三个主要步骤</h2><ol><li>解压源代码</li><li>编译成二进制文件</li><li>将二进制文件安装到适当的文件夹</li></ol><h2 id="2-解压源代码">2. 解压源代码</h2><h3 id="常用解压命令">常用解压命令</h3><table><thead><tr><th>命令格式</th><th>说明</th></tr></thead><tbody><tr><td><code>gunzip [文件名]</code></td><td>解压.gz文件</td></tr><tr><td><code>gzip [option] [文件名]</code></td><td>压缩/解压文件</td></tr><tr><td><code>bunzip [文件名]</code></td><td>解压.bz2文件</td></tr><tr><td><code>bzip [option] [文件名]</code></td><td>压缩/解压文件</td></tr></tbody></table><h3 id="gzip-bzip-选项说明">gzip/bzip 选项说明</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-d</code></td><td>解压压缩文件</td></tr><tr><td><code>-c</code></td><td>解压压缩文件到标准输出</td></tr></tbody></table><h2 id="3-patch命令">3. patch命令</h2><p>用于应用补丁文件</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-d 文件夹</code></td><td>移动到指定文件夹后处理</td></tr><tr><td><code>-p</code></td><td>修正patch文件内的path: <br><code>-p0</code>: 不修正path <br><code>-p1</code>: 删除最初的’/’ <br><code>-p2</code>: 删除下一级文件夹</td></tr><tr><td><code>patch</code></td><td>应用补丁</td></tr><tr><td><code>-C</code></td><td>测试(不实际应用补丁)</td></tr><tr><td><code>-R</code></td><td>取消补丁，恢复到补丁前状态</td></tr></tbody></table><h2 id="4-生成Makefile">4. 生成Makefile</h2><p>运行config脚本根据环境配置config文件:</p><h3 id="config脚本主要选项">config脚本主要选项</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>--help</code></td><td>显示帮助说明</td></tr><tr><td><code>--prefix=文件夹</code></td><td>指定安装目标的top路径</td></tr></tbody></table><h2 id="5-编译和安装">5. 编译和安装</h2><h3 id="make命令">make命令</h3><p>根据当前文件夹内的Makefile编译源代码</p><p>基本格式：</p><pre><code class="language-bash">make [option] [目标]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16.网络</title>
      <link href="/2020/11/16/linux/16-%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/11/16/linux/16-%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="1-网络设备管理">1. 网络设备管理</h2><h3 id="1-1-网络接口命名规则">1.1 网络接口命名规则</h3><table><thead><tr><th>接口名称</th><th>说明</th></tr></thead><tbody><tr><td><code>eth0</code></td><td>第一个 Ethernet 接口</td></tr><tr><td><code>eth1</code></td><td>第二个 Ethernet 接口</td></tr><tr><td><code>ppp0</code></td><td>第一个 PPP 接口</td></tr><tr><td><code>lo</code></td><td>Loopback 接口</td></tr></tbody></table><h3 id="1-2-网络设备识别命令">1.2 网络设备识别命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep eth  <span class="comment"># 查看内核识别的网络设备</span></span><br></pre></td></tr></table></figure><h3 id="1-3-网络接口配置命令">1.3 网络接口配置命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig [-a] [IF名] [参数]</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-a</code></td><td>显示所有接口</td></tr><tr><td><code>IF名</code></td><td>指定接口名称</td></tr><tr><td><code>IP地址</code></td><td>设置 IP 地址</td></tr><tr><td><code>netmask</code></td><td>设置子网掩码</td></tr><tr><td><code>up</code></td><td>激活接口（等价于 <code>ifup</code>）</td></tr><tr><td><code>down</code></td><td>停止接口（等价于 <code>ifdown</code>）</td></tr></tbody></table><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.120.27 netmask 255.255.255.0 up</span><br></pre></td></tr></table></figure><h3 id="1-4-NIC-组合与虚拟网络接口">1.4 NIC 组合与虚拟网络接口</h3><ul><li><strong>NIC 组合</strong>：允许将多个物理以太网适配器分组为虚拟网络适配器，提高性能和容错能力。</li><li><strong>MAC 地址设置</strong>：在 “交换机独立” 模式下，团队会将 MAC 地址设置为出站流量。</li><li><strong>IP 别名</strong>：在同一个网卡上分配不同 IP 地址。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0:0 192.168.0.1 netmask 255.255.255.0 up</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-ARP-协议管理">2. ARP 协议管理</h2><h3 id="2-1-ARP-协议简介">2.1 ARP 协议简介</h3><p>ARP (Address Resolution Protocol) 用于将 IP 地址解析为 MAC 地址。</p><h3 id="2-2-ARP-命令">2.2 ARP 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp [option]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-a [host]</code></td><td>显示指定主机或全部 ARP 表</td></tr><tr><td><code>-f 文件名</code></td><td>从文件读取主机:MAC 对应表</td></tr><tr><td><code>-n</code></td><td>显示 IP 地址而非主机名</td></tr><tr><td><code>-d [host]</code></td><td>删除指定主机的 ARP 记录</td></tr><tr><td><code>-i [IF名]</code></td><td>指定接口</td></tr><tr><td><code>-s [host] [MAC地址]</code></td><td>添加主机和 MAC 地址的对应关系</td></tr></tbody></table><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp -s h001.example.com 00:01:02:03:04:05</span><br></pre></td></tr></table></figure><h3 id="2-3-ARP-监视工具">2.3 ARP 监视工具</h3><ul><li><code>arpwatch</code>：监视网络中的 ARP 活动。</li></ul><h2 id="3-网络管理命令">3. 网络管理命令</h2><h3 id="3-1-Ping-命令">3.1 Ping 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping [host名或IP] [option]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-n</code></td><td>不解析主机名，显示 IP 地址</td></tr><tr><td><code>-c 次数</code></td><td>发送指定次数的 ICMP 包</td></tr><tr><td><code>-i 间隔</code></td><td>按指定间隔发送 ICMP 包</td></tr></tbody></table><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 4 192.168.1.1</span><br></pre></td></tr></table></figure><h3 id="3-2-Traceroute-命令">3.2 Traceroute 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute [option] [host名或IP]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-i [IF]</code></td><td>指定接口</td></tr><tr><td><code>-n</code></td><td>显示 IP 地址而非主机名</td></tr></tbody></table><h3 id="3-3-Tcpdump-命令">3.3 Tcpdump 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump [option] [条件式]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-i IF名</code></td><td>指定监视的接口</td></tr><tr><td><code>-s 比特数</code></td><td>指定从包中提取的比特数</td></tr><tr><td><code>-X</code></td><td>显示十六进制和 ASCII 文本</td></tr><tr><td><code>-n</code></td><td>不解析 ARP 地址</td></tr><tr><td><code>-l</code></td><td>缓存标准输出</td></tr><tr><td><code>-t</code></td><td>不显示时间</td></tr><tr><td><code>-v</code></td><td>显示详细信息</td></tr></tbody></table><p><strong>条件式</strong>:</p><ul><li><code>port</code>：指定端口</li></ul><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nli eth0 port 53</span><br></pre></td></tr></table></figure><h3 id="3-4-Wireshark">3.4 Wireshark</h3><ul><li>图形化网络监视工具。</li></ul><h3 id="3-5-Netstat-命令">3.5 Netstat 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [option]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-a</code></td><td>显示所有 socket</td></tr><tr><td><code>-c</code></td><td>每秒刷新</td></tr><tr><td><code>-i</code></td><td>显示接口状态</td></tr><tr><td><code>-l</code></td><td>只显示监听状态的端口</td></tr><tr><td><code>-n</code></td><td>显示地址和端口</td></tr><tr><td><code>-p</code></td><td>显示 PID 和进程</td></tr><tr><td><code>-r</code></td><td>显示路由表</td></tr><tr><td><code>-t</code></td><td>显示 TCP 连接</td></tr><tr><td><code>-u</code></td><td>显示 UDP 连接</td></tr></tbody></table><h3 id="3-6-IP-命令">3.6 IP 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip [option] 操作对象 [命令] [设备]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-s</code></td><td>显示状态</td></tr><tr><td><code>-r</code></td><td>解析名称</td></tr></tbody></table><p><strong>操作对象</strong>:</p><ul><li><code>link</code>：接口详细信息</li><li><code>addr</code>：IP 地址</li><li><code>route</code>：路由表</li><li><code>neigh</code>：ARP 缓存</li></ul><p><strong>命令</strong>:</p><ul><li><code>show</code>：显示指定对象</li><li><code>add</code>：设置指定对象的参数</li></ul><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip <span class="built_in">link</span> show eth0</span><br></pre></td></tr></table></figure><h2 id="4-路由设置">4. 路由设置</h2><h3 id="4-1-Route-命令">4.1 Route 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route [option]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-n</code></td><td>不解析主机名</td></tr><tr><td><code>-F</code></td><td>显示内核路由表</td></tr><tr><td><code>-C</code></td><td>显示内核路由缓存</td></tr></tbody></table><p><strong>路由表项目</strong>:</p><ul><li><code>Destination</code>：目标网络或主机</li><li><code>Gateway</code>：网关</li><li><code>Genmask</code>：目标子网掩码</li><li><code>Flags</code>：路由状态（U:有效, H:目标主机, G:使用网关, !:无效）</li><li><code>Metric</code>：到达目标的距离</li><li><code>Ref</code>：路由引用数</li><li><code>Use</code>：路径引用次数</li><li><code>Iface</code>：使用的接口</li></ul><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">route add -net 192.168.100.0 netmask 255.255.255.0 gw 172.16.0.1</span><br><span class="line">route add default gw 192.168.0.50</span><br><span class="line">route del -net 192.168.100.0 netmask 255.255.255.0 gw 172.16.0.1</span><br></pre></td></tr></table></figure><h2 id="5-无线网络设置">5. 无线网络设置</h2><h3 id="5-1-无线规格与安全标准">5.1 无线规格与安全标准</h3><table><thead><tr><th>规格</th><th>频率</th><th>传送速度</th></tr></thead><tbody><tr><td>IEEE 802.11a</td><td>5.2GHz</td><td>54Mbps</td></tr><tr><td>IEEE 802.11b</td><td>2.4GHz</td><td>11Mbps</td></tr><tr><td>IEEE 802.11g</td><td>2.4GHz</td><td>54Mbps</td></tr><tr><td>IEEE 802.11n</td><td>2.4GHz/5GHz</td><td>600Mbps</td></tr><tr><td>IEEE 802.11ac</td><td>5GHz</td><td>433Mbps~7Gbps</td></tr></tbody></table><p><strong>安全标准</strong>:</p><ul><li><strong>WEP</strong>：使用 RC4 算法，存在漏洞。</li><li><strong>WPA</strong>：多种加密技术（TKIP, AES），用户认证由 IEEE 802.1x 等实现。WPA-AES 比 WPA-TKIP 更安全。</li></ul><h3 id="5-2-无线接口状态确认">5.2 无线接口状态确认</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iwconfig [wlanN] [essid ESSID] [key [s:]WEP key]</span><br></pre></td></tr></table></figure><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iwconfig wlan0 essid <span class="string">&quot;windsor&quot;</span></span><br><span class="line">iwconfig wlan0 key s:abc12345</span><br></pre></td></tr></table></figure><h3 id="5-3-获取无线接口信息">5.3 获取无线接口信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iwlist [无线IF] [参数]</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>scanning [essid ID]</code></td><td>显示可接入的热点列表</td></tr><tr><td><code>channel</code></td><td>显示可设置的频道</td></tr><tr><td><code>rate</code></td><td>显示传送速度</td></tr></tbody></table><h2 id="6-高级网络设置">6. 高级网络设置</h2><h3 id="6-1-网络相关文件">6.1 网络相关文件</h3><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td><code>/etc/hostname</code></td><td>记录主机名</td></tr><tr><td><code>/etc/hosts</code></td><td>记录主机名、别名和 IP 的对应关系</td></tr><tr><td><code>/etc/networks</code></td><td>记录网络和 IP 的对应关系</td></tr><tr><td><code>/etc/nsswitch.conf</code></td><td>规定信息查找顺序</td></tr><tr><td><code>/etc/resolv.conf</code></td><td>记录 DNS 服务器和域名</td></tr><tr><td><code>/etc/sysconfig/network</code></td><td>网络功能、主机名、默认网关等设置</td></tr><tr><td><code>/etc/sysconfig/network-scripts/</code></td><td>存放网络接口设置文件</td></tr><tr><td><code>/etc/network/interfaces</code></td><td>Debian 系统的网络接口设置文件</td></tr></tbody></table><h3 id="6-2-配置文件示例">6.2 配置文件示例</h3><p><strong>/etc/sysconfig/network-scripts/ifcfg-eth0</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth0</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=192.168.0.6</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">NETWORK=192.168.0.0</span><br><span class="line">BROADCAST=192.168.0.255</span><br><span class="line">ONBOOT=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p><strong>/etc/network/interfaces (Debian)</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line">allow-hotplug eth0</span><br><span class="line">iface eth0 inet static </span><br><span class="line">    address 192.168.0.6</span><br><span class="line">    netmask 255.255.255.0</span><br><span class="line">    gateway 192.168.0.1</span><br><span class="line">    dns-domain example.com</span><br><span class="line">    dns-nameservers 192.168.1.1</span><br></pre></td></tr></table></figure><h2 id="7-网络问题排查">7. 网络问题排查</h2><h3 id="7-1-排查步骤">7.1 排查步骤</h3><ol><li><p><strong>Ping 测试</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping 172.16.0.1</span><br><span class="line">ping h001.s16.la.net</span><br></pre></td></tr></table></figure><ul><li>如果 IP 能 Ping 通，但主机名失败，可能是 DNS 问题，检查 <code>/etc/resolv.conf</code>。</li></ul></li><li><p><strong>局域网连通但无法访问互联网</strong>：</p><ul><li>检查默认网关或路由表：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route</span><br></pre></td></tr></table></figure></li><li>如果没有默认路由，添加默认网关：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add default gw 172.16.0.1</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>网络连接不通</strong>：</p><ul><li>使用 <code>traceroute</code> 或 <code>tracepath</code> 查看路径：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute www.lpi.jp</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>网络接口问题</strong>：</p><ul><li>检查网卡状态：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure></li><li>如果只显示 <code>lo</code>，启动接口：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifup eth0</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">ifconfig eth0 up</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="7-2-需要确认的配置文件">7.2 需要确认的配置文件</h3><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td><code>/etc/resolv.conf</code></td><td>DNS 服务器设置</td></tr><tr><td><code>/etc/sysconfig/network-scripts/*</code></td><td>网络接口设置（RHEL/CentOS）</td></tr><tr><td><code>/etc/network/interfaces</code></td><td>网络接口设置（Debian）</td></tr><tr><td><code>/etc/hosts.allow</code>, <code>/etc/hosts.deny</code></td><td>连接控制</td></tr></tbody></table><hr><p><strong>补充说明</strong>：</p><ul><li><strong>IP 别名</strong>：允许在同一个网卡上分配多个 IP 地址，常用于服务器提供多种服务。</li><li><strong>ARP 缓存</strong>：存储 IP 地址与 MAC 地址的映射关系，可通过 <code>arp -d</code> 手动清除缓存。</li><li><strong>无线安全</strong>：建议使用 WPA2 或 WPA3 加密方式，避免使用不安全的 WEP。</li><li><strong>路由表</strong>：理解目标网络、网关、子网掩码和接口的关系，确保数据包正确转发。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15.高度的存储管理</title>
      <link href="/2020/11/15/linux/15-%E9%AB%98%E5%BA%A6%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
      <url>/2020/11/15/linux/15-%E9%AB%98%E5%BA%A6%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1>1. RAID (冗余磁盘阵列)</h1><p>RAID（Redundant Arrays of Inexpensive Disks）是一种将多个硬盘组合以提高性能或数据冗余的技术。</p><h2 id="Linux-上的-RAID">Linux 上的 RAID</h2><p>在 Linux 上应用 RAID，有软件 RAID 和硬件 RAID 之分。通常，硬件 RAID 会被视作 SCSI 设备。</p><h2 id="RAID-各个等级：">RAID 各个等级：</h2><ul><li><p><strong>RAID 0 (条带化)</strong></p><ul><li>多个硬盘组合成一个大磁盘，没有备份，提供较好的性能但没有容灾能力。</li><li>示例：三台 100GB 硬盘组成一个 300GB 的 RAID 0。</li></ul></li><li><p><strong>RAID 1 (镜像)</strong></p><ul><li>多台硬盘写入相同数据，提供冗余备份。</li><li>示例：三个 100GB 硬盘组成一个 100GB 的 RAID 1。</li></ul></li><li><p><strong>RAID 4</strong></p><ul><li>至少需要 3 台硬盘，其中一台用作备份分区。性能瓶颈在于备份分区。</li><li>示例：三个 100GB 硬盘组成一个 200GB 的 RAID 4。</li></ul></li><li><p><strong>RAID 5</strong></p><ul><li>使用分布式备份技术，性能较 RAID 4 好，且不需要专门的备份硬盘。</li><li>示例：三个 100GB 硬盘组成一个 200GB 的 RAID 5。</li></ul></li><li><p><strong>其他 RAID 等级：</strong></p><ul><li><strong>RAID LINEAR</strong>：类似 RAID 0。</li><li><strong>RAID 0+1 (RAID01)</strong>：RAID 0 组成的 RAID 1。</li><li><strong>RAID 10 (RAID+0)</strong>：RAID 1 组成的 RAID 0。</li><li><strong>RAID 6</strong>：比 RAID 5 多一台备份区。</li></ul></li></ul><h2 id="mdadm-命令控制-RAID-阵列"><code>mdadm</code> 命令控制 RAID 阵列</h2><p><code>mdadm [option] [设备名]</code></p><h3 id="常用选项：">常用选项：</h3><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-C</code>, <code>--create</code></td><td>创建 RAID 阵列并生成相关设备</td></tr><tr><td><code>-a</code></td><td>自动生成必要的设备文件</td></tr><tr><td><code>-c</code></td><td>指定 Chunk 大小</td></tr><tr><td><code>-l</code>, <code>--level</code></td><td>指定 RAID 级别</td></tr><tr><td><code>-n</code>, <code>--raid-devices</code></td><td>指定 RAID 阵列中的设备数量</td></tr><tr><td><code>-x</code>, <code>--spare-devices</code></td><td>指定备用设备数量</td></tr><tr><td><code>--manage</code></td><td>管理 RAID 阵列</td></tr><tr><td><code>-a</code>, <code>--add</code></td><td>添加设备</td></tr><tr><td><code>-r</code>, <code>--remove</code></td><td>删除设备</td></tr><tr><td><code>-f</code>, <code>--fail</code></td><td>标记设备为失效</td></tr><tr><td><code>--query</code></td><td>查询 RAID 状态</td></tr><tr><td><code>--detail</code></td><td>查看 RAID 详细状态</td></tr><tr><td><code>--stop</code></td><td>停止指定的 RAID 阵列</td></tr><tr><td><code>--stop --scan</code></td><td>停止所有 RAID 阵列</td></tr></tbody></table><hr><h1>2. LVM (逻辑卷管理)</h1><p>LVM 是 Linux 下的一种磁盘管理工具，可以灵活地管理硬盘、分区和逻辑卷。</p><h3 id="LVM-结构：">LVM 结构：</h3><ol><li><strong>PV (Physical Volume)</strong>：一个硬盘或一个分区作为物理空间。</li><li><strong>PE (Physical Extent)</strong>：PV 组成 PE。</li><li><strong>VG (Volume Group)</strong>：PE 组成 VG。</li><li><strong>LV (Logical Volume)</strong>：VG 内的 PE 分配为 LV。</li></ol><h3 id="创建-LVM：">创建 LVM：</h3><ol><li><p>准备 LVM 用的分区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sda</span><br><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure></li><li><p>初始化 PV：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pvcreate /dev/sda1 /dev/sdb1</span><br></pre></td></tr></table></figure></li><li><p>创建 VG：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vgcreate testvg /dev/sda1 /dev/sdb1</span><br></pre></td></tr></table></figure></li><li><p>创建 LV：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvcreate -L 1G -n lv01 testvg</span><br></pre></td></tr></table></figure></li><li><p>创建文件系统并挂载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mke2fs -j /dev/testvg/lv01</span><br><span class="line">mount /dev/testvg/lv01 /mnt</span><br></pre></td></tr></table></figure></li></ol><h3 id="管理-LVM：">管理 LVM：</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>pvdisplay</code></td><td>显示物理 PV 信息</td></tr><tr><td><code>pvscan</code></td><td>显示 PV 状态</td></tr><tr><td><code>pvmove</code></td><td>移动 PV 中的 PE</td></tr><tr><td><code>pvremove</code></td><td>删除 PV</td></tr><tr><td><code>vgextend</code></td><td>扩展 VG</td></tr><tr><td><code>vgreduce</code></td><td>缩小 VG</td></tr><tr><td><code>vgdisplay</code></td><td>显示 VG 详情</td></tr><tr><td><code>lvdisplay</code></td><td>显示 LV 详情</td></tr><tr><td><code>lvextend</code></td><td>扩展 LV</td></tr><tr><td><code>lvreduce</code></td><td>缩小 LV</td></tr><tr><td><code>lvremove</code></td><td>删除 LV</td></tr><tr><td><code>lvcreate -s</code></td><td>创建快照</td></tr></tbody></table><hr><h1>3. 访问记忆装置</h1><h3 id="设备文件说明：">设备文件说明：</h3><table><thead><tr><th>设备文件</th><th>说明</th></tr></thead><tbody><tr><td><code>/dev/hda</code></td><td>IDE 主硬盘</td></tr><tr><td><code>/dev/hdb</code></td><td>IDE 从硬盘</td></tr><tr><td><code>/dev/sda</code></td><td>第一个 SCSI/STAT/USB 硬盘</td></tr><tr><td><code>/dev/sdb</code></td><td>第二个 SCSI/STAT/USB 硬盘</td></tr><tr><td><code>/dev/sr0</code></td><td>第一个 SCSI/STAT/USB CD/DVD</td></tr><tr><td><code>/dev/st0</code></td><td>第一个 SCSI 磁带设备</td></tr></tbody></table><h3 id="硬盘管理：">硬盘管理：</h3><p>Linux 将 IDE 以外的硬盘识别为 SCSI 设备。硬盘的数据传送模式有 PIO（Programmed I/O）和 DMA（Direct Memory Access）模式。通常使用 DMA 模式。</p><h3 id="检查-DMA-模式：">检查 DMA 模式：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdparm -i /dev/sda</span><br></pre></td></tr></table></figure><h3 id="硬盘控制：">硬盘控制：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdparm -d1 /dev/sda  <span class="comment"># 启用 DMA 模式</span></span><br></pre></td></tr></table></figure><h3 id="使用-SCSI-STAT-USB：">使用 SCSI/STAT/USB：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdparm [option] [设备文件]</span><br></pre></td></tr></table></figure><hr><h1>4. iSCSI (Internet Small Computer System Interface)</h1><p>iSCSI 是基于 TCP/IP 的 SCSI 协议，可以使远程存储设备像本地设备一样使用。</p><h2 id="iSCSI-配置步骤：">iSCSI 配置步骤：</h2><ol><li><p>配置 <code>targets.conf</code> 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">iqn.2014.01.com.example.lpic:target0</span>&gt;</span></span><br><span class="line">   backing-store /dev/sdb2</span><br><span class="line">   initiator-address 192.168.11.2</span><br><span class="line">   initiator-address 192.168.11.4</span><br><span class="line">   incominguser centuser password</span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>启动 iSCSI target 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service tgtd start</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>tgtadm</code> 命令查看 target 状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tgtadm --mode target --op show</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>iscsiadm</code> 从 initiator 查询 target：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iscsiadm -m discovery -t sendtargets -p 192.168.11.3</span><br></pre></td></tr></table></figure></li><li><p>配置认证方式：<br>修改 <code>/etc/iscsi/iscid.conf</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node.session.auth.authmethod = CHAP</span><br><span class="line">node.session.auth.username = centuser</span><br><span class="line">node.session.auth.password = password</span><br></pre></td></tr></table></figure></li><li><p>登录 iSCSI：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iscsiadm -m node --login</span><br></pre></td></tr></table></figure><p>登录后，使用 <code>cat /proc/partitions</code> 查看 iSCSI 目标是否添加成功。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.设备和文件系统</title>
      <link href="/2020/11/14/linux/14-%E8%AE%BE%E5%A4%87%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/11/14/linux/14-%E8%AE%BE%E5%A4%87%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-文件系统基础">1. 文件系统基础</h2><h3 id="etc-fstab-文件格式解析">/etc/fstab 文件格式解析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设备/标签/UUID  挂载点  文件系统类型  挂载选项  dump标志  fsck顺序</span><br></pre></td></tr></table></figure><p><strong>字段说明：</strong></p><table><thead><tr><th>字段</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>1</td><td>设备标识</td><td>/dev/sda1, UUID=xxxx, LABEL=root</td></tr><tr><td>2</td><td>挂载路径</td><td>/, /home, /boot</td></tr><tr><td>3</td><td>文件系统类型</td><td>ext4, xfs, nfs</td></tr><tr><td>4</td><td>挂载选项</td><td>defaults, noatime</td></tr><tr><td>5</td><td>dump备份标志</td><td>0(不备份), 1(备份)</td></tr><tr><td>6</td><td>fsck检查顺序</td><td>0(不检查), 1(优先), 2(次级)</td></tr></tbody></table><h3 id="文件系统类型对比">文件系统类型对比</h3><table><thead><tr><th>类型</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>ext4</td><td>日志式, 最大16TB文件</td><td>通用Linux系统</td></tr><tr><td>XFS</td><td>高性能, 最大8EB文件</td><td>大文件处理</td></tr><tr><td>Btrfs</td><td>写时复制, 快照功能</td><td>高级存储需求</td></tr><tr><td>FAT32</td><td>兼容性好</td><td>U盘/移动设备</td></tr><tr><td>NTFS</td><td>Windows兼容</td><td>双系统共享分区</td></tr></tbody></table><h3 id="常用挂载选项">常用挂载选项</h3><table><thead><tr><th>选项</th><th>作用</th><th>性能影响</th></tr></thead><tbody><tr><td>async</td><td>异步写入</td><td>提升性能</td></tr><tr><td>noatime</td><td>不更新访问时间</td><td>显著提升</td></tr><tr><td>nodiratime</td><td>不更新目录访问时间</td><td>小幅提升</td></tr><tr><td>discard</td><td>TRIM支持(SSD)</td><td>延长SSD寿命</td></tr><tr><td>data=writeback</td><td>ext4日志模式</td><td>性能最佳</td></tr></tbody></table><p><strong>查看支持的文件系统：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/filesystems</span><br></pre></td></tr></table></figure><p><strong>查看已挂载文件系统：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/mtab   <span class="comment"># 或</span></span><br><span class="line"><span class="built_in">cat</span> /proc/mounts</span><br></pre></td></tr></table></figure><h2 id="2-挂载管理命令">2. 挂载管理命令</h2><h3 id="mount-命令详解">mount 命令详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [选项] [设备] [挂载点]</span><br></pre></td></tr></table></figure><p><strong>常用选项：</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-t</td><td>指定文件系统类型</td></tr><tr><td>-o</td><td>指定挂载选项(多选项用逗号分隔)</td></tr><tr><td>-a</td><td>挂载/etc/fstab中所有文件系统</td></tr><tr><td>–bind</td><td>目录绑定挂载</td></tr><tr><td>-l</td><td>显示标签</td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t ext4 -o noatime /dev/sdb1 /mnt/data</span><br></pre></td></tr></table></figure><h3 id="umount-命令">umount 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount [选项] [设备|挂载点]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>卸载所有文件系统</td></tr><tr><td>-t</td><td>按类型卸载</td></tr><tr><td>-l</td><td>延迟卸载(强制)</td></tr><tr><td>-f</td><td>强制卸载</td></tr></tbody></table><p><strong>强制卸载流程：</strong></p><ol><li><code>fuser -vm /mountpoint</code> 查看占用进程</li><li><code>kill -9 PID</code> 结束进程</li><li><code>umount -f /mountpoint</code></li></ol><h2 id="3-SWAP-管理">3. SWAP 管理</h2><h3 id="创建SWAP文件">创建SWAP文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建1GB交换文件</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/swapfile bs=1M count=1024</span><br><span class="line"><span class="built_in">chmod</span> 600 /swapfile</span><br><span class="line">mkswap /swapfile</span><br><span class="line">swapon /swapfile</span><br></pre></td></tr></table></figure><h3 id="SWAP管理命令">SWAP管理命令</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>swapon -a</code></td><td>启用所有swap</td></tr><tr><td><code>swapon -s</code></td><td>查看swap使用</td></tr><tr><td><code>swapoff -a</code></td><td>禁用所有swap</td></tr></tbody></table><p><strong>优化建议：</strong></p><ul><li>物理内存&lt;8GB时，SWAP=1.5倍内存</li><li>物理内存≥8GB时，SWAP=8GB</li></ul><h2 id="4-文件系统创建与维护">4. 文件系统创建与维护</h2><h3 id="创建工具对比">创建工具对比</h3><table><thead><tr><th>命令</th><th>对应文件系统</th><th>特点</th></tr></thead><tbody><tr><td>mkfs.ext4</td><td>ext4</td><td>默认日志模式</td></tr><tr><td>mkfs.xfs</td><td>XFS</td><td>高性能大文件</td></tr><tr><td>mkfs.btrfs</td><td>Btrfs</td><td>高级功能支持</td></tr></tbody></table><p><strong>ext4创建示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 -b 4096 -m 1 -L DATA /dev/sdb1</span><br></pre></td></tr></table></figure><p><strong>XFS创建示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.xfs -f -L BIGDATA /dev/sdc1</span><br></pre></td></tr></table></figure><h3 id="文件系统检查">文件系统检查</h3><p><strong>ext系列检查：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fsck -y /dev/sda1   <span class="comment"># 自动修复</span></span><br><span class="line">e2fsck -f /dev/sda1 <span class="comment"># 强制检查</span></span><br></pre></td></tr></table></figure><p><strong>XFS检查：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_repair /dev/sdb1</span><br></pre></td></tr></table></figure><p><strong>检查时机：</strong></p><ul><li>异常关机后</li><li>定期维护时(建议每6个月)</li><li>出现I/O错误时</li></ul><h2 id="5-高级文件系统特性">5. 高级文件系统特性</h2><h3 id="ext4-特性管理">ext4 特性管理</h3><p><strong>转换ext3→ext4：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tune2fs -O extent,uninit_bg,dir_index /dev/sda1</span><br><span class="line">fsck -pf /dev/sda1</span><br></pre></td></tr></table></figure><p><strong>调整参数：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tune2fs -c 30 -i 7d /dev/sda1  <span class="comment"># 每30次挂载或7天检查</span></span><br><span class="line">tune2fs -m 5 /dev/sda1         <span class="comment"># 保留5%空间</span></span><br></pre></td></tr></table></figure><h3 id="XFS-高级功能">XFS 高级功能</h3><p><strong>查看信息：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xfs_info /dev/sdb1</span><br><span class="line">xfs_admin -l /dev/sdb1</span><br></pre></td></tr></table></figure><p><strong>备份恢复：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xfsdump -l 0 -f /backup/root.xfsdump /dev/sda1</span><br><span class="line">xfsrestore -f /backup/root.xfsdump /mnt/restore</span><br></pre></td></tr></table></figure><h2 id="6-光盘与加密文件系统">6. 光盘与加密文件系统</h2><h3 id="光盘制作">光盘制作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建ISO</span></span><br><span class="line">mkisofs -JR -V <span class="string">&quot;BACKUP_2023&quot;</span> -o backup.iso /backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刻录光盘</span></span><br><span class="line">cdrecord -v dev=1,0,0 speed=24 backup.iso</span><br></pre></td></tr></table></figure><h3 id="加密文件系统">加密文件系统</h3><p><strong>LUKS加密：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cryptsetup luksFormat /dev/sdb1</span><br><span class="line">cryptsetup luksOpen /dev/sdb1 secret</span><br><span class="line">mkfs.ext4 /dev/mapper/secret</span><br><span class="line">mount /dev/mapper/secret /mnt/secure</span><br></pre></td></tr></table></figure><p><strong>关闭加密卷：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umount /mnt/secure</span><br><span class="line">cryptsetup luksClose secret</span><br></pre></td></tr></table></figure><h2 id="7-磁盘健康监控">7. 磁盘健康监控</h2><h3 id="S-M-A-R-T-监控">S.M.A.R.T. 监控</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">smartctl -a /dev/sda          <span class="comment"># 查看详细信息</span></span><br><span class="line">smartctl -H /dev/sda          <span class="comment"># 健康状态</span></span><br><span class="line">smartctl -t long /dev/sda     <span class="comment"># 启动长测试</span></span><br></pre></td></tr></table></figure><p><strong>关键监控指标：</strong></p><ul><li>Reallocated_Sector_Ct</li><li>Current_Pending_Sector</li><li>Temperature_Celsius</li></ul><h2 id="8-故障处理流程">8. 故障处理流程</h2><h3 id="文件系统修复步骤">文件系统修复步骤</h3><ol><li><p><strong>卸载文件系统</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount /dev/sda1</span><br></pre></td></tr></table></figure></li><li><p><strong>进入单用户模式</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init 1</span><br></pre></td></tr></table></figure></li><li><p><strong>执行检查修复</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsck -y /dev/sda1</span><br></pre></td></tr></table></figure></li><li><p><strong>严重损坏时</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">debugfs /dev/sda1</span><br><span class="line">&gt; lsdel      <span class="comment"># 查看已删除inode</span></span><br><span class="line">&gt; dump &lt;inode&gt; /tmp/recover_file</span><br></pre></td></tr></table></figure></li></ol><h3 id="应急恢复方案">应急恢复方案</h3><table><thead><tr><th>问题现象</th><th>解决方案</th></tr></thead><tbody><tr><td>无法挂载</td><td><code>fsck -y /dev/sdX</code></td></tr><tr><td>Superblock损坏</td><td><code>e2fsck -b 32768 /dev/sdX</code></td></tr><tr><td>只读文件系统</td><td><code>mount -o remount,rw /</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.系统启动</title>
      <link href="/2020/11/10/linux/13-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"/>
      <url>/2020/11/10/linux/13-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-系统启动流程">1. 系统启动流程</h2><h3 id="1-1-启动阶段详解">1.1 启动阶段详解</h3><table><thead><tr><th>阶段</th><th>组件</th><th>功能说明</th></tr></thead><tbody><tr><td>1</td><td>BIOS</td><td>- 硬件自检(POST)<br>- 读取CMOS设置<br>- 检测启动设备顺序<br>- 加载MBR中的BootLoader</td></tr><tr><td>2</td><td>MBR</td><td>- 512字节(启动代码+分区表)<br>- 包含第一阶段BootLoader<br>- 标识活动分区</td></tr><tr><td>3</td><td>BootLoader</td><td>- 阶段1: MBR中的初始代码<br>- 阶段1.5: 文件系统识别<br>- 阶段2: 加载内核(/boot/grub/)</td></tr><tr><td>4</td><td>内核</td><td>- 硬件检测与初始化<br>- 加载驱动模块<br>- 挂载根文件系统<br>- 启动init进程(PID=1)</td></tr><tr><td>5</td><td>init进程</td><td>- 根据/etc/inittab初始化系统<br>- 启动运行级别对应服务<br>- 生成所有后续进程</td></tr></tbody></table><h3 id="1-2-inittab-文件格式">1.2 inittab 文件格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id:runlevels:action:process</span><br></pre></td></tr></table></figure><h4 id="主要action类型">主要action类型</h4><table><thead><tr><th>action</th><th>说明</th></tr></thead><tbody><tr><td>boot</td><td>系统启动时执行，不等待完成</td></tr><tr><td>bootwait</td><td>系统启动时执行，等待完成</td></tr><tr><td>ctrlaltdel</td><td>捕获Ctrl+Alt+Del组合键</td></tr><tr><td>initdefault</td><td>设置默认运行级别</td></tr><tr><td>once</td><td>进入运行级别时执行一次</td></tr><tr><td>respawn</td><td>进程终止后自动重启</td></tr><tr><td>sysinit</td><td>系统初始化脚本</td></tr><tr><td>wait</td><td>进入运行级别时执行并等待</td></tr></tbody></table><h3 id="1-3-运行级别管理">1.3 运行级别管理</h3><h4 id="标准运行级别">标准运行级别</h4><table><thead><tr><th>级别</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>关机</td></tr><tr><td>1/S</td><td>单用户模式</td></tr><tr><td>2</td><td>多用户无NFS</td></tr><tr><td>3</td><td>完整多用户模式</td></tr><tr><td>4</td><td>自定义</td></tr><tr><td>5</td><td>图形界面</td></tr><tr><td>6</td><td>重启</td></tr></tbody></table><h4 id="服务管理脚本">服务管理脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/service [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>start</td><td>启动服务</td></tr><tr><td>stop</td><td>停止服务</td></tr><tr><td>restart</td><td>重启服务</td></tr><tr><td>reload</td><td>重载配置</td></tr><tr><td>status</td><td>查看状态</td></tr></tbody></table><h4 id="服务自启动管理">服务自启动管理</h4><p><strong>RedHat系(chkconfig):</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig [选项] 服务名 [on|off]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>–list</td><td>显示服务状态</td></tr><tr><td>–level</td><td>指定运行级别</td></tr><tr><td>–add</td><td>添加服务</td></tr><tr><td>–del</td><td>删除服务</td></tr></tbody></table><p><strong>Debian系(update-rc.d):</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-rc.d [选项] 服务名 [commands]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>模拟执行</td></tr><tr><td>-f</td><td>强制操作</td></tr><tr><td>remove</td><td>删除链接</td></tr></tbody></table><h3 id="1-4-Upstart-事件驱动">1.4 Upstart 事件驱动</h3><p><strong>主要命令:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initctl [<span class="built_in">command</span>] job</span><br></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>start</td><td>启动作业</td></tr><tr><td>stop</td><td>停止作业</td></tr><tr><td>restart</td><td>重启作业</td></tr><tr><td>status</td><td>查看状态</td></tr><tr><td>list</td><td>列出所有作业</td></tr></tbody></table><p><strong>配置文件位置:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init/*.conf</span><br></pre></td></tr></table></figure><h2 id="2-GRUB-引导加载器">2. GRUB 引导加载器</h2><h3 id="2-1-GRUB-Legacy-vs-GRUB2">2.1 GRUB Legacy vs GRUB2</h3><table><thead><tr><th>特性</th><th>GRUB Legacy</th><th>GRUB2</th></tr></thead><tbody><tr><td>版本</td><td>0.9x</td><td>1.9x</td></tr><tr><td>配置文件</td><td>menu.lst</td><td>grub.cfg</td></tr><tr><td>生成方式</td><td>直接编辑</td><td>update-grub</td></tr><tr><td>分区表示</td><td>(hd0,0)</td><td>hd0,msdos1</td></tr></tbody></table><h3 id="2-2-GRUB-Legacy-配置">2.2 GRUB Legacy 配置</h3><p><strong>/boot/grub/menu.lst 示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">timeout 5</span><br><span class="line">default 0</span><br><span class="line">title CentOS</span><br><span class="line">root (hd0,0)</span><br><span class="line">kernel /vmlinuz ro root=/dev/sda1</span><br><span class="line">initrd /initrd.img</span><br></pre></td></tr></table></figure><p><strong>常用命令:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grub&gt; root (hd0,0)     <span class="comment"># 设置根分区</span></span><br><span class="line">grub&gt; setup (hd0)      <span class="comment"># 安装到MBR</span></span><br><span class="line">grub&gt; <span class="built_in">cat</span> /grub/menu.lst <span class="comment"># 查看配置</span></span><br></pre></td></tr></table></figure><h3 id="2-3-GRUB2-配置">2.3 GRUB2 配置</h3><p><strong>/etc/default/grub 关键参数:</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>GRUB_DEFAULT</td><td>默认启动项</td></tr><tr><td>GRUB_TIMEOUT</td><td>菜单超时</td></tr><tr><td>GRUB_CMDLINE_LINUX</td><td>内核参数</td></tr></tbody></table><p><strong>生成配置:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-grub</span><br></pre></td></tr></table></figure><h3 id="2-4-内核启动参数">2.4 内核启动参数</h3><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>root=/dev/sda1</td><td>指定根分区</td></tr><tr><td>ro/rw</td><td>只读/读写挂载</td></tr><tr><td>init=/bin/bash</td><td>指定初始化程序</td></tr><tr><td>single</td><td>单用户模式</td></tr><tr><td>mem=1024M</td><td>限制内存大小</td></tr></tbody></table><p><strong>查看当前参数:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cmdline</span><br></pre></td></tr></table></figure><h2 id="3-其他引导加载器">3. 其他引导加载器</h2><h3 id="3-1-LILO-配置">3.1 LILO 配置</h3><p><strong>/etc/lilo.conf 示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boot=/dev/sda</span><br><span class="line">map=/boot/map</span><br><span class="line">default=linux</span><br><span class="line">image=/boot/vmlinuz</span><br><span class="line">label=linux</span><br><span class="line">root=/dev/sda1</span><br></pre></td></tr></table></figure><p><strong>应用配置:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lilo -v</span><br></pre></td></tr></table></figure><h3 id="3-2-SYSLINUX-系列">3.2 SYSLINUX 系列</h3><table><thead><tr><th>类型</th><th>文件系统</th><th>用途</th></tr></thead><tbody><tr><td>SYSLINUX</td><td>FAT</td><td>USB启动</td></tr><tr><td>ISOLINUX</td><td>ISO9660</td><td>光盘启动</td></tr><tr><td>EXTLINUX</td><td>ext2/3/4</td><td>硬盘启动</td></tr><tr><td>PXELINUX</td><td>网络</td><td>网络启动</td></tr></tbody></table><p><strong>PXE启动环境搭建:</strong></p><ol><li>安装必要服务:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install dhcp tftp-server syslinux</span><br></pre></td></tr></table></figure><ol start="2"><li>配置DHCP:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filename &quot;pxelinux.0&quot;;</span><br><span class="line">next-server 192.168.1.100;</span><br></pre></td></tr></table></figure><ol start="3"><li>准备TFTP目录:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/</span><br><span class="line"><span class="built_in">mkdir</span> /var/lib/tftpboot/pxelinux.cfg</span><br></pre></td></tr></table></figure><h2 id="4-系统恢复方法">4. 系统恢复方法</h2><h3 id="4-1-救援模式操作">4.1 救援模式操作</h3><ol><li>使用安装介质启动</li><li>进入救援模式</li><li>挂载原系统:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chroot</span> /mnt/sysimage</span><br></pre></td></tr></table></figure><ol start="4"><li>修复引导:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-install /dev/sda</span><br></pre></td></tr></table></figure><h3 id="4-2-常见修复场景">4.2 常见修复场景</h3><table><thead><tr><th>问题</th><th>解决方案</th></tr></thead><tbody><tr><td>MBR损坏</td><td><code>dd if=/usr/share/syslinux/mbr.bin of=/dev/sda</code></td></tr><tr><td>GRUB损坏</td><td><code>grub-install /dev/sda</code></td></tr><tr><td>文件系统错误</td><td><code>fsck -y /dev/sda1</code></td></tr><tr><td>密码重置</td><td><code>init=/bin/bash</code> 启动后修改密码</td></tr></tbody></table><h2 id="5-启动优化技巧">5. 启动优化技巧</h2><ol><li><strong>并行启动</strong>:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/init/rc-sysinit.conf</span><br><span class="line"><span class="comment"># 修改为:</span></span><br><span class="line"><span class="built_in">env</span> DEFAULT_RUNLEVEL=2</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>禁用不需要的服务</strong>:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list | grep 3:on</span><br><span class="line">chkconfig servicename off</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>使用readahead</strong>:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service readahead-early restart</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>SSD优化</strong>:<br>在/etc/fstab添加:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">noatime,discard</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.内核</title>
      <link href="/2020/11/08/linux/12-%E5%86%85%E6%A0%B8/"/>
      <url>/2020/11/08/linux/12-%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-内核版本管理">1. 内核版本管理</h2><h3 id="版本号说明">版本号说明</h3><ul><li><p><strong>2.X.Y 旧版本格式</strong>：</p><ul><li>X：偶数表示稳定版，奇数表示开发版</li><li>Y：修订版本号</li><li>后缀说明：<ul><li><code>-rcN</code>：Release Candidate（候选版本）</li><li><code>-gitN</code>：开发中的Git版本</li></ul></li></ul></li><li><p><strong>3.0+ 新版本分类</strong>：</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>Prepatch</td><td>稳定版前的测试版本</td></tr><tr><td>Mainline</td><td>包含新特性的主线开发版本</td></tr><tr><td>Stable</td><td>稳定版本</td></tr><tr><td>Longterm</td><td>长期支持版本(LTS)</td></tr></tbody></table></li></ul><h3 id="版本查询命令">版本查询命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> [选项]</span><br></pre></td></tr></table></figure><h4 id="常用选项">常用选项</h4><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>显示全部系统信息</td></tr><tr><td>-r</td><td>显示内核版本</td></tr><tr><td>-m</td><td>显示硬件架构</td></tr></tbody></table><h4 id="其他查询方式">其他查询方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看/proc版本信息</span></span><br><span class="line"><span class="built_in">cat</span> /proc/version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过Makefile查看</span></span><br><span class="line"><span class="built_in">head</span> -4 /usr/src/linux/Makefile</span><br></pre></td></tr></table></figure><h2 id="2-内核模块管理">2. 内核模块管理</h2><h3 id="核心命令对比">核心命令对比</h3><table><thead><tr><th>命令</th><th>功能说明</th><th>特点</th></tr></thead><tbody><tr><td>lsmod</td><td>显示已加载模块</td><td>读取/proc/modules</td></tr><tr><td>insmod</td><td>加载单个模块</td><td>不处理依赖关系</td></tr><tr><td>rmmod</td><td>卸载模块</td><td>需确保无依赖</td></tr><tr><td>modprobe</td><td>智能加载/卸载模块</td><td>自动处理依赖关系</td></tr><tr><td>depmod</td><td>生成模块依赖关系文件</td><td>创建modules.dep</td></tr></tbody></table><h3 id="命令详解">命令详解</h3><h4 id="lsmod-输出说明">lsmod 输出说明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Module                  Size  Used by    Dependent modules</span><br></pre></td></tr></table></figure><ul><li>显示模块名、大小、引用计数和被哪些模块使用</li></ul><h4 id="modinfo-模块信息">modinfo 模块信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modinfo [选项] 模块名</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>显示作者信息</td></tr><tr><td>-d</td><td>显示描述信息</td></tr><tr><td>-l</td><td>显示许可证信息</td></tr><tr><td>-n</td><td>显示模块文件路径</td></tr></tbody></table><h4 id="modprobe-高级用法">modprobe 高级用法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe [选项] 模块名</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>加载所有匹配模块</td></tr><tr><td>-c</td><td>显示当前配置</td></tr><tr><td>-l</td><td>列出所有可用模块</td></tr><tr><td>-r</td><td>递归卸载模块及依赖</td></tr><tr><td>-t 类型</td><td>仅操作指定类型模块</td></tr><tr><td>–show-depends</td><td>显示模块依赖关系</td></tr></tbody></table><h3 id="配置文件">配置文件</h3><ul><li><code>/etc/modprobe.conf</code>：模块别名和参数配置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias eth0 e1000</span><br><span class="line">options e1000 speed=1000 duplex=full</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-内核编译流程">3. 内核编译流程</h2><h3 id="编译步骤">编译步骤</h3><ol><li><strong>准备源代码</strong></li><li><strong>配置内核</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make oldconfig    <span class="comment"># 基于旧配置更新</span></span><br><span class="line">make menuconfig  <span class="comment"># 文本界面配置</span></span><br><span class="line">make xconfig     <span class="comment"># Qt图形界面配置</span></span><br><span class="line">make gconfig     <span class="comment"># GTK图形界面配置</span></span><br></pre></td></tr></table></figure></li><li><strong>编译内核</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make           <span class="comment"># 编译内核和模块</span></span><br><span class="line">make bzImage   <span class="comment"># 仅编译内核</span></span><br><span class="line">make modules   <span class="comment"># 仅编译模块</span></span><br></pre></td></tr></table></figure></li><li><strong>安装组件</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make modules_install  <span class="comment"># 安装模块到/lib/modules/</span></span><br><span class="line">make install          <span class="comment"># 自动安装内核</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="手动安装示例">手动安装示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制内核文件</span></span><br><span class="line"><span class="built_in">cp</span> <span class="built_in">arch</span>/x86/boot/bzImage /boot/vmlinuz-2.6.32</span><br><span class="line"><span class="built_in">cp</span> System.map /boot/System.map-2.6.32</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建链接</span></span><br><span class="line"><span class="built_in">ln</span> -s /boot/vmlinuz-2.6.32 /boot/vmlinuz</span><br><span class="line"><span class="built_in">ln</span> -s /boot/System.map-2.6.32 /boot/System.map</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成initramfs</span></span><br><span class="line">mkinitramfs -o /boot/initrd-2.6.32.img 2.6.32</span><br></pre></td></tr></table></figure><h3 id="其他make目标">其他make目标</h3><table><thead><tr><th>目标</th><th>说明</th></tr></thead><tbody><tr><td>clean</td><td>清除编译文件</td></tr><tr><td>mrproper</td><td>彻底清除(含配置)</td></tr><tr><td>rpm-pkg</td><td>生成RPM包</td></tr><tr><td>deb-pkg</td><td>生成Debian包</td></tr></tbody></table><h2 id="4-内核参数调优">4. 内核参数调优</h2><h3 id="proc-sys-关键参数">/proc/sys 关键参数</h3><table><thead><tr><th>路径</th><th>说明</th></tr></thead><tbody><tr><td>kernel/ctrl-alt-del</td><td>Ctrl+Alt+Del行为</td></tr><tr><td>kernel/shmall</td><td>共享内存页数上限</td></tr><tr><td>kernel/shmmax</td><td>共享内存段最大大小</td></tr><tr><td>net/ipv4/ip_forward</td><td>IP转发开关(1/0)</td></tr><tr><td>fs/file-max</td><td>系统最大文件句柄数</td></tr></tbody></table><h3 id="sysctl-工具">sysctl 工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl [选项] [参数=值]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>显示所有可用参数</td></tr><tr><td>-p</td><td>从/etc/sysctl.conf加载配置</td></tr><tr><td>-w</td><td>临时修改参数</td></tr></tbody></table><h3 id="initramfs-管理">initramfs 管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建initramfs</span></span><br><span class="line">mkinitramfs -o initrd.img 3.16.0-4-amd64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压分析</span></span><br><span class="line"><span class="built_in">mkdir</span> initrd &amp;&amp; <span class="built_in">cd</span> initrd</span><br><span class="line">zcat ../initrd.img | cpio -<span class="built_in">id</span></span><br></pre></td></tr></table></figure><h2 id="5-内核调试与设备管理">5. 内核调试与设备管理</h2><h3 id="proc-关键文件">/proc 关键文件</h3><table><thead><tr><th>文件</th><th>内容说明</th></tr></thead><tbody><tr><td>/proc/cpuinfo</td><td>CPU详细信息</td></tr><tr><td>/proc/meminfo</td><td>内存使用情况</td></tr><tr><td>/proc/modules</td><td>已加载模块列表</td></tr><tr><td>/proc/partitions</td><td>分区信息</td></tr></tbody></table><h3 id="硬件信息工具">硬件信息工具</h3><h4 id="lspci">lspci</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci [选项]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-vv</td><td>超详细输出</td></tr><tr><td>-t</td><td>树状显示设备层级</td></tr></tbody></table><h4 id="lsusb">lsusb</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsusb [选项]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-v</td><td>详细输出设备描述符</td></tr><tr><td>-t</td><td>树状显示USB设备拓扑</td></tr></tbody></table><h3 id="udev-设备管理">udev 设备管理</h3><h4 id="规则文件示例">规则文件示例</h4><p><code>/etc/udev/rules.d/70-persistent-net.rules</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, </span><br><span class="line">ATTR&#123;address&#125;==&quot;08:00:27:aa:11:3c&quot;, NAME=&quot;eth0&quot;</span><br></pre></td></tr></table></figure><h4 id="udevadm-工具">udevadm 工具</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udevadm info [选项]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>显示父设备属性</td></tr><tr><td>-n</td><td>指定设备节点路径</td></tr></tbody></table><h4 id="实时监控">实时监控</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udevadm monitor</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.性能测定</title>
      <link href="/2020/11/07/linux/11-%E6%80%A7%E8%83%BD%E6%B5%8B%E5%AE%9A/"/>
      <url>/2020/11/07/linux/11-%E6%80%A7%E8%83%BD%E6%B5%8B%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="1-top-命令-实时进程监控">1. top 命令 - 实时进程监控</h2><h3 id="基本用法">基本用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [选项]</span><br></pre></td></tr></table></figure><h3 id="常用选项">常用选项</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>批处理模式（非交互式）</td></tr><tr><td>-d 秒</td><td>设置刷新间隔时间</td></tr><tr><td>-n 次数</td><td>指定刷新次数后退出</td></tr><tr><td>-u 用户</td><td>只显示指定用户的进程</td></tr><tr><td>-p PID</td><td>只监控指定PID的进程</td></tr></tbody></table><h3 id="显示字段说明">显示字段说明</h3><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>PID</td><td>进程ID</td></tr><tr><td>PPID</td><td>父进程ID</td></tr><tr><td>USER</td><td>进程所有者</td></tr><tr><td>RUSER</td><td>实际用户名</td></tr><tr><td>UID</td><td>用户ID</td></tr><tr><td>GROUP</td><td>所属组</td></tr><tr><td>PR</td><td>优先级</td></tr><tr><td>NI</td><td>nice值</td></tr><tr><td>VIRT</td><td>虚拟内存使用量(KB)</td></tr><tr><td>RES</td><td>物理内存使用量(KB)</td></tr><tr><td>SHR</td><td>共享内存大小(KB)</td></tr><tr><td>S</td><td>进程状态</td></tr><tr><td>TTY</td><td>关联终端</td></tr><tr><td>%CPU</td><td>CPU使用率</td></tr><tr><td>%MEM</td><td>内存使用率</td></tr><tr><td>TIME+</td><td>CPU占用时间累计</td></tr><tr><td>COMMAND</td><td>执行的命令</td></tr></tbody></table><h3 id="交互式操作">交互式操作</h3><table><thead><tr><th>按键</th><th>功能说明</th></tr></thead><tbody><tr><td>空格/Enter</td><td>立即刷新</td></tr><tr><td>f</td><td>选择显示字段</td></tr><tr><td>o</td><td>修改排序字段</td></tr><tr><td>l</td><td>切换负载显示</td></tr><tr><td>m</td><td>切换内存显示</td></tr><tr><td>u</td><td>筛选用户进程</td></tr><tr><td>t</td><td>切换CPU状态显示</td></tr><tr><td>P</td><td>按CPU%排序</td></tr><tr><td>M</td><td>按内存%排序</td></tr><tr><td>N</td><td>按PID排序</td></tr><tr><td>T</td><td>按运行时间排序</td></tr><tr><td>W</td><td>保存当前配置</td></tr><tr><td>k</td><td>结束进程</td></tr><tr><td>h/?</td><td>帮助信息</td></tr><tr><td>q</td><td>退出程序</td></tr><tr><td>A</td><td>切换显示模式</td></tr><tr><td>d/s</td><td>修改刷新间隔</td></tr><tr><td>&lt;/&gt;</td><td>切换排序顺序</td></tr></tbody></table><h2 id="2-vmstat-系统资源监控">2. vmstat - 系统资源监控</h2><h3 id="基本用法-2">基本用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmstat [刷新间隔(秒)] [刷新次数]</span><br></pre></td></tr></table></figure><h3 id="输出字段说明">输出字段说明</h3><table><thead><tr><th>类别</th><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>procs</td><td>r</td><td>运行队列中的进程数（若持续超过CPU核心数表示CPU瓶颈）</td></tr><tr><td></td><td>b</td><td>等待I/O的进程数</td></tr><tr><td>memory</td><td>swpd</td><td>使用的swap空间大小</td></tr><tr><td></td><td>free</td><td>空闲内存</td></tr><tr><td></td><td>buff</td><td>用作buffer的内存</td></tr><tr><td></td><td>cache</td><td>用作cache的内存</td></tr><tr><td>swap</td><td>si</td><td>每秒从swap读入内存量</td></tr><tr><td></td><td>so</td><td>每秒从内存写入swap量</td></tr><tr><td>io</td><td>bi</td><td>块设备每秒接收的块数</td></tr><tr><td></td><td>bo</td><td>块设备每秒发送的块数</td></tr><tr><td>system</td><td>in</td><td>每秒中断数</td></tr><tr><td></td><td>cs</td><td>每秒上下文切换数</td></tr><tr><td>cpu</td><td>us</td><td>用户空间CPU时间占比</td></tr><tr><td></td><td>sy</td><td>内核空间CPU时间占比</td></tr><tr><td></td><td>id</td><td>CPU空闲时间占比</td></tr><tr><td></td><td>wa</td><td>I/O等待时间占比</td></tr><tr><td></td><td>st</td><td>虚拟机偷取时间占比</td></tr></tbody></table><h2 id="3-iostat-I-O监控">3. iostat - I/O监控</h2><h3 id="基本用法-3">基本用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat [选项] [间隔秒数] [次数]</span><br></pre></td></tr></table></figure><h3 id="常用选项-2">常用选项</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>只显示CPU统计</td></tr><tr><td>-d</td><td>只显示磁盘统计</td></tr><tr><td>-k</td><td>以KB为单位显示</td></tr><tr><td>-t</td><td>显示时间戳</td></tr></tbody></table><h3 id="CPU统计字段">CPU统计字段</h3><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>%user</td><td>用户进程CPU占比</td></tr><tr><td>%nice</td><td>调整优先级进程的CPU占比</td></tr><tr><td>%system</td><td>内核CPU占比</td></tr><tr><td>%iowait</td><td>I/O等待占比</td></tr><tr><td>%steal</td><td>虚拟机占用占比</td></tr><tr><td>%idle</td><td>空闲占比</td></tr></tbody></table><h3 id="磁盘统计字段">磁盘统计字段</h3><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>tps</td><td>每秒I/O请求数</td></tr><tr><td>Blk_read/s</td><td>每秒读取块数</td></tr><tr><td>Blk_wrtn/s</td><td>每秒写入块数</td></tr><tr><td>Blk_read</td><td>总读取块数</td></tr><tr><td>Blk_wrtn</td><td>总写入块数</td></tr></tbody></table><h2 id="4-sar-系统活动报告">4. sar - 系统活动报告</h2><h3 id="基本用法-4">基本用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar [选项] [-s 开始时间] [-e 结束时间] [-f 日志文件] [间隔] [次数]</span><br></pre></td></tr></table></figure><h3 id="常用选项-3">常用选项</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-A</td><td>显示所有报告</td></tr><tr><td>-b</td><td>I/O和传输速率统计</td></tr><tr><td>-c</td><td>进程创建统计</td></tr><tr><td>-f 文件</td><td>指定日志文件</td></tr><tr><td>-n DEV</td><td>网络设备统计</td></tr><tr><td>-n EDEV</td><td>网络错误统计</td></tr><tr><td>-r</td><td>内存和swap统计</td></tr><tr><td>-u</td><td>CPU利用率</td></tr><tr><td>-P ALL</td><td>每个CPU核心统计</td></tr><tr><td>-R</td><td>内存统计</td></tr><tr><td>-W</td><td>swap统计</td></tr></tbody></table><h3 id="详细字段说明">详细字段说明</h3><h4 id="sar-b-I-O统计">sar -b (I/O统计)</h4><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>tps</td><td>每秒I/O请求数</td></tr><tr><td>rtps</td><td>每秒读请求数</td></tr><tr><td>wtps</td><td>每秒写请求数</td></tr><tr><td>bread/s</td><td>每秒读取块数</td></tr><tr><td>bwrtn/s</td><td>每秒写入块数</td></tr></tbody></table><h4 id="sar-n-DEV-网络统计">sar -n DEV (网络统计)</h4><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>IFACE</td><td>网络接口名</td></tr><tr><td>rxpck/s</td><td>每秒接收包数</td></tr><tr><td>txpck/s</td><td>每秒发送包数</td></tr><tr><td>rxkB/s</td><td>每秒接收KB数</td></tr><tr><td>txkB/s</td><td>每秒发送KB数</td></tr></tbody></table><h4 id="sar-r-内存统计">sar -r (内存统计)</h4><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>kbmemfree</td><td>空闲内存(KB)</td></tr><tr><td>kbmemused</td><td>已用内存(KB)</td></tr><tr><td>%memused</td><td>内存使用率</td></tr><tr><td>kbbuffers</td><td>buffer使用量(KB)</td></tr><tr><td>kbcached</td><td>cache使用量(KB)</td></tr></tbody></table><h2 id="5-系统负载命令">5. 系统负载命令</h2><h3 id="uptime">uptime</h3><p>显示：</p><ol><li>系统运行时间</li><li>登录用户数</li><li>1/5/15分钟平均负载</li></ol><h3 id="w-命令">w 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w [选项] [用户名]</span><br></pre></td></tr></table></figure><h4 id="选项">选项</h4><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-h</td><td>不显示标题</td></tr><tr><td>-s</td><td>精简格式(不显示登录时间/JCPU/PCPU)</td></tr></tbody></table><h4 id="输出字段">输出字段</h4><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>USER</td><td>用户名</td></tr><tr><td>TTY</td><td>终端名</td></tr><tr><td>FROM</td><td>远程主机</td></tr><tr><td>LOGIN@</td><td>登录时间</td></tr><tr><td>IDLE</td><td>空闲时间</td></tr><tr><td>JCPU</td><td>该终端所有进程CPU时间</td></tr><tr><td>PCPU</td><td>当前进程CPU时间</td></tr><tr><td>WHAT</td><td>正在执行的命令</td></tr></tbody></table><h2 id="6-进程监控">6. 进程监控</h2><h3 id="ps-命令">ps 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [选项]</span><br></pre></td></tr></table></figure><h4 id="常用选项-4">常用选项</h4><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>a</td><td>显示所有进程</td></tr><tr><td>e</td><td>显示环境变量</td></tr><tr><td>x</td><td>包括无终端进程</td></tr><tr><td>u</td><td>显示用户信息</td></tr><tr><td>r</td><td>只显示运行中进程</td></tr><tr><td>l</td><td>长格式显示</td></tr><tr><td>U 用户</td><td>筛选指定用户</td></tr><tr><td>-C 命令</td><td>筛选指定命令</td></tr><tr><td>-e</td><td>显示所有进程</td></tr><tr><td>-f</td><td>完整格式显示</td></tr><tr><td>-l</td><td>长格式显示</td></tr><tr><td>-p PID</td><td>筛选指定PID</td></tr><tr><td>-t tty</td><td>筛选指定终端</td></tr></tbody></table><h4 id="显示字段">显示字段</h4><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>USER</td><td>用户名</td></tr><tr><td>PID</td><td>进程ID</td></tr><tr><td>PPID</td><td>父进程ID</td></tr><tr><td>%CPU</td><td>CPU使用率</td></tr><tr><td>%MEM</td><td>内存使用率</td></tr><tr><td>VSZ</td><td>虚拟内存大小</td></tr><tr><td>RSS</td><td>物理内存大小</td></tr><tr><td>TTY</td><td>关联终端</td></tr><tr><td>STAT</td><td>进程状态</td></tr><tr><td>START</td><td>启动时间</td></tr><tr><td>TIME</td><td>CPU占用时间</td></tr><tr><td>COMMAND</td><td>执行的命令</td></tr></tbody></table><h3 id="其他进程工具">其他进程工具</h3><ul><li><code>pstree</code>：以树状显示进程关系</li><li><code>lsof</code>：列出打开的文件</li></ul><h2 id="7-内存监控">7. 内存监控</h2><h3 id="free-命令">free 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free [选项]</span><br></pre></td></tr></table></figure><h4 id="选项-2">选项</h4><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>以字节显示</td></tr><tr><td>-k</td><td>以KB显示(默认)</td></tr><tr><td>-m</td><td>以MB显示</td></tr><tr><td>-t</td><td>显示总计行</td></tr><tr><td>-o</td><td>不显示buffer行</td></tr><tr><td>-s 秒</td><td>持续监控间隔</td></tr></tbody></table><h4 id="输出字段-2">输出字段</h4><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>total</td><td>总内存量</td></tr><tr><td>used</td><td>已用量(含buffer/cache)</td></tr><tr><td>free</td><td>空闲量(含buffer/cache)</td></tr><tr><td>shared</td><td>共享内存</td></tr><tr><td>buffers</td><td>buffer缓存</td></tr><tr><td>cached</td><td>page cache</td></tr><tr><td>-/+ buffers/cache</td><td>实际内存使用</td></tr><tr><td>used</td><td>不含buffer/cache的用量</td></tr><tr><td>free</td><td>含buffer/cache的空闲量</td></tr></tbody></table><h2 id="8-磁盘与网络监控">8. 磁盘与网络监控</h2><h3 id="df-命令">df 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> [选项] [目录]</span><br></pre></td></tr></table></figure><h4 id="选项-3">选项</h4><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>显示所有文件系统</td></tr><tr><td>-h</td><td>人性化显示(1024进制)</td></tr><tr><td>-H</td><td>人性化显示(1000进制)</td></tr><tr><td>-i</td><td>显示inode信息</td></tr><tr><td>-l</td><td>只显示本地文件系统</td></tr><tr><td>-m</td><td>以MB为单位显示</td></tr></tbody></table><h3 id="网络测试工具">网络测试工具</h3><ul><li><code>netserver</code>：启动测试服务(监听12865端口)</li><li><code>netperf</code>：网络性能测试客户端</li></ul><h2 id="9-高级监控系统">9. 高级监控系统</h2><h3 id="collectd">collectd</h3><p>监控项目包括：</p><ul><li>CPU使用率</li><li>系统温度和风扇状态</li><li>进程状态</li><li>网络流量和延迟</li><li>Web服务器状态(APACHE/Nginx)</li><li>DNS服务器状态</li><li>数据库状态</li><li>SWAP使用情况</li><li>用户登录情况</li></ul><h3 id="Nagios">Nagios</h3><p>功能特点：</p><ul><li>网络服务监控</li><li>系统资源监控</li><li>基于Web的监控界面</li><li>邮件/SMS告警通知</li><li>自定义事件处理</li><li>日志自动轮转</li><li>支持分层主机结构</li></ul><h3 id="可视化工具">可视化工具</h3><ul><li><strong>MRTG</strong>：网络流量可视化</li><li><strong>Cacti</strong>：MRTG的增强替代品，提供更丰富的监控功能</li></ul><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.安全</title>
      <link href="/2020/06/24/linux/10-%E5%AE%89%E5%85%A8/"/>
      <url>/2020/06/24/linux/10-%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1>守护进程管理与系统安全笔记整理</h1><h2 id="守护进程管理">守护进程管理</h2><h3 id="Super-Server-超级服务器">Super Server (超级服务器)</h3><ul><li><strong>作用</strong>：代替其他服务监视服务请求，建立连接后转交给实际服务处理</li><li><strong>优势</strong>：降低系统负载，不需要为每个服务都启动独立进程</li></ul><h3 id="inetd-Internet-Daemon">inetd (Internet Daemon)</h3><ul><li>传统的超级服务器守护进程</li><li>配置文件：<code>/etc/inetd.conf</code></li></ul><h4 id="inetd-conf-字段说明">inetd.conf 字段说明</h4><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>service_name</td><td><code>/etc/services</code>中定义的服务名</td></tr><tr><td>socket_type</td><td>socket类型(TCP=stream, UDP=dgram)</td></tr><tr><td>protocol</td><td>协议类型(通常TCP/UDP)</td></tr><tr><td>flags</td><td>请求处理方式(wait=等待处理完成, nowait=立即处理下一个)</td></tr><tr><td>user</td><td>执行用户</td></tr><tr><td>program</td><td>程序绝对路径</td></tr><tr><td>args</td><td>转发参数</td></tr></tbody></table><h4 id="重启inetd">重启inetd</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP inetd的PID</span><br><span class="line">killall -HUP inetd</span><br><span class="line">/etc/init.d/inetd restart</span><br></pre></td></tr></table></figure><h3 id="TCP-Wrapper">TCP Wrapper</h3><ul><li>访问控制机制，检查顺序：<ol><li>先查<code>/etc/hosts.allow</code> → 匹配则允许</li><li>再查<code>/etc/hosts.deny</code> → 匹配则拒绝</li><li>都不匹配则允许</li></ol></li></ul><h4 id="通配符说明">通配符说明</h4><table><thead><tr><th>通配符</th><th>说明</th></tr></thead><tbody><tr><td>ALL</td><td>所有服务和主机</td></tr><tr><td>A EXCEPT B</td><td>除B以外的A</td></tr><tr><td>LOCAL</td><td>本地主机(不含.)</td></tr><tr><td>PARANOID</td><td>主机名与DNS解析IP不一致的情况</td></tr></tbody></table><h4 id="示例配置">示例配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in.telnetd: .lpic.jp  # 允许lpic.jp域访问telnet</span><br><span class="line">ALL: 192.168.2.      # 允许192.168.2.x网段所有服务</span><br></pre></td></tr></table></figure><h3 id="xinetd-扩展的inetd">xinetd (扩展的inetd)</h3><ul><li>更安全的超级服务器，支持分服务配置</li><li>主配置文件：<code>/etc/xinetd.conf</code></li><li>服务配置文件：<code>/etc/xinetd.d/</code></li></ul><h4 id="xinetd-conf-主要参数">xinetd.conf 主要参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">default</span><br><span class="line">&#123;</span><br><span class="line">    instance = 60               <span class="comment"># 最大守护进程数</span></span><br><span class="line">    log_type = SYSLOG authpriv  <span class="comment"># 日志类型</span></span><br><span class="line">    log_on_success = HOST PID   <span class="comment"># 成功日志内容</span></span><br><span class="line">    log_on_failure = HOST       <span class="comment"># 失败日志内容</span></span><br><span class="line">    cps = 25 30                 <span class="comment"># 每秒最大连接数(超限后暂停30秒)</span></span><br><span class="line">&#125;</span><br><span class="line">includedir /etc/xinetd.d        <span class="comment"># 包含服务配置目录</span></span><br></pre></td></tr></table></figure><h4 id="服务配置示例-telnet">服务配置示例(telnet)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">service telnet</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">disable</span> = no</span><br><span class="line">    socket_type = stream</span><br><span class="line">    <span class="built_in">wait</span> = no</span><br><span class="line">    user = root</span><br><span class="line">    server = /usr/sbin/in.telnetd</span><br><span class="line">    log_on_failure += USERID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重启xinetd">重启xinetd</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/xinetd restart</span><br></pre></td></tr></table></figure><h2 id="端口安全">端口安全</h2><h3 id="检查开放端口">检查开放端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netstat -atun       <span class="comment"># 显示所有TCP/UDP端口</span></span><br><span class="line">lsof -i -n          <span class="comment"># 查看网络连接</span></span><br><span class="line">lsof -i :22         <span class="comment"># 查看指定端口</span></span><br><span class="line">lsof -c ssh         <span class="comment"># 查看指定进程</span></span><br></pre></td></tr></table></figure><h3 id="nmap-扫描">nmap 扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap 目标主机       <span class="comment"># 扫描主机开放端口</span></span><br></pre></td></tr></table></figure><h3 id="查找特殊权限文件">查找特殊权限文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u+s -<span class="built_in">ls</span>   <span class="comment"># 查找SUID文件</span></span><br><span class="line">find / -perm -g+s -<span class="built_in">ls</span>   <span class="comment"># 查找SGID文件</span></span><br><span class="line">find / -perm -o+t -<span class="built_in">ls</span>   <span class="comment"># 查找sticky bit文件</span></span><br></pre></td></tr></table></figure><h2 id="用户安全">用户安全</h2><h3 id="密码有效期设置-chage">密码有效期设置(chage)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chage [选项] 用户名</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-l</td><td>显示有效期</td></tr><tr><td>-m 天数</td><td>密码最小使用天数</td></tr><tr><td>-M 天数</td><td>密码最大有效期</td></tr><tr><td>-d 日期</td><td>最后修改日期</td></tr><tr><td>-W 天数</td><td>密码过期前警告天数</td></tr><tr><td>-I 天数</td><td>密码过期后锁定前天数</td></tr><tr><td>-E 日期</td><td>账号失效日期</td></tr></tbody></table><h3 id="禁止登录方法">禁止登录方法</h3><ol><li>创建<code>/etc/nologin</code>文件：禁止所有非root用户登录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> /etc/nologin</span><br></pre></td></tr></table></figure></li><li>修改用户shell：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -s /sbin/nologin 用户名  <span class="comment"># 禁止指定用户登录</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="su-sudo">su/sudo</h3><h4 id="su-切换用户">su (切换用户)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su - 用户名   <span class="comment"># 完全切换(加载环境变量)</span></span><br><span class="line">su 用户名     <span class="comment"># 部分切换(保留当前环境)</span></span><br></pre></td></tr></table></figure><h4 id="sudo-超级用户权限">sudo (超级用户权限)</h4><ul><li>配置文件：<code>/etc/sudoers</code> (使用<code>visudo</code>编辑)</li><li>示例配置：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许student用户执行shutdown</span></span><br><span class="line">student ALL=(ALL) /sbin/shutdown</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许wheel组成员执行所有命令且不输密码</span></span><br><span class="line">%wheel ALL=(ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure></li></ul><h3 id="资源限制-ulimit">资源限制(ulimit)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> [选项] [限制值]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>显示所有限制</td></tr><tr><td>-c size</td><td>核心文件大小</td></tr><tr><td>-f size</td><td>最大文件大小</td></tr><tr><td>-n num</td><td>打开文件数限制</td></tr><tr><td>-u num</td><td>用户最大进程数</td></tr><tr><td>-v size</td><td>最大虚拟内存</td></tr></tbody></table><h2 id="OpenSSH-安全">OpenSSH 安全</h2><h3 id="SSH密钥文件">SSH密钥文件</h3><table><thead><tr><th>文件名</th><th>说明</th></tr></thead><tbody><tr><td>ssh_host_key</td><td>SSH1私钥</td></tr><tr><td>ssh_host_dsa_key</td><td>SSH2 DSA私钥</td></tr><tr><td>ssh_host_rsa_key</td><td>SSH2 RSA私钥</td></tr><tr><td>*.pub</td><td>对应公钥</td></tr></tbody></table><h3 id="sshd配置-etc-ssh-sshd-config">sshd配置(/etc/ssh/sshd_config)</h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>Port</td><td>SSH端口(默认22)</td></tr><tr><td>Protocol</td><td>SSH版本(1,2)</td></tr><tr><td>HostKey</td><td>私钥文件路径</td></tr><tr><td>PermitRootLogin</td><td>是否允许root登录</td></tr><tr><td>RSAAuthentication</td><td>是否启用SSH1公钥认证</td></tr><tr><td>PubkeyAuthentication</td><td>是否启用SSH2公钥认证</td></tr><tr><td>AuthorizedKeysFile</td><td>授权公钥文件路径</td></tr><tr><td>PermitEmptyPasswords</td><td>是否允许空密码</td></tr><tr><td>PasswordAuthentication</td><td>是否启用密码认证</td></tr><tr><td>X11Forwarding</td><td>是否允许X11转发</td></tr></tbody></table><h3 id="SSH密钥认证流程">SSH密钥认证流程</h3><ol><li>客户端生成密钥对：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa   <span class="comment"># 生成RSA密钥对</span></span><br></pre></td></tr></table></figure></li><li>上传公钥到服务器：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id 用户名@服务器</span><br></pre></td></tr></table></figure></li><li>服务器端公钥存储在：<code>~/.ssh/authorized_keys</code></li></ol><h3 id="SSH实用命令">SSH实用命令</h3><h4 id="scp-安全复制">scp (安全复制)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp 文件 用户@主机:路径   <span class="comment"># 上传</span></span><br><span class="line">scp -r 目录 用户@主机:路径 <span class="comment"># 递归复制目录</span></span><br></pre></td></tr></table></figure><h4 id="ssh-agent-密钥代理">ssh-agent (密钥代理)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> `ssh-agent`   <span class="comment"># 启动代理</span></span><br><span class="line">ssh-add            <span class="comment"># 添加密钥</span></span><br><span class="line">ssh-add -l         <span class="comment"># 列出已加载密钥</span></span><br></pre></td></tr></table></figure><h4 id="端口转发">端口转发</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地端口转发</span></span><br><span class="line">ssh -L 本地端口:远程主机:远程端口 用户@网关</span><br><span class="line"></span><br><span class="line"><span class="comment"># X11转发</span></span><br><span class="line">ssh -X 用户@主机</span><br></pre></td></tr></table></figure><h2 id="GnuPG-文件加密">GnuPG 文件加密</h2><h3 id="密钥管理">密钥管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gpg --gen-key              <span class="comment"># 生成密钥对</span></span><br><span class="line">gpg --list-keys            <span class="comment"># 列出密钥</span></span><br><span class="line">gpg --<span class="built_in">export</span> -a <span class="string">&quot;用户&quot;</span> &gt; pubkey.asc  <span class="comment"># 导出公钥</span></span><br><span class="line">gpg --import pubkey.asc    <span class="comment"># 导入公钥</span></span><br></pre></td></tr></table></figure><h3 id="文件加密-解密">文件加密/解密</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加密文件(给指定用户)</span></span><br><span class="line">gpg -e -a -r 接收者邮件 文件</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密文件</span></span><br><span class="line">gpg 加密文件.asc</span><br></pre></td></tr></table></figure><h3 id="密钥吊销">密钥吊销</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpg --gen-revoke 用户邮件 &gt; revoke.asc  <span class="comment"># 生成吊销证书</span></span><br><span class="line">gpg --import revoke.asc                 <span class="comment"># 导入吊销证书</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.TCP-IP</title>
      <link href="/2020/06/18/linux/9-TCP-IP/"/>
      <url>/2020/06/18/linux/9-TCP-IP/</url>
      
        <content type="html"><![CDATA[<h1>TCP/IP 基础笔记整理</h1><h2 id="IPv4-地址分类">IPv4 地址分类</h2><h3 id="标准分类">标准分类</h3><table><thead><tr><th>类别</th><th>IP 地址范围</th><th>子网掩码</th></tr></thead><tbody><tr><td>A</td><td>0.0.0.0 ~ 127.255.255.255</td><td>255.0.0.0</td></tr><tr><td>B</td><td>128.0.0.0 ~ 191.255.255.255</td><td>255.255.0.0</td></tr><tr><td>C</td><td>192.0.0.0 ~ 223.255.255.255</td><td>255.255.255.0</td></tr></tbody></table><h3 id="私有地址范围">私有地址范围</h3><table><thead><tr><th>类别</th><th>IP 地址范围</th></tr></thead><tbody><tr><td>A</td><td>10.0.0.0 ~ 10.255.255.255</td></tr><tr><td>B</td><td>172.16.0.0 ~ 172.31.255.255</td></tr><tr><td>C</td><td>192.168.0.0 ~ 192.168.255.255</td></tr></tbody></table><h2 id="CIDR-Classless-Inter-Domain-Routing">CIDR (Classless Inter-Domain Routing)</h2><ul><li>无类别域间路由</li><li>允许更灵活的子网划分方式，不再受传统 A/B/C 类限制</li></ul><h2 id="IPv6">IPv6</h2><ul><li>128 比特地址，用 16 进制表示，分为 8 个 block</li><li>表示规则：<ol><li>每个 block 开头的 0 可以省略</li><li>连续的 0 可以用 <code>::</code> 表示，但整个地址中 <code>::</code> 只能出现一次</li></ol></li></ul><h3 id="IPv6-地址类型">IPv6 地址类型</h3><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>单播地址 (Unicast)</td><td>标识单个接口，类似 IPv4 单播地址</td></tr><tr><td>组播地址 (Multicast)</td><td>标识一组接口，类似 IPv4 组播地址</td></tr><tr><td>任播地址 (Anycast)</td><td>新增类型，数据包发送给最近的一个接口</td></tr></tbody></table><h2 id="端口-Port">端口 (Port)</h2><ul><li><code>/etc/services</code>：端口与服务对应关系文件</li><li>常用端口：</li></ul><table><thead><tr><th>端口</th><th>协议</th><th>服务</th><th>说明</th></tr></thead><tbody><tr><td>20</td><td>TCP</td><td>FTP</td><td>文件传输(数据)</td></tr><tr><td>21</td><td>TCP</td><td>FTP</td><td>文件传输(控制)</td></tr><tr><td>22</td><td>TCP</td><td>SSH</td><td>安全Shell</td></tr><tr><td>23</td><td>TCP</td><td>Telnet</td><td>远程登录</td></tr><tr><td>25</td><td>TCP/UDP</td><td>SMTP</td><td>邮件发送</td></tr><tr><td>53</td><td>TCP/UDP</td><td>DNS</td><td>域名解析</td></tr><tr><td>80</td><td>TCP</td><td>HTTP</td><td>Web服务</td></tr><tr><td>110</td><td>TCP</td><td>POP3</td><td>邮件接收</td></tr><tr><td>119</td><td>TCP</td><td>NNTP</td><td>网络新闻</td></tr><tr><td>139</td><td>TCP/UDP</td><td>NetBIOS</td><td>Windows网络</td></tr><tr><td>143</td><td>TCP</td><td>IMAP</td><td>邮件访问</td></tr><tr><td>161</td><td>UDP</td><td>SNMP</td><td>网络管理</td></tr><tr><td>443</td><td>TCP</td><td>HTTPS</td><td>安全Web</td></tr><tr><td>465</td><td>TCP</td><td>SMTPS</td><td>安全SMTP</td></tr><tr><td>993</td><td>TCP</td><td>IMAPS</td><td>安全IMAP</td></tr><tr><td>995</td><td>TCP</td><td>POP3S</td><td>安全POP3</td></tr></tbody></table><h2 id="nsswitch-conf-文件">nsswitch.conf 文件</h2><p>控制各种系统数据库的搜索顺序和方法</p><h3 id="1-信息类型-Info">1. 信息类型(Info)</h3><ul><li><code>automount</code>：自动挂载信息</li><li><code>bootparams</code>：引导选项</li><li><code>ethers</code>：MAC地址</li><li><code>group</code>：用户组信息</li><li><code>hosts</code>：主机名和IP</li><li><code>networks</code>：网络信息</li><li><code>passwd</code>：用户信息</li><li><code>protocols</code>：网络协议</li><li><code>publickey</code>：NIS+/NFS公钥</li><li><code>rpc</code>：远程过程调用</li><li><code>services</code>：网络服务</li><li><code>shadow</code>：用户密码信息</li><li><code>aliases</code>：邮件别名</li></ul><h3 id="2-搜索方法-method">2. 搜索方法(method)</h3><ul><li><code>files</code>：搜索本地文件</li><li><code>nis</code>：搜索NIS数据库</li><li><code>dns</code>：查询DNS</li><li><code>compat</code>：兼容模式(±语法)</li></ul><h3 id="3-搜索顺序">3. 搜索顺序</h3><p>从左到右依次尝试，先找到的结果优先</p><h3 id="4-动作项-action">4. 动作项([action])</h3><p>格式：<code>[[!]STATUS=action]</code></p><ul><li>STATUS：<ul><li><code>NOTFOUND</code>：未找到</li><li><code>SUCCESS</code>：成功找到</li><li><code>UNAVAIL</code>：永久不可用</li><li><code>TRYAGAIN</code>：临时不可用</li></ul></li><li>action：<ul><li><code>return</code>：返回结果</li><li><code>continue</code>：继续尝试下个方法</li></ul></li></ul><h3 id="5-compat方法">5. compat方法</h3><p>在passwd/group/shadow文件中使用<code>+</code>和<code>-</code>来合并NIS信息</p><h2 id="网络故障排除命令">网络故障排除命令</h2><h3 id="ping">ping</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ping 主机名或IP地址</span><br><span class="line">ping -c 次数 目标  <span class="comment"># 指定发送次数</span></span><br><span class="line">ping -i 间隔 目标  <span class="comment"># 指定发送间隔</span></span><br></pre></td></tr></table></figure><ul><li>TTL：ICMP包最大生存时间</li><li>time：响应时间</li></ul><h3 id="traceroute-tracepath">traceroute/tracepath</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">traceroute 主机名或IP地址</span><br><span class="line">tracepath 主机名或IP地址 [端口]</span><br></pre></td></tr></table></figure><ul><li>显示到达目标的路径</li></ul><h3 id="host">host</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">host [选项] 主机名或IP [DNS服务器]</span><br><span class="line">host -v 目标  <span class="comment"># 显示详细信息</span></span><br></pre></td></tr></table></figure><ul><li>查询DNS信息</li></ul><h3 id="hostname">hostname</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hostname  <span class="comment"># 显示当前主机名</span></span><br><span class="line">hostname 新主机名  <span class="comment"># 设置主机名</span></span><br></pre></td></tr></table></figure><h3 id="netstat">netstat</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">netstat -a  <span class="comment"># 显示所有socket</span></span><br><span class="line">netstat -c  <span class="comment"># 实时更新</span></span><br><span class="line">netstat -i  <span class="comment"># 显示接口状态</span></span><br><span class="line">netstat -n  <span class="comment"># 显示数字地址</span></span><br><span class="line">netstat -p  <span class="comment"># 显示PID/进程名</span></span><br><span class="line">netstat -r  <span class="comment"># 显示路由表</span></span><br><span class="line">netstat -t  <span class="comment"># 只显示TCP</span></span><br><span class="line">netstat -u  <span class="comment"># 只显示UDP</span></span><br></pre></td></tr></table></figure><h3 id="route">route</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">route  <span class="comment"># 显示路由表</span></span><br><span class="line">route add -net 目标网络 netmask 子网掩码 gw 网关</span><br><span class="line">route add default gw 默认网关</span><br><span class="line">route del -net 目标网络</span><br></pre></td></tr></table></figure><p>路由表字段说明：</p><ul><li>Destination：目标网络/主机</li><li>Gateway：网关</li><li>Genmask：子网掩码</li><li>Flags：标志(U=有效,H=主机,G=网关)</li><li>Metric：距离</li><li>Ref：引用数</li><li>Use：使用计数</li><li>Iface：接口</li></ul><h3 id="ifconfig">ifconfig</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig 接口名 IP地址 netmask 子网掩码</span><br><span class="line">ifconfig 接口名 up/down  <span class="comment"># 启用/禁用接口</span></span><br></pre></td></tr></table></figure><h3 id="ifup-ifdown">ifup/ifdown</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifup 接口名  <span class="comment"># 启用接口</span></span><br><span class="line">ifdown 接口名  <span class="comment"># 禁用接口</span></span><br></pre></td></tr></table></figure><h2 id="网络服务命令">网络服务命令</h2><h3 id="telnet">telnet</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 主机 [端口]  <span class="comment"># 默认端口23</span></span><br></pre></td></tr></table></figure><h3 id="ftp">ftp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ftp 主机</span><br><span class="line"><span class="comment"># 常用命令：</span></span><br><span class="line"><span class="built_in">ls</span>      <span class="comment"># 列出远程文件</span></span><br><span class="line"><span class="built_in">pwd</span>     <span class="comment"># 显示远程当前目录</span></span><br><span class="line">get     <span class="comment"># 下载文件</span></span><br><span class="line">mget    <span class="comment"># 下载多个文件</span></span><br><span class="line">put     <span class="comment"># 上传文件</span></span><br><span class="line">ascii   <span class="comment"># ASCII传输模式</span></span><br><span class="line">binary  <span class="comment"># 二进制传输模式</span></span><br><span class="line">quit    <span class="comment"># 退出</span></span><br></pre></td></tr></table></figure><h3 id="dig">dig</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dig [选项] @DNS服务器 主机名 域名 [查询类型]</span><br><span class="line">dig -x IP地址  <span class="comment"># 反向查询</span></span><br><span class="line"><span class="comment"># 查询类型：</span></span><br><span class="line">a    <span class="comment"># IP地址</span></span><br><span class="line">any  <span class="comment"># 所有信息</span></span><br><span class="line">mx   <span class="comment"># 邮件服务器</span></span><br><span class="line">ns   <span class="comment"># 名称服务器</span></span><br></pre></td></tr></table></figure><h3 id="whois">whois</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whois 目标 [@whois服务器]</span><br></pre></td></tr></table></figure><ul><li>查询域名注册信息</li></ul><h2 id="网络配置文件">网络配置文件</h2><h3 id="etc-hostname">/etc/hostname</h3><ul><li>存储主机名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windsor.lpic.jp</span><br></pre></td></tr></table></figure><h3 id="etc-hosts">/etc/hosts</h3><ul><li>主机名与IP映射</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 localhost.localdomain localhost</span><br><span class="line">192.168.0.1 windsor.example.com windsor</span><br></pre></td></tr></table></figure><h3 id="etc-nsswitch-conf">/etc/nsswitch.conf</h3><ul><li>名称服务切换配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hosts: files ldap dns  # 先查本地文件，再LDAP，最后DNS</span><br></pre></td></tr></table></figure><h3 id="etc-resolv-conf">/etc/resolv.conf</h3><ul><li>DNS配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">domain lpic.jp</span><br><span class="line">search lpic.jp</span><br><span class="line">nameserver 192.168.1.253</span><br><span class="line">nameserver 192.168.1.2</span><br></pre></td></tr></table></figure><h3 id="etc-sysconfig-network">/etc/sysconfig/network</h3><ul><li>基本网络设置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NETWORKING=YES</span><br><span class="line">HOSTNAME=lpic.example.net</span><br><span class="line">GATEWAY=192.168.0.254</span><br></pre></td></tr></table></figure><h3 id="etc-sysconfig-network-scripts">/etc/sysconfig/network-scripts/</h3><ul><li>网络接口配置文件(如ifcfg-eth0)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth0</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=192.168.0.6</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">NETWORK=192.168.0.0</span><br><span class="line">BROADCAST=192.168.0.255</span><br><span class="line">ONBOOT=yes</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytest基础</title>
      <link href="/2020/06/12/pytest%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/06/12/pytest%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述">1. 概述</h2><p>pytest 是一个功能强大的 Python 测试框架，具有以下特点：</p><ul><li>简单灵活，文档丰富</li><li>支持参数化测试</li><li>可用于单元测试、功能测试、自动化测试（如 Selenium/Appium）和接口测试</li><li>丰富的插件生态系统</li><li>支持测试跳过（skip）和预期失败（xfail）</li><li>良好的 CI 工具集成（如 Jenkins）</li></ul><h3 id="主要插件">主要插件</h3><table><thead><tr><th>插件名称</th><th>功能描述</th></tr></thead><tbody><tr><td>pytest-selenium</td><td>Selenium 集成</td></tr><tr><td>pytest-html</td><td>生成 HTML 测试报告</td></tr><tr><td>pytest-rerunfailures</td><td>失败用例重试</td></tr><tr><td>pytest-xdist</td><td>多 CPU 并行测试</td></tr></tbody></table><h2 id="2-使用介绍">2. 使用介绍</h2><h3 id="2-1-安装">2.1 安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest</span><br></pre></td></tr></table></figure><h3 id="2-2-编写规则">2.2 编写规则</h3><ul><li>测试文件：<code>test_*.py</code> 或 <code>*_test.py</code></li><li>测试类：以 <code>Test</code> 开头，不能有 <code>__init__</code> 方法</li><li>测试函数：以 <code>test_</code> 开头</li><li>断言：使用 Python 原生 <code>assert</code></li></ul><h3 id="2-3-示例代码">2.3 示例代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pytest1.py</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">&#x27;function&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setup_function</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">teardown_function</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;teardown_function called.&quot;</span>)</span><br><span class="line">    request.addfinalizer(teardown_function)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;setup_function called.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">&#x27;module&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setup_module</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">teardown_module</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;teardown_module called.&quot;</span>)</span><br><span class="line">    request.addfinalizer(teardown_module)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;setup_module called.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.website</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_1</span>(<span class="params">setup_function</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Test_1 called.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_2</span>(<span class="params">setup_module</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Test_2 called.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_3</span>(<span class="params">setup_module</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Test_3 called.&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-4-fixture-的-scope-参数">2.4 fixture 的 scope 参数</h3><table><thead><tr><th>参数值</th><th>作用范围</th></tr></thead><tbody><tr><td>function</td><td>每个测试函数运行一次（默认）</td></tr><tr><td>class</td><td>每个测试类运行一次</td></tr><tr><td>module</td><td>每个模块运行一次</td></tr><tr><td>session</td><td>每次会话运行一次</td></tr></tbody></table><h3 id="2-5-setup-和-teardown">2.5 setup 和 teardown</h3><ul><li><strong>setup</strong>：测试前的准备工作</li><li><strong>teardown</strong>：测试后的清理工作</li><li>替代方案：使用 <code>yield</code> 实现 setup/teardown</li></ul><h2 id="3-测试执行">3. 测试执行</h2><h3 id="3-1-基本执行命令">3.1 基本执行命令</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>pytest</code></td><td>运行当前目录下所有测试</td></tr><tr><td><code>pytest test_mod.py</code></td><td>运行指定模块的测试</td></tr><tr><td><code>pytest somepath/</code></td><td>运行指定路径下的测试</td></tr><tr><td><code>pytest -k &quot;stringexpr&quot;</code></td><td>运行名称匹配表达式的测试</td></tr><tr><td><code>pytest test_mod.py::test_func</code></td><td>运行指定模块的特定测试函数</td></tr></tbody></table><h3 id="3-2-标记执行">3.2 标记执行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行标记为 website 的测试</span></span><br><span class="line">pytest -v -m <span class="string">&quot;website&quot;</span> pytest1.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行未标记为 website 的测试</span></span><br><span class="line">pytest -v -m <span class="string">&quot;not website&quot;</span> pytest1.py</span><br></pre></td></tr></table></figure><h3 id="3-3-常用命令行参数">3.3 常用命令行参数</h3><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td><code>-v</code></td><td>显示详细测试结果</td></tr><tr><td><code>-q</code></td><td>只显示简要结果</td></tr><tr><td><code>-s</code></td><td>显示 print 输出</td></tr><tr><td><code>-x</code></td><td>遇到第一个失败立即停止</td></tr><tr><td><code>--exitfirst</code></td><td>同 <code>-x</code></td></tr><tr><td><code>-h</code></td><td>显示帮助信息</td></tr></tbody></table><h2 id="4-扩展插件">4. 扩展插件</h2><h3 id="4-1-测试覆盖率-pytest-cov">4.1 测试覆盖率 (pytest-cov)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest-cov</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 HTML 覆盖率报告</span></span><br><span class="line">pytest --cov-report=html --cov=./ test_code_target_dir</span><br></pre></td></tr></table></figure><p><strong>覆盖率参数</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>--cov=[path]</code></td><td>指定计算覆盖率的路径</td></tr><tr><td><code>--cov-report=type</code></td><td>报告类型：term, html, xml 等</td></tr><tr><td><code>--cov-fail-under=MIN</code></td><td>设置覆盖率最低阈值</td></tr></tbody></table><h3 id="4-2-其他实用插件">4.2 其他实用插件</h3><table><thead><tr><th>插件</th><th>功能</th><th>安装命令</th></tr></thead><tbody><tr><td>pytest-randomly</td><td>随机执行测试</td><td><code>pip install pytest-randomly</code></td></tr><tr><td>pytest-xdist</td><td>分布式测试</td><td><code>pip install pytest-xdist</code></td></tr><tr><td>pytest-instafail</td><td>立即显示失败</td><td><code>pip install pytest-instafail</code></td></tr></tbody></table><h2 id="5-示例输出">5. 示例输出</h2><h3 id="5-1-详细模式-v">5.1 详细模式 (-v)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ pytest -v pytest1.py</span><br><span class="line">==============================================================================</span><br><span class="line">platform linux2 -- Python 2.7.14, pytest-3.0.0</span><br><span class="line">collected 3 items</span><br><span class="line"></span><br><span class="line">pytest1.py::test_1 PASSED</span><br><span class="line">pytest1.py::test_3 PASSED</span><br><span class="line">pytest1.py::test_2 PASSED</span><br></pre></td></tr></table></figure><h3 id="5-2-显示输出-s">5.2 显示输出 (-s)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ pytest -s pytest1.py</span><br><span class="line">==============================================================================</span><br><span class="line">setup_function called.</span><br><span class="line">Test_1 called.</span><br><span class="line">.teardown_function called.</span><br><span class="line">setup_module called.</span><br><span class="line">Test_2 called.</span><br><span class="line">.Test_3 called.</span><br><span class="line">.teardown_module called.</span><br></pre></td></tr></table></figure><h3 id="5-3-覆盖率报告">5.3 覆盖率报告</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------------------------------- coverage: platform linux2, python 2.7.14-final-0 ----------------------------------------------------------------</span><br><span class="line">Name         Stmts   Miss  Cover</span><br><span class="line">--------------------------------</span><br><span class="line">pytest1.py      18      0   100%</span><br></pre></td></tr></table></figure><h2 id="6-参考资源">6. 参考资源</h2><ol><li><a href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy">Python 测试工具大全</a></li><li><a href="http://docs.python-guide.org/en/latest/writing/tests/">主流测试工具比较</a></li><li><a href="http://pythontesting.net/test-podcast/">pytest 官方播客</a></li><li><a href="https://blog.csdn.net/liuchunming033/article/details/46501653">pytest 简介</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> pytest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> devops </tag>
            
            <tag> python </tag>
            
            <tag> pytest </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.系统管理</title>
      <link href="/2020/05/24/linux/8-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
      <url>/2020/05/24/linux/8-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1>Linux 用户、群组与系统管理</h1><h2 id="1-用户和群组管理">1. 用户和群组管理</h2><h3 id="1-1-用户配置文件">1.1 用户配置文件</h3><h4 id="etc-passwd-文件格式">/etc/passwd 文件格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lpic:x:500:500:LPI linux:/home/lpic:/bin/bash</span><br><span class="line">↑    ↑ ↑   ↑   ↑         ↑          ↑</span><br><span class="line">│    │ │   │   │         │          └─ 默认shell</span><br><span class="line">│    │ │   │   │         └─────────── 家目录</span><br><span class="line">│    │ │   │   └───────────────────── 用户备注信息(GECOS)</span><br><span class="line">│    │ │   └───────────────────────── 主组GID</span><br><span class="line">│    │ └───────────────────────────── 用户UID</span><br><span class="line">│    └─────────────────────────────── 密码占位符(实际在/etc/shadow)</span><br><span class="line">└──────────────────────────────────── 用户名</span><br></pre></td></tr></table></figure><h4 id="etc-shadow-文件">/etc/shadow 文件</h4><ul><li>存储用户密码哈希值</li><li>只有root用户可访问</li><li>包含密码过期时间等安全信息</li></ul><h4 id="etc-group-文件格式">/etc/group 文件格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">staff:x:500:linux,lpic</span><br><span class="line">↑     ↑ ↑   ↑</span><br><span class="line">│     │ │   └───────────── 附加组成员</span><br><span class="line">│     │ └───────────────── 组GID</span><br><span class="line">│     └─────────────────── 组密码占位符</span><br><span class="line">└───────────────────────── 组名</span><br></pre></td></tr></table></figure><h3 id="1-2-用户管理命令">1.2 用户管理命令</h3><h4 id="useradd-添加用户">useradd - 添加用户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -c <span class="string">&quot;开发人员&quot;</span> -d /home/dev -g staff -G developers -s /bin/bash -m devuser</span><br></pre></td></tr></table></figure><p>常用选项：</p><ul><li><code>-c</code>：用户备注信息</li><li><code>-d</code>：指定家目录路径</li><li><code>-g</code>：指定主组</li><li><code>-G</code>：指定附加组</li><li><code>-s</code>：指定登录shell</li><li><code>-m</code>：自动创建家目录(从/etc/skel复制模板)</li></ul><h4 id="usermod-修改用户">usermod - 修改用户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -c <span class="string">&quot;高级开发&quot;</span> -G managers -s /bin/zsh devuser</span><br></pre></td></tr></table></figure><p>常用选项：</p><ul><li><code>-c</code>：备注:指定备注</li><li><code>-d</code>：path:home目录</li><li><code>-g</code>：组名/GID:所属主组</li><li><code>-G</code>：组名/GID:其他所属组</li><li><code>-s</code>：path: login shell</li><li><code>-L</code>：锁定用户密码</li><li><code>-U</code>：解锁用户密码</li></ul><h4 id="userdel-删除用户">userdel - 删除用户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel -r devuser  <span class="comment"># 删除用户并移除家目录</span></span><br></pre></td></tr></table></figure><h4 id="passwd-密码管理">passwd - 密码管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">passwd devuser      <span class="comment"># 设置密码</span></span><br><span class="line">passwd -l devuser   <span class="comment"># 锁定账户</span></span><br><span class="line">passwd -u devuser   <span class="comment"># 解锁账户</span></span><br></pre></td></tr></table></figure><h3 id="1-3-群组管理命令">1.3 群组管理命令</h3><h4 id="groupadd-添加组">groupadd - 添加组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd developers</span><br></pre></td></tr></table></figure><h4 id="groupmod-修改组">groupmod - 修改组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod -g 1001 -n devgroup developers</span><br></pre></td></tr></table></figure><ul><li><code>-g</code>：修改GID</li><li><code>-n</code>：修改组名</li></ul><h4 id="groupdel-删除组">groupdel - 删除组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel devgroup</span><br></pre></td></tr></table></figure><h4 id="id-查看用户信息">id - 查看用户信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> devuser  <span class="comment"># 显示用户UID、GID和所属组</span></span><br></pre></td></tr></table></figure><h2 id="2-系统时间管理">2. 系统时间管理</h2><h3 id="2-1-date-系统时间">2.1 date - 系统时间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> 093017002012.30    <span class="comment"># 设置为2012年9月30日17:00:30</span></span><br><span class="line"><span class="built_in">date</span> <span class="string">&quot;+%Y/%m/%d (%a)&quot;</span>   <span class="comment"># 格式化为&quot;2023/05/15 (Mon)&quot;</span></span><br></pre></td></tr></table></figure><p>常用格式符号：</p><ul><li><code>%Y</code>：4位年份</li><li><code>%m</code>：2位月份</li><li><code>%d</code>：2位日期</li><li><code>%H</code>：24小时制小时</li><li><code>%M</code>：分钟</li><li><code>%a</code>：星期缩写</li></ul><h3 id="2-2-hwclock-硬件时钟">2.2 hwclock - 硬件时钟</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hwclock --show          <span class="comment"># 显示硬件时钟</span></span><br><span class="line">hwclock --systohc       <span class="comment"># 系统时间同步到硬件时钟</span></span><br><span class="line">hwclock --hctosys       <span class="comment"># 硬件时钟同步到系统时间</span></span><br></pre></td></tr></table></figure><h3 id="2-3-NTP时间同步">2.3 NTP时间同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ntpdate time.server.lpic.jp  <span class="comment"># 手动同步时间</span></span><br><span class="line">service ntpd start           <span class="comment"># 启动NTP服务</span></span><br></pre></td></tr></table></figure><p>NTP配置文件(<code>/etc/ntp.conf</code>)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driftfile /etc/ntp.drift</span><br><span class="line">logfile /var/log/ntp.log</span><br><span class="line">server ntp.server.lpic.jp</span><br></pre></td></tr></table></figure><h2 id="3-系统日志管理">3. 系统日志管理</h2><h3 id="3-1-syslog-配置">3.1 syslog 配置</h3><p>配置文件：<code>/etc/syslog.conf</code></p><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">facility.priority    log_location</span><br></pre></td></tr></table></figure><h4 id="facility-设施-类型：">facility(设施)类型：</h4><ul><li><code>auth</code>/<code>authpriv</code>：认证相关</li><li><code>cron</code>：定时任务</li><li><code>daemon</code>：守护进程</li><li><code>kern</code>：内核消息</li><li><code>mail</code>：邮件系统</li><li><code>syslog</code>：syslog自身</li><li><code>local0</code>-<code>local7</code>：自定义设施</li></ul><h4 id="priority-优先级-：">priority(优先级)：</h4><ul><li><code>emerg</code>：紧急情况</li><li><code>alert</code>：需要立即处理</li><li><code>crit</code>：严重错误</li><li><code>err</code>：一般错误</li><li><code>warning</code>：警告</li><li><code>notice</code>：重要通知</li><li><code>info</code>：一般信息</li><li><code>debug</code>：调试信息</li></ul><h4 id="输出目标：">输出目标：</h4><ul><li>文件名：如<code>/var/log/messages</code></li><li><code>@host</code>：远程syslog服务器</li><li>用户名：发送到用户终端</li><li><code>*</code>：所有用户终端</li></ul><h3 id="3-2-logger-命令">3.2 logger 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger -p syslog.info -t TEST <span class="string">&quot;测试日志消息&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-3-常用日志文件">3.3 常用日志文件</h3><ul><li><code>/var/log/secure</code>：认证日志</li><li><code>/var/log/messages</code>：系统消息</li><li><code>/var/log/boot.log</code>：启动日志</li></ul><h3 id="3-4-用户登录信息">3.4 用户登录信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span>          <span class="comment"># 显示当前登录用户</span></span><br><span class="line">w            <span class="comment"># 显示详细登录信息</span></span><br><span class="line">last         <span class="comment"># 显示登录历史</span></span><br><span class="line">lastlog      <span class="comment"># 显示用户最近登录时间</span></span><br></pre></td></tr></table></figure><h3 id="3-5-日志轮转">3.5 日志轮转</h3><p>配置文件：<code>/etc/logrotate.conf</code></p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">weekly</span><br><span class="line">rotate 4</span><br><span class="line">create</span><br><span class="line">compress</span><br><span class="line"></span><br><span class="line">/var/log/wtmp &#123;</span><br><span class="line">    monthly</span><br><span class="line">    create 0664 root utmp</span><br><span class="line">    rotate 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-邮件系统">4. 邮件系统</h2><h3 id="4-1-邮件组件">4.1 邮件组件</h3><ul><li><strong>MTA</strong>(邮件传输代理)：sendmail/postfix/exim</li><li><strong>MDA</strong>(邮件投递代理)：procmail</li><li><strong>MUA</strong>(邮件用户代理)：mail/mutt/thunderbird</li></ul><h3 id="4-2-启动MTA">4.2 启动MTA</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service sendmail start</span><br><span class="line">service postfix start</span><br><span class="line">service exim4 start</span><br></pre></td></tr></table></figure><h3 id="4-3-mail-命令">4.3 mail 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mail -s <span class="string">&quot;测试邮件&quot;</span> user@example.com</span><br><span class="line">邮件正文...</span><br><span class="line">.   <span class="comment"># 单独一行输入点结束</span></span><br><span class="line">Cc: <span class="comment"># 抄送地址(可选)</span></span><br></pre></td></tr></table></figure><h3 id="4-4-邮件转发">4.4 邮件转发</h3><h4 id="etc-aliases">/etc/aliases</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root: admin,lpic</span><br></pre></td></tr></table></figure><p>更新别名数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newaliases</span><br></pre></td></tr></table></figure><h4 id="用户-forward文件">用户.forward文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/user/.forward:</span><br><span class="line">user2@example.com</span><br></pre></td></tr></table></figure><h2 id="5-打印系统">5. 打印系统</h2><h3 id="5-1-CUPS打印系统">5.1 CUPS打印系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service cups start  <span class="comment"># 启动CUPS服务</span></span><br></pre></td></tr></table></figure><p>主要配置文件：</p><ul><li><code>/etc/cups/cupsd.conf</code>：服务配置</li><li><code>/etc/cups/printers.conf</code>：打印机配置</li><li><code>/etc/cups/ppd/</code>：PPD驱动文件</li></ul><h3 id="5-2-打印命令">5.2 打印命令</h3><h4 id="lpr-打印文件">lpr - 打印文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpr -P LaserJet -#2 document.pdf</span><br></pre></td></tr></table></figure><h4 id="lpq-查看打印队列">lpq - 查看打印队列</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpq -P LaserJet</span><br></pre></td></tr></table></figure><h4 id="lprm-删除打印任务">lprm - 删除打印任务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lprm -P LaserJet 123  <span class="comment"># 删除指定任务</span></span><br><span class="line">lprm -P LaserJet -    <span class="comment"># 删除用户所有任务</span></span><br></pre></td></tr></table></figure><h3 id="5-3-Web管理界面">5.3 Web管理界面</h3><p>访问：<a href="http://localhost:631">http://localhost:631</a></p><h2 id="6-定时任务管理">6. 定时任务管理</h2><h3 id="6-1-cron-定时任务系统">6.1 cron 定时任务系统</h3><h4 id="crontab-命令">crontab 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">crontab -e            <span class="comment"># 编辑当前用户的crontab</span></span><br><span class="line">crontab -l            <span class="comment"># 列出当前用户的crontab</span></span><br><span class="line">crontab -r            <span class="comment"># 删除当前用户的crontab</span></span><br><span class="line">crontab -u user -e    <span class="comment"># 编辑指定用户的crontab(root权限)</span></span><br></pre></td></tr></table></figure><h4 id="crontab-文件格式">crontab 文件格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* * * * * command_to_execute</span><br><span class="line">│ │ │ │ │</span><br><span class="line">│ │ │ │ └── 星期几 (0-6, 0=星期日)</span><br><span class="line">│ │ │ └──── 月份 (1-12)</span><br><span class="line">│ │ └────── 日 (1-31)</span><br><span class="line">│ └──────── 小时 (0-23)</span><br><span class="line">└────────── 分钟 (0-59)</span><br></pre></td></tr></table></figure><p>特殊字符：</p><ul><li><code>*</code>：所有有效值</li><li><code>,</code>：值列表分隔符(如1,3,5)</li><li><code>-</code>：范围(如1-5)</li><li><code>/</code>：步长(如*/2表示每2个单位)</li></ul><h4 id="系统cron目录">系统cron目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/crontab           <span class="comment"># 系统级crontab文件</span></span><br><span class="line">/etc/cron.d/           <span class="comment"># 系统cron片段</span></span><br><span class="line">/etc/cron.hourly/      <span class="comment"># 每小时执行</span></span><br><span class="line">/etc/cron.daily/       <span class="comment"># 每天执行</span></span><br><span class="line">/etc/cron.weekly/      <span class="comment"># 每周执行</span></span><br><span class="line">/etc/cron.monthly/     <span class="comment"># 每月执行</span></span><br></pre></td></tr></table></figure><h4 id="anacron">anacron</h4><ul><li>用于在系统停机后执行错过的定时任务</li><li>配置文件：<code>/etc/anacrontab</code></li></ul><h3 id="6-2-at-一次性任务">6.2 at 一次性任务</h3><h4 id="at-命令">at 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at 17:00 tomorrow      <span class="comment"># 创建定时任务</span></span><br><span class="line">at -f job.sh 23:00     <span class="comment"># 从文件读取任务</span></span><br><span class="line">atq                    <span class="comment"># 查看待执行任务(at -l)</span></span><br><span class="line">atrm 3                 <span class="comment"># 删除任务3(at -d 3)</span></span><br></pre></td></tr></table></figure><h4 id="时间格式">时间格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HH:MM                  # 24小时制(如23:00)</span><br><span class="line">noon/midnight          # 中午12点/午夜12点</span><br><span class="line">today/tomorrow         # 今天/明天</span><br><span class="line">now + count time-units # 如now + 3 days</span><br></pre></td></tr></table></figure><h3 id="6-3-batch-低负荷执行">6.3 batch 低负荷执行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch                  <span class="comment"># 进入交互式输入模式</span></span><br><span class="line">batch -f job.sh        <span class="comment"># 从文件读取任务</span></span><br></pre></td></tr></table></figure><h3 id="6-4-访问控制">6.4 访问控制</h3><h4 id="cron-访问控制">cron 访问控制</h4><ol><li>如存在<code>/etc/cron.allow</code>，仅允许文件内用户</li><li>如无allow文件，检查<code>/etc/cron.deny</code>，拒绝文件内用户</li><li>如两者都不存在，默认行为取决于系统配置</li></ol><h4 id="at-访问控制">at 访问控制</h4><ol><li>如存在<code>/etc/at.allow</code>，仅允许文件内用户</li><li>如无allow文件，检查<code>/etc/at.deny</code>，拒绝文件内用户</li><li>如两者都不存在，默认只有root可用</li></ol><h2 id="7-本地化与国际化">7. 本地化与国际化</h2><h3 id="7-1-本地化变量">7.1 本地化变量</h3><table><thead><tr><th>变量</th><th>作用域</th></tr></thead><tbody><tr><td><code>LC_CTYPE</code></td><td>字符分类和大小写转换</td></tr><tr><td><code>LC_COLLATE</code></td><td>排序和比较规则</td></tr><tr><td><code>LC_MESSAGES</code></td><td>系统消息语言</td></tr><tr><td><code>LC_MONETARY</code></td><td>货币格式</td></tr><tr><td><code>LC_NUMERIC</code></td><td>数字格式</td></tr><tr><td><code>LC_TIME</code></td><td>日期时间格式</td></tr><tr><td><code>LC_ALL</code></td><td>覆盖所有LC_*设置</td></tr><tr><td><code>LANG</code></td><td>默认设置(未被LC_*覆盖时使用)</td></tr></tbody></table><h3 id="7-2-常用locale设置">7.2 常用locale设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C/POSIX               <span class="comment"># 最小locale</span></span><br><span class="line">en_US.utf8            <span class="comment"># 英文(美国)</span></span><br><span class="line">ja_JP.utf8            <span class="comment"># 日文(UTF-8)</span></span><br><span class="line">ja_JP.eucJP           <span class="comment"># 日文(EUC-JP)</span></span><br><span class="line">zh_CN.utf8            <span class="comment"># 中文(简体)</span></span><br></pre></td></tr></table></figure><h3 id="7-3-locale-命令">7.3 locale 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">locale -a             <span class="comment"># 列出可用locale</span></span><br><span class="line">locale -m             <span class="comment"># 列出可用字符编码</span></span><br><span class="line">locale                <span class="comment"># 显示当前locale设置</span></span><br></pre></td></tr></table></figure><h3 id="7-4-字符编码">7.4 字符编码</h3><table><thead><tr><th>编码</th><th>描述</th></tr></thead><tbody><tr><td>ASCII</td><td>7位英文字符</td></tr><tr><td>ISO-8859</td><td>8位扩展ASCII</td></tr><tr><td>UTF-8</td><td>Unicode编码</td></tr><tr><td>EUC-JP</td><td>Linux日文编码</td></tr><tr><td>Shift_JIS</td><td>Windows/Mac日文编码</td></tr><tr><td>ISO-2022-JP</td><td>邮件用日文编码</td></tr></tbody></table><h3 id="7-5-iconv-编码转换">7.5 iconv 编码转换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iconv -f eucjp -t utf8 input.txt &gt; output.txt  <span class="comment"># EUC-JP转UTF-8</span></span><br><span class="line">iconv -l                                      <span class="comment"># 列出支持编码</span></span><br></pre></td></tr></table></figure><h2 id="8-时区设置">8. 时区设置</h2><h3 id="8-1-时区文件">8.1 时区文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/zoneinfo/   <span class="comment"># 所有时区定义文件</span></span><br><span class="line">/etc/localtime         <span class="comment"># 系统当前时区链接</span></span><br></pre></td></tr></table></figure><h3 id="8-2-设置时区方法">8.2 设置时区方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1: 复制时区文件</span></span><br><span class="line"><span class="built_in">cp</span> /usr/share/zoneinfo/Asia/Tokyo /etc/localtime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2: 创建符号链接</span></span><br><span class="line"><span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Tokyo /etc/localtime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法3: 临时设置(当前会话有效)</span></span><br><span class="line"><span class="built_in">export</span> TZ=<span class="string">&quot;Asia/Tokyo&quot;</span></span><br></pre></td></tr></table></figure><h3 id="8-3-时区配置工具">8.3 时区配置工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tzselect   <span class="comment"># 交互式时区选择</span></span><br><span class="line">tzconfig   <span class="comment"># 时区配置工具(部分发行版)</span></span><br><span class="line">dpkg-reconfigure tzdata  <span class="comment"># Debian系重新配置时区</span></span><br><span class="line">timedatectl set-timezone Asia/Tokyo  <span class="comment"># systemd系统设置时区</span></span><br></pre></td></tr></table></figure><h2 id="9-打印系统补充">9. 打印系统补充</h2><h3 id="9-1-CUPS-Web管理界面">9.1 CUPS Web管理界面</h3><p>访问：<code>http://localhost:631</code></p><h3 id="9-2-打印命令补充">9.2 打印命令补充</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpstat -p -d          <span class="comment"># 显示打印机状态和默认打印机</span></span><br><span class="line">lpoptions -d LaserJet <span class="comment"># 设置默认打印机</span></span><br></pre></td></tr></table></figure><h3 id="9-3-打印系统日志">9.3 打印系统日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/log/cups/        <span class="comment"># CUPS日志目录</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.XWindow</title>
      <link href="/2020/05/08/linux/7-XWindow/"/>
      <url>/2020/05/08/linux/7-XWindow/</url>
      
        <content type="html"><![CDATA[<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># X Window 系统架构详解</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 基础架构</span></span><br></pre></td></tr></table></figure><p>localhost(X server) --X protocol-- remotehost(X client)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 核心组件说明</span><br><span class="line">1. **X Server**：</span><br><span class="line">   - 负责硬件管理（显卡、显示器、输入设备等）</span><br><span class="line">   - 屏幕绘制与渲染</span><br><span class="line">   - 提供字体服务功能</span><br><span class="line">   - 典型实现：Xorg</span><br><span class="line"></span><br><span class="line">2. **X Client**：</span><br><span class="line">   - 应用程序逻辑处理</span><br><span class="line">   - 响应X Server的事件请求</span><br><span class="line">   - 例如：xterm、Firefox等GUI程序</span><br><span class="line"></span><br><span class="line">3. **X Window Manager**：</span><br><span class="line">   - 特殊的X Client</span><br><span class="line">   - 负责管理窗口布局、装饰和交互</span><br><span class="line">   - 常见WM：twm、KWin、Metacity等</span><br><span class="line"></span><br><span class="line">4. **Display Manager**：</span><br><span class="line">   - 提供图形化登录界面</span><br><span class="line">   - 负责加载用户选择的WM和语言环境</span><br><span class="line">   - 常见实现：GDM、KDM、XDM</span><br><span class="line"></span><br><span class="line">## startx 启动流程</span><br><span class="line"></span><br><span class="line">### 命令语法</span><br><span class="line">```bash</span><br><span class="line">startx [X client 参数] -- [X server 参数]</span><br></pre></td></tr></table></figure><h3 id="X-server-参数查找顺序">X server 参数查找顺序</h3><ol><li>startx 命令行参数</li><li>用户主目录 <code>~/.xserverrc</code></li><li>系统默认 <code>/etc/X11/xinit/xserverrc</code></li><li>最终回退 <code>/usr/bin/X</code> (X server可执行文件)</li></ol><h3 id="X-client-参数查找顺序">X client 参数查找顺序</h3><ol><li>startx 命令行参数</li><li>用户主目录 <code>~/.xinitrc</code></li><li>系统默认 <code>/etc/X11/xinit/xinitrc</code></li><li>最终回退 <code>xterm</code> (基础终端模拟器)</li></ol><h3 id="底层调用">底层调用</h3><p>startx 最终调用 <code>xinit</code> 启动X系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xinit [client option] -- [server or display option]</span><br></pre></td></tr></table></figure><p>默认等效命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xinit /etc/X11/xinit/xinitrc -- /usr/bin/X</span><br></pre></td></tr></table></figure><p>最小化启动示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xinit xterm -geometry +1+1 -n login -display :0 -- X :0</span><br></pre></td></tr></table></figure><h2 id="配置文件体系">配置文件体系</h2><h3 id="核心配置文件">核心配置文件</h3><ul><li>主配置文件：<code>/etc/X11/xorg.conf</code></li><li>模块目录：<code>/usr/lib64/xorg/modules/</code></li><li>字体目录：<code>/usr/share/X11/fonts/</code></li><li>显卡驱动：<code>/usr/lib64/xorg/modules/drivers/</code></li></ul><h3 id="配置段落-Section">配置段落(Section)</h3><table><thead><tr><th>Section名称</th><th>功能描述</th></tr></thead><tbody><tr><td>Module</td><td>X Server加载的功能模块</td></tr><tr><td>InputDevice</td><td>输入设备配置（键盘/鼠标）</td></tr><tr><td>Files</td><td>字体和颜色资源路径</td></tr><tr><td>Monitor</td><td>显示器参数（刷新率等）</td></tr><tr><td>Device</td><td>显卡芯片组配置</td></tr><tr><td>Screen</td><td>显示分辨率和色深设置</td></tr><tr><td>ServerLayout</td><td>各模块的组合配置</td></tr></tbody></table><h3 id="配置生成工具">配置生成工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Xorg -configure</span><br><span class="line"><span class="comment"># 生成测试配置文件：/root/xorg.conf.new</span></span><br><span class="line"><span class="comment"># 测试命令：X -config /root/xorg.conf.new</span></span><br></pre></td></tr></table></figure><h2 id="实用命令工具">实用命令工具</h2><h3 id="显示调节">显示调节</h3><ul><li><code>xvidtune</code>：GUI显示器频率调节工具</li><li><code>xhost</code>：X server访问控制<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xhost +hostname  <span class="comment"># 添加访问权限</span></span><br><span class="line">xhost -hostname  <span class="comment"># 移除访问权限</span></span><br><span class="line">xhost +          <span class="comment"># 允许所有主机</span></span><br><span class="line">xhost -          <span class="comment"># 禁用所有远程访问</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="环境变量">环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DISPLAY=localhost:0  <span class="comment"># 指定显示目标</span></span><br><span class="line"><span class="built_in">export</span> DISPLAY</span><br></pre></td></tr></table></figure><h3 id="信息查询">信息查询</h3><table><thead><tr><th>命令</th><th>功能描述</th></tr></thead><tbody><tr><td>showrgb</td><td>显示可用RGB颜色值</td></tr><tr><td>xlsclients</td><td>列出运行中的X客户端</td></tr><tr><td>xwininfo</td><td>查询窗口几何属性</td></tr><tr><td>xdpyinfo</td><td>显示X Server详细信息</td></tr></tbody></table><h2 id="显示管理器-XDM">显示管理器(XDM)</h2><h3 id="类型对比">类型对比</h3><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>XDM</td><td>基础X Display Manager</td></tr><tr><td>GDM</td><td>GNOME显示管理器</td></tr><tr><td>KDM</td><td>KDE显示管理器</td></tr></tbody></table><h3 id="XDM启动流程">XDM启动流程</h3><ol><li>启动XDM服务</li><li>加载 <code>/etc/X11/Xsession</code></li><li>执行 <code>/etc/X11/xinit/xinitrc.d/</code> 下脚本</li><li>读取用户配置 <code>~/.xsession</code></li><li>加载 <code>~/.Xclients</code> 或 <code>/etc/X11/xinit/Xclients</code></li></ol><h3 id="关键配置文件">关键配置文件</h3><table><thead><tr><th>文件名</th><th>用途描述</th></tr></thead><tbody><tr><td>xdm-config</td><td>基础配置和访问控制</td></tr><tr><td>Xaccess</td><td>主机访问权限设置</td></tr><tr><td>Xresources</td><td>登录界面样式和X资源定义</td></tr><tr><td>Xservers</td><td>X Server与Display映射</td></tr><tr><td>Xsetup_0</td><td>登录前环境设置（如壁纸）</td></tr><tr><td>Xsession</td><td>会话启动流程控制</td></tr></tbody></table><h2 id="窗口管理器列表">窗口管理器列表</h2><table><thead><tr><th>名称</th><th>特点描述</th></tr></thead><tbody><tr><td>twm</td><td>最基本的窗口管理器</td></tr><tr><td>fvwm</td><td>轻量级窗口管理器</td></tr><tr><td>sawfish</td><td>GNOME集成WM</td></tr><tr><td>enlightenment</td><td>高定制化WM</td></tr><tr><td>metacity</td><td>GNOME默认WM</td></tr><tr><td>fluxbox</td><td>轻量级高自由度WM</td></tr><tr><td>WindowMaker</td><td>NeXTSTEP风格WM</td></tr><tr><td>KWin</td><td>KDE标准窗口管理器</td></tr></tbody></table><h2 id="辅助功能技术">辅助功能技术</h2><h3 id="AccessX-功能">AccessX 功能</h3><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>粘滞键</td><td>分离组合键输入</td></tr><tr><td>慢速键</td><td>调整按键响应时间</td></tr><tr><td>防反弹键</td><td>防止重复输入</td></tr><tr><td>切换键</td><td>切换状态声音反馈</td></tr><tr><td>鼠标键</td><td>键盘模拟鼠标操作</td></tr></tbody></table><h3 id="其他辅助工具">其他辅助工具</h3><ul><li><strong>高对比度显示</strong>：增强视觉可读性</li><li><strong>屏幕阅读器</strong>：Orca等文本转语音工具</li><li><strong>盲文显示器</strong>：触觉输出设备</li><li><strong>屏幕放大镜</strong>：视觉辅助工具</li><li><strong>屏幕键盘</strong>：GOK等虚拟输入工具</li></ul><h3 id="专用软件">专用软件</h3><ul><li><strong>Orca</strong>：GNOME屏幕阅读器和放大镜</li><li><strong>GOK</strong>：GNOME屏幕键盘</li><li><strong>emacspeak</strong>：为Emacs添加语音功能</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.Shell变量与Shell脚本</title>
      <link href="/2020/05/08/linux/6-Shell%E5%8F%98%E9%87%8F%E4%B8%8EShell%E8%84%9A%E6%9C%AC/"/>
      <url>/2020/05/08/linux/6-Shell%E5%8F%98%E9%87%8F%E4%B8%8EShell%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1>Shell变量与Shell脚本</h1><h2 id="Bash设定文档">Bash设定文档</h2><ul><li><strong>/etc/profile</strong>: 登录时执行，适用于所有用户</li><li><strong>~/.bash_profile</strong>: 登录时执行</li><li><strong>~/.bash_login</strong>: 当 <code>~/.bash_profile</code> 不存在时，登录时执行</li><li><strong>~/.profile</strong>: 当 <code>~/.bash_profile</code> 和 <code>~/.bash_login</code> 都不存在时，登录时执行</li><li><strong>~/.bashrc</strong>: 每次启动 Bash 时执行</li><li><strong>~/.bash_logout</strong>: 登出时执行</li></ul><h2 id="Shell环境定制化">Shell环境定制化</h2><h3 id="export命令"><code>export</code>命令</h3><p>用于将shell变量转化为环境变量，使得该变量能够被其他程序或子进程访问。</p><h3 id="set命令"><code>set</code>命令</h3><ul><li><p><code>set</code>: 显示打印当前的环境变量和Shell变量</p></li><li><p><code>set [-o] [+o] option</code>：</p><ul><li><code>-o</code>：启用该选项</li><li><code>+o</code>：禁用该选项</li><li>常用选项：<ul><li><code>allexport</code>: 自动将变量导出为环境变量</li><li><code>emacs</code>: 设置Emacs风格的键绑定</li><li><code>ignoreeof</code>: 禁止通过 Ctrl+D 退出Shell</li><li><code>noclobber</code>: 禁止文件重定向覆盖文件</li><li><code>noglob</code>: 禁用元字符解析</li><li><code>vi</code>: 设置vi风格的键绑定</li></ul></li></ul></li><li><p><code>set -o</code>: 显示或更改选项的状态</p></li></ul><h3 id="printenv命令"><code>printenv</code>命令</h3><p>用于打印当前的环境变量。</p><h3 id="alias-unalias"><code>alias</code>/<code>unalias</code></h3><ul><li><code>alias</code>: 设置命令别名</li><li><code>unalias</code>: 取消命令别名</li><li>临时解除别名：可以使用反斜杠 <code>\</code>，例如：<code>alias ls='ls -l'</code> 后，<code>'\ls'</code> 会执行原始的 <code>ls</code> 命令。</li></ul><h2 id="定义Shell函数">定义Shell函数</h2><ul><li><p>定义函数语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> [函数名] () &#123;</span><br><span class="line">    运行内容;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>&#123;</code> 和 <code>&#125;</code> 前后需要有空格。</p></li><li><p>定义变量：<code>$变量名</code></p></li><li><p>函数名不能与变量名重名。</p></li><li><p>查看已定义的函数：<code>declare -f</code></p></li><li><p>删除函数：<code>unset</code></p></li></ul><h2 id="Shell脚本">Shell脚本</h2><h3 id="执行Shell脚本">执行Shell脚本</h3><ul><li>脚本命令可以分行书写，并逐行执行。</li><li>运行脚本时，如果没有执行权限，只需要文件的读取权限和文件夹的运行权限即可。<ul><li>使用 <code>source [脚本名]</code> 或简化版 <code>.[脚本名]</code> 执行脚本。</li><li>如果脚本有执行权限，可以省略 <code>source</code>，例如：<code>./[脚本名]</code>。</li><li>如果脚本不在 <code>PATH</code> 环境变量指定的文件夹中，需要显式指定脚本路径，或者在当前目录使用 <code>./</code>。</li></ul></li></ul><h3 id="传入Shell脚本的变量">传入Shell脚本的变量</h3><ul><li><code>$0</code>：脚本文件名（全路径）</li><li><code>$1</code>：第一个传入的变量值</li><li><code>$2</code>：第二个传入的变量值</li><li><code>#$</code>：传入的变量数量</li><li><code>$@</code>：所有传入的变量值（空格分隔）</li><li><code>$*</code>：所有变量值（以系统默认的分隔符分隔）</li><li>脚本执行结束后的返回状态：<code>echo $?</code>。正常执行返回0，错误返回1。</li></ul><h3 id="文件检查">文件检查</h3><p>使用 <code>test</code> 命令或者 <code>[</code> <code>]</code> 语法进行文件检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> 条件文</span><br><span class="line">[ 条件文 ]</span><br></pre></td></tr></table></figure><h4 id="常见条件文：">常见条件文：</h4><ul><li><code>-f 文件名</code>：检查文件是否存在且为普通文件</li><li><code>-d 文件夹名</code>：检查文件夹是否存在</li><li><code>-r 文件名</code>：检查文件是否有读取权限</li><li><code>-w 文件名</code>：检查文件是否有写入权限</li><li><code>-x 文件名</code>：检查文件是否有执行权限</li><li><code>-s 文件名</code>：检查文件是否为空</li><li><code>-L 文件名</code>：检查是否为软链接</li><li><code>-e 文件名</code>：检查文件是否存在</li><li><code>文件名1 -nt 文件名2</code>：文件1是否比文件2新</li><li><code>文件名1 -ot 文件名2</code>：文件1是否比文件2旧</li><li>数值比较：<code>-eq</code>, <code>-ge</code>, <code>-gt</code>, <code>-le</code>, <code>-lt</code>, <code>-ne</code>（等于、大于等于、大于、小于等于、小于、不等于）</li><li>字符串比较：<code>-n</code>（字符串长度大于0），<code>-z</code>（字符串长度为0）</li><li>字符串相等：<code>字符串1 = 字符串2</code></li><li>字符串不等：<code>字符串1 != 字符串2</code></li><li>逻辑操作：<ul><li><code>!</code>：条件非</li><li><code>-a</code>：与（and）</li><li><code>-o</code>：或（or）</li></ul></li></ul><h2 id="条件分歧">条件分歧</h2><h3 id="if语句"><code>if</code>语句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件式</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    执行文1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    执行文2</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件式; <span class="keyword">then</span></span><br><span class="line">    执行文1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    执行文2</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="case语句"><code>case</code>语句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> 式 <span class="keyword">in</span></span><br><span class="line">    值1)</span><br><span class="line">        执行文1 ;;</span><br><span class="line">    值2)</span><br><span class="line">        执行文2 ;;</span><br><span class="line">    *)</span><br><span class="line">        执行其他文 ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>注意：每个 <code>执行文</code> 后面要有 <code>;;</code>，并且最后使用 <code>esac</code> 结束。</p><h3 id="for循环"><code>for</code>循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量名 <span class="keyword">in</span> 变量值列表</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    执行文</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> Vine SUSE Gentoo</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$var</span> Linux</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>变量值列表可以通过空格分隔，也可以使用 <code>seq</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `<span class="built_in">seq</span> 10 15`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="while循环"><code>while</code>循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件文</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    执行文</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="read命令"><code>read</code>命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&#x27;Who are you?:&#x27;</span></span><br><span class="line"><span class="built_in">read</span> username</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$username</span>!&quot;</span></span><br></pre></td></tr></table></figure><ul><li>如果 <code>echo</code> 后面跟 <code>-n</code>，则输入的提示信息和用户输入将在同一行显示。</li></ul><h2 id="指定执行Shell类型">指定执行Shell类型</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure><p>此行用于指定脚本执行时使用的Shell解释器。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.文件系统与存储管理</title>
      <link href="/2020/05/08/linux/5-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/05/08/linux/5-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-磁盘配额管理">1. 磁盘配额管理</h2><h3 id="1-1-配额概念与类型">1.1 配额概念与类型</h3><h4 id="配额类型说明">配额类型说明</h4><ul><li><strong>硬限制(Hard Limit)</strong>：用户绝对不能超过的磁盘空间限制</li><li><strong>软限制(Soft Limit)</strong>：允许用户暂时超过的限制，系统会发出警告</li><li><strong>宽限期(Grace Period)</strong>：超过软限制后允许保留的时间（默认7天）</li></ul><h3 id="1-2-配额实施完整步骤">1.2 配额实施完整步骤</h3><ol><li><p><strong>修改fstab文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在/etc/fstab中添加usrquota和/或grpquota选项</span></span><br><span class="line">/dev/sda1 /home ext4 defaults,usrquota,grpquota 0 2</span><br></pre></td></tr></table></figure></li><li><p><strong>重新挂载文件系统</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umount /home</span><br><span class="line">mount -o remount /home</span><br></pre></td></tr></table></figure></li><li><p><strong>创建配额文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> /home/aquota.user /home/aquota.group</span><br><span class="line"><span class="built_in">chmod</span> 600 /home/aquota.*</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化配额数据库</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quotacheck -cugm /home</span><br></pre></td></tr></table></figure></li><li><p><strong>启用配额系统</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quotaon -avug</span><br></pre></td></tr></table></figure></li><li><p><strong>为用户设置配额</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edquota username</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-3-配额管理命令详解">1.3 配额管理命令详解</h3><h4 id="quota-显示配额信息">quota - 显示配额信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quota -u username  <span class="comment"># 显示用户配额</span></span><br><span class="line">quota -g groupname <span class="comment"># 显示组配额</span></span><br><span class="line">quota -v           <span class="comment"># 显示详细信息</span></span><br></pre></td></tr></table></figure><h4 id="quotacheck-检查配额">quotacheck - 检查配额</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quotacheck -avug  <span class="comment"># 检查所有文件系统配额</span></span><br><span class="line">quotacheck -cug /home  <span class="comment"># 检查指定文件系统</span></span><br></pre></td></tr></table></figure><h4 id="quotaon-quotaoff-启用-禁用配额">quotaon/quotaoff - 启用/禁用配额</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quotaon -avug     <span class="comment"># 启用所有配额</span></span><br><span class="line">quotaoff /home    <span class="comment"># 禁用指定文件系统配额</span></span><br></pre></td></tr></table></figure><h4 id="edquota-编辑配额">edquota - 编辑配额</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">edquota -u username  <span class="comment"># 编辑用户配额</span></span><br><span class="line">edquota -p template_user new_user  <span class="comment"># 复制配额设置</span></span><br><span class="line">edquota -t           <span class="comment"># 修改宽限期</span></span><br></pre></td></tr></table></figure><h4 id="repquota-报告配额状态">repquota - 报告配额状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repquota -a       <span class="comment"># 报告所有文件系统配额状态</span></span><br><span class="line">repquota -u /home <span class="comment"># 报告/home的用户配额</span></span><br></pre></td></tr></table></figure><h2 id="2-文件系统层次标准-FHS">2. 文件系统层次标准(FHS)</h2><h3 id="2-1-核心目录结构">2.1 核心目录结构</h3><table><thead><tr><th>目录</th><th>完整描述</th><th>典型内容</th></tr></thead><tbody><tr><td><code>/bin</code></td><td>基础命令二进制文件</td><td>ls, cp, mv等基本命令</td></tr><tr><td><code>/sbin</code></td><td>系统管理二进制文件</td><td>fdisk, fsck, ifconfig等</td></tr><tr><td><code>/etc</code></td><td>系统配置文件</td><td>passwd, fstab, network等配置文件</td></tr><tr><td><code>/dev</code></td><td>设备文件</td><td>sda, tty, null等设备节点</td></tr><tr><td><code>/lib</code></td><td>系统库文件</td><td>系统运行所需共享库</td></tr><tr><td><code>/mnt</code></td><td>临时挂载点</td><td>临时挂载文件系统的目录</td></tr><tr><td><code>/opt</code></td><td>可选应用软件包</td><td>第三方应用程序</td></tr><tr><td><code>/proc</code></td><td>进程和内核信息</td><td>虚拟文件系统，提供系统信息</td></tr><tr><td><code>/root</code></td><td>root用户主目录</td><td>root用户的个人文件和配置</td></tr><tr><td><code>/boot</code></td><td>启动加载文件</td><td>vmlinuz, initramfs, grub等</td></tr><tr><td><code>/home</code></td><td>用户主目录</td><td>普通用户的个人目录</td></tr><tr><td><code>/tmp</code></td><td>临时文件</td><td>系统重启后通常清空</td></tr><tr><td><code>/var</code></td><td>可变数据文件</td><td>日志、邮件、数据库等</td></tr><tr><td><code>/usr</code></td><td>用户程序资源</td><td>应用程序、文档、库文件等</td></tr></tbody></table><h2 id="3-分区与文件系统管理">3. 分区与文件系统管理</h2><h3 id="3-1-分区管理">3.1 分区管理</h3><h4 id="fdisk-完整操作流程">fdisk 完整操作流程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure><p>交互命令列表：</p><ul><li><code>n</code>：创建新分区</li><li><code>d</code>：删除分区</li><li><code>p</code>：显示分区表</li><li><code>t</code>：更改分区类型</li><li><code>a</code>：切换启动标志</li><li><code>w</code>：写入并退出</li><li><code>q</code>：不保存退出</li><li><code>m</code>：显示帮助菜单</li></ul><h3 id="3-2-文件系统创建与管理">3.2 文件系统创建与管理</h3><h4 id="mkfs-命令集">mkfs 命令集</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t ext4 /dev/sdb1      <span class="comment"># 创建ext4文件系统</span></span><br><span class="line">mkfs.ext4 /dev/sdb1         <span class="comment"># 同上</span></span><br><span class="line">mkfs.xfs /dev/sdb2          <span class="comment"># 创建XFS文件系统</span></span><br><span class="line">mkfs.btrfs /dev/sdb3        <span class="comment"># 创建Btrfs文件系统</span></span><br></pre></td></tr></table></figure><h4 id="交换空间管理">交换空间管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkswap /dev/sdb4            <span class="comment"># 创建交换分区</span></span><br><span class="line">swapon /dev/sdb4            <span class="comment"># 启用交换分区</span></span><br><span class="line">swapon -s                   <span class="comment"># 显示交换空间状态</span></span><br><span class="line">swapoff /dev/sdb4           <span class="comment"># 禁用交换分区</span></span><br></pre></td></tr></table></figure><h3 id="3-3-文件系统检查与维护">3.3 文件系统检查与维护</h3><h4 id="fsck-系列命令">fsck 系列命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fsck /dev/sdb1              <span class="comment"># 基本文件系统检查</span></span><br><span class="line">fsck -y /dev/sdb1           <span class="comment"># 自动修复错误</span></span><br><span class="line">e2fsck -p /dev/sdb1         <span class="comment"># ext文件系统自动修复</span></span><br><span class="line">xfs_repair /dev/sdb2        <span class="comment"># XFS文件系统修复</span></span><br></pre></td></tr></table></figure><h4 id="tune2fs-调整参数">tune2fs 调整参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tune2fs -c 30 /dev/sdb1     <span class="comment"># 设置每30次挂载后检查</span></span><br><span class="line">tune2fs -i 15d /dev/sdb1    <span class="comment"># 设置15天间隔检查</span></span><br><span class="line">tune2fs -L DATA /dev/sdb1   <span class="comment"># 设置卷标为DATA</span></span><br></pre></td></tr></table></figure><h3 id="3-4-空间监控命令">3.4 空间监控命令</h3><h4 id="df-详细用法">df 详细用法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h                       <span class="comment"># 人类可读格式</span></span><br><span class="line"><span class="built_in">df</span> -i                       <span class="comment"># 显示inode使用情况</span></span><br><span class="line"><span class="built_in">df</span> -T                       <span class="comment"># 显示文件系统类型</span></span><br><span class="line"><span class="built_in">df</span> --total                  <span class="comment"># 显示总计信息</span></span><br></pre></td></tr></table></figure><h4 id="du-详细用法">du 详细用法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh /var/log             <span class="comment"># 显示目录总大小</span></span><br><span class="line"><span class="built_in">du</span> -ah /home                <span class="comment"># 显示所有文件和目录大小</span></span><br><span class="line"><span class="built_in">du</span> -csh *                   <span class="comment"># 显示当前目录各项目大小和总计</span></span><br><span class="line"><span class="built_in">du</span> --max-depth=1 /usr       <span class="comment"># 只显示一级子目录大小</span></span><br></pre></td></tr></table></figure><h2 id="4-文件搜索命令">4. 文件搜索命令</h2><h3 id="4-1-find-命令完整用法">4.1 find 命令完整用法</h3><h4 id="基本语法">基本语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [路径] [选项] [操作]</span><br></pre></td></tr></table></figure><h4 id="常用示例">常用示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find / -name <span class="string">&quot;*.conf&quot;</span>               <span class="comment"># 按名称查找</span></span><br><span class="line">find /home -user alice              <span class="comment"># 按属主查找</span></span><br><span class="line">find /var/log -mtime -7             <span class="comment"># 查找7天内修改的文件</span></span><br><span class="line">find /tmp -size +10M                <span class="comment"># 查找大于10MB的文件</span></span><br><span class="line">find . -perm 644                    <span class="comment"># 查找权限为644的文件</span></span><br><span class="line">find /etc -<span class="built_in">type</span> f -<span class="built_in">exec</span> grep -l <span class="string">&quot;error&quot;</span> &#123;&#125; \;  <span class="comment"># 结合grep</span></span><br></pre></td></tr></table></figure><h3 id="4-2-locate-updatedb-系统">4.2 locate/updatedb 系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">locate passwd              <span class="comment"># 快速查找文件</span></span><br><span class="line">updatedb                   <span class="comment"># 更新数据库</span></span><br><span class="line">updatedb -e /mnt           <span class="comment"># 排除/mnt目录</span></span><br></pre></td></tr></table></figure><h3 id="4-3-which-whereis-type">4.3 which/whereis/type</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> <span class="built_in">ls</span>                   <span class="comment"># 查找命令路径</span></span><br><span class="line">whereis python             <span class="comment"># 查找命令相关文件</span></span><br><span class="line"><span class="built_in">type</span> -a <span class="built_in">cd</span>                 <span class="comment"># 显示命令类型</span></span><br></pre></td></tr></table></figure><h2 id="5-挂载管理">5. 挂载管理</h2><h3 id="5-1-挂载选项详解">5.1 挂载选项详解</h3><table><thead><tr><th>选项</th><th>完整描述</th></tr></thead><tbody><tr><td><code>async/sync</code></td><td>异步/同步写入</td></tr><tr><td><code>auto/noauto</code></td><td>是否允许mount -a自动挂载</td></tr><tr><td><code>exec/noexec</code></td><td>是否允许执行二进制文件</td></tr><tr><td><code>ro/rw</code></td><td>只读/读写模式</td></tr><tr><td><code>suid/nosuid</code></td><td>是否允许SUID/SGID</td></tr><tr><td><code>user/nouser</code></td><td>是否允许普通用户挂载</td></tr><tr><td><code>defaults</code></td><td>默认选项(rw,suid,dev,exec,auto,nouser,async)</td></tr></tbody></table><h3 id="5-2-mount-umount-完整用法">5.2 mount/umount 完整用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdb1 /mnt/data           <span class="comment"># 基本挂载</span></span><br><span class="line">mount -o remount,ro /mnt/data       <span class="comment"># 重新挂载为只读</span></span><br><span class="line">mount -t nfs server:/share /mnt/nfs <span class="comment"># 挂载NFS</span></span><br><span class="line">umount /mnt/data                    <span class="comment"># 卸载</span></span><br><span class="line">umount -l /mnt/data                 <span class="comment"># 延迟卸载</span></span><br></pre></td></tr></table></figure><h3 id="5-3-etc-fstab-文件格式">5.3 /etc/fstab 文件格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 设备文件/挂载点/文件系统类型/选项/备份标记/检查顺序</span><br><span class="line">/dev/sdb1  /data  ext4  defaults  0  2</span><br><span class="line">UUID=xxxx  /home  xfs   defaults  0  1</span><br></pre></td></tr></table></figure><h2 id="6-逻辑卷管理-LVM">6. 逻辑卷管理(LVM)</h2><h3 id="6-1-LVM-基本概念">6.1 LVM 基本概念</h3><ol><li><strong>PV(Physical Volume)</strong>：物理卷，实际存储设备</li><li><strong>VG(Volume Group)</strong>：卷组，由PV组成的存储池</li><li><strong>LV(Logical Volume)</strong>：逻辑卷，从VG划分的可挂载空间</li><li><strong>PE(Physical Extent)</strong>：物理块，LVM最小分配单元(默认4MB)</li><li><strong>LE(Logical Extent)</strong>：逻辑块，与PE一一对应</li></ol><h3 id="6-2-LVM-完整操作流程">6.2 LVM 完整操作流程</h3><h4 id="物理卷-PV-管理">物理卷(PV)管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pvcreate /dev/sdb /dev/sdc          <span class="comment"># 创建PV</span></span><br><span class="line">pvdisplay                           <span class="comment"># 显示PV信息</span></span><br><span class="line">pvmove /dev/sdb                     <span class="comment"># 迁移PV数据</span></span><br><span class="line">pvremove /dev/sdb                   <span class="comment"># 删除PV</span></span><br></pre></td></tr></table></figure><h4 id="卷组-VG-管理">卷组(VG)管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vgcreate vg_data /dev/sdb /dev/sdc  <span class="comment"># 创建VG</span></span><br><span class="line">vgextend vg_data /dev/sdd           <span class="comment"># 扩展VG</span></span><br><span class="line">vgreduce vg_data /dev/sdb           <span class="comment"># 缩减VG</span></span><br><span class="line">vgdisplay                           <span class="comment"># 显示VG信息</span></span><br><span class="line">vgremove vg_data                    <span class="comment"># 删除VG</span></span><br></pre></td></tr></table></figure><h4 id="逻辑卷-LV-管理">逻辑卷(LV)管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lvcreate -L 50G -n lv_home vg_data  <span class="comment"># 创建50G逻辑卷</span></span><br><span class="line">lvextend -L +10G /dev/vg_data/lv_home <span class="comment"># 扩展10G</span></span><br><span class="line">lvreduce -L -5G /dev/vg_data/lv_home <span class="comment"># 缩减5G</span></span><br><span class="line">lvresize -L 60G /dev/vg_data/lv_home <span class="comment"># 调整到60G</span></span><br><span class="line">lvdisplay                           <span class="comment"># 显示LV信息</span></span><br><span class="line">lvremove /dev/vg_data/lv_home       <span class="comment"># 删除LV</span></span><br></pre></td></tr></table></figure><h4 id="文件系统扩展">文件系统扩展</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于ext2/3/4文件系统</span></span><br><span class="line">resize2fs /dev/vg_data/lv_home</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于XFS文件系统</span></span><br><span class="line">xfs_growfs /dev/vg_data/lv_home</span><br></pre></td></tr></table></figure><h3 id="6-3-LVM-快照功能">6.3 LVM 快照功能</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lvcreate -L 10G -s -n snap_home /dev/vg_data/lv_home  <span class="comment"># 创建快照</span></span><br><span class="line">mount /dev/vg_data/snap_home /mnt/snapshot           <span class="comment"># 挂载快照</span></span><br><span class="line">umount /mnt/snapshot                                 <span class="comment"># 卸载快照</span></span><br><span class="line">lvremove /dev/vg_data/snap_home                      <span class="comment"># 删除快照</span></span><br></pre></td></tr></table></figure><h3 id="6-4-LVM-信息查看命令">6.4 LVM 信息查看命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pvs        <span class="comment"># 简要PV信息</span></span><br><span class="line">vgs        <span class="comment"># 简要VG信息</span></span><br><span class="line">lvs        <span class="comment"># 简要LV信息</span></span><br><span class="line">pvdisplay  <span class="comment"># 详细PV信息</span></span><br><span class="line">vgdisplay  <span class="comment"># 详细VG信息</span></span><br><span class="line">lvdisplay  <span class="comment"># 详细LV信息</span></span><br><span class="line">lsblk      <span class="comment"># 块设备层次结构</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.文件和程序管理</title>
      <link href="/2020/05/08/linux/4-%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"/>
      <url>/2020/05/08/linux/4-%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-用户权限管理">1. 用户权限管理</h2><h3 id="1-1-文件权限基础">1.1 文件权限基础</h3><h4 id="权限表示法">权限表示法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d rwx r-x r--</span><br><span class="line">↑ ↑   ↑   ↑</span><br><span class="line">│ │   │   └─ 其他用户权限(r--)</span><br><span class="line">│ │   └─── 所属组权限(r-x)</span><br><span class="line">│ └────── 所有者权限(rwx)</span><br><span class="line">└──────── 文件类型(d=目录)</span><br></pre></td></tr></table></figure><h4 id="权限数值">权限数值</h4><ul><li>r(读): 4</li><li>w(写): 2</li><li>x(执行): 1</li></ul><h3 id="1-2-chmod-命令">1.2 chmod 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [选项] 权限 文件</span><br></pre></td></tr></table></figure><h4 id="常用选项">常用选项</h4><ul><li><code>-R</code>: 递归修改目录下所有文件</li></ul><h4 id="权限设置方法">权限设置方法</h4><ol><li><p><strong>符号法</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+x file      <span class="comment"># 给所有者添加执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> g-w file      <span class="comment"># 移除组的写权限</span></span><br><span class="line"><span class="built_in">chmod</span> o=rx file     <span class="comment"># 设置其他用户为读执行</span></span><br><span class="line"><span class="built_in">chmod</span> a+r file      <span class="comment"># 给所有用户添加读权限</span></span><br></pre></td></tr></table></figure></li><li><p><strong>数字法</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 755 file      <span class="comment"># rwxr-xr-x</span></span><br><span class="line"><span class="built_in">chmod</span> 644 file      <span class="comment"># rw-r--r--</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="1-3-特殊权限">1.3 特殊权限</h3><table><thead><tr><th>权限</th><th>数值</th><th>设置方法</th><th>说明</th></tr></thead><tbody><tr><td>SUID</td><td>4000</td><td><code>u+s</code></td><td>执行时以文件所有者权限运行</td></tr><tr><td>SGID</td><td>2000</td><td><code>g+s</code></td><td>执行时以文件所属组权限运行</td></tr><tr><td>Sticky</td><td>1000</td><td><code>o+t</code></td><td>目录中文件只有所有者能删除</td></tr></tbody></table><h3 id="1-4-umask-命令">1.4 umask 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">umask</span>           <span class="comment"># 查看当前umask值</span></span><br><span class="line"><span class="built_in">umask</span> 022       <span class="comment"># 设置新的umask值</span></span><br></pre></td></tr></table></figure><ul><li>文件默认权限: <code>666 - umask</code></li><li>目录默认权限: <code>777 - umask</code></li></ul><h3 id="1-5-ACL-高级权限控制">1.5 ACL 高级权限控制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setfacl -m u:user:rwx file   <span class="comment"># 添加用户ACL</span></span><br><span class="line">setfacl -x u:user file       <span class="comment"># 删除用户ACL</span></span><br><span class="line">getfacl file                 <span class="comment"># 查看ACL权限</span></span><br></pre></td></tr></table></figure><h3 id="1-6-所有权管理">1.6 所有权管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> user:group file        <span class="comment"># 修改所有者和组</span></span><br><span class="line"><span class="built_in">chown</span> -R user:group <span class="built_in">dir</span>      <span class="comment"># 递归修改</span></span><br><span class="line"><span class="built_in">chgrp</span> group file             <span class="comment"># 修改文件所属组</span></span><br></pre></td></tr></table></figure><h2 id="2-链接管理">2. 链接管理</h2><h3 id="2-1-链接类型对比">2.1 链接类型对比</h3><table><thead><tr><th>特性</th><th>硬链接</th><th>软链接</th></tr></thead><tbody><tr><td>inode</td><td>相同</td><td>不同</td></tr><tr><td>跨文件系统</td><td>不支持</td><td>支持</td></tr><tr><td>链接目录</td><td>不允许</td><td>允许</td></tr><tr><td>原文件删除</td><td>仍可访问</td><td>失效</td></tr></tbody></table><h3 id="2-2-ln-命令">2.2 ln 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> <span class="built_in">source</span> <span class="built_in">link</span>        <span class="comment"># 创建硬链接</span></span><br><span class="line"><span class="built_in">ln</span> -s <span class="built_in">source</span> <span class="built_in">link</span>     <span class="comment"># 创建软链接</span></span><br></pre></td></tr></table></figure><h2 id="3-进程管理">3. 进程管理</h2><h3 id="3-1-ps-命令">3.1 ps 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps aux       <span class="comment"># 查看所有进程</span></span><br><span class="line">ps -ef       <span class="comment"># 完整格式显示</span></span><br><span class="line">ps -u user   <span class="comment"># 查看指定用户进程</span></span><br></pre></td></tr></table></figure><h3 id="3-2-top-命令">3.2 top 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top          <span class="comment"># 动态查看进程</span></span><br></pre></td></tr></table></figure><ul><li><code>r</code>: 调整进程优先级</li><li><code>k</code>: 终止进程</li><li><code>q</code>: 退出</li></ul><h3 id="3-3-进程控制">3.3 进程控制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 PID          <span class="comment"># 强制终止进程</span></span><br><span class="line">killall process      <span class="comment"># 终止同名所有进程</span></span><br><span class="line">pkill pattern        <span class="comment"># 按模式终止进程</span></span><br></pre></td></tr></table></figure><h4 id="常用信号">常用信号</h4><table><thead><tr><th>信号</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>HUP</td><td>1</td><td>重新加载配置</td></tr><tr><td>INT</td><td>2</td><td>中断(Ctrl+C)</td></tr><tr><td>KILL</td><td>9</td><td>强制终止</td></tr><tr><td>TERM</td><td>15</td><td>正常终止</td></tr></tbody></table><h3 id="3-4-作业控制">3.4 作业控制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &amp;       <span class="comment"># 后台运行</span></span><br><span class="line"><span class="built_in">fg</span> %1          <span class="comment"># 前台恢复作业1</span></span><br><span class="line"><span class="built_in">bg</span> %2          <span class="comment"># 后台继续作业2</span></span><br><span class="line"><span class="built_in">jobs</span>           <span class="comment"># 查看后台作业</span></span><br></pre></td></tr></table></figure><h3 id="3-5-优先级管理">3.5 优先级管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nice</span> -n 10 <span class="built_in">command</span>   <span class="comment"># 启动低优先级进程</span></span><br><span class="line">renice 15 -p PID     <span class="comment"># 调整运行中进程优先级</span></span><br></pre></td></tr></table></figure><h3 id="3-6-终端复用器">3.6 终端复用器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux                <span class="comment"># 启动新会话</span></span><br></pre></td></tr></table></figure><p>常用快捷键:</p><ul><li><code>Ctrl+b c</code>: 新建窗口</li><li><code>Ctrl+b %</code>: 垂直分割</li><li><code>Ctrl+b &quot;</code>: 水平分割</li><li><code>Ctrl+b d</code>: 分离会话</li></ul><h2 id="4-压缩与归档">4. 压缩与归档</h2><h3 id="4-1-单文件压缩">4.1 单文件压缩</h3><h4 id="gzip">gzip</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gzip file            <span class="comment"># 压缩为file.gz</span></span><br><span class="line">gunzip file.gz       <span class="comment"># 解压</span></span><br><span class="line">gzip -d file.gz      <span class="comment"># 解压(同上)</span></span><br></pre></td></tr></table></figure><h4 id="bzip2">bzip2</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bzip2 file           <span class="comment"># 压缩为file.bz2</span></span><br><span class="line">bunzip2 file.bz2     <span class="comment"># 解压</span></span><br></pre></td></tr></table></figure><h4 id="xz">xz</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xz file              <span class="comment"># 压缩为file.xz</span></span><br><span class="line">unxz file.xz         <span class="comment"># 解压</span></span><br></pre></td></tr></table></figure><h3 id="4-2-归档工具">4.2 归档工具</h3><h4 id="tar-命令">tar 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打包压缩</span></span><br><span class="line">tar czvf archive.tar.gz <span class="built_in">dir</span>/     <span class="comment"># gzip压缩</span></span><br><span class="line">tar cjvf archive.tar.bz2 <span class="built_in">dir</span>/    <span class="comment"># bzip2压缩</span></span><br><span class="line">tar cJvf archive.tar.xz <span class="built_in">dir</span>/     <span class="comment"># xz压缩</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar xzvf archive.tar.gz          <span class="comment"># 解压gzip</span></span><br><span class="line">tar xjvf archive.tar.bz2         <span class="comment"># 解压bzip2</span></span><br><span class="line">tar xJvf archive.tar.xz          <span class="comment"># 解压xz</span></span><br></pre></td></tr></table></figure><h4 id="cpio-命令">cpio 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . | cpio -ov &gt; backup.cpio      <span class="comment"># 创建归档</span></span><br><span class="line">cpio -idv &lt; backup.cpio              <span class="comment"># 解压归档</span></span><br></pre></td></tr></table></figure><h4 id="dd-命令">dd 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sda of=disk.img bs=1M     <span class="comment"># 创建磁盘映像</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=disk.img of=/dev/sdb           <span class="comment"># 恢复磁盘映像</span></span><br></pre></td></tr></table></figure><h2 id="5-实用技巧">5. 实用技巧</h2><h3 id="5-1-nohup-命令">5.1 nohup 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> <span class="built_in">command</span> &amp;      <span class="comment"># 退出终端后继续运行</span></span><br></pre></td></tr></table></figure><h3 id="5-2-watch-命令">5.2 watch 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 5 <span class="string">&#x27;ls -l&#x27;</span>   <span class="comment"># 每5秒执行一次命令</span></span><br></pre></td></tr></table></figure><h3 id="5-3-文件传输">5.3 文件传输</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=file.iso | ssh user@host <span class="string">&quot;dd of=file.iso&quot;</span>  <span class="comment"># 通过SSH传输文件</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.bash</title>
      <link href="/2020/05/07/linux/3-bash/"/>
      <url>/2020/05/07/linux/3-bash/</url>
      
        <content type="html"><![CDATA[<h1>Bash 命令与 Shell 使用指南</h1><h2 id="1-命令组合与控制">1. 命令组合与控制</h2><h3 id="1-1-命令组合方式">1.1 命令组合方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命令1 ; 命令2    <span class="comment"># 无论命令1成功与否，都会执行命令2</span></span><br><span class="line">命令1 &amp;&amp; 命令2   <span class="comment"># 只有命令1成功执行(返回0)才会执行命令2</span></span><br><span class="line">命令1 || 命令2   <span class="comment"># 只有命令1执行失败(非0)才会执行命令2</span></span><br></pre></td></tr></table></figure><h3 id="1-2-引用符号">1.2 引用符号</h3><table><thead><tr><th>符号</th><th>名称</th><th>功能说明</th></tr></thead><tbody><tr><td><code>'</code></td><td>单引号</td><td>内部所有内容视为纯文本，不解释变量和特殊字符</td></tr><tr><td><code>&quot;</code></td><td>双引号</td><td>会解释$、`和\等特殊字符，变量会被展开</td></tr><tr><td><code>`</code></td><td>反引号</td><td>执行内部命令并将结果替换到当前位置(等同于<code>$(命令)</code>语法)</td></tr></tbody></table><h2 id="2-命令历史">2. 命令历史</h2><h3 id="2-1-history-命令">2.1 history 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span>        <span class="comment"># 显示命令历史记录</span></span><br><span class="line">!5            <span class="comment"># 执行历史记录中第5条命令</span></span><br><span class="line">!<span class="built_in">ls</span>           <span class="comment"># 执行最近以ls开头的命令</span></span><br><span class="line">!?config      <span class="comment"># 执行最近包含config的命令</span></span><br></pre></td></tr></table></figure><h3 id="2-2-历史记录管理">2.2 历史记录管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> -c    <span class="comment"># 清除当前shell的历史记录</span></span><br><span class="line"><span class="built_in">history</span> -d 10 <span class="comment"># 删除第10条历史记录</span></span><br></pre></td></tr></table></figure><h3 id="2-3-相关环境变量">2.3 相关环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HISTSIZE=1000       <span class="comment"># 内存中保存的历史记录数量</span></span><br><span class="line">HISTFILESIZE=2000   <span class="comment"># 历史记录文件保存的最大数量</span></span><br><span class="line">HISTFILE=~/.bash_history  <span class="comment"># 历史记录文件路径</span></span><br></pre></td></tr></table></figure><h2 id="3-Shell-类型与快捷键">3. Shell 类型与快捷键</h2><h3 id="3-1-常见Shell类型">3.1 常见Shell类型</h3><ul><li><strong>Bourne Shell(sh)</strong>: 经典Unix shell → 衍生出bash</li><li><strong>Bash(Bourne-Again Shell)</strong>: Linux默认shell</li><li><strong>C Shell(csh)</strong>: 类C语法 → 衍生出tcsh</li><li><strong>Korn Shell(ksh)</strong>: 结合sh和csh优点</li><li><strong>Z Shell(zsh)</strong>: 功能强大的现代shell</li></ul><h3 id="3-2-常用快捷键">3.2 常用快捷键</h3><table><thead><tr><th>快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>Tab</td><td>命令/文件名自动补全</td></tr><tr><td>Ctrl+A</td><td>移动到行首</td></tr><tr><td>Ctrl+E</td><td>移动到行尾</td></tr><tr><td>Ctrl+D</td><td>删除当前字符(相当于Delete)</td></tr><tr><td>Ctrl+H</td><td>删除前一个字符(相当于Backspace)</td></tr><tr><td>Ctrl+L</td><td>清屏(等同于clear命令)</td></tr><tr><td>Ctrl+C</td><td>终止当前命令</td></tr><tr><td>Ctrl+Z</td><td>暂停当前命令(可用fg恢复)</td></tr><tr><td>Ctrl+S</td><td>暂停屏幕输出</td></tr><tr><td>Ctrl+Q</td><td>恢复屏幕输出</td></tr></tbody></table><h2 id="4-变量与环境设置">4. 变量与环境设置</h2><h3 id="4-1-变量操作">4.1 变量操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> VAR=value    <span class="comment"># 设置环境变量(对新shell有效)</span></span><br><span class="line"><span class="built_in">unset</span> VAR           <span class="comment"># 删除变量</span></span><br><span class="line">PATH=<span class="variable">$PATH</span>:/new/path <span class="comment"># 追加PATH路径</span></span><br></pre></td></tr></table></figure><h3 id="4-2-set-命令选项">4.2 set 命令选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -o option      <span class="comment"># 启用选项</span></span><br><span class="line"><span class="built_in">set</span> +o option      <span class="comment"># 禁用选项</span></span><br></pre></td></tr></table></figure><p>常用选项：</p><ul><li><code>noclobber</code>/<code>-C</code>: 防止重定向覆盖已有文件</li><li><code>histexpand</code>/<code>-H</code>: 启用<code>!</code>历史命令扩展</li></ul><h3 id="4-3-提示符定制-PS1">4.3 提示符定制(PS1)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS1=<span class="string">&#x27;[\u@\h \W]\$ &#x27;</span>  <span class="comment"># 常见默认提示符格式</span></span><br></pre></td></tr></table></figure><p>可用转义符：</p><ul><li><code>\s</code>: shell名称</li><li><code>\v</code>: bash版本</li><li><code>\u</code>: 用户名</li><li><code>\h</code>: 主机名</li><li><code>\w</code>: 当前工作目录</li></ul><h3 id="4-4-用户切换">4.4 用户切换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su user       <span class="comment"># 切换用户(不改变环境变量)</span></span><br><span class="line">su - user     <span class="comment"># 完全切换用户(包括环境)</span></span><br></pre></td></tr></table></figure><h2 id="5-帮助命令-man-详解">5.帮助命令 <code>man</code> 详解</h2><h3 id="基本用法">基本用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man <span class="built_in">command</span>      <span class="comment"># 查看命令的手册页(返回第一个匹配的帮助文件)</span></span><br></pre></td></tr></table></figure><h3 id="常用选项">常用选项</h3><table><thead><tr><th>选项</th><th>功能说明</th><th>等价命令</th></tr></thead><tbody><tr><td><code>-a</code></td><td>显示所有匹配的手册页(按顺序显示)</td><td>-</td></tr><tr><td><code>-f</code></td><td>查找完全匹配的命令文档</td><td><code>whatis</code></td></tr><tr><td><code>-k</code></td><td>查找包含关键词的文档</td><td><code>apropos</code></td></tr><tr><td><code>-w</code></td><td>显示手册页的存储路径</td><td>-</td></tr></tbody></table><h3 id="指定手册章节">指定手册章节</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">man 5 passwd     <span class="comment"># 查看/etc/passwd文件的格式说明(第5节)</span></span><br><span class="line">man 3 <span class="built_in">printf</span>     <span class="comment"># 查看C库函数printf的文档(第3节)</span></span><br></pre></td></tr></table></figure><h3 id="手册章节分类">手册章节分类</h3><table><thead><tr><th>Section</th><th>内容类型</th></tr></thead><tbody><tr><td>1</td><td>用户命令</td></tr><tr><td>2</td><td>系统调用</td></tr><tr><td>3</td><td>C库函数</td></tr><tr><td>4</td><td>设备文件</td></tr><tr><td>5</td><td>配置文件格式</td></tr><tr><td>6</td><td>游戏</td></tr><tr><td>7</td><td>杂项</td></tr><tr><td>8</td><td>系统管理命令</td></tr><tr><td>9</td><td>Linux内核相关</td></tr></tbody></table><h3 id="手册页存储位置">手册页存储位置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/man         <span class="comment"># 系统手册页主目录</span></span><br><span class="line">/usr/local/share/man   <span class="comment"># 本地安装软件的手册页</span></span><br></pre></td></tr></table></figure><h3 id="维护whatis数据库">维护whatis数据库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">makewhatis            <span class="comment"># 生成/更新whatis数据库(供-f/-k使用)</span></span><br><span class="line">mandb                 <span class="comment"># 现代系统中更新手册数据库(替代makewhatis)</span></span><br></pre></td></tr></table></figure><h3 id="使用示例">使用示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">man -a <span class="built_in">printf</span>        <span class="comment"># 查看所有章节的printf文档</span></span><br><span class="line">man -k <span class="string">&quot;copy&quot;</span>        <span class="comment"># 查找所有包含&quot;copy&quot;关键词的命令</span></span><br><span class="line">man -f <span class="built_in">ls</span>            <span class="comment"># 精确查找ls命令的文档</span></span><br><span class="line">man -w 5 passwd      <span class="comment"># 显示passwd配置文件的文档路径</span></span><br></pre></td></tr></table></figure><h2 id="6-管道与重定向">6. 管道与重定向</h2><h3 id="6-1-标准文件描述符">6.1 标准文件描述符</h3><table><thead><tr><th>文件描述符</th><th>名称</th><th>默认设备</th></tr></thead><tbody><tr><td>0</td><td>标准输入(stdin)</td><td>键盘</td></tr><tr><td>1</td><td>标准输出(stdout)</td><td>屏幕</td></tr><tr><td>2</td><td>标准错误(stderr)</td><td>屏幕</td></tr></tbody></table><h3 id="6-2-管道">6.2 管道(|)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令1 | 命令2    <span class="comment"># 将命令1的输出作为命令2的输入</span></span><br></pre></td></tr></table></figure><h3 id="6-3-tee命令">6.3 tee命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令 | <span class="built_in">tee</span> 文件    <span class="comment"># 同时输出到屏幕和文件</span></span><br><span class="line">命令 | <span class="built_in">tee</span> -a 文件 <span class="comment"># 追加模式(不覆盖原文件)</span></span><br></pre></td></tr></table></figure><h3 id="6-4-重定向操作">6.4 重定向操作</h3><table><thead><tr><th>语法</th><th>功能描述</th></tr></thead><tbody><tr><td><code>命令 &gt; 文件</code></td><td>标准输出覆盖写入文件</td></tr><tr><td><code>命令 &gt;&gt; 文件</code></td><td>标准输出追加写入文件</td></tr><tr><td><code>命令 &lt; 文件</code></td><td>从文件读取标准输入</td></tr><tr><td><code>命令 2&gt; 文件</code></td><td>标准错误覆盖写入文件</td></tr><tr><td><code>命令 2&gt;&gt; 文件</code></td><td>标准错误追加写入文件</td></tr><tr><td><code>命令 &gt; 文件 2&gt;&amp;1</code></td><td>标准输出和错误都覆盖写入同一文件</td></tr><tr><td><code>命令 &gt;&gt; 文件 2&gt;&amp;1</code></td><td>标准输出和错误都追加写入同一文件</td></tr><tr><td><code>命令 &lt;&lt; 结束标记</code></td><td>从标准输入读取直到遇到&quot;结束标记&quot;(here文档)</td></tr><tr><td><code>命令 &amp;&gt; 文件</code></td><td>标准输出和错误都覆盖写入文件(bash简写)</td></tr></tbody></table><h2 id="7-文件操作命令">7. 文件操作命令</h2><h3 id="7-1-ls命令">7.1 ls命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -a    <span class="comment"># 显示所有文件(包括.开头的隐藏文件)</span></span><br><span class="line"><span class="built_in">ls</span> -A    <span class="comment"># 类似-a但不显示.和..</span></span><br><span class="line"><span class="built_in">ls</span> -d    <span class="comment"># 显示目录本身而非内容</span></span><br><span class="line"><span class="built_in">ls</span> -F    <span class="comment"># 显示文件类型标识(/:目录, *:可执行, @:链接)</span></span><br><span class="line"><span class="built_in">ls</span> -i    <span class="comment"># 显示inode编号</span></span><br><span class="line"><span class="built_in">ls</span> -l    <span class="comment"># 长格式显示详细信息</span></span><br><span class="line"><span class="built_in">ls</span> -t    <span class="comment"># 按修改时间排序</span></span><br><span class="line"><span class="built_in">ls</span> -h    <span class="comment"># 人类可读的文件大小(如1K, 2M)</span></span><br></pre></td></tr></table></figure><h3 id="7-2-cp命令">7.2 cp命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -f    <span class="comment"># 强制覆盖不提示</span></span><br><span class="line"><span class="built_in">cp</span> -i    <span class="comment"># 覆盖前提示确认</span></span><br><span class="line"><span class="built_in">cp</span> -p    <span class="comment"># 保留原文件属性</span></span><br><span class="line"><span class="built_in">cp</span> -r/R  <span class="comment"># 递归复制目录</span></span><br><span class="line"><span class="built_in">cp</span> -d    <span class="comment"># 保留链接文件</span></span><br><span class="line"><span class="built_in">cp</span> -a    <span class="comment"># 归档模式(相当于-dpR)</span></span><br></pre></td></tr></table></figure><h3 id="7-3-mv命令">7.3 mv命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> -f    <span class="comment"># 强制覆盖不提示</span></span><br><span class="line"><span class="built_in">mv</span> -i    <span class="comment"># 覆盖前提示确认</span></span><br></pre></td></tr></table></figure><h3 id="7-4-mkdir命令">7.4 mkdir命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -m 755 <span class="built_in">dir</span>   <span class="comment"># 创建指定权限的目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p dir1/dir2 <span class="comment"># 创建多级目录</span></span><br></pre></td></tr></table></figure><h3 id="7-5-rm命令">7.5 rm命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f    <span class="comment"># 强制删除不提示</span></span><br><span class="line"><span class="built_in">rm</span> -i    <span class="comment"># 删除前提示确认</span></span><br><span class="line"><span class="built_in">rm</span> -r/R  <span class="comment"># 递归删除目录</span></span><br></pre></td></tr></table></figure><h3 id="7-6-rmdir命令">7.6 rmdir命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> -p dir1/dir2 <span class="comment"># 删除多级空目录</span></span><br></pre></td></tr></table></figure><h3 id="7-7-touch命令">7.7 touch命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> -t 202405071530.00 file  <span class="comment"># 设置特定时间戳(YYMMDDhhmm.ss)</span></span><br><span class="line"><span class="built_in">touch</span> -a file       <span class="comment"># 仅更新访问时间</span></span><br><span class="line"><span class="built_in">touch</span> -m file       <span class="comment"># 仅更新修改时间</span></span><br></pre></td></tr></table></figure><h3 id="7-8-file命令">7.8 file命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file document.txt   <span class="comment"># 检测文件类型和编码</span></span><br></pre></td></tr></table></figure><h2 id="8-元字符-通配符">8. 元字符(通配符)</h2><table><thead><tr><th>元字符</th><th>功能描述</th><th>示例</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配任意长度字符(包括空字符)</td><td><code>ls *.txt</code></td></tr><tr><td><code>?</code></td><td>匹配任意单个字符</td><td><code>ls file?.txt</code></td></tr><tr><td><code>[]</code></td><td>匹配括号内任意一个字符</td><td><code>ls file[123].txt</code></td></tr><tr><td><code>[!]</code></td><td>匹配不在括号内的任意一个字符</td><td><code>ls file[!a-z].txt</code></td></tr><tr><td><code>&#123;&#125;</code></td><td>展开括号内逗号分隔的多个模式</td><td><code>touch file&#123;1,2,3&#125;</code></td></tr></tbody></table><p>示例扩展：</p><ul><li><code>[a-z]</code>: 任意小写字母</li><li><code>[0-9]</code>: 任意数字</li><li><code>[a-zA-Z]</code>: 任意字母</li><li><code>file&#123;1..3&#125;</code>: 展开为file1, file2, file3</li></ul><h2 id="9-文档处理命令">9. 文档处理命令</h2><h3 id="9-1-文件内容查看">9.1 文件内容查看</h3><h4 id="cat-命令">cat 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> -n file.txt  <span class="comment"># 显示文件内容并添加行号</span></span><br></pre></td></tr></table></figure><h4 id="nl-命令（行号显示）">nl 命令（行号显示）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nl</span> -b a file.txt    <span class="comment"># 所有行添加行号</span></span><br><span class="line"><span class="built_in">nl</span> -b t file.txt    <span class="comment"># 非空行添加行号</span></span><br><span class="line"><span class="built_in">nl</span> -h a -f a file.txt  <span class="comment"># 为页眉和页脚也添加行号</span></span><br></pre></td></tr></table></figure><h4 id="od-命令（二进制查看）">od 命令（二进制查看）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">od</span> -t c file.bin    <span class="comment"># 以ASCII字符显示</span></span><br><span class="line"><span class="built_in">od</span> -t o file.bin    <span class="comment"># 以八进制显示</span></span><br><span class="line"><span class="built_in">od</span> -t x file.bin    <span class="comment"># 以十六进制显示</span></span><br></pre></td></tr></table></figure><h3 id="9-2-文件头部-尾部查看">9.2 文件头部/尾部查看</h3><h4 id="head-命令">head 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 10 file.txt    <span class="comment"># 显示前10行</span></span><br><span class="line"><span class="built_in">head</span> -10 file.txt      <span class="comment"># 同上</span></span><br><span class="line"><span class="built_in">head</span> -c 100 file.txt   <span class="comment"># 显示前100字节</span></span><br></pre></td></tr></table></figure><h4 id="tail-命令">tail 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -n 10 file.txt    <span class="comment"># 显示最后10行</span></span><br><span class="line"><span class="built_in">tail</span> -10 file.txt      <span class="comment"># 同上</span></span><br><span class="line"><span class="built_in">tail</span> -c 100 file.txt   <span class="comment"># 显示最后100字节</span></span><br><span class="line"><span class="built_in">tail</span> -f log.txt        <span class="comment"># 实时监控日志文件</span></span><br></pre></td></tr></table></figure><h3 id="9-3-文本提取与转换">9.3 文本提取与转换</h3><h4 id="cut-命令">cut 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cut</span> -c 1-5 file.txt      <span class="comment"># 提取每行第1-5个字符</span></span><br><span class="line"><span class="built_in">cut</span> -d: -f1 /etc/passwd  <span class="comment"># 以冒号分隔，提取第一个字段</span></span><br></pre></td></tr></table></figure><h4 id="join-命令（合并文件）">join 命令（合并文件）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">join</span> -j 1 file1.txt file2.txt  <span class="comment"># 按第一个字段合并两个文件</span></span><br></pre></td></tr></table></figure><h4 id="paste-命令">paste 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">paste</span> -d<span class="string">&quot;;&quot;</span> file1.txt file2.txt  <span class="comment"># 用分号分隔合并文件</span></span><br></pre></td></tr></table></figure><h4 id="tr-命令（字符转换）">tr 命令（字符转换）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tr</span> <span class="string">&#x27;a-z&#x27;</span> <span class="string">&#x27;A-Z&#x27;</span> &lt; file.txt    <span class="comment"># 小写转大写</span></span><br><span class="line"><span class="built_in">tr</span> -d <span class="string">&#x27;\r&#x27;</span> &lt; file.txt        <span class="comment"># 删除回车符</span></span><br><span class="line"><span class="built_in">tr</span> -s <span class="string">&#x27; &#x27;</span> &lt; file.txt         <span class="comment"># 压缩连续空格</span></span><br><span class="line"><span class="built_in">tr</span> -d <span class="string">&#x27;[:digit:]&#x27;</span> &lt; file.txt <span class="comment"># 删除所有数字</span></span><br></pre></td></tr></table></figure><h3 id="9-4-文本排序与统计">9.4 文本排序与统计</h3><h4 id="sort-命令">sort 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span> file.txt          <span class="comment"># 按字母顺序排序</span></span><br><span class="line"><span class="built_in">sort</span> -n file.txt       <span class="comment"># 按数值排序</span></span><br><span class="line"><span class="built_in">sort</span> -r file.txt       <span class="comment"># 反向排序</span></span><br><span class="line"><span class="built_in">sort</span> -t: -k3n /etc/passwd  <span class="comment"># 按冒号分隔的第3列数值排序</span></span><br></pre></td></tr></table></figure><h4 id="uniq-命令（去重）">uniq 命令（去重）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span> file.txt | <span class="built_in">uniq</span>    <span class="comment"># 去重（需先排序）</span></span><br><span class="line"><span class="built_in">uniq</span> -d file.txt        <span class="comment"># 只显示重复行</span></span><br><span class="line"><span class="built_in">uniq</span> -u file.txt        <span class="comment"># 只显示唯一行</span></span><br></pre></td></tr></table></figure><h4 id="wc-命令（统计）">wc 命令（统计）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wc</span> -l file.txt    <span class="comment"># 统计行数</span></span><br><span class="line"><span class="built_in">wc</span> -w file.txt    <span class="comment"># 统计单词数</span></span><br><span class="line"><span class="built_in">wc</span> -c file.txt    <span class="comment"># 统计字节数</span></span><br></pre></td></tr></table></figure><h3 id="9-5-文本分割与格式化">9.5 文本分割与格式化</h3><h4 id="split-命令">split 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> -l 1000 bigfile.txt part_  <span class="comment"># 每1000行分割文件</span></span><br></pre></td></tr></table></figure><h4 id="pr-命令（分页）">pr 命令（分页）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pr</span> -l 40 file.txt    <span class="comment"># 按每页40行分页显示</span></span><br></pre></td></tr></table></figure><h4 id="fmt-命令（格式化）">fmt 命令（格式化）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fmt</span> -w 80 file.txt   <span class="comment"># 设置每行80个字符</span></span><br></pre></td></tr></table></figure><h4 id="expand-unexpand-命令">expand/unexpand 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">expand</span> -t 4 file.txt    <span class="comment"># 将tab转为4个空格</span></span><br><span class="line"><span class="built_in">unexpand</span> -t 4 file.txt  <span class="comment"># 将4个空格转为tab</span></span><br></pre></td></tr></table></figure><h3 id="8-6-高级文本处理">8.6 高级文本处理</h3><h4 id="xargs-命令">xargs 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">&quot;*.log&quot;</span> | xargs <span class="built_in">rm</span>    <span class="comment"># 删除所有log文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f | xargs grep <span class="string">&quot;text&quot;</span> <span class="comment"># 在所有文件中搜索文本</span></span><br></pre></td></tr></table></figure><h2 id="10-vi-vim-编辑器">10. vi/vim 编辑器</h2><h3 id="10-1-基本操作">10.1 基本操作</h3><h4 id="启动与退出">启动与退出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi file.txt        <span class="comment"># 编辑文件</span></span><br><span class="line">vi -R file.txt     <span class="comment"># 只读模式</span></span><br><span class="line">:q                 <span class="comment"># 退出</span></span><br><span class="line">:q!                <span class="comment"># 强制退出</span></span><br><span class="line">:wq 或 ZZ          <span class="comment"># 保存退出</span></span><br></pre></td></tr></table></figure><h4 id="模式切换">模式切换</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>i</td><td>在光标前插入</td></tr><tr><td>a</td><td>在光标后插入</td></tr><tr><td>I</td><td>在行首插入</td></tr><tr><td>A</td><td>在行尾插入</td></tr><tr><td>o</td><td>在下一行插入</td></tr><tr><td>O</td><td>在上一行插入</td></tr><tr><td>ESC</td><td>返回命令模式</td></tr></tbody></table><h3 id="10-2-光标移动">10.2 光标移动</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>h/j/k/l</td><td>左/下/上/右</td></tr><tr><td>0</td><td>行首</td></tr><tr><td>$</td><td>行尾</td></tr><tr><td>gg</td><td>文件开头</td></tr><tr><td>G</td><td>文件末尾</td></tr><tr><td>50G</td><td>跳转到第50行</td></tr><tr><td>Ctrl+b</td><td>上一页</td></tr><tr><td>Ctrl+f</td><td>下一页</td></tr></tbody></table><h3 id="10-3-编辑命令">10.3 编辑命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>x</td><td>删除当前字符</td></tr><tr><td>X</td><td>删除前一个字符</td></tr><tr><td>dd</td><td>删除当前行</td></tr><tr><td>dw</td><td>删除下一个单词</td></tr><tr><td>yy</td><td>复制当前行</td></tr><tr><td>p</td><td>粘贴到光标后</td></tr><tr><td>P</td><td>粘贴到光标前</td></tr><tr><td>u</td><td>撤销</td></tr><tr><td>Ctrl+r</td><td>重做</td></tr></tbody></table><h3 id="10-4-搜索与替换">10.4 搜索与替换</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>/pattern</td><td>向前搜索</td></tr><tr><td>?pattern</td><td>向后搜索</td></tr><tr><td>n</td><td>下一个匹配项</td></tr><tr><td>N</td><td>上一个匹配项</td></tr><tr><td>:%s/old/new/g</td><td>全局替换</td></tr><tr><td>:1,10s/old/new/g</td><td>替换1-10行的内容</td></tr></tbody></table><h3 id="10-5-设置选项">10.5 设置选项</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">set</span> <span class="keyword">nu</span>        # 显示行号</span><br><span class="line">:<span class="keyword">set</span> nonu      # 隐藏行号</span><br><span class="line">:<span class="keyword">set</span> <span class="keyword">ts</span>=<span class="number">4</span>      # 设置<span class="keyword">tab</span>为<span class="number">4</span>个空格</span><br><span class="line">:<span class="keyword">set</span> <span class="keyword">list</span>      # 显示不可见字符</span><br></pre></td></tr></table></figure><h2 id="11-正则表达式与文本搜索">11. 正则表达式与文本搜索</h2><h3 id="11-1-基本元字符">11.1 基本元字符</h3><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配任意单个字符</td></tr><tr><td>*</td><td>前一个字符0次或多次</td></tr><tr><td>[]</td><td>匹配括号内任意一个字符</td></tr><tr><td>[^]</td><td>不匹配括号内的字符</td></tr><tr><td>^</td><td>行首</td></tr><tr><td>$</td><td>行尾</td></tr><tr><td>\</td><td>转义特殊字符</td></tr></tbody></table><h3 id="11-2-grep-命令">11.2 grep 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;pattern&quot;</span> file.txt      <span class="comment"># 基本搜索</span></span><br><span class="line">grep -i <span class="string">&quot;pattern&quot;</span> file.txt   <span class="comment"># 忽略大小写</span></span><br><span class="line">grep -v <span class="string">&quot;pattern&quot;</span> file.txt   <span class="comment"># 反向匹配</span></span><br><span class="line">grep -n <span class="string">&quot;pattern&quot;</span> file.txt   <span class="comment"># 显示行号</span></span><br><span class="line">grep -E <span class="string">&quot;regex&quot;</span> file.txt     <span class="comment"># 使用扩展正则</span></span><br><span class="line">grep -r <span class="string">&quot;pattern&quot;</span> /dir       <span class="comment"># 递归搜索目录</span></span><br></pre></td></tr></table></figure><h4 id="特殊变体">特殊变体</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">egrep = grep -E       <span class="comment"># 扩展正则表达式</span></span><br><span class="line">fgrep = grep -F       <span class="comment"># 不解析正则，快速搜索</span></span><br><span class="line">pgrep -u root         <span class="comment"># 搜索root用户的进程</span></span><br></pre></td></tr></table></figure><h3 id="11-3-sed-流编辑器">11.3 sed 流编辑器</h3><h4 id="基本用法-2">基本用法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/old/new/&#x27;</span> file.txt       <span class="comment"># 替换第一个匹配</span></span><br><span class="line">sed <span class="string">&#x27;s/old/new/g&#x27;</span> file.txt      <span class="comment"># 替换所有匹配</span></span><br><span class="line">sed <span class="string">&#x27;1,5d&#x27;</span> file.txt             <span class="comment"># 删除1-5行</span></span><br><span class="line">sed <span class="string">&#x27;/pattern/d&#x27;</span> file.txt       <span class="comment"># 删除匹配行</span></span><br></pre></td></tr></table></figure><h4 id="高级用法">高级用法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;10,20p&#x27;</span> file.txt       <span class="comment"># 只打印10-20行</span></span><br><span class="line">sed <span class="string">&#x27;y/abc/ABC/&#x27;</span> file.txt      <span class="comment"># 字符转换</span></span><br><span class="line">sed -i.bak <span class="string">&#x27;s/old/new/&#x27;</span> file   <span class="comment"># 直接修改文件并备份</span></span><br><span class="line">sed -e <span class="string">&#x27;cmd1&#x27;</span> -e <span class="string">&#x27;cmd2&#x27;</span> file   <span class="comment"># 执行多个命令</span></span><br></pre></td></tr></table></figure><h4 id="脚本示例">脚本示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将1-5行行首添加&gt;字符</span></span><br><span class="line">sed <span class="string">&#x27;1,5s/^/&gt;/&#x27;</span> file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将每行的第一个数字替换为#</span></span><br><span class="line">sed <span class="string">&#x27;s/[0-9]/#/&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><h3 id="11-4-正则表达式示例">11.4 正则表达式示例</h3><ol><li>匹配IP地址：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&#x27;([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><ol start="2"><li>匹配邮箱地址：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&#x27;[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]&#123;2,&#125;&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><ol start="3"><li>提取HTML标签内容：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;s/&lt;title&gt;\(.*\)&lt;\/title&gt;/\1/p&#x27;</span> file.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.linux安装与包管理</title>
      <link href="/2020/05/07/linux/2-linux%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8C%85%E7%AE%A1%E7%90%86/"/>
      <url>/2020/05/07/linux/2-linux%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8C%85%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1>Linux 安装与软件包管理</h1><h2 id="1-硬盘分区布局">1. 硬盘分区布局</h2><h3 id="1-1-标准目录结构">1.1 标准目录结构</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/home     # 普通用户文件存储目录</span><br><span class="line">/var      # 存放日志文件、邮件队列等可变数据</span><br><span class="line">/usr      # 存放程序、库文件、文档等(通常占用空间最大)</span><br><span class="line">/boot     # 引导分区，通常100MB左右足够</span><br><span class="line">/swap     # 交换分区(建议大小为物理内存的1-2倍)</span><br></pre></td></tr></table></figure><h2 id="2-引导加载程序-GRUB">2. 引导加载程序(GRUB)</h2><h3 id="2-1-传统GRUB-GRUB-Legacy">2.1 传统GRUB (GRUB Legacy)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grub-install /dev/sda   <span class="comment"># 安装GRUB到指定设备</span></span><br><span class="line">grub-install -v         <span class="comment"># 显示详细安装信息</span></span><br></pre></td></tr></table></figure><h4 id="配置文件关键参数-boot-grub-menu-lst">配置文件关键参数(/boot/grub/menu.lst):</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">timeout      # 等待用户选择的时间(秒)</span><br><span class="line">default      # 默认启动项序号</span><br><span class="line">title        # 启动项标题</span><br><span class="line">root         # 指定根分区</span><br><span class="line">kernel       # 指定内核文件</span><br><span class="line">makeactive   # 激活分区</span><br><span class="line">chainloader  # 链式加载其他引导程序</span><br><span class="line">hiddenmenu   # 是否隐藏菜单</span><br></pre></td></tr></table></figure><h3 id="2-2-GRUB2-现代Linux默认使用">2.2 GRUB2 (现代Linux默认使用)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-grub2   <span class="comment"># 更新GRUB2配置</span></span><br></pre></td></tr></table></figure><h4 id="配置文件-etc-default-grub">配置文件(/etc/default/grub):</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GRUB_DEFAULT                  # 默认启动项</span><br><span class="line">GRUB_HIDDEN_TIMEOUT           # 隐藏菜单超时</span><br><span class="line">GRUB_HIDDEN_TIMEOUT_QUIET     # 是否静默隐藏</span><br><span class="line">GRUB_TIMEOUT                  # 菜单显示时间</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT    # 默认内核参数</span><br><span class="line">GRUB_CMDLINE_LINUX            # 附加内核参数</span><br></pre></td></tr></table></figure><h2 id="3-共享库管理">3. 共享库管理</h2><h3 id="3-1-基本概念">3.1 基本概念</h3><ul><li><strong>共享库(Shared Library)</strong>: 通过动态链接方式被多个程序共同使用的库文件</li><li>命名规则: <code>lib*.so*</code> (如 <code>libc.so.6</code>)</li></ul><h3 id="3-2-常用命令">3.2 常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldd /bin/ls      <span class="comment"># 查看二进制文件依赖的共享库</span></span><br><span class="line">ldconfig         <span class="comment"># 重建共享库缓存</span></span><br><span class="line">ldconfig -p      <span class="comment"># 打印当前缓存内容</span></span><br></pre></td></tr></table></figure><h3 id="3-3-共享库搜索顺序">3.3 共享库搜索顺序</h3><ol><li>可执行文件中的DT_RPATH或DT_RUNPATH段</li><li>环境变量<code>LD_LIBRARY_PATH</code>指定的路径</li><li><code>/etc/ld.so.cache</code>缓存中的路径(除非使用<code>-z nodeflib</code>选项)</li><li>默认路径<code>/lib</code>和<code>/usr/lib</code>(除非使用<code>-z nodeflib</code>选项)</li></ol><h3 id="3-4-添加自定义库路径">3.4 添加自定义库路径</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 临时添加(当前会话有效)</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/path/to/library</span><br><span class="line"></span><br><span class="line"><span class="comment"># 永久添加(需修改配置文件)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/path/to/library&quot;</span> &gt;&gt; /etc/ld.so.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure><h2 id="4-Debian系包管理-Debian-Ubuntu等">4. Debian系包管理(Debian/Ubuntu等)</h2><h3 id="4-1-包命名格式">4.1 包命名格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tree_1.5.3-1_i386.deb</span><br><span class="line">├── 包名(tree)</span><br><span class="line">├── 版本号(1.5.3)</span><br><span class="line">├── 发布号(1)</span><br><span class="line">├── 架构(i386)</span><br><span class="line">└── 扩展名(.deb)</span><br></pre></td></tr></table></figure><h3 id="4-2-dpkg命令-底层工具">4.2 dpkg命令(底层工具)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i package.deb       <span class="comment"># 安装包</span></span><br><span class="line">dpkg -r package           <span class="comment"># 移除包(保留配置)</span></span><br><span class="line">dpkg -P package           <span class="comment"># 完全清除包(包括配置)</span></span><br><span class="line">dpkg -l                   <span class="comment"># 列出已安装包</span></span><br><span class="line">dpkg -L package           <span class="comment"># 列出包安装的文件</span></span><br><span class="line">dpkg -s package           <span class="comment"># 显示包状态信息</span></span><br><span class="line">dpkg -S /path/to/file     <span class="comment"># 查找文件属于哪个包</span></span><br><span class="line">dpkg --configure package  <span class="comment"># 配置已解压的包</span></span><br><span class="line">dpkg --unpack package.deb <span class="comment"># 仅解压不配置</span></span><br></pre></td></tr></table></figure><h3 id="4-3-apt-get命令-高级工具">4.3 apt-get命令(高级工具)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apt-get update            <span class="comment"># 更新包数据库</span></span><br><span class="line">apt-get upgrade           <span class="comment"># 升级所有可升级包</span></span><br><span class="line">apt-get dist-upgrade      <span class="comment"># 智能升级(处理依赖变化)</span></span><br><span class="line">apt-get install package   <span class="comment"># 安装包</span></span><br><span class="line">apt-get remove package    <span class="comment"># 移除包</span></span><br><span class="line">apt-get clean             <span class="comment"># 清理下载的包文件</span></span><br><span class="line">apt-get -d install package <span class="comment"># 仅下载不安装</span></span><br><span class="line">apt-get -s install package <span class="comment"># 模拟安装(不实际执行)</span></span><br></pre></td></tr></table></figure><h3 id="4-4-软件源配置-etc-apt-sources-list">4.4 软件源配置(/etc/apt/sources.list)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">↑         ↑                          ↑       ↑</span><br><span class="line">类型     镜像地址                    发行版   组件</span><br></pre></td></tr></table></figure><ul><li><strong>类型</strong>: <code>deb</code>(二进制包)或<code>deb-src</code>(源代码包)</li><li><strong>组件</strong>:<ul><li><code>main</code>: 官方支持的免费软件</li><li><code>contrib</code>: 非自由软件但有自由依赖</li><li><code>non-free</code>: 有分发限制的软件</li></ul></li></ul><h3 id="4-5-apt-cache命令-查询工具">4.5 apt-cache命令(查询工具)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-cache search keyword    <span class="comment"># 搜索包</span></span><br><span class="line">apt-cache show package      <span class="comment"># 显示包详细信息</span></span><br><span class="line">apt-cache depends package   <span class="comment"># 显示包依赖</span></span><br></pre></td></tr></table></figure><h3 id="4-6-aptitude命令-交互式工具">4.6 aptitude命令(交互式工具)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aptitude update          <span class="comment"># 更新包列表</span></span><br><span class="line">aptitude install package <span class="comment"># 安装包</span></span><br><span class="line">aptitude remove package  <span class="comment"># 移除包</span></span><br><span class="line">aptitude purge package   <span class="comment"># 完全清除包</span></span><br><span class="line">aptitude upgrade         <span class="comment"># 升级包</span></span><br><span class="line">aptitude dist-upgrade    <span class="comment"># 智能升级</span></span><br></pre></td></tr></table></figure><h2 id="5-RedHat系包管理-RHEL-CentOS-Fedora">5. RedHat系包管理(RHEL/CentOS/Fedora)</h2><h3 id="5-1-rpm命令-底层工具">5.1 rpm命令(底层工具)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh package.rpm     <span class="comment"># 安装包(-v:详细,-h:进度条)</span></span><br><span class="line">rpm -Uvh package.rpm     <span class="comment"># 升级包</span></span><br><span class="line">rpm -Fvh *.rpm           <span class="comment"># 仅升级已安装的包</span></span><br><span class="line">rpm -e package           <span class="comment"># 卸载包</span></span><br><span class="line">rpm -qa                  <span class="comment"># 查询所有已安装包</span></span><br><span class="line">rpm -qf /path/to/file    <span class="comment"># 查询文件属于哪个包</span></span><br><span class="line">rpm -qi package          <span class="comment"># 查询包信息</span></span><br><span class="line">rpm -ql package          <span class="comment"># 列出包安装的文件</span></span><br><span class="line">rpm -qc package          <span class="comment"># 列出包配置文件</span></span><br><span class="line">rpm -qd package          <span class="comment"># 列出包文档文件</span></span><br><span class="line">rpm --nodeps             <span class="comment"># 忽略依赖关系(不推荐)</span></span><br><span class="line">rpm --<span class="built_in">test</span>               <span class="comment"># 测试模式(不实际执行)</span></span><br></pre></td></tr></table></figure><h3 id="5-2-rpm文件提取">5.2 rpm文件提取</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm2cpio package.rpm | cpio -idv  <span class="comment"># 提取rpm包内容</span></span><br><span class="line">rpm2cpio package.rpm | cpio -t    <span class="comment"># 列出rpm包内容</span></span><br></pre></td></tr></table></figure><h3 id="5-3-yum命令-高级工具">5.3 yum命令(高级工具)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yum install package      <span class="comment"># 安装包</span></span><br><span class="line">yum remove package       <span class="comment"># 移除包</span></span><br><span class="line">yum update               <span class="comment"># 更新所有包</span></span><br><span class="line">yum update package       <span class="comment"># 更新指定包</span></span><br><span class="line">yum check-update         <span class="comment"># 检查可用更新</span></span><br><span class="line">yum info package         <span class="comment"># 显示包信息</span></span><br><span class="line">yum list                 <span class="comment"># 列出包</span></span><br><span class="line">yum search keyword       <span class="comment"># 搜索包</span></span><br><span class="line">yum groupinstall <span class="string">&quot;Development Tools&quot;</span> <span class="comment"># 安装软件组</span></span><br><span class="line">yum repolist             <span class="comment"># 列出已配置的仓库</span></span><br></pre></td></tr></table></figure><h3 id="5-4-下载rpm包">5.4 下载rpm包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yumdownloader package    <span class="comment"># 下载rpm包不安装</span></span><br></pre></td></tr></table></figure><h3 id="5-5-zypper命令-SUSE系统">5.5 zypper命令(SUSE系统)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zypper install package   <span class="comment"># 安装包</span></span><br><span class="line">zypper remove package    <span class="comment"># 移除包</span></span><br><span class="line">zypper update            <span class="comment"># 更新系统</span></span><br></pre></td></tr></table></figure><h2 id="6-软件包管理对比">6. 软件包管理对比</h2><table><thead><tr><th>功能</th><th>Debian系(apt)</th><th>RedHat系(yum)</th><th>SUSE系(zypper)</th></tr></thead><tbody><tr><td>安装包</td><td>apt-get install</td><td>yum install</td><td>zypper install</td></tr><tr><td>移除包</td><td>apt-get remove</td><td>yum remove</td><td>zypper remove</td></tr><tr><td>更新系统</td><td>apt-get upgrade</td><td>yum update</td><td>zypper update</td></tr><tr><td>搜索包</td><td>apt-cache search</td><td>yum search</td><td>zypper search</td></tr><tr><td>显示包信息</td><td>apt-cache show</td><td>yum info</td><td>zypper info</td></tr><tr><td>清理缓存</td><td>apt-get clean</td><td>yum clean</td><td>zypper clean</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.系统架构</title>
      <link href="/2020/05/06/linux/1-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
      <url>/2020/05/06/linux/1-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="1-系统架构">1. 系统架构</h2><h3 id="1-1-PCI架构">1.1 PCI架构</h3><ul><li><strong>PCI(外围组件互连)</strong>: Intel Core系统的主要总线架构</li><li><strong>组件</strong>:<ul><li><strong>CPU</strong>:<ul><li>显示: eDP(支持i7 CPU和DDR4内存)</li><li>显示: HDMI(支持i7 CPU和DDR4内存)</li></ul></li><li><strong>PCH(平台控制器中枢)</strong>:<ul><li>USB 3.0接口</li><li>PCI总线</li><li>音频输出</li></ul></li></ul></li></ul><h3 id="1-2-lspci命令">1.2 lspci命令</h3><ul><li>显示PCI总线和连接设备的信息</li><li>可以查看:<ul><li>中断请求(IRQ)信息</li><li>设备路径和速度</li><li>制造商ID</li></ul></li></ul><h3 id="1-3-ACPI-高级配置与电源接口">1.3 ACPI(高级配置与电源接口)</h3><ul><li>电源管理规范标准</li><li>管理功能包括:<ul><li>电源按钮操作</li><li>笔记本开合盖检测</li><li>电池充电状态</li><li>CPU速度调节</li></ul></li><li><strong>重要说明</strong>:<ul><li>不直接管理硬件，而是处理电源事件</li><li>配置文件位置:<ul><li><code>/etc/acpi/</code>目录</li><li><code>/proc/acpi/</code>目录</li></ul></li></ul></li><li><strong>守护进程</strong>:<ul><li><code>acpid</code>:<ul><li>配置目录: <code>/etc/acpi/</code></li><li>示例: 查看电源配置<code>cat /etc/acpi/events/power.conf</code></li></ul></li><li><code>systemd-logind</code>:<ul><li>配置文件: <code>/etc/systemd/logind.conf</code></li></ul></li></ul></li></ul><h2 id="2-启动流程">2. 启动流程</h2><h3 id="2-1-传统SysV-Init启动">2.1 传统SysV Init启动</h3><ol><li>电源启动</li><li>BIOS初始化</li><li>引导加载程序(GRUB)</li><li>加载内核(<code>vmlinuz</code>, <code>initramfs</code>)</li><li>执行内核</li><li>执行initramfs</li><li>init进程启动并挂载根文件系统</li><li>init启动各种服务</li></ol><h3 id="2-2-现代systemd启动">2.2 现代systemd启动</h3><ol><li>电源启动</li><li>UEFI初始化</li><li>引导加载程序(GRUB2)</li><li>加载内核(<code>vmlinuz</code>, <code>initramfs</code>)</li><li>执行内核</li><li>执行initramfs</li><li>systemd启动并挂载根文件系统</li><li>systemd启动各种服务</li></ol><h3 id="2-3-Init进程详情">2.3 Init进程详情</h3><ul><li>第一个用户空间进程路径: <code>/sbin/init</code></li><li>传统init流程:<ol><li>init读取<code>/etc/inittab</code></li><li>init执行<code>/etc/rc.sysinit</code>脚本</li><li>init执行<code>/etc/rc</code>脚本</li><li><code>/etc/rc</code>执行<code>/etc/rc&lt;运行级别&gt;.d/</code>目录下的脚本</li></ol></li></ul><h2 id="3-分区表">3. 分区表</h2><h3 id="3-1-GPT-GUID分区表">3.1 GPT(GUID分区表)</h3><ul><li>EFI规范的一部分</li><li>支持最大9.4TB分区</li><li>使用GUID标识:<ul><li>设备标识</li><li>分区标识</li></ul></li></ul><h3 id="3-2-MBR-主引导记录">3.2 MBR(主引导记录)</h3><ul><li>使用CHS(柱面/磁头/扇区)寻址</li><li>最大只支持2TB分区</li></ul><h2 id="4-系统信息命令">4. 系统信息命令</h2><h3 id="4-1-uname命令">4.1 uname命令</h3><p>显示系统信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -m  <span class="comment"># 显示硬件架构类型</span></span><br><span class="line"><span class="built_in">uname</span> -n  <span class="comment"># 显示网络节点主机名</span></span><br><span class="line"><span class="built_in">uname</span> -r  <span class="comment"># 显示内核发行版本</span></span><br><span class="line"><span class="built_in">uname</span> -s  <span class="comment"># 显示操作系统名称</span></span><br><span class="line"><span class="built_in">uname</span> -v  <span class="comment"># 显示内核版本</span></span><br><span class="line"><span class="built_in">uname</span> -a  <span class="comment"># 显示所有信息</span></span><br></pre></td></tr></table></figure><h3 id="4-2-wall命令">4.2 wall命令</h3><p>向所有用户广播消息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wall <span class="string">&quot;消息内容&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-3-dmesg命令">4.3 dmesg命令</h3><p>显示内核环形缓冲区消息(启动日志):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg</span><br></pre></td></tr></table></figure><h3 id="4-4-lsmod命令">4.4 lsmod命令</h3><p>列出已加载的内核模块:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod</span><br></pre></td></tr></table></figure><h3 id="4-5-modprobe命令">4.5 modprobe命令</h3><p>手动加载设备驱动:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe &lt;设备名称&gt;</span><br></pre></td></tr></table></figure><h2 id="5-proc文件系统">5. /proc文件系统</h2><p>/proc目录下的重要文件:</p><ul><li><code>/proc/bus/usb/*</code> - USB设备信息</li><li><code>/proc/cpuinfo</code> - CPU信息</li><li><code>/proc/interrupts</code> - 中断请求信息</li><li><code>/proc/pci</code> - PCI设备信息</li><li><code>/proc/scsi/scsi</code> - SCSI设备信息</li><li><code>/proc/version</code> - 内核版本信息</li><li><code>/proc/meminfo</code> - 内存信息</li></ul><h2 id="6-运行级别">6. 运行级别</h2><p>运行级别配置文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/inittab</span><br></pre></td></tr></table></figure><h2 id="7-模拟器">7. 模拟器</h2><p>通过软件模拟硬件环境来运行不同操作系统的工具</p><h2 id="8-启动顺序图示">8. 启动顺序图示</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[BIOS/UEFI固件] --&gt; B[引导加载程序]</span><br><span class="line">    B --&gt; C[Linux内核]</span><br><span class="line">    C --&gt; D[Init/Systemd]</span><br><span class="line">    D --&gt; E[系统服务]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率2-连续型随机分布律</title>
      <link href="/2019/10/28/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%872-%E8%BF%9E%E7%BB%AD%E5%9E%8B%E9%9A%8F%E6%9C%BA%E5%88%86%E5%B8%83%E5%BE%8B/"/>
      <url>/2019/10/28/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%872-%E8%BF%9E%E7%BB%AD%E5%9E%8B%E9%9A%8F%E6%9C%BA%E5%88%86%E5%B8%83%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="1-均匀分布">1,均匀分布</h5><p>若连续型随机变量X具有概率密度</p>\begin{align*}f(x)= \begin{cases}{1 \over {b-a}} ,a < x < b,\\0\end{cases}\end{align*}<p>则称X在区间(a,b)上服从均匀分布，记为X〜U(a,b)</p><p>分布函数：</p>\begin{align*}F(x)= \begin{cases} 0, & x < a \\\frac{x-a}{b-a}, & a \leq x < b \\1, & x \geq b \end{cases}\end{align*}<hr><h3 id="2-指数分布">2. 指数分布</h3><p>若连续型随机变量X具有概率密度：</p>\begin{align*}f(x)= \begin{cases}\frac{1}{\theta} e^{-x/\theta}, & x > 0 \\0, & \text{其他}\end{cases}\end{align*}<p>其中θ&gt;0为常数，则称X服从参数为θ的指数分布。</p><p>易知f(x)≥0，且：</p>\begin{align*}\int^\infty_{-\infty}f(x)dx = \left[-e^{-x/\theta}\right]^\infty_0 = 1\end{align*}<p>分布函数：</p>\begin{align*}F(x)= \begin{cases}1-e^{-x/\theta}, & x > 0 \\0, & \text{其他}\end{cases}\end{align*}<p>服从指数分布的随机变量X具有无记忆性：<br>对于任意s,t&gt;0，有</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>{</mo><mi>X</mi><mo>&gt;</mo><mi>s</mi><mo>+</mo><mi>t</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo>&gt;</mo><mi>s</mi><mo>}</mo><mo>=</mo><mi>P</mi><mo>(</mo><mi>X</mi><mo>&gt;</mo><mi>t</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">P\{X&gt;s+t|X&gt;s\} = P(X&gt;t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">{</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mrel">&gt;</span><span class="mord mathit">s</span><span class="mbin">+</span><span class="mord mathit">t</span><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mrel">&gt;</span><span class="mord mathit">s</span><span class="mclose">}</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mrel">&gt;</span><span class="mord mathit">t</span><span class="mclose">)</span></span></span></span></span></p><p>证明：</p>\begin{align*}P\{X>s+t|X>s\} &= \frac{P\{X>s+t\} \cap P\{X>s\}}{P\{X>s\}} \\&= \frac{P\{X>s+t\}}{P\{X>s\}} \\&= \frac{1-F(s+t)}{1-F(s)} \\&= \frac{e^{-(s+t)/\theta}}{e^{-s/\theta}} \\&= e^{-t/\theta} \\&= P\{X>t\}\end{align*}<hr><h3 id="3-正态分布">3. 正态分布</h3><p>若连续型随机变量X具有概率密度：</p>\begin{align*}f(x) = \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}\end{align*}<p>其中μ,σ(σ&gt;0)为常数，则称X服从参数为μ,σ的正态分布，记为X～N(μ,σ²)。</p><p>显然f(x)≥0，下面证明：</p>\begin{align*}\int^\infty_{-\infty}f(x)dx = 1\end{align*}<p>令<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mfrac><mrow><mi>x</mi><mo>−</mo><mi>μ</mi></mrow><mrow><mi>σ</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">t = \frac{x-\mu}{\sigma}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.854439em;"></span><span class="strut bottom" style="height:1.199439em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mrel">=</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03588em;">σ</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.44610799999999995em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">x</span><span class="mbin">−</span><span class="mord mathit">μ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>，则：</p>\begin{align*}σ=(x-μ)/t,t'(x)=1/σ\end{align*}<p>得到:</p>\begin{align*}\int^\infty_{-\infty}\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}dx &=\int^\infty_{-\infty}{1 \over {\sqrt{2 \pi}}(x-μ)/t}e^{-t^2 \over 2}dt \\&= \frac{1}{\sqrt{2\pi}}\int^\infty_{-\infty}e^{-\frac{t^2}{2}}dt\end{align*}<p>记：</p>\begin{align*}I = \int^\infty_{-\infty}e^{-\frac{t^2}{2}}dt\end{align*}<p>则有：</p>\begin{align*}I^2 = \int^\infty_{-\infty}\int^\infty_{-\infty}e^{-\frac{t^2+u^2}{2}}dtdu\end{align*}<p>利用极坐标变换：</p>\begin{align*}I^2 = \int^{2\pi}_0\int^\infty_0 re^{-\frac{r^2}{2}}drd\theta = 2\pi\end{align*}<p>（p55）</p><hr><h3 id="附：">附：</h3><p>计算：</p>\begin{align*}\iint_D^\infty e^{-\frac{x^2+y^2}{2}}dxdy\end{align*}]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率1-离散型随机分布律</title>
      <link href="/2019/10/28/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%871-%E7%A6%BB%E6%95%A3%E5%9E%8B%E9%9A%8F%E6%9C%BA%E5%88%86%E5%B8%83%E5%BE%8B/"/>
      <url>/2019/10/28/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%871-%E7%A6%BB%E6%95%A3%E5%9E%8B%E9%9A%8F%E6%9C%BA%E5%88%86%E5%B8%83%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="１-不放回抽样表达式">１.不放回抽样表达式:</h5><p>a件产品中抽取n件（不放回），则可能的取法有</p>\begin{align*}\left( \begin{matrix} a\\ n \\ \end{matrix} \right) =C^n_a=A^n_a/n!= { {a(a-1)...(a-n+1)} \over n!} ={a! \over n!(a-n)!}\end{align*}<hr><h5 id="伯努利试验-二项分布">伯努利试验,二项分布</h5><p>设试验E只有两种可能结果:A及非A,则称E为伯努利试验，设P(A)=p (0&lt;p&lt;1),此时P(非A)=1-p.将E独立重复地进行N次，则称这一串重复的独立试验为n重伯努利试验。</p><p>标记为<br>X〜b(n,p).</p>\begin{align*}P\{X = k\}=\left( \begin{matrix} n\\ k \\ \end{matrix} \right) p^k q^{n-k}\end{align*}<p>当n=1时，化为二项分布：</p>\begin{align*}P\{X = k\}= p^k q^{1-k}\end{align*}\begin{align*}\sum_{k=0}^n P\{X = k\}=\sum_{k=0}^n {\left( \begin{matrix} n\\ k \\ \end{matrix} \right) } p^k q^{n-k} =(p+q)^n=1\end{align*}<hr><h5 id="泊松分布">泊松分布</h5><p>设随机变量X所有可能取的值为0,1,2,…,2而取各个值的概率为</p>\begin{align*}P\{X=k\}={λ^ke^{-λ} \over {k!}} ,k=0,1,2,...,\end{align*}<p>其中λ&gt;0是常数.则称X服从参数为λ的泊松分布，记为X〜π(λ).</p><p>易知,P{X=k}≥0,k=0,1,2,…,且有</p>\begin{align*}\sum_{k=0}^\infty P\{X = k\}=\sum_{k=0}^\infty {λ^ke^{-λ} \over {k!}}=e^{-λ}\sum_{k=0}^\infty {λ^k\over {k!}}=e^{-λ}e^λ=1\end{align*}<p>倒数第二步是<strong>泰勒级数</strong>(见附表)</p><p><strong>泊松定理</strong>  设λ&gt;0是一个常数,n是任意正整数,设np=λ,则对于任一固定的非负整数k，有</p>\begin{align*}\lim_{n \to \infty} \binom{n}{k} p_n^k (1-p_n)^{n-k} = \frac{\color{red}\lambda^k \color{purple}e^{-\lambda}}{\color{red}k!}.\end{align*}<p><strong>证</strong> 由</p>\begin{align*}p_n= {λ \over n}\end{align*}<p>,有</p>\begin{align*}{\left( \begin{matrix} n\\ k \\ \end{matrix} \right)}p^k_n(1-p_n)^{n-k}&={\color{blue}{n(n-1)(n-2)...(n-k+1)} \over {\color{red}k!}}{({\color{red}{λ} \over \color{blue}n})^k}{(1-{λ \over n})^{n-k}} \\&={\color{red}{λ^k \over k!}}{[\color{blue}1 \cdot ({1-{1 \over n})}\cdot ({1-{2 \over n})...(1-{(k+1) \over n})}}]{\color{purple}(1-{λ \over n})^{n}}{(1-{λ \over n})^{-k}}\end{align*}<p>对于任意固定的k,当n→∞,</p>\begin{align*}\lim_{n \to \infty}[1 \cdot ({1-{1 \over n})}\cdot ({1-{2 \over n})...(1-{(k+1) \over n})}]=1, \\\lim_{n \to \infty}(1-{λ \over n})^{n}={\color{purple}e^{-λ}}, \\\lim_{n \to \infty}(1-{λ \over n})^{-k}=1\end{align*}<p>Q.E.D.</p><hr><p><strong>泰勒中值定理</strong> 如果函数f(x)在含有x₀的某个开区间(a,b)内具有直到(n+1)阶的导数，则对任一x∈(a,b),有</p>\begin{align*}f(x)=f(x_0)+f'(x_0)(x-x_0)+{f''(x_0) \over 2!}(x-x_0)^2+...+{f^{(n)}(x_0) \over n!}(x-x_0)^n+R_n(x),\end{align*}<p>其中</p>\begin{align*}R_n(x)={f^{(n+1)}(\xi) \over ({n+1})!} (x-x_0)^{n+1}\end{align*}<p>当</p>\begin{align*}&x_0=0,f(λ)=e^λ \\&f(λ)=e^λ \\&= e^0+{(e^0)(λ-0) \over {1!}}+{(e^0)(λ-0)^2 \over {2!}}+{(e^0)(λ-0)^3 \over {3!}}+...+{(e^0)(λ-0)^k \over {k!}} \\&= \sum_{k=0}^\infty {λ^k\over {k!}}\end{align*}]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.偏导数(拉普拉斯方程)</title>
      <link href="/2019/10/28/%E6%95%B0%E5%AD%A6/11-%E5%81%8F%E5%AF%BC%E6%95%B0-%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E6%96%B9%E7%A8%8B/"/>
      <url>/2019/10/28/%E6%95%B0%E5%AD%A6/11-%E5%81%8F%E5%AF%BC%E6%95%B0-%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E6%96%B9%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>拉普拉斯方程：<br>验证函数</p>\begin{align*}z=ln \sqrt{x^2+y^2}\end{align*}<p>满足方程</p>\begin{align*}{\partial^2{z} \over \partial{x^2}}+{\partial^2{z} \over \partial{y^2}}=0\end{align*}<p>证:因为</p>\begin{align*}z=ln \sqrt{x^2+y^2} =1/2 ln(x^2+y^2)\end{align*}<p>所以</p>\begin{align*}{\partial{z} \over \partial{x}}={x \over(x^2+y^2)}\end{align*}\begin{align*}{\partial^2{z} \over \partial{x^2}}={(x^2+y^2)-2x \cdot x \over(x^2+y^2)^2}={y^2-x^2 \over(x^2+y^2)^2}\end{align*}\begin{align*}{\partial{z} \over \partial{y}}={y \over(x^2+y^2)}\end{align*}\begin{align*}{\partial^2{z} \over \partial{y^2}}={(x^2+y^2)-2y \cdot y \over(x^2+y^2)^2}={x^2-y^2 \over(x^2+y^2)^2}\end{align*}<p>Q.E.D.</p><hr><p>验证函数</p>\begin{align*}u={1 \over r}\end{align*}<p>满足方程</p>\begin{align*}{\partial^2{u} \over \partial{x^2}}+{\partial^2{u} \over \partial{y^2}}+{\partial^2{u} \over \partial{z^2}}=0\end{align*}<p>其中</p>\begin{align*}r =\sqrt{x^2+y^2+z^2}\end{align*}<p>证：</p>\begin{align*}{\partial{u} \over \partial{x}}={-1 \over r^2} \cdot {1 \over {2r}}  \cdot 2x=-{x \over r^3}\end{align*}\begin{align*}{\partial^2{u} \over \partial{x^2}}=-{1 \over r^3}+ {3 \over r^4}x \cdot {1 \over {2r}}  \cdot 2x=-{1 \over r^3}+{3x^2 \over r^5}\end{align*}<p>同理</p>\begin{align*}{\partial^2{u} \over \partial{y^2}}=-{1 \over r^3}+ {3 \over r^4}y \cdot {1 \over {2r}}  \cdot 2y=-{1 \over r^3}+{3y^2 \over r^5}\end{align*}\begin{align*}{\partial^2{u} \over \partial{z^2}}=-{1 \over r^3}+ {3 \over r^4}z \cdot {1 \over {2r}}  \cdot 2z=-{1 \over r^3}+{3z^2 \over r^5}\end{align*}<p>于是</p>\begin{align*}{\partial^2{u} \over \partial{x^2}}+{\partial^2{u} \over \partial{y^2}}+{\partial^2{u} \over \partial{z^2}}={-3 \over r^3}+{(3x^2+3y^2+3z^2) \over r^5}=0\end{align*}]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.向量基本概念</title>
      <link href="/2019/10/28/%E6%95%B0%E5%AD%A6/10-%E5%90%91%E9%87%8F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/10/28/%E6%95%B0%E5%AD%A6/10-%E5%90%91%E9%87%8F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h4 id="一-向量的线性运算">一,向量的线性运算</h4><hr><p>1,向量的加减法</p><p>(1)交换律 a+b=B+a;</p><p>(2)结合律 (a+b)+c=a+(b+c);</p><hr><p>2,向量与数的乘法</p><p>(1)结合律</p>\begin{align*}\lambda (\mu \vec{a}) =\lambda (\mu \vec{a})= (\lambda \mu) \vec{a}\end{align*}<p>(2)分配律</p>\begin{align*}(\lambda + \mu)\vec{a} =\lambda \vec{a} + \mu \vec{a} \\\lambda (\vec{a}+\vec{b}) =\lambda \vec{a} + \lambda \vec{b}\end{align*}<p><strong>定理1 设向量a ≠ 0,那么，向量b平行于a的充分必要条件是:存在唯一的实数λ，使b=λa</strong></p><hr><h4 id="向量的模，方向角，投影">向量的模，方向角，投影</h4><p>向量模的坐标式</p>\begin{align*}|\vec{AB}|=\sqrt{x^2+y^2+z^2}\end{align*}<p>A，B两点间距离就是向量AB的模。</p>\begin{align*}|\vec{AB}|=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}\end{align*}<p>方向角和方向余弦</p><p>设有两个非零向量a,b,任取空间一点O，<br>（P298）</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.Γ函数(gamma函数)</title>
      <link href="/2019/10/27/%E6%95%B0%E5%AD%A6/9-%CE%93%E5%87%BD%E6%95%B0-gamma%E5%87%BD%E6%95%B0/"/>
      <url>/2019/10/27/%E6%95%B0%E5%AD%A6/9-%CE%93%E5%87%BD%E6%95%B0-gamma%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>Γ函数：</p>\begin{align*}\Gamma (s)= \int_0^{+ \infty} e^{-x} x^{(s-1)}dx \ .(s>0)\end{align*}<p>分别讨论以下两个积分:</p>\begin{align*}I_1= \int_0^1 e^{-x} x^{(s-1)}dx \ .(s>0)\end{align*}\begin{align*}I_2= \int_1^{+ \infty} e^{-x} x^{(s-1)}dx \ .(s>0)\end{align*}<p>当s≥1时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">I_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07847em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 是定积分（s看作定值），当0&lt;s&lt;1时，因为</p>\begin{align*}e^{-x} \cdot x^{s-1} ={1 \over x^{1-s}} \cdot {1 \over e^x} < {1 \over x^{1-s}}\end{align*}<p>根据比较审敛法2，反常积分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">I_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07847em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>收敛。</p><p>再讨论<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">I_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07847em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,因为</p>\begin{align*}\lim_{x \to + \infty} x^2 \cdot (e^{-x}x^{s-1})= \lim_{x \to + \infty} {x^{s+1} \over e^x}=0\end{align*}<p>根据比较审敛法1，反常积分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">I_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07847em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>收敛。<br>(最后一步洛必达法则)</p><hr><p>Γ函数四个性质:</p><p>1.递推公式</p>\begin{align*}\Gamma (s+1) = s \Gamma (s) (s>0)\end{align*}<p>证: 应用分部积分法,有</p>\begin{align*}\Gamma (s+1) &= \int_0^{+ \infty} e^{-x} x^s dx \\&= - \int_0^{+ \infty} x^s de^{-x} \\&= -([x^se^{-x}]_0^{+ \infty } -s \int_0^{+ \infty} e^{-x}x^{s-1}dx ) \\&= 0 + s \int_0^{+ \infty} e^{-x}x^{s-1}dx \\&= s \Gamma (s) \end{align*}<p>其中</p>\begin{align*}\lim_{x \to + \infty  } x^se^{-x} =0\end{align*}<p>可由洛必达法则求得。<br>显然:</p>\begin{align*}\Gamma (1) &=\int_0^{+ \infty} e^{-x}x^{s-1}dx \\&=\int_0^{+ \infty} e^{-x}dx \\ &=[-e^{-x}]^{+ \infty}_0 \\&=0-(-1) \\&=1\end{align*}<p>反复运用递推公式有:<br>对于任意的正整数</p>\begin{align*}\Gamma (n+1)=n!\end{align*}<p>所以Gamma函数可以看作阶乘的推广</p><p>2.当</p>\begin{align*}s \to 0^+\end{align*}<p>时,</p>\begin{align*}\Gamma (s) ={\Gamma (s+1) \over s},\Gamma (1)=1\end{align*}<p>,所以当</p>\begin{align*}s \to 0^+,\Gamma (s) \to + {\infty}\end{align*}<ol start="3"><li></li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow><mi mathvariant="normal">Γ</mi><mo>(</mo><mi>s</mi><mo>)</mo><mi mathvariant="normal">Γ</mi><mo>(</mo><mi>s</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>=</mo><mrow><mfrac><mrow><mi>π</mi></mrow><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mi>π</mi><mi>s</mi></mrow></mfrac></mrow><mtext> </mtext><mo>(</mo><mn>0</mn><mo>&lt;</mo><mi>s</mi><mo>&lt;</mo><mn>1</mn><mo>)</mo></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned}\Gamma (s) \Gamma (s-1) ={\pi \over sin \pi s} \ (0&lt;s&lt;1)\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.1467800000000001em;"></span><span class="strut bottom" style="height:1.7935600000000003em;vertical-align:-0.64678em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:-0.03922000000000003em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord mathrm">Γ</span><span class="mopen">(</span><span class="mord mathit">s</span><span class="mclose">)</span><span class="mord mathrm">Γ</span><span class="mopen">(</span><span class="mord mathit">s</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord displaystyle textstyle uncramped"><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">π</span><span class="mord mathit">s</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">π</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span><span class="mord mspace"> </span><span class="mopen">(</span><span class="mord mathrm">0</span><span class="mrel">&lt;</span><span class="mord mathit">s</span><span class="mrel">&lt;</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></span></p><p>4.在</p>\begin{align*}\Gamma (s)  = \int_0^{+ \infty} e^{-x} x^{(s-1)}dx\end{align*}<p>作代换</p>\begin{align*}x=u^2\end{align*}<p>,<br>有</p>\begin{align*}\Gamma (s) =  \int_0^{+ \infty} e^{-u^2} u^{2(s-1)}2udu = 2 \int_0^{+ \infty} e^{-u^2} u^{2s-1}du\end{align*}<p>再令2s-1=t有:</p>\begin{align*}\int_0^{+ \infty} e^{-u^2} u^{2s-1}du = \int_0^{+ \infty} e^{-u^2} u^tdu =\Gamma ({t+1 \over 2}) . (t>-1) \end{align*}<p>上式<br>令t=0,则s=1/2,得</p>\begin{align*}2 \int_0^{+ \infty} e^{-u^2}du =\Gamma({1 \over 2})=\sqrt{\pi}\end{align*}<p>以上即为高斯积分</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.反常积分</title>
      <link href="/2019/10/26/%E6%95%B0%E5%AD%A6/8-%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/"/>
      <url>/2019/10/26/%E6%95%B0%E5%AD%A6/8-%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h5 id="反常积分">反常积分</h5><p><strong>定义1 设函数f(x)在区间[a,+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>)上连续，取t&gt;a，如果极限</strong></p>\begin{align*}\lim_{t \to +\infty} \int_a^tf(x)dx\end{align*}<p><strong>存在，则称此极限为函数f(x)在无穷区间[a,+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>)上的反常积分,记作</strong></p>\begin{align*}\int_a^{+\infty}f(x)dx\end{align*}<p>此时称反常积分收敛。<br>-无穷大同理，两个无穷大都收敛，则称无穷限的反常积分。</p><p>例: 计算反常积分</p>\begin{align*}\int_0^{+\infty}te^{-pt}dt\end{align*}<p>(p是常数，p&gt;0)</p><p>解:</p>\begin{align*}\int_0^{+\infty}te^{-pt}dt &= [\int te^{-pt}dt]_0^{+\infty} \\&= [-1/p\int tde^{e^{-pt}}]_0^{+\infty} \\&= [-1/p(te^{-pt}-\int e^{-pt}dt)]^{+\infty}_0 \\&= [-1/p(te^{-pt}+1/pe^{-pt})]_0^{+\infty} \\&= [-1/pte^{-pt}]_0^{+\infty}-[1/p^2e^{-pt}]_0^{+\infty} \\&= -1/p \lim_{t \to +\infty}te^{-pt}-0-1/p^2(\lim_{t \to +\infty} e^{-pt}-1) \\&=1/p^2\end{align*}<hr>\begin{align*}&\because de^{-pt}/dt=-pe^{-pt} \\&\therefore dt= {de^{-pt} \over {-pe^{-pt}}}, e^{-pt}dt = {de^{-pt} \over {-p}}\end{align*}\begin{align*}(uv)'=u'v+v'u\end{align*}<hr><p><strong>定义2 设函数f(x)在区间(a,b]上连续，点a为f(x)的瑕点,取t&gt;a，如果极限</strong></p>\begin{align*}\lim_{t \to a^+} \int_t^bf(x)dx\end{align*}<p><strong>存在，则称此极限为函数f(x)在无穷区间(a,b]上的反常积分,记作</strong></p>\begin{align*}\int_a^bf(x)dx\end{align*}<p>此时称反常积分收敛。-a同理。</p><hr><h5 id="反常积分的审敛法">反常积分的审敛法</h5><p><strong>定理1 设函数f(x)在区间[a,+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>)上连续,且f(x)≥0,若函数</strong></p>\begin{align*}F(x)=\int_a^xf(t)dt\end{align*}<p>在[a,+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>]上有界，则反常积分</p>\begin{align*}\int_a^{+\infty} f(t)dt\end{align*}<p>收敛</p><hr><p><strong>定理2(比较审敛原理) 设函数f(x),g(x)在区间[a,+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>)上连续,如果0≤f(x)≤g(x)(a≤x≤+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>),并且</strong></p>\begin{align*}\int_a^{+\infty} g(x)dx\end{align*}<p><strong>收敛，则</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx\end{align*}<p><strong>也收敛;如果0≤g(x)≤f(x)(a≤x≤+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>)，并且</strong></p>\begin{align*}\int_a^{+\infty} g(x)dx\end{align*}<p><strong>发散，则</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx\end{align*}<p><strong>也发散.</strong></p><hr><p><strong>定理3(比较审敛法1) 设函数f(x)在区间[a,+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>)上连续,且f(x)≥0,如果存在常数M&gt;0及p&gt;1,使得</strong></p>\begin{align*}f(x) \le {M \over x^p} (a \le x< + \infty )\end{align*}<p><strong>则反常积分</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx\end{align*}<p><strong>收敛;如果存在常数N&gt;0,使得</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>≥</mo><mrow><mfrac><mrow><mi>N</mi></mrow><mrow><mi>x</mi></mrow></mfrac></mrow><mo>(</mo><mi>a</mi><mo>≤</mo><mi>x</mi><mo>&lt;</mo><mo>+</mo><mi mathvariant="normal">∞</mi><mo>)</mo></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned}f(x) \ge {N \over x} (a \le x&lt; + \infty )\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.273165em;"></span><span class="strut bottom" style="height:2.04633em;vertical-align:-0.773165em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:0.08716499999999994em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mrel">≥</span><span class="mord displaystyle textstyle uncramped"><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit">x</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mrel">≤</span><span class="mord mathit">x</span><span class="mrel">&lt;</span><span class="mord">+</span><span class="mord mathrm">∞</span><span class="mclose">)</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></span></p><p><strong>则反常积分</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx\end{align*}<p><strong>发散.</strong></p><hr><p><strong>定理4(极限审敛法1) 设函数f(x)在区间[a,+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>)上连续,且f(x)≥0,如果存在常数p&gt;1,使得</strong></p>\begin{align*}\lim_{x \to + \infty }x^pf(x)\end{align*}<p><strong>存在,则反常积分</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx\end{align*}<p><strong>收敛;如果</strong></p>\begin{align*}\lim_{x \to + \infty }xf(x)=d>0\end{align*}<p><strong>或</strong></p>\begin{align*}\lim_{x \to + \infty }xf(x)=+ \infty\end{align*}<p><strong>,则反常积分</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx\end{align*}<p><strong>发散</strong></p><hr><p><strong>定理5 设函数f(x)在区间[a,+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>)上连续,如果反常积分</strong></p>\begin{align*}\int_a^{+\infty} |f(x)|dx\end{align*}<p><strong>收敛，则反常积分</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx\end{align*}<p><strong>收敛.</strong></p><hr><p><strong>定理6(比较审敛法2) 设函数f(x)在区间(a,b]上连续,且f(x)≥0，x=a为f(x)的瑕玷.如果存在常数M&gt;0及q&lt;1,使得</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx \le {M \over (x-a)^q} (a < x \le b),\end{align*}<p><strong>则反常积分</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx\end{align*}<p><strong>收敛.</strong></p><p><strong>如果存在常数N&gt;0,使得</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx \ge {N \over (x-a)} (a < x \le b),\end{align*}<p><strong>则反常积分</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx\end{align*}<p><strong>发散.</strong></p><hr><p><strong>定理7(极限审敛法2) 设函数f(x)在区间(a,b]上连续,且f(x)≥0,x=a为f(x)的瑕点如果存在常数0&lt;q&lt;1,使得</strong></p>\begin{align*}\lim_{x \to a^+ }(x - a )^qf(x)\end{align*}<p><strong>存在,则反常积分</strong></p>\begin{align*}\int_a^b f(x)dx\end{align*}<p><strong>收敛;如果</strong></p>\begin{align*}\lim_{x \to + a^+ }(x-a)f(x)=d>0\end{align*}<p><strong>或</strong></p>\begin{align*}\lim_{x \to + a^+ }(x-a)f(x)=+ \infty\end{align*}<p><strong>,则反常积分</strong></p>\begin{align*}\int_a^b f(x)dx\end{align*}<p><strong>发散</strong></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.定积分</title>
      <link href="/2019/10/24/%E6%95%B0%E5%AD%A6/7-%E5%AE%9A%E7%A7%AF%E5%88%86/"/>
      <url>/2019/10/24/%E6%95%B0%E5%AD%A6/7-%E5%AE%9A%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p><strong>定义</strong> 设函数f(x)在[a,b]上有界，在[a,b]中任意插入若干个分点</p>\begin{align*}a={x_0}<{x_1}<{x_2}<...<{x_{n-1}}<{x_n}=b\end{align*}<p>把区间[a,b]分成n个小区间</p>\begin{align*}[x_0,x_1],[x_1,x_2],...,[x_{n-1},x_n],\end{align*}<p>各个小区间的长度依次为</p>\begin{align*}\Delta x_1 = x_1-x_0,\Delta x_2 = x_2-x_1,...,\Delta x_n = x_n-x_{n-1},\end{align*}<p>在每个小区间</p>\begin{align*}[x_n,x_{n-1}],\end{align*}<p>上任取一点ξ(ξ∈[xi-1,xi],作函数f(ξ)与小区间长度Δxi的乘积f(ξ)Δxi(i),并作出和</p>\begin{align*}S= \sum_{i=1}f(\xi_i) \Delta x_i\end{align*}<hr><h5 id="定积分基本性质">定积分基本性质</h5><p>(1)当a=b时,</p>\begin{align*}\int^b_a f(x)dx=0\end{align*}<p>(2)当a&gt;b时,</p>\begin{align*}\int^b_a f(x)dx= - \int^a_b f(x)dx\end{align*}<p><strong>性质1</strong></p>\begin{align*}\int^b_a [f(x) \pm g(x)]dx = \int^b_a f(x) \pm \int^b_a  g(x)dx \end{align*}<p><strong>性质2</strong></p>\begin{align*}\int^b_a kf(x)dx = k \int^b_a f(x)dx \end{align*}<p><strong>性质3</strong></p><p>设a&lt;c&lt;b,则</p>\begin{align*}\int^b_a f(x)dx = \int^c_a f(x)dx + \int^b_c f(x)dx \end{align*}<p><strong>性质4</strong></p><p>如果在区间[a,b]上f(x)≡1，则</p>\begin{align*}\int^b_a 1dx = \int^b_a dx=b-a\end{align*}<p><strong>性质5</strong></p><p>如果在区间[a,b]上f(x)≥0，则</p>\begin{align*}\int^b_a f(x)dx \ge 0 (a < b)\end{align*}<hr><h5 id="积分上限函数及其导数">积分上限函数及其导数</h5><p>设函数f(t)在区间[a,b]上连续，并且设x为[a,b]上的一点。在[a,b]定义一个函数，记作</p>\begin{align*}\Phi (x)= \int^x_a f(t)dt (a \le x \le b )\end{align*}<p><strong>定理1 如果函数f(x)在区间[a,b]上连续，则积分上限的函数</strong></p>\begin{align*}\Phi (x)= \int^x_a f(t)dt\end{align*}<p>在[a,b]上可导,并且它的导数是</p>\begin{align*}\Phi' (x)={d \over dx} \int^x_a f(t)dt=f(x)(a \le x \le b )\end{align*}<p><strong>证</strong> 若x∈(a,b),设x获得增量Δx,其绝对值足够地小，使得x+Δx∈(a,b),<br>则Φ（x）在x+Δx∈处的函数值为</p>\begin{align*}\Phi (x+\Delta x)=\int^{x+\Delta x}_a f(t)dt\end{align*}<p>由此得函数的增量为</p>\begin{align*}\Phi (x+\Delta x)-\Phi (x) &= \int^{x+\Delta x}_a f(t)dt - \int^{x}_a f(t)dt \\ &= \int^x_a f(t)dt+\int^{x+\Delta x}_x f(t)dt - \int^{x}_a f(t)dt \\ &= \int^{x+\Delta x}_x f(t)dt\end{align*}<p>应用积分中值定理有等式<br>ΔΦ(x)=f(ξ)Δx<br>即：</p>\begin{align*}{ΔΦ(x) \over Δx}=f(ξ)\end{align*}<p>由于f(x)在[a,b]上连续，当Δx→0，ξ→x,因此</p>\begin{align*}\lim_{\Delta x\to 0}f(ξ)=f(x)\end{align*}<p>两端取极限即可。</p><p><strong>定理2 如果函数f(x)在区间[a,b]上连续，则函数</strong></p>\begin{align*}\Phi (x)= \int^x_a f(t)dt\end{align*}<p><strong>就是f(x)在[a,b]上的一个原函数</strong></p><hr><h5 id="牛顿-莱布尼茨公式">牛顿-莱布尼茨公式</h5><p><strong>定理3 如果函数F(x)是连续函数f(x)在区间[a,b]上的一个原函数，则</strong></p>\begin{align*}\int^b_a f(x)dx=F(b)-F(a). \  \  (1)\end{align*}<p>证 已知函数F(x)是连续函数f(x)的一个原函数，又根据定理2知道，积分上限函数</p>\begin{align*}\Phi (x)= \int^x_a f(t)dt  \  \  (2)\end{align*}<p>也是f(x)的一个原函数.于是这两个原函数之差F(x)-Φ(x)在[a,b]上必定是一个常数C，即<br>差</p><p>F(x)-Φ(x)=C (a≤x≤b)   (3)</p><p>令x=a.得F(a)-Φ(a)=C,由定理2，得Φ(a)=0，因此F(a)=C,代入式(1),F(a)代入式(3)得</p>\begin{align*}F(x)- \int^x_a f(t)dt =F(a) \\\therefore \int^x_a f(t)dt =F(x)-F(a)\end{align*}<p>将x=b代入，即式（1）</p><p>也记为</p>\begin{align*}\therefore \int^b_a f(x)dx =[F(x)]_a^b\end{align*}]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.不定积分</title>
      <link href="/2019/10/24/%E6%95%B0%E5%AD%A6/6-%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/"/>
      <url>/2019/10/24/%E6%95%B0%E5%AD%A6/6-%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h5 id="基本积分表">基本积分表</h5>\begin{align*}1. &\int kdx = kx +C \\2. &\int x^n dx = {x^{n+1} \over {\mu +1}} +C \ (\mu \neq -1) \\3. &\int {dx \over x} = ln|x| +C \\4. &\int {dx \over {1+x^2}} = arctan x +C \\5. &\int {dx \over \sqrt {1+x^2}} = arcsin x +C \\6. &\int cosx \ dx = sin \ x + C \\7. &\int sinx \ dx = -cos \ x +C \\8. &\int {dx \over cos^2 x} = \int sec^2 x dx=tan x + C \\9. &\int {dx \over sin^2 x} = \int sec^2 x dx=-cot x + C \\10. &\int sec x \ tanx \ dx = sec x + C \\11. &\int csc x \ cot x \ dx = -csc x +C \\12. &\int e^x dx =e^x + C \\13. &\int a^x dx = {a^x \over ln \ a} + C \\14. &\int sh \ x \ dx = ch \ x + C \\15. &\int ch \ x \ dx = sh \ x + C\end{align*}<hr><h5 id="不定积分的性质">不定积分的性质:</h5><p><strong>性质1</strong> 设函数 f(x)及g(x)的原函数存在，则</p>\begin{align*}\int [f(x)+g(x)]dx = \int f(x)dx + \int g(x)dx\end{align*}<p><strong>性质2</strong> 设函数 f(x)及g(x)的原函数存在，则</p>\begin{align*}\int kf(x)dx = k \int f(x)dx \end{align*}<hr><h5 id="换元积分法">换元积分法</h5><p><strong>1，第一类换元积分法</strong></p><p><strong>定理1</strong> 设f(u)具有原函数，u=ψ(x)可导,则有换元公式</p>\begin{align*}\int f[ \psi(x)]\psi '(x)dx =[\int f(u)du]_{u=\psi(x)}\end{align*}<p><strong>2，第二类换元积分法</strong></p><p><strong>定理2</strong> 设x=ψ(t) 是单调的，可导的函数,并且ψ’(t)≠0.又设f[ψ(t)]ψ’(t)具有原函数,则有换元公式</p>\begin{align*}\int f(x)dx = [ \int  f[ \psi (t)] \psi ' (t)dt]_{t=\psi ^{-1} (x)}\end{align*}<p>其中</p>\begin{align*}\psi ^{-1} (x)\end{align*}<p>是x=ψ(t)的反函数.</p><p><strong>证</strong> 设f[ψ(t)]ψ’(t)的原函数为Ψ(t),记</p>\begin{align*}Ψ[ψ^{-1}(x)] = F(x)\end{align*}<p>，利用复合函数及反函数的求导法则，得到</p>\begin{align*}F'(x) = {\color{red}{d \Psi \over dt}} \cdot {\color{blue}{dt \over dx}} = {\color{red}f[ \psi(t) ] \psi'(t)} \cdot {\color{blue}{1 \over \psi'(t)}} = f[\psi (t)]=f(x)\end{align*}<hr><h5 id="分部积分法">分部积分法</h5>\begin{align*}\int u dv = uv - \int v du\end{align*}]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.微分中值定理</title>
      <link href="/2019/10/13/%E6%95%B0%E5%AD%A6/5-%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/"/>
      <url>/2019/10/13/%E6%95%B0%E5%AD%A6/5-%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="费马定理">费马定理</h4>\begin{align*}{设函数}f(x) {在点} x_0 {的某邻域} U(x_0) {内有定义，且在} x_0 {处可导。若对任意} x \in U(x_0)\end{align*}<p>有：</p>\begin{align*}f(x) \leq f(x_0) \quad \text{（或} \ f(x) \geq f(x_0)\text{）}\end{align*}<p>则：</p>\begin{align*}f'(x_0) = 0\end{align*}<p><strong>证明</strong>：<br>对于</p>\begin{align*}x_0 + \Delta x \in U(x_0)，\end{align*}<p>有</p>\begin{align*}f(x_0 + \Delta x) \leq f(x_0) \\\end{align*}<p>当 $$\Delta x &gt; 0$$ 时：</p>\begin{align*}\frac{f(x_0 + \Delta x) - f(x_0)}{\Delta x} \leq 0 \quad \text{（右导数非正）}\end{align*}<p>当 $$\Delta x &lt; 0$$ 时：</p>\begin{align*}\frac{f(x_0 + \Delta x) - f(x_0)}{\Delta x} \geq 0 \quad \text{（左导数非负）}\end{align*}<p>由可导性知左右导数相等，故 $$f’(x_0) = 0$$。</p><hr><h4 id="罗尔定理">罗尔定理</h4><p>若函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span> 满足：</p><ol><li>在闭区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">]</span></span></span></span> 上连续；</li><li>在开区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span></span></span></span> 内可导；</li><li>在区间端点处的函数值相等，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(a) = f(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">b</span><span class="mclose">)</span></span></span></span>，</li></ol><p>则在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span></span></span></span> 内至少存在一点 \xi{(a < ξ < b)} 使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup><mo>(</mo><mi>ξ</mi><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f&#x27;(\xi) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.04601em;">ξ</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span></span>。</p><hr><h4 id="拉格朗日中值定理">拉格朗日中值定理</h4><p>如果函数f(x)满足</p><p>(1)在闭区间[a,b]上连续;</p><p>(2)在开区间(a,b)内可导;</p><p>那么在(a,b)内至少有一点ξ(a&lt;ξ&lt;b) 使等式</p>\begin{align*}f(b)-f(a)=f'(\xi)(b-a)\end{align*}<p>成立</p><hr><p><strong>证:</strong></p><ol><li>构造辅助函数ψ(x)，等于f(x)曲线跟直线AB之间的垂直距离:</li></ol><p>有</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ψ</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>=</mo><mi>ψ</mi><mo>(</mo><mi>b</mi><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\psi(a)=\psi(b)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span></span></span></p><p>设直线AB的方程为y=L(x),则</p>\begin{align*}L(x) = f(a)+\frac{f(b)-f(a)}{b-a}(x-a)\end{align*}<p>由于M,N的纵坐标为f(x)及L(x)，有:</p>\begin{align*}\psi(x)=f(x)-L(x)=f(x)-\left[f(a)+\frac{f(b)-f(a)}{b-a}(x-a)\right] \quad (1)\end{align*}<ol start="2"><li>验证罗尔定理条件:</li></ol><ul><li>ψ(x)在[a,b]上连续</li><li>ψ(x)在(a,b)内可导</li><li>ψ(a)=ψ(b)=0</li></ul><p>对(1)式求导:</p>\begin{align*}\psi'(x)=f'(x)-\frac{f(b)-f(a)}{b-a}\end{align*}<ol start="3"><li>应用罗尔定理:<br>在(a,b)内至少存在一点ξ(a&lt;ξ&lt;b)使得ψ’(ξ)=0,即:</li></ol>\begin{align*}f'(\xi)-\frac{f(b)-f(a)}{b-a}=0\end{align*}<p>从而得到:</p>\begin{align*}f(b)-f(a)=f'(\xi)(b-a) \quad (2)\end{align*}<ol start="4"><li>推论:<br>如果函数f(x)在区间I上的导数恒为0，那么f(x)在区间I上是一个常数。</li></ol><p>证明:<br>由(2)式，当$ f’(ξ)=0 $时，有f(b)-f(a)=0，即f(b)=f(a)。由于a,b是I上任意两点，故f(x)在I上为常数。</p><hr><p><strong>注:</strong></p><ol><li>式(2)表明存在点ξ处的切线斜率等于弦AB的斜率</li><li>辅助函数ψ(x)的构造是关键，它表示曲线与弦的垂直距离</li><li>当f(a)=f(b)时，即为罗尔定理的特殊情形</li></ol><hr><h4 id="柯西中值定理">柯西中值定理</h4><p>若函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">F(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span> 满足：</p><ol><li>在闭区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">]</span></span></span></span> 上连续；</li><li>在开区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span></span></span></span> 内可导；</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo>∈</mo><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo separator="true">,</mo><msup><mi>F</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup><mo>(</mo><mi>x</mi><mo>)</mo><mo>≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\forall x \in (a,b), F&#x27;(x) \neq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∀</span><span class="mord mathit">x</span><span class="mrel">∈</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mrel">≠</span><span class="mord mathrm">0</span></span></span></span>，</li></ol><p>则在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span></span></span></span> 内至少存在一点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ξ</mi></mrow><annotation encoding="application/x-tex">\xi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.04601em;">ξ</span></span></span></span> 使得：</p>\begin{align*}\frac{f(b)-f(a)}{F(b)-F(a)} = \frac{f'(\xi)}{F'(\xi)} \quad \text{（两函数变化率之比相等）}\end{align*}<p><strong>证:</strong><br>f(x),F(x)应用(2)式，上下一除即可</p><hr><h4 id="洛必达法则">洛必达法则</h4><p><strong>定理1</strong>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">x \to a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">→</span><span class="mord mathit">a</span></span></span></span> 型）：<br>若：</p>\begin{align*}&1. \lim\limits_{x \to a} f(x) = \lim\limits_{x \to a} F(x) = 0 ； \\&2. 在 a 的去心邻域内 f'(x), F'(x) 存在且 F'(x) \neq 0； \\&3. \lim\limits_{x \to a} \frac{f'(x)}{F'(x)} 存在（或为无穷大）， \\\end{align*}<p>则：</p>\begin{align*}\lim_{x \to a} \frac{f(x)}{F(x)} = \lim_{x \to a} \frac{f'(x)}{F'(x)}\end{align*}<p><strong>定理2</strong>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">x \to \infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">→</span><span class="mord mathrm">∞</span></span></span></span> 型）：<br>将定理1中的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">x \to a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">→</span><span class="mord mathit">a</span></span></span></span> 改为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">x \to \infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">→</span><span class="mord mathrm">∞</span></span></span></span>，条件类似。</p><hr><h4 id="重要极限例子">重要极限例子</h4><ol><li>对数函数与幂函数：</li></ol>\begin{align*}\lim_{x \to \infty} \frac{\ln x}{x^n} &= \lim_{x \to \infty} {f'(x) \over F'(x)} \\&= \lim_{x \to \infty} \frac{1/x}{n x^{n-1}} \\&= \lim_{x \to \infty} \frac{1}{n x^n} \\&= 0 \quad \text{（对数增长慢于幂函数）}\end{align*}<ol start="2"><li>幂函数与指数函数：</li></ol>\begin{align*}\lim_{x \to \infty} \frac{x^n}{e^{\lambda x}} &= \lim_{x \to \infty} {f'(x) \over F'(x)} \\&= \lim_{x \to \infty} \frac{n x^{n-1}}{\lambda e^{\lambda x}} \\&= \cdots \\&= \lim_{x \to \infty} \frac{n!}{\lambda^n e^{\lambda x}} \\&= 0 \quad \text{（指数增长快于幂函数）}\end{align*}<hr><h4 id="泰勒公式">泰勒公式</h4><p><strong>泰勒中值定理</strong>：</p>\begin{align*} 若 f(x) 在含 x_0 的开区间 (a,b) 内有直到 (n+1) 阶导数，则对任意 x \in (a,b) 有：\end{align*}\begin{align*}f(x) &= f(x_0) + f'(x_0)(x-x_0) + \frac{f''(x_0)}{2!}(x-x_0)^2 + \cdots \\&\quad + \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n + R_n(x)\end{align*}<p>其中余项：</p>\begin{align*}R_n(x) = \frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1} \quad \text{（$\xi$ 在 $x_0$ 与 $x$ 之间）}\end{align*}]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.微分</title>
      <link href="/2019/09/28/%E6%95%B0%E5%AD%A6/4-%E5%BE%AE%E5%88%86/"/>
      <url>/2019/09/28/%E6%95%B0%E5%AD%A6/4-%E5%BE%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h3 id="定义">定义</h3><p><strong>微分的基本概念：</strong></p>\begin{align*}\Delta y &= f(x_0 + \Delta x) - f(x_0) \quad \text{（函数增量）} \\\Delta y &= A \Delta x + o(\Delta x) \quad \text{（线性近似+高阶无穷小）}\end{align*}<p><strong>微分表达式：</strong></p>\begin{align*}dy = y'_x(x)dx = f'(u)g'(x)dx \quad \text{（链式法则微分形式）}\end{align*}<hr><h4 id="复合函数的微分法则">复合函数的微分法则</h4><p><strong>乘法法则的微分形式：</strong></p>\begin{align*}d(uv) &= (uv)'dx \\[5pt]\text{∵}\quad (uv)' &= u'v + v'u \quad \text{（乘积导数法则）} \\[5pt]u'dx &= du \\[5pt]v'dx &= dv \\[5pt]\text{∴}\quad d(uv) &=(u'v+v'u)dx \\&=u'vdx+v'udx \\&= vdu + udv \quad \text{（微分乘积法则）} \\\end{align*}<p><strong>复合函数示例：</strong></p>\begin{align*}y &= \sin(2x+1) \\dy &= d(\sin u) = \cos(2x+1)d(2x+1) \\&= \cos(2x+1) \cdot 2dx = 2\cos(2x+1)dx \text{（先外函数后内函数）}\end{align*}<hr><h4 id="近似计算原理">近似计算原理</h4><p><strong>线性近似公式：</strong></p>\begin{align*}\text{∵} \Delta y=f(x_0 + \Delta x) - f(x_0)&\approx dy = f'(x_0)\Delta x \quad \text{（用切线近似函数）} \\[5pt]\text{∴} f(x_0 + \Delta x) \approx f(x_0) + f'(x_0) \Delta x \\[5pt]for \ x=(x_0 + \Delta x): \\[5pt]f(x) &\approx f(x_0) + f'(x_0)(x-x_0) \quad \text{（泰勒展开一阶项）}\end{align*}<hr><h4 id="常用近似公式（当-x-很小时）：">常用近似公式（当|x|很小时）：</h4><ol><li><p><strong>n次方根：</strong></p>\begin{align*}\sqrt[n]{1+x} \approx f(0) + f'(0)x (x - 0) =1 +(\frac{1}{n})(x)  = 1 + \frac{1}{n}x\end{align*}<p>如 $$\sqrt{1.02} \approx 1.01$$</p></li><li><p><strong>正弦函数：</strong></p>\begin{align*}\sin x \approx f(0) + f'(0)(x - 0) = 0 + \cos(0)x = x\end{align*}<p>小角度时正弦值≈弧度值</p></li><li><p><strong>正切函数：</strong></p>\begin{align*}\tan x &= \frac{\sin x}{\cos x} \\[5pt]\text{∵}\quad \tan'x &= \frac{\cos^2x + \sin^2x}{\cos^2x} = \frac{1}{\cos^2x} = \sec^2x \\[5pt]\text{∴}\quad \tan x &\approx f(0) + f'(0)(x - 0) = 0 + 1 \cdot x = x\end{align*}<p>小角度时正切值≈弧度值</p></li><li><p><strong>指数函数：</strong></p>\begin{align*}e^x \approx f(0) + f'(0)(x - 0) = 1 + x\end{align*}<p>如 $$e^{0.01} \approx 1.01$$</p></li><li><p><strong>对数函数：</strong></p>\begin{align*}\ln(1+x) \approx f(0) + f'(0)(x - 0) = 0 + 1 \cdot x = x\end{align*}<p>如 $$\ln(1.02) \approx 0.02$$</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.莱布尼兹公式</title>
      <link href="/2019/09/28/%E6%95%B0%E5%AD%A6/3-%E8%8E%B1%E5%B8%83%E5%B0%BC%E5%85%B9%E5%85%AC%E5%BC%8F/"/>
      <url>/2019/09/28/%E6%95%B0%E5%AD%A6/3-%E8%8E%B1%E5%B8%83%E5%B0%BC%E5%85%B9%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>对于幂函数：</p>\begin{align*}&y=x^n \\&y' = n x^{n-1} \\&y''=n(n-1)x^{n-2}  \\&...\\&y^{(m)}=n(n-1)...(n-m+1) x^{(n-m)}=n!/m! x^{(n-m)} \\if  \ n=m: \\&y^{(n)}=n!\end{align*}<p>莱布尼兹公式:</p>\begin{align*}(uv)^{(n)} = \sum^n_{k=0}C^k_nu^{(n-k)}v^{(k)}\end{align*}]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.函数的求导法则</title>
      <link href="/2019/09/28/%E6%95%B0%E5%AD%A6/2-%E5%87%BD%E6%95%B0%E7%9A%84%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99/"/>
      <url>/2019/09/28/%E6%95%B0%E5%AD%A6/2-%E5%87%BD%E6%95%B0%E7%9A%84%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99/</url>
      
        <content type="html"><![CDATA[\begin{align*}(1)\ & [u(x) \pm v(x)]' = u'(x) \pm v'(x) \\[10pt](2)\ & [u(x)v(x)]' = u'(x)v(x) + u(x)v'(x) \\[10pt](3)\ & \left[\frac{u(x)}{v(x)}\right]' = \frac{u'(x)v(x) - u(x)v'(x)}{v^2(x)}\end{align*}<h3 id="证明">证明</h3><h4 id="1-加减法则">(1) 加减法则</h4>\begin{align*}[u(x) \pm v(x)]' &= \lim_{\Delta x \to 0} \frac{[u(x + \Delta x) \pm v(x + \Delta x)] - [u(x) \pm v(x)]}{\Delta x} \\&= \lim_{\Delta x \to 0} \frac{[u(x + \Delta x) - u(x)] \pm [v(x + \Delta x) - v(x)]}{\Delta x} \\&= \lim_{\Delta x \to 0} \frac{u(x + \Delta x) - u(x)}{\Delta x} \pm \lim_{\Delta x \to 0} \frac{v(x + \Delta x) - v(x)}{\Delta x} \\&= u'(x) \pm v'(x)\end{align*}<h4 id="2-乘法法则">(2) 乘法法则</h4>\begin{align*}[u(x)v(x)]' &= \lim_{\Delta x \to 0} \frac{u(x + \Delta x)v(x + \Delta x) - u(x)v(x)}{\Delta x} \\&= \lim_{\Delta x \to 0} \left[  \frac{u(x + \Delta x) - u(x)}{\Delta x} \cdot v(x + \Delta x)   + u(x) \cdot \frac{v(x + \Delta x) - v(x)}{\Delta x}\right] \\&= u'(x)v(x) + u(x)v'(x)\end{align*}<h4 id="3-除法法则">(3) 除法法则</h4>\begin{align*}\left[\frac{u(x)}{v(x)}\right]' &= \lim_{\Delta x \to 0} \frac{\frac{u(x + \Delta x)}{v(x + \Delta x)} - \frac{u(x)}{v(x)}}{\Delta x} \\&= \lim_{\Delta x \to 0} \frac{u(x + \Delta x)v(x) - u(x)v(x + \Delta x)}{\Delta x \cdot v(x)v(x + \Delta x)} \\&= \lim_{\Delta x \to 0} \frac{  \frac{[u(x + \Delta x) - u(x)]v(x)}{\Delta x}   - \frac{u(x)[v(x + \Delta x) - v(x)]}{\Delta x}}{v(x)v(x + \Delta x)} \\&= \frac{u'(x)v(x) - u(x)v'(x)}{v^2(x)}\end{align*}<hr><h3 id="反函数的导数">反函数的导数</h3>\begin{align*}[f^{-1}(x)]' = \lim_{\Delta x \to 0} \frac{\Delta y}{\Delta x} = \lim_{\Delta y \to 0} \frac{1}{\frac{\Delta x}{\Delta y}} = \frac{1}{f'(y)}\end{align*}<hr><h3 id="复合函数导数">复合函数导数</h3>\begin{align*}y &= f(u) \\u &= g(x) \\y &= f[g(x)] \\[10pt]\frac{dy}{dx} &= f'(u) \cdot g'(x) = \frac{dy}{du} \cdot \frac{du}{dx}\end{align*}<hr><h3 id="隐函数求导">隐函数求导</h3><h4 id="例1">例1</h4>\begin{align*}x + y^3 - 1 &= 0 \\1 + 3y^2 \cdot \frac{dy}{dx} &= 0\end{align*}<h4 id="例2">例2</h4>\begin{align*}e^y + xy - e &= 0 \\e^y \frac{dy}{dx} + y + x\frac{dy}{dx} &= 0\end{align*}<hr><h3 id="参数方程导数">参数方程导数</h3><h4 id="运动学示例">运动学示例</h4>\begin{align*}\begin{cases}x = v_1 t \\y = v_2 t - \frac{1}{2}gt^2\end{cases}\end{align*}<h4 id="一般形式">一般形式</h4>\begin{align*}\begin{cases}x = \varphi(t) \\y = \psi(t)\end{cases}\quad \Rightarrow \quad\frac{dy}{dx} = \frac{\frac{dy}{dt}}{\frac{dx}{dt}} = \frac{\psi'(t)}{\varphi'(t)}\end{align*}]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.初等函数的导数推导</title>
      <link href="/2019/09/28/%E6%95%B0%E5%AD%A6/1-%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E6%95%B0%E6%8E%A8%E5%AF%BC/"/>
      <url>/2019/09/28/%E6%95%B0%E5%AD%A6/1-%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E6%95%B0%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="初等函数的导数推导">初等函数的导数推导</h2><h3 id="1-幂函数求导">1. 幂函数求导</h3><p>求 $$\textcolor{red}{f(x)=x^n}$$ 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">x=a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">=</span><span class="mord mathit">a</span></span></span></span> 处的导数：</p>\begin{align*}f'(x) &= \lim_{x\to a} \frac{f(x)-f(a)}{x-a} \\&= \lim_{x\to a} \frac{x^n-a^n}{x-a} \\&= \lim_{x\to a} \frac{(x^n-ax^{n-1}) + (ax^{n-1}-a^2x^{n-2}) + \cdots + a^{n-1}x-a^n}{x-a} \\&= \lim_{x\to a} \left[(x^{n-1}) + (ax^{n-2}) + \cdots + a^{n-1}\right] \\&= \lim_{x\to a} (x^{n-1}) + \lim_{x \to a} (ax^{n-2})...+\lim_{x\to a} a^{n-1} \\&= na^{n-1}\end{align*}\begin{align*}\thereforef(x)=x^n \\f'(x) = n x^{n-1}\end{align*}<hr><h3 id="2-正弦函数求导">2. 正弦函数求导</h3><p>求 $$\textcolor{red}{f(x)= \sin x}$$ 的导数：</p>\begin{align*}f'(x) &= \lim_{h\to 0} \frac{f(x+h)-f(x)}{h} \\&= \lim_{h\to 0} \frac{\sin(x+h)-\sin x}{h} \\&= \lim_{h\to 0} \frac{2\sin\left(\frac{h}{2}\right)\cos\left(x+\frac{h}{2}\right)}{h} \\&= \lim_{h\to 0} \left(\frac{\sin\left(\frac{h}{2}\right)}{\frac{h}{2}} \cdot \cos\left(x+\frac{h}{2}\right)\right) \\&= \cos x\end{align*}<hr><h3 id="3-余弦函数求导">3. 余弦函数求导</h3><p>求 $$\textcolor{red}{f(x)= \cos x}$$ 的导数：</p>\begin{align*}f'(x) &= \lim_{h\to 0} {f(x+h)-f(x) \over h} \\&= \lim_{h\to 0} \frac{\cos(x+h)-\cos x}{h} \\&= \lim_{h\to 0} \frac{-2\sin\left(\frac{h}{2}\right)\sin\left(x+\frac{h}{2}\right)}{h} \\&= -\lim_{h\to 0} \left(\frac{\sin\left(\frac{h}{2}\right)}{\frac{h}{2}} \cdot \sin\left(x+\frac{h}{2}\right)\right) \\&= -\sin x\end{align*}<hr><h3 id="4-指数函数求导">4. 指数函数求导</h3><p>求 $$\textcolor{red}{f(x)= a^x}$$ 的导数：</p>\begin{align*}f'(x) &= \lim_{h\to 0} {f(x+h)-f(x) \over h} \\&= \lim_{h\to 0} \frac{a^{x+h}-a^x}{h} \\&= \textcolor{red}{a^x \lim_{h\to 0} \frac{a^h-1}{h}} \\&= \textcolor{red}{a^x \ln a}\end{align*}<p><strong>推导关键步骤</strong>：<br>令 $$t = a^h - 1$$，则：</p>\begin{align*}a=log_a (t+1)\end{align*}\begin{align*}此时有:\textcolor{red}{\lim_{h\to 0} \frac{a^h-1}{h} = \lim_{t\to 0} \frac{t}{\log_a(t+1)} = \ln a}\end{align*}<hr><h3 id="5-对数函数求导">5. 对数函数求导</h3><p>求 $$\textcolor{red}{f(x)= \log_a x}$$ 的导数：</p>\begin{align*}f'(x) &= \lim_{h\to 0} {f(x+h)-f(x) \over h} \\&= \lim_{h\to 0} \frac{\log_a(x+h) - \log_a x}{h} \\&= \lim_{h\to 0} {log_a \ {(x+h) \over x} \over h} \\&= \lim_{h\to 0} \frac{1}{x} \cdot \textcolor{red}{\frac{\log_a\left(1+\frac{h}{x}\right)}{\frac{h}{x}}} \\&\textcolor{red}{= \frac{1}{x \ln a}}\end{align*}<p><strong>特例</strong>：当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">a=e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mrel">=</span><span class="mord mathit">e</span></span></span></span> 时，</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>l</mi><mi>n</mi><mtext> </mtext><mi>x</mi></mrow><annotation encoding="application/x-tex">f(x)= ln \ x </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">n</span><span class="mord mspace"> </span><span class="mord mathit">x</span></span></span></span></span></p>\begin{align*}& f'(x) =(\ln x)' = \frac{1}{x}\end{align*}]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0.中学数学复习</title>
      <link href="/2019/09/13/%E6%95%B0%E5%AD%A6/0-%E4%B8%AD%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0/"/>
      <url>/2019/09/13/%E6%95%B0%E5%AD%A6/0-%E4%B8%AD%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="等比公式：">等比公式：</h4>\begin{align*}S_n=a_1(1-q^n)/(1-q)\end{align*}<h4 id="等差公式：">等差公式：</h4>\begin{align*}S_n=(a_1+a_n)n/2=na_1+n(n-1)d/2\end{align*}<hr><h3 id="排列组合：">排列组合：</h3><h4 id="排列">排列</h4>\begin{align*}A^m_n=n(n-1)(n-2)...(n-m+1)=\frac{n!}{(n-m)!}\end{align*}<h4 id="组合">组合</h4>\begin{align*}C^m_n={A^m_n \over m!}={n(n-1)(n-2)...(n-m+1)\over m!}={n! \over m!(n-m)!}\end{align*}<hr><h3 id="牛顿二项式">牛顿二项式</h3>\begin{align*}(a+b)^n=\sum^n_{k=0}C^k_nx^k\end{align*}<hr><h3 id="三角函数">三角函数</h3>\begin{align*}\sin(\alpha+\beta)=\sin(\alpha)\cos(\beta)+\cos(\alpha)\sin(\beta)\therefore \sin(2\alpha)=2\sin(\alpha)\cos(\alpha)\end{align*}\begin{align*}\cos(\alpha+\beta)=\cos(\alpha)\cos(\beta)-\sin(\alpha)s\in(\beta)\therefore \cos(2\alpha)=\cos^2(\alpha)-\sin^2(\alpha)\end{align*}<hr><h3 id="对数函数">对数函数</h3><hr><p>e的定义</p>\begin{align*}\lim_{x\to \infty} (1+{1 \over {n}})^n=e\end{align*}]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX的写法</title>
      <link href="/2019/09/12/%E6%95%B0%E5%AD%A6/markdown-latex%E7%9A%84%E6%95%B0%E5%AD%A6%E5%BC%8F%E5%86%99%E6%B3%95/"/>
      <url>/2019/09/12/%E6%95%B0%E5%AD%A6/markdown-latex%E7%9A%84%E6%95%B0%E5%AD%A6%E5%BC%8F%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>数学符号和对应的LaTeX代码：</p><table><thead><tr><th>符号显示</th><th>LaTeX代码</th><th>符号显示</th><th>LaTeX代码</th></tr></thead><tbody><tr><td>∑</td><td><code>$\sum$</code></td><td>∑_{i=0}^n</td><td><code>$\sum_&#123;i=0&#125;^n$</code></td></tr><tr><td>∏</td><td><code>$\prod$</code></td><td>∏_{i=0}^n</td><td><code>$\prod_&#123;i=0&#125;^n$</code></td></tr><tr><td>×</td><td><code>$\times$</code></td><td>∗</td><td><code>$\ast$</code></td></tr><tr><td>±</td><td><code>$\pm$</code></td><td>÷</td><td><code>$\div$</code></td></tr><tr><td>∣</td><td><code>$\mid$</code></td><td>⋅</td><td><code>$\cdot$</code></td></tr><tr><td>⨀</td><td><code>$\bigodot$</code></td><td>≈</td><td><code>$\approx$</code></td></tr><tr><td>≤</td><td><code>$\leq$</code></td><td>≥</td><td><code>$\geq$</code></td></tr><tr><td>≠</td><td><code>$\neq$</code></td><td>≡</td><td><code>$\equiv$</code></td></tr><tr><td>x̄</td><td><code>$\overline&#123;x&#125;$</code></td><td>x̲</td><td><code>$\underline&#123;x&#125;$</code></td></tr><tr><td>x̂</td><td><code>$\hat&#123;x&#125;$</code></td><td>x̌</td><td><code>$\check&#123;x&#125;$</code></td></tr><tr><td>x̆</td><td><code>$\breve&#123;x&#125;$</code></td><td>↑</td><td><code>$\uparrow$</code></td></tr><tr><td>↓</td><td><code>$\downarrow$</code></td><td>←</td><td><code>$\leftarrow$</code></td></tr><tr><td>→</td><td><code>$\rightarrow$</code></td><td>⇑</td><td><code>$\Uparrow$</code></td></tr><tr><td>⇓</td><td><code>$\Downarrow$</code></td><td>⇐</td><td><code>$\Leftarrow$</code></td></tr><tr><td>⇒</td><td><code>$\Rightarrow$</code></td><td>⟵</td><td><code>$\longleftarrow$</code></td></tr><tr><td>⟶</td><td><code>$\longrightarrow$</code></td><td>⟸</td><td><code>$\Longleftarrow$</code></td></tr><tr><td>⟹</td><td><code>$\Longrightarrow$</code></td><td>∵</td><td><code>$\because$</code></td></tr><tr><td>∴</td><td><code>$\therefore$</code></td><td>∀</td><td><code>$\forall$</code></td></tr><tr><td>∃</td><td><code>$\exists$</code></td><td>y′</td><td><code>$y'$</code></td></tr><tr><td>∫</td><td><code>$\int$</code></td><td>∬</td><td><code>$\iint$</code></td></tr><tr><td>∭</td><td><code>$\iiint$</code></td><td>∮</td><td><code>$\oint$</code></td></tr><tr><td>lim</td><td><code>$\lim$</code></td><td>∞</td><td><code>$\infty$</code></td></tr><tr><td>∇</td><td><code>$\nabla$</code></td><td>⊥</td><td><code>$\bot$</code></td></tr><tr><td>∠30°</td><td><code>$\angle 30^\circ$</code></td><td>sin</td><td><code>$\sin$</code></td></tr><tr><td>cos</td><td><code>$\cos$</code></td><td>tan</td><td><code>$\tan$</code></td></tr><tr><td>cot</td><td><code>$\cot$</code></td><td>sec</td><td><code>$\sec$</code></td></tr><tr><td>csc</td><td><code>$\csc$</code></td><td>log</td><td><code>$\log$</code></td></tr><tr><td>lg</td><td><code>$\lg$</code></td><td>ln</td><td><code>$\ln$</code></td></tr><tr><td>∅</td><td><code>$\emptyset$</code></td><td>∈</td><td><code>$\in$</code></td></tr><tr><td>∉</td><td><code>$\notin$</code></td><td>⊂</td><td><code>$\subset$</code></td></tr><tr><td>⊃</td><td><code>$\supset$</code></td><td>⊆</td><td><code>$\subseteq$</code></td></tr><tr><td>⊇</td><td><code>$\supseteq$</code></td><td>⋂</td><td><code>$\bigcap$</code></td></tr><tr><td>⋃</td><td><code>$\bigcup$</code></td><td>⋁</td><td><code>$\bigvee$</code></td></tr><tr><td>⋀</td><td><code>$\bigwedge$</code></td><td>⨄</td><td><code>$\biguplus$</code></td></tr><tr><td>⨆</td><td><code>$\bigsqcup$</code></td><td></td><td></td></tr></tbody></table><h3 id="分式与特殊符号">分式与特殊符号</h3><table><thead><tr><th>显示</th><th>LaTeX代码</th></tr></thead><tbody><tr><td>1/(2x+1)</td><td><code>$\frac&#123;1&#125;&#123;2x+1&#125;$</code></td></tr><tr><td>1/(2x+1)</td><td><code>$&#123;&#123;1&#125; \over &#123;2x+1&#125;&#125;$</code></td></tr><tr><td>du/dx|_{x=0}</td><td>`$\left.\frac{du}{dx}\right</td></tr><tr><td>∛9</td><td><code>$\sqrt[3]&#123;9&#125;$</code></td></tr><tr><td>√16</td><td><code>$\sqrt&#123;16&#125;$</code></td></tr><tr><td>…</td><td><code>$\ldots$</code></td></tr><tr><td>f(x₁,x₂,…,xₙ)=x₁²+⋯+xₙ²</td><td><code>$f(x_1,x_2,\ldots,x_n)=x_1^2+\cdots+x_n^2$</code></td></tr><tr><td>a⃗</td><td><code>$\vec&#123;a&#125;$</code></td></tr><tr><td>∫₀¹ x²dx</td><td><code>$\int_0^1 x^2 dx$</code></td></tr><tr><td>limₙ→∞ 1/[n(n+1)]</td><td><code>$\lim_&#123;n\to\infty&#125;\frac&#123;1&#125;&#123;n(n+1)&#125;$</code></td></tr><tr><td>∑₁ⁿ 1/x²</td><td><code>$\sum_1^n \frac&#123;1&#125;&#123;x^2&#125;$</code></td></tr><tr><td>x∈[0,100]</td><td><code>$x \in [0,100]$</code></td></tr><tr><td>xʸᶻ=(1+eˣ)⁻²ˣʸʷ</td><td><code>$x^&#123;y^z&#125;=(1+e^x)^&#123;-2xy^w&#125;$</code></td></tr></tbody></table><h3 id="分段函数">分段函数</h3>\begin{align*}y = \begin{cases} x \\ \alpha \end{cases}\end{align*}<p>LaTeX代码：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span>y =<span class="keyword">\begin</span>&#123;cases&#125; x<span class="keyword">\\</span> <span class="keyword">\alpha</span> <span class="keyword">\end</span>&#123;cases&#125;<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java变量类型</title>
      <link href="/2019/01/18/Java%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/01/18/Java%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="变量类型">变量类型</h3><hr><p>在Java语言中，所有的变量在使用前必须声明。声明变量的基本格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type identifier [ = value][, identifier [= value] ...] ;</span><br></pre></td></tr></table></figure><p>格式说明：type为Java数据类型。identifier是变量名。可以使用逗号隔开来声明多个同类型变量。<br>以下列出了一些变量的声明实例。注意有些包含了初始化过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a, b, c;         // 声明三个int型整数：a、 b、c</span><br><span class="line">int d = 3, e = 4, f = 5; // 声明三个整数并赋予初值</span><br><span class="line">byte z = 22;         // 声明并初始化 z</span><br><span class="line">String s = &quot;runoob&quot;;  // 声明并初始化字符串 s</span><br><span class="line">double pi = 3.14159; // 声明了双精度浮点型变量 pi</span><br><span class="line">char x = &#x27;x&#x27;;        // 声明变量 x 的值是字符 &#x27;x&#x27;。</span><br></pre></td></tr></table></figure><h1></h1><p>Java语言支持的变量类型有：</p><ul><li>类变量：独立于方法之外的变量，用 static 修饰。</li><li>实例变量：独立于方法之外的变量，不过没有 static 修饰。</li><li>局部变量：类的方法中的变量。</li></ul><h1></h1><h4 id="Java-局部变量">Java 局部变量</h4><ul><li>局部变量声明在方法、构造方法或者语句块中；</li><li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li><li>==访问修饰符不能用于局部变量；==</li><li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li><li>局部变量是在栈上分配的。</li><li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li></ul><h1></h1><h4 id="Java-实例变量">Java 实例变量</h4><ul><li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li><li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li><li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</li><li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li><li>实例变量可以声明在使用前或者使用后；</li><li>==访问修饰符可以修饰实例变量；==</li><li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li><li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li><li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</li></ul><h1></h1><h4 id="类变量（静态变量）">类变量（静态变量）</h4><ul><li>类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。</li><li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li><li>静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。</li><li>==静态变量储存在静态存储区。==经常被声明为常量，很少单独使用static声明变量。</li><li>静态变量在第一次被访问时创建，在程序结束时销毁。</li><li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。</li><li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li><li>静态变量可以通过：ClassName.VariableName的方式访问。</li><li>类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git rebase</title>
      <link href="/2017/09/16/git/git-rebase/"/>
      <url>/2017/09/16/git/git-rebase/</url>
      
        <content type="html"><![CDATA[<h2 id="变基">变基</h2><p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。</p><h3 id="变基的基本操作">变基的基本操作</h3><p>请回顾之前在 <a href="https://git-scm.com/book/zh/v2/ch00/_basic_merging">分支的合并</a> 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。</p><p><img src="https://git-scm.com/book/zh/v2/images/basic-rebase-1.png" alt="分叉的提交历史。"></p><p>Figure 35. 分叉的提交历史</p><p>之前介绍过，整合分支最容易的方法是 <code>merge</code> 命令。 它会把两个分支的最新快照（<code>C3</code> 和 <code>C4</code>）以及二者最近的共同祖先（<code>C2</code>）进行三方合并，合并的结果是生成一个新的快照（并提交）。</p><p><img src="https://git-scm.com/book/zh/v2/images/basic-rebase-2.png" alt="通过合并操作来整合分叉了的历史。"></p><p>Figure 36. 通过合并操作来整合分叉的历史</p><p>其实，还有一种方法：你可以提取在 <code>C4</code> 中引入的补丁和修改，然后在 <code>C3</code> 的基础上应用一次。 在 Git 中，这种操作就叫做 <strong>变基（rebase）</strong>。 你可以使用 <code>rebase</code> 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p><p>在这个例子中，你可以检出 <code>experiment</code> 分支，然后将它变基到 <code>master</code> 分支上：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout experiment</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase master</span></span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: added staged command</span><br></pre></td></tr></table></figure><p>它的原理是首先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的目标基底分支 <code>master</code>） 的最近共同祖先 <code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 <code>C3</code>, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同）</p><p><img src="https://git-scm.com/book/zh/v2/images/basic-rebase-3.png" alt="将  中的修改变基到  上。"></p><p>Figure 37. 将 <code>C4</code> 中的修改变基到 <code>C3</code> 上</p><p>现在回到 <code>master</code> 分支，进行一次快进合并。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge experiment</span></span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/zh/v2/images/basic-rebase-4.png" alt=" 分支的快进合并。"></p><p>Figure 38. <code>master</code> 分支的快进合并</p><p>此时，<code>C4'</code> 指向的快照就和 <a href="https://git-scm.com/book/zh/v2/ch00/ebasing-merging-example">the merge example</a> 中 <code>C5</code> 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p><p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 <code>origin/master</code> 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p><p>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p><h3 id="更有趣的变基例子">更有趣的变基例子</h3><p>在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 <a href="https://git-scm.com/book/zh/v2/ch00/bdiag_e">从一个主题分支里再分出一个主题分支的提交历史</a> 中的例子那样。 你创建了一个主题分支 <code>server</code>，为服务端添加了一些功能，提交了 <code>C3</code> 和 <code>C4</code>。 然后从 <code>C3</code> 上创建了主题分支 <code>client</code>，为客户端添加了一些功能，提交了 <code>C8</code> 和 <code>C9</code>。 最后，你回到 <code>server</code> 分支，又提交了 <code>C10</code>。</p><p><img src="https://git-scm.com/book/zh/v2/images/interesting-rebase-1.png" alt="从一个主题分支里再分出一个主题分支的提交历史。"></p><p>Figure 39. 从一个主题分支里再分出一个主题分支的提交历史</p><p>假设你希望将 <code>client</code> 中的修改合并到主分支并发布，但暂时并不想合并 <code>server</code> 中的修改， 因为它们还需要经过更全面的测试。这时，你就可以使用 <code>git rebase</code> 命令的 <code>--onto</code> 选项， 选中在 <code>client</code> 分支里但不在 <code>server</code> 分支里的修改（即 <code>C8</code> 和 <code>C9</code>），将它们在 <code>master</code> 分支上重放：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase --onto master server client</span></span><br></pre></td></tr></table></figure><p>以上命令的意思是：“取出 <code>client</code> 分支，找出它从 <code>server</code> 分支分歧之后的补丁， 然后把这些补丁在 <code>master</code> 分支上重放一遍，让 <code>client</code> 看起来像直接基于 <code>master</code> 修改一样”。这理解起来有一点复杂，不过效果非常酷。</p><p><img src="https://git-scm.com/book/zh/v2/images/interesting-rebase-2.png" alt="截取主题分支上的另一个主题分支，然后变基到其他分支。"></p><p>Figure 40. 截取主题分支上的另一个主题分支，然后变基到其他分支</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge client</span></span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/zh/v2/images/interesting-rebase-3.png" alt="快进合并  分支，使之包含来自  分支的修改。"></p><p>Figure 41. 快进合并 <code>master</code> 分支，使之包含来自 <code>client</code> 分支的修改</p><p>接下来你决定将 <code>server</code> 分支中的修改也整合进来。 使用 <code>git rebase &lt;basebranch&gt; &lt;topicbranch&gt;</code> 命令可以直接将主题分支 （即本例中的 <code>server</code>）变基到目标分支（即 <code>master</code>）上。 这样做能省去你先切换到 <code>server</code> 分支，再对其执行变基命令的多个步骤。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase master server</span></span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/zh/v2/images/interesting-rebase-4.png" alt="将  中的修改变基到  上。"></p><p>Figure 42. 将 <code>server</code> 中的修改变基到 <code>master</code> 上</p><p>然后就可以快进合并主分支 <code>master</code> 了：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge server</span></span><br></pre></td></tr></table></figure><p>至此，<code>client</code> 和 <code>server</code> 分支中的修改都已经整合到主分支里了， 你可以删除这两个分支，最终提交历史会变成图 <a href="https://git-scm.com/book/zh/v2/ch00/bdiag_i">最终的提交历史</a> 中的样子：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d client</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d server</span></span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/zh/v2/images/interesting-rebase-5.png" alt="最终的提交历史。"></p><p>Figure 43. 最终的提交历史</p><h3 id="变基的风险">变基的风险</h3><p>呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：</p><p><strong>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。</strong></p><p>如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p><p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p><p>让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：</p><p><img src="https://git-scm.com/book/zh/v2/images/perils-of-rebasing-1.png" alt="克隆一个仓库，然后在它的基础上进行了一些开发。"></p><p>Figure 44. 克隆一个仓库，然后在它的基础上进行了一些开发</p><p>然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：</p><p><img src="https://git-scm.com/book/zh/v2/images/perils-of-rebasing-2.png" alt="抓取别人的提交，合并到自己的开发分支。"></p><p>Figure 45. 抓取别人的提交，合并到自己的开发分支</p><p>接下来，这个人又决定把合并操作回滚，改用变基；继而又用 <code>git push --force</code> 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。</p><p><img src="https://git-scm.com/book/zh/v2/images/perils-of-rebasing-3.png" alt="有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交。"></p><p>Figure 46. 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交</p><p>结果就是你们两人的处境都十分尴尬。 如果你执行 <code>git pull</code> 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：</p><p><img src="https://git-scm.com/book/zh/v2/images/perils-of-rebasing-4.png" alt="你将相同的内容又合并了一次，生成了一个新的提交。"></p><p>Figure 47. 你将相同的内容又合并了一次，生成了一个新的提交</p><p>此时如果你执行 <code>git log</code> 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 <code>C4</code> 和 <code>C6</code>，因为之前就是他把这两个提交通过变基丢弃的。</p><h3 id="用变基解决变基">用变基解决变基</h3><p>如果你 <strong>真的</strong> 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。</p><p>实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patch-id”。</p><p>如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。</p><ul><li><p>检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</p></li><li><p>检查其中哪些提交不是合并操作的结果（C2，C3，C4）</p></li><li><p>检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’）</p></li><li><p>把查到的这些提交应用在 <code>teamone/master</code> 上面</p></li></ul><p><img src="https://git-scm.com/book/zh/v2/images/perils-of-rebasing-5.png" alt="在一个被变基然后强制推送的分支上再次执行变基。"></p><p>Figure 48. 在一个被变基然后强制推送的分支上再次执行变基</p><p>要想上述方案有效，还需要对方在变基时确保 <code>C4'</code> 和 <code>C4</code> 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 <code>C4</code> 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。</p><p>在本例中另一种简单的方法是使用 <code>git pull --rebase</code> 命令而不是直接 <code>git pull</code>。 又或者你可以自己手动完成这个过程，先 <code>git fetch</code>，再 <code>git rebase teamone/master</code>。</p><p>如果你习惯使用 <code>git pull</code> ，同时又希望默认使用选项 <code>--rebase</code>，你可以执行这条语句 <code>git config --global pull.rebase true</code> 来更改 <code>pull.rebase</code> 的默认配置。</p><p>如果你只对不会离开你电脑的提交执行变基，那就不会有事。 如果你对已经推送过的提交执行变基，但别人没有基于它的提交，那么也不会有事。 如果你对已经推送至共用仓库的提交上执行变基命令，并因此丢失了一些别人的开发所基于的提交， 那你就有大麻烦了，你的同事也会因此鄙视你。</p><p>如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 <code>git pull --rebase</code> 命令，这样尽管不能避免伤痛，但能有所缓解。</p><h3 id="变基-vs-合并">变基 vs. 合并</h3><p>至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。</p><p>有一种观点认为，仓库的提交历史即是 <strong>记录实际发生过什么</strong>。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 <em>谎言</em> 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p><p>另一种观点则正好相反，他们认为提交历史是 <strong>项目过程中发生的事</strong>。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 <code>rebase</code> 及 <code>filter-branch</code> 等工具来编写故事，怎么方便后来的读者就怎么写。</p><p>现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p><p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git flow</title>
      <link href="/2017/09/15/git/git-flow/"/>
      <url>/2017/09/15/git/git-flow/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-Flow">Git Flow</h2><p>Git Flow 是一种基于 Git 的分支模型，旨在帮助团队更好地管理和发布软件。</p><p>Git Flow 由 Vincent Driessen 在 2010 年提出，并通过一套标准的分支命名和工作流程，使开发、测试和发布过程更加有序和高效。</p><p>Git Flow 主要由以下几类分支组成：<code>master</code>、<code>develop</code>、<code>feature</code>、<code>release</code>、<code>hotfix</code>。</p><h2 id="Git-Flow-安装">Git Flow 安装</h2><h3 id="Linux">Linux</h3><p><strong>Debian/Ubuntu:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git-flow</span><br></pre></td></tr></table></figure><p><strong>Fedora:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install gitflow</span><br><span class="line">sudo apt-get install git-flow</span><br></pre></td></tr></table></figure><h3 id="macOS">macOS</h3><p>在 macOS 上，你可以使用 Homebrew 来安装 Git Flow:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git-flow</span><br></pre></td></tr></table></figure><h3 id="源码安装">源码安装</h3><p>如果你的发行版的包管理器中没有 Git Flow，你也可以从源代码进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/nvie/gitflow.git</span><br><span class="line">cd gitflow</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>安装完成后，你可以通过以下命令验证 Git Flow 是否成功安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow version</span><br></pre></td></tr></table></figure><h3 id="Windows">Windows</h3><p>在 Windows 上，你可以通过以下方式安装 Git Flow：</p><ul><li><p><strong>使用 Git for Windows</strong>: Git for Windows 包含了 Git Flow。你可以从 <a href="https://gitforwindows.org/">Git for Windows</a> 安装 Git，然后使用 Git Bash 来使用 Git Flow。</p></li><li><p><strong>使用 Scoop</strong>: 如果你使用 Scoop 包管理工具，可以通过以下命令安装 Git Flow：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop install git-flow</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 Chocolatey</strong>: 如果你使用 Chocolatey 包管理工具，可以通过以下命令安装 Git Flow：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install gitflow</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="Git-Flow-分支模型">Git Flow 分支模型</h2><p><strong><code>master</code> 分支</strong>：</p><ul><li>永远保持稳定和可发布的状态。</li><li>每次发布一个新的版本时，都会从 <code>develop</code> 分支合并到 <code>master</code> 分支。</li></ul><p><strong><code>develop</code> 分支</strong>：</p><ul><li>用于集成所有的开发分支。</li><li>代表了最新的开发进度。</li><li>功能分支、发布分支和修复分支都从这里分支出去，最终合并回这里。</li></ul><p><strong><code>feature</code> 分支</strong>：</p><ul><li>用于开发新功能。</li><li>从 <code>develop</code> 分支创建，开发完成后合并回 <code>develop</code> 分支。</li><li>命名规范：<code>feature/feature-name</code>。</li></ul><p><strong><code>release</code> 分支</strong>：</p><ul><li>用于准备新版本的发布。</li><li>从 <code>develop</code> 分支创建，进行最后的测试和修复，然后合并回 <code>develop</code> 和 <code>master</code> 分支，并打上版本标签。</li><li>命名规范：<code>release/release-name</code>。</li></ul><p><strong><code>hotfix</code> 分支</strong>：</p><ul><li>用于修复紧急问题。</li><li>从 <code>master</code> 分支创建，修复完成后合并回 <code>master</code> 和 <code>develop</code> 分支，并打上版本标签。</li><li>命名规范：<code>hotfix/hotfix-name</code>。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2024/07/git-flow.png" alt=""></p><h3 id="分支操作原理">分支操作原理</h3><ul><li>Master 分支上的每个 Commit 应打上 Tag，Develop 分支基于 Master 创建。</li><li>Feature 分支完成后合并回 Develop 分支，并通常删除该分支。</li><li>Release 分支基于 Develop 创建，用于测试和修复 Bug，发布后合并回 Master 和 Develop，并打 Tag 标记版本号。</li><li>Hotfix 分支基于 Master 创建，完成后合并回 Master 和 Develop，并打 Tag 1。</li></ul><h3 id="Git-Flow-命令示例">Git Flow 命令示例</h3><ul><li>开始 Feature 分支：<code>git flow feature start MYFEATURE</code></li><li>完成 Feature 分支：<code>git flow feature finish MYFEATURE</code></li><li>开始 Release 分支：<code>git flow release start RELEASE [BASE]</code></li><li>完成 Release 分支：合并到 Master 和 Develop，打 Tag，删除 Release 分支。</li><li>开始 Hotfix 分支：<code>git flow hotfix start HOTFIX [BASE]</code></li><li>完成 Hotfix 分支：合并到 Master 和 Develop，打 Tag，删除 Hotfix 分支。</li></ul><h3 id="Git-Flow-工作流程">Git Flow 工作流程</h3><h4 id="1-初始化-Git-Flow">1. 初始化 Git Flow</h4><p>首先，在项目中初始化 Git Flow。可以使用 Git Flow 插件（例如 <code>git-flow</code>）来简化操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow init</span><br></pre></td></tr></table></figure><p>初始化时，你需要设置分支命名规则和默认分支。</p><h4 id="2-创建功能分支">2. 创建功能分支</h4><p>当开始开发一个新功能时，从 <code>develop</code> 分支创建一个功能分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow feature start feature-name</span><br></pre></td></tr></table></figure><p>完成开发后，将功能分支合并回 <code>develop</code> 分支，并删除功能分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow feature finish feature-name</span><br></pre></td></tr></table></figure><h4 id="3-创建发布分支">3. 创建发布分支</h4><p>当准备发布一个新版本时，从 <code>develop</code> 分支创建一个发布分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow release start release-name</span><br></pre></td></tr></table></figure><p>在发布分支上进行最后的测试和修复，准备好发布后，将发布分支合并回 <code>develop</code> 和 <code>master</code> 分支，并打上版本标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow release finish release-name</span><br></pre></td></tr></table></figure><h4 id="4-创建修复分支">4. 创建修复分支</h4><p>当发现需要紧急修复的问题时，从 <code>master</code> 分支创建一个修复分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow hotfix start hotfix-name</span><br></pre></td></tr></table></figure><p>修复完成后，将修复分支合并回 <code>master</code> 和 <code>develop</code> 分支，并打上版本标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow hotfix finish hotfix-name</span><br></pre></td></tr></table></figure><h3 id="实例操作">实例操作</h3><p>以下是一个实际使用 Git Flow 的综合实例。</p><p><strong>初始化 Git Flow</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow init</span><br></pre></td></tr></table></figure><p><strong>创建和完成功能分支</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git flow feature start new-feature # 开发新功能</span><br><span class="line">git flow feature finish new-feature</span><br></pre></td></tr></table></figure><p><strong>创建和完成发布分支</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git flow release start v1.0.0 # 测试和修复</span><br><span class="line">git flow release finish v1.0.0</span><br></pre></td></tr></table></figure><p><strong>创建和完成修复分支</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git flow hotfix start hotfix-1.0.1. # 修复紧急问题</span><br><span class="line">git flow hotfix finish hotfix-1.0.1</span><br></pre></td></tr></table></figure><h3 id="优点和缺点">优点和缺点</h3><p><strong>优点</strong></p><ul><li><strong>明确的分支模型</strong>：清晰的分支命名和使用规则，使得开发过程井然有序。</li><li><strong>隔离开发和发布</strong>：开发和发布过程分离，减少了开发中的不确定性对发布的影响。</li><li><strong>版本管理</strong>：每次发布和修复都会打上版本标签，方便回溯和管理。</li></ul><p><strong>缺点</strong></p><ul><li><strong>复杂性</strong>：对于小型团队或简单项目，Git Flow 的分支模型可能显得过于复杂。</li><li><strong>频繁的合并</strong>：在大型团队中，频繁的分支合并可能导致合并冲突增加。</li></ul><p>Git Flow 是一种结构化的分支管理模型，通过定义明确的分支和工作流程，帮助团队更好地管理软件开发和发布过程。虽然它增加了一定的复杂性，但对于大型项目和团队协作，Git Flow 提供了强大的支持和管理能力。</p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git教程</title>
      <link href="/2017/08/12/git/git%E6%95%99%E7%A8%8B/"/>
      <url>/2017/08/12/git/git%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="初始化仓库">初始化仓库:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m &#x27;initial project version&#x27;</span><br></pre></td></tr></table></figure><p><img src="/assets/images/fileStatusLifecycle.png" alt="image"></p><h5 id="忽略某些文件">忽略某些文件</h5><p>我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。<br>文件 .gitignore 的格式规范如下：</p><ul><li>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式最后跟反斜杠（/）说明要忽略的是目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li></ul><p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。</p><p>我们再看一个 .gitignore 文件的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line"># 忽略所有 .a 结尾的文件</span><br><span class="line">*.a</span><br><span class="line"># 但 lib.a 除外</span><br><span class="line">!lib.a</span><br><span class="line"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"># 忽略 build/ 目录下的所有文件</span><br><span class="line">build/</span><br><span class="line"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"># 忽略 doc/ 目录下所有扩展名为 txt 的文件</span><br><span class="line">doc/**/*.txt</span><br></pre></td></tr></table></figure><h5 id="跟踪新文件">跟踪新文件</h5><p>使用命令 git add 开始跟踪一个新文件。所以，要跟踪 README 文件，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add README</span><br></pre></td></tr></table></figure><h5 id="提交更新">提交更新</h5><p>每次准备提交前，先用 git status 看下，是不是都已暂存起来了，然后再运行提交命令 git commit：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></table></figure><p>这种方式会启动文本编辑器以便输入本次提交的说明。（默认会启用 shell 的环境变量 $EDITOR 所指定的软件，一般都是 vim 或 emacs。当然也可以按照第一章介绍的方式，使用 ++git config --global core.editor++ 命令设定你喜欢的编辑软件。）</p><p>默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。（如果觉得这还不够，可以用 -v 选项将修改差异的每一行都包含到注释中来。）退出编辑器时，Git 会丢掉注释行，将说明内容和本次更新提交到仓库。</p><p>另外也可以用 +±m++ 参数后跟提交说明的方式，在一行命令中提交更新：</p><p>跳过使用暂存区域<br>Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 <strong>git commit 加上 -a</strong> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤</p><h5 id="移除文件">移除文件</h5><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 <strong>git rm</strong> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><h5 id="移动文件">移动文件</h5><p>要在 Git 中对文件改名，可以这么做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mv file_from file_to</span><br></pre></td></tr></table></figure><p>运行 git mv 就相当于运行了下面三条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv README.txt README</span><br><span class="line">$ git rm README.txt</span><br><span class="line">$ git add README</span><br></pre></td></tr></table></figure><h5 id="查看提交历史">查看提交历史</h5><p>默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。看到了吗，每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间，最后缩进一个段落显示提交说明。</p><p>git log 有许多选项可以帮助你搜寻感兴趣的提交，接下来我们介绍些最常用的。</p><p>我们常用 -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新</p><p>某些时候，单词层面的对比，比行层面的对比，更加容易观察。Git 提供了 +±-word-diff++ 选项。我们可以将其添加到 ++git log -p++ 命令的后面，从而获取单词层面上的对比。在程序代码中进行单词层面的对比常常是没什么用的。不过当你需要在书籍、论文这种很大的文本文件上进行对比的时候，这个功能就显出用武之地了。</p><p>另外，git log 还提供了许多摘要选项可以用，比如 --stat，仅显示简要的增改行数统计</p><p>用 oneline 或 format 时结合 --graph 选项，可以看到开头多出一些 ASCII 字符串表示的简单图形，形象地展示了每个提交所在的分支及其分化衍合情况。</p><p>另外还有按照时间作限制的选项，比如 --since 和 --until。</p><h5 id="撤消操作">撤消操作</h5><p>有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用 --amend 选项重新提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%92%A4%E6%B6%88%E6%93%8D%E4%BD%9C">撤消操作</a></p><h5 id="远程仓库的使用">远程仓库的使用</h5><p>查看当前的远程库<br>要查看当前配置有哪些远程仓库，可以用 git remote 命令，它会列出每个远程库的简短名字。<br>也可以加上 -v 选项（译注：此为 --verbose 的简写，取首字母），显示对应的克隆地址</p><p>添加远程仓库</p><p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add [shortname] [url]：</span><br></pre></td></tr></table></figure><p>现在可以用字符串 pb 指代对应的仓库地址了。比如说，要抓取所有 Paul 有的，但本地仓库没有的信息，可以运行 git fetch pb</p><p>从远程仓库抓取数据</p><p>正如之前所看到的，可以用下面的命令从远程仓库抓取数据到本地：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch [remote-name]</span><br></pre></td></tr></table></figure><p>推送数据到远程仓库</p><p>目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库中的数据推送到远程仓库。实现这个任务的命令很简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [remote-name] [branch-name]。</span><br></pre></td></tr></table></figure><p>如果要把本地的 master 分支推送到 origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>查看远程仓库信息<br>我们可以通过命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show [remote-name]</span><br></pre></td></tr></table></figure><p>查看某个远程仓库的详细信息</p><p>远程仓库的删除和重命名<br>在新版 Git 中可以用 git remote rename 命令修改某个远程仓库在本地的简称，比如想把 pb 改成 paul，可以这么运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure><p>碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><h5 id="打标签">打标签</h5><p><a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE/">打标签</a></p><h5 id="Git-命令别名">Git 命令别名</h5><p>Git 并不会推断你输入的几个字符将会是哪条命令，不过如果想偷懒，少敲几个命令的字符，可以用 git config 为命令设置别名。来看看下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure><p>取消暂存文件时的输入比较繁琐，可以自己设置一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.unstage &#x27;reset HEAD --&#x27;</span><br></pre></td></tr></table></figure><p>这样一来，下面的两条命令完全等同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git unstage fileA</span><br><span class="line">$ git reset HEAD fileA</span><br></pre></td></tr></table></figure><p>显然，使用别名的方式看起来更清楚。另外，我们还经常设置 last 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.last &#x27;log -1 HEAD&#x27;</span><br></pre></td></tr></table></figure><p>然后要看最后一次的提交信息，就变得简单多了</p><h5 id="分支的新建与切换">分支的新建与切换</h5><p>要新建并切换到该分支，运行 git checkout 并加上 -b 参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b iss53</span><br><span class="line">Switched to a new branch &#x27;iss53&#x27;</span><br></pre></td></tr></table></figure><p>回到 master 分支并把它合并进来，然后发布到生产服务器。用 git merge 命令来进行合并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge hotfix</span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> README | 1 -</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br></pre></td></tr></table></figure><p>这相当于执行下面这两条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch iss53</span><br><span class="line">$ git checkout iss53</span><br></pre></td></tr></table></figure><p>如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。</p><p>合并之后，master 分支和 hotfix 分支指向同一位置。<br>由于当前 hotfix 分支和 master 都指向相同的提交对象，所以 hotfix 已经完成了历史使命，可以删掉了。使用 git branch 的 -d 选项执行删除操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d hotfix</span><br><span class="line">Deleted branch hotfix (was 3a0874c).</span><br></pre></td></tr></table></figure><h5 id="遇到冲突时的分支合并">遇到冲突时的分支合并</h5><p>有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）。<br>Git 作了合并，但没有提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用 <strong>git status</strong> 查阅</p><p>任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line">=======</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">  please contact us at support@github.com</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53</span><br></pre></td></tr></table></figure><p>可以看到 ======= 隔开的上半部分，是 HEAD（即 master 分支，在运行 merge 命令时所切换到的分支）中的内容，下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">please contact us at email.support@github.com</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这个解决方案各采纳了两个分支中的一部分内容，而且我还删除了 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，======= 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行。在解决了所有文件里的所有冲突后，运行 git add 将把它们标记为已解决状态（译注：实际上就是来一次快照保存到暂存区域。）。</p><p>再运行一次 git status 来确认所有冲突都已解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   index.html</span><br></pre></td></tr></table></figure><p>如果觉得满意了，并且确认所有冲突都已解决，也就是进入了暂存区，就可以用 git commit 来完成这次合并提交。提交的记录差不多是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Merge branch &#x27;iss53&#x27;</span><br><span class="line"></span><br><span class="line">Conflicts:</span><br><span class="line">  index.html</span><br><span class="line">#</span><br><span class="line"># It looks like you may be committing a merge.</span><br><span class="line"># If this is not correct, please remove the file</span><br><span class="line">#       .git/MERGE_HEAD</span><br><span class="line"># and try again.</span><br><span class="line">#</span><br></pre></td></tr></table></figure><h5 id="查看当前的远程库">查看当前的远程库</h5><p>要查看当前配置有哪些远程仓库，可以用 git remote 命令，它会列出每个远程库的简短名字。<br>可以加上 -v 选项（译注：此为 --verbose 的简写，取首字母），显示对应的克隆地址</p><h5 id="添加远程仓库">添加远程仓库</h5><p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add [shortname] [url]：</span><br></pre></td></tr></table></figure><h5 id="从远程仓库抓取数据">从远程仓库抓取数据</h5><p>正如之前所看到的，可以用下面的命令从远程仓库抓取数据到本地：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch [remote-name]</span><br></pre></td></tr></table></figure><p>推送数据到远程仓库<br>项目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库中的数据推送到远程仓库。实现这个任务的命令很简单： git push [remote-name] [branch-name]。如果要把本地的 master 分支推送到 origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。</p><p>查看远程仓库信息<br>我们可以通过命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show [remote-name]</span><br></pre></td></tr></table></figure><p>查看某个远程仓库的详细信息</p><h1></h1><p>远程仓库的删除和重命名<br>在新版 Git 中可以用 git remote rename 命令修改某个远程仓库在本地的简称，比如想把 pb 改成 paul，可以这么运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure><p>注意，对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 pb/master 分支现在成了 paul/master。</p><p>碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><h5 id="远程分支">远程分支</h5><p>我们用 ==(远程仓库名)/(分支名)== 这样的形式表示远程分支。比如我们想看看上次同 origin 仓库通讯时 master 分支的样子，就应该查看 origin/master 分支。如果你和同伴一起修复某个问题，但他们先推送了一个 iss53 分支到远程仓库，虽然你可能也有一个本地的 iss53 分支，但指向服务器上最新更新的却应该是 origin/iss53 分支。</p><p>可以运行 git fetch origin 来同步远程服务器上的数据到本地。该命令首先找到 origin 是哪个服务器（本例为 <a href="http://git.ourcompany.com">git.ourcompany.com</a>），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 origin/master 的指针移到它最新的位置上<br><img src="/assets/images/gitfetch.png" alt="image"></p><p>为了演示拥有多个远程分支（在不同的远程服务器上）的项目是如何工作的，我们假设你还有另一个仅供你的敏捷开发小组使用的内部服务器 <a href="http://git.team1.ourcompany.com">git.team1.ourcompany.com</a>。可以用第二章中提到的 git remote add 命令把它加为当前项目的远程分支之一。我们把它命名为 teamone，以便代替完整的 Git URL 以方便使用<br><img src="/assets/images/gitaddremote.png" alt="image"><br>现在你可以用 git fetch teamone 来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你 origin 服务器上的子集，Git 不会下载任何数据，而只是简单地创建一个名为 teamone/master 的远程分支，指向 teamone 服务器上 master 分支所在的提交对象 31b8e（见图 3-26）。</p><p><img src="/assets/images/gitfetchremote.png" alt="image"></p><h5 id="推送本地分支">推送本地分支</h5><p>要想和其他人分享某个本地分支，你需要把它推送到一个你拥有写权限的远程仓库。你创建的本地分支不会因为你的写入操作而被自动同步到你引入的远程服务器上，你需要明确地执行推送分支的操作。</p><p>如果你有个叫 serverfix 的分支需要和他人一起开发，可以运行 git push (远程仓库名) (分支名)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin serverfix</span><br><span class="line">Counting objects: 20, done.</span><br><span class="line">Compressing objects: 100% (14/14), done.</span><br><span class="line">Writing objects: 100% (15/15), 1.74 KiB, done.</span><br><span class="line">Total 15 (delta 5), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new branch]      serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure><p>这里其实走了一点捷径。Git 自动把 serverfix 分支名扩展为 refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的 serverfix 分支，推送到远程仓库的 serverfix 分支中去”。</p><p>也可以运行 ==git push origin serverfix:serverfix== 来实现相同的效果，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作 awesomebranch，可以用 git push origin serverfix:awesomebranch 来推送数据。</p><h5 id="跟踪远程分支">跟踪远程分支</h5><p>从远程分支 checkout 出来的本地分支，称为 跟踪分支 (tracking branch)。跟踪分支是一种和某个远程分支有直接联系的本地分支。在跟踪分支里输入 git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。同样，在这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来。</p><p>在克隆仓库时，Git 通常会自动创建一个名为 master 的分支来跟踪 origin/master。这正是 git push 和 git pull 一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如 origin 上除了 master 之外的其它分支。刚才我们已经看到了这样的一个例子：git checkout -b [分支名] [远程名]/[分支名]。如果你有 1.6.2 以上版本的 Git，还可以用 --track 选项简化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout --track origin/serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;serverfix&#x27;</span><br></pre></td></tr></table></figure><p>要为本地分支设定不同于远程分支的名字，只需在第一个版本的命令里换个名字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b sf origin/serverfix</span><br><span class="line">Branch sf set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;sf&#x27;</span><br></pre></td></tr></table></figure><p>现在你的本地分支 sf 会自动将推送和抓取数据的位置定位到 origin/serverfix 了</p><h5 id="删除远程分支">删除远程分支</h5><p>如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的 master 分支（或任何其他存放稳定代码的分支），可以用这个非常无厘头的语法来删除它：git push [远程名] :[分支名]。如果想在服务器上删除 serverfix 分支，运行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :serverfix</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure><p>咚！服务器上的分支没了。你最好特别留心这一页，因为你一定会用到那个命令，而且你很可能会忘掉它的语法。有种方便记忆这条命令的方法：==记住我们不久前见过的 git push [远程名] [本地分支]:[远程分支] 语法，如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]”==。</p><h5 id="解决远程分支和本地冲突">解决远程分支和本地冲突</h5><p>1.先将本地修改储存起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>2.pull内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>3.还原暂存内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><p>4.解决冲突</p><p>5.提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#x27;&#x27;</span><br></pre></td></tr></table></figure><ol start="6"><li>打标签</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.1 -m &#x27;&#x27;</span><br></pre></td></tr></table></figure><p>7.列标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -l</span><br></pre></td></tr></table></figure><p>8.获取标签代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout </span><br></pre></td></tr></table></figure><p>9.提交标签到远程端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push tag </span><br></pre></td></tr></table></figure><h5 id="拉取本地没有的远程分支">拉取本地没有的远程分支</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 本地分支名 origin/远程分支名</span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E5%8F%98%E5%9F%BA/">后续:变基rebase</a></p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iptables</title>
      <link href="/2017/04/28/iptables/"/>
      <url>/2017/04/28/iptables/</url>
      
        <content type="html"><![CDATA[<h2 id="基本操作">基本操作</h2><hr><h3 id="查看iptable版本">查看iptable版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -q iptables</span><br></pre></td></tr></table></figure><h3 id="查看iptables-规则">查看iptables 规则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service iptables status</span><br><span class="line"># 或</span><br><span class="line">service -L --line-numbers</span><br></pre></td></tr></table></figure><h2 id="表">表</h2><p>iptables的4个表分别是：</p><ul><li>filter（过滤）：数据包过滤/拦截，可以包含INPUT、FORWARD、OUTPUT这3个内置chain。</li><li>nat（地址转换）：IP地址或端口号转换，可以包含PREROUTING、OUTPUT、POSTROUTING 3个内置chain，nat table在会话建立时会记录转换的对应关系，同一会话的回包和后续报文会自动地址转换，这是因为nat使用了ip_conntrack模块。</li><li>mangle（包管理）：用来修改IP报文，可以包含PREROUTING、OUTPUT、INPUT、FORWARD、POSTROUTING 5个内置chain。</li><li>raw：此表的优先级高于ip_conntrack模块和其它的table，主要用于将有会话状态的连接（比如tcp）的数据包排除在会话外。可以包含POSTROUTING、OUTPUT两个内置chain。</li></ul><p>看到这里肯定会有这样的疑问，为什么table只能包含一些而不是全部的chain呢？我想这个构架是按需设计而不是按功能设计的，尽管table不是包含所有的chain，但是每种功能的table都包含了实现这种功能所需的chain，即使包含更多的chain也是累赘或者无用的，而且实际上用起来也的确如此，够用了。</p><p>还有就是不同table生效优先顺序问题，先后优先级是这样的：</p><p>raw &gt; mangle &gt; nat &gt; filter</p><p>所以，如果有filter禁止ping目的地址2.2.2.2，而nat又有策略将目的地址1.1.1.1转换成2.2.2.2，那么ping 1.1.1.1是ping不通的。</p><p>不过一般情况下filter是不会和nat的策略打起架来，比如INPUT chain能做filter，却不能做nat，PREROUTING能做nat却不能做filter，而且PREROUTING只能做目的地址转换，不会对源地址过滤的需求造成麻烦，所以通常是不会相互干扰的。</p><h2 id="规则链-chain">规则链(chain)</h2><p>iptables内置的5个chain：PREROUTING、INPUT、OUPUT、FORWARD、POSTROUGING，这5个chain分别与netfilter中数据转发路径上的5个不同的位置挂钩，以匹配筛选不同类型的数据流，如下图所示：</p><p>其中：</p><ul><li>PREROUTING链：应用于所有进入机器的ip包，包括目的地址是本机和目的地址非本机的包。</li><li>INPUT链：应用于所有目的是本机的包，也就是目的IP是本机接口地址，所有发给本地socket的数据都经过它。</li><li>OUPUT链：应用于所有由本机产生的包，所有应用程序发出的数据都经过它。</li><li>FORWARD链：应用于所有经过路由决策被转发的包，也就是目的地址不是本机的数据包。</li><li>POSTROUGING链：应用于所有发出机器的IP包，包括本机发出的和从本机转发的数据包。</li></ul><p>策略匹配按照重上到下的顺序进行，当测试到某策略匹配时执行target并跳出，不再向下匹配，当测试到最后一条策略仍不匹配时，则采用policy指定的动作，如下图：</p><p>除了内置chain外，还可以自定义chain，自定义chain并不能利用netfilter的hook来捕捉数据包，但是可用于策略的分类，比如有3类不同的用户访问主机上的不同服务，如果所有策略都放在INPUT chain中策略会多而难以维护，这个时候就可以定义3个自定义chain，分别配置不同的策略，同时在INPUT chain中添加策略对来访者分类并将目标指向3个自定义chain。</p><p>自定义chain大显神威的地方在于动态生成策略，例如VPN服务器上，需要对不同分组的用户区别对待管理，但是用户IP是随机分配的，不能根据IP来区分用户组，这时候可以预先定义好各组chain，利用VPN服务端软件的一些钩子，当用户登陆时自动添加策略引导到自定义chain上来匹配。如果这时候没有自定义chain，那么策略的数量将是（用户数×所属组策略数），每增加一个用户，都要把所属组的全部策略添加一遍，这样大量的时间花费在策略匹配上，性能下降很快。</p><hr><h2 id="各指令的含义">各指令的含义</h2><hr><h3 id="APPEND-A">-APPEND -A</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A chain firewall-rule</span><br></pre></td></tr></table></figure><p>将规则添加到末尾。</p><p>一般情况下,iptables 中最后的规则是丢弃所有数据包。</p><p>于是使用-A参数添加的规则在丢弃规则后，将不起作用。</p><hr><h3 id="DELETE-D">-DELETE -D</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iptables -D chain firewall-rule</span><br><span class="line"># 删除对应规则direwall-rule的那一条</span><br><span class="line"># 或</span><br><span class="line">iptables -D chain rulenum</span><br><span class="line"># 删除chain中编号为rulenum的那一条.1表示第一条。</span><br></pre></td></tr></table></figure><hr><h3 id="INSERT-I">-INSERT -I</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I chain [rulenum] firewall-rule.</span><br></pre></td></tr></table></figure><p>将firewall-rule添加为chain中的第rulenum条规则,原先的第rulenum条规则及以后的各条顺次+1。如未指定rulenum,则默认为1.</p><hr><h3 id="REPLACE-R">-REPLACE -R</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -R chain [rulenum] firewall-rule.</span><br></pre></td></tr></table></figure><p>将firewall-rule添加为chain中的第rulenum条规则,原先的第rulenum条规则及以后的各条顺次+1。如未指定rulenum,则默认为1.</p><hr><h3 id="LIST-L">-LIST -L</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -L chain [rulenum] firewall-rule.</span><br></pre></td></tr></table></figure><p>列出chain或所有chain的第rulenum条规则或所有规则，在-L后再加上–lube-numbers，则显示序号</p><hr><h3 id="LIST-RULES-S">-LIST-RULES -S</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -S chain [rulenum] </span><br></pre></td></tr></table></figure><p>打印全部规则</p><hr><h3 id="FLUSH-F">-FLUSH -F</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -F chain</span><br></pre></td></tr></table></figure><p>情况chain(或全部chain)中的规则</p><hr><h3 id="ZERO-Z">-ZERO -Z</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -Z chain [rulenum] </span><br></pre></td></tr></table></figure><p>清空chain或所有chain的包和字节计数器</p><hr><h3 id="NEW-N">-NEW -N</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -N chain [rulenum] </span><br></pre></td></tr></table></figure><p>创建名称为chain的新链</p><hr><h3 id="DELETE-CHAIN-X">-DELETE-CHAIN -X</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -X [chain] </span><br></pre></td></tr></table></figure><p>删除用户自定义chain或所有用户定义的chain,该指令不影响预设规则</p><hr><h3 id="POLICY-P">-POLICY -P</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -P chain target </span><br></pre></td></tr></table></figure><p>改变chain的策略为target</p><hr><h3 id="RENAME-CHAIN-E">-RENAME-CHAIN -E</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -E old-chain new-chain</span><br></pre></td></tr></table></figure><p>将old-chain名更换为new-chain,使得old-chain的规则失效</p><hr><h2 id="各参数的含义">各参数的含义</h2><hr><h3 id="P-代表协议（PROTOCOL）">-P 代表协议（PROTOCOL）</h3><ul><li>指明当前规则针对的传输协议（如 TCP、UDP、ICMP 等）</li><li>可能的参数值有：tcp, udp, icmp, all</li><li>使用 “all” 表示适用于所有协议。而如果在规则中不指定 -p 参数，则默认使用 “all” 参数。一般不使用 “all” 这个值，要么指定某个特定的协议，要么就指定 -p 参数。</li><li>-p 的参数值既可以用名称（如 tcp）也可以用协议对应的数值（如 6 代表 tcp 协议）</li><li>/etc/protocols 文件中包含了所有允许的协议名称和相应数值</li><li>也可以用长的参数名 –protocol</li></ul><h3 id="S-代表源地址（SOURCE）">-S 代表源地址（SOURCE）</h3><ul><li>指定数据包的源地址</li><li>可以是 ip 地址，或者网络地址，或者主机名（hostname）</li><li>例如：-s 192.168.1.101 表示针对特定的 ip 地址</li><li>对于网络掩码，使用 /mask。例如，“-s 192.168.1.0/24″ 表示网络掩码为 255.255.255.0 的所有 192.168.1.x 地址都匹配。</li><li>如果不指定 -s 参数，默认匹配所有源地址</li><li>也可以用长参数名 –src 或者 –source</li></ul><h3 id="D-代表目的地址（DESTINATION）">-D 代表目的地址（DESTINATION）</h3><ul><li>指定数据包的目的地址</li><li>使用方式与上面的 “-s” 一样（不同之处仅在于 -s 指源，而 -d 表示目的地址）</li><li>也可以用长参数名 –dst 或者 –destination</li></ul><h3 id="J-代表跳转（TARGET）">-J 代表跳转（TARGET）</h3><ul><li>j 的意思是 “jump”（跳转） 到目标</li><li>指定当某个数据包满足该规则的时候的就跳转到的下一个处理规则，而不再顺序执行后面的规则判断</li><li>可能的值有：ACCEPT, DROP, QUEUE, RETURN，分别表示接受、丢弃、进入队列，返回（跳出，通常是从某个 chain 中跳回到调用该 chain 的上层 chain）</li><li>也可以跳转到某个自定义的 chain 中，使用该 chain 的名称做为跳转目标</li></ul><h3 id="I-代表-IN-INTERFACE（入站接口）">-I 代表 IN INTERFACE（入站接口）</h3><ul><li>i 表示 “input interface”（输入接口，即，指定网络数据处理的网卡，一般 eth0 即表示第一块有线网卡的外网接口，lo 表示局域网接口）</li><li>可以直接理解为 “-i” 表示接口。不过，-i 和 -o 都表示接口，-i 表示输入时的接口，而 -o 特指输出用的接口。</li><li>指定数据包进入 INPUT、FORWARD 和 PREROUTING 链时经由的接口。</li><li>例如：-i eth0 表示该规则应该针对从 eth0 接口进来的数据包。</li><li>如果不指定 -i 参数，则经由系统中所有可用的接口进入的数据包都可以匹配该规则。</li><li>也可以使用长参数 –in-interface</li></ul><h3 id="O-代表-OUT-INTERFACE（出站接口）">-O 代表 OUT INTERFACE（出站接口）</h3><ul><li>o 表示 “output interface”（出站经由接口）</li><li>指定发送出去的数据包进入 INPUT、FORWARD 和 PREROUTING 链时经由的接口。</li><li>如果不指定 -o 参数，则经由系统中所有可用的接口发出的数据包都可以匹配该规则。</li><li>也可以使用长参数 –out-interface</li></ul><hr><h2 id="其它防火墙参数选项">其它防火墙参数选项</h2><p>上面某些防火墙参数还有属于它自己的参数选项，可以与其配合使用。下面是一些常用的选项。</p><p>要使用这些参数选项，需要指定相应的参数，例如，要使用 “–sport” 选项，应该在规则中指定 “-p tcp” （或者 “-p udp”）等参数。</p><p>注意：所有这些选项前面都是 –（2个短横线 – ）。</p><h3 id="–SPORT-表示-SOURCE-PORT-源端口，用于-P-TCP-或者-P-UDP">–SPORT 表示 SOURCE PORT (源端口，用于 -P TCP, 或者 -P UDP)</h3><ul><li>默认匹配所有端口（未特别指定时）</li><li>可以指定端口号（数字），也可以指定端口名称。例如，默认的 SSH 端口号码为 22，名称为 ssh，可以表示为 “–sport 22″ 或者 “–sport ssh”。</li><li>/etc/services 文件包含了所有允许的端口名称和对应的端口号码。</li><li>在规则中使用号码比使用名称要好（效率高些）</li><li>要匹配一个端口范围，使用英文半角冒号（:），如 22:100 匹配从 22 到 100 的所有端口号。</li><li>也可以使用长名称 –source-port</li></ul><h3 id="–DPORT-表示-DESTINATION-PORT-目的端口，-P-TCP-或者-P-UDP">–DPORT 表示 DESTINATION PORT (目的端口，-P TCP, 或者 -P UDP)</h3><ul><li>与 –sport 的用法相同，区别仅在于对象是目的端口</li><li>也可以使用长名称 –destination-port</li></ul><h3 id="–TCP-FLAGS-表示-TCP-FLAGS-用于-P-TCP">–TCP-FLAGS 表示 TCP FLAGS (用于 -P TCP)</h3><ul><li>可以使用英文半角逗号（,）来指定多个 TCP 状态标识</li><li>可能值有：SYN, ACK, FIN, RST, URG, PSH。可以全用，也可以不用。</li></ul><h3 id="–ICMP-TYPE-表示-ICMP-TYPE-ICMP-类型，用于-P-ICMP">–ICMP-TYPE 表示 ICMP TYPE (ICMP 类型，用于 -P ICMP)</h3><ul><li>当使用 icmp 协议 “-p icmp” 的时候，可以使用 “–icmp-type” 特别指定 ICMP 类型</li><li>例如，使用 “–icmp-type 0″ 表示 “Echo Reply”，“–icmp-type 8″ 表示 “Echo”。</li></ul><p>添加VIP:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0:1 192.168.1.22 broadcast 192.168.1.2 netmask 255.255.255.0 up</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础</title>
      <link href="/2017/04/28/linux%E5%9F%BA%E7%A1%80/"/>
      <url>/2017/04/28/linux%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1>Linux 基础操作笔记</h1><h2 id="1-文件操作">1. 文件操作</h2><h3 id="1-1-创建文件">1.1 创建文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建单个文件</span></span><br><span class="line"><span class="built_in">touch</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量创建文件（创建love_1_linux.txt到love_10_linux.txt）</span></span><br><span class="line"><span class="built_in">touch</span> love_&#123;1..10&#125;_linux.txt</span><br></pre></td></tr></table></figure><h3 id="1-2-文件权限查看">1.2 文件权限查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l  <span class="comment"># 详细列表显示文件权限</span></span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 user group 1024 Mar 1 10:00 example.txt</span><br></pre></td></tr></table></figure><p>权限字段说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[文件类型][所有者权限][组权限][其他用户权限]</span><br><span class="line">d rwx r-x r-x</span><br></pre></td></tr></table></figure><ul><li>文件类型：<code>-</code>普通文件，<code>d</code>目录，<code>l</code>链接文件</li><li>权限组成：<code>r</code>读(4) + <code>w</code>写(2) + <code>x</code>执行(1)</li></ul><h2 id="2-帮助系统">2. 帮助系统</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">man &lt;<span class="built_in">command</span>&gt;  <span class="comment"># 查看命令手册</span></span><br><span class="line">man <span class="built_in">ls</span>         <span class="comment"># 示例：查看ls命令手册</span></span><br></pre></td></tr></table></figure><p>常用操作键：</p><ul><li>空格键：向下翻页</li><li><code>q</code>：退出手册</li><li><code>/</code>：搜索内容</li></ul><h2 id="3-用户管理">3. 用户管理</h2><h3 id="3-1-用户查看命令">3.1 用户查看命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">whoami</span>        <span class="comment"># 显示当前用户名</span></span><br><span class="line"><span class="built_in">who</span> am i      <span class="comment"># 显示登录信息</span></span><br><span class="line"><span class="built_in">who</span> -m        <span class="comment"># 同&quot;who am i&quot;</span></span><br><span class="line"><span class="built_in">who</span> mom likes <span class="comment"># 显示特定用户信息（需实际用户存在）</span></span><br></pre></td></tr></table></figure><h3 id="3-2-用户操作">3.2 用户操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户（自动创建home目录）</span></span><br><span class="line"><span class="built_in">sudo</span> adduser lilei</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已创建用户</span></span><br><span class="line"><span class="built_in">ls</span> /home</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换用户</span></span><br><span class="line">su -l lilei   <span class="comment"># &quot;-l&quot;模拟完整登录环境</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除用户及home目录</span></span><br><span class="line"><span class="built_in">sudo</span> deluser lilei --remove-home</span><br></pre></td></tr></table></figure><h2 id="4-用户组管理">4. 用户组管理</h2><h3 id="4-1-用户组查看">4.1 用户组查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看指定用户所属组</span></span><br><span class="line"><span class="built_in">groups</span> shiyanlou</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有组（按字母排序）</span></span><br><span class="line"><span class="built_in">cat</span> /etc/group | <span class="built_in">sort</span></span><br></pre></td></tr></table></figure><p><code>/etc/group</code> 文件格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group_name:password:GID:user_list</span><br></pre></td></tr></table></figure><h3 id="4-2-用户组操作">4.2 用户组操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加用户到组（需要root权限）</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG <span class="built_in">sudo</span> lilei  <span class="comment"># 示例：添加sudo组</span></span><br></pre></td></tr></table></figure><h2 id="5-权限管理">5. 权限管理</h2><h3 id="5-1-文件权限修改">5.1 文件权限修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变更文件所有者</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> shiyanlou iphone6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变更文件所属组</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chgrp</span> group_name file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改所有权限（所有者/组/其他用户）</span></span><br><span class="line"><span class="built_in">chmod</span> 755 filename  <span class="comment"># rwxr-xr-x</span></span><br></pre></td></tr></table></figure><h3 id="5-2-权限数字表示法">5.2 权限数字表示法</h3><table><thead><tr><th>权限</th><th>数字</th></tr></thead><tbody><tr><td>r–</td><td>4</td></tr><tr><td>-w-</td><td>2</td></tr><tr><td>–x</td><td>1</td></tr><tr><td>rwx</td><td>7 (4+2+1)</td></tr></tbody></table><h2 id="6-文件类型说明">6. 文件类型说明</h2><p>Linux 一切皆文件，主要类型包括：</p><ul><li><code>-</code>：普通文件</li><li><code>d</code>：目录文件</li><li><code>l</code>：符号链接（相当于快捷方式）</li><li><code>c</code>：字符设备文件</li><li><code>b</code>：块设备文件</li><li><code>s</code>：套接字文件</li><li><code>p</code>：管道文件</li></ul><h2 id="7-重要补充说明">7. 重要补充说明</h2><ol><li><p>目录权限特殊含义：</p><ul><li>读权限：可查看目录内容</li><li>写权限：可创建/删除文件</li><li>执行权限：可进入目录</li></ul></li><li><p>新建用户默认会：</p><ul><li>创建同名用户组</li><li>在<code>/home</code>下创建用户目录</li><li>基本配置文件从<code>/etc/skel</code>复制</li></ul></li><li><p>sudo权限配置路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/sudoers</span><br><span class="line">/etc/sudoers.d/</span><br></pre></td></tr></table></figure></li></ol><p>建议后续可补充：</p><ul><li>实际权限修改案例</li><li>用户组管理实验</li><li>sudoers文件的配置方法</li><li>ACL高级权限控制</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql基础教程</title>
      <link href="/2015/10/12/mysql%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
      <url>/2015/10/12/mysql%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>为什么需要数据库？</p><p>因为应用程序需要保存用户的数据，比如Word需要把用户文档保存起来，以便下次继续编辑或者拷贝到另一台电脑。</p><p>要保存用户的数据，一个最简单的方法是把用户数据写入文件。例如，要保存一个班级所有学生的信息，可以向文件中写入一个CSV文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id,name,gender,score</span><br><span class="line">1,小明,M,90</span><br><span class="line">2,小红,F,95</span><br><span class="line">3,小军,M,88</span><br><span class="line">4,小丽,F,88</span><br></pre></td></tr></table></figure><p>如果要保存学校所有班级的信息，可以写入另一个CSV文件。</p><p>但是，随着应用程序的功能越来越复杂，数据量越来越大，如何管理这些数据就成了大问题：</p><ul><li>读写文件并解析出数据需要大量重复代码；</li><li>从成千上万的数据中快速查询出指定数据需要复杂的逻辑。</li></ul><p>如果每个应用程序都各自写自己的读写数据的代码，一方面效率低，容易出错，另一方面，每个应用程序访问数据的接口都不相同，数据难以复用。</p><p>所以，数据库作为一种专门管理数据的软件就出现了。应用程序不需要自己管理数据，而是通过数据库软件提供的接口来读写数据。至于数据本身如何存储到文件，那是数据库软件的事情，应用程序自己并不关心：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌───────────┐</span><br><span class="line">│application│</span><br><span class="line">└───────────┘</span><br><span class="line">     ▲ │</span><br><span class="line">     │ │</span><br><span class="line"> read│ │write</span><br><span class="line">     │ │</span><br><span class="line">     │ ▼</span><br><span class="line">┌───────────┐</span><br><span class="line">│ database  │</span><br><span class="line">└───────────┘</span><br></pre></td></tr></table></figure><p>这样一来，编写应用程序的时候，数据读写的功能就被大大地简化了。</p><h3 id="数据模型">数据模型</h3><p>数据库按照数据结构来组织、存储和管理数据，实际上，数据库一共有三种模型：</p><ul><li>层次模型</li><li>网状模型</li><li>关系模型</li></ul><p>层次模型就是以“上下级”的层次关系来组织数据的一种方式，层次模型的数据结构看起来就像一颗树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">            ┌─────┐</span><br><span class="line">            │     │</span><br><span class="line">            └─────┘</span><br><span class="line">               │</span><br><span class="line">       ┌───────┴───────┐</span><br><span class="line">       │               │</span><br><span class="line">    ┌─────┐         ┌─────┐</span><br><span class="line">    │     │         │     │</span><br><span class="line">    └─────┘         └─────┘</span><br><span class="line">       │               │</span><br><span class="line">   ┌───┴───┐       ┌───┴───┐</span><br><span class="line">   │       │       │       │</span><br><span class="line">┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐</span><br><span class="line">│     │ │     │ │     │ │     │</span><br><span class="line">└─────┘ └─────┘ └─────┘ └─────┘</span><br></pre></td></tr></table></figure><p>网状模型把每个数据节点和其他很多节点都连接起来，它的数据结构看起来就像很多城市之间的路网：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     ┌─────┐      ┌─────┐</span><br><span class="line">   ┌─│     │──────│     │──┐</span><br><span class="line">   │ └─────┘      └─────┘  │</span><br><span class="line">   │    │            │     │</span><br><span class="line">   │    └──────┬─────┘     │</span><br><span class="line">   │           │           │</span><br><span class="line">┌─────┐     ┌─────┐     ┌─────┐</span><br><span class="line">│     │─────│     │─────│     │</span><br><span class="line">└─────┘     └─────┘     └─────┘</span><br><span class="line">   │           │           │</span><br><span class="line">   │     ┌─────┴─────┐     │</span><br><span class="line">   │     │           │     │</span><br><span class="line">   │  ┌─────┐     ┌─────┐  │</span><br><span class="line">   └──│     │─────│     │──┘</span><br><span class="line">      └─────┘     └─────┘</span><br></pre></td></tr></table></figure><p>关系模型把数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，它的数据模型看起来就是一个Excel表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌─────┬─────┬─────┬─────┬─────┐</span><br><span class="line">│     │     │     │     │     │</span><br><span class="line">├─────┼─────┼─────┼─────┼─────┤</span><br><span class="line">│     │     │     │     │     │</span><br><span class="line">├─────┼─────┼─────┼─────┼─────┤</span><br><span class="line">│     │     │     │     │     │</span><br><span class="line">├─────┼─────┼─────┼─────┼─────┤</span><br><span class="line">│     │     │     │     │     │</span><br><span class="line">└─────┴─────┴─────┴─────┴─────┘</span><br></pre></td></tr></table></figure><p>随着时间的推移和市场竞争，最终，基于关系模型的关系数据库获得了绝对市场份额。</p><p>为什么关系数据库获得了最广泛的应用？</p><p>因为相比层次模型和网状模型，关系模型理解和使用起来最简单。</p><p>关系数据库的关系模型是基于数学理论建立的。我们把域（Domain）定义为一组具有相同数据类型的值的集合，给定一组域D1,D2,…,Dn，它们的笛卡尔集定义为D1×D2×……×Dn={(d1,d2,…,dn)|di∈Di,i=1,2,…,n}， 而D1×D2×……×Dn的子集叫作在域D1,D2,…,Dn上的关系，表示为R(D1,D2,…,Dn)，这里的R表示#%&amp;^@!&amp;$#;!~％¥%……算了，根本讲不明白，大家也不用理解。</p><p>基于数学理论的关系模型虽然讲起来挺复杂，但是，基于日常生活的关系模型却十分容易理解。我们以学校班级为例，一个班级的学生就可以用一个表格存起来，并且定义如下：</p><table><thead><tr><th>ID</th><th>姓名</th><th>班级ID</th><th>性别</th><th>年龄</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>201</td><td>M</td><td>9</td></tr><tr><td>2</td><td>小红</td><td>202</td><td>F</td><td>8</td></tr><tr><td>3</td><td>小军</td><td>202</td><td>M</td><td>8</td></tr><tr><td>4</td><td>小白</td><td>201</td><td>F</td><td>9</td></tr></tbody></table><p>其中，班级ID对应着另一个班级表：</p><table><thead><tr><th>ID</th><th>名称</th><th>班主任</th></tr></thead><tbody><tr><td>201</td><td>二年级一班</td><td>王老师</td></tr><tr><td>202</td><td>二年级二班</td><td>李老师</td></tr></tbody></table><p>通过给定一个班级名称，可以查到一条班级记录，根据班级ID，又可以查到多条学生记录，这样，二维表之间就通过ID映射建立了“一对多”关系。</p><h3 id="数据类型">数据类型</h3><p>对于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>INT</td><td>整型</td><td>4字节整数类型，范围约+/-21亿</td></tr><tr><td>BIGINT</td><td>长整型</td><td>8字节整数类型，范围约+/-922亿亿</td></tr><tr><td>REAL</td><td>浮点型</td><td>4字节浮点数，范围约+/-1038</td></tr><tr><td>DOUBLE</td><td>浮点型</td><td>8字节浮点数，范围约+/-10308</td></tr><tr><td>DECIMAL(M,N)</td><td>高精度小数</td><td>由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算</td></tr><tr><td>CHAR(N)</td><td>定长字符串</td><td>存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串</td></tr><tr><td>VARCHAR(N)</td><td>变长字符串</td><td>存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串</td></tr><tr><td>BOOLEAN</td><td>布尔类型</td><td>存储True或者False</td></tr><tr><td>DATE</td><td>日期类型</td><td>存储日期，例如，2018-06-22</td></tr><tr><td>TIME</td><td>时间类型</td><td>存储时间，例如，12:20:59</td></tr><tr><td>DATETIME</td><td>日期和时间类型</td><td>存储日期+时间，例如，2018-06-22 12:20:59</td></tr></tbody></table><p>上面的表中列举了最常用的数据类型。很多数据类型还有别名，例如，<code>REAL</code>又可以写成<code>FLOAT(24)</code>。还有一些不常用的数据类型，例如，<code>TINYINT</code>（范围在0~255）。各数据库厂商还会支持特定的数据类型，例如<code>JSON</code>。</p><p>选择数据类型的时候，要根据业务规则选择合适的类型。通常来说，<code>BIGINT</code>能满足整数存储的需求，<code>VARCHAR(N)</code>能满足字符串存储的需求，这两种类型是使用最广泛的。</p><h3 id="主流关系数据库">主流关系数据库</h3><p>目前，主流的关系数据库主要分为以下几类：</p><ol><li>商用数据库，例如：<a href="https://www.oracle.com/">Oracle</a>，<a href="https://www.microsoft.com/sql-server/">SQL Server</a>，<a href="https://www.ibm.com/db2/">DB2</a>等；</li><li>开源数据库，例如：<a href="https://www.mysql.com/">MySQL</a>，<a href="https://www.postgresql.org/">PostgreSQL</a>等；</li><li>桌面数据库，以微软<a href="https://products.office.com/access">Access</a>为代表，适合桌面应用程序使用；</li><li>嵌入式数据库，以<a href="https://sqlite.org/">Sqlite</a>为代表，适合手机应用和桌面程序。</li></ol><h3 id="SQL">SQL</h3><p>什么是SQL？SQL是结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。不同的数据库，都支持SQL，这样，我们通过学习SQL这一种语言，就可以操作各种不同的数据库。</p><p>虽然SQL已经被ANSI组织定义为标准，不幸地是，各个不同的数据库对标准的SQL支持不太一致。并且，大部分数据库都在标准的SQL上做了扩展。也就是说，如果只使用标准SQL，理论上所有数据库都可以支持，但如果使用某个特定数据库的扩展SQL，换一个数据库就不能执行了。例如，Oracle把自己扩展的SQL称为<code>PL/SQL</code>，Microsoft把自己扩展的SQL称为<code>T-SQL</code>。</p><p>现实情况是，如果我们只使用标准SQL的核心功能，那么所有数据库通常都可以执行。不常用的SQL功能，不同的数据库支持的程度都不一样。而各个数据库支持的各自扩展的功能，通常我们把它们称之为“方言”。</p><p>总的来说，SQL语言定义了这么几种操作数据库的能力：</p><h4 id="DDL：Data-Definition-Language">DDL：Data Definition Language</h4><p>DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。</p><h4 id="DML：Data-Manipulation-Language">DML：Data Manipulation Language</h4><p>DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。</p><h4 id="DQL：Data-Query-Language">DQL：Data Query Language</h4><p>DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。</p><h3 id="语法特点">语法特点</h3><p>SQL语言关键字不区分大小写！！！但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。同一个数据库，有的在Linux上区分大小写，有的在Windows上不区分大小写。</p><p>所以，本教程约定：SQL关键字总是大写，以示突出，表名和列名均使用小写。</p><p>MySQL是目前应用最广泛的开源关系数据库。MySQL最早是由瑞典的MySQL AB公司开发，该公司在2008年被SUN公司收购，紧接着，SUN公司在2009年被Oracle公司收购，所以MySQL最终就变成了Oracle旗下的产品。</p><p>和其他关系数据库有所不同的是，MySQL本身实际上只是一个SQL接口，它的内部还包含了多种数据引擎，常用的包括：</p><ul><li>InnoDB：由Innobase Oy公司开发的一款支持事务的数据库引擎，2006年被Oracle收购；</li><li>MyISAM：MySQL早期集成的默认数据库引擎，不支持事务。</li></ul><p>MySQL接口和数据库引擎的关系就好比某某浏览器和浏览器引擎（IE引擎或Webkit引擎）的关系。对用户而言，切换浏览器引擎不影响浏览器界面，切换MySQL引擎不影响自己写的应用程序使用MySQL的接口。</p><p>使用MySQL时，不同的表还可以使用不同的数据库引擎。如果你不知道应该采用哪种引擎，记住总是选择<em>InnoDB</em>就好了。</p><p>因为MySQL一开始就是开源的，所以基于MySQL的开源版本，又衍生出了各种版本：</p><h3 id="MariaDB">MariaDB</h3><p>由MySQL的创始人创建的一个开源分支版本，使用XtraDB引擎。</p><h3 id="Aurora">Aurora</h3><p>由Amazon改进的一个MySQL版本，专门提供给在AWS托管MySQL用户，号称5倍的性能提升。</p><h3 id="PolarDB">PolarDB</h3><p>由Alibaba改进的一个MySQL版本，专门提供给在阿里云托管的MySQL用户，号称6倍的性能提升。</p><p>而MySQL官方版本又分了好几个版本：</p><ul><li>Community Edition：社区开源版本，免费；</li><li>Standard Edition：标准版；</li><li>Enterprise Edition：企业版；</li><li>Cluster Carrier Grade Edition：集群版。</li></ul><p>以上版本的功能依次递增，价格也依次递增。不过，功能增加的主要是监控、集群等管理功能，对于基本的SQL功能是完全一样的。</p><p>所以使用MySQL就带来了一个巨大的好处：可以在自己的电脑上安装免费的Community Edition版本，进行学习、开发、测试，部署的时候，可以选择付费的高级版本，或者云服务商提供的兼容版本，而不需要对应用程序本身做改动。</p><h3 id="安装MySQL">安装MySQL</h3><p>要安装MySQL，可以从MySQL官方网站下载最新的MySQL Community Server版本：</p><p><a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></p><p>选择对应的操作系统版本，下载安装即可。在安装过程中，MySQL会自动创建一个<code>root</code>用户，并提示输入<code>root</code>口令。</p><p>要在Linux上安装MySQL，可以使用发行版的包管理器。例如，Debian和Ubuntu用户可以简单地通过命令<code>apt install mysql-server</code>安装最新的MySQL版本。</p><p>MySQL安装后会自动在后台运行。为了验证MySQL安装是否正确，我们需要通过<code>mysql</code>这个命令行程序来连接MySQL服务器。</p><p>在命令提示符下输入<code>mysql -u root -p</code>，然后输入口令，如果一切正确，就会连接到MySQL服务器，同时提示符变为<code>mysql&gt;</code>。</p><p>输入<code>exit</code>退出MySQL命令行。注意，MySQL服务器仍在后台运行。</p><h3 id="使用Docker运行MySQL">使用Docker运行MySQL</h3><p>另一种运行MySQL的方式不需要下载安装包，而是直接通过Docker安装最新的MySQL：</p><p>首先安装<a href="https://www.docker.com/products/docker-desktop/">Docker Desktop</a>，然后在命令行输入以下命令拉取MySQL最新版：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull mysql</span><br></pre></td></tr></table></figure><p>拉取完成后，输入以下命令直接启动MySQL服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=password -v /Users/chankein/mysql-data:/var/lib/mysql mysql</span><br></pre></td></tr></table></figure><p>命令<code>docker run</code>表示启动一个容器，后面各参数含义如下：</p><ul><li><code>-d</code>：表示在后台执行；</li><li><code>--name mysql</code>：表示容器的名字，不输入Docker会自动选择一个名字；</li><li><code>-p 3306:3306</code>：表示把容器的端口3306映射到本机，这样可以在本机通过3306端口连接MySQL；</li><li><code>-e MYSQL_ROOT_PASSWORD=password</code>：表示传入一个环境变量，作为root的口令，这里设置的口令是<code>password</code>，不输入此项则会自动生成一个口令，需要查看日志才能知道口令；</li><li><code>-v /Users/chankein/mysql-data:/var/lib/mysql</code>：表示将本地目录映射到容器目录<code>/var/lib/mysql</code>作为MySQL数据库存放的位置，需要将<code>/Users/chankein/mysql-data</code>改为你的电脑上的实际目录；</li><li><code>mysql</code>：最后一个参数是Docker镜像的名称。</li></ul><p>可以在Docker Desktop的管理窗口中选择<code>Containers</code>，看到正在运行的MySQL：</p><p><img src="https://liaoxuefeng.com/books/sql/rdbms/install-mysql/docker-mysql.png" alt="docker-mysql"></p><p>点击MySQL查看日志：</p><p><img src="https://liaoxuefeng.com/books/sql/rdbms/install-mysql/docker-mysql-log.png" alt="docker-mysql-log"></p><p>点击Exec进入命令行，输入命令<code>mysql -u root -p</code>，输入口令，即可进入MySQL命令行界面：</p><p><img src="https://liaoxuefeng.com/books/sql/rdbms/install-mysql/docker-mysql-exec.png" alt="docker-mysql-exec"></p><p>使用Docker运行MySQL时，任何时候都可以删除MySQL容器并重新运行。如果删除了本地映射的目录，重新运行就相当于一个全新的MySQL，因此，建议仅作为学习和开发使用，不要存储重要的数据。</p><h2 id="关系模型">关系模型</h2><p>我们已经知道，关系数据库是建立在关系模型上的。而关系模型本质上就是若干个存储数据的二维表，可以把它们看作很多Excel表。</p><p>表的每一行称为记录（Record），记录是一个逻辑意义上的数据。</p><p>表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。</p><p>字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为<code>NULL</code>。注意<code>NULL</code>表示字段数据不存在。一个整型字段如果为<code>NULL</code>不表示它的值为<code>0</code>，同样的，一个字符串型字段为<code>NULL</code>也不表示它的值为空串<code>''</code>。</p><p>提示</p><p>通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。</p><p>和Excel表有所不同的是，关系数据库的表和表之间需要建立“一对多”，“多对一”和“一对一”的关系，这样才能够按照应用程序的逻辑来组织和存储数据。</p><p>例如，一个班级表：</p><table><thead><tr><th>ID</th><th>名称</th><th>班主任</th></tr></thead><tbody><tr><td>201</td><td>二年级一班</td><td>王老师</td></tr><tr><td>202</td><td>二年级二班</td><td>李老师</td></tr></tbody></table><p>每一行对应着一个班级，而一个班级对应着多个学生，所以班级表和学生表的关系就是“一对多”：</p><table><thead><tr><th>ID</th><th>姓名</th><th>班级ID</th><th>性别</th><th>年龄</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>201</td><td>M</td><td>9</td></tr><tr><td>2</td><td>小红</td><td>202</td><td>F</td><td>8</td></tr><tr><td>3</td><td>小军</td><td>202</td><td>M</td><td>8</td></tr><tr><td>4</td><td>小白</td><td>201</td><td>F</td><td>9</td></tr></tbody></table><p>反过来，如果我们先在学生表中定位了一行记录，例如<code>ID=1</code>的小明，要确定他的班级，只需要根据他的“班级ID”对应的值<code>201</code>找到班级表中<code>ID=201</code>的记录，即二年级一班。所以，学生表和班级表是“多对一”的关系。</p><p>如果我们把班级表分拆得细一点，例如，单独创建一个教师表：</p><table><thead><tr><th>ID</th><th>名称</th><th>年龄</th></tr></thead><tbody><tr><td>A1</td><td>王老师</td><td>26</td></tr><tr><td>A2</td><td>张老师</td><td>39</td></tr><tr><td>A3</td><td>李老师</td><td>32</td></tr><tr><td>A4</td><td>赵老师</td><td>27</td></tr></tbody></table><p>班级表只存储教师ID：</p><table><thead><tr><th>ID</th><th>名称</th><th>班主任ID</th></tr></thead><tbody><tr><td>201</td><td>二年级一班</td><td>A1</td></tr><tr><td>202</td><td>二年级二班</td><td>A3</td></tr></tbody></table><p>这样，一个班级总是对应一个教师，班级表和教师表就是“一对一”关系。</p><p>在关系数据库中，关系是通过<em>主键</em>和<em>外键</em>来维护的。我们在后面会分别深入讲解。</p><h2 id="主键">主键</h2><p>在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。例如，<code>students</code>表的两行记录：</p><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>gender</th><th>score</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>M</td><td>90</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>F</td><td>95</td></tr></tbody></table><p>每一条记录都包含若干定义好的字段。同一个表的所有记录都有相同的字段定义。</p><p>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为<em>主键</em>。</p><p>例如，假设我们把<code>name</code>字段作为主键，那么通过名字<code>小明</code>或<code>小红</code>就能唯一确定一条记录。但是，这么设定，就没法存储同名的同学了，因为插入相同主键的两条记录是不被允许的。</p><p>对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。</p><p>由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。</p><p>所以，选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。</p><p>因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均<em>不可</em>用作主键。</p><p>作为主键最好是完全业务无关的字段，我们一般把这个字段命名为<code>id</code>。常见的可作为<code>id</code>字段的类型有：</p><ol><li>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</li><li>全局唯一GUID类型：也称UUID，使用一种全局唯一的字符串作为主键，类似<code>8f55d96b-8acc-4636-8cb8-76bf8abc2f57</code>。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</li></ol><p>对于大部分应用来说，通常自增类型的主键就能满足需求。我们在<code>students</code>表中定义的主键也是<code>BIGINT NOT NULL AUTO_INCREMENT</code>类型。</p><p>注意</p><p>如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。</p><h3 id="联合主键">联合主键</h3><p>关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。</p><p>对于联合主键，允许一列有重复，只要不是所有主键列都重复即可：</p><table><thead><tr><th>id_num</th><th>id_type</th><th>other columns…</th></tr></thead><tbody><tr><td>1</td><td>A</td><td>…</td></tr><tr><td>2</td><td>A</td><td>…</td></tr><tr><td>2</td><td>B</td><td>…</td></tr></tbody></table><p>如果我们把上述表的<code>id_num</code>和<code>id_type</code>这两列作为联合主键，那么上面的3条记录都是允许的，因为没有两列主键组合起来是相同的。</p><p>没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。</p><h3 id="小结">小结</h3><p>主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许<code>NULL</code>。</p><p>可以使用多个列作为联合主键，但联合主键并不常用。</p><p>当我们用主键唯一标识记录时，我们就可以在<code>students</code>表中确定任意一个学生的记录：</p><table><thead><tr><th>id</th><th>name</th><th>other columns…</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>…</td></tr><tr><td>2</td><td>小红</td><td>…</td></tr></tbody></table><p>我们还可以在<code>classes</code>表中确定任意一个班级记录：</p><table><thead><tr><th>id</th><th>name</th><th>other columns…</th></tr></thead><tbody><tr><td>1</td><td>一班</td><td>…</td></tr><tr><td>2</td><td>二班</td><td>…</td></tr></tbody></table><p>但是我们如何确定<code>students</code>表的一条记录，例如，<code>id=1</code>的小明，属于哪个班级呢？</p><p>由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个<code>classes</code>的记录可以对应多个<code>students</code>表的记录。</p><p>为了表达这种一对多的关系，我们需要在<code>students</code>表中加入一列<code>class_id</code>，让它的值与<code>classes</code>表的某条记录相对应：</p><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>other columns…</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>…</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>…</td></tr><tr><td>5</td><td>2</td><td>小白</td><td>…</td></tr></tbody></table><p>这样，我们就可以根据<code>class_id</code>这个列直接定位出一个<code>students</code>表的记录应该对应到<code>classes</code>的哪条记录。</p><p>例如：</p><ul><li>小明的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li><li>小红的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li><li>小白的<code>class_id</code>是<code>2</code>，因此，对应的<code>classes</code>表的记录是<code>id=2</code>的二班。</li></ul><p>在<code>students</code>表中，通过<code>class_id</code>的字段，可以把数据与另一张表关联起来，这种列称为<code>外键</code>。</p><p>外键并不是通过列名实现的，而是通过定义外键约束实现的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD CONSTRAINT</span> fk_class_id</span><br><span class="line"><span class="keyword">FOREIGN KEY</span> (class_id)</span><br><span class="line"><span class="keyword">REFERENCES</span> classes (id);</span><br></pre></td></tr></table></figure><p>其中，外键约束的名称<code>fk_class_id</code>可以任意，<code>FOREIGN KEY (class_id)</code>指定了<code>class_id</code>作为外键，<code>REFERENCES classes (id)</code>指定了这个外键将关联到<code>classes</code>表的<code>id</code>列（即<code>classes</code>表的主键）。</p><p>通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果<code>classes</code>表不存在<code>id=99</code>的记录，<code>students</code>表就无法插入<code>class_id=99</code>的记录。</p><p>由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，<code>class_id</code>仅仅是一个普通的列，只是它起到了外键的作用而已。</p><p>要删除一个外键约束，也是通过<code>ALTER TABLE</code>实现的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FOREIGN KEY</span> fk_class_id;</span><br></pre></td></tr></table></figure><p>注意：删除外键约束并没有删除外键这一列。删除列是通过<code>DROP COLUMN ...</code>实现的。</p><h3 id="多对多">多对多</h3><p>通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。</p><p>多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系：</p><p><code>teachers</code>表：</p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>张老师</td></tr><tr><td>2</td><td>王老师</td></tr><tr><td>3</td><td>李老师</td></tr><tr><td>4</td><td>赵老师</td></tr></tbody></table><p><code>classes</code>表：</p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>一班</td></tr><tr><td>2</td><td>二班</td></tr></tbody></table><p>中间表<code>teacher_class</code>关联两个一对多关系：</p><table><thead><tr><th>id</th><th>teacher_id</th><th>class_id</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>1</td><td>2</td></tr><tr><td>3</td><td>2</td><td>1</td></tr><tr><td>4</td><td>2</td><td>2</td></tr><tr><td>5</td><td>3</td><td>1</td></tr><tr><td>6</td><td>4</td><td>2</td></tr></tbody></table><p>通过中间表<code>teacher_class</code>可知<code>teachers</code>到<code>classes</code>的关系：</p><ul><li><code>id=1</code>的张老师对应<code>id=1,2</code>的一班和二班；</li><li><code>id=2</code>的王老师对应<code>id=1,2</code>的一班和二班；</li><li><code>id=3</code>的李老师对应<code>id=1</code>的一班；</li><li><code>id=4</code>的赵老师对应<code>id=2</code>的二班。</li></ul><p>同理可知<code>classes</code>到<code>teachers</code>的关系：</p><ul><li><code>id=1</code>的一班对应<code>id=1,2,3</code>的张老师、王老师和李老师；</li><li><code>id=2</code>的二班对应<code>id=1,2,4</code>的张老师、王老师和赵老师；</li></ul><p>因此，通过中间表，我们就定义了一个“多对多”关系。</p><h3 id="一对一">一对一</h3><p>一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。</p><p>例如，<code>students</code>表的每个学生可以有自己的联系方式，如果把联系方式存入另一个表<code>contacts</code>，我们就可以得到一个“一对一”关系：</p><table><thead><tr><th>id</th><th>student_id</th><th>mobile</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>135xxxx6300</td></tr><tr><td>2</td><td>2</td><td>138xxxx2209</td></tr><tr><td>3</td><td>5</td><td>139xxxx8086</td></tr></tbody></table><p>有细心的童鞋会问，既然是一对一关系，那为啥不给<code>students</code>表增加一个<code>mobile</code>列，这样就能合二为一了？</p><p>如果业务允许，完全可以把两个表合为一个表。但是，有些时候，如果某个学生没有手机号，那么，<code>contacts</code>表就不存在对应的记录。实际上，一对一关系准确地说，是<code>contacts</code>表一对一对应<code>students</code>表。</p><p>还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表<code>user_info</code>和用户详细信息表<code>user_profiles</code>，大部分时候，只需要查询<code>user_info</code>表，并不需要查询<code>user_profiles</code>表，这样就提高了查询速度。</p><h3 id="小结-2">小结</h3><p>关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。</p><p>在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。</p><p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。</p><p>例如，对于<code>students</code>表：</p><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>gender</th><th>score</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>M</td><td>90</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>F</td><td>95</td></tr><tr><td>3</td><td>1</td><td>小军</td><td>M</td><td>88</td></tr></tbody></table><p>如果要经常根据<code>score</code>列进行查询，就可以对<code>score</code>列创建索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_score (score);</span><br></pre></td></tr></table></figure><p>使用<code>ADD INDEX idx_score (score)</code>就创建了一个名称为<code>idx_score</code>，使用列<code>score</code>的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_name_score (name, score);</span><br></pre></td></tr></table></figure><p>索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如<code>gender</code>列，大约一半的记录值是<code>M</code>，另一半是<code>F</code>，因此，对该列创建索引就没有意义。</p><p>可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。</p><p>对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。</p><h3 id="唯一索引">唯一索引</h3><p>在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。</p><p>但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。例如，我们假设<code>students</code>表的<code>name</code>不能重复：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX uni_name (name);</span><br></pre></td></tr></table></figure><p>通过<code>UNIQUE</code>关键字我们就添加了一个唯一索引。</p><p>也可以只对某一列添加一个唯一约束而不创建唯一索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD CONSTRAINT</span> uni_name <span class="keyword">UNIQUE</span> (name);</span><br></pre></td></tr></table></figure><p>这种情况下，<code>name</code>列没有索引，但仍然具有唯一性保证。</p><p>无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。</p><h3 id="小结-3">小结</h3><p>通过对数据库表创建索引，可以提高查询速度；</p><p>通过创建唯一索引，可以保证某一列的值具有唯一性；</p><p>数据库索引对于用户和应用程序来说都是透明的。</p><p>在关系数据库中，最常用的操作就是查询。</p><h3 id="准备数据">准备数据</h3><p>为了便于讲解和练习，我们先准备好了一个<code>students</code>表和一个<code>classes</code>表，它们的结构和数据如下：</p><p><code>students</code>表存储了学生信息：</p><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>gender</th><th>score</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>M</td><td>90</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>F</td><td>95</td></tr><tr><td>3</td><td>1</td><td>小军</td><td>M</td><td>88</td></tr><tr><td>4</td><td>1</td><td>小米</td><td>F</td><td>73</td></tr><tr><td>5</td><td>2</td><td>小白</td><td>F</td><td>81</td></tr><tr><td>6</td><td>2</td><td>小兵</td><td>M</td><td>55</td></tr><tr><td>7</td><td>2</td><td>小林</td><td>M</td><td>85</td></tr><tr><td>8</td><td>3</td><td>小新</td><td>F</td><td>91</td></tr><tr><td>9</td><td>3</td><td>小王</td><td>M</td><td>89</td></tr><tr><td>10</td><td>3</td><td>小丽</td><td>F</td><td>85</td></tr></tbody></table><p><code>classes</code>表存储了班级信息：</p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>一班</td></tr><tr><td>2</td><td>二班</td></tr><tr><td>3</td><td>三班</td></tr><tr><td>4</td><td>四班</td></tr></tbody></table><p>请注意，和<code>MySQL</code>的持久化存储不同的是，由于我们使用的是<a href="https://alasql.org/">AlaSQL</a>内存数据库，两张表的数据在页面加载时导入，并且只存在于浏览器的内存中，因此，刷新页面后，数据会重置为上述初始值。</p><h3 id="MySQL">MySQL</h3><p>如果你想用MySQL练习，可以<a href="https://liaoxuefeng.com/books/sql/query/mysql-init-test-data.sql">下载这个SQL脚本</a>，然后在命令行运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u root -p &lt; init-test-data.sql</span><br></pre></td></tr></table></figure><p>就可以自动创建<code>test</code>数据库，并且在<code>test</code>数据库下创建<code>students</code>表和<code>classes</code>表，以及必要的初始化数据。</p><p>和内存数据库不同的是，对MySQL数据库做的所有修改，都会保存下来。如果你希望恢复到初始状态，可以再次运行该脚本。</p><h2 id="基本查询">基本查询</h2><p>要查询数据库表的数据，我们使用如下的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>假设表名是<code>students</code>，要查询<code>students</code>表的所有行，我们用如下SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询students表的所有数据</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>使用<code>SELECT * FROM students</code>时，<code>SELECT</code>是关键字，表示将要执行一个查询，<code>*</code>表示“所有列”，<code>FROM</code>表示将要从哪个表查询，本例中是<code>students</code>表。</p><p>该SQL将查询出<code>students</code>表的所有数据。注意：查询结果也是一个二维表，它包含列名和每一行的数据。</p><p>要查询<code>classes</code>表的所有行，我们用如下SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询classes表的所有数据</span><br><span class="line">SELECT * FROM classes;</span><br></pre></td></tr></table></figure><p>运行上述SQL语句，观察查询结果。</p><p><code>SELECT</code>语句其实并不要求一定要有<code>FROM</code>子句。我们来试试下面的<code>SELECT</code>语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 计算100+200</span><br><span class="line">SELECT 100+200;</span><br></pre></td></tr></table></figure><p>上述查询会直接计算出表达式的结果。虽然<code>SELECT</code>可以用作计算，但它并不是SQL的强项。但是，不带<code>FROM</code>子句的<code>SELECT</code>语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条<code>SELECT 1;</code>来测试数据库连接。</p><h3 id="小结-4">小结</h3><p>使用SELECT查询的基本语句<code>SELECT * FROM &lt;表名&gt;</code>可以查询一个表的所有行和所有列的数据；</p><p>SELECT查询的结果是一个二维表。</p><p>使用<code>SELECT * FROM &lt;表名&gt;</code>可以查询到一张表的所有记录。但是，很多时候，我们并不希望获得所有记录，而是根据条件选择性地获取指定条件的记录，例如，查询分数在80分以上的学生记录。在一张表有数百万记录的情况下，获取所有记录不仅费时，还费内存和网络带宽。</p><p>SELECT语句可以通过<code>WHERE</code>条件来设定查询条件，查询结果是满足查询条件的记录。例如，要指定条件“分数在80分或以上的学生”，写成<code>WHERE</code>条件就是<code>SELECT * FROM students WHERE score &gt;= 80</code>。</p><p>其中，<code>WHERE</code>关键字后面的<code>score &gt;= 80</code>就是条件。<code>score</code>是列名，该列存储了学生的成绩，因此，<code>score &gt;= 80</code>就筛选出了指定条件的记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按条件查询students:</span><br><span class="line">SELECT * FROM students WHERE score &gt;= 80;</span><br></pre></td></tr></table></figure><p>因此，条件查询的语法就是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>条件表达式可以用<code>&lt;条件1&gt; AND &lt;条件2&gt;</code>表达满足条件1并且满足条件2。例如，符合条件“分数在80分或以上”，并且还符合条件“男生”，把这两个条件写出来：</p><ul><li>条件1：根据score列的数据判断：<code>score &gt;= 80</code>；</li><li>条件2：根据gender列的数据判断：<code>gender = 'M'</code>，注意<code>gender</code>列存储的是字符串，需要用单引号括起来。</li></ul><p>就可以写出<code>WHERE</code>条件：<code>score &gt;= 80 AND gender = 'M'</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按AND条件查询students:</span><br><span class="line">SELECT * FROM students WHERE score &gt;= 80 AND gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure><p>第二种条件是<code>&lt;条件1&gt; OR &lt;条件2&gt;</code>，表示满足条件1或者满足条件2。例如，把上述<code>AND</code>查询的两个条件改为<code>OR</code>，查询结果就是“分数在80分或以上”或者“男生”，满足任意之一的条件即选出该记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按OR条件查询students:</span><br><span class="line">SELECT * FROM students WHERE score &gt;= 80 OR gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure><p>很显然<code>OR</code>条件要比<code>AND</code>条件宽松，返回的符合条件的记录也更多。</p><p>第三种条件是<code>NOT &lt;条件&gt;</code>，表示“不符合该条件”的记录。例如，写一个“不是2班的学生”这个条件，可以先写出“是2班的学生”：<code>class_id = 2</code>，再加上<code>NOT</code>：<code>NOT class_id = 2</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按NOT条件查询students:</span><br><span class="line">SELECT * FROM students WHERE NOT class_id = 2;</span><br></pre></td></tr></table></figure><p>上述<code>NOT</code>条件<code>NOT class_id = 2</code>其实等价于<code>class_id &lt;&gt; 2</code>，因此，<code>NOT</code>查询不是很常用。</p><p>要组合三个或者更多的条件，就需要用小括号<code>()</code>表示如何进行条件运算。例如，编写一个复杂的条件：分数在80以下或者90以上，并且是男生：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按多个条件查询students:</span><br><span class="line">SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure><p>如果不加括号，条件运算按照<code>NOT</code>、<code>AND</code>、<code>OR</code>的优先级进行，即<code>NOT</code>优先级最高，其次是<code>AND</code>，最后是<code>OR</code>。加上括号可以改变优先级。</p><h3 id="常用的条件表达式">常用的条件表达式</h3><table><thead><tr><th>条件</th><th>表达式举例1</th><th>表达式举例2</th><th>说明</th></tr></thead><tbody><tr><td>使用=判断相等</td><td>score = 80</td><td>name = ‘abc’</td><td>字符串需要用单引号括起来</td></tr><tr><td>使用&gt;判断大于</td><td>score &gt; 80</td><td>name &gt; ‘abc’</td><td>字符串比较根据ASCII码，中文字符比较根据数据库设置</td></tr><tr><td>使用&gt;=判断大于或相等</td><td>score &gt;= 80</td><td>name &gt;= ‘abc’</td><td></td></tr><tr><td>使用&lt;判断小于</td><td>score &lt; 80</td><td>name &lt;= ‘abc’</td><td></td></tr><tr><td>使用&lt;=判断小于或相等</td><td>score &lt;= 80</td><td>name &lt;= ‘abc’</td><td></td></tr><tr><td>使用&lt;&gt;判断不相等</td><td>score &lt;&gt; 80</td><td>name &lt;&gt; ‘abc’</td><td></td></tr><tr><td>使用LIKE判断相似</td><td>name LIKE ‘ab%’</td><td>name LIKE ‘%bc%’</td><td>%表示任意字符，例如’ab%‘将匹配’ab’，‘abc’，‘abcd’</td></tr></tbody></table><p>查询分数在60分(含)～90分(含)之间的学生可以使用的WHERE语句是：</p><h3 id="小结-5">小结</h3><p>通过<code>WHERE</code>条件查询，可以筛选出符合指定条件的记录，而不是整个表的所有记录。</p><h2 id="投影查询">投影查询</h2><p>使用<code>SELECT * FROM &lt;表名&gt; WHERE &lt;条件&gt;</code>可以选出表中的若干条记录。我们注意到返回的二维表结构和原表是相同的，即结果集的所有列与原表的所有列都一一对应。</p><p>如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用<code>SELECT 列1, 列2, 列3 FROM ...</code>，让结果集仅包含指定列。这种操作称为投影查询。</p><p>例如，从<code>students</code>表中返回<code>id</code>、<code>score</code>和<code>name</code>这三列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用投影查询</span><br><span class="line">SELECT id, score, name FROM students;</span><br></pre></td></tr></table></figure><p>这样返回的结果集就只包含了我们指定的列，并且，结果集的列的顺序和原表可以不一样。</p><p>使用<code>SELECT 列1, 列2, 列3 FROM ...</code>时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是<code>SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...</code>。</p><p>例如，以下<code>SELECT</code>语句将列名<code>score</code>重命名为<code>points</code>，而<code>id</code>和<code>name</code>列名保持不变：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用投影查询，并将列名重命名：</span><br><span class="line">SELECT id, score points, name FROM students;</span><br></pre></td></tr></table></figure><p>投影查询同样可以接<code>WHERE</code>条件，实现复杂的查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用投影查询+WHERE条件：</span><br><span class="line">SELECT id, score points, name FROM students WHERE gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure><h3 id="小结-6">小结</h3><p>使用<code>SELECT *</code>表示查询表的所有列，使用<code>SELECT 列1, 列2, 列3</code>则可以仅返回指定列，这种操作称为投影；</p><p><code>SELECT</code>语句可以对结果集的列进行重命名。</p><h2 id="排序">排序</h2><h3 id="排序-2">排序</h3><p>我们使用SELECT查询时，细心的读者可能注意到，查询结果集通常是按照<code>id</code>排序的，也就是根据主键排序。这也是大部分数据库的做法。如果我们要根据其他条件排序怎么办？可以加上<code>ORDER BY</code>子句。例如按照成绩从低到高进行排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按score从低到高:</span><br><span class="line">SELECT id, name, gender, score FROM students ORDER BY score;</span><br></pre></td></tr></table></figure><p>如果要反过来，按照成绩从高到底排序，我们可以加上<code>DESC</code>表示“倒序”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按score从高到低:</span><br><span class="line">SELECT id, name, gender, score FROM students ORDER BY score DESC;</span><br></pre></td></tr></table></figure><p>如果<code>score</code>列有相同的数据，要进一步排序，可以继续添加列名。例如，使用<code>ORDER BY score DESC, gender</code>表示先按<code>score</code>列倒序，如果有相同分数的，再按<code>gender</code>列排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按score, gender排序:</span><br><span class="line">SELECT id, name, gender, score FROM students ORDER BY score DESC, gender;</span><br></pre></td></tr></table></figure><p>默认的排序规则是<code>ASC</code>：“升序”，即从小到大。<code>ASC</code>可以省略，即<code>ORDER BY score ASC</code>和<code>ORDER BY score</code>效果一样。</p><p>如果有<code>WHERE</code>子句，那么<code>ORDER BY</code>子句要放到<code>WHERE</code>子句后面。例如，查询一班的学生成绩，并按照倒序排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 带WHERE条件的ORDER BY:</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">WHERE class_id = 1</span><br><span class="line">ORDER BY score DESC;</span><br></pre></td></tr></table></figure><p>这样，结果集仅包含符合<code>WHERE</code>条件的记录，并按照<code>ORDER BY</code>的设定排序。</p><h3 id="小结-7">小结</h3><p>使用<code>ORDER BY</code>可以对结果集进行排序；</p><p>可以对多列进行升序、倒序排序。</p><p>使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。</p><p>要实现分页功能，实际上就是从结果集中显示第1~100条记录作为第1页，显示第101~200条记录作为第2页，以此类推。</p><p>因此，分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过<code>LIMIT &lt;N-M&gt; OFFSET &lt;M&gt;</code>子句实现。我们先把所有学生按照成绩从高到低进行排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按score从高到低:</span><br><span class="line">SELECT id, name, gender, score FROM students ORDER BY score DESC;</span><br></pre></td></tr></table></figure><p>现在，我们把结果集分页，每页3条记录。要获取第1页的记录，可以使用<code>LIMIT 3 OFFSET 0</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询第1页:</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 0;</span><br></pre></td></tr></table></figure><p>上述查询<code>LIMIT 3 OFFSET 0</code>表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。</p><p>如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把<code>OFFSET</code>设定为3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询第2页:</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 3;</span><br></pre></td></tr></table></figure><p>类似的，查询第3页的时候，<code>OFFSET</code>应该设定为6:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询第3页:</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 6;</span><br></pre></td></tr></table></figure><p>查询第4页的时候，<code>OFFSET</code>应该设定为9:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询第4页:</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 9;</span><br></pre></td></tr></table></figure><p>由于第4页只有1条记录，因此最终结果集按实际数量1显示。<code>LIMIT 3</code>表示的意思是“最多3条记录”。</p><p>可见，分页查询的关键在于，首先要确定每页需要显示的结果数量<code>pageSize</code>（这里是3），然后根据当前页的索引<code>pageIndex</code>（从1开始），确定<code>LIMIT</code>和<code>OFFSET</code>应该设定的值：</p><ul><li><code>LIMIT</code>总是设定为<code>pageSize</code>；</li><li><code>OFFSET</code>计算公式为<code>pageSize * (pageIndex - 1)</code>。</li></ul><p>这样就能正确查询出第N页的记录集。</p><p>如果原本记录集一共就10条记录，但我们把<code>OFFSET</code>设置为20，会得到什么结果呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- OFFSET设定为20:</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 20;</span><br></pre></td></tr></table></figure><p><code>OFFSET</code>超过了查询的最大数量并不会报错，而是得到一个空的结果集。</p><h3 id="注意">注意</h3><p><code>OFFSET</code>是可选的，如果只写<code>LIMIT 15</code>，那么相当于<code>LIMIT 15 OFFSET 0</code>。</p><p>在MySQL中，<code>LIMIT 15 OFFSET 30</code>还可以简写成<code>LIMIT 30, 15</code>。</p><p>使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>分页时，随着<code>N</code>越来越大，查询效率也会越来越低。</p><h3 id="思考">思考</h3><p>在分页查询之前，如何计算一共有几页？</p><h3 id="小结-8">小结</h3><p>使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>可以对结果集进行分页，每次查询返回结果集的一部分；</p><p>分页查询需要先确定每页的数量和当前页数，然后确定<code>LIMIT</code>和<code>OFFSET</code>的值。</p><p>如果我们要统计一张表的数据量，例如，想查询<code>students</code>表一共有多少条记录，难道必须用<code>SELECT * FROM students</code>查出来然后再数一数有多少行吗？</p><p>这个方法当然可以，但是比较弱智。对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。</p><p>仍然以查询<code>students</code>表一共有多少条记录为例，我们可以使用SQL内置的<code>COUNT()</code>函数查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用聚合查询:</span><br><span class="line">SELECT COUNT(*) FROM students;</span><br></pre></td></tr></table></figure><p><code>COUNT(*)</code>表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是<code>COUNT(*)</code>。</p><p>通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用聚合查询并设置结果集的列名为num:</span><br><span class="line">SELECT COUNT(*) num FROM students;</span><br></pre></td></tr></table></figure><p><code>COUNT(*)</code>和<code>COUNT(id)</code>实际上是一样的效果。另外注意，聚合查询同样可以使用<code>WHERE</code>条件，因此我们可以方便地统计出有多少男生、多少女生、多少80分以上的学生等：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用聚合查询并设置WHERE条件:</span><br><span class="line">SELECT COUNT(*) boys FROM students WHERE gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure><p>除了<code>COUNT()</code>函数外，SQL还提供了如下聚合函数：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SUM</td><td>计算某一列的合计值，该列必须为数值类型</td></tr><tr><td>AVG</td><td>计算某一列的平均值，该列必须为数值类型</td></tr><tr><td>MAX</td><td>计算某一列的最大值</td></tr><tr><td>MIN</td><td>计算某一列的最小值</td></tr></tbody></table><p>注意，<code>MAX()</code>和<code>MIN()</code>函数并不限于数值类型。如果是字符类型，<code>MAX()</code>和<code>MIN()</code>会返回排序最后和排序最前的字符。</p><p>要统计男生的平均成绩，我们用下面的聚合查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用聚合查询计算男生平均成绩:</span><br><span class="line">SELECT AVG(score) average FROM students WHERE gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure><p>要特别注意：如果聚合查询的<code>WHERE</code>条件没有匹配到任何行，<code>COUNT()</code>会返回0，而<code>SUM()</code>、<code>AVG()</code>、<code>MAX()</code>和<code>MIN()</code>会返回<code>NULL</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- WHERE条件gender = &#x27;X&#x27;匹配不到任何行:</span><br><span class="line">SELECT AVG(score) average FROM students WHERE gender = &#x27;X&#x27;;</span><br></pre></td></tr></table></figure><h3 id="分组">分组</h3><p>如果我们要统计一班的学生数量，我们知道，可以用<code>SELECT COUNT(*) num FROM students WHERE class_id = 1;</code>。如果要继续统计二班、三班的学生数量，难道必须不断修改<code>WHERE</code>条件来执行<code>SELECT</code>语句吗？</p><p>对于聚合查询，SQL还提供了“分组聚合”的功能。我们观察下面的聚合查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按class_id分组:</span><br><span class="line">SELECT COUNT(*) num FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure><p>执行这个查询，<code>COUNT()</code>的结果不再是一个，而是3个，这是因为，<code>GROUP BY</code>子句指定了按<code>class_id</code>分组，因此，执行该<code>SELECT</code>语句时，会把<code>class_id</code>相同的列先分组，再分别计算，因此，得到了3行结果。</p><p>但是这3行结果分别是哪三个班级的，不好看出来，所以我们可以把<code>class_id</code>列也放入结果集中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按class_id分组:</span><br><span class="line">SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure><p>这下结果集就可以一目了然地看出各个班级的学生人数。我们再试试把<code>name</code>放入结果集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按class_id分组:</span><br><span class="line">SELECT name, class_id, COUNT(*) num FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure><p>不出意外，执行这条查询我们会得到一个语法错误，因为在任意一个分组中，只有<code>class_id</code>都相同，<code>name</code>是不同的，SQL引擎不能把多个<code>name</code>的值放入一行记录中。因此，聚合查询的列中，只能放入分组的列。</p><p>注意</p><p>AlaSQL并没有严格执行SQL标准，上述SQL在浏览器可以正常执行，但是在MySQL、Oracle等环境下将报错，请自行在MySQL中测试。</p><p>也可以使用多个列进行分组。例如，我们想统计各班的男生和女生人数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按class_id, gender分组:</span><br><span class="line">SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender;</span><br></pre></td></tr></table></figure><p>上述查询结果集一共有6条记录，分别对应各班级的男生和女生人数。</p><h3 id="练习">练习</h3><p>请使用一条SELECT查询查出每个班级的平均分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查出每个班级的平均分，结果集应当有3条记录:</span><br><span class="line">SELECT &#x27;TODO&#x27;;</span><br></pre></td></tr></table></figure><p>请使用一条SELECT查询查出每个班级男生和女生的平均分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查出每个班级的平均分，结果集应当有6条记录:</span><br><span class="line">SELECT &#x27;TODO&#x27;;</span><br></pre></td></tr></table></figure><h3 id="小结-9">小结</h3><p>使用SQL提供的聚合查询，我们可以方便地计算总数、合计值、平均值、最大值和最小值；</p><p>聚合查询可以用<code>GROUP BY</code>分组聚合；</p><p>聚合查询也可以添加<code>WHERE</code>条件。</p><p>SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：<code>SELECT * FROM &lt;表1&gt; &lt;表2&gt;</code>。</p><p>例如，同时从<code>students</code>表和<code>classes</code>表的“乘积”，即查询数据，可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- FROM students, classes:</span><br><span class="line">SELECT * FROM students, classes;</span><br></pre></td></tr></table></figure><p>这种一次查询两个表的数据，查询的结果也是一个二维表，它是<code>students</code>表和<code>classes</code>表的“乘积”，即<code>students</code>表的每一行与<code>classes</code>表的每一行都两两拼在一起返回。结果集的列数是<code>students</code>表和<code>classes</code>表的列数之和，行数是<code>students</code>表和<code>classes</code>表的行数之积。</p><p>这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。</p><p>你可能还注意到了，上述查询的结果集有两列<code>id</code>和两列<code>name</code>，两列<code>id</code>是因为其中一列是<code>students</code>表的<code>id</code>，而另一列是<code>classes</code>表的<code>id</code>，但是在结果集中，不好区分。两列<code>name</code>同理</p><p>要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的<code>id</code>和<code>name</code>列起别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- set alias:</span><br><span class="line">SELECT</span><br><span class="line">    students.id sid,</span><br><span class="line">    students.name,</span><br><span class="line">    students.gender,</span><br><span class="line">    students.score,</span><br><span class="line">    classes.id cid,</span><br><span class="line">    classes.name cname</span><br><span class="line">FROM students, classes;</span><br></pre></td></tr></table></figure><p>注意，多表查询时，要使用<code>表名.列名</code>这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用<code>表名.列名</code>这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- set table alias:</span><br><span class="line">SELECT</span><br><span class="line">    s.id sid,</span><br><span class="line">    s.name,</span><br><span class="line">    s.gender,</span><br><span class="line">    s.score,</span><br><span class="line">    c.id cid,</span><br><span class="line">    c.name cname</span><br><span class="line">FROM students s, classes c;</span><br></pre></td></tr></table></figure><p>注意到<code>FROM</code>子句给表设置别名的语法是<code>FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;</code>。这样我们用别名<code>s</code>和<code>c</code>分别表示<code>students</code>表和<code>classes</code>表。</p><p>多表查询也是可以添加<code>WHERE</code>条件的，我们来试试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- set where clause:</span><br><span class="line">SELECT</span><br><span class="line">    s.id sid,</span><br><span class="line">    s.name,</span><br><span class="line">    s.gender,</span><br><span class="line">    s.score,</span><br><span class="line">    c.id cid,</span><br><span class="line">    c.name cname</span><br><span class="line">FROM students s, classes c</span><br><span class="line">WHERE s.gender = &#x27;M&#x27; AND c.id = 1;</span><br></pre></td></tr></table></figure><p>这个查询的结果集每行记录都满足条件<code>s.gender = 'M'</code>和<code>c.id = 1</code>。添加<code>WHERE</code>条件后结果集的数量大大减少了。</p><h3 id="小结-10">小结</h3><p>使用多表查询可以获取M x N行记录；</p><p>多表查询的结果集可能非常巨大，要小心使用。</p><p>连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。</p><p>例如，我们想要选出<code>students</code>表的所有学生信息，可以用一条简单的SELECT语句完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 选出所有学生:</span><br><span class="line">SELECT s.id, s.name, s.class_id, s.gender, s.score FROM students s;</span><br></pre></td></tr></table></figure><p>但是，假设我们希望结果集同时包含所在班级的名称，上面的结果集只有<code>class_id</code>列，缺少对应班级的<code>name</code>列。</p><p>现在问题来了，存放班级名称的<code>name</code>列存储在<code>classes</code>表中，只有根据<code>students</code>表的<code>class_id</code>，找到<code>classes</code>表对应的行，再取出<code>name</code>列，就可以获得班级名称。</p><p>这时，连接查询就派上了用场。我们先使用最常用的一种内连接——INNER JOIN来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 选出所有学生，同时返回班级名称:</span><br><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">INNER JOIN classes c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure><p>注意INNER JOIN查询的写法是：</p><ol><li>先确定主表，仍然使用<code>FROM &lt;表1&gt;</code>的语法；</li><li>再确定需要连接的表，使用<code>INNER JOIN &lt;表2&gt;</code>的语法；</li><li>然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示<code>students</code>表的<code>class_id</code>列与<code>classes</code>表的<code>id</code>列相同的行需要连接；</li><li>可选：加上<code>WHERE</code>子句、<code>ORDER BY</code>等子句。</li></ol><p>使用别名不是必须的，但可以更好地简化查询语句。</p><p>那什么是内连接（INNER JOIN）呢？先别着急，有内连接（INNER JOIN）就有外连接（OUTER JOIN）。我们把内连接查询改成外连接查询，看看效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 使用OUTER JOIN:</span><br><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">RIGHT OUTER JOIN classes c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure><p>执行上述RIGHT OUTER JOIN可以看到，和INNER JOIN相比，RIGHT OUTER JOIN多了一行，多出来的一行是“四班”，但是，学生相关的列如<code>name</code>、<code>gender</code>、<code>score</code>都为<code>NULL</code>。</p><p>这也容易理解，因为根据<code>ON</code>条件<code>s.class_id = c.id</code>，<code>classes</code>表的<code>id=4</code>的行正是“四班”，但是，<code>students</code>表中并不存在<code>class_id=4</code>的行。</p><p>有RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN。它们的区别是：</p><p>INNER JOIN只返回同时存在于两张表的行数据，由于<code>students</code>表的<code>class_id</code>包含1，2，3，<code>classes</code>表的<code>id</code>包含1，2，3，4，所以，INNER JOIN根据条件<code>s.class_id = c.id</code>返回的结果集仅包含1，2，3。</p><p>RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以<code>NULL</code>填充剩下的字段。</p><p>LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加<code>class_id=5</code>，由于classes表并不存在<code>id=5</code>的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的<code>class_name</code>是<code>NULL</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 先增加一列class_id=5:</span><br><span class="line">INSERT INTO students (class_id, name, gender, score) values (5, &#x27;新生&#x27;, &#x27;M&#x27;, 88);</span><br><span class="line">-- 使用LEFT OUTER JOIN:</span><br><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">LEFT OUTER JOIN classes c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure><p>最后，我们使用FULL OUTER JOIN，它会把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 使用FULL OUTER JOIN:</span><br><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">FULL OUTER JOIN classes c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure><p>对于这么多种JOIN查询，到底什么使用应该用哪种呢？其实我们用图来表示结果集就一目了然了。</p><p>假设查询语句是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> tableA ??? <span class="keyword">JOIN</span> tableB <span class="keyword">ON</span> tableA.column1 <span class="operator">=</span> tableB.column2;</span><br></pre></td></tr></table></figure><p>我们把tableA看作左表，把tableB看成右表，那么INNER JOIN是选出两张表都存在的记录：</p><p><img src="https://liaoxuefeng.com/books/sql/query/join/inner-join.jpg" alt="inner-join"></p><p>LEFT OUTER JOIN是选出左表存在的记录：</p><p><img src="https://liaoxuefeng.com/books/sql/query/join/left-outer-join.jpg" alt="left-outer-join"></p><p>RIGHT OUTER JOIN是选出右表存在的记录：</p><p><img src="https://liaoxuefeng.com/books/sql/query/join/right-outer-join.jpg" alt="right-outer-join"></p><p>FULL OUTER JOIN则是选出左右表都存在的记录：</p><p><img src="https://liaoxuefeng.com/books/sql/query/join/full-outer-join.jpg" alt="full-outer-join"></p><h3 id="小结-11">小结</h3><p>JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上；</p><p>INNER JOIN是最常用的一种JOIN查询，它的语法是<code>SELECT ... FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; ON &lt;条件...&gt;</code>；</p><p>JOIN查询仍然可以使用<code>WHERE</code>条件和<code>ORDER BY</code>排序。</p><p>关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve、Update、Delete。其中，对于查询，我们已经详细讲述了<code>SELECT</code>语句的详细用法。</p><p>而对于增、删、改，对应的SQL语句分别是：</p><ul><li>INSERT：插入新记录；</li><li>UPDATE：更新已有记录；</li><li>DELETE：删除已有记录。</li></ul><p>我们将分别讨论这三种修改数据的语句的使用方法。</p><h2 id="插入数据">插入数据</h2><p>当我们需要向数据库表中插入一条新记录时，就必须使用<code>INSERT</code>语句。</p><p><code>INSERT</code>语句的基本语法是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> (字段<span class="number">1</span>, 字段<span class="number">2</span>, ...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...);</span><br></pre></td></tr></table></figure><p>例如，我们向<code>students</code>表插入一条新记录，先列举出需要插入的字段名称，然后在<code>VALUES</code>子句中依次写出对应字段的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 添加一条新记录:</span><br><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES (2, &#x27;大牛&#x27;, &#x27;M&#x27;, 80);</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>注意到我们并没有列出<code>id</code>字段，也没有列出<code>id</code>字段对应的值，这是因为<code>id</code>字段是一个自增主键，它的值可以由数据库自己推算出来。此外，如果一个字段有默认值，那么在<code>INSERT</code>语句中也可以不出现。</p><p>要注意，<code>INSERT</code>字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和<code>INSERT</code>字段顺序一致。也就是说，可以写<code>INSERT INTO students (score, gender, name, class_id) ...</code>，但是对应的<code>VALUES</code>就得变成<code>(80, 'M', '大牛', 2)</code>。</p><p>还可以一次性添加多条记录，只需要在<code>VALUES</code>子句中指定多个记录值，每个记录是由<code>(...)</code>包含的一组值，每组值用逗号<code>,</code>分隔：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 一次性添加多条新记录:</span><br><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES</span><br><span class="line">  (1, &#x27;大宝&#x27;, &#x27;M&#x27;, 87),</span><br><span class="line">  (2, &#x27;二宝&#x27;, &#x27;M&#x27;, 81),</span><br><span class="line">  (3, &#x27;三宝&#x27;, &#x27;M&#x27;, 83);</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><h3 id="小结-12">小结</h3><p>使用<code>INSERT</code>，我们就可以一次向一个表中插入一条或多条记录。</p><hr><hr><p>如果要更新数据库表中的记录，我们就必须使用<code>UPDATE</code>语句。</p><p><code>UPDATE</code>语句的基本语法是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">SET</span> 字段<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>, 字段<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>, ... <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure><p>例如，我们想更新<code>students</code>表<code>id=1</code>的记录的<code>name</code>和<code>score</code>这两个字段，先写出<code>UPDATE students SET name='大牛', score=66</code>，然后在<code>WHERE</code>子句中写出需要更新的行的筛选条件<code>id=1</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 更新id=1的记录:</span><br><span class="line">UPDATE students SET name=&#x27;大牛&#x27;, score=66 WHERE id=1;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students WHERE id=1;</span><br></pre></td></tr></table></figure><p>注意到<code>UPDATE</code>语句的<code>WHERE</code>条件和<code>SELECT</code>语句的<code>WHERE</code>条件其实是一样的，因此完全可以一次更新多条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 更新id=5,6,7的记录:</span><br><span class="line">UPDATE students SET name=&#x27;小牛&#x27;, score=77 WHERE id&gt;=5 AND id&lt;=7;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>在<code>UPDATE</code>语句中，更新字段时可以使用表达式。例如，把所有80分以下的同学的成绩加10分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 更新score&lt;80的记录:</span><br><span class="line">UPDATE students SET score=score+10 WHERE score&lt;80;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>其中，<code>SET score=score+10</code>就是给当前行的<code>score</code>字段的值加上了10。</p><p>如果<code>WHERE</code>条件没有匹配到任何记录，<code>UPDATE</code>语句不会报错，也不会有任何记录被更新。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 更新id=999的记录:</span><br><span class="line">UPDATE students SET score=100 WHERE id=999;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>最后，要特别小心的是，<code>UPDATE</code>语句可以没有<code>WHERE</code>条件，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> students <span class="keyword">SET</span> score<span class="operator">=</span><span class="number">60</span>;</span><br></pre></td></tr></table></figure><p>这时，整个表的所有记录都会被更新。所以，在执行<code>UPDATE</code>语句时要非常小心，最好先用<code>SELECT</code>语句来测试<code>WHERE</code>条件是否筛选出了期望的记录集，然后再用<code>UPDATE</code>更新。</p><h3 id="MySQL-2">MySQL</h3><p>在使用MySQL这类真正的关系数据库时，<code>UPDATE</code>语句会返回更新的行数以及<code>WHERE</code>条件匹配的行数。</p><p>例如，更新<code>id=1</code>的记录时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UPDATE students SET name=&#x27;大宝&#x27; WHERE id=1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure><p>MySQL会返回<code>1</code>，可以从打印的结果<code>Rows matched: 1 Changed: 1</code>看到。</p><p>当更新<code>id=999</code>的记录时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UPDATE students SET name=&#x27;大宝&#x27; WHERE id=999;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Rows matched: 0  Changed: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>MySQL会返回<code>0</code>，可以从打印的结果<code>Rows matched: 0 Changed: 0</code>看到。</p><h3 id="小结-13">小结</h3><p>使用<code>UPDATE</code>，我们就可以一次更新表中的一条或多条记录。</p><h2 id="删除数据">删除数据</h2><p>如果要删除数据库表中的记录，我们可以使用<code>DELETE</code>语句。</p><p><code>DELETE</code>语句的基本语法是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure><p>例如，我们想删除<code>students</code>表中<code>id=1</code>的记录，就需要这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 删除id=1的记录:</span><br><span class="line">DELETE FROM students WHERE id=1;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>注意到<code>DELETE</code>语句的<code>WHERE</code>条件也是用来筛选需要删除的行，因此和<code>UPDATE</code>类似，<code>DELETE</code>语句也可以一次删除多条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 删除id=5,6,7的记录:</span><br><span class="line">DELETE FROM students WHERE id&gt;=5 AND id&lt;=7;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>如果<code>WHERE</code>条件没有匹配到任何记录，<code>DELETE</code>语句不会报错，也不会有任何记录被删除。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 删除id=999的记录:</span><br><span class="line">DELETE FROM students WHERE id=999;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>最后，要特别小心的是，和<code>UPDATE</code>类似，不带<code>WHERE</code>条件的<code>DELETE</code>语句会删除整个表的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure><p>这时，整个表的所有记录都会被删除。所以，在执行<code>DELETE</code>语句时也要非常小心，最好先用<code>SELECT</code>语句来测试<code>WHERE</code>条件是否筛选出了期望的记录集，然后再用<code>DELETE</code>删除。</p><h3 id="MySQL-3">MySQL</h3><p>在使用MySQL这类真正的关系数据库时，<code>DELETE</code>语句也会返回删除的行数以及<code>WHERE</code>条件匹配的行数。</p><p>例如，分别执行删除<code>id=1</code>和<code>id=999</code>的记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELETE FROM students WHERE id=1;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; DELETE FROM students WHERE id=999;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><h3 id="小结-14">小结</h3><p>使用<code>DELETE</code>，我们就可以一次删除表中的一条或多条记录。</p><h2 id="MySQL-4">MySQL</h2><p>安装完MySQL后，除了MySQL Server，即真正的MySQL服务器外，还附赠一个MySQL Client程序。MySQL Client是一个命令行客户端，可以通过MySQL Client登录MySQL，然后，输入SQL语句并执行。</p><p>打开命令提示符，输入命令<code>mysql -u root -p</code>，提示输入口令。填入MySQL的root口令，如果正确，就连上了MySQL Server，同时提示符变为<code>mysql&gt;</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────┐</span><br><span class="line">│Windows PowerShell                                 - □ x │</span><br><span class="line">├─────────────────────────────────────────────────────────┤</span><br><span class="line">│Windows PowerShell                                       │</span><br><span class="line">│Copyright (C) Microsoft Corporation. All rights reserved.│</span><br><span class="line">│                                                         │</span><br><span class="line">│PS C:\Users\chankein&gt; mysql -u root -p                │</span><br><span class="line">│Enter password: ******                                   │</span><br><span class="line">│                                                         │</span><br><span class="line">│Server version: 5.7                                      │</span><br><span class="line">│Copyright (c) 2000, 2018, ...                            │</span><br><span class="line">│Type &#x27;help;&#x27; or &#x27;\h&#x27; for help.                           │</span><br><span class="line">│                                                         │</span><br><span class="line">│mysql&gt;                                                   │</span><br><span class="line">│                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>输入<code>exit</code>断开与MySQL Server的连接并返回到命令提示符。</p><p>提示</p><p>MySQL Client的可执行程序是mysql，MySQL Server的可执行程序是mysqld。</p><p>MySQL Client和MySQL Server的关系如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────┐  SQL   ┌──────────────┐</span><br><span class="line">│ MySQL Client │───────▶│ MySQL Server │</span><br><span class="line">└──────────────┘  TCP   └──────────────┘</span><br></pre></td></tr></table></figure><p>在MySQL Client中输入的SQL语句通过TCP连接发送到MySQL Server。默认端口号是3306，即如果发送到本机MySQL Server，地址就是<code>127.0.0.1:3306</code>。</p><p>也可以只安装MySQL Client，然后连接到远程MySQL Server。假设远程MySQL Server的IP地址是<code>10.0.1.99</code>，那么就使用<code>-h</code>指定IP或域名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 10.0.1.99 -u root -p</span><br></pre></td></tr></table></figure><h3 id="小结-15">小结</h3><p>命令行程序<code>mysql</code>实际上是MySQL客户端，真正的MySQL服务器程序是<code>mysqld</code>，在后台运行。</p><hr><hr><p>要管理MySQL，可以使用可视化图形界面<a href="https://dev.mysql.com/downloads/workbench/">MySQL Workbench</a>。</p><p>MySQL Workbench可以用可视化的方式查询、创建和修改数据库表，但是，归根到底，MySQL Workbench是一个图形客户端，它对MySQL的操作仍然是发送SQL语句并执行。因此，本质上，MySQL Workbench和MySQL Client命令行都是客户端，和MySQL交互，唯一的接口就是SQL。</p><p>因此，MySQL提供了大量的SQL语句用于管理。虽然可以使用MySQL Workbench图形界面来直接管理MySQL，但是，很多时候，通过SSH远程连接时，只能使用SQL命令，所以，了解并掌握常用的SQL管理操作是必须的。</p><h3 id="数据库">数据库</h3><p>在一个运行MySQL的服务器上，实际上可以创建多个数据库（Database）。要列出所有数据库，使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| shici              |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">| school             |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure><p>其中，<code>information_schema</code>、<code>mysql</code>、<code>performance_schema</code>和<code>sys</code>是系统库，不要去改动它们。其他的是用户创建的数据库。</p><p>注意：在MySQL命令行客户端输入SQL后，记得加一个<code>;</code>表示SQL语句结束，再回车就可以执行该SQL语句。虽然有些SQL命令不需要<code>;</code>也能执行，但类似<code>SELECT</code>等语句不加<code>;</code>会让MySQL客户端换行后继续等待输入。如果在图形界面或程序开发中集成SQL则不需要加<code>;</code>。</p><p>要创建一个新数据库，使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE test;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>要删除一个数据库，使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP DATABASE test;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>注意：删除一个数据库将导致该数据库的所有表全部被删除。</p><p>对一个数据库进行操作时，要首先将其切换为当前数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE test;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure><h3 id="表">表</h3><p>列出当前数据库的所有表，使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES;</span><br><span class="line">+---------------------+</span><br><span class="line">| Tables_in_test      |</span><br><span class="line">+---------------------+</span><br><span class="line">| classes             |</span><br><span class="line">| statistics          |</span><br><span class="line">| students            |</span><br><span class="line">| students_of_class1  |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><p>要查看一个表的结构，使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DESC students;</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field    | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id       | bigint(20)   | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| class_id | bigint(20)   | NO   |     | NULL    |                |</span><br><span class="line">| name     | varchar(100) | NO   |     | NULL    |                |</span><br><span class="line">| gender   | varchar(1)   | NO   |     | NULL    |                |</span><br><span class="line">| score    | int(11)      | NO   |     | NULL    |                |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>还可以使用以下命令查看创建表的SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW CREATE TABLE students;</span><br><span class="line">+----------+-------------------------------------------------------+</span><br><span class="line">| students | CREATE TABLE `students` (                             |</span><br><span class="line">|          |   `id` bigint(20) NOT NULL AUTO_INCREMENT,            |</span><br><span class="line">|          |   `class_id` bigint(20) NOT NULL,                     |</span><br><span class="line">|          |   `name` varchar(100) NOT NULL,                       |</span><br><span class="line">|          |   `gender` varchar(1) NOT NULL,                       |</span><br><span class="line">|          |   `score` int(11) NOT NULL,                           |</span><br><span class="line">|          |   PRIMARY KEY (`id`)                                  |</span><br><span class="line">|          | ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 |</span><br><span class="line">+----------+-------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>创建表使用<code>CREATE TABLE</code>语句，而删除表使用<code>DROP TABLE</code>语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP TABLE students;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>修改表就比较复杂。如果要给<code>students</code>表新增一列<code>birth</code>，使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;</span><br></pre></td></tr></table></figure><p>要修改<code>birth</code>列，例如把列名改为<code>birthday</code>，类型改为<code>VARCHAR(20)</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;</span><br></pre></td></tr></table></figure><p>要删除列，使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students DROP COLUMN birthday;</span><br></pre></td></tr></table></figure><h3 id="退出MySQL">退出MySQL</h3><p>使用<code>EXIT</code>命令退出MySQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXIT</span><br><span class="line">Bye</span><br></pre></td></tr></table></figure><p>注意<code>EXIT</code>仅仅断开了客户端和服务器的连接，MySQL服务器仍然继续运行。</p><p>在编写SQL时，灵活运用一些技巧，可以大大简化程序逻辑。</p><h3 id="插入或替换">插入或替换</h3><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用<code>REPLACE</code>语句，这样就不必先查询，再决定是否先删除再插入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLACE <span class="keyword">INTO</span> students (id, class_id, name, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">99</span>);</span><br></pre></td></tr></table></figure><p>若<code>id=1</code>的记录不存在，<code>REPLACE</code>语句将插入新记录，否则，当前<code>id=1</code>的记录将被删除，然后再插入新记录。</p><h3 id="插入或更新">插入或更新</h3><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用<code>INSERT INTO ... ON DUPLICATE KEY UPDATE ...</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> students (id, class_id, name, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">99</span>) <span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> name<span class="operator">=</span><span class="string">&#x27;小明&#x27;</span>, gender<span class="operator">=</span><span class="string">&#x27;F&#x27;</span>, score<span class="operator">=</span><span class="number">99</span>;</span><br></pre></td></tr></table></figure><p>若<code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，当前<code>id=1</code>的记录将被更新，更新的字段由<code>UPDATE</code>指定。</p><h3 id="插入或忽略">插入或忽略</h3><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用<code>INSERT IGNORE INTO ...</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> IGNORE <span class="keyword">INTO</span> students (id, class_id, name, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">99</span>);</span><br></pre></td></tr></table></figure><p>若<code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，不执行任何操作。</p><h3 id="快照">快照</h3><p>如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合<code>CREATE TABLE</code>和<code>SELECT</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 对class_id=1的记录进行快照，并存储为新表students_of_class1:</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> students_of_class1 <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> class_id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>新创建的表结构和<code>SELECT</code>使用的表结构完全一致。</p><h3 id="写入查询结果集">写入查询结果集</h3><p>如果查询结果集需要写入到表中，可以结合<code>INSERT</code>和<code>SELECT</code>，将<code>SELECT</code>语句的结果集直接插入到指定表中。</p><p>例如，创建一个统计成绩的表<code>statistics</code>，记录各班的平均成绩：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> statistics (</span><br><span class="line">    id <span class="type">BIGINT</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">    class_id <span class="type">BIGINT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    average <span class="keyword">DOUBLE</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后，我们就可以用一条语句写入各班的平均成绩：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> statistics (class_id, average) <span class="keyword">SELECT</span> class_id, <span class="built_in">AVG</span>(score) <span class="keyword">FROM</span> students <span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id;</span><br></pre></td></tr></table></figure><p>确保<code>INSERT</code>语句的列和<code>SELECT</code>语句的列能一一对应，就可以在<code>statistics</code>表中直接保存查询的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM statistics;</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">| id | class_id | average      |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">|  1 |        1 |         86.5 |</span><br><span class="line">|  2 |        2 | 73.666666666 |</span><br><span class="line">|  3 |        3 | 88.333333333 |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="强制使用指定索引">强制使用指定索引</h3><p>在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用<code>FORCE INDEX</code>强制查询使用指定的索引。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students FORCE INDEX (idx_class_id) <span class="keyword">WHERE</span> class_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>指定索引的前提是索引<code>idx_class_id</code>必须存在。</p><h2 id="事务">事务</h2><p>在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 从id=1的账户给id=2的账户转账100元</span></span><br><span class="line"><span class="comment">-- 第一步：将id=1的A账户余额减去100</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 第二步：将id=2的B账户余额加上100</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。</p><p>这种把多条语句作为一个整体进行操作的功能，被称为数据库<em>事务</em>。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。</p><p>可见，数据库事务具有ACID这4个特性：</p><ul><li>A：Atomicity，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；</li><li>C：Consistency，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；</li><li>I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；</li><li>D：Durability，持久性，即事务完成后，对数据库数据的修改被持久化存储。</li></ul><p>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为<em>隐式事务</em>。</p><p>要手动把多条SQL语句作为一个事务执行，使用<code>BEGIN</code>开启一个事务，使用<code>COMMIT</code>提交一个事务，这种事务被称为<em>显式事务</em>，例如，把上述的转账操作作为一个显式事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>很显然多条SQL语句要想作为一个事务执行，就必须使用显式事务。</p><p><code>COMMIT</code>是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果<code>COMMIT</code>语句执行失败了，整个事务也会失败。</p><p>有些时候，我们希望主动让事务失败，这时，可以用<code>ROLLBACK</code>回滚事务，整个事务会失败：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><p>数据库事务是由数据库系统保证的，我们只需要根据业务逻辑使用它就可以。</p><h3 id="隔离级别">隔离级别</h3><p>对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。</p><p>SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：</p><table><thead><tr><th>Isolation Level</th><th>脏读（Dirty Read）</th><th>不可重复读（Non Repeatable Read）</th><th>幻读（Phantom Read）</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Read Committed</td><td>-</td><td>Yes</td><td>Yes</td></tr><tr><td>Repeatable Read</td><td>-</td><td>-</td><td>Yes</td></tr><tr><td>Serializable</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p>我们会依次介绍4种隔离级别的数据一致性问题。</p><h3 id="小结-16">小结</h3><p>数据库事务具有ACID特性，用来保证多条SQL的全部执行。</p><h2 id="Read-Uncommitted">Read Uncommitted</h2><p>Read Uncommitted是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。</p><p>我们来看一个例子。</p><p>首先，我们准备好<code>students</code>表的数据，该表仅一行记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p><table><thead><tr><th>时刻</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td><td>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td></tr><tr><td>2</td><td>BEGIN;</td><td>BEGIN;</td></tr><tr><td>3</td><td>UPDATE students SET name = ‘Bob’ WHERE id = 1;</td><td></td></tr><tr><td>4</td><td></td><td>SELECT * FROM students WHERE id = 1;</td></tr><tr><td>5</td><td>ROLLBACK;</td><td></td></tr><tr><td>6</td><td></td><td>SELECT * FROM students WHERE id = 1;</td></tr><tr><td>7</td><td></td><td>COMMIT;</td></tr></tbody></table><p>当事务A执行完第3步时，它更新了<code>id=1</code>的记录，但并未提交，而事务B在第4步读取到的数据就是未提交的数据。</p><p>随后，事务A在第5步进行了回滚，事务B再次读取<code>id=1</code>的记录，发现和上一次读取到的数据不一致，这就是脏读。</p><p>可见，在Read Uncommitted隔离级别下，一个事务可能读取到另一个事务更新但未提交的数据，这个数据有可能是脏数据。</p><h2 id="Read-Committed">Read Committed</h2><p>在Read Committed隔离级别下，一个事务不会读到另一个事务还没有提交的数据，但可能会遇到不可重复读（Non Repeatable Read）的问题。</p><p>不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。</p><p>我们仍然先准备好<code>students</code>表的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p><table><thead><tr><th>时刻</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td><td>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td></tr><tr><td>2</td><td>BEGIN;</td><td>BEGIN;</td></tr><tr><td>3</td><td></td><td>SELECT * FROM students WHERE id = 1; – Alice</td></tr><tr><td>4</td><td>UPDATE students SET name = ‘Bob’ WHERE id = 1;</td><td></td></tr><tr><td>5</td><td>COMMIT;</td><td></td></tr><tr><td>6</td><td></td><td>SELECT * FROM students WHERE id = 1; – Bob</td></tr><tr><td>7</td><td></td><td>COMMIT;</td></tr></tbody></table><p>当事务B第一次执行第3步的查询时，得到的结果是<code>Alice</code>，随后，由于事务A在第4步更新了这条记录并提交，所以，事务B在第6步再次执行同样的查询时，得到的结果就变成了<code>Bob</code>，因此，在Read Committed隔离级别下，事务不可重复读同一条记录，因为很可能读到的结果不一致。</p><h2 id="Repeatable-Read">Repeatable Read</h2><p>在Repeatable Read隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。</p><p>幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。</p><p>我们仍然先准备好<code>students</code>表的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p><table><thead><tr><th>时刻</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td><td>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td></tr><tr><td>2</td><td>BEGIN;</td><td>BEGIN;</td></tr><tr><td>3</td><td></td><td>SELECT * FROM students WHERE id = 99; – empty</td></tr><tr><td>4</td><td>INSERT INTO students (id, name) VALUES (99, ‘Bob’);</td><td></td></tr><tr><td>5</td><td>COMMIT;</td><td></td></tr><tr><td>6</td><td></td><td>SELECT * FROM students WHERE id = 99; – empty</td></tr><tr><td>7</td><td></td><td>UPDATE students SET name = ‘Alice’ WHERE id = 99; – 1 row affected</td></tr><tr><td>8</td><td></td><td>SELECT * FROM students WHERE id = 99; – Alice</td></tr><tr><td>9</td><td></td><td>COMMIT;</td></tr></tbody></table><p>事务B在第3步第一次读取<code>id=99</code>的记录时，读到的记录为空，说明不存在<code>id=99</code>的记录。随后，事务A在第4步插入了一条<code>id=99</code>的记录并提交。事务B在第6步再次读取<code>id=99</code>的记录时，读到的记录仍然为空，但是，事务B在第7步试图更新这条不存在的记录时，竟然成功了，并且，事务B在第8步再次读取<code>id=99</code>的记录时，记录出现了。</p><p>可见，幻读就是没有读到的记录，以为不存在，但其实是可以更新成功的，并且，更新成功后，再次读取，就出现了。</p><hr><hr><p>Serializable是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。</p><p>虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。</p><h3 id="默认隔离级别">默认隔离级别</h3><p>如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read。</p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cheat sheet </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言-线性回归</title>
      <link href="/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
      <url>/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h2 id="R-线性回归">R - 线性回归</h2><p><a href="https://www.runoob.com/r/r-examples.html"><img src="https://www.runoob.com/images/up.gif" alt="R 语言实例"> R 语言实例</a></p><p>在统计学中，线性回归(Linear Regression)是利用称为线性回归方程的最小平方函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。</p><p>简单对来说就是用来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。</p><p>回归分析中，只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为一元线性回归分析。如果回归分析中包括两个或两个以上的自变量，且因变量和自变量之间是线性关系，则称为多元线性回归分析。</p><p>一元线性回归分析法的数学方程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = ax + b</span><br></pre></td></tr></table></figure><ul><li><p><strong>y</strong> 是因变量的值。</p></li><li><p><strong>x</strong> 是自变量的值。</p></li><li><p><strong>a</strong> 与 <strong>b</strong> 为一元线性回归方程的参数。</p></li></ul><p>接下来我们可以创建一个人体身高与体重的预测模型：</p><ul><li>1、收集样本数据：身高与体重。</li><li>2、使用 lm() 函数来创建一个关系模型。</li><li>3、从创建的模型中找到系数，并创建数学方程式。</li><li>4、获取关系模型的概要，了解平均误差即残差（估计值与真实值之差）。</li><li>5、使用 predict() 函数来预测人的体重。</li></ul><h3 id="准备数据">准备数据</h3><p>以下是人的身高与体重数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 身高，单位 cm</span><br><span class="line">151, 174, 138, 186, 128, 136, 179, 163, 152, 131</span><br><span class="line"></span><br><span class="line"># 体重，单位 kg</span><br><span class="line">63, 81, 56, 91, 47, 57, 76, 72, 62, 48</span><br></pre></td></tr></table></figure><h3 id="lm-函数">lm() 函数</h3><p>在 R 中，你可以通过函数 lm() 进行线性回归。</p><p>lm() 函数用于创建自变量与因变量之间的关系模型。</p><p>lm() 函数语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lm(formula,data)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>formula - 一个符号公式，表示 x 和 y 之间的关系。</li><li>data - 应用数据。</li></ul><p>创建关系模型，并获取系数：</p><h2 id="实例">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\# 样本数据  </span><br><span class="line">x &lt;- c(151, 174, 138, 186, 128, 136, 179, 163, 152, 131)  </span><br><span class="line">y &lt;- c(63, 81, 56, 91, 47, 57, 76, 72, 62, 48)</span><br><span class="line"></span><br><span class="line">\# 提交给 lm() 函数  </span><br><span class="line">relation &lt;- lm(y~x)</span><br><span class="line"></span><br><span class="line">print(relation)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Call:</span><br><span class="line">lm(formula = y ~ x)</span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">(Intercept)            x  </span><br><span class="line">    -38.4551       0.6746  </span><br></pre></td></tr></table></figure><p>使用 <strong>summary()</strong> 函数获取关系模型的概要:</p><h2 id="实例-2">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(151, 174, 138, 186, 128, 136, 179, 163, 152, 131)  </span><br><span class="line">y &lt;- c(63, 81, 56, 91, 47, 57, 76, 72, 62, 48)</span><br><span class="line"></span><br><span class="line">\# 提交给 lm() 函数  </span><br><span class="line">relation &lt;- lm(y~x)</span><br><span class="line"></span><br><span class="line">print(summary(relation))</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Call:</span><br><span class="line">lm(formula = y ~ x)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">    Min      1Q     Median      3Q     Max </span><br><span class="line">-6.3002    -1.6629  0.0412    1.8944  3.9775 </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">             Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept) -38.45509    8.04901  -4.778  0.00139 ** </span><br><span class="line">x             0.67461    0.05191  12.997 1.16e-06 ***</span><br><span class="line">---</span><br><span class="line">Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</span><br><span class="line"></span><br><span class="line">Residual standard error: 3.253 on 8 degrees of freedom</span><br><span class="line">Multiple R-squared:  0.9548,    Adjusted R-squared:  0.9491 </span><br><span class="line">F-statistic: 168.9 on 1 and 8 DF,  p-value: 1.164e-06</span><br></pre></td></tr></table></figure><h3 id="predict-函数">predict() 函数</h3><p>predict() 函数用于根据我们建立的模型来预测数值。</p><p>predict() 函数语法格式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predict(object, newdata)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>object - lm() 函数创建的公式。</li><li>newdata - 要预测的值。</li></ul><p>以下实例我们预测一个新的体重值：</p><h2 id="实例-3">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\# 样本数据  </span><br><span class="line">x &lt;- c(151, 174, 138, 186, 128, 136, 179, 163, 152, 131)  </span><br><span class="line">y &lt;- c(63, 81, 56, 91, 47, 57, 76, 72, 62, 48)</span><br><span class="line"></span><br><span class="line">\# 提交给 lm() 函数  </span><br><span class="line">relation &lt;- lm(y~x)</span><br><span class="line"></span><br><span class="line">\# 判断身高为 170cm 的体重  </span><br><span class="line">a &lt;- data.frame(x \= 170)  </span><br><span class="line">result &lt;-  predict(relation,a)  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 </span><br><span class="line">76.22869 </span><br></pre></td></tr></table></figure><p>我们也可以生成一个图表：</p><h2 id="实例-4">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\# 样本数据  </span><br><span class="line">x &lt;- c(151, 174, 138, 186, 128, 136, 179, 163, 152, 131)  </span><br><span class="line">y &lt;- c(63, 81, 56, 91, 47, 57, 76, 72, 62, 48)  </span><br><span class="line">relation &lt;- lm(y~x)</span><br><span class="line"></span><br><span class="line">\# 生成 png 图片  </span><br><span class="line">png(file \= &quot;linearregression.png&quot;)</span><br><span class="line"></span><br><span class="line">\# 生成图表  </span><br><span class="line">plot(y,x,col \= &quot;blue&quot;,main \= &quot;Height &amp; Weight Regression&quot;,  </span><br><span class="line">abline(lm(x~y)),cex \= 1.3,pch \= 16,xlab \= &quot;Weight in Kg&quot;,ylab \= &quot;Height in cm&quot;)</span><br></pre></td></tr></table></figure><p>图表如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/08/linearregression.png" alt=""></p><p><a href="https://www.runoob.com/r/r-examples.html"><img src="https://www.runoob.com/images/up.gif" alt="R 语言实例"> R 语言实例</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> R语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言-绘图</title>
      <link href="/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"/>
      <url>/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="R-绘图-饼图">R 绘图 - 饼图</h2><p>R 语言提供来大量的库来实现绘图功能。</p><p>饼图，或称饼状图，是一个划分为几个扇形的圆形统计图表，用于描述量、频率或百分比之间的相对关系。</p><p>R 语言使用 pie() 函数来实现饼图，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pie(x, labels = names(x), edges = 200, radius = 0.8,</span><br><span class="line">    clockwise = FALSE, init.angle = if(clockwise) 90 else 0,</span><br><span class="line">    density = NULL, angle = 45, col = NULL, border = NULL,</span><br><span class="line">    lty = NULL, main = NULL, …)</span><br></pre></td></tr></table></figure><ul><li>x: 数值向量，表示每个扇形的面积。</li><li>labels: 字符型向量，表示各扇形面积标签。</li><li>edges: 这个参数用处不大，指的是多边形的边数（圆的轮廓类似很多边的多边形）。</li><li>radius: 饼图的半径。</li><li>main: 饼图的标题。</li><li>clockwise: 是一个逻辑值,用来指示饼图各个切片是否按顺时针做出分割。</li><li>angle: 设置底纹的斜率。</li><li>density: 底纹的密度。默认值为 NULL。</li><li>col: 是表示每个扇形的颜色，相当于调色板。</li></ul><p>绘制饼状图要做这些准备：反映数量的向量、各部分的标签、各部分的颜色（可选）。</p><p>接下来我们绘制一个简单的饼图：</p><h2 id="实例">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\# 数据准备  </span><br><span class="line">info = c(1, 2, 4, 8)</span><br><span class="line"></span><br><span class="line">\# 命名  </span><br><span class="line">names = c(&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;, &quot;Weibo&quot;)</span><br><span class="line"></span><br><span class="line">\# 涂色（可选）  </span><br><span class="line">cols = c(&quot;#ED1C24&quot;,&quot;#22B14C&quot;,&quot;#FFC90E&quot;,&quot;#3f48CC&quot;)</span><br><span class="line"></span><br><span class="line">\# 绘图  </span><br><span class="line">pie(info, labels\=names, col\=cols)</span><br></pre></td></tr></table></figure><p>执行绘图程序，会在当前目录下生存一个 PDF 文件（Rplots.pdf）,打开文件可以看到图形效果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/CE239EAD-2217-4623-A99C-6BB2DB7C72D9.jpg" alt=""></p><p>我们也可以使用 png()、jpeg()、bmp() 函数设置输出的文件格式为图片：</p><h2 id="实例-2">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\# 数据准备  </span><br><span class="line">info \= c(1, 2, 4, 8)</span><br><span class="line"></span><br><span class="line">\# 命名  </span><br><span class="line">names \= c(&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;, &quot;Weibo&quot;)</span><br><span class="line"></span><br><span class="line">\# 涂色（可选）  </span><br><span class="line">cols \= c(&quot;#ED1C24&quot;,&quot;#22B14C&quot;,&quot;#FFC90E&quot;,&quot;#3f48CC&quot;)</span><br><span class="line"></span><br><span class="line">\# 设置输出图片  </span><br><span class="line">png(file\=&#x27;runoob-pie.png&#x27;, height\=300, width\=300)  </span><br><span class="line">\# 绘图  </span><br><span class="line">pie(info, labels\=names, col\=cols)</span><br></pre></td></tr></table></figure><p>接下来我们给饼图设置标题，中文字体需要设置字体参数 family=‘GB1’，也可以自己设置字体库，详细参考：<a href="https://www.runoob.com/r/r-charts-cn.html">R 绘图 - 中文支持</a>。</p><h2 id="实例-3">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\# 数据准备  </span><br><span class="line">info = c(1, 2, 4, 8)</span><br><span class="line"></span><br><span class="line">\# 命名  </span><br><span class="line">names = c(&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;, &quot;Weibo&quot;)</span><br><span class="line"></span><br><span class="line">\# 涂色（可选）  </span><br><span class="line">cols = c(&quot;#ED1C24&quot;,&quot;#22B14C&quot;,&quot;#FFC90E&quot;,&quot;#3f48CC&quot;)  </span><br><span class="line">\# 计算百分比  </span><br><span class="line">piepercent = paste(round(100\*info/sum(info)), &quot;%&quot;)  </span><br><span class="line">\# 绘图  </span><br><span class="line">pie(info, labels\=piepercent, main = &quot;网站分析&quot;, col\=cols, family\=&#x27;GB1&#x27;)  </span><br><span class="line">\# 添加颜色样本标注  </span><br><span class="line">legend(&quot;topright&quot;, names, cex\=0.8, fill\=cols)</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/065BA223-69F9-4AF5-A3D4-D92A6A895D89.jpg" alt=""></p><p>如果要绘制 3D 的饼图，可以使用 plotrix 库的 pie3D() 函数，使用前我们需要先安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(&quot;plotrix&quot;, repos = &quot;https://mirrors.ustc.edu.cn/CRAN/&quot;)</span><br></pre></td></tr></table></figure><h2 id="实例-4">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">\# 载入 plotrix  </span><br><span class="line">library(plotrix)  </span><br><span class="line">\# 数据准备  </span><br><span class="line">info \= c(1, 2, 4, 8)</span><br><span class="line"></span><br><span class="line">\# 命名  </span><br><span class="line">names \= c(&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;, &quot;Weibo&quot;)</span><br><span class="line"></span><br><span class="line">\# 涂色（可选）  </span><br><span class="line">cols \= c(&quot;#ED1C24&quot;,&quot;#22B14C&quot;,&quot;#FFC90E&quot;,&quot;#3f48CC&quot;)</span><br><span class="line"></span><br><span class="line">\# 设置文件名，输出为 png  </span><br><span class="line">png(file \= &quot;3d\_pie\_chart.png&quot;)</span><br><span class="line"></span><br><span class="line">\# 绘制 3D 图，family 要设置你系统支持的中文字体库  </span><br><span class="line">pie3D(info,labels \= names,explode \= 0.1, main \= &quot;3D 图&quot;,family \= &quot;STHeitiTC-Light&quot;)</span><br></pre></td></tr></table></figure><p>生成图片如下所示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/3d_pie_chart.png" alt=""></p><h2 id="R-绘图-条形图">R 绘图 - 条形图</h2><p>条形图，也称为柱状图条形图，是一种以长方形的长度为变量的统计图表。</p><p>条形图可以是水平或垂直的，每个长方形可以有不同的颜色。</p><p>R 语言使用 barplot() 函数来创建条形图，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">barplot(H,xlab,ylab,main, names.arg,col,beside)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><strong>H</strong> 向量或矩阵，包含图表用的数字值，每个数值表示矩形条的高度。</li><li><strong>xlab</strong> x 轴标签。</li><li><strong>ylab</strong> y 轴标签。</li><li><strong>main</strong> 图表标题。</li><li><strong>names.arg</strong> 每个矩形条的名称。</li><li><strong>col</strong> 每个矩形条的颜色。</li></ul><p>接下来我们创建一个简单的条形图：</p><h2 id="实例-5">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\# 准备一个向量  </span><br><span class="line">cvd19 \= c(83534,2640626,585493)</span><br><span class="line"></span><br><span class="line">\# 显示条形图  </span><br><span class="line">barplot(cvd19)</span><br></pre></td></tr></table></figure><p>执行绘图程序，会在当前目录下生存一个 PDF 文件（Rplots.pdf）,打开文件可以看到图形效果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-bar-1.png" alt=""></p><p>为了更好地表达信息，我们可以在图表上添加标题、颜色及每个矩形条的名称。</p><p>以下我们创建 2020 年 7 月 1 日中国、美国和印度的新冠疫情确诊人数统计图。</p><p>中文字体需要设置字体参数 family=‘GB1’：</p><h2 id="实例-6">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cvd19 \= c(83534,2640626,585493)</span><br><span class="line"></span><br><span class="line">barplot(cvd19,  </span><br><span class="line">    main\=&quot;新冠疫情条形图&quot;,  </span><br><span class="line">    col\=c(&quot;#ED1C24&quot;,&quot;#22B14C&quot;,&quot;#FFC90E&quot;),  </span><br><span class="line">    names.arg\=c(&quot;中国&quot;,&quot;美国&quot;,&quot;印度&quot;),  </span><br><span class="line">    family\=&#x27;GB1&#x27;  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-bar-2.png" alt=""></p><p>barplot 中的数据既可以是向量，也可以是矩阵，现在我们生成一张新冠疫情 6 月和 7 月对比图。</p><p>首先准备数据：</p><table><thead><tr><th></th><th>中国</th><th>美国</th><th>印度</th></tr></thead><tbody><tr><td>6 月</td><td>83017</td><td>1794546</td><td>190535</td></tr><tr><td>7 月</td><td>83534</td><td>2640626</td><td>585493</td></tr></tbody></table><p>转换成矩阵，生成条形图，按并排格式显示，而且要显示颜色样本。</p><p>这里我们设置了自己的字体库，详细内容可以参考 <a href="https://www.runoob.com/r/r-charts-cn.html">R 绘图 - 中文支持</a></p><h2 id="实例-7">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">library(showtext);  </span><br><span class="line">font\_add(&quot;SyHei&quot;, &quot;SourceHanSansSC-Bold.otf&quot;);  </span><br><span class="line">cvd19 \= matrix(  </span><br><span class="line">  c(83017, 83534, 1794546, 2640626, 190535, 585493),  </span><br><span class="line">  2, 3  </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">\# 设置文件名，输出为 png  </span><br><span class="line">png(file \= &quot;runoob-bar-1.png&quot;)</span><br><span class="line"></span><br><span class="line">#加载字体  </span><br><span class="line">showtext\_begin();</span><br><span class="line"></span><br><span class="line">colnames(cvd19) \= c(&quot;中国&quot;, &quot;美国&quot;, &quot;印度&quot;)  </span><br><span class="line">rownames(cvd19) \= c(&quot;6月&quot;, &quot;7月&quot;)  </span><br><span class="line">barplot(cvd19, main \= &quot;新冠疫情条形图&quot;, beside\=TRUE, legend\=TRUE,  family\=&#x27;SyHei&#x27;)</span><br><span class="line"></span><br><span class="line">\# 去掉字体  </span><br><span class="line">showtext\_end();</span><br></pre></td></tr></table></figure><p>以下代码会在当前程序目录下生存一个 runoob-bar-1.png 文件，如下所示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/runoob-bar-1.png" alt=""></p><p>我们设置的颜色样本将是每各组的颜色样本：</p><h2 id="实例-8">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">library(plotrix)  </span><br><span class="line">library(showtext);  </span><br><span class="line">font\_add(&quot;SyHei&quot;, &quot;SourceHanSansSC-Bold.otf&quot;);  </span><br><span class="line">cvd19 \= matrix(  </span><br><span class="line">  c(83017, 83534, 1794546, 2640626, 190535, 585493),  </span><br><span class="line">  2, 3  </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">\# 设置文件名，输出为 png  </span><br><span class="line">png(file \= &quot;runoob-bar-2.png&quot;)  </span><br><span class="line">#加载字体  </span><br><span class="line">showtext\_begin();  </span><br><span class="line">colnames(cvd19) \= c(&quot;中国&quot;, &quot;美国&quot;, &quot;印度&quot;)  </span><br><span class="line">rownames(cvd19) \= c(&quot;6月&quot;, &quot;7月&quot;)</span><br><span class="line"></span><br><span class="line">barplot(cvd19, main \= &quot;新冠疫情条形图&quot;, beside\=TRUE, legend\=TRUE,col\=c(&quot;blue&quot;,&quot;green&quot;),  family\=&#x27;SyHei&#x27;)  </span><br><span class="line">\# 去掉字体  </span><br><span class="line">showtext\_end();</span><br></pre></td></tr></table></figure><p>以下代码会在当前程序目录下生存一个 runoob-bar-2.png 文件，如下所示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/runoob-bar-2.png" alt=""></p><h3 id="beside-参数">beside 参数</h3><p>beside 设置矩形条堆叠的方式，默认为 FALSE：</p><ul><li><p><strong>beside=FALSE</strong> 时，条形图的高度是矩阵的数值，矩形条是水平堆叠的。</p></li><li><p><strong>beside=TRUE</strong> 时，条形图的高度是矩阵的数值，矩形条是并列的。</p></li></ul><h2 id="实例-9">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">library(showtext);  </span><br><span class="line">font\_add(&quot;SyHei&quot;, &quot;SourceHanSansSC-Bold.otf&quot;);  </span><br><span class="line">cvd19 \= matrix(  </span><br><span class="line">  c(83017, 83534, 1794546, 2640626, 190535, 585493),  </span><br><span class="line">  2, 3  </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">\# 设置文件名，输出为 png  </span><br><span class="line">png(file \= &quot;runoob-bar-3.png&quot;)  </span><br><span class="line">#加载字体  </span><br><span class="line">showtext\_begin();  </span><br><span class="line">colnames(cvd19) \= c(&quot;中国&quot;, &quot;美国&quot;, &quot;印度&quot;)  </span><br><span class="line">rownames(cvd19) \= c(&quot;6月&quot;, &quot;7月&quot;)</span><br><span class="line"></span><br><span class="line">barplot(cvd19, main \= &quot;新冠疫情条形图&quot;, beside\=FALSE, legend\=TRUE,col\=c(&quot;blue&quot;,&quot;green&quot;),  family\=&#x27;SyHei&#x27;)  </span><br><span class="line">\# 去掉字体  </span><br><span class="line">showtext\_end();</span><br></pre></td></tr></table></figure><p>以下代码会在当前程序目录下生存一个 runoob-bar-3.png 文件，如下所示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/runoob-bar-3.png" alt=""></p><h2 id="R-绘图-函数曲线图">R 绘图 - 函数曲线图</h2><p>函数曲线图是研究函数的重要工具。</p><p>R 中 curve() 函数可以绘制函数的图像，代码格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curve(expr, from = NULL, to = NULL, n = 101, add = FALSE,</span><br><span class="line">      type = &quot;l&quot;, xname = &quot;x&quot;, xlab = xname, ylab = NULL,</span><br><span class="line">      log = NULL, xlim = NULL, …)</span><br><span class="line"></span><br><span class="line"># S3 函数的方法</span><br><span class="line">plot(x, y = 0, to = 1, from = y, xlim = NULL, ylab = NULL, …)</span><br></pre></td></tr></table></figure><p>**注：**R 语言的类有 S3 类和 S4 类，S3 类用的比较广，创建简单粗糙但是灵活，而 S4 类比较精细。</p><p>参数：</p><ul><li>expr：函数表达式</li><li>from 和 to：绘图的起止范围</li><li>n：一个整数值，表示 x 取值的数量</li><li>add：是一个逻辑值，当为 TRUE 时，表示将绘图添加到已存在的绘图中。</li><li>type：绘图的类型，p 为点、l 为直线， o 同时绘制点和线，且线穿过点。</li><li>xname：用于 x 轴变量的名称。</li><li>xlim 和 ylim 表示x轴和y轴的范围。</li><li>xlab，ylab：x 轴和 y 轴的标签名称。</li></ul><p>plot 函数中，x 和 y 分别表示所绘图形的横坐标和纵坐标。</p><p>以下我们绘制一个 sin(x) 函数的图表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curve(sin(x), -2 * pi, 2 * pi)</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-line-1.png" alt=""></p><p>注意：任何计算机绘图工具绘制的都是模式图，它并不能保证与真的函数图像一模一样，它只是每隔一段距离取一个点，然后计算这个点的&quot;高度&quot;并绘制出来，为了保证曲线连续性，相邻两个点之间会有直线连接，所以在某些情况下例如 tan(x) 可能会出现错误：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-line-2.png" alt=""></p><p>在每一个 (2n+1)Pi / 2 的位置都会出现断点，但是 R 的图像将它们连接了，希望大家理解这一点。</p><p>当然，不是所有的函数都像 sin 一样支持向量处理，我们也可以手动生成一个数字序列然后用 plot 函数生成函数图像。假设函数 f 仅支持单个数值作为参数：</p><h2 id="实例-10">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">\# 定义函数 f  </span><br><span class="line">f \= function (x) &#123;  </span><br><span class="line">    if (x \&gt;= 0) &#123;  </span><br><span class="line">        x  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        x ^ 2  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\# 生成自变量序列  </span><br><span class="line">x \= seq(\-2, 2, length\=100)</span><br><span class="line"></span><br><span class="line">\# 生成因变量序列  </span><br><span class="line">y \= rep(0, length(x))  </span><br><span class="line">j \= 1  </span><br><span class="line">for (i in x) &#123;  </span><br><span class="line">    y\[j\] \= f(i)  </span><br><span class="line">    j \= j + 1  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\# 绘制图像  </span><br><span class="line">plot(x, y, type\=&#x27;l&#x27;)</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-line-3.png" alt=""></p><p>接下来我们使用 plot() 函数对向量数据进行绘图：</p><h2 id="实例-11">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\# 向量数据  </span><br><span class="line">v &lt;- c(7,12,28,3,41)</span><br><span class="line"></span><br><span class="line">\# 生成图片  </span><br><span class="line">png(file \= &quot;line\_chart\_label\_colored.jpg&quot;)</span><br><span class="line"></span><br><span class="line">\# 绘图、线图颜色为红色，main 参数用于设置标题  </span><br><span class="line">plot(v,type \= &quot;o&quot;, col \= &quot;red&quot;, xlab \= &quot;Month&quot;, ylab \= &quot;Rain fall&quot;,  </span><br><span class="line">   main \= &quot;Rain fall chart&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/line_chart_label_colored.png" alt=""></p><h2 id="R-绘图-散点图">R 绘图 - 散点图</h2><p>散点图是将所有的数据以点的形式展现在直角坐标系上，以显示变量之间的相互影响程度，点的位置由变量的数值决定，每个点对应一个 X 和 Y 轴点坐标。</p><p>散点图可以使用 plot() 函数来绘制，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot(x, y, type=&quot;p&quot;, main, xlab, ylab, xlim, ylim, axes)</span><br></pre></td></tr></table></figure><ul><li><p><strong>x</strong> 横坐标 x 轴的数据集合</p></li><li><p><strong>y</strong> 纵坐标 y 轴的数据集合</p></li><li><p>type：绘图的类型，p 为点、l 为直线， o 同时绘制点和线，且线穿过点。</p></li><li><p><strong>main</strong> 图表标题。</p></li><li><p><strong>xlab、ylab</strong> x 轴和 y 轴的标签名称。</p></li><li><p><strong>xlim、ylim</strong> x 轴和 y 轴的范围。</p></li><li><p><strong>axes</strong> 布尔值，是否绘制两个 x 轴。</p></li></ul><p>type 参数可选择值：</p><ul><li>p：点图</li><li>l：线图</li><li>b：同时绘制点和线</li><li>c：仅绘制参数 b 所示的线</li><li>o：同时绘制点和线，且线穿过点</li><li>h：绘制出点到横坐标轴的垂直线</li><li>s：阶梯图，先横后纵</li><li>S：阶梯图，先纵后竖</li><li>n： 空图</li></ul><p>创建一个简单的线图：</p><h2 id="实例-12">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x&lt;-c(10,40)  </span><br><span class="line">y&lt;-c(20,60)  </span><br><span class="line">\# 生成 png 图片  </span><br><span class="line">png(file \= &quot;runnob-test-plot2.png&quot;)</span><br><span class="line"></span><br><span class="line">plot(x, y, &quot;l&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/runnob-test-plot2.png" alt=""></p><p>创建一个简单的线图，type 使用 o 参数，同时绘制点和线，且线穿过点：</p><h2 id="实例-13">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x&lt;-c(10,40)  </span><br><span class="line">y&lt;-c(20,60)  </span><br><span class="line">\# 生成 png 图片  </span><br><span class="line">png(file \= &quot;runnob-test-plot.png&quot;)</span><br><span class="line"></span><br><span class="line">plot(x, y, &quot;o&quot;)</span><br></pre></td></tr></table></figure><p>接下来我们使用 R 语言的内置数据集 mtcars 来进行测试。</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/runnob-test-plot.png" alt=""></p><p>我们使用 mtcars 数据集的 wt 和 mpg 列：</p><h2 id="实例-14">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input &lt;- mtcars\[,c(&#x27;wt&#x27;,&#x27;mpg&#x27;)\]  </span><br><span class="line">print(head(input))  </span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wt  mpg</span><br><span class="line">Mazda RX4         2.620 21.0</span><br><span class="line">Mazda RX4 Wag     2.875 21.0</span><br><span class="line">Datsun 710        2.320 22.8</span><br><span class="line">Hornet 4 Drive    3.215 21.4</span><br><span class="line">Hornet Sportabout 3.440 18.7</span><br><span class="line">Valiant           3.460 18.1</span><br></pre></td></tr></table></figure><p>接着我们使用以上数据生存一个散点图</p><p>：</p><h2 id="实例-15">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\# 数据  </span><br><span class="line">input &lt;- mtcars\[,c(&#x27;wt&#x27;,&#x27;mpg&#x27;)\]</span><br><span class="line"></span><br><span class="line">\# 生成 png 图片  </span><br><span class="line">png(file \= &quot;scatterplot.png&quot;)</span><br><span class="line"></span><br><span class="line">\# 设置坐标 x 轴范围 2.5 到 5, y 轴范围 15 到 30.  </span><br><span class="line">plot(x \= input$wt,y \= input$mpg,  </span><br><span class="line">   xlab \= &quot;Weight&quot;,  </span><br><span class="line">   ylab \= &quot;Milage&quot;,  </span><br><span class="line">   xlim \= c(2.5,5),  </span><br><span class="line">   ylim \= c(15,30),                </span><br><span class="line">   main \= &quot;Weight vs Milage&quot;  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/scatterplot.png" alt=""></p><h3 id="散点图矩阵">散点图矩阵</h3><p>散点图矩阵是借助两变量散点图的作图方法，它可以看作是一个大的图形方阵，其每一个非主对角元素的位置上是对应行的变量与对应列的变量的散点图。而主对角元素位置上是各变量名，这样，借助散点图矩阵可以清晰地看到所研究多个变量两两之间的相关关系。</p><p>散点图矩阵就是把数据集中的每个数值变量两两绘制散点图。</p><p>R 语言使用以下函数创建散点图矩阵：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pairs(formula, data)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><p><strong>formula</strong> 变量系列</p></li><li><p><strong>data</strong> 变量的数据集</p></li></ul><h2 id="实例-16">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\# 输出图片  </span><br><span class="line">png(file \= &quot;scatterplot\_matrices.png&quot;)</span><br><span class="line"></span><br><span class="line">\# 4 个变量绘制矩阵，12 个图</span><br><span class="line"></span><br><span class="line">pairs(~wt+mpg+disp+cyl,data \= mtcars, main \= &quot;Scatterplot Matrix&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/scatterplot_matrices.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> R语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言-读取数据</title>
      <link href="/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
      <url>/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="R-CSV-文件">R CSV 文件</h2><p>R 作为统计学专业工具，如果只能人工的导入和导出数据将使其功能变得没有意义，所以 R 支持批量的从主流的表格存储格式文件（例如 CSV、Excel、XML 等）中获取数据。</p><h3 id="CSV-表格交互">CSV 表格交互</h3><p>CSV（Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符也可以不是逗号） 是一种非常流行的表格存储文件格式，这种格式适合储存中型或小型数据规模的数据。</p><p>由于大多数软件支持这个文件格式，所以常用于数据的储存与交互。</p><p>CSV 本质是文本，它的文件格式极度简单：数据一行一行的用文本保存起来而已，每条记录被分隔符分隔为字段，每条记录都有同样的字段序列。</p><p>以下是一个简单的 sites.csv 文件（存储在测试程序的相同目录下）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id,name,url,likes</span><br><span class="line">1,Google,www.google.com,111</span><br><span class="line">2,Runoob,www.runoob.com,222</span><br><span class="line">3,Taobao,www.taobao.com,333</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>CSV 用逗号来分割列，如果数据中含有逗号，就要用双引号将整个数据块包括起来。</p><p>**注意：**包含非英文字符的文本要注意保存的编码，由于很多计算机普遍使用 UTF-8 编码，所以我是用 UTF-8 进行保存的。</p><p><strong>注意：</strong> CSV 文件最后一行需要保留一个空行，不然执行程序会有警告信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Warning message:</span><br><span class="line">In read.table(file = file, header = header, sep = sep, quote = quote,  :</span><br><span class="line">  incomplete final line found by readTableHeader on &#x27;sites.csv&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/057FE509-4EE4-4A74-9F7D-786AC2C5282E.jpg" alt=""></p><h3 id="读取-CSV-文件">读取 CSV 文件</h3><p>接下来我们就可以使用 read.csv() 函数来读取 CSV 文件的数据：</p><h2 id="实例">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data &lt;- read.csv(&quot;sites.csv&quot;, encoding\=&quot;UTF-8&quot;)  </span><br><span class="line">print(data)  </span><br></pre></td></tr></table></figure><p>如果不设置 encoding 属性，read.csv 函数将默认以操作系统默认的文字编码进行读取，如果你使用的是 Windows 中文版系统且没有设置过系统的默认编码，那系统的默认编码应该是 GBK。所以大家请尽可能地统一文字编码以防出错。</p><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  id   name            url likes</span><br><span class="line">1  1 Google www.google.com   111</span><br><span class="line">2  2 Runoob www.runoob.com   222</span><br><span class="line">3  3 Taobao www.taobao.com   333</span><br></pre></td></tr></table></figure><p>read.csv() 函数返回的是数据框，我们可以很方便的对数据进行统计处理，以下实例我们查看行数和列数：</p><h2 id="实例-2">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data &lt;- read.csv(&quot;sites.csv&quot;, encoding\=&quot;UTF-8&quot;)</span><br><span class="line"></span><br><span class="line">print(is.data.frame(data))  \# 查看是否是数据框  </span><br><span class="line">print(ncol(data))  \# 列数  </span><br><span class="line">print(nrow(data))  \# 行数</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1] TRUE</span><br><span class="line">[1] 4</span><br><span class="line">[1] 3</span><br></pre></td></tr></table></figure><p>以下统计数据框中 likes 字段最大对数据：</p><h2 id="实例-3">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data &lt;- read.csv(&quot;sites.csv&quot;, encoding\=&quot;UTF-8&quot;)</span><br><span class="line"></span><br><span class="line">\# likes 最大的数据  </span><br><span class="line">like &lt;- max(data$likes)  </span><br><span class="line">print(like)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] 333</span><br></pre></td></tr></table></figure><p>我们也可以指定查找条件，类似 SQL where 子句一样查询数据，需要用到到函数是 <strong>subset()</strong>。</p><p>以下实例查找 likes 为 222 到数据：</p><h2 id="实例-4">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data &lt;- read.csv(&quot;sites.csv&quot;, encoding\=&quot;UTF-8&quot;)</span><br><span class="line"></span><br><span class="line">\# likes 为 222 的数据  </span><br><span class="line">retval &lt;- subset(data, likes \== 222)  </span><br><span class="line">print(retval)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  id   name            url likes</span><br><span class="line">2  2 Runoob www.runoob.com   222</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：条件语句等于使用 ==。</p><p>多个条件使用 &amp; 分隔符，以下实例查找 likes 大于 1 name 为 Runoob 的数据：</p><h2 id="实例-5">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data &lt;- read.csv(&quot;sites.csv&quot;, encoding\=&quot;UTF-8&quot;)</span><br><span class="line"></span><br><span class="line">\# likes 大于 1 name 为 Runoob 的数据  </span><br><span class="line">retval &lt;- subset(data, likes \&gt; 1 &amp; name\==&quot;Runoob&quot;)  </span><br><span class="line">print(retval)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  id   name            url likes</span><br><span class="line">2  2 Runoob www.runoob.com   222</span><br></pre></td></tr></table></figure><h3 id="保存为-CSV-文件">保存为 CSV 文件</h3><p>R 语言可以使用 <strong>write.csv()</strong> 函数将数据保存为 CSV 文件。</p><p>接着以上实例，我们将 likes 为 222 的数据 保存到 runoob.csv 文件：</p><h2 id="实例-6">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data &lt;- read.csv(&quot;sites.csv&quot;, encoding\=&quot;UTF-8&quot;)</span><br><span class="line"></span><br><span class="line">\# likes 为 222 的数据  </span><br><span class="line">retval &lt;- subset(data, likes \== 222)</span><br><span class="line"></span><br><span class="line">\# 写入新的文件  </span><br><span class="line">write.csv(retval,&quot;runoob.csv&quot;)  </span><br><span class="line">newdata &lt;- read.csv(&quot;runoob.csv&quot;)  </span><br><span class="line">print(newdata)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> X id   name            url likes</span><br><span class="line">1 2  2 Runoob www.runoob.com   222</span><br></pre></td></tr></table></figure><p>X 来自数据集 newper，可以通过参数 row.names = FALSE 来删除它：</p><h2 id="实例-7">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data &lt;- read.csv(&quot;sites.csv&quot;, encoding\=&quot;UTF-8&quot;)</span><br><span class="line"></span><br><span class="line">\# likes 为 222 的数据  </span><br><span class="line">retval &lt;- subset(data, likes \== 222)</span><br><span class="line"></span><br><span class="line">\# 写入新的文件  </span><br><span class="line">write.csv(retval,&quot;runoob.csv&quot;, row.names \= FALSE)  </span><br><span class="line">newdata &lt;- read.csv(&quot;runoob.csv&quot;)  </span><br><span class="line">print(newdata)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  id   name            url likes</span><br><span class="line">1  2 Runoob www.runoob.com   222</span><br></pre></td></tr></table></figure><p>执行完后，我们就可以看到 runoob.csv 文件生存：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-csv-1.jpeg" alt=""></p><h2 id="R-Excel-文件">R Excel 文件</h2><p>Excel 格式的文件主要是 xls 或 xlsx，这两种文件可以在 R 语言中导入 xlsx 库来实现直接的读取。</p><p>R 语言读写 Excel 文件需要安装扩展包，我们可以在 R 到控制台输入以下命令来安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(&quot;xlsx&quot;, repos = &quot;https://mirrors.ustc.edu.cn/CRAN/&quot;)</span><br></pre></td></tr></table></figure><p>安装过程如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/4C19EC49-38CA-4C21-9A11-B15995728BCD.jpg" alt=""></p><p>事实上，几乎所有的 Excel 软件与大多数表格软件一样支持 CSV 格式的数据，所以完全可以通过 CSV 与 R 交互，没必要再使用 Excel。</p><p>查看 xlsx 是否安装成功：</p><h2 id="实例-8">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\# 验证包是否安装  </span><br><span class="line">any(grepl(&quot;xlsx&quot;,installed.packages()))  </span><br><span class="line">\# 载入包  </span><br><span class="line">library(&quot;xlsx&quot;)  </span><br><span class="line">library(&quot;xlsx&quot;)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1] TRUE</span><br><span class="line">Loading required package: rJava</span><br><span class="line">Loading required package: methods</span><br><span class="line">Loading required package: xlsxjars</span><br></pre></td></tr></table></figure><p>Excel 文件数据：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/55596D4D-4122-4605-B40E-1826D638A572.jpg" alt=""></p><p>点击链接下载 Excel 测试数据：<a href="https://static.jyshare.com/download/sites.xlsx">https://static.jyshare.com/download/sites.xlsx</a></p><p>接下来，我们可以使用 read.xlsx() 函数来读取 Excel 数据：</p><h2 id="实例-9">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\# 读取 sites.xlsx 第一个工作表数据  </span><br><span class="line">data &lt;- read.xlsx(&quot;sites.xlsx&quot;, sheetIndex \= 1)  </span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure><h2 id="R-XML-文件">R XML 文件</h2><p>XML 指的是可扩展标记语言（eXtensible Markup Language），XML 被设计用来传输和存储数据。</p><p>如果你对 XML 还不了解，可以先查阅：<a href="https://www.runoob.com/xml/xml-tutorial.html">XML 教程</a></p><p>R 语言读写 XML 文件需要安装扩展包，我们可以在 R 到控制台输入以下命令来安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(&quot;XML&quot;, repos = &quot;https://mirrors.ustc.edu.cn/CRAN/&quot;)</span><br></pre></td></tr></table></figure><p>查看是否安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; any(grepl(&quot;XML&quot;,installed.packages()))</span><br><span class="line">[1] TRUE</span><br></pre></td></tr></table></figure><p>创建 sites.xml 文件，xml 文件与测试脚本同一目录下，代码如下：</p><h2 id="实例-10">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;sites\&gt; &lt;site\&gt; &lt;id\&gt;1&lt;/id\&gt; &lt;name\&gt;Google&lt;/name\&gt; &lt;url\&gt;www.google.com&lt;/url\&gt; &lt;likes\&gt;111&lt;/likes\&gt; &lt;/site\&gt; &lt;site\&gt; &lt;id\&gt;2&lt;/id\&gt; &lt;name\&gt;Runoob&lt;/name\&gt; &lt;url\&gt;www.runoob.com&lt;/url\&gt; &lt;likes\&gt;222&lt;/likes\&gt; &lt;/site\&gt; &lt;site\&gt; &lt;id\&gt;3&lt;/id\&gt; &lt;name\&gt;Taobao&lt;/name\&gt; &lt;url\&gt;www.taobao.com&lt;/url\&gt; &lt;likes\&gt;333&lt;/likes\&gt; &lt;/site\&gt; &lt;/sites\&gt;</span><br></pre></td></tr></table></figure><p>接下来我们可以使用 XML 包来载入 xml 文件的数据：</p><h2 id="实例-11">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\# 载入 XML 包  </span><br><span class="line">library(&quot;XML&quot;)</span><br><span class="line"></span><br><span class="line">\# 设置文件名  </span><br><span class="line">result &lt;- xmlParse(file \= &quot;sites.xml&quot;)</span><br><span class="line"></span><br><span class="line">\# 输出结果  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>统计 xml 数据量：</p><h2 id="实例-12">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\# 载入 XML 包  </span><br><span class="line">library(&quot;XML&quot;)</span><br><span class="line"></span><br><span class="line">\# 设置文件名  </span><br><span class="line">result &lt;- xmlParse(file \= &quot;sites.xml&quot;)</span><br><span class="line"></span><br><span class="line">\# 提取根节点  </span><br><span class="line">rootnode &lt;- xmlRoot(result)</span><br><span class="line"></span><br><span class="line">\# 统计数据量  </span><br><span class="line">rootsize &lt;- xmlSize(rootnode)</span><br><span class="line"></span><br><span class="line">\# 输出结果  </span><br><span class="line">print(rootsize)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] 3</span><br></pre></td></tr></table></figure><p>查看节点数据，某一行使用 [ ], 指定的行和列使用 [[ ]]:</p><h2 id="实例-13">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">\# 载入 XML 包  </span><br><span class="line">library(&quot;XML&quot;)</span><br><span class="line"></span><br><span class="line">\# 设置文件名  </span><br><span class="line">result &lt;- xmlParse(file \= &quot;sites.xml&quot;)</span><br><span class="line"></span><br><span class="line">\# 提取根节点  </span><br><span class="line">rootnode &lt;- xmlRoot(result)</span><br><span class="line"></span><br><span class="line">\# 查看第 2 个节点数据  </span><br><span class="line">print(rootnode\[2\])</span><br><span class="line"></span><br><span class="line">\# 查看第 2 个节点的第  1 个数据  </span><br><span class="line">print(rootnode\[\[2\]\]\[\[1\]\])</span><br><span class="line"></span><br><span class="line">\# 查看第 2 个节点的第 3 个数据</span><br><span class="line"></span><br><span class="line">print(rootnode\[\[2\]\]\[\[3\]\])</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$site</span><br><span class="line">&lt;site&gt;</span><br><span class="line">  &lt;id&gt;2&lt;/id&gt;</span><br><span class="line">  &lt;name&gt;Runoob&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;www.runoob.com&lt;/url&gt;</span><br><span class="line">  &lt;likes&gt;222&lt;/likes&gt;</span><br><span class="line">&lt;/site&gt; </span><br><span class="line"></span><br><span class="line">attr(,&quot;class&quot;)</span><br><span class="line">[1] &quot;XMLInternalNodeList&quot; &quot;XMLNodeList&quot;        </span><br><span class="line">&lt;id&gt;2&lt;/id&gt; </span><br><span class="line">&lt;url&gt;www.runoob.com&lt;/url&gt; </span><br></pre></td></tr></table></figure><h3 id="XML-转为数据列表">XML 转为数据列表</h3><p>以上代码对输出都是 xml 格式，我们使用 xmlToList() 函数可以将文件对数据转为列表格式，更方便读取：</p><h2 id="实例-14">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\# 载入 XML 包  </span><br><span class="line">library(&quot;XML&quot;)</span><br><span class="line"></span><br><span class="line">\# 设置文件名  </span><br><span class="line">result &lt;- xmlParse(file \= &quot;sites.xml&quot;)</span><br><span class="line"></span><br><span class="line">\# 转为列表  </span><br><span class="line">xml\_data &lt;- xmlToList(result)</span><br><span class="line"></span><br><span class="line">print(xml\_data)  </span><br><span class="line">print(&quot;============================&quot;)</span><br><span class="line"></span><br><span class="line">\# 输出第一行第二列的数据  </span><br><span class="line">print(xml\_data\[\[1\]\]\[\[2\]\])</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">$site</span><br><span class="line">$site$id</span><br><span class="line">[1] &quot;1&quot;</span><br><span class="line"></span><br><span class="line">$site$name</span><br><span class="line">[1] &quot;Google&quot;</span><br><span class="line"></span><br><span class="line">$site$url</span><br><span class="line">[1] &quot;www.google.com&quot;</span><br><span class="line"></span><br><span class="line">$site$likes</span><br><span class="line">[1] &quot;111&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$site</span><br><span class="line">$site$id</span><br><span class="line">[1] &quot;2&quot;</span><br><span class="line"></span><br><span class="line">$site$name</span><br><span class="line">[1] &quot;Runoob&quot;</span><br><span class="line"></span><br><span class="line">$site$url</span><br><span class="line">[1] &quot;www.runoob.com&quot;</span><br><span class="line"></span><br><span class="line">$site$likes</span><br><span class="line">[1] &quot;222&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$site</span><br><span class="line">$site$id</span><br><span class="line">[1] &quot;3&quot;</span><br><span class="line"></span><br><span class="line">$site$name</span><br><span class="line">[1] &quot;Taobao&quot;</span><br><span class="line"></span><br><span class="line">$site$url</span><br><span class="line">[1] &quot;www.taobao.com&quot;</span><br><span class="line"></span><br><span class="line">$site$likes</span><br><span class="line">[1] &quot;333&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[1] &quot;============================&quot;</span><br><span class="line">[1] &quot;Google&quot;</span><br></pre></td></tr></table></figure><h3 id="XML-转为数据框">XML 转为数据框</h3><p>XML 文件数据可以转为数据框类型，这样我们就更方便对数据进行操作：</p><h2 id="实例-15">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\# 载入 XML 包  </span><br><span class="line">library(&quot;XML&quot;)</span><br><span class="line"></span><br><span class="line">\# xml 文件数据转为数据框  </span><br><span class="line">xmldataframe &lt;- xmlToDataFrame(&quot;sites.xml&quot;)  </span><br><span class="line">print(xmldataframe)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  id   name            url likes</span><br><span class="line">1  1 Google www.google.com   111</span><br><span class="line">2  2 Runoob www.runoob.com   222</span><br><span class="line">3  3 Taobao www.taobao.com   333</span><br></pre></td></tr></table></figure><h2 id="R-JSON-文件">R JSON 文件</h2><p>JSON: <strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation(JavaScript 对象表示法)。</p><p>JSON 是存储和交换文本信息的语法。</p><p>JSON 类似 XML，但比 XML 更小、更快，更易解析。</p><p>如果你对 JSON 还不了解，可以先查阅：<a href="https://www.runoob.com/json/json-tutorial.html">JSON 教程</a></p><p>R 语言读写 JSON 文件需要安装扩展包，我们可以在 R 到控制台输入以下命令来安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(&quot;rjson&quot;, repos = &quot;https://mirrors.ustc.edu.cn/CRAN/&quot;)</span><br></pre></td></tr></table></figure><p>查看是否安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; any(grepl(&quot;rjson&quot;,installed.packages()))</span><br><span class="line">[1] TRUE</span><br></pre></td></tr></table></figure><p>创建 sites.json 文件，json 文件与测试脚本同一目录下，代码如下：</p><h2 id="实例-16">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;id&quot;:\[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;\], &quot;name&quot;:\[&quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;\], &quot;url&quot;:\[&quot;www.google.com&quot;,&quot;www.runoob.com&quot;,&quot;www.taobao.com&quot;\], &quot;likes&quot;:\[ 111,222,333\] &#125;</span><br></pre></td></tr></table></figure><p>接下来我们可以使用 rjson 包来载入 json 文件的数据。</p><p>查看数据，某一行使用 [ ], 指定的行和列使用 [[ ]]:</p><h2 id="实例-17">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">\# 载入 rjson 包  </span><br><span class="line">library(&quot;rjson&quot;)</span><br><span class="line"></span><br><span class="line">\# 获取 json 数据  </span><br><span class="line">result &lt;- fromJSON(file \= &quot;sites.json&quot;)</span><br><span class="line"></span><br><span class="line">\# 输出结果  </span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">print(&quot;===============&quot;)</span><br><span class="line"></span><br><span class="line">\# 输出第 1 列的结果  </span><br><span class="line">print(result\[1\])</span><br><span class="line"></span><br><span class="line">print(&quot;===============&quot;)  </span><br><span class="line">\# 输出第 2 行第 2 列的结果  </span><br><span class="line">print(result\[\[2\]\]\[\[2\]\])</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$id</span><br><span class="line">[1] &quot;1&quot; &quot;2&quot; &quot;3&quot;</span><br><span class="line"></span><br><span class="line">$name</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot; &quot;Taobao&quot;</span><br><span class="line"></span><br><span class="line">$url</span><br><span class="line">[1] &quot;www.google.com&quot; &quot;www.runoob.com&quot; &quot;www.taobao.com&quot;</span><br><span class="line"></span><br><span class="line">$likes</span><br><span class="line">[1] 111 222 333</span><br><span class="line"></span><br><span class="line">[1] &quot;===============&quot;</span><br><span class="line">$id</span><br><span class="line">[1] &quot;1&quot; &quot;2&quot; &quot;3&quot;</span><br><span class="line"></span><br><span class="line">[1] &quot;===============&quot;</span><br><span class="line">[1] &quot;Runoob&quot;</span><br></pre></td></tr></table></figure><p>我们也可以使用 <strong>as.data.frame()</strong> 函数将 json 文件数据可以转为数据框类型，这样我们就更方便对数据进行操作：</p><h2 id="实例-18">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\# 载入 rjson 包  </span><br><span class="line">library(&quot;rjson&quot;)</span><br><span class="line"></span><br><span class="line">\# 获取 json 数据  </span><br><span class="line">result &lt;- fromJSON(file \= &quot;sites.json&quot;)</span><br><span class="line"></span><br><span class="line">\# 转为数据框  </span><br><span class="line">json\_data\_frame &lt;- as.data.frame(result)</span><br><span class="line"></span><br><span class="line">print(json\_data\_frame)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  id   name            url likes</span><br><span class="line">1  1 Google www.google.com   111</span><br><span class="line">2  2 Runoob www.runoob.com   222</span><br><span class="line">3  3 Taobao www.taobao.com   333</span><br></pre></td></tr></table></figure><h2 id="R-MySQL-连接">R MySQL 连接</h2><p>MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。</p><p>如果你对 MySQL 还不了解，可以先查阅：<a href="https://www.runoob.com/mysql/mysql-tutorial.html">MySQL 教程</a></p><p>R 语言读写 MySQL 文件需要安装扩展包，我们可以在 R 到控制台输入以下命令来安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(&quot;RMySQL&quot;, repos = &quot;https://mirrors.ustc.edu.cn/CRAN/&quot;)</span><br></pre></td></tr></table></figure><p>查看是否安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; any(grepl(&quot;RMySQL&quot;,installed.packages()))</span><br><span class="line">[1] TRUE</span><br></pre></td></tr></table></figure><p>MySQL 目前被甲骨文收购，所以很多人使用来它的复制版本 MariaDB，MariaDB 在 GNU GPL下开源，MariaDB 的开发是由 MySQL 的一些原始开发者领导的，所以语法操作都差不多：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(&quot;RMariaDB&quot;, repos = &quot;https://mirrors.ustc.edu.cn/CRAN/&quot;)</span><br></pre></td></tr></table></figure><p>在 test 数据库中创建数据表 runoob，表结构及数据代码如下：</p><h2 id="实例-19">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\-- -- 表的结构 \`runoob\` \-- CREATE TABLE \`runoob\` ( \`id\` int(11) NOT NULL, \`name\` char(20) NOT NULL, \`url\` varchar(255) NOT NULL, \`likes\` int(11) NOT NULL ) ENGINE\=InnoDB DEFAULT CHARSET\=utf8mb4; \-- -- 转存表中的数据 \`runoob\` \-- INSERT INTO \`runoob\` (\`id\`, \`name\`, \`url\`, \`likes\`) VALUES (1, &#x27;Google&#x27;, &#x27;www.google.com&#x27;, 111), (2, &#x27;Runoob&#x27;, &#x27;www.runoob.com&#x27;, 222), (3, &#x27;Taobao&#x27;, &#x27;www.taobao.com&#x27;, 333);</span><br></pre></td></tr></table></figure><p>接下来我们可以使用 RMySQL 包来读取数据：</p><h2 id="实例-20">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">library(RMySQL)</span><br><span class="line"></span><br><span class="line">\# dbname 为数据库名，这边的参数请根据自己实际情况填写  </span><br><span class="line">mysqlconnection \= dbConnect(MySQL(), user \= &#x27;root&#x27;, password \= &#x27;&#x27;, dbname \= &#x27;test&#x27;,host \= &#x27;localhost&#x27;)</span><br><span class="line"></span><br><span class="line">\# 查看数据  </span><br><span class="line">dbListTables(mysqlconnection)</span><br></pre></td></tr></table></figure><p>接下来我们可以使用 dbSendQuery 来读取数据库的表，结果集通过 fetch() 函数来获取：</p><h2 id="实例-21">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">library(RMySQL)  </span><br><span class="line">\# 查询 sites 表，增删改查操作可以通过第二个参数的 SQL 语句来实现  </span><br><span class="line">result \= dbSendQuery(mysqlconnection, &quot;select \* from sites&quot;)</span><br><span class="line"></span><br><span class="line">\# 获取前面两行数据  </span><br><span class="line">data.frame \= fetch(result, n \= 2)  </span><br><span class="line">print(data.frame)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> R语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言-基础</title>
      <link href="/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"/>
      <url>/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="R-语言基础">R 语言基础</h2><p>一门新的语言学习一般是从输出 “Hello, World!” 程序开始，R 语言的 “Hello, World!” 程序代码如下：</p><h2 id="实例（helloworld-R）">实例（helloworld.R）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myString &lt;- &quot;Hello, World!&quot;</span><br><span class="line"></span><br><span class="line">print ( myString )</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/try/runcode.php?filename=helloworld&amp;type=r">运行实例 »</a></p><p>以上实例将字符串 “Hello, World!” 赋值给 myString 变量，然后使用 print() 函数输出。</p><p>**注意：**R 语言赋值使用的是左箭头 &lt;- 符号，不过一些新版本也支持等号 <strong>=</strong>。</p><h3 id="变量">变量</h3><p>R 语言的有效的变量名称由字母，数字以及点号 . 或下划线 _ 组成。</p><p>变量名称以字母或点开头。</p><table><thead><tr><th>变量名</th><th>是否正确</th><th>原因</th></tr></thead><tbody><tr><td>var_name2.</td><td>正确</td><td>字符开头，并由字母、数字、下划线和点号组成</td></tr><tr><td>var_name%</td><td>错误</td><td>% 是非法字符</td></tr><tr><td>2var_name</td><td>错误</td><td>不能数字开头</td></tr><tr><td>.var_name,<a href="http://var.name">var.name</a></td><td>正确</td><td>可以 . 号开头，但是要注意 . 号开头后面不能跟着数字</td></tr><tr><td>.2var_name</td><td>错误</td><td>. 号开头后面不能跟着数字</td></tr><tr><td>_var_name</td><td>错误</td><td>不能以下划线 _ 开头</td></tr></tbody></table><h3 id="变量赋值">变量赋值</h3><p>最新版本的 R 语言的赋值可以使用左箭头 &lt;-、等号 = 、右箭头 -&gt; 赋值:</p><h2 id="实例">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\# 使用等号 = 号赋值  </span><br><span class="line">\&gt; var.1 \= c(0,1,2,3)            </span><br><span class="line">\&gt; print(var.1)  </span><br><span class="line">\[1\] 0 1 2 3</span><br><span class="line"></span><br><span class="line">\# 使用左箭头 &lt;-赋值  </span><br><span class="line">\&gt; var.2 &lt;- c(&quot;learn&quot;,&quot;R&quot;)    </span><br><span class="line">\&gt; print(var.2)  </span><br><span class="line">\[1\] &quot;learn&quot; &quot;R&quot;</span><br><span class="line"></span><br><span class="line">    \# 使用右箭头 -&gt; 赋值  </span><br><span class="line">\&gt; c(TRUE,1) \-&gt; var.3  </span><br><span class="line">\&gt; print(var.3)  </span><br><span class="line">\[1\] 1 1</span><br></pre></td></tr></table></figure><p>查看已定义的变量可以使用 <strong>ls()</strong> 函数：</p><h2 id="实例-2">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\&gt; print(ls())  </span><br><span class="line">\[1\] &quot;var.1&quot; &quot;var.2&quot; &quot;var.3&quot;  </span><br></pre></td></tr></table></figure><p>删除变量可以使用 <strong>rm()</strong> 函数：</p><h2 id="实例-3">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\&gt; rm(var.3)  </span><br><span class="line">\&gt; print(ls())  </span><br><span class="line">\[1\] &quot;var.1&quot; &quot;var.2&quot;  </span><br><span class="line">\&gt;  </span><br></pre></td></tr></table></figure><p>上一章节中我们已经学会来如何安装 R 的编程环境，接下来我们将为大家介绍 R 语言的交互式编程与文件脚本编程。</p><h3 id="交互式编程">交互式编程</h3><p>我们只需要在命令行中执行 R 命令就可以进入交互式的编程窗口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R</span><br></pre></td></tr></table></figure><p>执行完这个命令后会调出 R 语言的解释器，我们在 &gt; 符后面输入代码即可。</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/AA89F11A-9180-4BD0-8A6A-4BE2FD5F1E8E.jpg" alt=""></p><p>交互式命令可以通过输入 q() 来退出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; q()</span><br><span class="line">Save workspace image? [y/n/c]: y</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/DDF9B88F-3BBC-4679-9D93-565E4D0ABBAB.jpg" alt=""></p><h3 id="文件脚本">文件脚本</h3><p>R 语言文件后缀为 .R。</p><p>接下来我们创建一个 runoob-test.R 文件：代码如下：</p><h2 id="runoob-test-R-文件">runoob-test.R 文件</h2><p>myString &lt;- “RUNOOB”</p><p>print ( myString )</p><p>接下来我们在命令行窗口使用 Rscript 来执行该脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rscript runoob-test.R</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;RUNOOB&quot;</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/0E277616-7A0A-423B-A3FB-8BCF0D381C80.jpg" alt=""></p><hr><h2 id="输入输出">输入输出</h2><h3 id="print-输出">print() 输出</h3><p>print() 是 R 语言的输出函数。</p><p>和其他编程语言一样，R 语言支持数字、字符等输出。</p><p>输出的语句十分简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;RUNOOB&quot;)</span><br><span class="line">print(123)</span><br><span class="line">print(3e2)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;RUNOOB&quot;</span><br><span class="line">[1] 123</span><br><span class="line">[1] 300</span><br></pre></td></tr></table></figure><p>R 语言与 node.js 和 Python 一样，是解释型的语言，所以我们往往可以像使用命令行一样使用 R 语言。</p><p>如果我们在一行上进输入一个值，那么 R 也会把它直接标准化输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 5e-2</span><br><span class="line">[1] 0.05</span><br></pre></td></tr></table></figure><h3 id="cat-函数">cat() 函数</h3><p>如果需要输出结果的拼接，我们可以使用 cat() 函数：</p><h2 id="实例-4">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\&gt; cat(1, &quot;加&quot;, 1, &quot;等于&quot;, 2, &#x27;\\n&#x27;)  </span><br><span class="line">1 加 1 等于 2  </span><br></pre></td></tr></table></figure><p>cat() 函数会在每两个拼接元素之间自动加上空格。</p><h3 id="输出内容到文件">输出内容到文件</h3><p>R 语言输出到文件的方法十分多样，而且很方便。</p><p>cat() 函数支持直接输出结果到文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat(&quot;RUNOOB&quot;, file=&quot;/Users/runoob/runoob-test/r_test.txt&quot;)</span><br></pre></td></tr></table></figure><p>这个语句不会在控制台产生结果，而是把 “RUNOOB” 输出到 “/Users/runoob/runoob-test/r_test.txt” 文件中去。</p><p>file 参数可以是绝对路径或相对路径，建议使用绝对路径，Windows 路径格式为 D:\\r_test.txt。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat(&quot;RUNOOB&quot;, file=&quot;D:\\r_test.txt&quot;)</span><br></pre></td></tr></table></figure><p>注意：这个操作是&quot;覆盖写入&quot;操作，请谨慎使用，因为它会将输出文件的原有数据清除。如果想&quot;追加写入&quot;，请不要忘记设置 append 参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat(&quot;GOOGLE&quot;, file=&quot;/Users/runoob/runoob-test/r_test.txt&quot;, append=TRUE)</span><br></pre></td></tr></table></figure><p>执行以上代码后，打开 r_test.txt 文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUNOOBGOOGLE</span><br></pre></td></tr></table></figure><h3 id="sink">sink()</h3><p>sink() 函数可以把控制台输出的文字直接输出到文件中去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sink(&quot;/Users/runoob/runoob-test/r_test.txt&quot;)</span><br></pre></td></tr></table></figure><p>这条语句执行以后，任何控制台上的输出都会被写入到 “/Users/runoob/runoob-test/r_test.txt” 文件中去，控制台将不会显示输出。</p><p>注意：这个操作也是&quot;覆盖写入&quot;操作，会直接清除原有的文件内容。</p><p>如果我们依然想保留控制台的输出，可以设置 split 属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sink(&quot;/Users/runoob/runoob-test/r_test.txt&quot;, split=TRUE)</span><br></pre></td></tr></table></figure><p>如果想取消输出到文件，可以调用无参数的 sink ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sink()</span><br></pre></td></tr></table></figure><h2 id="实例-5">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sink(&quot;r\_test.txt&quot;, split\=TRUE)  \# 控制台同样输出  </span><br><span class="line">for (i in 1:5)  </span><br><span class="line">    print(i)  </span><br><span class="line">sink()   \# 取消输出到文件</span><br><span class="line"></span><br><span class="line">sink(&quot;r\_test.txt&quot;, append\=TRUE) \# 控制台不输出，追加写入文件  </span><br><span class="line">print(&quot;RUNOOB&quot;)</span><br></pre></td></tr></table></figure><p>执行以上代码，当前目录下会生存一个 r_test.txt 文件，打开文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1] 1</span><br><span class="line">[1] 2</span><br><span class="line">[1] 3</span><br><span class="line">[1] 4</span><br><span class="line">[1] 5</span><br><span class="line">[1] &quot;RUNOOB&quot;</span><br></pre></td></tr></table></figure><p>控制台输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1] 1</span><br><span class="line">[1] 2</span><br><span class="line">[1] 3</span><br><span class="line">[1] 4</span><br><span class="line">[1] 5</span><br></pre></td></tr></table></figure><h3 id="文字输入">文字输入</h3><p>可能我们会联想到 C 语言中的 scanf 、Java 中的 java.util.Scanner，如果你学习过 Python 可能对 input() 函数更熟悉。但是 R 语言本身作为一种解释型的语言，更类似于一些终端脚本语言（比如 bash 或者 PowerShell），这些语言是基于命令系统的，本身就需要输入和输出且不适合开发面向用户的应用程序（因为他们本身就是给最终用户使用的）。因此 R 语言没有专门再从控制台读取的函数，文字输入在 R 的使用中一直在进行。</p><h3 id="从文件读入文字">从文件读入文字</h3><p>R 语言中有丰富的文件读取函数，但是如果纯粹的想将某个文件中的内容读取为字符串，可以使用 readLines 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readLines(&quot;/Users/runoob/runoob-test/r_test.txt&quot;)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;RUNOOBGOOGLE&quot;</span><br></pre></td></tr></table></figure><p>读取结果是两个字符串，分别是所读取的文件包含的两行内容。</p><blockquote><p>**注意：**所读取的文本文件每一行 (包括最后一行) 的结束必须有换行符，否则会报错。</p></blockquote><h3 id="其他方式">其他方式</h3><p>除了文字的简单输入输出以外，R 还提供了很多输入数据和输出数据的方法，R 语言最方便的地方就是可以将数据结构直接保存到文件中去，而且支持保存为 CSV、Excel 表格等形式，并且支持直接地读取。这对于数学研究者来说无疑是非常方便的。但是这些功能对于 R 语言的学习影响不大，我们将在之后的章节提到。</p><h3 id="工作目录">工作目录</h3><p>对于文件操作，我们需要设置文件的路径，R 语言可以通过以下两个函数来获取和设置当前的工作目录：</p><ul><li><strong>getwd()</strong> : 获取当前工作目录</li><li><strong>setwd()</strong> : 设置当前工作目录</li></ul><h2 id="实例-6">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\# 当前工作目录  </span><br><span class="line">print(getwd())</span><br><span class="line"></span><br><span class="line">\# 设置当前工作目录  </span><br><span class="line">setwd(&quot;/Users/runoob/runoob-test2&quot;)</span><br><span class="line"></span><br><span class="line">\# 查看当前工作目录  </span><br><span class="line">print(getwd())</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;/Users/runoob/runoob-test&quot;</span><br><span class="line">[1] &quot;/Users/tianqixin/runoob-test2&quot;</span><br></pre></td></tr></table></figure><h2 id="R-注释">R 注释</h2><p>注释主要用于一段代码的解析，可以让阅读者更易理解，编程语言的注释会被编译器忽略掉，且不会影响代码的执行。</p><p>一般编程语言的注释分为单行注释与多行注释，但是 R 语言只支持单行注释，注释符号为 #。</p><p>其实如果有多行注释我们只需要在每一行添加 # 号就好了。</p><h2 id="单行注释">单行注释</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\# 这是我的第一个编程代码  </span><br><span class="line">myString &lt;- &quot;Hello, World!&quot;</span><br><span class="line"></span><br><span class="line">print ( myString )</span><br></pre></td></tr></table></figure><h2 id="多行注释">多行注释</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\# R 语言实现两个数相加</span><br><span class="line"></span><br><span class="line">  \# 变量赋值  </span><br><span class="line">a &lt;- 9  </span><br><span class="line">b &lt;- 4</span><br><span class="line"></span><br><span class="line">  \# 输出结果  </span><br><span class="line">print(a + b)</span><br></pre></td></tr></table></figure><p>其实多行注释还有一个变通的写法，就是使用 if 语言，如下实例：</p><h2 id="多行注释-2">多行注释</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(FALSE) &#123;  </span><br><span class="line">    &quot;  </span><br><span class="line">    这是一个多行注释的实例  </span><br><span class="line">    注释内容放在单引号或双引号之间  </span><br><span class="line">    &quot;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myString &lt;- &quot;Hello, World!&quot;  </span><br><span class="line">print ( myString)</span><br></pre></td></tr></table></figure><h2 id="R-基础运算">R 基础运算</h2><p>本章介绍 R 语言的简单运算。</p><h3 id="赋值">赋值</h3><p>一般语言的赋值是 <strong>=</strong> 号，但是 R 语言是数学语言，所以赋值符号与我们数学书上的伪代码很相似，是一个左箭头 &lt;- ：</p><h2 id="实例-7">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- 123  </span><br><span class="line">b &lt;- 456  </span><br><span class="line">print(a + b)  </span><br></pre></td></tr></table></figure><p>以上代码执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] 579</span><br></pre></td></tr></table></figure><p>这个赋值符号是 R 语言的一个形式上的优点和操作上的缺点：形式上更适合数学工作者，毕竟不是所有的数学工作者都习惯于使用 <strong>=</strong> 作为赋值符号。</p><p>操作上来讲，&lt; 符号和 - 符号都不是很好打的字符，这会让很多程序员不适应。因此，R 语言的比较新的版本也支持 = 作为赋值符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 123</span><br><span class="line">b = 456</span><br><span class="line">print(a + b)</span><br></pre></td></tr></table></figure><p>这也是合法的 R 程序。</p><p>**注意：**很难考证从 R 的哪个版本开始支持了 <strong>=</strong> 赋值，但是本教程习用的 R 版本是 4.0.0。</p><h3 id="数学运算符">数学运算符</h3><p>下表列出了主要的数学运算符以及他们的运算顺序：</p><table><thead><tr><th>优先级</th><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>()</td><td>括号</td></tr><tr><td>2</td><td>^</td><td>乘方运算</td></tr><tr><td>3</td><td>%%</td><td>整除求余</td></tr><tr><td></td><td>%/%</td><td>整除</td></tr><tr><td>4</td><td>*</td><td>乘法</td></tr><tr><td></td><td>/</td><td>除法</td></tr><tr><td>5</td><td>+</td><td>加法</td></tr><tr><td></td><td>-</td><td>减法</td></tr></tbody></table><p>以下实例演示了简单的数学运算：</p><h2 id="实例-8">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">\&gt; 1 + 2 \* 3  </span><br><span class="line">\[1\] 7  </span><br><span class="line">\&gt; (1 + 2) \* 3  </span><br><span class="line">\[1\] 9  </span><br><span class="line">\&gt; 3 / 4  </span><br><span class="line">\[1\] 0.75  </span><br><span class="line">\&gt; 3.4 \- 1.2  </span><br><span class="line">\[1\] 2.2  </span><br><span class="line">\&gt; 1 \- 4 \* 0.5^3  </span><br><span class="line">\[1\] 0.5  </span><br><span class="line">\&gt; 8 / 3 %% 2  </span><br><span class="line">\[1\] 8  </span><br><span class="line">\&gt; 8 / 4 %% 2  </span><br><span class="line">\[1\] Inf  </span><br><span class="line">\&gt; 3 %% 2^2  </span><br><span class="line">\[1\] 3  </span><br><span class="line">\&gt; 10 / 3 %/% 2  </span><br><span class="line">\[1\] 10  </span><br></pre></td></tr></table></figure><h3 id="关系运算符">关系运算符</h3><p>下表列出了 R 语言支持的关系运算符，关系运算符比较两个向量，将第一向量与第二向量的每个元素进行比较，结果返回一个布尔值。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&gt;</td><td>判断第一个向量的每个元素是否大于第二个向量的相对应元素。</td></tr><tr><td>&lt;</td><td>判断第一个向量的每个元素是否小于第二个向量的相对应元素。</td></tr><tr><td>==</td><td>判断第一个向量的每个元素是否等于第二个向量的相对应元素。</td></tr><tr><td>!=</td><td>判断第一个向量的每个元素是否不等于第二个向量的相对应元素。</td></tr><tr><td>&gt;=</td><td>判断第一个向量的每个元素是否大于等于第二个向量的相对应元素。</td></tr><tr><td>&lt;=</td><td>判断第一个向量的每个元素是否小于等于第二个向量的相对应元素。</td></tr></tbody></table><h2 id="实例-9">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v &lt;- c(2,4,6,9)  </span><br><span class="line">t &lt;- c(1,4,7,9)  </span><br><span class="line">print(v\&gt;t)  </span><br><span class="line">print(v &lt; t)  </span><br><span class="line">print(v \== t)  </span><br><span class="line">print(v!=t)  </span><br><span class="line">print(v\&gt;=t)  </span><br><span class="line">print(v&lt;=t)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1]  TRUE FALSE FALSE FALSE</span><br><span class="line">[1] FALSE FALSE  TRUE FALSE</span><br><span class="line">[1] FALSE  TRUE FALSE  TRUE</span><br><span class="line">[1]  TRUE FALSE  TRUE FALSE</span><br><span class="line">[1]  TRUE  TRUE FALSE  TRUE</span><br><span class="line">[1] FALSE  TRUE  TRUE  TRUE</span><br></pre></td></tr></table></figure><h3 id="逻辑运算符">逻辑运算符</h3><p>下表列出了 R 语言支持的逻辑运算符，可用于数字、逻辑和复数类型的向量。</p><p>非 0 的数字（正数或负数）都为 TRUE。</p><p>逻辑运算符比较两个向量，将第一向量与第二向量的每个元素进行比较，结果返回一个布尔值。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>元素逻辑与运算符，将第一个向量的每个元素与第二个向量的相对应元素进行组合，如果两个元素都为 TRUE，则结果为 TRUE，否则为 FALSE。</td></tr><tr><td>｜</td><td>元素逻辑或运算符，将第一个向量的每个元素与第二个向量的相对应元素进行组合，如果两个元素中有一个为 TRUE，则结果为 TRUE，如果都为 FALSE，则返回 FALSE。</td></tr><tr><td>!</td><td>逻辑非运算符，返回向量每个元素相反的逻辑值，如果元素为 TRUE 则返回 FALSE，如果元素为 FALSE 则返回 TRUE。</td></tr><tr><td>&amp;&amp;</td><td>逻辑与运算符，只对两个向量对第一个元素进行判断，如果两个元素都为 TRUE，则结果为 TRUE，否则为 FALSE。</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="实例-10">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">v &lt;- c(3,1,TRUE,2+3i)  </span><br><span class="line">t &lt;- c(4,1,FALSE,2+3i)  </span><br><span class="line">print(v&amp;t)  </span><br><span class="line">print(v|t)  </span><br><span class="line">print(!v)</span><br><span class="line"></span><br><span class="line">\# &amp;&amp;、||只对第一个元素进行比较  </span><br><span class="line">v &lt;- c(3,0,TRUE,2+2i)  </span><br><span class="line">t &lt;- c(1,3,TRUE,2+3i)  </span><br><span class="line">print(v&amp;&amp;t)</span><br><span class="line"></span><br><span class="line">v &lt;- c(0,0,TRUE,2+2i)  </span><br><span class="line">t &lt;- c(0,3,TRUE,2+3i)  </span><br><span class="line">print(v||t)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1]  TRUE  TRUE FALSE  TRUE</span><br><span class="line">[1] TRUE TRUE TRUE TRUE</span><br><span class="line">[1] FALSE FALSE FALSE FALSE</span><br><span class="line">[1] TRUE</span><br><span class="line">[1] FALSE</span><br></pre></td></tr></table></figure><h3 id="赋值运算符">赋值运算符</h3><p>R 语言变量可以使用向左，向右或等于操作符来赋值。</p><p>下表列出了 R 语言支持的赋值运算符。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;−</code>, <code>=</code>，<code>&lt;&lt;−</code></td><td>向左赋值。</td></tr><tr><td><code>−&gt;</code>, <code>−&gt;&gt;</code></td><td>向右赋值。</td></tr></tbody></table><h2 id="实例-11">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\# 向左赋值  </span><br><span class="line">v1 &lt;- c(3,1,TRUE,&quot;runoob&quot;)  </span><br><span class="line">v2 &lt;&lt;- c(3,1,TRUE,&quot;runoob&quot;)  </span><br><span class="line">v3 \= c(3,1,TRUE,&quot;runoob&quot;)  </span><br><span class="line">print(v1)  </span><br><span class="line">print(v2)  </span><br><span class="line">print(v3)</span><br><span class="line"></span><br><span class="line">\# 向右赋值  </span><br><span class="line">c(3,1,TRUE,&quot;runoob&quot;) \-&gt; v1  </span><br><span class="line">c(3,1,TRUE,&quot;runoob&quot;) \-&gt;&gt; v2  </span><br><span class="line">print(v1)  </span><br><span class="line">print(v2)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;3&quot;      &quot;1&quot;      &quot;TRUE&quot;   &quot;runoob&quot;</span><br><span class="line">[1] &quot;3&quot;      &quot;1&quot;      &quot;TRUE&quot;   &quot;runoob&quot;</span><br><span class="line">[1] &quot;3&quot;      &quot;1&quot;      &quot;TRUE&quot;   &quot;runoob&quot;</span><br><span class="line">[1] &quot;3&quot;      &quot;1&quot;      &quot;TRUE&quot;   &quot;runoob&quot;</span><br><span class="line">[1] &quot;3&quot;      &quot;1&quot;      &quot;TRUE&quot;   &quot;runoob&quot;</span><br></pre></td></tr></table></figure><h3 id="其他运算符">其他运算符</h3><p>R 语言还包含了一些特别的运算符。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>:</td><td>冒号运算符，用于创建一系列数字的向量。</td></tr><tr><td>%in%</td><td>用于判断元素是否在向量里，返回布尔值，有的话返回 TRUE，没有返回 FALSE。</td></tr><tr><td>%*%</td><td>用于矩阵与它转置的矩阵相乘。</td></tr></tbody></table><h2 id="实例-12">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\# 1 到 10 的向量  </span><br><span class="line">v &lt;- 1:10  </span><br><span class="line">print(v)</span><br><span class="line"></span><br><span class="line">\# 判断数字是否在向量 v 中  </span><br><span class="line">v1 &lt;- 3  </span><br><span class="line">v2 &lt;- 15  </span><br><span class="line">print(v1 %in% v)  </span><br><span class="line">print(v2 %in% v)</span><br><span class="line"></span><br><span class="line">\# 矩阵与它转置的矩阵相乘  </span><br><span class="line">M \= matrix( c(2,6,5,1,10,4), nrow \= 2,ncol \= 3,byrow \= TRUE)  </span><br><span class="line">t \= M %\*% t(M)  </span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1]  1  2  3  4  5  6  7  8  9 10</span><br><span class="line">[1] TRUE</span><br><span class="line">[1] FALSE</span><br><span class="line">     [,1] [,2]</span><br><span class="line">[1,]   65   82</span><br><span class="line">[2,]   82  117</span><br></pre></td></tr></table></figure><h3 id="数学函数">数学函数</h3><p>常见对一些数学函数有：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>sqrt(n)</td><td>n的平方根</td></tr><tr><td>exp(n)</td><td>自然常数e的n次方，</td></tr><tr><td>log(m,n)</td><td>m的对数函数，返回n的几次方等于m</td></tr><tr><td>log10(m)</td><td>相当于log(m,10)</td></tr></tbody></table><p>以下实例演示了数学函数的应用：</p><h2 id="实例-13">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\&gt; sqrt(4)  </span><br><span class="line">\[1\] 2  </span><br><span class="line">\&gt; exp(1)  </span><br><span class="line">\[1\] 2.718282  </span><br><span class="line">\&gt; exp(2)  </span><br><span class="line">\[1\] 7.389056  </span><br><span class="line">\&gt; log(2,4)  </span><br><span class="line">\[1\] 0.5  </span><br><span class="line">\&gt; log10(10000)  </span><br><span class="line">\[1\] 4  </span><br></pre></td></tr></table></figure><p>取整函数：</p><table><thead><tr><th>名称</th><th>参数模型</th><th>含义</th></tr></thead><tbody><tr><td>round</td><td>(n)</td><td>对 n 四舍五入取整</td></tr><tr><td></td><td>(n, m)</td><td>对 n 保留 m 位小数四舍五入</td></tr><tr><td>ceiling</td><td>(n)</td><td>对 n 向上取整</td></tr><tr><td>floor</td><td>(n)</td><td>对 n 向下取整</td></tr></tbody></table><p>以下实例演示了取整函数的应用：</p><h2 id="实例-14">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\&gt; round(1.5)  </span><br><span class="line">\[1\] 2  </span><br><span class="line">\&gt; round(2.5)  </span><br><span class="line">\[1\] 2  </span><br><span class="line">\&gt; round(3.5)  </span><br><span class="line">\[1\] 4  </span><br><span class="line">\&gt; round(4.5)  </span><br><span class="line">\[1\] 4  </span><br></pre></td></tr></table></figure><p><strong>注意</strong>：R 中的 round 函数有些情况下可能会&quot;舍掉五&quot;。</p><p>当取整位是偶数的时候，五也会被舍去，这一点与 C 语言有所不同。</p><p>R 的三角函数是弧度制：</p><h2 id="实例-15">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\&gt; sin(pi/6)  </span><br><span class="line">\[1\] 0.5  </span><br><span class="line">\&gt; cos(pi/4)  </span><br><span class="line">\[1\] 0.7071068  </span><br><span class="line">\&gt; tan(pi/3)  </span><br><span class="line">\[1\] 1.732051  </span><br></pre></td></tr></table></figure><p>反三角函数：</p><h2 id="实例-16">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\&gt; asin(0.5)  </span><br><span class="line">\[1\] 0.5235988  </span><br><span class="line">\&gt; acos(0.7071068)  </span><br><span class="line">\[1\] 0.7853981  </span><br><span class="line">\&gt; atan(1.732051)  </span><br><span class="line">\[1\] 1.047198  </span><br></pre></td></tr></table></figure><p>如果学习过概率论和统计学，应该对以下的概率分布函数比较了解，因为 R 语言为数学工作者设计，所以经常会用到：</p><h2 id="实例-17">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\&gt; dnorm(0)  </span><br><span class="line">\[1\] 0.3989423  </span><br><span class="line">\&gt; pnorm(0)  </span><br><span class="line">\[1\] 0.5  </span><br><span class="line">\&gt; qnorm(0.95)  </span><br><span class="line">\[1\] 1.644854  </span><br><span class="line">\&gt; rnorm(3, 5, 2) \# 产生 3 个平均值为 5，标准差为 2 的正态随机数  </span><br><span class="line">\[1\] 4.177589 6.413927 4.206032  </span><br></pre></td></tr></table></figure><p>这四个都是用来计算正态分布的函数。它们的名字都以 norm 结尾，代表&quot;正态分布&quot;。</p><p>分布函数名字的前缀有四种：</p><ul><li><strong>d</strong> - 概率密度函数</li><li><strong>p</strong> - 概率密度积分函数（从无限小到 x 的积分）</li><li><strong>q</strong> - 分位数函数</li><li><strong>r</strong> - 随机数函数（常用于概率仿真）</li></ul><p><strong>注</strong>：由于本教程不是阐述数学专业理论的教程，所以对有关概率分布的数学理论不作详细解释。R 语言除了含有正态分布函数以外还有泊松分布 (pois, Poisson) 等常见分布函数，如果想详细了解可以学习&quot;概率论与数理统计&quot;。</p><h2 id="R-数据类型">R 数据类型</h2><p>数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。</p><p>变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。</p><p>R 语言中的最基本数据类型主要有三种：</p><ul><li>数字</li><li>逻辑</li><li>文本</li></ul><p>数字常量主要有两种：</p><table><thead><tr><th>一般型</th><th>123 -0.125</th></tr></thead><tbody><tr><td>科学计数法</td><td>1.23e2 -1.25E-1</td></tr></tbody></table><p>逻辑类型在许多其他编程语言中常称为布尔型（Boolean），常量值只有 <strong>TRUE</strong> 和 <strong>FALSE</strong>。</p><p>**注意：**R 语言区分大小写，true 或 True 不能代表 TRUE。</p><p>最直观的数据类型就是文本类型。文本就是其它语言中常出现的字符串（String），常量用双引号包含。在 R 语言中，文本常量既可以用单引号包含，也可以用双引号包含，例如：</p><h2 id="实例-18">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\&gt; &#x27;runoob&#x27; \== &quot;runoob&quot;  </span><br><span class="line">\[1\] TRUE  </span><br></pre></td></tr></table></figure><p>有关于 R 语言的变量定义，并不像一些强类型语言中的语法规则，需要专门为变量设置名称和数据类型，每当在 R 中使用赋值运算符时，实际上就是定义了一个新的变量：</p><h2 id="实例-19">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a \= 1  </span><br><span class="line">b &lt;- TRUE  </span><br><span class="line">b \= &quot;abc&quot;  </span><br></pre></td></tr></table></figure><p>按对象类型来分是以下 6 种（后面会详细介绍这几种类型）：</p><ul><li>向量（vector）</li><li><a href="https://www.runoob.com/r/r-list.html">列表（list）</a></li><li><a href="https://www.runoob.com/r/r-matrix.html">矩阵（matrix）</a></li><li><a href="https://www.runoob.com/r/r-array.html">数组（array）</a></li><li><a href="https://www.runoob.com/r/r-factor.html">因子（factor)</a></li><li><a href="https://www.runoob.com/r/r-data-frame.html">数据框（data.frame)</a></li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/52988954-D570-42FD-9CFC-90CD78D361C3.jpg" alt=""></p><h3 id="向量">向量</h3><p>向量（Vector）在 Java、Rust、C# 这些专门编程的的语言的标准库里往往会提供，这是因为向量在数学运算中是不可或缺的工具——我们最常见的向量是二维向量，这种向量在平面坐标系中必然会用到。</p><p>向量从数据结构上看就是一个线性表，可以看成一个数组。</p><p>R 语言中向量作为一种类型存在可以让向量的操作变得更加容易：</p><h2 id="实例-20">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\&gt; a \= c(3, 4)  </span><br><span class="line">\&gt; b \= c(5, 0)  </span><br><span class="line">\&gt; a + b  </span><br><span class="line">\[1\] 8 4  </span><br><span class="line">\&gt;  </span><br></pre></td></tr></table></figure><p>c() 是一个创造向量的函数。</p><p>这里把两个二维向量相加，得到一个新的二维向量 (8, 4)。如果将一个二维向量和三维向量做运算，将失去数学意义，虽然不会停止运行，但会被警告。</p><p>我建议大家从习惯上杜绝这种情况的出现。</p><p>向量中的每一个元素可以通过下标单独取出：</p><h2 id="实例-21">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\&gt; a \= c(10, 20, 30, 40, 50)  </span><br><span class="line">\&gt; a\[2\]  </span><br><span class="line">\[1\] 20  </span><br></pre></td></tr></table></figure><p>**注意：**R 语言中的&quot;下标&quot;不代表偏移量，而代表第几个，也就是说是从 1 开始的！</p><p>R 也可以方便的取出向量的一部分：</p><h2 id="实例-22">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\&gt; a\[1:4\] \# 取出第 1 到 4 项，包含第 1 和第 4 项  </span><br><span class="line">\[1\] 10 20 30 40  </span><br><span class="line">\&gt; a\[c(1, 3, 5)\] \# 取出第 1, 3, 5 项  </span><br><span class="line">\[1\] 10 30 50  </span><br><span class="line">\&gt; a\[c(\-1, \-5)\] \# 去掉第 1 和第 5 项  </span><br><span class="line">\[1\] 20 30 40  </span><br></pre></td></tr></table></figure><p>这三种部分取出方法是最常用的。</p><p>向量支持标量计算：</p><h2 id="实例-23">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\&gt; c(1.1, 1.2, 1.3) \- 0.5  </span><br><span class="line">\[1\] 0.6 0.7 0.8  </span><br><span class="line">\&gt; a \= c(1,2)  </span><br><span class="line">\&gt; a ^ 2  </span><br><span class="line">\[1\] 1 4  </span><br></pre></td></tr></table></figure><p>之前讲述的常用的数学运算函数，如 sqrt 、exp 等，同样可以用于对向量作标量运算。</p><p>&quot;向量&quot;作为线性表结构，应该具备一些常用的线性表处理函数，R 确实具备这些函数：</p><p>向量排序：</p><h2 id="实例-24">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\&gt; a \= c(1, 3, 5, 2, 4, 6)  </span><br><span class="line">\&gt; sort(a)  </span><br><span class="line">\[1\] 1 2 3 4 5 6  </span><br><span class="line">\&gt; rev(a)  </span><br><span class="line">\[1\] 6 4 2 5 3 1  </span><br><span class="line">\&gt; order(a)  </span><br><span class="line">\[1\] 1 4 2 5 3 6  </span><br><span class="line">\&gt; a\[order(a)\]  </span><br><span class="line">\[1\] 1 2 3 4 5 6  </span><br></pre></td></tr></table></figure><p>order() 函数返回的是一个向量排序之后的下标向量。</p><p><strong>向量统计</strong></p><p>R 中有十分完整的统计学函数：</p><table><thead><tr><th><strong>函数名</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>sum</td><td>求和</td></tr><tr><td>mean</td><td>求平均值</td></tr><tr><td>var</td><td>方差</td></tr><tr><td>sd</td><td>标准差</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>range</td><td>取值范围（二维向量，最大值和最小值）</td></tr></tbody></table><p>向量统计实例：</p><h2 id="实例-25">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\&gt; sum(1:5)  </span><br><span class="line">\[1\] 15  </span><br><span class="line">\&gt; sd(1:5)  </span><br><span class="line">\[1\] 1.581139  </span><br><span class="line">\&gt; range(1:5)  </span><br><span class="line">\[1\] 1 5  </span><br></pre></td></tr></table></figure><p><strong>向量生成</strong></p><p>向量的生成可以用 <strong>c()</strong> 函数生成，也可以用 min:max 运算符生成连续的序列。</p><p>如果想生成有间隙的等差数列，可以用 seq 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; seq(1, 9, 2)</span><br><span class="line">[1] 1 3 5 7 9</span><br></pre></td></tr></table></figure><p>seq 还可以生成从 m 到 n 的等差数列，只需要指定 m, n 以及数列的长度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; seq(0, 1, length.out=3)</span><br><span class="line">[1] 0.0 0.5 1.0</span><br></pre></td></tr></table></figure><p>rep 是 repeat（重复）的意思，可以用于产生重复出现的数字序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rep(0, 5)</span><br><span class="line">[1] 0 0 0 0 0</span><br></pre></td></tr></table></figure><p>向量中常会用到 NA 和 NULL ，这里介绍一下这两个词语与区别：</p><ul><li>NA 代表的是&quot;缺失&quot;，NULL 代表的是&quot;不存在&quot;。</li><li>NA 缺失就像占位符，代表这里没有一个值，但位置存在。</li><li>NULL 代表的就是数据不存在。</li></ul><p>实例说明：</p><h2 id="实例-26">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\&gt; length(c(NA, NA, NULL))  </span><br><span class="line">\[1\] 2  </span><br><span class="line">\&gt; c(NA, NA, NULL, NA)  </span><br><span class="line">\[1\] NA NA NA  </span><br></pre></td></tr></table></figure><p>很显然， NULL 在向量中没有任何意义。</p><hr><h2 id="逻辑型">逻辑型</h2><p>逻辑向量主要用于向量的逻辑运算，例如：</p><h2 id="实例-27">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\&gt; c(11, 12, 13) \&gt; 12  </span><br><span class="line">\[1\] FALSE FALSE  TRUE  </span><br></pre></td></tr></table></figure><p>which 函数是十分常见的逻辑型向量处理函数，可以用于筛选我们需要的数据的下标:</p><h2 id="实例-28">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\&gt; a \= c(11, 12, 13)  </span><br><span class="line">\&gt; b \= a \&gt; 12  </span><br><span class="line">\&gt; print(b)  </span><br><span class="line">\[1\] FALSE FALSE  TRUE  </span><br><span class="line">\&gt; which(b)  </span><br><span class="line">\[1\] 3  </span><br></pre></td></tr></table></figure><p>例如我们需要从一个线性表中筛选大于等于 60 且小于 70 的数据：</p><h2 id="实例-29">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\&gt; vector \= c(10, 40, 78, 64, 53, 62, 69, 70)  </span><br><span class="line">\&gt; print(vector\[which(vector \&gt;= 60 &amp; vector &lt; 70)\])  </span><br><span class="line">\[1\] 64 62 69  </span><br></pre></td></tr></table></figure><p>类似的函数还有 all 和 any：</p><h2 id="实例-30">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\&gt; all(c(TRUE, TRUE, TRUE))  </span><br><span class="line">\[1\] TRUE  </span><br><span class="line">\&gt; all(c(TRUE, TRUE, FALSE))  </span><br><span class="line">\[1\] FALSE  </span><br><span class="line">\&gt; any(c(TRUE, FALSE, FALSE))  </span><br><span class="line">\[1\] TRUE  </span><br><span class="line">\&gt; any(c(FALSE, FALSE, FALSE))  </span><br><span class="line">\[1\] FALSE  </span><br></pre></td></tr></table></figure><p>all() 用于检查逻辑向量是否全部为 TRUE，any() 用于检查逻辑向量是否含有 TRUE。</p><hr><h2 id="字符串">字符串</h2><p>字符串数据类型本身并不复杂，这里注重介绍字符串的操作函数：</p><h2 id="实例-31">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">\&gt; toupper(&quot;Runoob&quot;) \# 转换为大写  </span><br><span class="line">\[1\] &quot;RUNOOB&quot;  </span><br><span class="line">\&gt; tolower(&quot;Runoob&quot;) \# 转换为小写  </span><br><span class="line">\[1\] &quot;runoob&quot;  </span><br><span class="line">\&gt; nchar(&quot;中文&quot;, type\=&quot;bytes&quot;) \# 统计字节长度  </span><br><span class="line">\[1\] 4  </span><br><span class="line">\&gt; nchar(&quot;中文&quot;, type\=&quot;char&quot;) \# 总计字符数量  </span><br><span class="line">\[1\] 2  </span><br><span class="line">\&gt; substr(&quot;123456789&quot;, 1, 5) \# 截取字符串，从 1 到 5  </span><br><span class="line">\[1\] &quot;12345&quot;  </span><br><span class="line">\&gt; substring(&quot;1234567890&quot;, 5) \# 截取字符串，从 5 到结束  </span><br><span class="line">\[1\] &quot;567890&quot;  </span><br><span class="line">\&gt; as.numeric(&quot;12&quot;) \# 将字符串转换为数字  </span><br><span class="line">\[1\] 12  </span><br><span class="line">\&gt; as.character(12.34) \# 将数字转换为字符串  </span><br><span class="line">\[1\] &quot;12.34&quot;  </span><br><span class="line">\&gt; strsplit(&quot;2019;10;1&quot;, &quot;;&quot;) \# 分隔符拆分字符串  </span><br><span class="line">\[\[1\]\]  </span><br><span class="line">\[1\] &quot;2019&quot; &quot;10&quot;   &quot;1&quot;  </span><br><span class="line">\&gt; gsub(&quot;/&quot;, &quot;-&quot;, &quot;2019/10/1&quot;) \# 替换字符串  </span><br><span class="line">\[1\] &quot;2019-10-1&quot;  </span><br></pre></td></tr></table></figure><p>在 Windows 计算机上实现，使用的是 GBK 编码标准，所以一个中文字符是两个字节，如果在 UTF-8 编码的计算机上运行，单个中文字符的字节长度应该是 3。</p><p>R 支持 perl 语言格式的正则表达式：</p><h2 id="实例-32">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\&gt; gsub(&quot;\[\[:alpha:\]\]+&quot;, &quot;$&quot;, &quot;Two words&quot;)  </span><br><span class="line">\[1\] &quot;$ $&quot;  </span><br></pre></td></tr></table></figure><p>更多字符串内容参考：<a href="https://www.runoob.com/r/r-string.html">R 语言字符串介绍</a>。</p><hr><h2 id="矩阵">矩阵</h2><p>R 语言为线性代数的研究提供了矩阵类型，这种数据结构很类似于其它语言中的二维数组，但 R 提供了语言级的矩阵运算支持。</p><p>首先看看矩阵的生成：</p><h2 id="实例-33">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\&gt; vector\=c(1, 2, 3, 4, 5, 6)  </span><br><span class="line">\&gt; matrix(vector, 2, 3)  </span><br><span class="line">     \[,1\] \[,2\] \[,3\]  </span><br><span class="line">\[1,\]    1    3    5  </span><br><span class="line">\[2,\]    2    4    6  </span><br></pre></td></tr></table></figure><p>矩阵初始化内容是由一个向量来传递的，其次要表达一个矩阵有几行、有几列。</p><p>向量中的值会一列一列的填充到矩阵中。如果想按行填充，需要指定 byrow 属性：</p><h2 id="实例-34">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\&gt; matrix(vector, 2, 3, byrow\=TRUE)  </span><br><span class="line">     \[,1\] \[,2\] \[,3\]  </span><br><span class="line">\[1,\]    1    2    3  </span><br><span class="line">\[2,\]    4    5    6  </span><br></pre></td></tr></table></figure><p>矩阵中的每一个值都可以被直接访问：</p><h2 id="实例-35">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\&gt; m1 \= matrix(vector, 2, 3, byrow\=TRUE)  </span><br><span class="line">\&gt; m1\[1,1\] \# 第 1 行 第 1 列  </span><br><span class="line">\[1\] 1  </span><br><span class="line">\&gt; m1\[1,3\] \# 第 1 行 第 3 列  </span><br><span class="line">\[1\] 3  </span><br></pre></td></tr></table></figure><p>R 中的矩阵的每一个列和每一行都可以设定名称，这个过程通过字符串向量批量完成：</p><h2 id="实例-36">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\&gt; colnames(m1) \= c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)  </span><br><span class="line">\&gt; rownames(m1) \= c(&quot;a&quot;, &quot;b&quot;)  </span><br><span class="line">\&gt; m1  </span><br><span class="line">  x y z  </span><br><span class="line">a 1 2 3  </span><br><span class="line">b 4 5 6  </span><br><span class="line">\&gt; m1\[&quot;a&quot;, \]  </span><br><span class="line">x y z  </span><br><span class="line">1 2 3  </span><br></pre></td></tr></table></figure><p>矩阵的四则运算与向量基本一致，既可以与标量做运算，也可以与同规模的矩阵做对应位置的运算。</p><p>矩阵乘法运算：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/MVGBECflKCDs5GnJ__thumbnail.png" alt=""></p><h2 id="实例-37">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\&gt; m1 \= matrix(c(1, 2), 1, 2)  </span><br><span class="line">\&gt; m2 \= matrix(c(3, 4), 2, 1)  </span><br><span class="line">\&gt; m1 %\*% m2  </span><br><span class="line">     \[,1\]  </span><br><span class="line">\[1,\]   11  </span><br></pre></td></tr></table></figure><p>逆矩阵：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/GOSMbhCW6t98uvPl__thumbnail.png" alt=""></p><h2 id="实例-38">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\&gt; A \= matrix(c(1, 3, 2, 4), 2, 2)  </span><br><span class="line">\&gt; solve(A)  </span><br><span class="line">     \[,1\] \[,2\]  </span><br><span class="line">\[1,\] \-2.0  1.0  </span><br><span class="line">\[2,\]  1.5 \-0.5  </span><br></pre></td></tr></table></figure><p><strong>solve()</strong> 函数用于求解线性代数方程，基本用法是 solve(A,b)，其中，<strong>A</strong> 为方程组的系数矩阵，<strong>b</strong> 方程的向量或矩阵。</p><p><strong>apply()</strong> 函数可以将矩阵的每一行或每一列当作向量来进行操作：</p><h2 id="实例-39">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\&gt; (A \= matrix(c(1, 3, 2, 4), 2, 2))  </span><br><span class="line">     \[,1\] \[,2\]  </span><br><span class="line">\[1,\]    1    2  </span><br><span class="line">\[2,\]    3    4  </span><br><span class="line">\&gt; apply(A, 1, sum) \# 第二个参数为 1 按行操作，用 sum() 函数  </span><br><span class="line">\[1\] 3 7  </span><br><span class="line">\&gt; apply(A, 2, sum) \# 第二个参数为 2 按列操作  </span><br><span class="line">\[1\] 4 6  </span><br></pre></td></tr></table></figure><p>更多矩阵内容参考：<a href="https://www.runoob.com/r/r-matrix.html">R 矩阵</a>。</p><h2 id="R-判断语句">R 判断语句</h2><p>判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。</p><p>下面是大多数编程语言中典型的判断结构的一般形式：</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/12/if.png" alt=""></p><p>R 语言提供了以下类型的判断语句：</p><ul><li>if 语句</li><li>if…else 语句</li><li>switch 语句</li></ul><h3 id="if-语句">if 语句</h3><p>一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(boolean_expression) &#123;</span><br><span class="line">    // 布尔表达式为真将执行的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果布尔表达式 boolean_expression 为 ture 执行这里面的代码，如果 为 false 则不执行。</p><h2 id="实例-40">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 50L  </span><br><span class="line">if(is.integer(x)) &#123;  </span><br><span class="line">   print(&quot;X 是一个整数&quot;)  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;X 是一个整数&quot;</span><br></pre></td></tr></table></figure><h3 id="if…else-语句">if…else 语句</h3><p>一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(boolean_expression) &#123;</span><br><span class="line">    // 如果布尔表达式为真将执行的语句</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 如果布尔表达式为假将执行的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果布尔表达式 boolean_expression 为 true，则执行 if 块内的代码。如果布尔表达式为 false，则执行 else 块内的代码。</p><h2 id="实例-41">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(&quot;google&quot;,&quot;runoob&quot;,&quot;taobao&quot;)</span><br><span class="line"></span><br><span class="line">if(&quot;runoob&quot; %in% x) &#123;  </span><br><span class="line">   print(&quot;包含 runoob&quot;)  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">   print(&quot;不包含 runoob&quot;)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;包含 runoob&quot;</span><br></pre></td></tr></table></figure><p>如果有多个条件判断，可以使用 if…else if…else：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(boolean_expression 1) &#123;</span><br><span class="line">    // 如果布尔表达式 boolean_expression 1 为真将执行的语句</span><br><span class="line">&#125; else if( boolean_expression 2) &#123;</span><br><span class="line">    // 如果布尔表达式 boolean_expression 2 为真将执行的语句</span><br><span class="line">&#125; else if( boolean_expression 3) &#123;</span><br><span class="line">    // 如果布尔表达式 boolean_expression 3 为真将执行的语句</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 以上所有的布尔表达式都为 false 时执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例-42">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(&quot;google&quot;,&quot;runoob&quot;,&quot;taobao&quot;)</span><br><span class="line"></span><br><span class="line">if(&quot;weibo&quot; %in% x) &#123;  </span><br><span class="line">   print(&quot;第一个 if 包含 weibo&quot;)  </span><br><span class="line">&#125; else if (&quot;runoob&quot; %in% x) &#123;  </span><br><span class="line">   print(&quot;第二个 if 包含 runoob&quot;)  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">   print(&quot;没有找到&quot;)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;第二个 if 包含 runoob&quot;</span><br></pre></td></tr></table></figure><h3 id="switch-语句">switch 语句</h3><p>一个 switch 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch(expression, case1, case2, case3....)</span><br></pre></td></tr></table></figure><p><strong>switch</strong> 语句必须遵循下面的规则：</p><ul><li><strong>switch</strong> 语句中的 <strong>expression</strong> 是一个常量表达式，可以是整数或字符串，如果是整数则返回对应的 case 位置值，如果整数不在位置的范围内则返回 NULL。</li><li>如果匹配到多个值则返回第一个。</li><li><strong>expression</strong>如果是字符串，则对应的是 case 中的变量名对应的值，没有匹配则没有返回值。</li><li>switch 没有默认参数可用。</li></ul><p>以下实例返回第三个值：</p><h2 id="实例-43">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- switch(  </span><br><span class="line">   3,  </span><br><span class="line">   &quot;google&quot;,  </span><br><span class="line">   &quot;runoob&quot;,  </span><br><span class="line">   &quot;taobao&quot;,  </span><br><span class="line">   &quot;weibo&quot;  </span><br><span class="line">)  </span><br><span class="line">print(x)  </span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;taobao&quot;</span><br></pre></td></tr></table></figure><p>如果是字符串返回字符串变量对应的值：</p><h2 id="实例-44">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">you.like&lt;-&quot;runoob&quot;  </span><br><span class="line">switch(you.like, google\=&quot;www.google.com&quot;, runoob \= &quot;www.runoob.com&quot;, taobao \= &quot;www.taobao.com&quot;)  </span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;www.runoob.com&quot;</span><br></pre></td></tr></table></figure><p>如果整数不在范围内的则返回 NULL</p><h2 id="实例-45">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\&gt; x &lt;- switch(4,&quot;google&quot;,&quot;runoob&quot;,&quot;taobao&quot;)  </span><br><span class="line">\&gt; x  </span><br><span class="line">NULL  </span><br><span class="line">\&gt; x &lt;- switch(4,&quot;google&quot;,&quot;runoob&quot;,&quot;taobao&quot;)  </span><br><span class="line">\&gt; x  </span><br><span class="line">NULL</span><br></pre></td></tr></table></figure><h2 id="R-循环">R 循环</h2><p>有的时候，我们可能需要多次执行同一块代码。一般情况下，语句是按顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。</p><p>编程语言提供了更为复杂执行路径的多种控制结构。</p><p>循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的流程图：</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/12/loop.png" alt="循环结构"></p><p>R 语言提供的循环类型有:</p><ul><li>repeat 循环</li><li>while 循环</li><li>for 循环</li></ul><p>R 语言提供的循环控制语句有：</p><ul><li>break 语句</li><li>Next 语句</li></ul><p>循环控制语句改变你代码的执行顺序，通过它你可以实现代码的跳转。</p><h2 id="循环类型">循环类型</h2><h3 id="repeat">repeat</h3><p>repeat 循环会一直执行代码，直到条件语句为 true 时才退出循环，退出要使用到 break 语句。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">repeat &#123; </span><br><span class="line">    // 相关代码 </span><br><span class="line">    if(condition) &#123;</span><br><span class="line">       break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下实例在变量 cnt 为 5 时退出循环，cnt 为计数变量：</p><h2 id="实例-46">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v &lt;- c(&quot;Google&quot;,&quot;Runoob&quot;)  </span><br><span class="line">cnt &lt;- 2</span><br><span class="line"></span><br><span class="line">repeat &#123;  </span><br><span class="line">   print(v)  </span><br><span class="line">   cnt &lt;- cnt+1</span><br><span class="line"></span><br><span class="line">       if(cnt \&gt; 5) &#123;  </span><br><span class="line">      break  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上代码，输入结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br></pre></td></tr></table></figure><h3 id="while">while</h3><p>只要给定的条件为 true，R 语言中的 while 循环语句会重复执行一个目标语句。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(condition)</span><br><span class="line">&#123;</span><br><span class="line">   statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，statement(s) 可以是一个单独的语句，也可以是几个语句组成的代码块。</p><p>condition 可以是任意的表达式，当为任意非零值时都为 true。当条件为 true 时执行循环。 当条件为 false 时，退出循环，程序流将继续执行紧接着循环的下一条语句。</p><p>以下实例在在变量 cnt 小于 7 时输出 while 语句块中的内容，cnt 为计数变量：</p><h2 id="实例-47">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v &lt;- c(&quot;Google&quot;,&quot;Runoob&quot;)  </span><br><span class="line">cnt &lt;- 2</span><br><span class="line"></span><br><span class="line">while (cnt &lt; 7) &#123;  </span><br><span class="line">   print(v)  </span><br><span class="line">   cnt \= cnt + 1  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上代码，输入结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br></pre></td></tr></table></figure><h3 id="for">for</h3><p>R 编程语言中 for 循环语句可以重复执行指定语句，重复次数可在 for 语句中控制。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (value in vector) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>R 语言的 for 循环特别灵活，不仅可以循环整数变量，还可以对字符向量，逻辑向量，列表等数据类型进行迭代。</p><p>以下实例输出 26 个字母对前面四个字母：</p><h2 id="实例-48">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v &lt;- LETTERS\[1:4\]  </span><br><span class="line">for ( i in v) &#123;  </span><br><span class="line">   print(i)  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>执行以上代码，输入结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;A&quot;</span><br><span class="line">[1] &quot;B&quot;</span><br><span class="line">[1] &quot;C&quot;</span><br><span class="line">[1] &quot;D&quot;</span><br></pre></td></tr></table></figure><hr><h2 id="循环控制">循环控制</h2><h3 id="break">break</h3><p>R 语言的 break 语句插入在循环体中，用于退出当前循环或语句，并开始脚本执行紧接着的语句。</p><p>如果你使用循环嵌套，break 语句将停止最内层循环的执行，并开始执行的外层的循环语句。</p><p>break 也常用于 switch 语句中。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break</span><br></pre></td></tr></table></figure><p>以下实例在变量 cnt 为 5 时使用 break 退出循环，cnt 为计数变量：</p><h2 id="实例-49">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v &lt;- c(&quot;Google&quot;,&quot;Runoob&quot;)  </span><br><span class="line">cnt &lt;- 2</span><br><span class="line"></span><br><span class="line">repeat &#123;  </span><br><span class="line">   print(v)  </span><br><span class="line">   cnt &lt;- cnt+1</span><br><span class="line"></span><br><span class="line">       if(cnt \&gt; 5) &#123;  </span><br><span class="line">      break  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上代码，输入结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br></pre></td></tr></table></figure><h3 id="next">next</h3><p>next 语句用于跳过当前循环，开始下一次循环（类似其他语言的 continue）。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next</span><br></pre></td></tr></table></figure><p>以下实例输出 26 个字母的前面 6 个字母，在字母为 D 的时候跳过当前的循环，进行下一次循环：</p><h2 id="实例-50">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v &lt;- LETTERS\[1:6\]  </span><br><span class="line">for ( i in v) &#123;</span><br><span class="line"></span><br><span class="line">       if (i \== &quot;D&quot;) &#123;  \# D 不会输出，跳过这次循环，进入下一次  </span><br><span class="line">      next  </span><br><span class="line">   &#125;  </span><br><span class="line">   print(i)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上代码，输入结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;A&quot;</span><br><span class="line">[1] &quot;B&quot;</span><br><span class="line">[1] &quot;C&quot;</span><br><span class="line">[1] &quot;E&quot;</span><br><span class="line">[1] &quot;F&quot;</span><br></pre></td></tr></table></figure><h2 id="R-函数">R 函数</h2><p>函数是一组一起执行一个任务的语句。R 语言本身提供了很多的内置函数，当然我们也可以自己创建函数。</p><p>您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</p><p>函数<strong>声明</strong>告诉编译器函数的名称、返回类型和参数。函数<strong>定义</strong>提供了函数的实际主体。</p><p>R 语言中函数是一个对象，可以拥有属性。</p><h2 id="定义函数">定义函数</h2><p>函数定义通常由以下几个部分组成：</p><ul><li><strong>函数名:</strong> 为函数指定一个唯一的名称，以便在调用时使用。</li><li><strong>参数:</strong> 定义函数接受的输入值。参数是可选的，可以有多个。</li><li><strong>函数体:</strong> 包含实际执行的代码块，用大括号 {} 括起来。</li><li><strong>返回值:</strong> 指定函数的输出结果，使用关键字<code>return</code>。</li></ul><p>R 语言中的函数定义使用 function 关键字，一般形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function_name &lt;- function(arg_1, arg_2, ...) &#123;</span><br><span class="line">    # 函数体</span><br><span class="line">    # 执行的代码块</span><br><span class="line">    return(output)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>function_name : 为函数名</li><li>arg_1, arg_2, … : 形式参数列表</li></ul><p>函数返回值使用 return()。</p><p>以下是一个简单的例子，展示如何定义和使用函数：</p><h2 id="实例-51">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\# 定义一个加法函数  </span><br><span class="line">add\_numbers &lt;- function(x, y) &#123;  </span><br><span class="line">  result &lt;- x + y  </span><br><span class="line">  return(result)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\# 调用函数  </span><br><span class="line">sum\_result &lt;- add\_numbers(3, 4)  </span><br><span class="line">print(sum\_result)  \# 输出 7</span><br></pre></td></tr></table></figure><p>以上代码中，我们定义了一个名为 <strong>add_numbers</strong> 的函数，它接受两个参数 <strong>x</strong> 和 <strong>y</strong>。函数体中的代码将这两个参数相加，并将结果存储在变量 <strong>result</strong> 中。最后，使用 <strong>return</strong> 关键字返回结果。</p><p>要调用函数，我们使用函数名后跟参数列表的形式，将参数的值传递给函数。在本例中，我们调用 <strong>add_numbers</strong> 函数，并传递参数 3 和 4。函数执行后，返回结果 7，我们将其存储在变量 <strong>sum_result</strong> 中，并打印输出。</p><h3 id="自定义函数">自定义函数</h3><p>我们可以自己创建函数，用于特定到功能，定义后可以向内置函数一样使用它们。</p><p>下面演示两如何自定义函数：</p><h2 id="实例-52">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\# 定义一个函数，用于计数一个系列到平方值  </span><br><span class="line">new.function &lt;- function(a) &#123;  </span><br><span class="line">   for(i in 1:a) &#123;  </span><br><span class="line">      b &lt;- i^2  </span><br><span class="line">      print(b)  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>接下来我们可以调用函数：</p><h2 id="实例-53">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new.function &lt;- function(a) &#123;  </span><br><span class="line">    for(i in 1:a) &#123;  </span><br><span class="line">       b &lt;- i^2  </span><br><span class="line">       print(b)  </span><br><span class="line">    &#125;  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  \# 调用函数，并传递参数  </span><br><span class="line">new.function(6)</span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1] 1</span><br><span class="line">[1] 4</span><br><span class="line">[1] 9</span><br><span class="line">[1] 16</span><br><span class="line">[1] 25</span><br><span class="line">[1] 36</span><br></pre></td></tr></table></figure><p>我们也可以创建一个不带参数的函数：</p><h2 id="实例-54">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new.function &lt;- function() &#123;  </span><br><span class="line">    for(i in 1:5) &#123;  </span><br><span class="line">        print(i^2)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  \# 调用函数，不需要传递参数  </span><br><span class="line">new.function()</span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1] 1</span><br><span class="line">[1] 4</span><br><span class="line">[1] 9</span><br><span class="line">[1] 16</span><br><span class="line">[1] 25</span><br></pre></td></tr></table></figure><h3 id="带有参数值的函数">带有参数值的函数</h3><p>函数参数，可以按函数创建时的顺序来传递，也可以不按顺序，但需要指定参数名：</p><h2 id="实例-55">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\# 创建函数  </span><br><span class="line">new.function &lt;- function(a,b,c) &#123;  </span><br><span class="line">   result &lt;- a \* b + c  </span><br><span class="line">   print(result)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\# 不带参数名  </span><br><span class="line">new.function(5,3,11)</span><br><span class="line"></span><br><span class="line">\# 带参数名  </span><br><span class="line">new.function(a \= 11, b \= 5, c \= 3)</span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1] 26</span><br><span class="line">[1] 58</span><br></pre></td></tr></table></figure><p>函数创建时也可以为参数指定默认值，如果调用的时候不传递参数就会使用默认值：</p><h2 id="实例-56">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\# 创建带默认参数的函数  </span><br><span class="line">new.function &lt;- function(a \= 3, b \= 6) &#123;  </span><br><span class="line">   result &lt;- a \* b  </span><br><span class="line">   print(result)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\# 调用函数，但不传递参数，会使用默认的  </span><br><span class="line">new.function()</span><br><span class="line"></span><br><span class="line">\# 调用函数，传递参数  </span><br><span class="line">new.function(9,5)</span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><p>[1] 18 [1] 45</p><h3 id="懒惰计算的函数">懒惰计算的函数</h3><p>懒惰计算将推迟计算工作直到系统需要这些计算的结果。如果不需要结果，将不用进行计算。</p><p>默认情况下，R 函数对参数的计算是懒惰的，就是只有我们在计算它的时候才会调用：</p><h2 id="实例-57">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(x) &#123;  </span><br><span class="line">  10  </span><br><span class="line">&#125;  </span><br><span class="line">f()  </span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] 10</span><br></pre></td></tr></table></figure><p>以上代码执行，并没有报错，虽然我们没有传入参数，但函数体内没有使用参数 x，所以不会去调用它，也不会报错。</p><h2 id="实例-58">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new.function &lt;- function(a, b) &#123;  </span><br><span class="line">   print(a^2)  </span><br><span class="line">   print(a)  </span><br><span class="line">   print(b)  \# 使用到 b，但未传入，所以会报错  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\# 传入一个参数  </span><br><span class="line">new.function(6)</span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1] 36</span><br><span class="line">[1] 6</span><br><span class="line">Error in print(b) : 缺少参数&quot;b&quot;,也没有缺省值</span><br><span class="line">Calls: new.function -&gt; print</span><br><span class="line">停止执行</span><br></pre></td></tr></table></figure><hr><h2 id="内置函数">内置函数</h2><p>R 语言提供了很多有用的内置函数，我们无需定义它就可以直接使用。</p><p>例如：seq(), mean(), max(), sum(x) 以及 paste(…) 等。</p><h2 id="实例-59">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\# 输出  32 到 44 到的所有数字  </span><br><span class="line">print(seq(32,44))</span><br><span class="line"></span><br><span class="line">\# 计算两个数的平均数  </span><br><span class="line">print(mean(25:82))</span><br><span class="line"></span><br><span class="line">\# 计算 41 到 68 所有数字之和  </span><br><span class="line">print(sum(41:68))</span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> [1] 32 33 34 35 36 37 38 39 40 41 42 43 44</span><br><span class="line">[1] 53.5</span><br><span class="line">[1] 1526</span><br></pre></td></tr></table></figure><p>sum(): 计算向量或矩阵的总和。</p><h2 id="实例-60">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\# 向量求和  </span><br><span class="line">x &lt;- c(1, 2, 3, 4, 5)  </span><br><span class="line">total &lt;- sum(x)  </span><br><span class="line">print(total)  \# 输出 15</span><br><span class="line"></span><br><span class="line">\# 矩阵求和  </span><br><span class="line">matrix &lt;- matrix(1:9, nrow \= 3)  </span><br><span class="line">total &lt;- sum(matrix)  </span><br><span class="line">print(total)  \# 输出 45</span><br></pre></td></tr></table></figure><p>mean(): 计算向量或矩阵的平均值。</p><h2 id="实例-61">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\# 向量平均值  </span><br><span class="line">x &lt;- c(1, 2, 3, 4, 5)  </span><br><span class="line">avg &lt;- mean(x)  </span><br><span class="line">print(avg)  \# 输出 3</span><br><span class="line"></span><br><span class="line">\# 矩阵平均值  </span><br><span class="line">matrix &lt;- matrix(1:9, nrow \= 3)  </span><br><span class="line">avg &lt;- mean(matrix)  </span><br><span class="line">print(avg)  \# 输出 5</span><br></pre></td></tr></table></figure><p>paste(): 将多个字符串连接成一个字符串。</p><h2 id="实例-62">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- &quot;Hello&quot;  </span><br><span class="line">y &lt;- &quot;World&quot;  </span><br><span class="line">result &lt;- paste(x, y)  </span><br><span class="line">print(result)  \# 输出 &quot;Hello World&quot;  </span><br></pre></td></tr></table></figure><p>length(): 返回向量的长度或对象的元素个数。</p><h2 id="实例-63">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(1, 2, 3, 4, 5)  </span><br><span class="line">length\_x &lt;- length(x)  </span><br><span class="line">print(length\_x)  \# 输出 5</span><br><span class="line"></span><br><span class="line">matrix &lt;- matrix(1:9, nrow \= 3)  </span><br><span class="line">length\_matrix &lt;- length(matrix)  </span><br><span class="line">print(length\_matrix)  \# 输出 9</span><br></pre></td></tr></table></figure><p>str(): 显示对象的结构和内容摘要。</p><h2 id="实例-64">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(1, 2, 3, 4, 5)  </span><br><span class="line">str(x)  </span><br><span class="line">\# 输出：  </span><br><span class="line">\# num \[1:5\] 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">matrix &lt;- matrix(1:9, nrow \= 3)  </span><br><span class="line">str(matrix)  </span><br><span class="line">\# 输出：  </span><br><span class="line">\#  int \[1:3, 1:3\] 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>以上只列举了一小部分的 R 语言函数实例，R 有大量的内置函数和扩展包提供的函数，可以满足各种数据处理、统计分析、绘图等需求，您可以查阅 R 语言的官方文档获得更详细的函数列表和使用说明。</p><h2 id="R-字符串">R 字符串</h2><p>R 语言中，字符串是一种表示文本数据的数据类型，它由字符（字符向量）组成，可以包含字母、数字、符号和空格等字符。</p><p>R 语言字符串可以使用一对单引号 ’ ’ 或一对双引号 &quot; &quot; 来表示。</p><ul><li>单引号字符串中可以包含双引号。</li><li>单引号字符串中不可以包含单引号。</li><li>双引号字符串中可以包含单引号。</li><li>双引号字符串中不可以包含双引号。</li></ul><p>**创建字符串：**您可以使用单引号或双引号来创建字符串。</p><p>以下实例演示来字符串的使用：</p><h2 id="实例-65">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- &#x27;使用单引号&#x27;  </span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">b &lt;- &quot;使用双引号&quot;  </span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">c &lt;- &quot;双引号字符串中可以包含单引号（&#x27;） &quot;  </span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">d &lt;- &#x27;单引号字符串中可以包含双引号（&quot;） &#x27;  </span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;使用单引号&quot;</span><br><span class="line">[1] &quot;使用双引号&quot;</span><br><span class="line">[1] &quot;双引号字符串中可以包含单引号（&#x27;） &quot;</span><br><span class="line">[1] &quot;单引号字符串中可以包含双引号（\&quot;） &quot;</span><br></pre></td></tr></table></figure><hr><h2 id="字符串操作">字符串操作</h2><p>R 语言提供了多种操作字符串的函数和操作符，使得处理和操作文本数据变得方便。</p><p>以下我们来看下 R 语言一些内置函数对字符串对操作。</p><h3 id="paste-函数">paste() 函数</h3><p>paste() 函数用于使用指定对分隔符来对字符串进行连接，默认的分隔符为空格。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste(..., sep = &quot; &quot;, collapse = NULL)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>… ： 字符串列表</li><li>sep ： 分隔符，默认为空格</li><li>collapse ： 两个或者更多字符串对象根据元素对应关系拼接到一起，在字符串进行连接后，再使用 collapse 指定对连接符进行连接</li></ul><h2 id="实例-66">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- &quot;Google&quot;  </span><br><span class="line">b &lt;- &#x27;Runoob&#x27;  </span><br><span class="line">c &lt;- &quot;Taobao&quot;</span><br><span class="line"></span><br><span class="line">print(paste(a,b,c))</span><br><span class="line"></span><br><span class="line">print(paste(a,b,c, sep \= &quot;-&quot;))</span><br><span class="line"></span><br><span class="line">print(paste(letters\[1:6\],1:6, sep \= &quot;&quot;, collapse \= &quot;=&quot;))  </span><br><span class="line">paste(letters\[1:6\],1:6, collapse \= &quot;.&quot;)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;Google Runoob Taobao&quot;</span><br><span class="line">[1] &quot;Google-Runoob-Taobao&quot;</span><br><span class="line">[1] &quot;a1=b2=c3=d4=e5=f6&quot;</span><br><span class="line">[1] &quot;a 1.b 2.c 3.d 4.e 5.f 6&quot;</span><br></pre></td></tr></table></figure><h3 id="format-函数">format() 函数</h3><p>format() 函数用于格式化字符串，format() 可作用于字符串或数字。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">format(x, digits, nsmall, scientific, width, justify = c(&quot;left&quot;, &quot;right&quot;, &quot;centre&quot;, &quot;none&quot;)) </span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>x ： 输入对向量</li><li>digits ： 显示的位数</li><li>nsmall ： 小数点右边显示的最少位数</li><li>scientific ： 设置科学计数法</li><li>width ： 通过开头填充空白来显示最小的宽度</li><li>justify：设置位置，显示可以是左边、右边、中间等。</li></ul><h2 id="实例-67">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">\# 显示 9 位，最后一位四舍五入  </span><br><span class="line">result &lt;- format(23.123456789, digits \= 9)  </span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">\# 使用科学计数法显示  </span><br><span class="line">result &lt;- format(c(6, 13.14521), scientific \= TRUE)  </span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">\# 小数点右边最小显示 5 位，没有的以 0 补充  </span><br><span class="line">result &lt;- format(23.47, nsmall \= 5)  </span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">\# 将数字转为字符串  </span><br><span class="line">result &lt;- format(6)  </span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">\# 宽度为 6 位，不够的在开头添加空格  </span><br><span class="line">result &lt;- format(13.7, width \= 6)  </span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">\# 左对齐字符串  </span><br><span class="line">result &lt;- format(&quot;Runoob&quot;, width \= 9, justify \= &quot;l&quot;)  </span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">\# 居中显示  </span><br><span class="line">result &lt;- format(&quot;Runoob&quot;, width \= 10, justify \= &quot;c&quot;)  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;23.1234568&quot;</span><br><span class="line">[1] &quot;6.000000e+00&quot; &quot;1.314521e+01&quot;</span><br><span class="line">[1] &quot;23.47000&quot;</span><br><span class="line">[1] &quot;6&quot;</span><br><span class="line">[1] &quot;  13.7&quot;</span><br><span class="line">[1] &quot;Runoob   &quot;</span><br><span class="line">[1] &quot;  Runoob  &quot;</span><br></pre></td></tr></table></figure><h3 id="nchar-函数">nchar() 函数</h3><p>nchar() 函数用于计数字符串或数字列表的长度。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nchar(x)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>x ： 向量或字符串</li></ul><h2 id="实例-68">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result &lt;- nchar(&quot;Google Runoob Taobao&quot;)  </span><br><span class="line">print(result)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] 20</span><br></pre></td></tr></table></figure><h3 id="toupper-tolower-函数">toupper() &amp; tolower() 函数</h3><p>toupper() &amp; tolower() 函数用于将字符串的字母转化为大写或者小写。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toupper(x)</span><br><span class="line">tolower(x)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>x ： 向量或字符串</li></ul><p># 转大写</p><h2 id="实例-69">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result &lt;- toupper(&quot;Runoob&quot;)  </span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">\# 转小写  </span><br><span class="line">result &lt;- tolower(&quot;Runoob&quot;)  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;RUNOOB&quot;</span><br><span class="line">[1] &quot;runoob&quot;</span><br></pre></td></tr></table></figure><h3 id="substring-函数">substring() 函数</h3><p>substring() 函数用于截取字符串。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">substring(x,first,last)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>x ： 向量或字符串</li><li>first ： 开始截取的位置</li><li>last： 结束截取的位置</li></ul><h2 id="实例-70">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\# 从第 2 位截取到第 5 位  </span><br><span class="line">result &lt;- substring(&quot;Runoob&quot;, 2, 5)  </span><br><span class="line">print(result)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;unoo&quot;</span><br></pre></td></tr></table></figure><h3 id="字符串替换">字符串替换</h3><p>使用 <strong>gsub()</strong> 函数来替换字符串中的特定字符或模式。</p><h2 id="实例-71">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str &lt;- &quot;Hello, World!&quot;  </span><br><span class="line">new\_str &lt;- gsub(&quot;World&quot;, &quot;R&quot;, str)  </span><br><span class="line">\# 输出： &quot;Hello, R!&quot;  </span><br></pre></td></tr></table></figure><h3 id="字符串拆分">字符串拆分</h3><p>使用 <strong>strsplit()</strong> 函数将字符串拆分为子字符串。</p><h2 id="实例-72">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str &lt;- &quot;Hello, World!&quot;  </span><br><span class="line">split\_str &lt;- strsplit(str, &quot;,&quot;)  </span><br><span class="line">\# 输出： List of 1  </span><br><span class="line">\#         \[\[1\]\]  </span><br><span class="line">\#         \[1\] &quot;Hello&quot;   &quot; World!&quot;  </span><br></pre></td></tr></table></figure><p>以上只列举了一小部分的 R 语言字符串操作实例，R 有大量的字符串处理函数和操作符，例如模式匹配、大小写转换、字符串比较等，您可以查阅 R 语言的官方文档获得更多字符串操作函数列表和使用说明。</p><h2 id="R-列表">R 列表</h2><p>列表是 R 语言的对象集合，可以用来保存不同类型的数据，可以是数字、字符串、向量、另一个列表、矩阵、数据框等，当然还可以包含矩阵和函数。</p><p>列表是一种灵活的数据结构，可以存储和操作多种类型的数据对象。</p><h3 id="创建列表">创建列表</h3><p>R 语言创建列表使用 list() 函数。</p><p>如下实例，我们创建一个列表，包含了字符串、向量和数字：</p><h2 id="实例-73">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list\_data &lt;- list(&quot;runoob&quot;, &quot;google&quot;, c(11,22,33), 123, 51.23, 119.1)  </span><br><span class="line">print(list\_data)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[[1]]</span><br><span class="line">[1] &quot;runoob&quot;</span><br><span class="line"></span><br><span class="line">[[2]]</span><br><span class="line">[1] &quot;google&quot;</span><br><span class="line"></span><br><span class="line">[[3]]</span><br><span class="line">[1] 11 22 33</span><br><span class="line"></span><br><span class="line">[[4]]</span><br><span class="line">[1] 123</span><br><span class="line"></span><br><span class="line">[[5]]</span><br><span class="line">[1] 51.23</span><br><span class="line"></span><br><span class="line">[[6]]</span><br><span class="line">[1] 119.1</span><br></pre></td></tr></table></figure><p>我们也可以使用 c() 函数来创建列表，也可以使用该函数将多个对象合并为一个列表，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_list &lt;- c(object1, object2, object3)</span><br></pre></td></tr></table></figure><h2 id="实例-74">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\# 创建包含数字的向量  </span><br><span class="line">numbers &lt;- c(1, 2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line">\# 创建包含字符的向量  </span><br><span class="line">characters &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;)</span><br><span class="line"></span><br><span class="line">\# 合并两个数字向量  </span><br><span class="line">merged\_vector &lt;- c(numbers, c(6, 7, 8))</span><br><span class="line"></span><br><span class="line">\# 合并两个字符向量  </span><br><span class="line">merged\_characters &lt;- c(characters, c(&quot;grape&quot;, &quot;melon&quot;))</span><br></pre></td></tr></table></figure><p>我们可以使用 names() 函数给列表的元素命名：</p><h2 id="实例-75">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\# 列表包含向量、矩阵、列表  </span><br><span class="line">list\_data &lt;- list(c(&quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;), matrix(c(1,2,3,4,5,6), nrow \= 2),  </span><br><span class="line">   list(&quot;runoob&quot;,12.3))</span><br><span class="line"></span><br><span class="line">\# 给列表元素设置名字  </span><br><span class="line">names(list\_data) &lt;- c(&quot;Sites&quot;, &quot;Numbers&quot;, &quot;Lists&quot;)</span><br><span class="line"></span><br><span class="line">\# 显示列表  </span><br><span class="line">print(list\_data)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$Sites</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot; &quot;Taobao&quot;</span><br><span class="line"></span><br><span class="line">$Numbers</span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    1    3    5</span><br><span class="line">[2,]    2    4    6</span><br><span class="line"></span><br><span class="line">$Lists</span><br><span class="line">$Lists[[1]]</span><br><span class="line">[1] &quot;runoob&quot;</span><br><span class="line"></span><br><span class="line">$Lists[[2]]</span><br><span class="line">[1] 12.3</span><br></pre></td></tr></table></figure><h3 id="访问列表">访问列表</h3><p>列表中的元素可以使用索引来访问，如果使用来 <strong>names()</strong> 函数命名后，我们还可以使用对应名字来访问：</p><h2 id="实例-76">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">\# 列表包含向量、矩阵、列表  </span><br><span class="line">list\_data &lt;- list(c(&quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;), matrix(c(1,2,3,4,5,6), nrow \= 2),  </span><br><span class="line">   list(&quot;runoob&quot;,12.3))</span><br><span class="line"></span><br><span class="line">\# 给列表元素设置名字  </span><br><span class="line">names(list\_data) &lt;- c(&quot;Sites&quot;, &quot;Numbers&quot;, &quot;Lists&quot;)</span><br><span class="line"></span><br><span class="line">\# 显示列表  </span><br><span class="line">print(list\_data\[1\])</span><br><span class="line"></span><br><span class="line">\# 访问列表的第三个元素  </span><br><span class="line">print(list\_data\[3\])</span><br><span class="line"></span><br><span class="line">\# 访问第一个向量元素  </span><br><span class="line">print(list\_data$Numbers)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$Sites</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot; &quot;Taobao&quot;</span><br><span class="line"></span><br><span class="line">$Lists</span><br><span class="line">$Lists[[1]]</span><br><span class="line">[1] &quot;runoob&quot;</span><br><span class="line"></span><br><span class="line">$Lists[[2]]</span><br><span class="line">[1] 12.3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    1    3    5</span><br><span class="line">[2,]    2    4    6</span><br></pre></td></tr></table></figure><h3 id="操作列表元素">操作列表元素</h3><p>我们可以对列表进行添加、删除、更新的操作，如下实例：</p><h2 id="实例-77">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">\# 列表包含向量、矩阵、列表  </span><br><span class="line">list\_data &lt;- list(c(&quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;), matrix(c(1,2,3,4,5,6), nrow \= 2),  </span><br><span class="line">   list(&quot;runoob&quot;,12.3))</span><br><span class="line"></span><br><span class="line">\# 给列表元素设置名字  </span><br><span class="line">names(list\_data) &lt;- c(&quot;Sites&quot;, &quot;Numbers&quot;, &quot;Lists&quot;)</span><br><span class="line"></span><br><span class="line">\# 添加元素  </span><br><span class="line">list\_data\[4\] &lt;- &quot;新元素&quot;  </span><br><span class="line">print(list\_data\[4\])</span><br><span class="line"></span><br><span class="line">\# 删除元素  </span><br><span class="line">list\_data\[4\] &lt;- NULL</span><br><span class="line"></span><br><span class="line">\# 删除后输出为 NULL  </span><br><span class="line">print(list\_data\[4\])</span><br><span class="line"></span><br><span class="line">\# 更新元素  </span><br><span class="line">list\_data\[3\] &lt;- &quot;我替换来第三个元素&quot;  </span><br><span class="line">print(list\_data\[3\])</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[1]]</span><br><span class="line">[1] &quot;新元素&quot;</span><br><span class="line"></span><br><span class="line">$&lt;NA&gt;</span><br><span class="line">NULL</span><br><span class="line"></span><br><span class="line">$Lists</span><br><span class="line">[1] &quot;我替换来第三个元素&quot;</span><br></pre></td></tr></table></figure><p>使用 for 循环遍历列表时：</p><h2 id="实例-78">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\# 创建一个包含数字和字符的列表  </span><br><span class="line">my\_list &lt;- list(1, 2, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</span><br><span class="line"></span><br><span class="line">\# 使用 for 循环遍历列表中的每个元素  </span><br><span class="line">for (element in my\_list) &#123;  </span><br><span class="line">  print(element)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，for 循环会依次遍历列表 my_list 中的每个元素，并将每个元素存储在变量 element 中。然后，我们可以在循环体内对每个元素执行特定的操作，例如使用 print() 函数打印元素的值。</p><p>for 循环遍历列表时，每次循环都将当前元素赋值给变量 element。因此，在循环体内可以对 element 进行任何需要的操作，例如计算、条件判断等。</p><p>需要注意的是，使用 for 循环遍历列表时，循环变量 element 将依次取到列表中的每个元素，但不能直接修改列表元素本身。如果需要修改列表中的元素值，可以通过索引来实现，例如 my_list[[index]] &lt;- new_value。</p><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1] 1</span><br><span class="line">[1] 2</span><br><span class="line">[1] 3</span><br><span class="line">[1] &quot;a&quot;</span><br><span class="line">[1] &quot;b&quot;</span><br><span class="line">[1] &quot;c&quot;</span><br></pre></td></tr></table></figure><h3 id="合并列表">合并列表</h3><p>我们可以使用 c() 函数将多个列表合并为一个列表：</p><h2 id="实例-79">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\# 创建两个列表  </span><br><span class="line">list1 &lt;- list(1,2,3)  </span><br><span class="line">list2 &lt;- list(&quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;)</span><br><span class="line"></span><br><span class="line">\# 合并列表  </span><br><span class="line">merged.list &lt;- c(list1,list2)</span><br><span class="line"></span><br><span class="line">\# 显示合并后的列表  </span><br><span class="line">print(merged.list)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[[1]]</span><br><span class="line">[1] 1</span><br><span class="line"></span><br><span class="line">[[2]]</span><br><span class="line">[1] 2</span><br><span class="line"></span><br><span class="line">[[3]]</span><br><span class="line">[1] 3</span><br><span class="line"></span><br><span class="line">[[4]]</span><br><span class="line">[1] &quot;Google&quot;</span><br><span class="line"></span><br><span class="line">[[5]]</span><br><span class="line">[1] &quot;Runoob&quot;</span><br><span class="line"></span><br><span class="line">[[6]]</span><br><span class="line">[1] &quot;Taobao&quot;</span><br></pre></td></tr></table></figure><h3 id="列表转换为向量">列表转换为向量</h3><p>要将列表转换为向量可以使用 unlist() 函数，将列表转换为向量，可以方便我们进行算术运算：</p><h2 id="实例-80">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">\# 创建列表  </span><br><span class="line">list1 &lt;- list(1:5)  </span><br><span class="line">print(list1)</span><br><span class="line"></span><br><span class="line">list2 &lt;-list(10:14)  </span><br><span class="line">print(list2)</span><br><span class="line"></span><br><span class="line">\# 转换为向量  </span><br><span class="line">v1 &lt;- unlist(list1)  </span><br><span class="line">v2 &lt;- unlist(list2)</span><br><span class="line"></span><br><span class="line">print(v1)  </span><br><span class="line">print(v2)</span><br><span class="line"></span><br><span class="line">\# 两个向量相加  </span><br><span class="line">result &lt;- v1+v2  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[1]]</span><br><span class="line">[1] 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">[[1]]</span><br><span class="line">[1] 10 11 12 13 14</span><br><span class="line"></span><br><span class="line">[1] 1 2 3 4 5</span><br><span class="line">[1] 10 11 12 13 14</span><br><span class="line">[1] 11 13 15 17 19</span><br></pre></td></tr></table></figure><h3 id="归纳总结">归纳总结</h3><p>以下是一些常用的 R 语言列表操作和函数：</p><p><strong>创建列表：</strong></p><ul><li>使用 c() 函数：例如，list1 &lt;- c(1, 2, 3) 创建一个包含 1、2 和 3 的列表。</li><li>使用 list() 函数：例如，list2 &lt;- list(1, “a”, TRUE) 创建一个包含不同类型元素的列表。</li></ul><p><strong>访问列表元素：</strong></p><ul><li>使用索引：通过索引访问列表中的元素。例如，list1[1] 返回列表中的第一个元素。</li><li>使用元素名称：如果列表中的元素有名称，可以使用名称来访问它们。例如，list3 &lt;- list(a = 1, b = 2) 可以通过 list3a 和 list3b 来访问元素。</li></ul><p><strong>列表操作：</strong></p><ul><li>长度：使用 length() 函数获取列表的长度。例如，length(list1) 返回列表 list1 的长度。</li><li>合并：使用 c() 函数或 append() 函数将两个或多个列表合并为一个列表。例如，list4 &lt;- c(list1, list2) 合并列表 list1 和 list2。</li><li>增加元素：使用 c() 函数将元素添加到现有列表中。例如，list1 &lt;- c(list1, 4) 将 4 添加到列表 list1 的末尾。</li><li>删除元素：使用索引和负索引操作符 - 删除列表中的元素。例如，list1 &lt;- list1[-2] 删除列表 list1 中的第二个元素。</li></ul><p><strong>列表循环：</strong></p><ul><li>for 循环：使用 for 循环遍历列表中的元素。例如，for (element in list1) { … } 遍历列表 list1 中的每个元素。</li><li>lapply() 函数：将一个函数应用于列表中的每个元素，并返回结果列表。例如，new_list &lt;- lapply(list1, function(x) x * 2) 将列表 list1 中的每个元素乘以 2。</li></ul><h2 id="R-矩阵">R 矩阵</h2><p>R 语言为线性代数的研究提供了矩阵类型，这种数据结构很类似于其它语言中的二维数组，但 R 提供了语言级的矩阵运算支持。</p><p>矩阵里的元素可以是数字、符号或数学式。</p><p>一个 M x N 的矩阵是一个由 <strong>M（row） 行</strong> 和 **N 列（column）**元素排列成的矩形阵列。</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/Matrix_zh-hans.png" alt=""></p><p>以下是一个由 6 个数字元素构成的 2 行 3 列的矩阵：</p><p><img src="https://static.jyshare.com/images/mix/61f786996bcfb75972dd77712c90122bc8765269.svg" alt=""></p><p>R 语言的矩阵可以使用 matrix() 函数来创建，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE,dimnames = NULL)</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><p><strong>data</strong> 向量，矩阵的数据</p></li><li><p><strong>nrow</strong> 行数</p></li><li><p><strong>ncol</strong> 列数</p></li><li><p><strong>byrow</strong> 逻辑值，为 FALSE 按列排列，为 TRUE 按行排列</p></li><li><p><strong>dimname</strong> 设置行和列的名称</p></li></ul><p>创建一个数字矩阵：</p><h2 id="实例-81">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\# byrow 为 TRUE 元素按行排列  </span><br><span class="line">M &lt;- matrix(c(3:14), nrow \= 4, byrow \= TRUE)  </span><br><span class="line">print(M)</span><br><span class="line"></span><br><span class="line">\# Ebyrow 为 FALSE 元素按列排列  </span><br><span class="line">N &lt;- matrix(c(3:14), nrow \= 4, byrow \= FALSE)  </span><br><span class="line">print(N)</span><br><span class="line"></span><br><span class="line">\# 定义行和列的名称  </span><br><span class="line">rownames \= c(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;, &quot;row4&quot;)  </span><br><span class="line">colnames \= c(&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;)</span><br><span class="line"></span><br><span class="line">P &lt;- matrix(c(3:14), nrow \= 4, byrow \= TRUE, dimnames \= list(rownames, colnames))  </span><br><span class="line">print(P)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[,1] [,2] [,3]</span><br><span class="line">[1,]    3    4    5</span><br><span class="line">[2,]    6    7    8</span><br><span class="line">[3,]    9   10   11</span><br><span class="line">[4,]   12   13   14</span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    3    7   11</span><br><span class="line">[2,]    4    8   12</span><br><span class="line">[3,]    5    9   13</span><br><span class="line">[4,]    6   10   14</span><br><span class="line">     col1 col2 col3</span><br><span class="line">row1    3    4    5</span><br><span class="line">row2    6    7    8</span><br><span class="line">row3    9   10   11</span><br><span class="line">row4   12   13   14</span><br></pre></td></tr></table></figure><h3 id="转置矩阵">转置矩阵</h3><p>R 语言矩阵提供了 t() 函数，可以实现矩阵的行列互换。</p><p>例如有个 m 行 n 列的矩阵，使用 t() 函数就能转换为 n 行 m 列的矩阵。</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/Matrix_transpose.gif" alt=""></p><p><img src="https://static.jyshare.com/images/mix/4a92835c45d5cd15dd00a8d90c14bdb4b8150ef0.svg" alt=""></p><p><img src="https://static.jyshare.com/images/mix/8a1e10800e0d0e3ffa90917139532cfb8348fc63.svg" alt=""></p><h2 id="实例-82">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\# 创建一个 2 行 3 列的矩阵  </span><br><span class="line">M \= matrix( c(2,6,5,1,10,4), nrow \= 2,ncol \= 3,byrow \= TRUE)  </span><br><span class="line">print(M)  </span><br><span class="line">     \[,1\] \[,2\] \[,3\]  </span><br><span class="line">\[1,\]    2    6    5  </span><br><span class="line">\[2,\]    1   10    4  </span><br><span class="line">\# 转换为 3 行 2 列的矩阵  </span><br><span class="line">print(t(M))  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    2    6    5</span><br><span class="line">[2,]    1   10    4</span><br><span class="line">[1] &quot;-----转换-----&quot;</span><br><span class="line">     [,1] [,2]</span><br><span class="line">[1,]    2    1</span><br><span class="line">[2,]    6   10</span><br><span class="line">[3,]    5    4</span><br></pre></td></tr></table></figure><h3 id="访问矩阵元素">访问矩阵元素</h3><p>如果想获取矩阵元素，可以通过使用元素的列索引和行索引，类似坐标形式。</p><h2 id="实例-83">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">\# 定义行和列的名称  </span><br><span class="line">rownames \= c(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;, &quot;row4&quot;)  </span><br><span class="line">colnames \= c(&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;)</span><br><span class="line"></span><br><span class="line">\# 创建矩阵  </span><br><span class="line">P &lt;- matrix(c(3:14), nrow \= 4, byrow \= TRUE, dimnames \= list(rownames, colnames))  </span><br><span class="line">print(P)  </span><br><span class="line">\# 获取第一行第三列的元素  </span><br><span class="line">print(P\[1,3\])</span><br><span class="line"></span><br><span class="line">\# 获取第四行第二列的元素  </span><br><span class="line">print(P\[4,2\])</span><br><span class="line"></span><br><span class="line">\# 获取第二行  </span><br><span class="line">print(P\[2,\])</span><br><span class="line"></span><br><span class="line">\# 获取第三列  </span><br><span class="line">print(P\[,3\])</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">col1 col2 col3</span><br><span class="line">row1    3    4    5</span><br><span class="line">row2    6    7    8</span><br><span class="line">row3    9   10   11</span><br><span class="line">row4   12   13   14</span><br><span class="line">[1] 5</span><br><span class="line">[1] 13</span><br><span class="line">col1 col2 col3 </span><br><span class="line">    6    7    8 </span><br><span class="line">row1 row2 row3 row4 </span><br><span class="line">    5    8   11   14 </span><br></pre></td></tr></table></figure><h3 id="矩阵计算">矩阵计算</h3><p>大小相同（行数列数都相同）的矩阵之间可以相互加减，具体是对每个位置上的元素做加减法。矩阵的乘法则较为复杂。两个矩阵可以相乘，当且仅当第一个矩阵的列数等于第二个矩阵的行数。</p><h3 id="矩阵加减法">矩阵加减法</h3><h2 id="实例-84">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">\# 创建 2 行 3 列的矩阵  </span><br><span class="line">matrix1 &lt;- matrix(c(7, 9, \-1, 4, 2, 3), nrow \= 2)  </span><br><span class="line">print(matrix1)</span><br><span class="line"></span><br><span class="line">matrix2 &lt;- matrix(c(6, 1, 0, 9, 3, 2), nrow \= 2)  </span><br><span class="line">print(matrix2)</span><br><span class="line"></span><br><span class="line">\# 两个矩阵相加  </span><br><span class="line">result &lt;- matrix1 + matrix2  </span><br><span class="line">cat(&quot;相加结果：&quot;,&quot;\\n&quot;)  </span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">\# 两个矩阵相减  </span><br><span class="line">result &lt;- matrix1 \- matrix2  </span><br><span class="line">cat(&quot;相减结果：&quot;,&quot;\\n&quot;)  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[,1] [,2] [,3]</span><br><span class="line">[1,]    7   -1    2</span><br><span class="line">[2,]    9    4    3</span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    6    0    3</span><br><span class="line">[2,]    1    9    2</span><br><span class="line">相加结果： </span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]   13   -1    5</span><br><span class="line">[2,]   10   13    5</span><br><span class="line">相减结果： </span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    1   -1   -1</span><br><span class="line">[2,]    8   -5    1</span><br></pre></td></tr></table></figure><h3 id="矩阵乘除法">矩阵乘除法</h3><h2 id="实例-85">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">\# 创建 2 行 3 列的矩阵  </span><br><span class="line">matrix1 &lt;- matrix(c(7, 9, \-1, 4, 2, 3), nrow \= 2)  </span><br><span class="line">print(matrix1)</span><br><span class="line"></span><br><span class="line">matrix2 &lt;- matrix(c(6, 1, 0, 9, 3, 2), nrow \= 2)  </span><br><span class="line">print(matrix2)</span><br><span class="line"></span><br><span class="line">\# 两个矩阵相乘  </span><br><span class="line">result &lt;- matrix1 \* matrix2  </span><br><span class="line">cat(&quot;相乘结果：&quot;,&quot;\\n&quot;)  </span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">\# 两个矩阵相除  </span><br><span class="line">result &lt;- matrix1 / matrix2  </span><br><span class="line">cat(&quot;相除结果：&quot;,&quot;\\n&quot;)  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[,1] [,2] [,3]</span><br><span class="line">[1,]    7   -1    2</span><br><span class="line">[2,]    9    4    3</span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    6    0    3</span><br><span class="line">[2,]    1    9    2</span><br><span class="line">相乘结果： </span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]   42    0    6</span><br><span class="line">[2,]    9   36    6</span><br><span class="line">相除结果： </span><br><span class="line">         [,1]      [,2]      [,3]</span><br><span class="line">[1,] 1.166667      -Inf 0.6666667</span><br><span class="line">[2,] 9.000000 0.4444444 1.5000000</span><br></pre></td></tr></table></figure><h2 id="R-数组">R 数组</h2><p>数组也是 R 语言的对象，R 语言可以创建一维或多维数组。</p><p>R 语言数组是一个同一类型的集合，前面我们学的矩阵 matrix 其实就是一个二维数组。</p><p>向量、矩阵、数组关系可以看下图：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/2039-08-06Done.png" alt=""></p><p>R 语言数组创建使用 array() 函数，该函数使用向量作为输入参数，可以使用 dim 设置数组维度。</p><p>array() 函数语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array(data = NA, dim = length(data), dimnames = NULL)</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><strong>data</strong> - 指定数组的数据源，可以是一个向量、矩阵或列表。</li><li><strong>dim</strong> - 指定数组的维度，可以是一个整数向量或一个表示维度的元组，默认是一维数组。例如，dim = c(2, 3, 4) 表示创建一个 <strong>2x3x4</strong> 的三维数组。</li><li><strong>dimnames</strong> - 可选参数，用于指定数组每个维度的名称，可以是一个包含维度名称的列表。</li></ul><p>在 R 中，数组索引是从 1 开始的，与其他编程语言的习惯有所不同。</p><p>此外，R 还提供了丰富的函数和操作符用于处理数组数据，如索引、切片、重塑、聚合等。</p><p>在 R 中，可以使用<a href="https://www.runoob.com/r/r-matrix.html">矩阵（Matrix）</a>或<a href="https://www.runoob.com/r/r-list.html">列表（List）</a>来表示多维数组。</p><p>**矩阵（Matrix）：**矩阵是 R 中最常用的表示数组的形式，它是一个二维的结构，具有固定的行数和列数。</p><p>可以使用 matrix() 函数创建矩阵，指定数据元素和维度。</p><h2 id="实例-86">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\# 创建一个3x3的矩阵  </span><br><span class="line">my\_matrix &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow \= 3, ncol \= 3)  </span><br><span class="line">print(my\_matrix)  </span><br></pre></td></tr></table></figure><p><strong>列表（List）</strong>：列表是 R 中更通用的多维数组形式，它可以包含不同类型的元素，并且每个元素可以是一个矩阵、向量或其他数据结构。</p><h2 id="实例-87">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\# 创建一个包含矩阵和向量的列表  </span><br><span class="line">my\_list &lt;- list(matrix(c(1, 2, 3, 4), nrow \= 2), c(5, 6, 7))  </span><br><span class="line">print(my\_list)  </span><br></pre></td></tr></table></figure><h2 id="实例-88">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\# 创建一个包含矩阵和向量的列表  </span><br><span class="line">my\_list &lt;- list(matrix(c(1, 2, 3, 4), nrow \= 2), c(5, 6, 7))  </span><br><span class="line">print(my\_list)  </span><br></pre></td></tr></table></figure><p>除了矩阵和列表，R 还提供了其他数据结构来表示多维数组，如数组（Array）和数据帧（Data Frame）。</p><h3 id="实例-89">实例</h3><p>下面是一些示例来演示 <strong>array()</strong> 函数的使用：</p><p>使用向量创建一维数组：</p><h2 id="实例-90">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my\_vector &lt;- c(1, 2, 3, 4)  </span><br><span class="line">my\_array &lt;- array(my\_vector, dim \= c(4))  </span><br><span class="line">print(my\_array)  </span><br></pre></td></tr></table></figure><p>以下实例我们创建一个 3 行 3 列的的二维数组：</p><h2 id="实例-91">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\# 创建两个不同长度的向量  </span><br><span class="line">vector1 &lt;- c(5,9,3)  </span><br><span class="line">vector2 &lt;- c(10,11,12,13,14,15)</span><br><span class="line"></span><br><span class="line">\# 创建数组  </span><br><span class="line">result &lt;- array(c(vector1,vector2),dim \= c(3,3,2))  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">, , 1</span><br><span class="line"></span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    5   10   13</span><br><span class="line">[2,]    9   11   14</span><br><span class="line">[3,]    3   12   15</span><br><span class="line"></span><br><span class="line">, , 2</span><br><span class="line"></span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    5   10   13</span><br><span class="line">[2,]    9   11   14</span><br><span class="line">[3,]    3   12   15</span><br></pre></td></tr></table></figure><p>使用 dimnames 参数来设置各个维度的名称：：</p><h2 id="实例-92">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\# 创建两个不同长度的向量  </span><br><span class="line">vector1 &lt;- c(5,9,3)  </span><br><span class="line">vector2 &lt;- c(10,11,12,13,14,15)  </span><br><span class="line">column.names &lt;- c(&quot;COL1&quot;,&quot;COL2&quot;,&quot;COL3&quot;)  </span><br><span class="line">row.names &lt;- c(&quot;ROW1&quot;,&quot;ROW2&quot;,&quot;ROW3&quot;)  </span><br><span class="line">matrix.names &lt;- c(&quot;Matrix1&quot;,&quot;Matrix2&quot;)</span><br><span class="line"></span><br><span class="line">\# 创建数组，并设置各个维度的名称  </span><br><span class="line">result &lt;- array(c(vector1,vector2),dim \= c(3,3,2),dimnames \= list(row.names,column.names,matrix.names))  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">, , Matrix1</span><br><span class="line"></span><br><span class="line">     COL1 COL2 COL3</span><br><span class="line">ROW1    5   10   13</span><br><span class="line">ROW2    9   11   14</span><br><span class="line">ROW3    3   12   15</span><br><span class="line"></span><br><span class="line">, , Matrix2</span><br><span class="line"></span><br><span class="line">     COL1 COL2 COL3</span><br><span class="line">ROW1    5   10   13</span><br><span class="line">ROW2    9   11   14</span><br><span class="line">ROW3    3   12   15</span><br></pre></td></tr></table></figure><h3 id="访问数组元素">访问数组元素</h3><p>在 R 语言中，可以使用索引操作符 [ ] 来访问多维数组的元素。</p><p>索引操作符允许您按照指定的索引位置获取数组中的特定元素。</p><p>如果想获取数组元素，可以通过使用元素的列索引和行索引，类似坐标形式。</p><p>访问单个元素：</p><h2 id="实例-93">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my\_array &lt;- array(1:12, dim \= c(2, 3, 2))  \# 创建一个3维数组  </span><br><span class="line">element &lt;- my\_array\[1, 2, 1\]  \# 访问第一个维度为1，第二个维度为2，第三个维度为1的元素  </span><br><span class="line">print(element)  </span><br></pre></td></tr></table></figure><p>访问多个元素：</p><h2 id="实例-94">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my\_array &lt;- array(1:12, dim \= c(2, 3, 2))  \# 创建一个3维数组  </span><br><span class="line">elements &lt;- my\_array\[c(1, 2), c(2, 3), c(1, 2)\]  \# 访问多个元素，其中每个维度的索引分别为1和2  </span><br><span class="line">print(elements)  </span><br></pre></td></tr></table></figure><p>访问二维数组的元素：</p><h2 id="实例-95">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">\# 创建两个不同长度的向量  </span><br><span class="line">vector1 &lt;- c(5,9,3)  </span><br><span class="line">vector2 &lt;- c(10,11,12,13,14,15)  </span><br><span class="line">column.names &lt;- c(&quot;COL1&quot;,&quot;COL2&quot;,&quot;COL3&quot;)  </span><br><span class="line">row.names &lt;- c(&quot;ROW1&quot;,&quot;ROW2&quot;,&quot;ROW3&quot;)  </span><br><span class="line">matrix.names &lt;- c(&quot;Matrix1&quot;,&quot;Matrix2&quot;)</span><br><span class="line"></span><br><span class="line">\# 创建数组  </span><br><span class="line">result &lt;- array(c(vector1,vector2),dim \= c(3,3,2),dimnames \= list(row.names, column.names, matrix.names))</span><br><span class="line"></span><br><span class="line">\# 显示数组第二个矩阵中第三行的元素  </span><br><span class="line">print(result\[3,,2\])</span><br><span class="line"></span><br><span class="line">\# 显示数组第一个矩阵中第一行第三列的元素  </span><br><span class="line">print(result\[1,3,1\])</span><br><span class="line"></span><br><span class="line">\# 输出第二个矩阵  </span><br><span class="line">print(result\[,,2\])</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">COL1 COL2 COL3 </span><br><span class="line">   3   12   15 </span><br><span class="line">[1] 13</span><br><span class="line">     COL1 COL2 COL3</span><br><span class="line">ROW1    5   10   13</span><br><span class="line">ROW2    9   11   14</span><br><span class="line">ROW3    3   12   15</span><br></pre></td></tr></table></figure><p>使用逻辑条件进行筛选：</p><h2 id="实例-96">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my\_array &lt;- array(1:12, dim \= c(2, 3, 2))  \# 创建一个3维数组  </span><br><span class="line">filtered\_elements &lt;- my\_array\[my\_array \&gt; 5\]  \# 选择大于5的元素  </span><br><span class="line">print(filtered\_elements)  \# 输出：6 7 8 9 10 11 12  </span><br></pre></td></tr></table></figure><h3 id="操作数组元素">操作数组元素</h3><p>由于数组是由多个维度的矩阵组成，所以我们可以通过访问矩阵的元素来访问数组元素。</p><h2 id="实例-97">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">\# 创建两个不同长度的向量  </span><br><span class="line">vector1 &lt;- c(5,9,3)  </span><br><span class="line">vector2 &lt;- c(10,11,12,13,14,15)</span><br><span class="line"></span><br><span class="line">\# 创建数组  </span><br><span class="line">array1 &lt;- array(c(vector1,vector2),dim \= c(3,3,2))</span><br><span class="line"></span><br><span class="line">\# 创建两个不同长度的向量  </span><br><span class="line">vector3 &lt;- c(9,1,0)  </span><br><span class="line">vector4 &lt;- c(6,0,11,3,14,1,2,6,9)  </span><br><span class="line">array2 &lt;- array(c(vector3,vector4),dim \= c(3,3,2))</span><br><span class="line"></span><br><span class="line">\# 从数组中创建矩阵  </span><br><span class="line">matrix1 &lt;- array1\[,,2\]  </span><br><span class="line">matrix2 &lt;- array2\[,,2\]</span><br><span class="line"></span><br><span class="line">\# 矩阵相加  </span><br><span class="line">result &lt;- matrix1+matrix2  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    7   19   19</span><br><span class="line">[2,]   15   12   14</span><br><span class="line">[3,]   12   12   26</span><br></pre></td></tr></table></figure><p>另外我们可以使用 <strong>apply()</strong> 元素对数组元素进行跨维度计算，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply(X, MARGIN, FUN, ...)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>X</code>：要应用函数的数组或矩阵。</li><li><code>MARGIN</code>：指定应用函数的维度，可以是1表示行，2表示列，或者c(1, 2)表示同时应用于行和列。</li><li><code>FUN</code>：要应用的函数，可以是内置函数（如<code>mean</code>、<code>sum</code>等）或自定义函数。</li><li><code>...</code>：可选参数，用于传递给函数的其他参数。</li></ul><p>以下我们使用 apply() 函数来计算数组两个矩阵中每一行对数字之和。</p><h2 id="实例-98">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\# 创建两个不同长度的向量  </span><br><span class="line">vector1 &lt;- c(5,9,3)  </span><br><span class="line">vector2 &lt;- c(10,11,12,13,14,15)</span><br><span class="line"></span><br><span class="line">\# 创建数组  </span><br><span class="line">new.array &lt;- array(c(vector1,vector2),dim \= c(3,3,2))  </span><br><span class="line">print(new.array)</span><br><span class="line"></span><br><span class="line">\# 计算数组中所有矩阵第一行的数字之和  </span><br><span class="line">result &lt;- apply(new.array, c(1), sum)  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">, , 1</span><br><span class="line"></span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    5   10   13</span><br><span class="line">[2,]    9   11   14</span><br><span class="line">[3,]    3   12   15</span><br><span class="line"></span><br><span class="line">, , 2</span><br><span class="line"></span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    5   10   13</span><br><span class="line">[2,]    9   11   14</span><br><span class="line">[3,]    3   12   15</span><br><span class="line"></span><br><span class="line">[1] 56 68 60</span><br></pre></td></tr></table></figure><p>对矩阵的行或列应用内置函数：</p><h2 id="实例-99">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\# 创建一个3x3的矩阵  </span><br><span class="line">my\_matrix &lt;- matrix(1:9, nrow \= 3)  </span><br><span class="line">\# 对每列应用sum函数  </span><br><span class="line">col\_sums &lt;- apply(my\_matrix, 2, sum)  </span><br><span class="line">print(col\_sums)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1]  6 15 24</span><br></pre></td></tr></table></figure><p>对矩阵的行或列应用自定义函数：</p><h2 id="实例-100">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\# 创建一个3x3的矩阵  </span><br><span class="line">my\_matrix &lt;- matrix(1:9, nrow \= 3)  </span><br><span class="line">\# 自定义函数：计算每行的平均值  </span><br><span class="line">row\_mean &lt;- function(x) &#123;  </span><br><span class="line">  return(mean(x))  </span><br><span class="line">&#125;  </span><br><span class="line">\# 对每行应用row\_mean函数  </span><br><span class="line">row\_means &lt;- apply(my\_matrix, 1, row\_mean)  </span><br><span class="line">print(row\_means)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] 4 5 6</span><br></pre></td></tr></table></figure><p>对数组的多个维度同时应用函数：</p><h2 id="实例-101">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\# 创建一个3维数组  </span><br><span class="line">my\_array &lt;- array(1:12, dim \= c(2, 3, 2))  </span><br><span class="line">\# 对第一个和第三个维度同时应用mean函数  </span><br><span class="line">result &lt;- apply(my\_array, c(1, 3), mean)  </span><br><span class="line">print(result)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     [,1] [,2]</span><br><span class="line">[1,]    3    9</span><br><span class="line">[2,]    4   10</span><br></pre></td></tr></table></figure><h2 id="R-因子">R 因子</h2><p>因子用于存储不同类别的数据类型，例如人的性别有男和女两个类别，年龄来分可以有未成年人和成年人。</p><p>R 语言创建因子使用 factor() 函数，向量作为输入参数。</p><p>factor() 函数语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">factor(x = character(), levels, labels = levels,</span><br><span class="line">       exclude = NA, ordered = is.ordered(x), nmax = NA)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>x：向量。</li><li>levels：指定各水平值, 不指定时由x的不同值来求得。</li><li>labels：水平的标签, 不指定时用各水平值的对应字符串。</li><li>exclude：排除的字符。</li><li>ordered：逻辑值，用于指定水平是否有序。</li><li>nmax：水平的上限数量。</li></ul><p>以下实例把字符型向量转换成因子：</p><h2 id="实例-102">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(&quot;男&quot;, &quot;女&quot;, &quot;男&quot;, &quot;男&quot;,  &quot;女&quot;)  </span><br><span class="line">sex &lt;- factor(x)  </span><br><span class="line">print(sex)  </span><br><span class="line">print(is.factor(sex))  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1] 男 女 男 男 女</span><br><span class="line">Levels: 男 女</span><br><span class="line">[1] TRUE</span><br></pre></td></tr></table></figure><p>以下实例设置因子水平为 c(‘男’,‘女’)：</p><h2 id="实例-103">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(&quot;男&quot;, &quot;女&quot;, &quot;男&quot;, &quot;男&quot;,  &quot;女&quot;,levels\=c(&#x27;男&#x27;,&#x27;女&#x27;))  </span><br><span class="line">sex &lt;- factor(x)  </span><br><span class="line">print(sex)  </span><br><span class="line">print(is.factor(sex))  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">levels1 levels2 </span><br><span class="line">男      女      男      男      女      男      女 </span><br><span class="line">Levels: 男 女</span><br><span class="line">[1] TRUE</span><br></pre></td></tr></table></figure><h3 id="因子水平标签">因子水平标签</h3><p>接下来我们使用 labels 参数为每个因子水平添加标签，labels 参数的字符顺序，要和 levels 参数的字符顺序保持一致，例如：</p><h2 id="实例-104">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sex\=factor(c(&#x27;f&#x27;,&#x27;m&#x27;,&#x27;f&#x27;,&#x27;f&#x27;,&#x27;m&#x27;),levels\=c(&#x27;f&#x27;,&#x27;m&#x27;),labels\=c(&#x27;female&#x27;,&#x27;male&#x27;),ordered\=TRUE)  </span><br><span class="line">print(sex)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1] female male   female female male  </span><br><span class="line">Levels: female &lt; male</span><br></pre></td></tr></table></figure><h3 id="生成因子水平">生成因子水平</h3><p>我们可以使用 gl() 函数来生成因子水平，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl(n, k, length = n*k, labels = seq_len(n), ordered = FALSE)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><strong>n</strong>: 设置 level 的个数</li><li><strong>k</strong>: 设置每个 level 重复的次数</li><li><strong>length</strong>: 设置长度</li><li><strong>labels</strong>: 设置 level 的值</li><li><strong>ordered</strong>: 设置是否 level 是排列好顺序的，布尔值。</li></ul><h2 id="实例-105">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v &lt;- gl(3, 4, labels \= c(&quot;Google&quot;, &quot;Runoob&quot;,&quot;Taobao&quot;))  </span><br><span class="line">print(v)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> [1] Google Google Google Google Runoob Runoob Runoob Runoob Taobao Taobao</span><br><span class="line">[11] Taobao Taobao</span><br><span class="line">Levels: Google Runoob Taobao</span><br></pre></td></tr></table></figure><h2 id="R-数据框">R 数据框</h2><p>数据框（Data frame）可以理解成我们常说的&quot;表格&quot;。</p><p>数据框是 R 语言的数据结构，是特殊的二维列表。</p><p>数据框每一列都有一个唯一的列名，长度都是相等的，同一列的数据类型需要一致，不同列的数据类型可以不一样。</p><p><img src="https://static.jyshare.com/images/mix/data-frame.svg" alt=""></p><p>R 语言数据框使用 data.frame() 函数来创建，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.frame(…, row.names = NULL, check.rows = FALSE,</span><br><span class="line">           check.names = TRUE, fix.empty.names = TRUE,</span><br><span class="line">           stringsAsFactors = default.stringsAsFactors())</span><br></pre></td></tr></table></figure><ul><li><strong>…</strong>: 列向量，可以是任何类型（字符型、数值型、逻辑型），一般以 tag = value 的形式表示，也可以是 value。</li><li><strong>row.names</strong>: 行名，默认为 NULL，可以设置为单个数字、字符串或字符串和数字的向量。</li><li><strong>check.rows</strong>: 检测行的名称和长度是否一致。</li><li><strong>check.names</strong>: 检测数据框的变量名是否合法。</li><li><strong>fix.empty.names</strong>: 设置未命名的参数是否自动设置名字。</li><li><strong>stringsAsFactors</strong>: 布尔值，字符是否转换为因子，factory-fresh 的默认值是 TRUE，可以通过设置选项（stringsAsFactors=FALSE）来修改。</li></ul><p>以下创建一个简单的数据框，包含姓名、工号、月薪：</p><h2 id="实例-106">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">table \= data.frame(  </span><br><span class="line">    姓名 \= c(&quot;张三&quot;, &quot;李四&quot;),  </span><br><span class="line">    工号 \= c(&quot;001&quot;,&quot;002&quot;),  </span><br><span class="line">    月薪 \= c(1000, 2000)</span><br><span class="line"></span><br><span class="line">    )  </span><br><span class="line">print(table) \# 查看 table 数据</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">姓名 工号 月薪</span><br><span class="line">1 张三  001 1000</span><br><span class="line">2 李四  002 2000</span><br></pre></td></tr></table></figure><p>数据框的数据结构可以通过 <strong>str()</strong> 函数来展示：</p><h2 id="实例-107">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">table \= data.frame(  </span><br><span class="line">    姓名 \= c(&quot;张三&quot;, &quot;李四&quot;),  </span><br><span class="line">    工号 \= c(&quot;001&quot;,&quot;002&quot;),  </span><br><span class="line">    月薪 \= c(1000, 2000)  </span><br><span class="line">)  </span><br><span class="line">\# 获取数据结构  </span><br><span class="line">str(table)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;data.frame&#x27;:   2 obs. of  3 variables:</span><br><span class="line"> $ 姓名: chr  &quot;张三&quot; &quot;李四&quot;</span><br><span class="line"> $ 工号: chr  &quot;001&quot; &quot;002&quot;</span><br><span class="line"> $ 月薪: num  1000 2000</span><br></pre></td></tr></table></figure><p><strong>summary()</strong> 可以显示数据框的概要信息：</p><h2 id="实例-108">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">table \= data.frame(  </span><br><span class="line">    姓名 \= c(&quot;张三&quot;, &quot;李四&quot;),  </span><br><span class="line">    工号 \= c(&quot;001&quot;,&quot;002&quot;),  </span><br><span class="line">    月薪 \= c(1000, 2000)</span><br><span class="line"></span><br><span class="line">    )  </span><br><span class="line">\# 显示概要  </span><br><span class="line">print(summary(table))</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">姓名               工号                月薪     </span><br><span class="line">Length:2           Length:2           Min.   :1000  </span><br><span class="line">Class :character   Class :character   1st Qu.:1250  </span><br><span class="line">Mode  :character   Mode  :character   Median :1500  </span><br><span class="line">                                      Mean   :1500  </span><br><span class="line">                                      3rd Qu.:1750  </span><br><span class="line">                                      Max.   :2000  </span><br></pre></td></tr></table></figure><p>我们也可以提取指定的列：</p><h2 id="实例-109">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">table \= data.frame(  </span><br><span class="line">    姓名 \= c(&quot;张三&quot;, &quot;李四&quot;),  </span><br><span class="line">    工号 \= c(&quot;001&quot;,&quot;002&quot;),  </span><br><span class="line">    月薪 \= c(1000, 2000)  </span><br><span class="line">)  </span><br><span class="line">\# 提取指定的列  </span><br><span class="line">result &lt;- data.frame(table$姓名,table$月薪)  </span><br><span class="line">print(result)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">table.姓名 table.月薪</span><br><span class="line">1       张三       1000</span><br><span class="line">2       李四       2000</span><br></pre></td></tr></table></figure><p>以下形式显示前面两行：</p><h2 id="实例-110">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">table \= data.frame(  </span><br><span class="line">    姓名 \= c(&quot;张三&quot;, &quot;李四&quot;,&quot;王五&quot;),  </span><br><span class="line">    工号 \= c(&quot;001&quot;,&quot;002&quot;,&quot;003&quot;),  </span><br><span class="line">    月薪 \= c(1000, 2000,3000)  </span><br><span class="line">)  </span><br><span class="line">print(table)  </span><br><span class="line">\# 提取前面两行  </span><br><span class="line">print(&quot;---输出前面两行----&quot;)  </span><br><span class="line">result &lt;- table\[1:2,\]  </span><br><span class="line">print(result)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">姓名 工号 月薪</span><br><span class="line">1 张三  001 1000</span><br><span class="line">2 李四  002 2000</span><br><span class="line">3 王五  003 3000</span><br><span class="line">[1] &quot;---输出前面两行----&quot;</span><br><span class="line">  姓名 工号 月薪</span><br><span class="line">1 张三  001 1000</span><br><span class="line">2 李四  002 2000</span><br></pre></td></tr></table></figure><p>我们可以通过类似坐标的形式读取指定行的某一列的数据，以下我们读取第 2 、3 行的第 1 、2 列数据：</p><h2 id="实例-111">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">table \= data.frame(  </span><br><span class="line">    姓名 \= c(&quot;张三&quot;, &quot;李四&quot;,&quot;王五&quot;),  </span><br><span class="line">    工号 \= c(&quot;001&quot;,&quot;002&quot;,&quot;003&quot;),  </span><br><span class="line">    月薪 \= c(1000, 2000,3000)  </span><br><span class="line">)  </span><br><span class="line">\# 读取第 2 、3 行的第 1 、2 列数据：  </span><br><span class="line">result &lt;- table\[c(2,3),c(1,2)\]  </span><br><span class="line">print(result)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">姓名 工号</span><br><span class="line">2 李四  002</span><br><span class="line">3 王五  003</span><br></pre></td></tr></table></figure><h3 id="扩展数据框">扩展数据框</h3><p>我们可以对已有的数据框进行扩展，以下实例我们添加部门列：</p><h2 id="实例-112">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">table \= data.frame(  </span><br><span class="line">    姓名 \= c(&quot;张三&quot;, &quot;李四&quot;,&quot;王五&quot;),  </span><br><span class="line">    工号 \= c(&quot;001&quot;,&quot;002&quot;,&quot;003&quot;),  </span><br><span class="line">    月薪 \= c(1000, 2000,3000)  </span><br><span class="line">)  </span><br><span class="line">\# 添加部门列  </span><br><span class="line">table$部门 &lt;- c(&quot;运营&quot;,&quot;技术&quot;,&quot;编辑&quot;)</span><br><span class="line"></span><br><span class="line">print(table)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">姓名 工号 月薪 部门</span><br><span class="line">1 张三  001 1000 运营</span><br><span class="line">2 李四  002 2000 技术</span><br><span class="line">3 王五  003 3000 编辑</span><br></pre></td></tr></table></figure><p>我们可以使用 <strong>cbind()</strong> 函数将多个向量合成一个数据框：</p><h2 id="实例-113">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\# 创建向量  </span><br><span class="line">sites &lt;- c(&quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;)  </span><br><span class="line">likes &lt;- c(222,111,123)  </span><br><span class="line">url &lt;- c(&quot;www.google.com&quot;,&quot;www.runoob.com&quot;,&quot;www.taobao.com&quot;)</span><br><span class="line"></span><br><span class="line">\# 将向量组合成数据框  </span><br><span class="line">addresses &lt;- cbind(sites,likes,url)</span><br><span class="line"></span><br><span class="line">\# 查看数据框  </span><br><span class="line">print(addresses)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     sites    likes url             </span><br><span class="line">[1,] &quot;Google&quot; &quot;222&quot; &quot;www.google.com&quot;</span><br><span class="line">[2,] &quot;Runoob&quot; &quot;111&quot; &quot;www.runoob.com&quot;</span><br><span class="line">[3,] &quot;Taobao&quot; &quot;123&quot; &quot;www.taobao.com&quot;</span><br></pre></td></tr></table></figure><p>如果要对两个数据框进行合并可以使用 <strong>rbind()</strong> 函数：</p><h2 id="实例-114">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">table \= data.frame(  </span><br><span class="line">    姓名 \= c(&quot;张三&quot;, &quot;李四&quot;,&quot;王五&quot;),  </span><br><span class="line">    工号 \= c(&quot;001&quot;,&quot;002&quot;,&quot;003&quot;),  </span><br><span class="line">    月薪 \= c(1000, 2000,3000)  </span><br><span class="line">)  </span><br><span class="line">newtable \= data.frame(  </span><br><span class="line">    姓名 \= c(&quot;小明&quot;, &quot;小白&quot;),  </span><br><span class="line">    工号 \= c(&quot;101&quot;,&quot;102&quot;),  </span><br><span class="line">    月薪 \= c(5000, 7000)  </span><br><span class="line">)  </span><br><span class="line">\# 合并两个数据框  </span><br><span class="line">result &lt;- rbind(table,newtable)  </span><br><span class="line">print(result)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">姓名 工号 月薪</span><br><span class="line">1 张三  001 1000</span><br><span class="line">2 李四  002 2000</span><br><span class="line">3 王五  003 3000</span><br><span class="line">4 小明  101 5000</span><br><span class="line">5 小白  102 7000</span><br></pre></td></tr></table></figure><h2 id="R-数据重塑">R 数据重塑</h2><h3 id="合并数据框">合并数据框</h3><p>R 语言合并数据框使用 <strong>merge()</strong> 函数。</p><p>merge() 函数语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># S3 方法</span><br><span class="line">merge(x, y, …)</span><br><span class="line"></span><br><span class="line"># data.frame 的 S3 方法 </span><br><span class="line">merge(x, y, by = intersect(names(x), names(y)),</span><br><span class="line">      by.x = by, by.y = by, all = FALSE, all.x = all, all.y = all,</span><br><span class="line">      sort = TRUE, suffixes = c(&quot;.x&quot;,&quot;.y&quot;), no.dups = TRUE,</span><br><span class="line">      incomparables = NULL, …)</span><br></pre></td></tr></table></figure><p>常用参数说明：</p><ul><li>x, y： 数据框</li><li>by, by.x, by.y：指定两个数据框中匹配列名称，默认情况下使用两个数据框中相同列名称。</li><li>all：逻辑值; all = L 是 all.x = L 和 all.y = L 的简写，L 可以是 TRUE 或 FALSE。</li><li>all.x：逻辑值，默认为 FALSE。如果为 TRUE, 显示 x 中匹配的行，即便 y 中没有对应匹配的行，y 中没有匹配的行用 NA 来表示。</li><li>all.y：逻辑值，默认为 FALSE。如果为 TRUE, 显示 y 中匹配的行，即便 x 中没有对应匹配的行，x 中没有匹配的行用 NA 来表示。</li><li>sort：逻辑值，是否对列进行排序。</li></ul><p>merge() 函数和 SQL 的 JOIN 功能很相似：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-merge-join.jpg" alt=""></p><ul><li><strong>Natural join 或 INNER JOIN</strong>：如果表中有至少一个匹配，则返回行</li><li><strong>Left outer join 或 LEFT JOIN</strong>：即使右表中没有匹配，也从左表返回所有的行</li><li><strong>Right outer join 或 RIGHT JOIN</strong>：即使左表中没有匹配，也从右表返回所有的行</li><li><strong>Full outer join 或 FULL JOIN</strong>：只要其中一个表中存在匹配，则返回行</li></ul><h2 id="实例-115">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">\# data frame 1  </span><br><span class="line">df1 \= data.frame(SiteId \= c(1:6), Site \= c(&quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;,&quot;Facebook&quot;,&quot;Zhihu&quot;,&quot;Weibo&quot;))</span><br><span class="line"></span><br><span class="line">\# data frame 2  </span><br><span class="line">df2 \= data.frame(SiteId \= c(2, 4, 6, 7, 8), Country \= c(&quot;CN&quot;,&quot;USA&quot;,&quot;CN&quot;,&quot;USA&quot;,&quot;IN&quot;))</span><br><span class="line"></span><br><span class="line">\# INNER JOIN  </span><br><span class="line">df1 \= merge(x\=df1,y\=df2,by\=&quot;SiteId&quot;)  </span><br><span class="line">print(&quot;----- INNER JOIN -----&quot;)  </span><br><span class="line">print(df1)</span><br><span class="line"></span><br><span class="line">\# FULL JOIN  </span><br><span class="line">df2 \= merge(x\=df1,y\=df2,by\=&quot;SiteId&quot;,all\=TRUE)  </span><br><span class="line">print(&quot;----- FULL JOIN -----&quot;)  </span><br><span class="line">print(df2)</span><br><span class="line"></span><br><span class="line">\# LEFT JOIN  </span><br><span class="line">df3 \= merge(x\=df1,y\=df2,by\=&quot;SiteId&quot;,all.x\=TRUE)  </span><br><span class="line">print(&quot;----- LEFT JOIN -----&quot;)  </span><br><span class="line">print(df3)</span><br><span class="line"></span><br><span class="line">\# RIGHT JOIN  </span><br><span class="line">df4 \= merge(x\=df1,y\=df2,by\=&quot;SiteId&quot;,all.y\=TRUE)  </span><br><span class="line">print(&quot;----- RIGHT JOIN -----&quot;)  </span><br><span class="line">print(df4)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;----- INNER JOIN -----&quot;</span><br><span class="line">  SiteId     Site Country</span><br><span class="line">1      2   Runoob      CN</span><br><span class="line">2      4 Facebook     USA</span><br><span class="line">3      6    Weibo      CN</span><br><span class="line">[1] &quot;----- FULL JOIN -----&quot;</span><br><span class="line">  SiteId     Site Country.x Country.y</span><br><span class="line">1      2   Runoob        CN        CN</span><br><span class="line">2      4 Facebook       USA       USA</span><br><span class="line">3      6    Weibo        CN        CN</span><br><span class="line">4      7     &lt;NA&gt;      &lt;NA&gt;       USA</span><br><span class="line">5      8     &lt;NA&gt;      &lt;NA&gt;        IN</span><br><span class="line">[1] &quot;----- LEFT JOIN -----&quot;</span><br><span class="line">  SiteId   Site.x Country   Site.y Country.x Country.y</span><br><span class="line">1      2   Runoob      CN   Runoob        CN        CN</span><br><span class="line">2      4 Facebook     USA Facebook       USA       USA</span><br><span class="line">3      6    Weibo      CN    Weibo        CN        CN</span><br><span class="line">[1] &quot;----- RIGHT JOIN -----&quot;</span><br><span class="line">  SiteId   Site.x Country   Site.y Country.x Country.y</span><br><span class="line">1      2   Runoob      CN   Runoob        CN        CN</span><br><span class="line">2      4 Facebook     USA Facebook       USA       USA</span><br><span class="line">3      6    Weibo      CN    Weibo        CN        CN</span><br><span class="line">4      7     &lt;NA&gt;    &lt;NA&gt;     &lt;NA&gt;      &lt;NA&gt;       USA</span><br><span class="line">5      8     &lt;NA&gt;    &lt;NA&gt;     &lt;NA&gt;      &lt;NA&gt;        IN</span><br></pre></td></tr></table></figure><h3 id="数据整合和拆分">数据整合和拆分</h3><p>R 语言使用 <strong>melt()</strong> 和 <strong>cast()</strong> 函数来对数据进行整合和拆分。</p><ul><li>melt() ：宽格式数据转化成长格式。</li><li>cast() ：长格式数据转化成宽格式。</li></ul><p>下图很好展示来 melt() 和 cast() 函数的功能(后面实例会详细说明)：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/08/6634703-5e733d531862b668.webp" alt=""></p><p>melt() 将数据集的每个列堆叠到一个列中，函数语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">melt(data, ..., na.rm = FALSE, value.name = &quot;value&quot;)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>data：数据集。</li><li>…：传递给其他方法或来自其他方法的其他参数。</li><li>na.rm：是否删除数据集中的 NA 值。</li><li><a href="http://value.name">value.name</a> 变量名称，用于存储值。</li></ul><p>进行以下操作之前，我们先安装依赖包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 安装库，MASS 包含很多统计相关的函数，工具和数据集</span><br><span class="line">install.packages(&quot;MASS&quot;, repos = &quot;https://mirrors.ustc.edu.cn/CRAN/&quot;) </span><br><span class="line">  </span><br><span class="line">#  melt() 和 cast() 函数需要对库 </span><br><span class="line">install.packages(&quot;reshape2&quot;, repos = &quot;https://mirrors.ustc.edu.cn/CRAN/&quot;) </span><br><span class="line">install.packages(&quot;reshape&quot;, repos = &quot;https://mirrors.ustc.edu.cn/CRAN/&quot;) </span><br></pre></td></tr></table></figure><p>测试实例：</p><h2 id="实例-116">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">\# 载入库  </span><br><span class="line">library(MASS)  </span><br><span class="line">library(reshape2)  </span><br><span class="line">library(reshape)</span><br><span class="line"></span><br><span class="line">  \# 创建数据框  </span><br><span class="line">id&lt;\- c(1, 1, 2, 2)  </span><br><span class="line">time &lt;\- c(1, 2, 1, 2)  </span><br><span class="line">x1 &lt;\- c(5, 3, 6, 2)  </span><br><span class="line">x2 &lt;\- c(6, 5, 1, 4)  </span><br><span class="line">mydata &lt;\- data.frame(id, time, x1, x2)</span><br><span class="line"></span><br><span class="line">  \# 原始数据框  </span><br><span class="line">cat(&quot;原始数据框:\\n&quot;)  </span><br><span class="line">print(mydata)  </span><br><span class="line">\# 整合  </span><br><span class="line">md &lt;\- melt(mydata, id = c(&quot;id&quot;,&quot;time&quot;))</span><br><span class="line"></span><br><span class="line">  cat(&quot;\\n整合后:\\n&quot;)  </span><br><span class="line">print(md)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">原始数据框:</span><br><span class="line">id time x1 x2</span><br><span class="line">1  1    1  5  6</span><br><span class="line">2  1    2  3  5</span><br><span class="line">3  2    1  6  1</span><br><span class="line">4  2    2  2  4</span><br><span class="line"></span><br><span class="line">整合后:</span><br><span class="line">id time variable value</span><br><span class="line">1  1    1       x1     5</span><br><span class="line">2  1    2       x1     3</span><br><span class="line">3  2    1       x1     6</span><br><span class="line">4  2    2       x1     2</span><br><span class="line">5  1    1       x2     6</span><br><span class="line">6  1    2       x2     5</span><br><span class="line">7  2    1       x2     1</span><br><span class="line">8  2    2       x2     4</span><br></pre></td></tr></table></figure><p>cast 函数用于对合并对数据框进行还原，dcast() 返回数据框，acast() 返回一个向量/矩阵/数组。</p><p>cast() 函数语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dcast(</span><br><span class="line">  data,</span><br><span class="line">  formula,</span><br><span class="line">  fun.aggregate = NULL,</span><br><span class="line">  ...,</span><br><span class="line">  margins = NULL,</span><br><span class="line">  subset = NULL,</span><br><span class="line">  fill = NULL,</span><br><span class="line">  drop = TRUE,</span><br><span class="line">  value.var = guess_value(data)</span><br><span class="line">)</span><br><span class="line">acast(</span><br><span class="line">  data,</span><br><span class="line">  formula,</span><br><span class="line">  fun.aggregate = NULL,</span><br><span class="line">  ...,</span><br><span class="line">  margins = NULL,</span><br><span class="line">  subset = NULL,</span><br><span class="line">  fill = NULL,</span><br><span class="line">  drop = TRUE,</span><br><span class="line">  value.var = guess_value(data)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>data：合并的数据框。</li><li>formula：重塑的数据的格式，类似 x ~ y 格式，x 为行标签，y 为列标签 。</li><li>fun.aggregate：聚合函数，用于对 value 值进行处理。</li><li>margins：变量名称的向量（可以包含&quot;grand\_col&quot; 和 “grand\_row”），用于计算边距，设置 TURE 计算所有边距。</li><li>subset：对结果进行条件筛选，格式类似 <strong>subset = .(variable==“length”)</strong>。</li><li>drop：是否保留默认值。</li><li>value.var：后面跟要处理的字段。</li></ul><h2 id="实例-117">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">\# 载入库  </span><br><span class="line">library(MASS)  </span><br><span class="line">library(reshape2)  </span><br><span class="line">library(reshape)</span><br><span class="line"></span><br><span class="line">  \# 创建数据框  </span><br><span class="line">id&lt;- c(1, 1, 2, 2)  </span><br><span class="line">time &lt;- c(1, 2, 1, 2)  </span><br><span class="line">x1 &lt;- c(5, 3, 6, 2)  </span><br><span class="line">x2 &lt;- c(6, 5, 1, 4)  </span><br><span class="line">mydata &lt;- data.frame(id, time, x1, x2)  </span><br><span class="line">\# 整合  </span><br><span class="line">md &lt;- melt(mydata, id \= c(&quot;id&quot;,&quot;time&quot;))  </span><br><span class="line">\# Print recasted dataset using cast() function  </span><br><span class="line">cast.data &lt;- cast(md, id~variable, mean)</span><br><span class="line"></span><br><span class="line">  print(cast.data)</span><br><span class="line"></span><br><span class="line">  cat(&quot;\\n&quot;)  </span><br><span class="line">time.cast &lt;- cast(md, time~variable, mean)  </span><br><span class="line">print(time.cast)</span><br><span class="line"></span><br><span class="line">cat(&quot;\\n&quot;)  </span><br><span class="line">id.time &lt;- cast(md, id~time, mean)  </span><br><span class="line">print(id.time)</span><br><span class="line"></span><br><span class="line">cat(&quot;\\n&quot;)  </span><br><span class="line">id.time.cast &lt;- cast(md, id+time~variable)  </span><br><span class="line">print(id.time.cast)</span><br><span class="line"></span><br><span class="line">cat(&quot;\\n&quot;)  </span><br><span class="line">id.variable.time &lt;- cast(md, id+variable~time)  </span><br><span class="line">print(id.variable.time)</span><br><span class="line"></span><br><span class="line">cat(&quot;\\n&quot;)  </span><br><span class="line">id.variable.time2 &lt;- cast(md, id~variable+time)  </span><br><span class="line">print(id.variable.time2)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">id x1  x2</span><br><span class="line">1  1  4 5.5</span><br><span class="line">2  2  4 2.5</span><br><span class="line"></span><br><span class="line">  time  x1  x2</span><br><span class="line">1    1 5.5 3.5</span><br><span class="line">2    2 2.5 4.5</span><br><span class="line"></span><br><span class="line">  id   1 2</span><br><span class="line">1  1 5.5 4</span><br><span class="line">2  2 3.5 3</span><br><span class="line"></span><br><span class="line">  id time x1 x2</span><br><span class="line">1  1    1  5  6</span><br><span class="line">2  1    2  3  5</span><br><span class="line">3  2    1  6  1</span><br><span class="line">4  2    2  2  4</span><br><span class="line"></span><br><span class="line">  id variable 1 2</span><br><span class="line">1  1       x1 5 3</span><br><span class="line">2  1       x2 6 5</span><br><span class="line">3  2       x1 6 2</span><br><span class="line">4  2       x2 1 4</span><br><span class="line"></span><br><span class="line">  id x1_1 x1_2 x2_1 x2_2</span><br><span class="line">1  1    5    3    6    5</span><br><span class="line">2  2    6    2    1    4</span><br></pre></td></tr></table></figure><h2 id="R-包">R 包</h2><p>包是 R 函数、实例数据、预编译代码的集合，包括 R 程序，注释文档、实例、测试数据等。</p><p>R 语言相关的包一般存储安装目录下对 “library” 目录，默认情况在 R 语言安装完成已经自带来一些常用对包，当然我们也可以在后期自定义添加一些要使用的包。</p><p>R 语言完整的相关包可以查阅：<a href="https://cran.r-project.org/web/packages/available_packages_by_name.html">https://cran.r-project.org/web/packages/available_packages_by_name.html</a></p><p>接下来我们主要介绍如何安装 R 语言的包。</p><h3 id="查看-R-包的安装目录">查看 R 包的安装目录</h3><p>我们可以使用以下函数来查看 R 包的安装目录：</p><h2 id="实例-118">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\&gt; .libPaths()  </span><br><span class="line">\[1\] &quot;/Library/Frameworks/R.framework/Versions/4.0/Resources/library&quot;  </span><br><span class="line">\&gt;  </span><br></pre></td></tr></table></figure><h3 id="查看已安装的包">查看已安装的包</h3><p>我们可以使用以下函数来查看已安装的包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">library()</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">base                    The R Base Package</span><br><span class="line">boot                    Bootstrap Functions (Originally by Angelo Canty</span><br><span class="line">                        for S)</span><br><span class="line">class                   Functions for Classification</span><br><span class="line">cluster                 &quot;Finding Groups in Data&quot;: Cluster Analysis</span><br><span class="line">                        Extended Rousseeuw et al.</span><br><span class="line">codetools               Code Analysis Tools for R</span><br><span class="line">compiler                The R Compiler Package</span><br><span class="line">datasets                The R Datasets Package</span><br><span class="line">foreign                 Read Data Stored by &#x27;Minitab&#x27;, &#x27;S&#x27;, &#x27;SAS&#x27;,</span><br><span class="line">                        &#x27;SPSS&#x27;, &#x27;Stata&#x27;, &#x27;Systat&#x27;, &#x27;Weka&#x27;, &#x27;dBase&#x27;, ...</span><br><span class="line">graphics                The R Graphics Package</span><br><span class="line">grDevices               The R Graphics Devices and Support for Colours</span><br><span class="line">                        and Fonts</span><br><span class="line">grid                    The Grid Graphics Package</span><br><span class="line">KernSmooth              Functions for Kernel Smoothing Supporting Wand</span><br><span class="line">                        &amp; Jones (1995)</span><br><span class="line">lattice                 Trellis Graphics for R</span><br><span class="line">MASS                    Support Functions and Datasets for Venables and</span><br><span class="line">                        Ripley&#x27;s MASS</span><br></pre></td></tr></table></figure><h3 id="查看已载入的包">查看已载入的包</h3><p>我们可以使用以下函数来查看编译环境已载入的包：</p><h2 id="实例-119">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\&gt; search()  </span><br><span class="line">\[1\] &quot;.GlobalEnv&quot;        &quot;package:stats&quot;     &quot;package:graphics&quot;  </span><br><span class="line">\[4\] &quot;package:grDevices&quot; &quot;package:utils&quot;     &quot;package:datasets&quot;  </span><br><span class="line">\[7\] &quot;package:methods&quot;   &quot;Autoloads&quot;         &quot;package:base&quot;    </span><br></pre></td></tr></table></figure><hr><h2 id="安装新包">安装新包</h2><p>安装新包可以使用 <strong>install.packages()</strong> 函数，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(&quot;要安装的包名&quot;)</span><br></pre></td></tr></table></figure><p>我们可以直接设置包名，从 <a href="https://cran.r-project.org/web/packages/available_packages_by_name.html">CRAN</a> 网站上获取包，如下实例我们载入 XML 包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装 XML 包</span><br><span class="line">install.packages(&quot;XML&quot;)</span><br></pre></td></tr></table></figure><p>或者我们可以直接在 <a href="https://cran.r-project.org/web/packages/available_packages_by_name.html">CRAN</a> 上下载相关包，直接在本地安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(&quot;./XML_3.98-1.3.zip&quot;)</span><br></pre></td></tr></table></figure><p>我们国内一般建议大家使用国内镜像，以下实例使用中国科学技术大学源进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装 XML 包</span><br><span class="line">install.packages(&quot;XML&quot;, repos = &quot;https://mirrors.ustc.edu.cn/CRAN/&quot;)</span><br></pre></td></tr></table></figure><p>CRAN (The Comprehensive R Archive Network) 镜像源配置文件之一是 .Rprofile (linux 下位于 ~/.Rprofile )。</p><p>在文末添加如下语句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options(&quot;repos&quot; = c(CRAN=&quot;https://mirrors.tuna.tsinghua.edu.cn/CRAN/&quot;))</span><br></pre></td></tr></table></figure><p>打开 R 即可使用该 CRAN 镜像源安装 R 软件包。</p><h3 id="使用包">使用包</h3><p>新安装的包需要先载入 R 编译环境中才可以使用，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">library(&quot;包名&quot;)</span><br></pre></td></tr></table></figure><p>以下实例载入 XML 包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">library(&quot;XML&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> R语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言-环境安装</title>
      <link href="/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="R-环境安装">R 环境安装</h2><p>R 语言的开发环境本身具备了图形开发环境，这与其他很多工程语言是不同的，所以开发环境最好安装在为桌面个人计算机设计的操作系统上（如 Windows, macOS 或 Ubuntu 桌面版 等）。</p><p>首先，我们需要下载 R 语言环境的安装包：</p><h3 id="Windows">Windows</h3><ul><li>官方地址：<a href="https://cloud.r-project.org/bin/windows/base/">https://cloud.r-project.org/bin/windows/base/</a></li><li>USTC 镜像：<a href="https://mirrors.ustc.edu.cn/CRAN/bin/windows/base/">https://mirrors.ustc.edu.cn/CRAN/bin/windows/base/</a></li><li>TUNA 镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/windows/base/">https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/windows/base/</a></li></ul><h3 id="Linux">Linux</h3><ul><li>官方地址：<a href="https://cloud.r-project.org/bin/linux/">https://cloud.r-project.org/bin/linux/</a></li><li>USTC 镜像：<a href="https://mirrors.ustc.edu.cn/CRAN/bin/linux/">https://mirrors.ustc.edu.cn/CRAN/bin/linux/</a></li><li>TUNA 镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/linux/">https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/linux/</a></li></ul><h3 id="macOS">macOS</h3><ul><li>官方地址：<a href="https://cloud.r-project.org/bin/macosx/">https://cloud.r-project.org/bin/macosx/</a></li><li>USTC 镜像：<a href="https://mirrors.ustc.edu.cn/CRAN/bin/macosx/">https://mirrors.ustc.edu.cn/CRAN/bin/macosx/</a></li><li>TUNA 镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/macosx/">https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/macosx/</a></li></ul><p>以上的版本有可能是过时的，如果你需要最新版本，可以访问：</p><ul><li>清华大学源： <a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/">https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/</a></li><li>官网：<a href="https://cloud.r-project.org/bin/">https://cloud.r-project.org/bin/</a></li></ul><hr><h2 id="Windows-操作系统">Windows 操作系统</h2><p>Windows 安装很简单，下载安装包后，双击下载的安装包，开始安装向导：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-setup-1.png" alt=""></p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-setup-2.png" alt=""></p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-setup-3.png" alt=""></p><p>**注意：**这里使用的操作系统是 64 位的，但现在仍有少数的计算机使用的是 32 位的操作系统，如果你的操作系统是 32 位的，请在此步骤选择&quot;32-bit 用户安装&quot;选项。</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-setup-4.png" alt=""></p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-setup-5.png" alt=""></p><p>当我们在交互式的命令窗口输入以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;Hello, world&quot;)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Hello, world&quot;</span><br></pre></td></tr></table></figure><h2 id="Linux-2">Linux</h2><h3 id="Ubuntu-安装">Ubuntu 安装</h3><p>执行以下命令安装 R 语言执行环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt update</span><br><span class="line"># sudo apt -y upgrade</span><br><span class="line"># sudo apt -y install r-base</span><br></pre></td></tr></table></figure><p>安装成功后，执行 R 命令就可以进入交互式的编程窗口了：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/AA1FF155-B2EB-48F9-8660-DB32706A134B.jpg" alt=""></p><h3 id="Centos-安装">Centos 安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo yum install R</span><br></pre></td></tr></table></figure><p>输入以下命令，查看安装的版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># R --version</span><br></pre></td></tr></table></figure><p>交互式命令可以通过输入 q() 来退出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; q()</span><br><span class="line">Save workspace image? [y/n/c]: y</span><br></pre></td></tr></table></figure><h2 id="macOS-安装">macOS 安装</h2><p>macOS 安装 R 语言环境类似 Windows，下载 pkg 安装包，双击安装包打开，然后按安装向导安装：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/R-setup-macos-1.jpg" alt=""></p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/R-setup-macos-2.jpg" alt=""></p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/R-setup-macos-3.jpg" alt=""></p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/R-setup-macos-4.jpg" alt=""></p><p>安装成功后，执行 R 命令就可以进入交互式的编程窗口了：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/AA89F11A-9180-4BD0-8A6A-4BE2FD5F1E8E.jpg" alt=""></p><p>交互式命令可以通过输入 q() 来退出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; q()</span><br><span class="line">Save workspace image? [y/n/c]: y</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/DDF9B88F-3BBC-4679-9D93-565E4D0ABBAB.jpg" alt=""></p><h3 id="脚本执行">脚本执行</h3><p>在 R 语言中，可以在命令行中使用 Rscript 命令来执行 R 脚本文件。</p><p>Rscript 命令允许您直接从命令行运行 R 脚本，而无需打开 R 控制台。。</p><p>要使用 Rscript命令 执行 R 脚本文件，可以按照以下步骤进行操作：</p><p>创建一个 R 脚本文件，其中包含要执行的R代码。例如，将以下代码保存为 <strong>script.R</strong> 文件：</p><h2 id="script-R-文件代码：">script.R 文件代码：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\# script.R  </span><br><span class="line">x &lt;- 1:10  </span><br><span class="line">y &lt;- x^2  </span><br><span class="line">print(y)  </span><br></pre></td></tr></table></figure><p>打开终端或命令行界面，进入当前文件 <strong>script.R</strong> 所在目录，在命令行中使用 Rscript 命令来执行脚本文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rscript script.R</span><br></pre></td></tr></table></figure><p>执行以上命令后，R 脚本文件将被 Rscript 解释器读取和执行。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> R语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
