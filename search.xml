<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JAVA-网络编程</title>
      <link href="/2025/05/24/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2025/05/24/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>在学习Java网络编程之前，我们先来了解什么是计算机网络。</p><p>计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。</p><p>那什么是互联网呢？互联网是网络的网络（Internet），即把很多计算机网络连接起来，形成一个全球统一的互联网。</p><p>对某个特定的计算机网络来说，它可能使用网络协议ABC，而另一个计算机网络可能使用网络协议XYZ。如果计算机网络各自的通讯协议不统一，就没法把不同的网络连接起来形成互联网。因此，为了把计算机网络接入互联网，就必须使用TCP/IP协议。</p><p>TCP/IP协议泛指互联网协议，其中最重要的两个协议是TCP协议和IP协议。只有使用TCP/IP协议的计算机才能够联入互联网，使用其他网络协议（例如NetBIOS、AppleTalk协议等）是无法联入互联网的。</p><h3 id="IP地址">IP地址</h3><p>在互联网中，一个IP地址用于唯一标识一个网络接口（Network Interface）。一台联入互联网的计算机肯定有一个IP地址，但也可能有多个IP地址。</p><p>IP地址分为IPv4和IPv6两种。IPv4采用32位地址，类似<code>101.202.99.12</code>，而IPv6采用128位地址，类似<code>2001:0DA8:100A:0000:0000:1020:F2F3:1428</code>。IPv4地址总共有232个（大约42亿），而IPv6地址则总共有2128个（大约340万亿亿亿亿），IPv4的地址目前已耗尽，而IPv6的地址是根本用不完的。</p><p>IP地址又分为公网IP地址和内网IP地址。公网IP地址可以直接被访问，内网IP地址只能在内网访问。内网IP地址类似于：</p><ul><li>192.168.x.x</li><li>10.x.x.x</li></ul><p>有一个特殊的IP地址，称之为本机地址，它总是<code>127.0.0.1</code>。</p><p>IPv4地址实际上是一个32位整数。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1707762444 = 0x65ca630c</span><br><span class="line">           = 65  ca  63 0c</span><br><span class="line">           = 101.202.99.12</span><br></pre></td></tr></table></figure><p>如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址<code>127.0.0.1</code>，还有一个IP地址，例如<code>101.202.99.12</code>，可以通过这个IP地址接入网络。</p><p>如果一台计算机有两块网卡，那么除了本机地址，它可以有两个IP地址，可以分别接入两个网络。通常连接两个网络的设备是路由器或者交换机，它至少有两个IP地址，分别接入不同的网络，让网络之间连接起来。</p><p>如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的IP地址前段是相同的，也就是网络号是相同的。网络号是IP地址通过子网掩码过滤后得到的。例如：</p><p>某台计算机的IP是<code>101.202.99.2</code>，子网掩码是<code>255.255.255.0</code>，那么计算该计算机的网络号是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP = 101.202.99.2</span><br><span class="line">Mask = 255.255.255.0</span><br><span class="line">Network = IP &amp; Mask = 101.202.99.0</span><br></pre></td></tr></table></figure><p>每台计算机都需要正确配置IP地址和子网掩码，根据这两个就可以计算网络号，如果两台计算机计算出的网络号相同，说明两台计算机在同一个网络，可以直接通信。如果两台计算机计算出的网络号不同，那么两台计算机不在同一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备间接通信，我们把这种设备称为网关。</p><p>网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫路由。</p><p>所以，一台计算机的一个网卡会有3个关键配置：</p><p><img src="https://liaoxuefeng.com/books/java/network/basic/network-config.png" alt="network"></p><ul><li>IP地址，例如：<code>10.0.2.15</code></li><li>子网掩码，例如：<code>255.255.255.0</code></li><li>网关的IP地址，例如：<code>10.0.2.2</code></li></ul><h3 id="域名">域名</h3><p>因为直接记忆IP地址非常困难，所以我们通常使用域名访问某个特定的服务。域名解析服务器DNS负责把域名翻译成对应的IP，客户端再根据IP地址访问服务器。</p><p>用<code>nslookup</code>可以查看域名对应的IP地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup liaoxuefeng.com</span><br><span class="line">Server:  xxx.xxx.xxx.xxx</span><br><span class="line">Address: xxx.xxx.xxx.xxx#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:    liaoxuefeng.com</span><br><span class="line">Address: xxx.xxx.xxx.xxx</span><br></pre></td></tr></table></figure><p>有一个特殊的本机域名<code>localhost</code>，它对应的IP地址总是本机地址<code>127.0.0.1</code>。</p><h3 id="网络模型">网络模型</h3><p>由于计算机网络从底层的传输到高层的软件设计十分复杂，要合理地设计计算机网络模型，必须采用分层模型，每一层负责处理自己的操作。OSI（Open System Interconnect）网络模型是ISO组织定义的一个计算机互联的标准模型，注意它只是一个定义，目的是为了简化网络各层的操作，提供标准接口便于实现和维护。这个模型从上到下依次是：</p><ul><li>应用层，提供应用程序之间的通信；</li><li>表示层：处理数据格式，加解密等等；</li><li>会话层：负责建立和维护会话；</li><li>传输层：负责提供端到端的可靠传输；</li><li>网络层：负责根据目标地址选择路由来传输数据；</li><li>链路层和物理层负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等。</li></ul><p>互联网实际使用的TCP/IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型：</p><table><thead><tr><th>OSI</th><th>TCP/IP</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td></tr><tr><td>表示层</td><td></td></tr><tr><td>会话层</td><td></td></tr><tr><td>传输层</td><td>传输层</td></tr><tr><td>网络层</td><td>IP层</td></tr><tr><td>链路层</td><td>网络接口层</td></tr><tr><td>物理层</td><td></td></tr></tbody></table><h3 id="常用协议">常用协议</h3><p>IP协议是一个分组交换，它不保证可靠传输。而TCP协议是传输控制协议，它是面向连接的协议，支持可靠传输和双向通信。TCP协议是建立在IP协议之上的，简单地说，IP协议只负责发数据包，不保证顺序和正确性，而TCP协议负责控制数据包传输，它在传输数据之前需要先建立连接，建立连接后才能传输数据，传输完后还需要断开连接。TCP协议之所以能保证数据的可靠传输，是通过接收确认、超时重传这些机制实现的。并且，TCP协议允许双向通信，即通信双方可以同时发送和接收数据。</p><p>TCP协议也是应用最广泛的协议，许多高级协议都是建立在TCP协议之上的，例如HTTP、SMTP等。</p><p>UDP协议（User Datagram Protocol）是一种数据报文协议，它是无连接协议，不保证可靠传输。因为UDP协议在通信前不需要建立连接，因此它的传输效率比TCP高，而且UDP协议比TCP协议要简单得多。</p><p>选择UDP协议时，传输的数据通常是能容忍丢失的，例如，一些语音视频通信的应用会选择UDP协议。</p><h3 id="小结">小结</h3><p>计算机网络的基本概念主要有：</p><ul><li>计算机网络：由两台或更多计算机组成的网络；</li><li>互联网：连接网络的网络；</li><li>IP地址：计算机的网络接口（通常是网卡）在网络中的唯一标识；</li><li>网关：负责连接多个网络，并在多个网络之间转发数据的计算机，通常是路由器或交换机；</li><li>网络协议：互联网使用TCP/IP协议，它泛指互联网协议簇；</li><li>IP协议：一种分组交换传输协议；</li><li>TCP协议：一种面向连接，可靠传输的协议；</li><li>UDP协议：一种无连接，不可靠传输的协议。</li></ul><p>在开发网络应用程序的时候，我们又会遇到Socket这个概念。Socket是一个抽象概念，一个应用程序通过一个Socket来建立一个远程连接，而Socket内部通过TCP/IP协议把数据传输到网络：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌───────────┐                                ┌───────────┐</span><br><span class="line">│Application│                                │Application│</span><br><span class="line">├───────────┤                                ├───────────┤</span><br><span class="line">│  Socket   │                                │  Socket   │</span><br><span class="line">├───────────┤                                ├───────────┤</span><br><span class="line">│    TCP    │                                │    TCP    │</span><br><span class="line">├───────────┤     ┌──────┐      ┌──────┐     ├───────────┤</span><br><span class="line">│    IP     │◀───▶│Router│◀────▶│Router│◀───▶│    IP     │</span><br><span class="line">└───────────┘     └──────┘      └──────┘     └───────────┘</span><br></pre></td></tr></table></figure><p>Socket、TCP和部分IP的功能都是由操作系统提供的，不同的编程语言只是提供了对操作系统调用的简单的封装。例如，Java提供的几个Socket相关的类就封装了操作系统提供的接口。</p><p>为什么需要Socket进行网络通信？因为仅仅通过IP地址进行通信是不够的，同一台计算机同一时间会运行多个网络应用程序，例如浏览器、QQ、邮件客户端等。当操作系统接收到一个数据包的时候，如果只有IP地址，它没法判断应该发给哪个应用程序，所以，操作系统抽象出Socket接口，每个应用程序需要各自对应到不同的Socket，数据包才能根据Socket正确地发到对应的应用程序。</p><p>一个Socket就是由IP地址和端口号（范围是0～65535）组成，可以把Socket简单理解为IP地址加端口号。端口号总是由操作系统分配，它是一个0～65535之间的数字，其中，小于1024的端口属于<em>特权端口</em>，需要管理员权限，大于1024的端口可以由任意用户的应用程序打开。</p><ul><li>Browser: 101.202.99.2:1201</li><li>QQ: 101.202.99.2:1304</li><li>Email: 101.202.99.2:15000</li></ul><p>使用Socket进行网络编程时，本质上就是两个进程之间的网络通信。其中一个进程必须充当服务器端，它会主动监听某个指定的端口，另一个进程必须充当客户端，它必须主动连接服务器的IP地址和指定端口，如果连接成功，服务器端和客户端就成功地建立了一个TCP连接，双方后续就可以随时发送和接收数据。</p><p>因此，当Socket连接成功地在服务器端和客户端之间建立后：</p><ul><li>对服务器端来说，它的Socket是指定的IP地址和指定的端口号；</li><li>对客户端来说，它的Socket是它所在计算机的IP地址和一个由操作系统分配的随机端口号。</li></ul><h3 id="服务器端">服务器端</h3><p>要使用Socket编程，我们首先要编写服务器端程序。Java标准库提供了<code>ServerSocket</code>来实现对指定IP和指定端口的监听。<code>ServerSocket</code>的典型实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>); <span class="comment">// 监听指定端口</span></span><br><span class="line">        System.out.println(<span class="string">&quot;server is running...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;connected from &quot;</span> + sock.getRemoteSocketAddress());</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(sock);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Socket sock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(Socket sock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sock = sock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="built_in">this</span>.sock.getInputStream()) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="built_in">this</span>.sock.getOutputStream()) &#123;</span><br><span class="line">                handle(input, output);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.sock.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;client disconnected.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(InputStream input, OutputStream output)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(output, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="type">var</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(input, StandardCharsets.UTF_8));</span><br><span class="line">        writer.write(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;bye&quot;</span>)) &#123;</span><br><span class="line">                writer.write(<span class="string">&quot;bye\n&quot;</span>);</span><br><span class="line">                writer.flush();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            writer.write(<span class="string">&quot;ok: &quot;</span> + s + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端通过代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure><p>在指定端口<code>6666</code>监听。这里我们没有指定IP地址，表示在计算机的所有网络接口上进行监听。</p><p>如果<code>ServerSocket</code>监听成功，我们就使用一个无限循环来处理客户端的连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(sock);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到代码<code>ss.accept()</code>表示每当有新的客户端连接进来后，就返回一个<code>Socket</code>实例，这个<code>Socket</code>实例就是用来和刚连接的客户端进行通信的。由于客户端很多，要实现并发处理，我们就必须为每个新的<code>Socket</code>创建一个新线程来处理，这样，主线程的作用就是接收新的连接，每当收到新连接后，就创建一个新线程进行处理。</p><p>我们在多线程编程的章节中介绍过线程池，这里也完全可以利用线程池来处理客户端连接，能大大提高运行效率。</p><p>如果没有客户端连接进来，<code>accept()</code>方法会阻塞并一直等待。如果有多个客户端同时连接进来，<code>ServerSocket</code>会把连接扔到队列里，然后一个一个处理。对于Java程序而言，只需要通过循环不断调用<code>accept()</code>就可以获取新的连接。</p><h3 id="客户端">客户端</h3><p>相比服务器端，客户端程序就要简单很多。一个典型的客户端程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>); <span class="comment">// 连接指定服务器和端口</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> sock.getInputStream()) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> sock.getOutputStream()) &#123;</span><br><span class="line">                handle(input, output);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sock.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;disconnected.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(InputStream input, OutputStream output)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(output, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="type">var</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(input, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;[server] &quot;</span> + reader.readLine());</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine(); <span class="comment">// 读取一行输入</span></span><br><span class="line">            writer.write(s);</span><br><span class="line">            writer.newLine();</span><br><span class="line">            writer.flush();</span><br><span class="line">            <span class="type">String</span> <span class="variable">resp</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;&lt;&lt;&lt; &quot;</span> + resp);</span><br><span class="line">            <span class="keyword">if</span> (resp.equals(<span class="string">&quot;bye&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端程序通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br></pre></td></tr></table></figure><p>连接到服务器端，注意上述代码的服务器地址是<code>&quot;localhost&quot;</code>，表示本机地址，端口号是<code>6666</code>。如果连接成功，将返回一个<code>Socket</code>实例，用于后续通信。</p><h3 id="Socket流">Socket流</h3><p>当Socket连接创建成功后，无论是服务器端，还是客户端，我们都使用<code>Socket</code>实例进行网络通信。因为TCP是一种基于流的协议，因此，Java标准库使用<code>InputStream</code>和<code>OutputStream</code>来封装Socket的数据流，这样我们使用Socket的流，和普通IO流类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于读取网络数据:</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> sock.getInputStream();</span><br><span class="line"><span class="comment">// 用于写入网络数据:</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> sock.getOutputStream();</span><br></pre></td></tr></table></figure><p>最后我们重点来看看，为什么写入网络数据时，要调用<code>flush()</code>方法。</p><p>如果不调用<code>flush()</code>，我们很可能会发现，客户端和服务器都收不到数据，这并不是Java标准库的设计问题，而是我们以流的形式写入数据的时候，并不是一写入就立刻发送到网络，而是先写入内存缓冲区，直到缓冲区满了以后，才会一次性真正发送到网络，这样设计的目的是为了提高传输效率。如果缓冲区的数据很少，而我们又想强制把这些数据发送到网络，就必须调用<code>flush()</code>强制把缓冲区数据发送出去。</p><h3 id="练习">练习</h3><p>使用Socket实现服务器和客户端通信。</p><p><a href="https://liaoxuefeng.com/books/java/network/tcp/network-socket.zip">下载练习</a></p><h3 id="小结-2">小结</h3><p>使用Java进行TCP编程时，需要使用Socket模型：</p><ul><li>服务器端用<code>ServerSocket</code>监听指定端口；</li><li>客户端使用<code>Socket(InetAddress, port)</code>连接服务器；</li><li>服务器端用<code>accept()</code>接收连接并返回<code>Socket</code>；</li><li>双方通过<code>Socket</code>打开<code>InputStream</code>/<code>OutputStream</code>读写数据；</li><li>服务器端通常使用多线程同时处理多个客户端连接，利用线程池可大幅提升效率；</li><li><code>flush()</code>用于强制输出缓冲区到网络。</li></ul><p>和TCP编程相比，UDP编程就简单得多，因为UDP没有创建连接，数据包也是一次收发一个，所以没有流的概念。</p><p>在Java中使用UDP编程，仍然需要使用Socket，因为应用程序在使用UDP时必须指定网络接口（IP）和端口号。注意：UDP端口和TCP端口虽然都使用0~65535，但他们是两套独立的端口，即一个应用程序用TCP占用了端口1234，不影响另一个应用程序用UDP占用端口1234。</p><h3 id="服务器端-2">服务器端</h3><p>在服务器端，使用UDP也需要监听指定的端口。Java提供了<code>DatagramSocket</code>来实现这个功能，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">6666</span>); <span class="comment">// 监听指定端口</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">    <span class="comment">// 数据缓冲区:</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line">    ds.receive(packet); <span class="comment">// 收取一个UDP数据包</span></span><br><span class="line">    <span class="comment">// 收取到的数据存储在buffer中，由packet.getOffset(), packet.getLength()指定起始位置和长度</span></span><br><span class="line">    <span class="comment">// 将其按UTF-8编码转换为String:</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8);</span><br><span class="line">    <span class="comment">// 发送数据:</span></span><br><span class="line">    <span class="type">byte</span>[] data = <span class="string">&quot;ACK&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    packet.setData(data);</span><br><span class="line">    ds.send(packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端首先使用如下语句在指定的端口监听UDP数据包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure><p>如果没有其他应用程序占据这个端口，那么监听成功，我们就使用一个无限循环来处理收到的UDP数据包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要接收一个UDP数据包，需要准备一个<code>byte[]</code>缓冲区，并通过<code>DatagramPacket</code>实现接收：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line">ds.receive(packet);</span><br></pre></td></tr></table></figure><p>假设我们收取到的是一个<code>String</code>，那么，通过<code>DatagramPacket</code>返回的<code>packet.getOffset()</code>和<code>packet.getLength()</code>确定数据在缓冲区的起止位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure><p>当服务器收到一个DatagramPacket后，通常必须立刻回复一个或多个UDP包，因为客户端地址在DatagramPacket中，每次收到的DatagramPacket可能是不同的客户端，如果不回复，客户端就收不到任何UDP包。</p><p>发送UDP包也是通过<code>DatagramPacket</code>实现的，发送代码非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] data = ...</span><br><span class="line">packet.setData(data);</span><br><span class="line">ds.send(packet);</span><br></pre></td></tr></table></figure><h3 id="客户端-2">客户端</h3><p>和服务器端相比，客户端使用UDP时，只需要直接向服务器端发送UDP包，然后接收返回的UDP包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">ds.setSoTimeout(<span class="number">1000</span>);</span><br><span class="line">ds.connect(InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">6666</span>); <span class="comment">// 连接指定服务器和端口</span></span><br><span class="line"><span class="comment">// 发送:</span></span><br><span class="line"><span class="type">byte</span>[] data = <span class="string">&quot;Hello&quot;</span>.getBytes();</span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data, data.length);</span><br><span class="line">ds.send(packet);</span><br><span class="line"><span class="comment">// 接收:</span></span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">packet = <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line">ds.receive(packet);</span><br><span class="line"><span class="type">String</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), packet.getOffset(), packet.getLength());</span><br><span class="line">ds.disconnect();</span><br><span class="line"><span class="comment">// 关闭:</span></span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure><p>客户端打开一个<code>DatagramSocket</code>使用以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">ds.setSoTimeout(<span class="number">1000</span>);</span><br><span class="line">ds.connect(InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">6666</span>);</span><br></pre></td></tr></table></figure><p>客户端创建<code>DatagramSocket</code>实例时并不需要指定端口，而是由操作系统自动指定一个当前未使用的端口。紧接着，调用<code>setSoTimeout(1000)</code>设定超时1秒，意思是后续接收UDP包时，等待时间最多不会超过1秒，否则在没有收到UDP包时，客户端会无限等待下去。这一点和服务器端不一样，服务器端可以无限等待，因为它本来就被设计成长时间运行。</p><p>注意到客户端的<code>DatagramSocket</code>还调用了一个<code>connect()</code>方法“连接”到指定的服务器端。不是说UDP是无连接的协议吗？为啥这里需要<code>connect()</code>？</p><p>这个<code>connect()</code>方法不是真连接，它是为了在客户端的<code>DatagramSocket</code>实例中保存服务器端的IP和端口号，确保这个<code>DatagramSocket</code>实例只能往指定的地址和端口发送UDP包，不能往其他地址和端口发送。这么做不是UDP的限制，而是Java内置了安全检查。</p><p>后续的收发数据和服务器端是一致的。通常来说，客户端必须先发UDP包，因为客户端不发UDP包，服务器端就根本不知道客户端的地址和端口号。</p><p>如果客户端认为通信结束，就可以调用<code>disconnect()</code>断开连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds.disconnect();</span><br></pre></td></tr></table></figure><p>注意到<code>disconnect()</code>也不是真正地断开连接，它只是清除了客户端<code>DatagramSocket</code>实例记录的远程服务器地址和端口号，这样，<code>DatagramSocket</code>实例就可以连接另一个服务器端。</p><p>如果客户端希望向两个不同的服务器发送UDP包，有两种方法：</p><ol><li>客户端可以创建两个<code>DatagramSocket</code>实例，用<code>connect()</code>连接到不同的服务器；</li><li>客户端也可以不调用<code>connect()</code>方法，而是在创建<code>DatagramPacket</code>的时候指定服务器地址，这样可以用一个<code>DatagramSocket</code>实例发送<code>DatagramPacket</code>到不同的服务器。</li></ol><p>不调用<code>connect()</code>方法的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">ds.setSoTimeout(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 发送到localhost:6666:</span></span><br><span class="line"><span class="type">byte</span>[] data1 = <span class="string">&quot;Hello&quot;</span>.getBytes();</span><br><span class="line"><span class="type">var</span> <span class="variable">packet1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data1, data1.length, InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">6666</span>);</span><br><span class="line">ds.send(packet1);</span><br><span class="line"><span class="comment">// 发送到localhost:8888:</span></span><br><span class="line"><span class="type">byte</span>[] data2 = <span class="string">&quot;Hi&quot;</span>.getBytes();</span><br><span class="line"><span class="type">var</span> <span class="variable">packet2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data2, data2.length, InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">8888</span>);</span><br><span class="line">ds.send(packet2);</span><br><span class="line"><span class="comment">// 关闭:</span></span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure><h3 id="练习-2">练习</h3><p>使用UDP实现服务器和客户端通信。</p><p><a href="https://liaoxuefeng.com/books/java/network/udp/network-datagram.zip">下载练习</a></p><h3 id="小结-3">小结</h3><p>使用UDP协议通信时，服务器和客户端双方无需建立连接：</p><ul><li>服务器端用<code>DatagramSocket(port)</code>监听端口；</li><li>客户端使用<code>DatagramSocket.connect()</code>指定远程地址和端口；</li><li>双方通过<code>receive()</code>和<code>send()</code>读写数据；</li><li><code>DatagramSocket</code>没有IO流接口，数据被直接写入<code>byte[]</code>缓冲区。</li></ul><p>Email就是电子邮件。电子邮件的应用已经有几十年的历史了，我们熟悉的邮箱地址比如<code>abc@example.com</code>，邮件软件比如Outlook都是用来收发邮件的。</p><p>使用Java程序也可以收发电子邮件。我们先来看一下传统的邮件是如何发送的。</p><p>传统的邮件是通过邮局投递，然后从一个邮局到另一个邮局，最终到达用户的邮箱：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">           ┌──────────┐    ┌──────────┐</span><br><span class="line">           │PostOffice│    │PostOffice│     .───.</span><br><span class="line">┌─────┐    ├──────────┤    ├──────────┤    (   ( )</span><br><span class="line">│═══ ░│───▶│ ┌─┐ ┌┐┌┐ │───▶│ ┌─┐ ┌┐┌┐ │───▶ `─┬─&#x27;</span><br><span class="line">└─────┘    │ │░│ └┘└┘ │    │ │░│ └┘└┘ │       │</span><br><span class="line">           └─┴─┴──────┘    └─┴─┴──────┘       │</span><br></pre></td></tr></table></figure><p>电子邮件的发送过程也是类似的，只不过是电子邮件是从用户电脑的邮件软件，例如Outlook，发送到邮件服务器上，可能经过若干个邮件服务器的中转，最终到达对方邮件服务器上，收件方就可以用软件接收邮件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">             ┌─────────┐    ┌─────────┐    ┌─────────┐</span><br><span class="line">             │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│</span><br><span class="line">┌───────┐    ├─────────┤    ├─────────┤    ├─────────┤    ┌───────┐</span><br><span class="line">│░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░│</span><br><span class="line">├───────┤    ├─────────┤    ├─────────┤    ├─────────┤    ├───────┤</span><br><span class="line">│       │───▶│O ░░░░░░░│───▶│O ░░░░░░░│───▶│O ░░░░░░░│◀───│       │</span><br><span class="line">└───────┘    └─────────┘    └─────────┘    └─────────┘    └───────┘</span><br><span class="line">   MUA           MTA            MTA            MDA           MUA</span><br></pre></td></tr></table></figure><p>我们把类似Outlook这样的邮件软件称为MUA：Mail User Agent，意思是给用户服务的邮件代理；邮件服务器则称为MTA：Mail Transfer Agent，意思是邮件中转的代理；最终到达的邮件服务器称为MDA：Mail Delivery Agent，意思是邮件到达的代理。电子邮件一旦到达MDA，就不再动了。实际上，电子邮件通常就存储在MDA服务器的硬盘上，然后等收件人通过软件或者登陆浏览器查看邮件。</p><p>MTA和MDA这样的服务器软件通常是现成的，我们不关心这些服务器内部是如何运行的。要发送邮件，我们关心的是如何编写一个MUA的软件，把邮件发送到MTA上。</p><p>MUA到MTA发送邮件的协议就是SMTP协议，它是Simple Mail Transport Protocol的缩写，使用标准端口<code>25</code>，也可以使用加密端口<code>465</code>或<code>587</code>。</p><p>SMTP协议是一个建立在TCP之上的协议，任何程序发送邮件都必须遵守SMTP协议。使用Java程序发送邮件时，我们无需关心SMTP协议的底层原理，只需要使用JavaMail这个标准API就可以直接发送邮件。</p><h3 id="准备SMTP登录信息">准备SMTP登录信息</h3><p>假设我们准备使用自己的邮件地址<code>me@example.com</code>给小明发送邮件，已知小明的邮件地址是<code>xiaoming@somewhere.com</code>，发送邮件前，我们首先要确定作为MTA的邮件服务器地址和端口号。邮件服务器地址通常是<code>smtp.example.com</code>，端口号由邮件服务商确定使用25、465还是587。以下是一些常用邮件服务商的SMTP信息：</p><ul><li>QQ邮箱：SMTP服务器是<code>smtp.qq.com</code>，端口是465/587；</li><li>163邮箱：SMTP服务器是<code>smtp.163.com</code>，端口是465；</li><li>Gmail邮箱：SMTP服务器是<code>smtp.gmail.com</code>，端口是465/587。</li></ul><p>有了SMTP服务器的域名和端口号，我们还需要SMTP服务器的登录信息，通常是使用自己的邮件地址作为用户名，登录口令是用户口令或者一个独立设置的SMTP口令。</p><p>我们来看看如何使用JavaMail发送邮件。</p><p>首先，我们需要创建一个Maven工程，并把JavaMail相关的两个依赖加入进来：</p><ul><li>jakarta.mail:javax.mail-api:2.0.1</li><li>com.sun.mail:jakarta.mail:2.0.1</li></ul><p>这两个包一个是接口定义，一个是具体实现。如果使用早期的1.x版本，则需注意引入的包名有所不同：</p><ul><li>javax.mail:javax.mail-api:1.6.2</li><li>com.sun.mail:javax.mail:1.6.2</li></ul><p>并且代码引用的<code>jakarta.mail</code>需替换为<code>javax.mail</code>。</p><p>然后，我们通过JavaMail API连接到SMTP服务器上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器地址:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">smtp</span> <span class="operator">=</span> <span class="string">&quot;smtp.office365.com&quot;</span>;</span><br><span class="line"><span class="comment">// 登录用户名:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;jxsmtp101@outlook.com&quot;</span>;</span><br><span class="line"><span class="comment">// 登录口令:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;********&quot;</span>;</span><br><span class="line"><span class="comment">// 连接到SMTP服务器587端口:</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.host&quot;</span>, smtp); <span class="comment">// SMTP主机名</span></span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.port&quot;</span>, <span class="string">&quot;587&quot;</span>); <span class="comment">// 主机端口号</span></span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.auth&quot;</span>, <span class="string">&quot;true&quot;</span>); <span class="comment">// 是否需要用户认证</span></span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.starttls.enable&quot;</span>, <span class="string">&quot;true&quot;</span>); <span class="comment">// 启用TLS加密</span></span><br><span class="line"><span class="comment">// 获取Session实例:</span></span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> Session.getInstance(props, <span class="keyword">new</span> <span class="title class_">Authenticator</span>() &#123;</span><br><span class="line">    <span class="keyword">protected</span> PasswordAuthentication <span class="title function_">getPasswordAuthentication</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PasswordAuthentication</span>(username, password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 设置debug模式便于调试:</span></span><br><span class="line">session.setDebug(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>以587端口为例，连接SMTP服务器时，需要准备一个<code>Properties</code>对象，填入相关信息。最后获取<code>Session</code>实例时，如果服务器需要认证，还需要传入一个<code>Authenticator</code>对象，并返回指定的用户名和口令。</p><p>当我们获取到<code>Session</code>实例后，打开调试模式可以看到SMTP通信的详细内容，便于调试。</p><h3 id="发送邮件">发送邮件</h3><p>发送邮件时，我们需要构造一个<code>Message</code>对象，然后调用<code>Transport.send(Message)</code>即可完成发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessage</span>(session);</span><br><span class="line"><span class="comment">// 设置发送方地址:</span></span><br><span class="line">message.setFrom(<span class="keyword">new</span> <span class="title class_">InternetAddress</span>(<span class="string">&quot;me@example.com&quot;</span>));</span><br><span class="line"><span class="comment">// 设置接收方地址:</span></span><br><span class="line">message.setRecipient(Message.RecipientType.TO, <span class="keyword">new</span> <span class="title class_">InternetAddress</span>(<span class="string">&quot;xiaoming@somewhere.com&quot;</span>));</span><br><span class="line"><span class="comment">// 设置邮件主题:</span></span><br><span class="line">message.setSubject(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// 设置邮件正文:</span></span><br><span class="line">message.setText(<span class="string">&quot;Hi Xiaoming...&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// 发送:</span></span><br><span class="line">Transport.send(message);</span><br></pre></td></tr></table></figure><p>绝大多数邮件服务器要求发送方地址和登录用户名必须一致，否则发送将失败。</p><p>填入真实的地址，运行上述代码，我们可以在控制台看到JavaMail打印的调试信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">这是JavaMail打印的调试信息:</span><br><span class="line">DEBUG: setDebug: JavaMail version 1.6.2</span><br><span class="line">DEBUG: getProvider() returning javax.mail.Provider[TRANSPORT,smtp,com.sun.mail.smtp.SMTPTransport,Oracle]</span><br><span class="line">DEBUG SMTP: need username and password for authentication</span><br><span class="line">DEBUG SMTP: protocolConnect returning false, host=smtp.office365.com, ...</span><br><span class="line">DEBUG SMTP: useEhlo true, useAuth true</span><br><span class="line">开始尝试连接smtp.office365.com:</span><br><span class="line">DEBUG SMTP: trying to connect to host &quot;smtp.office365.com&quot;, port 587, ...</span><br><span class="line">DEBUG SMTP: connected to host &quot;smtp.office365.com&quot;, port: 587</span><br><span class="line">发送命令EHLO:</span><br><span class="line">EHLO localhost</span><br><span class="line">SMTP服务器响应250:</span><br><span class="line">250-SG3P274CA0024.outlook.office365.com Hello</span><br><span class="line">250-SIZE 157286400</span><br><span class="line">...</span><br><span class="line">DEBUG SMTP: Found extension &quot;SIZE&quot;, arg &quot;157286400&quot;</span><br><span class="line">发送命令STARTTLS:</span><br><span class="line">STARTTLS</span><br><span class="line">SMTP服务器响应220:</span><br><span class="line">220 2.0.0 SMTP server ready</span><br><span class="line">EHLO localhost</span><br><span class="line">250-SG3P274CA0024.outlook.office365.com Hello [111.196.164.63]</span><br><span class="line">250-SIZE 157286400</span><br><span class="line">250-PIPELINING</span><br><span class="line">250-...</span><br><span class="line">DEBUG SMTP: Found extension &quot;SIZE&quot;, arg &quot;157286400&quot;</span><br><span class="line">...</span><br><span class="line">尝试登录:</span><br><span class="line">DEBUG SMTP: protocolConnect login, host=smtp.office365.com, user=********, password=********</span><br><span class="line">DEBUG SMTP: Attempt to authenticate using mechanisms: LOGIN PLAIN DIGEST-MD5 NTLM XOAUTH2 </span><br><span class="line">DEBUG SMTP: Using mechanism LOGIN</span><br><span class="line">DEBUG SMTP: AUTH LOGIN command trace suppressed</span><br><span class="line">登录成功:</span><br><span class="line">DEBUG SMTP: AUTH LOGIN succeeded</span><br><span class="line">DEBUG SMTP: use8bit false</span><br><span class="line">开发发送邮件，设置FROM:</span><br><span class="line">MAIL FROM:&lt;********@outlook.com&gt;</span><br><span class="line">250 2.1.0 Sender OK</span><br><span class="line">设置TO:</span><br><span class="line">RCPT TO:&lt;********@sina.com&gt;</span><br><span class="line">250 2.1.5 Recipient OK</span><br><span class="line">发送邮件数据:</span><br><span class="line">DATA</span><br><span class="line">服务器响应354:</span><br><span class="line">354 Start mail input; end with &lt;CRLF&gt;.&lt;CRLF&gt;</span><br><span class="line">真正的邮件数据:</span><br><span class="line">Date: Mon, 2 Dec 2019 09:37:52 +0800 (CST)</span><br><span class="line">From: ********@outlook.com</span><br><span class="line">To: ********001@sina.com</span><br><span class="line">Message-ID: &lt;1617791695.0.1575250672483@localhost&gt;</span><br><span class="line">邮件主题是编码后的文本:</span><br><span class="line">Subject: =?UTF-8?Q?JavaMail=E9=82=AE=E4=BB=B6?=</span><br><span class="line">MIME-Version: 1.0</span><br><span class="line">Content-Type: text/plain; charset=UTF-8</span><br><span class="line">Content-Transfer-Encoding: base64</span><br><span class="line"></span><br><span class="line">邮件正文是Base64编码的文本:</span><br><span class="line">SGVsbG8sIOi/meaYr+S4gOWwgeadpeiHqmphdmFtYWls55qE6YKu5Lu277yB</span><br><span class="line">.</span><br><span class="line">邮件数据发送完成后，以\r\n.\r\n结束，服务器响应250表示发送成功:</span><br><span class="line">250 2.0.0 OK &lt;HK0PR03MB4961.apcprd03.prod.outlook.com&gt; [Hostname=HK0PR03MB4961.apcprd03.prod.outlook.com]</span><br><span class="line">DEBUG SMTP: message successfully delivered to mail server</span><br><span class="line">发送QUIT命令:</span><br><span class="line">QUIT</span><br><span class="line">服务器响应221结束TCP连接:</span><br><span class="line">221 2.0.0 Service closing transmission channel</span><br></pre></td></tr></table></figure><p>从上面的调试信息可以看出，SMTP协议是一个请求-响应协议，客户端总是发送命令，然后等待服务器响应。服务器响应总是以数字开头，后面的信息才是用于调试的文本。这些响应码已经被定义在<a href="https://www.iana.org/assignments/smtp-enhanced-status-codes/smtp-enhanced-status-codes.txt">SMTP协议</a>中了，查看具体的响应码就可以知道出错原因。</p><p>如果一切顺利，对方将收到一封文本格式的电子邮件：</p><p><img src="https://liaoxuefeng.com/books/java/network/send-email/mail-text.png" alt="mail-text"></p><h3 id="发送HTML邮件">发送HTML邮件</h3><p>发送HTML邮件和文本邮件是类似的，只需要把：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message.setText(body, <span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message.setText(body, <span class="string">&quot;UTF-8&quot;</span>, <span class="string">&quot;html&quot;</span>);</span><br></pre></td></tr></table></figure><p>传入的<code>body</code>是类似<code>&lt;h1&gt;Hello&lt;/h1&gt;&lt;p&gt;Hi, xxx&lt;/p&gt;</code>这样的HTML字符串即可。</p><p>HTML邮件可以在邮件客户端直接显示为网页格式：</p><p><img src="https://liaoxuefeng.com/books/java/network/send-email/mail-html.png" alt="mail-html"></p><h3 id="发送附件">发送附件</h3><p>要在电子邮件中携带附件，我们就不能直接调用<code>message.setText()</code>方法，而是要构造一个<code>Multipart</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Multipart</span> <span class="variable">multipart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMultipart</span>();</span><br><span class="line"><span class="comment">// 添加text:</span></span><br><span class="line"><span class="type">BodyPart</span> <span class="variable">textpart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeBodyPart</span>();</span><br><span class="line">textpart.setContent(body, <span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">multipart.addBodyPart(textpart);</span><br><span class="line"><span class="comment">// 添加image:</span></span><br><span class="line"><span class="type">BodyPart</span> <span class="variable">imagepart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeBodyPart</span>();</span><br><span class="line">imagepart.setFileName(fileName);</span><br><span class="line">imagepart.setDataHandler(<span class="keyword">new</span> <span class="title class_">DataHandler</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayDataSource</span>(input, <span class="string">&quot;application/octet-stream&quot;</span>)));</span><br><span class="line">multipart.addBodyPart(imagepart);</span><br><span class="line"><span class="comment">// 设置邮件内容为multipart:</span></span><br><span class="line">message.setContent(multipart);</span><br></pre></td></tr></table></figure><p>一个<code>Multipart</code>对象可以添加若干个<code>BodyPart</code>，其中第一个<code>BodyPart</code>是文本，即邮件正文，后面的BodyPart是附件。<code>BodyPart</code>依靠<code>setContent()</code>决定添加的内容，如果添加文本，用<code>setContent(&quot;...&quot;, &quot;text/plain;charset=utf-8&quot;)</code>添加纯文本，或者用<code>setContent(&quot;...&quot;, &quot;text/html;charset=utf-8&quot;)</code>添加HTML文本。如果添加附件，需要设置文件名（不一定和真实文件名一致），并且添加一个<code>DataHandler()</code>，传入文件的MIME类型。二进制文件可以用<code>application/octet-stream</code>，Word文档则是<code>application/msword</code>。</p><p>最后，通过<code>setContent()</code>把<code>Multipart</code>添加到<code>Message</code>中，即可发送。</p><p>带附件的邮件在客户端会被提示下载：</p><p><img src="https://liaoxuefeng.com/books/java/network/send-email/mail-attachment.png" alt="mail-attachment"></p><h3 id="发送内嵌图片的HTML邮件">发送内嵌图片的HTML邮件</h3><p>有些童鞋可能注意到，HTML邮件中可以内嵌图片，这是怎么做到的？</p><p>如果给一个<code>&lt;img src=&quot;http://example.com/test.jpg&quot;&gt;</code>，这样的外部图片链接通常会被邮件客户端过滤，并提示用户显示图片并不安全。只有内嵌的图片才能正常在邮件中显示。</p><p>内嵌图片实际上也是一个附件，即邮件本身也是<code>Multipart</code>，但需要做一点额外的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Multipart</span> <span class="variable">multipart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMultipart</span>();</span><br><span class="line"><span class="comment">// 添加text:</span></span><br><span class="line"><span class="type">BodyPart</span> <span class="variable">textpart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeBodyPart</span>();</span><br><span class="line">textpart.setContent(<span class="string">&quot;&lt;h1&gt;Hello&lt;/h1&gt;&lt;p&gt;&lt;img src=\&quot;cid:img01\&quot;&gt;&lt;/p&gt;&quot;</span>, <span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">multipart.addBodyPart(textpart);</span><br><span class="line"><span class="comment">// 添加image:</span></span><br><span class="line"><span class="type">BodyPart</span> <span class="variable">imagepart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeBodyPart</span>();</span><br><span class="line">imagepart.setFileName(fileName);</span><br><span class="line">imagepart.setDataHandler(<span class="keyword">new</span> <span class="title class_">DataHandler</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayDataSource</span>(input, <span class="string">&quot;image/jpeg&quot;</span>)));</span><br><span class="line"><span class="comment">// 与HTML的&lt;img src=&quot;cid:img01&quot;&gt;关联:</span></span><br><span class="line">imagepart.setHeader(<span class="string">&quot;Content-ID&quot;</span>, <span class="string">&quot;&lt;img01&gt;&quot;</span>);</span><br><span class="line">multipart.addBodyPart(imagepart);</span><br></pre></td></tr></table></figure><p>在HTML邮件中引用图片时，需要设定一个ID，用类似<code>&lt;img src=\&quot;cid:img01\&quot;&gt;</code>引用，然后，在添加图片作为BodyPart时，除了要正确设置MIME类型（根据图片类型使用<code>image/jpeg</code>或<code>image/png</code>），还需要设置一个Header：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imagepart.setHeader(<span class="string">&quot;Content-ID&quot;</span>, <span class="string">&quot;&lt;img01&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><p>这个ID和HTML中引用的ID对应起来，邮件客户端就可以正常显示内嵌图片：</p><p><img src="https://liaoxuefeng.com/books/java/network/send-email/mail-image.png" alt="mail-image"></p><h3 id="常见问题">常见问题</h3><p>如果用户名或口令错误，会导致<code>535</code>登录失败：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEBUG SMTP: AUTH LOGIN failed</span><br><span class="line">Exception in thread &quot;main&quot; javax.mail.AuthenticationFailedException: 535 5.7.3 Authentication unsuccessful [HK0PR03CA0105.apcprd03.prod.outlook.com]</span><br></pre></td></tr></table></figure><p>如果登录用户和发件人不一致，会导致<code>554</code>拒绝发送错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEBUG SMTP: MessagingException while sending, THROW: </span><br><span class="line">com.sun.mail.smtp.SMTPSendFailedException: 554 5.2.0 STOREDRV.Submission.Exception:SendAsDeniedException.MapiExceptionSendAsDenied;</span><br></pre></td></tr></table></figure><p>有些时候，如果邮件主题和正文过于简单，会导致<code>554</code>被识别为垃圾邮件的错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEBUG SMTP: MessagingException while sending, THROW: </span><br><span class="line">com.sun.mail.smtp.SMTPSendFailedException: 554 DT:SPM</span><br></pre></td></tr></table></figure><p>总之，出错时，需要查看DEBUG信息，找到服务器返回的错误码和描述信息来定位错误原因。</p><h3 id="练习-3">练习</h3><p>使用SMTP发送邮件。</p><p><a href="https://liaoxuefeng.com/books/java/network/send-email/network-smtp.zip">下载练习</a></p><h3 id="小结-4">小结</h3><p>使用JavaMail API发送邮件本质上是一个MUA软件通过SMTP协议发送邮件至MTA服务器；</p><p>打开调试模式可以看到详细的SMTP交互信息；</p><p>某些邮件服务商需要开启SMTP，并需要独立的SMTP登录密码。</p><p>发送Email的过程我们在上一节已经讲过了，客户端总是通过SMTP协议把邮件发送给MTA。</p><p>接收Email则相反，因为邮件最终到达收件人的MDA服务器，所以，接收邮件是收件人用自己的客户端把邮件从MDA服务器上抓取到本地的过程。</p><p>接收邮件使用最广泛的协议是POP3：Post Office Protocol version 3，它也是一个建立在TCP连接之上的协议。POP3服务器的标准端口是<code>110</code>，如果整个会话需要加密，那么使用加密端口<code>995</code>。</p><p>另一种接收邮件的协议是IMAP：Internet Mail Access Protocol，它使用标准端口<code>143</code>和加密端口<code>993</code>。IMAP和POP3的主要区别是，IMAP协议在本地的所有操作都会自动同步到服务器上，并且，IMAP可以允许用户在邮件服务器的收件箱中创建文件夹。</p><p>JavaMail也提供了IMAP协议的支持。因为POP3和IMAP的使用方式非常类似，这里我们只介绍POP3的用法。</p><p>使用POP3收取Email时，我们无需关心POP3协议底层，因为JavaMail提供了高层接口。首先需要连接到Store对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备登录信息:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;pop3.example.com&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">995</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;bob@example.com&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;password&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.setProperty(<span class="string">&quot;mail.store.protocol&quot;</span>, <span class="string">&quot;pop3&quot;</span>); <span class="comment">// 协议名称</span></span><br><span class="line">props.setProperty(<span class="string">&quot;mail.pop3.host&quot;</span>, host);<span class="comment">// POP3主机名</span></span><br><span class="line">props.setProperty(<span class="string">&quot;mail.pop3.port&quot;</span>, String.valueOf(port)); <span class="comment">// 端口号</span></span><br><span class="line"><span class="comment">// 启动SSL:</span></span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.socketFactory.class&quot;</span>, <span class="string">&quot;javax.net.ssl.SSLSocketFactory&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.socketFactory.port&quot;</span>, String.valueOf(port));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接到Store:</span></span><br><span class="line"><span class="type">URLName</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLName</span>(<span class="string">&quot;pop3&quot;</span>, host, post, <span class="string">&quot;&quot;</span>, username, password);</span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> Session.getInstance(props, <span class="literal">null</span>);</span><br><span class="line">session.setDebug(<span class="literal">true</span>); <span class="comment">// 显示调试信息</span></span><br><span class="line"><span class="type">Store</span> <span class="variable">store</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">POP3SSLStore</span>(session, url);</span><br><span class="line">store.connect();</span><br></pre></td></tr></table></figure><p>一个<code>Store</code>对象表示整个邮箱的存储，要收取邮件，我们需要通过<code>Store</code>访问指定的<code>Folder</code>（文件夹），通常是<code>INBOX</code>表示收件箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取收件箱:</span></span><br><span class="line"><span class="type">Folder</span> <span class="variable">folder</span> <span class="operator">=</span> store.getFolder(<span class="string">&quot;INBOX&quot;</span>);</span><br><span class="line"><span class="comment">// 以读写方式打开:</span></span><br><span class="line">folder.open(Folder.READ_WRITE);</span><br><span class="line"><span class="comment">// 打印邮件总数/新邮件数量/未读数量/已删除数量:</span></span><br><span class="line">System.out.println(<span class="string">&quot;Total messages: &quot;</span> + folder.getMessageCount());</span><br><span class="line">System.out.println(<span class="string">&quot;New messages: &quot;</span> + folder.getNewMessageCount());</span><br><span class="line">System.out.println(<span class="string">&quot;Unread messages: &quot;</span> + folder.getUnreadMessageCount());</span><br><span class="line">System.out.println(<span class="string">&quot;Deleted messages: &quot;</span> + folder.getDeletedMessageCount());</span><br><span class="line"><span class="comment">// 获取每一封邮件:</span></span><br><span class="line">Message[] messages = folder.getMessages();</span><br><span class="line"><span class="keyword">for</span> (Message message : messages) &#123;</span><br><span class="line">    <span class="comment">// 打印每一封邮件:</span></span><br><span class="line">    printMessage((MimeMessage) message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们获取到一个<code>Message</code>对象时，可以强制转型为MimeMessage，然后打印出邮件主题、发件人、收件人等信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(MimeMessage msg)</span> <span class="keyword">throws</span> IOException, MessagingException &#123;</span><br><span class="line">    <span class="comment">// 邮件主题:</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Subject: &quot;</span> + MimeUtility.decodeText(msg.getSubject()));</span><br><span class="line">    <span class="comment">// 发件人:</span></span><br><span class="line">    Address[] froms = msg.getFrom();</span><br><span class="line">    <span class="type">InternetAddress</span> <span class="variable">address</span> <span class="operator">=</span> (InternetAddress) froms[<span class="number">0</span>];</span><br><span class="line">    <span class="type">String</span> <span class="variable">personal</span> <span class="operator">=</span> address.getPersonal();</span><br><span class="line">    <span class="type">String</span> <span class="variable">from</span> <span class="operator">=</span> personal == <span class="literal">null</span> ? address.getAddress() : (MimeUtility.decodeText(personal) + <span class="string">&quot; &lt;&quot;</span> + address.getAddress() + <span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;From: &quot;</span> + from);</span><br><span class="line">    <span class="comment">// 继续打印收件人:</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较麻烦的是获取邮件的正文。一个<code>MimeMessage</code>对象也是一个<code>Part</code>对象，它可能只包含一个文本，也可能是一个<code>Multipart</code>对象，即由几个<code>Part</code>构成，因此，需要递归地解析出完整的正文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getBody</span><span class="params">(Part part)</span> <span class="keyword">throws</span> MessagingException, IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (part.isMimeType(<span class="string">&quot;text/*&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// Part是文本:</span></span><br><span class="line">        <span class="keyword">return</span> part.getContent().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (part.isMimeType(<span class="string">&quot;multipart/*&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// Part是一个Multipart对象:</span></span><br><span class="line">        <span class="type">Multipart</span> <span class="variable">multipart</span> <span class="operator">=</span> (Multipart) part.getContent();</span><br><span class="line">        <span class="comment">// 循环解析每个子Part:</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; multipart.getCount(); i++) &#123;</span><br><span class="line">            <span class="type">BodyPart</span> <span class="variable">bodyPart</span> <span class="operator">=</span> multipart.getBodyPart(i);</span><br><span class="line">            <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> getBody(bodyPart);</span><br><span class="line">            <span class="keyword">if</span> (!body.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> body;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后记得关闭<code>Folder</code>和<code>Store</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">folder.close(<span class="literal">true</span>); <span class="comment">// 传入true表示删除操作会同步到服务器上（即删除服务器收件箱的邮件）</span></span><br><span class="line">store.close();</span><br></pre></td></tr></table></figure><h3 id="练习-4">练习</h3><p>使用POP3接收邮件。</p><p><a href="https://liaoxuefeng.com/books/java/network/receive-email/network-pop3.zip">下载练习</a></p><h3 id="小结-5">小结</h3><p>使用Java接收Email时，可以用POP3协议或IMAP协议。</p><p>使用POP3协议时，需要用Maven引入JavaMail依赖，并确定POP3服务器的域名／端口／是否使用SSL等，然后，调用相关API接收Email。</p><p>设置debug模式可以查看通信详细内容，便于排查错误。</p><p>什么是HTTP？HTTP就是目前使用最广泛的Web应用程序使用的基础协议，例如，浏览器访问网站，手机App访问后台服务器，都是通过HTTP协议实现的。</p><p>HTTP是HyperText Transfer Protocol的缩写，翻译为超文本传输协议，它是基于TCP协议之上的一种请求-响应协议。</p><p>我们来看一下浏览器请求访问某个网站时发送的HTTP请求-响应。当浏览器希望访问某个网站时，浏览器和网站服务器之间首先建立TCP连接，且服务器总是使用<code>80</code>端口和加密端口<code>443</code>，然后，浏览器向服务器发送一个HTTP请求，服务器收到后，返回一个HTTP响应，并且在响应中包含了HTML的网页内容，这样，浏览器解析HTML后就可以给用户显示网页了。一个完整的HTTP请求-响应如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">            GET / HTTP/1.1</span><br><span class="line">            Host: www.sina.com.cn</span><br><span class="line">            User-Agent: Mozilla/5 MSIE</span><br><span class="line">            Accept: */*                ┌────────┐</span><br><span class="line">┌─────────┐ Accept-Language: zh-CN,en  │░░░░░░░░│</span><br><span class="line">│O ░░░░░░░│───────────────────────────▶├────────┤</span><br><span class="line">├─────────┤◀───────────────────────────│░░░░░░░░│</span><br><span class="line">│         │ HTTP/1.1 200 OK            ├────────┤</span><br><span class="line">│         │ Content-Type: text/html    │░░░░░░░░│</span><br><span class="line">└─────────┘ Content-Length: 133251     └────────┘</span><br><span class="line">  Browser   &lt;!DOCTYPE html&gt;              Server</span><br><span class="line">            &lt;html&gt;&lt;body&gt;</span><br><span class="line">            &lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>HTTP请求的格式是固定的，它由HTTP Header和HTTP Body两部分构成。第一行总是<code>请求方法 路径 HTTP版本</code>，例如，<code>GET / HTTP/1.1</code>表示使用<code>GET</code>请求，路径是<code>/</code>，版本是<code>HTTP/1.1</code>。</p><p>后续的每一行都是固定的<code>Header: Value</code>格式，我们称为HTTP Header，服务器依靠某些特定的Header来识别客户端请求，例如：</p><ul><li>Host：表示请求的域名，因为一台服务器上可能有多个网站，因此有必要依靠Host来识别请求是发给哪个网站的；</li><li>User-Agent：表示客户端自身标识信息，不同的浏览器有不同的标识，服务器依靠User-Agent判断客户端类型是IE还是Chrome，是Firefox还是一个Python爬虫；</li><li>Accept：表示客户端能处理的HTTP响应格式，<code>*/*</code>表示任意格式，<code>text/*</code>表示任意文本，<code>image/png</code>表示PNG格式的图片；</li><li>Accept-Language：表示客户端接收的语言，多种语言按优先级排序，服务器依靠该字段给用户返回特定语言的网页版本。</li></ul><p>如果是<code>GET</code>请求，那么该HTTP请求只有HTTP Header，没有HTTP Body。如果是<code>POST</code>请求，那么该HTTP请求带有Body，以一个空行分隔。一个典型的带Body的HTTP请求如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /login HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 30</span><br><span class="line"></span><br><span class="line">username=hello&amp;password=123456</span><br></pre></td></tr></table></figure><p><code>POST</code>请求通常要设置<code>Content-Type</code>表示Body的类型，<code>Content-Length</code>表示Body的长度，这样服务器就可以根据请求的Header和Body做出正确的响应。</p><p>此外，<code>GET</code>请求的参数必须附加在URL上，并以URLEncode方式编码，例如：<code>http://www.example.com/?a=1&amp;b=K%26R</code>，参数分别是<code>a=1</code>和<code>b=K&amp;R</code>。因为URL的长度限制，<code>GET</code>请求的参数不能太多，而<code>POST</code>请求的参数就没有长度限制，因为<code>POST</code>请求的参数必须放到Body中。并且，<code>POST</code>请求的参数不一定是URL编码，可以按任意格式编码，只需要在<code>Content-Type</code>中正确设置即可。常见的发送JSON的<code>POST</code>请求如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /login HTTP/1.1</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 38</span><br><span class="line"></span><br><span class="line">&#123;&quot;username&quot;:&quot;bob&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</span><br></pre></td></tr></table></figure><p>HTTP响应也是由Header和Body两部分组成，一个典型的HTTP响应如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 133251</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>响应的第一行总是<code>HTTP版本 响应代码 响应说明</code>，例如，<code>HTTP/1.1 200 OK</code>表示版本是<code>HTTP/1.1</code>，响应代码是<code>200</code>，响应说明是<code>OK</code>。客户端只依赖响应代码判断HTTP响应是否成功。HTTP有固定的响应代码：</p><ul><li>1xx：表示一个提示性响应，例如101表示将切换协议，常见于WebSocket连接；</li><li>2xx：表示一个成功的响应，例如200表示成功，206表示只发送了部分内容；</li><li>3xx：表示一个重定向的响应，例如301表示永久重定向，303表示客户端应该按指定路径重新发送请求；</li><li>4xx：表示一个因为客户端问题导致的错误响应，例如400表示因为Content-Type等各种原因导致的无效请求，404表示指定的路径不存在；</li><li>5xx：表示一个因为服务器问题导致的错误响应，例如500表示服务器内部故障，503表示服务器暂时无法响应。</li></ul><p>当浏览器收到第一个HTTP响应后，它解析HTML后，又会发送一系列HTTP请求，例如，<code>GET /logo.jpg HTTP/1.1</code>请求一个图片，服务器响应图片请求后，会直接把二进制内容的图片发送给浏览器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line">Content-Length: 18391</span><br><span class="line"></span><br><span class="line">????JFIFHH??XExifMM?i&amp;??X?...(二进制的JPEG图片)</span><br></pre></td></tr></table></figure><p>因此，服务器总是被动地接收客户端的一个HTTP请求，然后响应它。客户端则根据需要发送若干个HTTP请求。</p><p>对于最早期的HTTP/1.0协议，每次发送一个HTTP请求，客户端都需要先创建一个新的TCP连接，然后，收到服务器响应后，关闭这个TCP连接。由于建立TCP连接就比较耗时，因此，为了提高效率，HTTP/1.1协议允许在一个TCP连接中反复发送-响应，这样就能大大提高效率：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">                       ┌─────────┐</span><br><span class="line">┌─────────┐            │░░░░░░░░░│</span><br><span class="line">│O ░░░░░░░│            ├─────────┤</span><br><span class="line">├─────────┤            │░░░░░░░░░│</span><br><span class="line">│         │            ├─────────┤</span><br><span class="line">│         │            │░░░░░░░░░│</span><br><span class="line">└─────────┘            └─────────┘</span><br><span class="line">     │      request 1       │</span><br><span class="line">     │─────────────────────▶│</span><br><span class="line">     │      response 1      │</span><br><span class="line">     │◀─────────────────────│</span><br><span class="line">     │      request 2       │</span><br><span class="line">     │─────────────────────▶│</span><br><span class="line">     │      response 2      │</span><br><span class="line">     │◀─────────────────────│</span><br><span class="line">     │      request 3       │</span><br><span class="line">     │─────────────────────▶│</span><br><span class="line">     │      response 3      │</span><br><span class="line">     │◀─────────────────────│</span><br><span class="line">     ▼                      ▼</span><br></pre></td></tr></table></figure><p>因为HTTP协议是一个请求-响应协议，客户端在发送了一个HTTP请求后，必须等待服务器响应后，才能发送下一个请求，这样一来，如果某个响应太慢，它就会堵住后面的请求。</p><p>所以，为了进一步提速，HTTP/2.0允许客户端在没有收到响应的时候，发送多个HTTP请求，服务器返回响应的时候，不一定按顺序返回，只要双方能识别出哪个响应对应哪个请求，就可以做到并行发送和接收：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">                       ┌─────────┐</span><br><span class="line">┌─────────┐            │░░░░░░░░░│</span><br><span class="line">│O ░░░░░░░│            ├─────────┤</span><br><span class="line">├─────────┤            │░░░░░░░░░│</span><br><span class="line">│         │            ├─────────┤</span><br><span class="line">│         │            │░░░░░░░░░│</span><br><span class="line">└─────────┘            └─────────┘</span><br><span class="line">     │      request 1       │</span><br><span class="line">     │─────────────────────▶│</span><br><span class="line">     │      request 2       │</span><br><span class="line">     │─────────────────────▶│</span><br><span class="line">     │      response 1      │</span><br><span class="line">     │◀─────────────────────│</span><br><span class="line">     │      request 3       │</span><br><span class="line">     │─────────────────────▶│</span><br><span class="line">     │      response 3      │</span><br><span class="line">     │◀─────────────────────│</span><br><span class="line">     │      response 2      │</span><br><span class="line">     │◀─────────────────────│</span><br><span class="line">     ▼                      ▼</span><br></pre></td></tr></table></figure><p>可见，HTTP/2.0进一步提高了效率。</p><h3 id="HTTP编程">HTTP编程</h3><p>既然HTTP涉及到客户端和服务器端，和TCP类似，我们也需要针对客户端编程和针对服务器端编程。</p><p>本节我们不讨论服务器端的HTTP编程，因为服务器端的HTTP编程本质上就是编写Web服务器，这是一个非常复杂的体系，也是JavaEE开发的核心内容，我们在后面的章节再仔细研究。</p><p>本节我们只讨论作为客户端的HTTP编程。</p><p>因为浏览器也是一种HTTP客户端，所以，客户端的HTTP编程，它的行为本质上和浏览器是一样的，即发送一个HTTP请求，接收服务器响应后，获得响应内容。只不过浏览器进一步把响应内容解析后渲染并展示给了用户，而我们使用Java进行HTTP客户端编程仅限于获得响应内容。</p><p>我们来看一下Java如何使用HTTP客户端编程。</p><p>Java标准库提供了基于HTTP的包，但是要注意，早期的JDK版本是通过<code>HttpURLConnection</code>访问HTTP，典型代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://www.example.com/path/to/target?a=1&amp;b=2&quot;</span>);</span><br><span class="line"><span class="type">HttpURLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">conn.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">conn.setUseCaches(<span class="literal">false</span>);</span><br><span class="line">conn.setConnectTimeout(<span class="number">5000</span>); <span class="comment">// 请求超时5秒</span></span><br><span class="line"><span class="comment">// 设置HTTP头:</span></span><br><span class="line">conn.setRequestProperty(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;*/*&quot;</span>);</span><br><span class="line">conn.setRequestProperty(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (compatible; MSIE 11; Windows NT 5.1)&quot;</span>);</span><br><span class="line"><span class="comment">// 连接并发送HTTP请求:</span></span><br><span class="line">conn.connect();</span><br><span class="line"><span class="comment">// 判断HTTP响应是否200:</span></span><br><span class="line"><span class="keyword">if</span> (conn.getResponseCode() != <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;bad response&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取所有响应Header:</span></span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; map = conn.getHeaderFields();</span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(key + <span class="string">&quot;: &quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取响应内容:</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> conn.getInputStream();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上述代码编写比较繁琐，并且需要手动处理<code>InputStream</code>，所以用起来很麻烦。</p><p>从Java 11开始，引入了新的<code>HttpClient</code>，它使用链式调用的API，能大大简化HTTP的处理。</p><p>我们来看一下如何使用新版的<code>HttpClient</code>。首先需要创建一个全局<code>HttpClient</code>实例，因为<code>HttpClient</code>内部使用线程池优化多个HTTP连接，可以复用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">HttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClient.newBuilder().build();</span><br></pre></td></tr></table></figure><p>使用<code>GET</code>请求获取文本内容代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.http.*;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpClient.Version;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// 全局HttpClient:</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">HttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClient.newBuilder().build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://www.sina.com.cn/&quot;</span>;</span><br><span class="line">        <span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpRequest.newBuilder(<span class="keyword">new</span> <span class="title class_">URI</span>(url))</span><br><span class="line">            <span class="comment">// 设置Header:</span></span><br><span class="line">            .header(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Java HttpClient&quot;</span>).header(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;*/*&quot;</span>)</span><br><span class="line">            <span class="comment">// 设置超时:</span></span><br><span class="line">            .timeout(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">            <span class="comment">// 设置版本:</span></span><br><span class="line">            .version(Version.HTTP_2).build();</span><br><span class="line">        HttpResponse&lt;String&gt; response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">        <span class="comment">// HTTP允许重复的Header，因此一个Header可对应多个Value:</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; headers = response.headers().map();</span><br><span class="line">        <span class="keyword">for</span> (String header : headers.keySet()) &#123;</span><br><span class="line">            System.out.println(header + <span class="string">&quot;: &quot;</span> + headers.get(header).get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(response.body().substring(<span class="number">0</span>, <span class="number">1024</span>) + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们要获取图片这样的二进制内容，只需要把<code>HttpResponse.BodyHandlers.ofString()</code>换成<code>HttpResponse.BodyHandlers.ofByteArray()</code>，就可以获得一个<code>HttpResponse&lt;byte[]&gt;</code>对象。如果响应的内容很大，不希望一次性全部加载到内存，可以使用<code>HttpResponse.BodyHandlers.ofInputStream()</code>获取一个<code>InputStream</code>流。</p><p>要使用<code>POST</code>请求，我们要准备好发送的Body数据并正确设置<code>Content-Type</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://www.example.com/login&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot;username=bob&amp;password=123456&quot;</span>;</span><br><span class="line"><span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpRequest.newBuilder(<span class="keyword">new</span> <span class="title class_">URI</span>(url))</span><br><span class="line">    <span class="comment">// 设置Header:</span></span><br><span class="line">    .header(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;*/*&quot;</span>)</span><br><span class="line">    .header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)</span><br><span class="line">    <span class="comment">// 设置超时:</span></span><br><span class="line">    .timeout(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">    <span class="comment">// 设置版本:</span></span><br><span class="line">    .version(Version.HTTP_2)</span><br><span class="line">    <span class="comment">// 使用POST并设置Body:</span></span><br><span class="line">    .POST(BodyPublishers.ofString(body, StandardCharsets.UTF_8)).build();</span><br><span class="line">HttpResponse&lt;String&gt; response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> response.body();</span><br></pre></td></tr></table></figure><p>可见发送<code>POST</code>数据也十分简单。</p><h3 id="练习-5">练习</h3><p>使用HttpClient。</p><p><a href="https://liaoxuefeng.com/books/java/network/http/network-http.zip">下载练习</a></p><h3 id="小结-6">小结</h3><p>Java提供了<code>HttpClient</code>作为新的HTTP客户端编程接口用于取代老的<code>HttpURLConnection</code>接口；</p><p><code>HttpClient</code>使用链式调用并通过内置的<code>BodyPublishers</code>和<code>BodyHandlers</code>来更方便地处理数据。</p><p>Java的RMI远程调用是指，一个JVM中的代码可以通过网络实现远程调用另一个JVM的某个方法。RMI是Remote Method Invocation的缩写。</p><p>提供服务的一方我们称之为服务器，而实现远程调用的一方我们称之为客户端。</p><p>我们先来实现一个最简单的RMI：服务器会提供一个<code>WorldClock</code>服务，允许客户端获取指定时区的时间，即允许客户端调用下面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime <span class="title function_">getLocalDateTime</span><span class="params">(String zoneId)</span>;</span><br></pre></td></tr></table></figure><p>要实现RMI，服务器和客户端必须共享同一个接口。我们定义一个<code>WorldClock</code>接口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WorldClock</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    LocalDateTime <span class="title function_">getLocalDateTime</span><span class="params">(String zoneId)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java的RMI规定此接口必须派生自<code>java.rmi.Remote</code>，并在每个方法声明抛出<code>RemoteException</code>。</p><p>下一步是编写服务器的实现类，因为客户端请求的调用方法<code>getLocalDateTime()</code>最终会通过这个实现类返回结果。实现类<code>WorldClockService</code>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorldClockService</span> <span class="keyword">implements</span> <span class="title class_">WorldClock</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalDateTime <span class="title function_">getLocalDateTime</span><span class="params">(String zoneId)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now(ZoneId.of(zoneId)).withNano(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，服务器端的服务相关代码就编写完毕。我们需要通过Java RMI提供的一系列底层支持接口，把上面编写的服务以RMI的形式暴露在网络上，客户端才能调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;create World clock remote service...&quot;</span>);</span><br><span class="line">        <span class="comment">// 实例化一个WorldClock:</span></span><br><span class="line">        <span class="type">WorldClock</span> <span class="variable">worldClock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorldClockService</span>();</span><br><span class="line">        <span class="comment">// 将此服务转换为远程服务接口:</span></span><br><span class="line">        <span class="type">WorldClock</span> <span class="variable">skeleton</span> <span class="operator">=</span> (WorldClock) UnicastRemoteObject.exportObject(worldClock, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 将RMI服务注册到1099端口:</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="comment">// 注册此服务，服务名为&quot;WorldClock&quot;:</span></span><br><span class="line">        registry.rebind(<span class="string">&quot;WorldClock&quot;</span>, skeleton);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码主要目的是通过RMI提供的相关类，将我们自己的<code>WorldClock</code>实例注册到RMI服务上。RMI的默认端口是<code>1099</code>，最后一步注册服务时通过<code>rebind()</code>指定服务名称为<code>&quot;WorldClock&quot;</code>。</p><p>下一步我们就可以编写客户端代码。RMI要求服务器和客户端共享同一个接口，因此我们要把<code>WorldClock.java</code>这个接口文件复制到客户端，然后在客户端实现RMI调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException &#123;</span><br><span class="line">        <span class="comment">// 连接到服务器localhost，端口1099:</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;localhost&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="comment">// 查找名称为&quot;WorldClock&quot;的服务并强制转型为WorldClock接口:</span></span><br><span class="line">        <span class="type">WorldClock</span> <span class="variable">worldClock</span> <span class="operator">=</span> (WorldClock) registry.lookup(<span class="string">&quot;WorldClock&quot;</span>);</span><br><span class="line">        <span class="comment">// 正常调用接口方法:</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> worldClock.getLocalDateTime(<span class="string">&quot;Asia/Shanghai&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先运行服务器，再运行客户端。从运行结果可知，因为客户端只有接口，并没有实现类，因此，客户端获得的接口方法返回值实际上是通过网络从服务器端获取的。整个过程实际上非常简单，对客户端来说，客户端持有的<code>WorldClock</code>接口实际上对应了一个“实现类”，它是由<code>Registry</code>内部动态生成的，并负责把方法调用通过网络传递到服务器端。而服务器端接收网络调用的服务并不是我们自己编写的<code>WorldClockService</code>，而是<code>Registry</code>自动生成的代码。我们把客户端的“实现类”称为<code>stub</code>，而服务器端的网络服务类称为<code>skeleton</code>，它会真正调用服务器端的<code>WorldClockService</code>，获取结果，然后把结果通过网络传递给客户端。整个过程由RMI底层负责实现序列化和反序列化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌ ─ ─ ─ ─ ─ ─ ─ ─ ┐         ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line">  ┌─────────────┐                                  ┌────────────┐</span><br><span class="line">│ │   Service   │ │         │                      │  Service   │ │</span><br><span class="line">  └─────────────┘                                  └────────────┘</span><br><span class="line">│        ▲        │         │                            ▲        │</span><br><span class="line">         │                                               │</span><br><span class="line">│        │        │         │                            │        │</span><br><span class="line">  ┌─────────────┐   Network    ┌───────────────┐   ┌────────────┐</span><br><span class="line">│ │ Client Stub ├─┼─────────┼─▶│Server Skeleton│──▶│Service Impl│ │</span><br><span class="line">  └─────────────┘              └───────────────┘   └────────────┘</span><br><span class="line">└ ─ ─ ─ ─ ─ ─ ─ ─ ┘         └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure><p>Java的RMI严重依赖序列化和反序列化，而这种情况下可能会造成严重的安全漏洞，因为Java的序列化和反序列化不但涉及到数据，还涉及到二进制的字节码，即使使用白名单机制也很难保证100%排除恶意构造的字节码。因此，使用RMI时，双方必须是内网互相信任的机器，不要把1099端口暴露在公网上作为对外服务。</p><p>此外，Java的RMI调用机制决定了双方必须是Java程序，其他语言很难调用Java的RMI。如果要使用不同语言进行RPC调用，可以选择更通用的协议，例如<a href="https://grpc.io/">gRPC</a>。</p><h3 id="练习-6">练习</h3><p>使用RMI实现远程调用。</p><p><a href="https://liaoxuefeng.com/books/java/network/rmi/network-rmi.zip">下载练习</a></p><h3 id="小结-7">小结</h3><p>Java提供了RMI实现远程方法调用：</p><p>RMI通过自动生成stub和skeleton实现网络调用，客户端只需要查找服务并获得接口实例，服务器端只需要编写实现类并注册为服务；</p><p>RMI的序列化和反序列化可能会造成安全漏洞，因此调用双方必须是内网互相信任的机器，不要把1099端口暴露在公网上作为对外服务。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-Maven基础</title>
      <link href="/2025/05/24/JAVA-Maven%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/05/24/JAVA-Maven%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>在了解Maven之前，我们先来看看一个Java项目需要的东西。首先，我们需要确定引入哪些依赖包。例如，如果我们需要用到<a href="https://commons.apache.org/proper/commons-logging/">commons logging</a>，我们就必须把commons logging的jar包放入classpath。如果我们还需要<a href="https://logging.apache.org/log4j/">log4j</a>，就需要把log4j相关的jar包都放到classpath中。这些就是依赖包的管理。</p><p>其次，我们要确定项目的目录结构。例如，<code>src</code>目录存放Java源码，<code>resources</code>目录存放配置文件，<code>bin</code>目录存放编译生成的<code>.class</code>文件。</p><p>此外，我们还需要配置环境，例如JDK的版本，编译打包的流程，当前代码的版本号。</p><p>最后，除了使用Eclipse这样的IDE进行编译外，我们还必须能通过命令行工具进行编译，才能够让项目在一个独立的服务器上编译、测试、部署。</p><p>这些工作难度不大，但是非常琐碎且耗时。如果每一个项目都自己搞一套配置，肯定会一团糟。我们需要的是一个标准化的Java项目管理和构建工具。</p><p>Maven就是是专门为Java项目打造的管理和构建工具，它的主要功能有：</p><ul><li>提供了一套标准化的项目结构；</li><li>提供了一套标准化的构建流程（编译，测试，打包，发布……）；</li><li>提供了一套依赖管理机制。</li></ul><h3 id="Maven项目结构">Maven项目结构</h3><p>一个使用Maven管理的普通的Java项目，它的目录结构默认如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a-maven-project</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   └── resources</span><br><span class="line">│   └── test</span><br><span class="line">│       ├── java</span><br><span class="line">│       └── resources</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure><p>项目的根目录<code>a-maven-project</code>是项目名，它有一个项目描述文件<code>pom.xml</code>，存放Java源码的目录是<code>src/main/java</code>，存放资源文件的目录是<code>src/main/resources</code>，存放测试源码的目录是<code>src/test/java</code>，存放测试资源的目录是<code>src/test/resources</code>，最后，所有编译、打包生成的文件都放在<code>target</code>目录里。这些就是一个Maven项目的标准目录结构。</p><p>所有的目录结构都是约定好的标准结构，我们千万不要随意修改目录结构。使用标准结构不需要做任何配置，Maven就可以正常使用。</p><p>我们再来看最关键的一个项目描述文件<code>pom.xml</code>，它的内容长得像下面：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.release</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.release</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，<code>groupId</code>类似于Java的包名，通常是公司或组织名称，<code>artifactId</code>类似于Java的类名，通常是项目名称，再加上<code>version</code>，一个Maven工程就是由<code>groupId</code>，<code>artifactId</code>和<code>version</code>作为唯一标识。</p><p>我们在引用其他第三方库的时候，也是通过这3个变量确定。例如，依赖<code>org.slfj4:slf4j-simple:2.0.16</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>&lt;dependency&gt;</code>声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。</p><p>另外，注意到<code>&lt;properties&gt;</code>定义了一些属性，常用的属性有：</p><ul><li><code>project.build.sourceEncoding</code>：表示项目源码的字符编码，通常应设定为<code>UTF-8</code>；</li><li><code>maven.compiler.release</code>：表示使用的JDK版本，例如<code>21</code>；</li><li><code>maven.compiler.source</code>：表示Java编译器读取的源码版本；</li><li><code>maven.compiler.target</code>：表示Java编译器编译的Class版本。</li></ul><p>从Java 9开始，推荐使用<code>maven.compiler.release</code>属性，保证编译时输入的源码和编译输出版本一致。如果源码和输出版本不同，则应该分别设置<code>maven.compiler.source</code>和<code>maven.compiler.target</code>。</p><p>通过<code>&lt;properties&gt;</code>定义的属性，就可以固定JDK版本，防止同一个项目的不同的开发者各自使用不同版本的JDK。</p><h3 id="安装Maven">安装Maven</h3><p>要安装Maven，可以从<a href="https://maven.apache.org/">Maven官网</a>下载最新的Maven 3.9.x，然后在本地解压，设置几个环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M2_HOME=/path/to/maven-3.9.x</span><br><span class="line">PATH=$PATH:$M2_HOME/bin</span><br></pre></td></tr></table></figure><p>Windows可以把<code>%M2_HOME%\bin</code>添加到系统Path变量中。</p><p>然后，打开命令行窗口，输入<code>mvn -version</code>，应该看到Maven的版本信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────┐</span><br><span class="line">│Windows PowerShell                                 - □ x │</span><br><span class="line">├─────────────────────────────────────────────────────────┤</span><br><span class="line">│Windows PowerShell                                       │</span><br><span class="line">│Copyright (C) Microsoft Corporation. All rights reserved.│</span><br><span class="line">│                                                         │</span><br><span class="line">│PS C:\Users\liaoxuefeng&gt; mvn -version                    │</span><br><span class="line">│Apache Maven 3.9.x ...                                   │</span><br><span class="line">│Maven home: C:\Users\liaoxuefeng\maven                   │</span><br><span class="line">│Java version: ...                                        │</span><br><span class="line">│...                                                      │</span><br><span class="line">│                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>如果提示命令未找到，说明系统PATH路径有误，需要修复后再运行。</p><h3 id="小结">小结</h3><p>Maven是一个Java项目的管理和构建工具：</p><ul><li>Maven使用<code>pom.xml</code>定义项目内容，并使用预设的目录结构；</li><li>在Maven中声明一个依赖项可以自动下载并导入classpath；</li><li>Maven使用<code>groupId</code>，<code>artifactId</code>和<code>version</code>唯一定位一个依赖。</li></ul><p>如果我们的项目依赖第三方的jar包，例如commons logging，那么问题来了：commons logging发布的jar包在哪下载？</p><p>如果我们还希望依赖log4j，那么使用log4j需要哪些jar包？</p><p>类似的依赖还包括：JUnit，JavaMail，MySQL驱动等等，一个可行的方法是通过搜索引擎搜索到项目的官网，然后手动下载zip包，解压，放入classpath。但是，这个过程非常繁琐。</p><p>Maven解决了依赖管理问题。例如，我们的项目依赖<code>abc</code>这个jar包，而<code>abc</code>又依赖<code>xyz</code>这个jar包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────┐</span><br><span class="line">│Sample Project│</span><br><span class="line">└──────────────┘</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">┌──────────────┐</span><br><span class="line">│     abc      │</span><br><span class="line">└──────────────┘</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">┌──────────────┐</span><br><span class="line">│     xyz      │</span><br><span class="line">└──────────────┘</span><br></pre></td></tr></table></figure><p>当我们声明了<code>abc</code>的依赖时，Maven自动把<code>abc</code>和<code>xyz</code>都加入了我们的项目依赖，不需要我们自己去研究<code>abc</code>是否需要依赖<code>xyz</code>。</p><p>因此，Maven的第一个作用就是解决依赖管理。我们声明了自己的项目需要<code>abc</code>，Maven会自动导入<code>abc</code>的jar包，再判断出<code>abc</code>需要<code>xyz</code>，又会自动导入<code>xyz</code>的jar包，这样，最终我们的项目会依赖<code>abc</code>和<code>xyz</code>两个jar包。</p><p>我们来看一个复杂依赖示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们声明一个<code>spring-boot-starter-web</code>依赖时，Maven会自动解析并判断最终需要大概二三十个其他依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">spring-boot-starter-web</span><br><span class="line">  spring-boot-starter</span><br><span class="line">    spring-boot</span><br><span class="line">    sprint-boot-autoconfigure</span><br><span class="line">    spring-boot-starter-logging</span><br><span class="line">      logback-classic</span><br><span class="line">        logback-core</span><br><span class="line">        slf4j-api</span><br><span class="line">      jcl-over-slf4j</span><br><span class="line">        slf4j-api</span><br><span class="line">      jul-to-slf4j</span><br><span class="line">        slf4j-api</span><br><span class="line">      log4j-over-slf4j</span><br><span class="line">        slf4j-api</span><br><span class="line">    spring-core</span><br><span class="line">    snakeyaml</span><br><span class="line">  spring-boot-starter-tomcat</span><br><span class="line">    tomcat-embed-core</span><br><span class="line">    tomcat-embed-el</span><br><span class="line">    tomcat-embed-websocket</span><br><span class="line">      tomcat-embed-core</span><br><span class="line">  jackson-databind</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>如果我们自己去手动管理这些依赖是非常费时费力的，而且出错的概率很大。</p><h3 id="依赖关系">依赖关系</h3><p>Maven定义了几种依赖关系，分别是<code>compile</code>、<code>test</code>、<code>runtime</code>和<code>provided</code>：</p><table><thead><tr><th>scope</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>compile</td><td>编译时需要用到该jar包（默认）</td><td>commons-logging</td></tr><tr><td>test</td><td>编译Test时需要用到该jar包</td><td>junit</td></tr><tr><td>runtime</td><td>编译时不需要，但运行时需要用到</td><td>mysql</td></tr><tr><td>provided</td><td>编译时需要用到，但运行时由JDK或某个服务器提供</td><td>servlet-api</td></tr></tbody></table><p>其中，默认的<code>compile</code>是最常用的，Maven会把这种类型的依赖直接放入classpath。</p><p><code>test</code>依赖表示仅在测试时使用，正常运行时并不需要。最常用的<code>test</code>依赖就是JUnit：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>runtime</code>依赖表示编译时不需要，但运行时需要。最典型的<code>runtime</code>依赖是JDBC驱动，例如MySQL驱动：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.48<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>provided</code>依赖表示编译时需要，但运行时不需要。最典型的<code>provided</code>依赖是Servlet API，编译的时候需要，但是运行时，Servlet服务器内置了相关的jar，所以运行期不需要：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后一个问题是，Maven如何知道从何处下载所需的依赖？也就是相关的jar包？答案是Maven维护了一个中央仓库（<a href="https://repo1.maven.org/">repo1.maven.org</a>），所有第三方库将自身的jar以及相关信息上传至中央仓库，Maven就可以从中央仓库把所需依赖下载到本地。</p><p>Maven并不会每次都从中央仓库下载jar包。一个jar包一旦被下载过，就会被Maven自动缓存在本地目录（用户主目录的<code>.m2</code>目录），所以，除了第一次编译时因为下载需要时间会比较慢，后续过程因为有本地缓存，并不会重复下载相同的jar包。</p><h3 id="唯一ID">唯一ID</h3><p>对于某个依赖，Maven只需要3个变量即可唯一确定某个jar包：</p><ul><li>groupId：属于组织的名称，类似Java的包名；</li><li>artifactId：该jar包自身的名称，类似Java的类名；</li><li>version：该jar包的版本。</li></ul><p>通过上述3个变量，即可唯一确定某个jar包。Maven通过对jar包进行PGP签名确保任何一个jar包一经发布就无法修改。修改已发布jar包的唯一方法是发布一个新版本。</p><p>因此，某个jar包一旦被Maven下载过，即可永久地安全缓存在本地。</p><p>注：只有以<code>-SNAPSHOT</code>结尾的版本号会被Maven视为开发版本，开发版本每次都会重复下载，这种SNAPSHOT版本只能用于内部私有的Maven repo，公开发布的版本不允许出现SNAPSHOT。</p><p>提示</p><p>后续我们在表示Maven依赖时，使用简写形式groupId:artifactId:version，例如：org.slf4j:slf4j-api:2.0.4。</p><h3 id="Maven镜像">Maven镜像</h3><p>除了可以从Maven的中央仓库下载外，还可以从Maven的镜像仓库下载。如果访问Maven的中央仓库非常慢，我们可以选择一个速度较快的Maven的镜像仓库。Maven镜像仓库定期从中央仓库同步：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">           slow    ┌───────────────────┐</span><br><span class="line">    ┌─────────────▶│Maven Central Repo.│</span><br><span class="line">    │              └───────────────────┘</span><br><span class="line">    │                        │</span><br><span class="line">    │                        │sync</span><br><span class="line">    │                        ▼</span><br><span class="line">┌───────┐  fast    ┌───────────────────┐</span><br><span class="line">│ User  │─────────▶│Maven Mirror Repo. │</span><br><span class="line">└───────┘          └───────────────────┘</span><br></pre></td></tr></table></figure><p>中国区用户可以使用阿里云提供的Maven镜像仓库。使用Maven镜像仓库需要一个配置，在用户主目录下进入<code>.m2</code>目录，创建一个<code>settings.xml</code>配置文件，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 国内推荐阿里云的Maven镜像 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/central<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置镜像仓库后，Maven的下载速度就会非常快。</p><h3 id="搜索第三方组件">搜索第三方组件</h3><p>最后一个问题：如果我们要引用一个第三方组件，比如<code>okhttp</code>，如何确切地获得它的<code>groupId</code>、<code>artifactId</code>和<code>version</code>？方法是通过<a href="https://search.maven.org/">search.maven.org</a>搜索关键字，找到对应的组件后，直接复制：</p><p><img src="https://liaoxuefeng.com/books/java/maven/dependency/maven-info.png" alt="maven-info"></p><h3 id="命令行编译">命令行编译</h3><p>在命令中，进入到<code>pom.xml</code>所在目录，输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn clean package</span><br></pre></td></tr></table></figure><p>如果一切顺利，即可在<code>target</code>目录下获得编译后自动打包的jar。</p><h3 id="在IDE中使用Maven">在IDE中使用Maven</h3><p>几乎所有的IDE都内置了对Maven的支持。在Eclipse中，可以直接创建或导入Maven项目。如果导入后的Maven项目有错误，可以尝试选择项目后点击右键，选择Maven - Update Project…更新：</p><p><img src="https://liaoxuefeng.com/books/java/maven/dependency/maven-ide.png" alt="update-maven-project"></p><h3 id="练习">练习</h3><p>使用Maven编译hello项目。</p><p><a href="https://liaoxuefeng.com/books/java/maven/dependency/maven-hello.zip">下载练习</a></p><h3 id="小结-2">小结</h3><p>Maven通过解析依赖关系确定项目所需的jar包，常用的4种<code>scope</code>有：<code>compile</code>（默认），<code>test</code>，<code>runtime</code>和<code>provided</code>；</p><p>Maven从中央仓库下载所需的jar包并缓存在本地；</p><p>可以通过镜像仓库加速下载。</p><h3 id="构建流程">构建流程</h3><p>Maven不但有标准化的项目结构，而且还有一套标准化的构建流程，可以自动化实现编译，打包，发布，等等。</p><h3 id="Lifecycle和Phase">Lifecycle和Phase</h3><p>使用Maven时，我们首先要了解什么是Maven的生命周期（lifecycle）。</p><p>Maven的生命周期由一系列阶段（phase）构成，以内置的生命周期<code>default</code>为例，它包含以下phase：</p><ul><li>validate</li><li>initialize</li><li>generate-sources</li><li>process-sources</li><li>generate-resources</li><li>process-resources</li><li>compile</li><li>process-classes</li><li>generate-test-sources</li><li>process-test-sources</li><li>generate-test-resources</li><li>process-test-resources</li><li>test-compile</li><li>process-test-classes</li><li>test</li><li>prepare-package</li><li>package</li><li>pre-integration-test</li><li>integration-test</li><li>post-integration-test</li><li>verify</li><li>install</li><li>deploy</li></ul><p>如果我们运行<code>mvn package</code>，Maven就会执行<code>default</code>生命周期，它会从开始一直运行到<code>package</code>这个phase为止：</p><ul><li>validate</li><li>initialize</li><li>…</li><li>prepare-package</li><li>package</li></ul><p>如果我们运行<code>mvn compile</code>，Maven也会执行<code>default</code>生命周期，但这次它只会运行到<code>compile</code>，即以下几个phase：</p><ul><li>validate</li><li>initialize</li><li>…</li><li>process-resources</li><li>compile</li></ul><p>Maven另一个常用的生命周期是<code>clean</code>，它会执行3个phase：</p><ul><li>pre-clean</li><li>clean （注意这个clean不是lifecycle而是phase）</li><li>post-clean</li></ul><p>所以，我们使用<code>mvn</code>这个命令时，后面的参数是phase，Maven自动根据生命周期运行到指定的phase。</p><p>更复杂的例子是指定多个phase，例如，运行<code>mvn clean package</code>，Maven先执行<code>clean</code>生命周期并运行到<code>clean</code>这个phase，然后执行<code>default</code>生命周期并运行到<code>package</code>这个phase，实际执行的phase如下：</p><ul><li>pre-clean</li><li>clean （注意这个clean是phase）</li><li>validate （开始执行default生命周期的第一个phase）</li><li>initialize</li><li>…</li><li>prepare-package</li><li>package</li></ul><p>在实际开发过程中，经常使用的命令有：</p><p><code>mvn clean</code>：清理所有生成的class和jar；</p><p><code>mvn clean compile</code>：先清理，再执行到<code>compile</code>；</p><p><code>mvn clean test</code>：先清理，再执行到<code>test</code>，因为执行<code>test</code>前必须执行<code>compile</code>，所以这里不必指定<code>compile</code>；</p><p><code>mvn clean package</code>：先清理，再执行到<code>package</code>。</p><p>大多数phase在执行过程中，因为我们通常没有在<code>pom.xml</code>中配置相关的设置，所以这些phase什么事情都不做。</p><p>经常用到的phase其实只有几个：</p><ul><li>clean：清理</li><li>compile：编译</li><li>test：运行测试</li><li>package：打包</li></ul><h3 id="Goal">Goal</h3><p>执行一个phase又会触发一个或多个goal：</p><table><thead><tr><th>执行的Phase</th><th>对应执行的Goal</th></tr></thead><tbody><tr><td>compile</td><td>compiler:compile</td></tr><tr><td>test</td><td>compiler:testCompile</td></tr><tr><td>surefire:test</td><td></td></tr></tbody></table><p>goal的命名总是<code>abc:xyz</code>这种形式。</p><p>看到这里，相信大家对lifecycle、phase和goal已经明白了吧？</p><p><img src="https://liaoxuefeng.com/books/java/maven/process/meng.jpg" alt="meng"></p><p>其实我们类比一下就明白了：</p><ul><li>lifecycle相当于Java的package，它包含一个或多个phase；</li><li>phase相当于Java的class，它包含一个或多个goal；</li><li>goal相当于class的method，它其实才是真正干活的。</li></ul><p>大多数情况，我们只要指定phase，就默认执行这些phase默认绑定的goal，只有少数情况，我们可以直接指定运行一个goal，例如，启动Tomcat服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn tomcat:run</span><br></pre></td></tr></table></figure><h3 id="小结-3">小结</h3><p>Maven通过lifecycle、phase和goal来提供标准的构建流程。</p><p>最常用的构建命令是指定phase，然后让Maven执行到指定的phase：</p><ul><li>mvn clean</li><li>mvn clean compile</li><li>mvn clean test</li><li>mvn clean package</li></ul><p>通常情况，我们总是执行phase默认绑定的goal，因此不必指定goal。</p><h2 id="使用插件">使用插件</h2><p>我们在前面介绍了Maven的lifecycle，phase和goal：使用Maven构建项目就是执行lifecycle，执行到指定的phase为止。每个phase会执行自己默认的一个或多个goal。goal是最小任务单元。</p><p>我们以<code>compile</code>这个phase为例，如果执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn compile</span><br></pre></td></tr></table></figure><p>Maven将执行<code>compile</code>这个phase，这个phase会调用<code>compiler</code>插件执行关联的<code>compiler:compile</code>这个goal。</p><p>实际上，执行每个phase，都是通过某个插件（plugin）来执行的，Maven本身其实并不知道如何执行<code>compile</code>，它只是负责找到对应的<code>compiler</code>插件，然后执行默认的<code>compiler:compile</code>这个goal来完成编译。</p><p>所以，使用Maven，实际上就是配置好需要使用的插件，然后通过phase调用它们。</p><p>Maven已经内置了一些常用的标准插件：</p><table><thead><tr><th>插件名称</th><th>对应执行的phase</th></tr></thead><tbody><tr><td>clean</td><td>clean</td></tr><tr><td>compiler</td><td>compile</td></tr><tr><td>surefire</td><td>test</td></tr><tr><td>jar</td><td>package</td></tr></tbody></table><p>如果标准插件无法满足需求，我们还可以使用自定义插件。使用自定义插件的时候，需要声明。例如，使用<code>maven-shade-plugin</code>可以创建一个可执行的jar，要使用这个插件，需要在<code>pom.xml</code>中声明它：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            ...插件配置...</span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>自定义插件往往需要一些配置，例如，<code>maven-shade-plugin</code>需要指定Java程序的入口，它的配置是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.itranswarp.learnjava.Main<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，Maven自带的标准插件例如<code>compiler</code>是无需声明的，只有引入其它的插件才需要声明。</p><p>下面列举了一些常用的插件：</p><ul><li>maven-shade-plugin：打包所有依赖包并生成可执行jar；</li><li>cobertura-maven-plugin：生成单元测试覆盖率报告；</li><li>findbugs-maven-plugin：对Java源码进行静态分析以找出潜在问题。</li></ul><h3 id="练习-2">练习</h3><p>使用maven-shade-plugin创建可执行jar。</p><p><a href="https://liaoxuefeng.com/books/java/maven/plugin/maven-plugin.zip">下载练习</a></p><h3 id="小结-4">小结</h3><p>Maven通过自定义插件可以执行项目构建时需要的额外功能，使用自定义插件必须在pom.xml中声明插件及配置；</p><p>插件会在某个phase被执行时执行；</p><p>插件的配置和用法需参考插件的官方文档。</p><hr><hr><p>在软件开发中，把一个大项目分拆为多个模块是降低软件复杂度的有效方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                        ┌ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line">                          ┌─────────┐</span><br><span class="line">                        │ │Module A │ │</span><br><span class="line">                          └─────────┘</span><br><span class="line">┌──────────────┐ split  │ ┌─────────┐ │</span><br><span class="line">│Single Project│───────▶  │Module B │</span><br><span class="line">└──────────────┘        │ └─────────┘ │</span><br><span class="line">                          ┌─────────┐</span><br><span class="line">                        │ │Module C │ │</span><br><span class="line">                          └─────────┘</span><br><span class="line">                        └ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure><p>对于Maven工程来说，原来是一个大项目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">single-project</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br></pre></td></tr></table></figure><p>现在可以分拆成3个模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">multiple-projects</span><br><span class="line">├── module-a</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── module-b</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">└── module-c</span><br><span class="line">    ├── pom.xml</span><br><span class="line">    └── src</span><br></pre></td></tr></table></figure><p>Maven可以有效地管理多个模块，我们只需要把每个模块当作一个独立的Maven项目，它们有各自独立的<code>pom.xml</code>。例如，模块A的<code>pom.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>module-a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>module-a<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>模块B的<code>pom.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>module-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>module-b<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出来，模块A和模块B的<code>pom.xml</code>高度相似，因此，我们可以提取出共同部分作为<code>parent</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意到parent的<code>&lt;packaging&gt;</code>是<code>pom</code>而不是<code>jar</code>，因为<code>parent</code>本身不含任何Java代码。编写<code>parent</code>的<code>pom.xml</code>只是为了在各个模块中减少重复的配置。现在我们的整个工程结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">multiple-project</span><br><span class="line">├── pom.xml</span><br><span class="line">├── parent</span><br><span class="line">│   └── pom.xml</span><br><span class="line">├── module-a</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── module-b</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">└── module-c</span><br><span class="line">    ├── pom.xml</span><br><span class="line">    └── src</span><br></pre></td></tr></table></figure><p>这样模块A就可以简化为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>module-a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>module-a<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>模块B、模块C都可以直接从<code>parent</code>继承，大幅简化了<code>pom.xml</code>的编写。</p><p>如果模块A依赖模块B，则模块A需要模块B的jar包才能正常编译，我们需要在模块A中引入模块B：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>module-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后，在编译的时候，需要在根目录创建一个<code>pom.xml</code>统一编译：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>build<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>build<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>module-a<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>module-b<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>module-c<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，在根目录执行<code>mvn clean package</code>时，Maven根据根目录的<code>pom.xml</code>找到包括<code>parent</code>在内的共4个<code>&lt;module&gt;</code>，一次性全部编译。</p><h3 id="中央仓库">中央仓库</h3><p>其实我们使用的大多数第三方模块都是这个用法，例如，我们使用commons logging、log4j这些第三方模块，就是第三方模块的开发者自己把编译好的jar包发布到Maven的中央仓库中。</p><h3 id="私有仓库">私有仓库</h3><p>私有仓库是指公司内部如果不希望把源码和jar包放到公网上，那么可以搭建私有仓库。私有仓库总是在公司内部使用，它只需要在本地的<code>~/.m2/settings.xml</code>中配置好，使用方式和中央仓位没有任何区别。</p><h3 id="本地仓库">本地仓库</h3><p>本地仓库是指把本地开发的项目“发布”在本地，这样其他项目可以通过本地仓库引用它。但是我们不推荐把自己的模块安装到Maven的本地仓库，因为每次修改某个模块的源码，都需要重新安装，非常容易出现版本不一致的情况。更好的方法是使用模块化编译，在编译的时候，告诉Maven几个模块之间存在依赖关系，需要一块编译，Maven就会自动按依赖顺序编译这些模块。</p><h3 id="小结-5">小结</h3><p>Maven支持模块化管理，可以把一个大项目拆成几个模块：</p><ul><li>可以通过继承在parent的<code>pom.xml</code>统一定义重复配置；</li><li>可以通过<code>&lt;modules&gt;</code>编译多个模块。</li></ul><h2 id="使用mvnw">使用mvnw</h2><p>我们使用Maven时，基本上只会用到<code>mvn</code>这一个命令。有些童鞋可能听说过<code>mvnw</code>，这个是啥？</p><p><code>mvnw</code>是Maven Wrapper的缩写。因为我们安装Maven时，默认情况下，系统所有项目都会使用全局安装的这个Maven版本。但是，对于某些项目来说，它可能必须使用某个特定的Maven版本，这个时候，就可以使用Maven Wrapper，它可以负责给这个特定的项目安装指定版本的Maven，而其他项目不受影响。</p><p>简单地说，Maven Wrapper就是给一个项目提供一个独立的，指定版本的Maven给它使用。</p><h3 id="安装Maven-Wrapper">安装Maven Wrapper</h3><p>安装Maven Wrapper最简单的方式是在项目的根目录（即<code>pom.xml</code>所在的目录）下运行安装命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn wrapper:wrapper</span><br></pre></td></tr></table></figure><p>它会自动使用最新版本的Maven。如果要指定使用的Maven版本，使用下面的安装命令指定版本，例如<code>3.9.0</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn wrapper:wrapper -Dmaven=3.9.0</span><br></pre></td></tr></table></figure><p>安装后，查看项目结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">my-project</span><br><span class="line">├── .mvn</span><br><span class="line">│   └── wrapper</span><br><span class="line">│       └── maven-wrapper.properties</span><br><span class="line">├── mvnw</span><br><span class="line">├── mvnw.cmd</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   └── resources</span><br><span class="line">    └── test</span><br><span class="line">        ├── java</span><br><span class="line">        └── resources</span><br></pre></td></tr></table></figure><p>发现多了<code>mvnw</code>、<code>mvnw.cmd</code>和<code>.mvn</code>目录，我们只需要把<code>mvn</code>命令改成<code>mvnw</code>就可以使用跟项目关联的Maven。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvnw clean package</span><br></pre></td></tr></table></figure><p>在Linux或macOS下运行时需要加上<code>./</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./mvnw clean package</span><br></pre></td></tr></table></figure><p>Maven Wrapper的另一个作用是把项目的<code>mvnw</code>、<code>mvnw.cmd</code>和<code>.mvn</code>提交到版本库中，可以使所有开发人员使用统一的Maven版本。</p><h3 id="练习-3">练习</h3><p>使用mvnw编译hello项目。</p><p><a href="https://liaoxuefeng.com/books/java/maven/wrapper/maven-wrapper.zip">下载练习</a></p><h3 id="小结-6">小结</h3><p>使用Maven Wrapper，可以为一个项目指定特定的Maven版本。</p><hr><hr><p>当我们使用<code>commons-logging</code>这些第三方开源库的时候，我们实际上是通过Maven自动下载它的jar包，并根据其<code>pom.xml</code>解析依赖，自动把相关依赖包都下载后加入到classpath。</p><p>那么问题来了：当我们自己写了一个牛逼的开源库时，非常希望别人也能使用，总不能直接放个jar包的链接让别人下载吧？</p><p>如果我们把自己的开源库放到Maven的repo中，那么，别人只需按标准引用<code>groupId:artifactId:version</code>，即可自动下载jar包以及相关依赖。因此，本节我们介绍如何发布一个库到Maven的repo中。</p><p>把自己的库发布到Maven的repo中有好几种方法，我们介绍3种最常用的方法。</p><h3 id="以静态文件发布">以静态文件发布</h3><p>如果我们观察一个中央仓库的Artifact结构，例如<a href="https://commons.apache.org/proper/commons-math/">Commons Math</a>，它的groupId是<code>org.apache.commons</code>，artifactId是<code>commons-math3</code>，以版本<code>3.6.1</code>为例，发布在中央仓库的文件夹路径就是<a href="https://repo1.maven.org/maven2/org/apache/commons/commons-math3/3.6.1/">https://repo1.maven.org/maven2/org/apache/commons/commons-math3/3.6.1/</a>，在此文件夹下，<code>commons-math3-3.6.1.jar</code>就是发布的jar包，<code>commons-math3-3.6.1.pom</code>就是它的<code>pom.xml</code>描述文件，<code>commons-math3-3.6.1-sources.jar</code>是源代码，<code>commons-math3-3.6.1-javadoc.jar</code>是文档。其它以<code>.asc</code>、<code>.md5</code>、<code>.sha1</code>结尾的文件分别是GPG签名、MD5摘要和SHA-1摘要。</p><p>我们只要按照这种目录结构组织文件，它就是一个有效的Maven仓库。</p><p>我们以广受好评的开源项目<a href="https://github.com/michaelliao/how-to-become-rich">how-to-become-rich</a>为例，先创建Maven工程目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">how-to-become-rich</span><br><span class="line">├── maven-repo        &lt;-- Maven本地文件仓库</span><br><span class="line">├── pom.xml           &lt;-- 项目文件</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java      &lt;-- 源码目录</span><br><span class="line">│   │   └── resources &lt;-- 资源目录</span><br><span class="line">│   └── test</span><br><span class="line">│       ├── java      &lt;-- 测试源码目录</span><br><span class="line">│       └── resources &lt;-- 测试资源目录</span><br><span class="line">└── target            &lt;-- 编译输出目录</span><br></pre></td></tr></table></figure><p>在<code>pom.xml</code>中添加如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>local-repo-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>GitHub Release<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>file://$&#123;project.basedir&#125;/maven-repo<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-sources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar-no-fork<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-javadocs<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意到<code>&lt;distributionManagement&gt;</code>，它指示了发布的软件包的位置，这里的<code>&lt;url&gt;</code>是项目根目录下的<code>maven-repo</code>目录，在<code>&lt;build&gt;</code>中定义的两个插件<code>maven-source-plugin</code>和<code>maven-javadoc-plugin</code>分别用来创建源码和javadoc，如果不想发布源码，可以把对应的插件去掉。</p><p>我们直接在项目根目录下运行Maven命令<code>mvn clean package deploy</code>，如果一切顺利，我们就可以在<code>maven-repo</code>目录下找到部署后的所有文件如下：</p><p><a href="https://github.com/michaelliao/how-to-become-rich/tree/master/maven-repo">how-to-become-rich-repo</a></p><p>最后一步，是把这个工程推到GitHub上，并选择<code>Settings</code>-<code>GitHub Pages</code>，选择<code>master branch</code>启用Pages服务：</p><p><img src="https://liaoxuefeng.com/books/java/maven/deploy/github-page.jpg" alt="enable-github-pages"></p><p>这样，把全部内容推送至GitHub后，即可作为静态网站访问Maven的repo，它的地址是<a href="https://michaelliao.github.io/how-to-become-rich/maven-repo/">https://michaelliao.github.io/how-to-become-rich/maven-repo/</a>。版本<code>1.0.0</code>对应的jar包地址是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://michaelliao.github.io/how-to-become-rich/maven-repo/com/itranswarp/rich/how-to-become-rich/1.0.0/how-to-become-rich-1.0.0.jar</span><br></pre></td></tr></table></figure><p>现在，如果其他人希望引用这个Maven包，我们可以告知如下依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.rich<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>how-to-become-rich<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是，除了正常导入依赖外，对方还需要再添加一个<code>&lt;repository&gt;</code>的声明，即使用方完整的<code>pom.xml</code>如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>how-to-become-rich-usage<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>github-rich-repo<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>The Maven Repository on Github<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://michaelliao.github.io/how-to-become-rich/maven-repo/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.rich<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>how-to-become-rich<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>&lt;repository&gt;</code>中，我们必须声明发布的Maven的repo地址，其中<code>&lt;id&gt;</code>和<code>&lt;name&gt;</code>可以任意填写，<code>&lt;url&gt;</code>填入GitHub Pages提供的地址+<code>/maven-repo/</code>后缀。现在，即可正常引用这个库并编写代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Millionaire</span> <span class="variable">millionaire</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Millionaire</span>();</span><br><span class="line">System.out.println(millionaire.howToBecomeRich());</span><br></pre></td></tr></table></figure><p>有的童鞋会问，为什么使用<code>commons-logging</code>等第三方库时，并不需要声明repo地址？这是因为这些库都是发布到Maven中央仓库的，发布到中央仓库后，不需要告诉Maven仓库地址，因为它知道中央仓库的地址默认是<a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a>，也可以通过<code>~/.m2/settings.xml</code>指定一个代理仓库地址以替代中央仓库来提高速度（参考<a href="https://liaoxuefeng.com/books/java/maven/20-dependency/index.html">依赖管理</a>的Maven镜像）。</p><p>因为GitHub Pages并不会把我们发布的Maven包同步到中央仓库，所以使用方必须手动添加一个我们提供的仓库地址。</p><p>此外，通过GitHub Pages发布Maven repo时需要注意一点，即不要改动已发布的版本。因为Maven的仓库是不允许修改任何版本的，对一个库进行修改的唯一方法是发布一个新版本。但是通过静态文件的方式发布repo，实际上我们是可以修改jar文件的，但最好遵守规范，不要修改已发布版本。</p><h3 id="通过Nexus发布到中央仓库">通过Nexus发布到中央仓库</h3><p>有的童鞋会问，能不能把自己的开源库发布到Maven的中央仓库，这样用户就不需要声明repo地址，可以直接引用，显得更专业。</p><p>当然可以，但我们不能直接发布到Maven中央仓库，而是通过曲线救国的方式，发布到<a href="https://central.sonatype.org/">central.sonatype.org</a>，它会定期自动同步到Maven的中央仓库。<a href="https://www.sonatype.com/nexus-repository-oss">Nexus</a>是一个支持Maven仓库的软件，由Sonatype开发，有免费版和专业版两个版本，很多大公司内部都使用Nexus作为自己的私有Maven仓库，而这个<a href="https://central.sonatype.org/">central.sonatype.org</a>相当于面向开源的一个Nexus公共服务。</p><p>所以，第一步是在<a href="https://central.sonatype.org/">central.sonatype.org</a>上注册一个账号，如果注册顺利并审核通过，会得到一个登录账号，然后，通过<a href="https://central.sonatype.org/pages/apache-maven.html">这个页面</a>一步一步操作就可以成功地将自己的Artifact发布到Nexus上，再耐心等待几个小时后，你的Artifact就会出现在Maven的中央仓库中。</p><p>这里简单提一下发布重点与难点：</p><ul><li>必须正确创建GPG签名，Linux和Mac下推荐使用gnupg2；</li><li>必须在<code>~/.m2/settings.xml</code>中配置好登录用户名和口令，以及GPG口令：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>ossrh<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">username</span>&gt;</span>OSSRH-USERNAME<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">password</span>&gt;</span>OSSRH-PASSWORD<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>ossrh<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gpg.executable</span>&gt;</span>gpg2<span class="tag">&lt;/<span class="name">gpg.executable</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gpg.passphrase</span>&gt;</span>GPG-PASSWORD<span class="tag">&lt;/<span class="name">gpg.passphrase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在待发布的Artifact的<code>pom.xml</code>中添加OSS的Maven repo地址，以及<code>maven-jar-plugin</code>、<code>maven-source-plugin</code>、<code>maven-javadoc-plugin</code>、<code>maven-gpg-plugin</code>、<code>nexus-staging-maven-plugin</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>ossrh<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://oss.sonatype.org/content/repositories/snapshots<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>ossrh<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Release Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://oss.sonatype.org/service/local/staging/deploy/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>test-jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-sources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar-no-fork<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-javadocs<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">additionalOption</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">additionalOption</span>&gt;</span>-Xdoclint:none<span class="tag">&lt;/<span class="name">additionalOption</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">additionalOption</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-gpg-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>sign-artifacts<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>verify<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>sign<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.sonatype.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nexus-staging-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>true<span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">serverId</span>&gt;</span>ossrh<span class="tag">&lt;/<span class="name">serverId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">nexusUrl</span>&gt;</span>https://oss.sonatype.org/<span class="tag">&lt;/<span class="name">nexusUrl</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">autoReleaseAfterClose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">autoReleaseAfterClose</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后执行命令<code>mvn clean package deploy</code>即可发布至<a href="https://central.sonatype.org/">central.sonatype.org</a>。</p><p>此方法前期需要复杂的申请账号和项目的流程，后期需要安装调试GPG，但只要跑通流程，后续发布都只需要一行命令。</p><h3 id="发布到私有仓库">发布到私有仓库</h3><p>通过<code>nexus-staging-maven-plugin</code>除了可以发布到<a href="https://central.sonatype.org/">central.sonatype.org</a>外，也可以发布到私有仓库，例如，公司内部自己搭建的Nexus服务器。</p><p>如果没有私有Nexus服务器，还可以发布到<a href="https://github.com/features/packages">GitHub Packages</a>。GitHub Packages是GitHub提供的仓库服务，支持Maven、NPM、Docker等。使用GitHub Packages时，无论是发布Artifact，还是引用已发布的Artifact，都需要明确的授权Token，因此，GitHub Packages只能作为私有仓库使用。</p><p>在发布前，我们必须首先登录后在用户的<code>Settings</code>-<code>Developer settings</code>-<code>Personal access tokens</code>中创建两个Token，一个用于发布，一个用于使用。发布Artifact的Token必须有<code>repo</code>、<code>write:packages</code>和<code>read:packages</code>权限：</p><p><img src="https://liaoxuefeng.com/books/java/maven/deploy/private-repo.jpg" alt="token-scopes"></p><p>使用Artifact的Token只需要<code>read:packages</code>权限。</p><p>在发布端，把GitHub的用户名和发布Token写入<code>~/.m2/settings.xml</code>配置中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>github-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">username</span>&gt;</span>GITHUB-USERNAME<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">password</span>&gt;</span>f052...c21f<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，在需要发布的Artifact的<code>pom.xml</code>中，添加一个<code>&lt;repository&gt;</code>声明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>github-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>GitHub Release<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.pkg.github.com/michaelliao/complex<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意到<code>&lt;id&gt;</code>和<code>~/.m2/settings.xml</code>配置中的<code>&lt;id&gt;</code>要保持一致，因为发布时Maven根据id找到用于登录的用户名和Token，才能成功上传文件到GitHub。我们直接通过命令<code>mvn clean package deploy</code>部署，成功后，在GitHub用户页面可以看到该Artifact：</p><p><img src="https://liaoxuefeng.com/books/java/maven/deploy/github-packages.jpg" alt="github-packages"></p><p>完整的配置请参考<a href="https://github.com/michaelliao/complex/">complex</a>项目，这是一个非常简单的支持复数运算的库。</p><p>使用该Artifact时，因为GitHub的Package只能作为私有仓库使用，所以除了在使用方的<code>pom.xml</code>中声明<code>&lt;repository&gt;</code>外：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>github-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>GitHub Release<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.pkg.github.com/michaelliao/complex<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>complex<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还需要把有读权限的Token配置到<code>~/.m2/settings.xml</code>文件中。</p><h3 id="练习-4">练习</h3><p>使用maven-deploy-plugin把Artifact发布到本地。</p><h3 id="小结-7">小结</h3><p>使用Maven发布一个Artifact时：</p><ul><li>可以发布到本地，然后推送到远程Git库，由静态服务器提供基于网页的repo服务，使用方必须声明repo地址；</li><li>可以发布到<a href="https://central.sonatype.org/">central.sonatype.org</a>，并自动同步到Maven中央仓库，需要前期申请账号以及本地配置；</li><li>可以发布到GitHub Packages作为私有仓库使用，必须提供Token以及正确的权限才能发布和使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-多线程1</title>
      <link href="/2025/05/24/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B1/"/>
      <url>/2025/05/24/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B1/</url>
      
        <content type="html"><![CDATA[<p>现代操作系统（Windows，macOS，Linux）都可以执行多任务。多任务就是同时运行多个任务，例如：</p><p><img src="https://liaoxuefeng.com/books/java/threading/basic/multitask.jpg" alt="multitask"></p><p>CPU执行代码都是一条一条顺序执行的，但是，即使是单核cpu，也可以同时运行多个任务。因为操作系统执行多任务实际上就是让CPU对多个任务轮流交替执行。</p><p>例如，假设我们有语文、数学、英语3门作业要做，每个作业需要30分钟。我们把这3门作业看成是3个任务，可以做1分钟语文作业，再做1分钟数学作业，再做1分钟英语作业：</p><p><img src="https://liaoxuefeng.com/books/java/threading/basic/hurry.jpg" alt="hurry"></p><p>这样轮流做下去，在某些人眼里看来，做作业的速度就非常快，看上去就像同时在做3门作业一样</p><p><img src="https://liaoxuefeng.com/books/java/threading/basic/fast.gif" alt="ooops"></p><p>类似的，操作系统轮流让多个任务交替执行，例如，让浏览器执行0.001秒，让QQ执行0.001秒，再让音乐播放器执行0.001秒，在人看来，CPU就是在同时执行多个任务。</p><p>即使是多核CPU，因为通常任务的数量远远多于CPU的核数，所以任务也是交替执行的。</p><h3 id="进程">进程</h3><p>在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。</p><p>某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。</p><p>进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                        ┌──────────┐</span><br><span class="line">                        │Process   │</span><br><span class="line">                        │┌────────┐│</span><br><span class="line">            ┌──────────┐││ Thread ││┌──────────┐</span><br><span class="line">            │Process   ││└────────┘││Process   │</span><br><span class="line">            │┌────────┐││┌────────┐││┌────────┐│</span><br><span class="line">┌──────────┐││ Thread ││││ Thread ││││ Thread ││</span><br><span class="line">│Process   ││└────────┘││└────────┘││└────────┘│</span><br><span class="line">│┌────────┐││┌────────┐││┌────────┐││┌────────┐│</span><br><span class="line">││ Thread ││││ Thread ││││ Thread ││││ Thread ││</span><br><span class="line">│└────────┘││└────────┘││└────────┘││└────────┘│</span><br><span class="line">└──────────┘└──────────┘└──────────┘└──────────┘</span><br><span class="line">┌──────────────────────────────────────────────┐</span><br><span class="line">│               Operating System               │</span><br><span class="line">└──────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>操作系统调度的最小任务单位其实不是进程，而是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。</p><p>因为同一个应用程序，既可以有多个进程，也可以有多个线程，因此，实现多任务的方法，有以下几种：</p><p>多进程模式（每个进程只有一个线程）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──────────┐ ┌──────────┐ ┌──────────┐</span><br><span class="line">│Process   │ │Process   │ │Process   │</span><br><span class="line">│┌────────┐│ │┌────────┐│ │┌────────┐│</span><br><span class="line">││ Thread ││ ││ Thread ││ ││ Thread ││</span><br><span class="line">│└────────┘│ │└────────┘│ │└────────┘│</span><br><span class="line">└──────────┘ └──────────┘ └──────────┘</span><br></pre></td></tr></table></figure><p>多线程模式（一个进程有多个线程）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────────┐</span><br><span class="line">│Process             │</span><br><span class="line">│┌────────┐┌────────┐│</span><br><span class="line">││ Thread ││ Thread ││</span><br><span class="line">│└────────┘└────────┘│</span><br><span class="line">│┌────────┐┌────────┐│</span><br><span class="line">││ Thread ││ Thread ││</span><br><span class="line">│└────────┘└────────┘│</span><br><span class="line">└────────────────────┘</span><br></pre></td></tr></table></figure><p>多进程＋多线程模式（复杂度最高）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──────────┐┌──────────┐┌──────────┐</span><br><span class="line">│Process   ││Process   ││Process   │</span><br><span class="line">│┌────────┐││┌────────┐││┌────────┐│</span><br><span class="line">││ Thread ││││ Thread ││││ Thread ││</span><br><span class="line">│└────────┘││└────────┘││└────────┘│</span><br><span class="line">│┌────────┐││┌────────┐││┌────────┐│</span><br><span class="line">││ Thread ││││ Thread ││││ Thread ││</span><br><span class="line">│└────────┘││└────────┘││└────────┘│</span><br><span class="line">└──────────┘└──────────┘└──────────┘</span><br></pre></td></tr></table></figure><h3 id="进程-vs-线程">进程 vs 线程</h3><p>进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。</p><p>具体采用哪种方式，要考虑到进程和线程的特点。</p><p>和多线程相比，多进程的缺点在于：</p><ul><li>创建进程比创建线程开销大，尤其是在Windows系统上；</li><li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</li></ul><p>而多进程的优点在于：</p><p>多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</p><h3 id="多线程">多线程</h3><p>Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行<code>main()</code>方法，在<code>main()</code>方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p><p>因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。</p><p>和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。</p><p>Java多线程编程的特点又在于：</p><ul><li>多线程模型是Java程序最基本的并发模型；</li><li>后续读写网络、数据库、Web开发等都依赖Java多线程模型。</li></ul><p>因此，必须掌握Java多线程编程才能继续深入学习其他内容。</p><p>Java语言内置了多线程支持。当Java程序启动的时候，实际上是启动了一个JVM进程，然后，JVM启动主线程来执行<code>main()</code>方法。在<code>main()</code>方法中，我们又可以启动其他线程。</p><p>要创建一个新线程非常容易，我们需要实例化一个<code>Thread</code>实例，然后调用它的<code>start()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个线程启动后实际上什么也不做就立刻结束了。我们希望新线程能执行指定的代码，有以下几种方法：</p><p>方法一：从<code>Thread</code>派生一个自定义类，然后覆写<code>run()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，注意到<code>start()</code>方法会在内部自动调用实例的<code>run()</code>方法。</p><p>方法二：创建<code>Thread</code>实例时，传入一个<code>Runnable</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者用Java 8引入的lambda语法进一步简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有童鞋会问，使用线程执行的打印语句，和直接在<code>main()</code>方法执行有区别吗？</p><p>区别大了去了。我们看以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;main start...&quot;);</span><br><span class="line">        Thread t = new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;thread run...&quot;);</span><br><span class="line">                System.out.println(&quot;thread end.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(&quot;main end...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用蓝色表示主线程，也就是<code>main</code>线程，<code>main</code>线程执行的代码有4行，首先打印<code>main start</code>，然后创建<code>Thread</code>对象，紧接着调用<code>start()</code>启动新线程。当<code>start()</code>方法被调用时，JVM就创建了一个新线程，我们通过实例变量<code>t</code>来表示这个新线程对象，并开始执行。</p><p>接着，<code>main</code>线程继续执行打印<code>main end</code>语句，而<code>t</code>线程在<code>main</code>线程执行的同时会并发执行，打印<code>thread run</code>和<code>thread end</code>语句。</p><p>当<code>run()</code>方法结束时，新线程就结束了。而<code>main()</code>方法结束时，主线程也结束了。</p><p>我们再来看线程的执行顺序：</p><ol><li><code>main</code>线程肯定是先打印<code>main start</code>，再打印<code>main end</code>；</li><li><code>t</code>线程肯定是先打印<code>thread run</code>，再打印<code>thread end</code>。</li></ol><p>但是，除了可以肯定，<code>main start</code>会先打印外，<code>main end</code>打印在<code>thread run</code>之前、<code>thread end</code>之后或者之间，都无法确定。因为从<code>t</code>线程开始运行以后，两个线程就开始同时运行了，并且由操作系统调度，程序本身无法确定线程的调度顺序。</p><p>要模拟并发执行的效果，我们可以在线程中调用<code>Thread.sleep()</code>，强迫当前线程暂停一段时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread run...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread end.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sleep()</code>传入的参数是毫秒。调整暂停时间的大小，我们可以看到<code>main</code>线程和<code>t</code>线程执行的先后顺序。</p><p>要特别注意：直接调用<code>Thread</code>实例的<code>run()</code>方法是无效的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用<code>run()</code>方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程。上述代码实际上是在<code>main()</code>方法内部又调用了<code>run()</code>方法，打印<code>hello</code>语句是在<code>main</code>线程中执行的，没有任何新线程被创建。</p><p>必须调用<code>Thread</code>实例的<code>start()</code>方法才能启动新线程，如果我们查看<code>Thread</code>类的源代码，会看到<code>start()</code>方法内部调用了一个<code>private native void start0()</code>方法，<code>native</code>修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。</p><h3 id="线程的优先级">线程的优先级</h3><p>可以对线程设定优先级，设定优先级的方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.setPriority(<span class="type">int</span> n) <span class="comment">// 1~10, 默认值5</span></span><br></pre></td></tr></table></figure><p>JVM自动把1（低）~10（高）的优先级映射到操作系统实际优先级上（不同操作系统有不同的优先级数量）。优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。</p><h3 id="练习">练习</h3><p>创建一个新线程。</p><p><a href="https://liaoxuefeng.com/books/java/threading/new-thread/thread-multi.zip">下载练习</a></p><h3 id="小结">小结</h3><p>Java用<code>Thread</code>对象表示一个线程，通过调用<code>start()</code>启动一个新线程；</p><p>一个线程对象只能调用一次<code>start()</code>方法；</p><p>线程的执行代码写在<code>run()</code>方法中；</p><p>线程调度由操作系统决定，程序本身无法决定调度顺序；</p><p><code>Thread.sleep()</code>可以把当前线程暂停一段时间。</p><h2 id="线程的状态">线程的状态</h2><p>在Java程序中，一个线程对象只能调用一次<code>start()</code>方法启动新线程，并在新线程中执行<code>run()</code>方法。一旦<code>run()</code>方法执行完毕，线程就结束了。因此，Java线程的状态有以下几种：</p><ul><li>New：新创建的线程，尚未执行；</li><li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li><li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li><li>Waiting：运行中的线程，因为某些操作在等待中；</li><li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li><li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</li></ul><p>用一个状态转移图表示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">         ┌─────────────┐</span><br><span class="line">         │     New     │</span><br><span class="line">         └─────────────┘</span><br><span class="line">                │</span><br><span class="line">                ▼</span><br><span class="line">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line"> ┌─────────────┐ ┌─────────────┐</span><br><span class="line">││  Runnable   │ │   Blocked   ││</span><br><span class="line"> └─────────────┘ └─────────────┘</span><br><span class="line">│┌─────────────┐ ┌─────────────┐│</span><br><span class="line"> │   Waiting   │ │Timed Waiting│</span><br><span class="line">│└─────────────┘ └─────────────┘│</span><br><span class="line"> ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─</span><br><span class="line">                │</span><br><span class="line">                ▼</span><br><span class="line">         ┌─────────────┐</span><br><span class="line">         │ Terminated  │</span><br><span class="line">         └─────────────┘</span><br></pre></td></tr></table></figure><p>当线程启动后，它可以在<code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>和<code>Timed Waiting</code>这几个状态之间切换，直到最后变成<code>Terminated</code>状态，线程终止。</p><p>线程终止的原因有：</p><ul><li>线程正常终止：<code>run()</code>方法执行到<code>return</code>语句返回；</li><li>线程意外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</li><li>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</li></ul><p>一个线程还可以等待另一个线程直到其运行结束。例如，<code>main</code>线程在启动<code>t</code>线程后，可以通过<code>t.join()</code>等待<code>t</code>线程结束后再继续运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        t.start(); <span class="comment">// 启动t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 此处main线程会等待t结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>main</code>线程对线程对象<code>t</code>调用<code>join()</code>方法时，主线程将等待变量<code>t</code>表示的线程运行结束，即<code>join</code>就是指等待该线程结束，然后才继续往下执行自身线程。所以，上述代码打印顺序可以肯定是<code>main</code>线程先打印<code>start</code>，<code>t</code>线程再打印<code>hello</code>，<code>main</code>线程最后再打印<code>end</code>。</p><p>如果<code>t</code>线程已经结束，对实例<code>t</code>调用<code>join()</code>会立刻返回。此外，<code>join(long)</code>的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。</p><h3 id="小结-2">小结</h3><p>Java线程对象<code>Thread</code>的状态包括：<code>New</code>、<code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>、<code>Timed Waiting</code>和<code>Terminated</code>；</p><p>通过对另一个线程对象调用<code>join()</code>方法可以等待其执行结束；</p><p>可以指定等待时间，超过等待时间线程仍然没有结束就不再等待；</p><p>对已经运行结束的线程调用<code>join()</code>方法会立刻返回。</p><hr><hr><p>如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是其他线程给该线程发一个信号，该线程收到信号后结束执行<code>run()</code>方法，使得自身线程能立刻结束运行。</p><p>我们举个栗子：假设从网络下载一个100M的文件，如果网速很慢，用户等得不耐烦，就可能在下载过程中点“取消”，这时，程序就需要中断下载线程的执行。</p><p>中断一个线程非常简单，只需要在其他线程中对目标线程调用<code>interrupt()</code>方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。</p><p>我们还是看示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>); <span class="comment">// 暂停1毫秒</span></span><br><span class="line">        t.interrupt(); <span class="comment">// 中断t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 等待t线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (! isInterrupted()) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细看上述代码，<code>main</code>线程通过调用<code>t.interrupt()</code>方法中断<code>t</code>线程，但是要注意，<code>interrupt()</code>方法仅仅向<code>t</code>线程发出了“中断请求”，至于<code>t</code>线程是否能立刻响应，要看具体代码。而<code>t</code>线程的<code>while</code>循环会检测<code>isInterrupted()</code>，所以上述代码能正确响应<code>interrupt()</code>请求，使得自身立刻结束运行<code>run()</code>方法。</p><p>如果线程处于等待状态，例如，<code>t.join()</code>会让<code>main</code>线程进入等待状态，此时，如果对<code>main</code>线程调用<code>interrupt()</code>，<code>join()</code>方法会立刻抛出<code>InterruptedException</code>，因此，目标线程只要捕获到<code>join()</code>方法抛出的<code>InterruptedException</code>，就说明有其他线程对其调用了<code>interrupt()</code>方法，通常情况下该线程应该立刻结束运行。</p><p>我们来看下面的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t.interrupt(); <span class="comment">// 中断t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 等待t线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">        hello.start(); <span class="comment">// 启动hello线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hello.join(); <span class="comment">// 等待hello线程结束</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;interrupted!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hello.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code>线程通过调用<code>t.interrupt()</code>从而通知<code>t</code>线程中断，而此时<code>t</code>线程正位于<code>hello.join()</code>的等待中，此方法会立刻结束等待并抛出<code>InterruptedException</code>。由于我们在<code>t</code>线程中捕获了<code>InterruptedException</code>，因此，就可以准备结束该线程。在<code>t</code>线程结束前，对<code>hello</code>线程也进行了<code>interrupt()</code>调用通知其中断。如果去掉这一行代码，可以发现<code>hello</code>线程仍然会继续运行，且JVM不会退出。</p><p>另一个常用的中断线程的方法是设置标志位。我们通常会用一个<code>running</code>标志位来标识线程是否应该继续运行，在外部线程中，通过把<code>HelloThread.running</code>置为<code>false</code>，就可以让线程结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">HelloThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        t.running = <span class="literal">false</span>; <span class="comment">// 标志位置为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>HelloThread</code>的标志位<code>boolean running</code>是一个线程间共享的变量。线程间共享变量需要使用<code>volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值。</p><p>为什么要对线程间共享的变量用关键字<code>volatile</code>声明？这涉及到Java的内存模型。在Java虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是，这个时间是不确定的！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line">           Main Memory</span><br><span class="line">│                               │</span><br><span class="line">   ┌───────┐┌───────┐┌───────┐</span><br><span class="line">│  │ var A ││ var B ││ var C │  │</span><br><span class="line">   └───────┘└───────┘└───────┘</span><br><span class="line">│     │ ▲               │ ▲     │</span><br><span class="line"> ─ ─ ─│─│─ ─ ─ ─ ─ ─ ─ ─│─│─ ─ ─</span><br><span class="line">      │ │               │ │</span><br><span class="line">┌ ─ ─ ┼ ┼ ─ ─ ┐   ┌ ─ ─ ┼ ┼ ─ ─ ┐</span><br><span class="line">      ▼ │               ▼ │</span><br><span class="line">│  ┌───────┐  │   │  ┌───────┐  │</span><br><span class="line">   │ var A │         │ var C │</span><br><span class="line">│  └───────┘  │   │  └───────┘  │</span><br><span class="line">   Thread 1          Thread 2</span><br><span class="line">└ ─ ─ ─ ─ ─ ─ ┘   └ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure><p>这会导致如果一个线程更新了某个变量，另一个线程读取的值可能还是更新前的。例如，主内存的变量<code>a = true</code>，线程1执行<code>a = false</code>时，它在此刻仅仅是把变量<code>a</code>的副本变成了<code>false</code>，主内存的变量<code>a</code>还是<code>true</code>，在JVM把修改后的<code>a</code>回写到主内存之前，其他线程读取到的<code>a</code>的值仍然是<code>true</code>，这就造成了多线程之间共享的变量不一致。</p><p>因此，<code>volatile</code>关键字的目的是告诉虚拟机：</p><ul><li>每次访问变量时，总是获取主内存的最新值；</li><li>每次修改变量后，立刻回写到主内存。</li></ul><p><code>volatile</code>关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。</p><p>如果我们去掉<code>volatile</code>关键字，运行上述程序，发现效果和带<code>volatile</code>差不多，这是因为在x86的架构下，JVM回写主内存的速度非常快，但是，换成ARM的架构，就会有显著的延迟。</p><h3 id="小结-3">小结</h3><p>对目标线程调用<code>interrupt()</code>方法可以请求中断一个线程，目标线程通过检测<code>isInterrupted()</code>标志获取自身是否已中断。如果目标线程处于等待状态，该线程会捕获到<code>InterruptedException</code>；</p><p>目标线程检测到<code>isInterrupted()</code>为<code>true</code>或者捕获了<code>InterruptedException</code>都应该立刻结束自身线程；</p><p>通过标志位判断需要正确使用<code>volatile</code>关键字；</p><p><code>volatile</code>关键字解决了共享变量在线程间的可见性问题。</p><h2 id="守护线程">守护线程</h2><p>Java程序入口就是由JVM启动<code>main</code>线程，<code>main</code>线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。</p><p>如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。</p><p>但是有一种线程的目的就是无限循环，例如，一个定时触发任务的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(LocalTime.now());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个线程不结束，JVM进程就无法结束。问题是，由谁负责结束这个线程？</p><p>然而这类线程经常没有负责人来负责结束它们。但是，当其他线程结束时，JVM进程又必须要结束，怎么办？</p><p>答案是使用守护线程（Daemon Thread）。</p><p>守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p><p>因此，JVM退出时，不必关心守护线程是否已结束。</p><p>如何创建守护线程呢？方法和普通线程一样，只是在调用<code>start()</code>方法前，调用<code>setDaemon(true)</code>把该线程标记为守护线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p>在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。</p><h3 id="练习-2">练习</h3><p>使用守护线程。</p><p><a href="https://liaoxuefeng.com/books/java/threading/daemon/thread-daemon.zip">下载练习</a></p><h3 id="小结-4">小结</h3><p>守护线程是为其他线程服务的线程；</p><p>所有非守护线程都执行完毕后，虚拟机退出，守护线程随之结束；</p><p>守护线程不能持有需要关闭的资源（如打开文件等）。</p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-多线程2(线程同步)</title>
      <link href="/2025/05/24/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B2(%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5)/"/>
      <url>/2025/05/24/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B2(%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5)/</url>
      
        <content type="html"><![CDATA[<p>当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。</p><p>这个时候，有个单线程模型下不存在的问题就来了：如果多个线程同时读写共享变量，会出现数据不一致的问题。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddThread</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">dec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecThread</span>();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123; Counter.count += <span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123; Counter.count -= <span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很简单，两个线程同时对一个<code>int</code>变量进行操作，一个加10000次，一个减10000次，最后结果应该是0，但是，每次运行，结果实际上都是不一样的。</p><p>这是因为对变量进行读取和写入时，结果要正确，必须保证是原子操作。原子操作是指不能被中断的一个或一系列操作。</p><p>例如，对于语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = n + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>看上去是一行语句，实际上对应了3条指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ILOAD</span><br><span class="line">IADD</span><br><span class="line">ISTORE</span><br></pre></td></tr></table></figure><p>我们假设<code>n</code>的值是<code>100</code>，如果两个线程同时执行<code>n = n + 1</code>，得到的结果很可能不是<code>102</code>，而是<code>101</code>，原因在于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌───────┐     ┌───────┐</span><br><span class="line">│Thread1│     │Thread2│</span><br><span class="line">└───┬───┘     └───┬───┘</span><br><span class="line">    │             │</span><br><span class="line">    │ILOAD (100)  │</span><br><span class="line">    │             │ILOAD (100)</span><br><span class="line">    │             │IADD</span><br><span class="line">    │             │ISTORE (101)</span><br><span class="line">    │IADD         │</span><br><span class="line">    │ISTORE (101) │</span><br><span class="line">    ▼             ▼</span><br></pre></td></tr></table></figure><p>如果线程1在执行<code>ILOAD</code>后被操作系统中断，此刻如果线程2被调度执行，它执行<code>ILOAD</code>后获取的值仍然是<code>100</code>，最终结果被两个线程的<code>ISTORE</code>写入后变成了<code>101</code>，而不是期待的<code>102</code>。</p><p>这说明多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌───────┐     ┌───────┐</span><br><span class="line">│Thread1│     │Thread2│</span><br><span class="line">└───┬───┘     └───┬───┘</span><br><span class="line">    │             │</span><br><span class="line">    │-- lock --   │</span><br><span class="line">    │ILOAD (100)  │</span><br><span class="line">    │IADD         │</span><br><span class="line">    │ISTORE (101) │</span><br><span class="line">    │-- unlock -- │</span><br><span class="line">    │             │-- lock --</span><br><span class="line">    │             │ILOAD (101)</span><br><span class="line">    │             │IADD</span><br><span class="line">    │             │ISTORE (102)</span><br><span class="line">    │             │-- unlock --</span><br><span class="line">    ▼             ▼</span><br></pre></td></tr></table></figure><p>通过加锁和解锁的操作，就能保证3条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间。即使在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。这种加锁和解锁之间的代码块我们称之为临界区（Critical Section），任何时候临界区最多只有一个线程能执行。</p><p>可见，保证一段代码的原子性就是通过加锁和解锁实现的。Java程序使用<code>synchronized</code>关键字对一个对象进行加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    n = n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>synchronized</code>保证了代码块在任意时刻最多只有一个线程能执行。我们把上面的代码用<code>synchronized</code>改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddThread</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">dec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecThread</span>();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Counter.lock) &#123; <span class="comment">// 获取锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure><p>它表示用<code>Counter.lock</code>实例作为锁，两个线程在执行各自的<code>synchronized(Counter.lock) &#123; ... &#125;</code>代码块时，必须先获得锁，才能进入代码块进行。执行结束后，在<code>synchronized</code>语句块结束会自动释放锁。这样一来，对<code>Counter.count</code>变量进行读写就不可能同时进行。上述代码无论运行多少次，最终结果都是0。</p><p>使用<code>synchronized</code>解决了多线程同步访问共享变量的正确性问题。但是，它的缺点是带来了性能下降。因为<code>synchronized</code>代码块无法并发执行。此外，加锁和解锁需要消耗一定的时间，所以，<code>synchronized</code>会降低程序的执行效率。</p><p>我们来概括一下如何使用<code>synchronized</code>：</p><ol><li>找出修改共享变量的线程代码块；</li><li>选择一个共享实例作为锁；</li><li>使用<code>synchronized(lockObject) &#123; ... &#125;</code>。</li></ol><p>在使用<code>synchronized</code>的时候，不必担心抛出异常。因为无论是否有异常，都会在<code>synchronized</code>结束处正确释放锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.value += m;</span><br><span class="line">    &#125; <span class="comment">// 无论有无异常，都会在此释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看一个错误使用<code>synchronized</code>的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddThread</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">dec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecThread</span>();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock1) &#123;</span><br><span class="line">                Counter.count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock2) &#123;</span><br><span class="line">                Counter.count -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果并不是0，这是因为两个线程各自的<code>synchronized</code>锁住的<em>不是同一个对象</em>！这使得两个线程各自都可以同时获得锁：因为JVM只保证同一个锁在任意时刻只能被一个线程获取，但两个不同的锁在同一时刻可以被两个线程分别获取。</p><p>因此，使用<code>synchronized</code>的时候，获取到的是哪个锁非常重要。锁对象如果不对，代码逻辑就不对。</p><p>我们再看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>[] &#123; <span class="keyword">new</span> <span class="title class_">AddStudentThread</span>(), <span class="keyword">new</span> <span class="title class_">DecStudentThread</span>(), <span class="keyword">new</span> <span class="title class_">AddTeacherThread</span>(), <span class="keyword">new</span> <span class="title class_">DecTeacherThread</span>() &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t : ts) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t : ts) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Counter.studentCount);</span><br><span class="line">        System.out.println(Counter.teacherCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">studentCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">teacherCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddStudentThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.studentCount += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecStudentThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.studentCount -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddTeacherThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.teacherCount += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecTeacherThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.teacherCount -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的4个线程对两个共享变量分别进行读写操作，但是使用的锁都是<code>Counter.lock</code>这一个对象，这就造成了原本可以并发执行的<code>Counter.studentCount += 1</code>和<code>Counter.teacherCount += 1</code>，现在无法并发执行了，执行效率大大降低。实际上，需要同步的线程可以分成两组：<code>AddStudentThread</code>和<code>DecStudentThread</code>，<code>AddTeacherThread</code>和<code>DecTeacherThread</code>，组之间不存在竞争，因此，应该使用两个不同的锁，即：</p><p><code>AddStudentThread</code>和<code>DecStudentThread</code>使用<code>lockStudent</code>锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Counter.lockStudent) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AddTeacherThread</code>和<code>DecTeacherThread</code>使用<code>lockTeacher</code>锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Counter.lockTeacher) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样才能最大化地提高执行效率。</p><h3 id="不需要synchronized的操作">不需要synchronized的操作</h3><p>JVM规范定义了几种原子操作：</p><ul><li>基本类型（<code>long</code>和<code>double</code>除外）赋值，例如：<code>int n = m</code>；</li><li>引用类型赋值，例如：<code>List&lt;String&gt; list = anotherList</code>。</li></ul><p><code>long</code>和<code>double</code>是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把<code>long</code>和<code>double</code>的赋值作为原子操作实现的。</p><p>单条原子操作的语句不需要同步。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就不需要同步。</p><p>对引用也是类似。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述赋值语句并不需要同步。</p><p>但是，如果是多行赋值语句，就必须保证是同步操作，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示</p><p>多线程连续读写多个变量时，同步的目的是为了保证程序逻辑正确！</p><p>不但写需要同步，读也需要同步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] get() &#123;</span><br><span class="line">        <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        copy[<span class="number">0</span>] = x;</span><br><span class="line">        copy[<span class="number">1</span>] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假定当前坐标是<code>(100, 200)</code>，那么当设置新坐标为<code>(110, 220)</code>时，上述未同步的多线程读到的值可能有：</p><ul><li>(100, 200)：x，y更新前；</li><li>(110, 200)：x更新后，y更新前；</li><li>(110, 220)：x，y更新后。</li></ul><p>如果读取到<code>(110, 200)</code>，即读到了更新后的x，更新前的y，那么可能会造成程序的逻辑错误，无法保证读取的多个变量状态保持一致。</p><p>有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作。例如，上述代码如果改造成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] ps;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ps = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; x, y &#125;;</span><br><span class="line">        <span class="built_in">this</span>.ps = ps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就不再需要写同步，因为<code>this.ps = ps</code>是引用赋值的原子操作。而语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ps = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; x, y &#125;;</span><br></pre></td></tr></table></figure><p>这里的<code>ps</code>是方法内部定义的局部变量，每个线程都会有各自的局部变量，互不影响，并且互不可见，并不需要同步。</p><p>不过要注意，读方法在复制<code>int[]</code>数组的过程中仍然需要同步。</p><h3 id="不可变对象无需同步">不可变对象无需同步</h3><p>如果多线程读写的是一个不可变对象，那么无需同步，因为不会修改对象的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    List&lt;String&gt; names;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String[] names)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.names = List.of(names);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>set()</code>方法内部创建了一个不可变<code>List</code>，这个<code>List</code>包含的对象也是不可变对象<code>String</code>，因此，整个<code>List&lt;String&gt;</code>对象都是不可变的，因此读写均无需同步。</p><p>分析变量是否能被多线程访问时，首先要理清概念，多线程同时执行的是方法。对于下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    List&lt;String&gt; names;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String[] names, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ns = List.of(names);</span><br><span class="line">        <span class="built_in">this</span>.names = ns;</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> n * <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">this</span>.x += step;</span><br><span class="line">        <span class="built_in">this</span>.y += step;</span><br><span class="line">    &#125;</span><br><span class="line">    StatusRecord <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StatusRecord</span>(<span class="built_in">this</span>.names, <span class="built_in">this</span>.x, <span class="built_in">this</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有A、B两个线程，同时执行是指：</p><ul><li>可能同时执行set()；</li><li>可能同时执行get()；</li><li>可能A执行set()，同时B执行get()。</li></ul><p>类的成员变量<code>names</code>、<code>x</code>、<code>y</code>显然能被多线程同时读写，但局部变量（包括方法参数）如果没有“逃逸”，那么只有当前线程可见。局部变量<code>step</code>仅在<code>set()</code>方法内部使用，因此每个线程同时执行set时都有一份独立的step存储在线程的栈上，互不影响，但是局部变量<code>ns</code>虽然每个线程也各有一份，但后续赋值后对其他线程就变成可见了。对<code>set()</code>方法同步时，如果要最小化<code>synchronized</code>代码块，可以改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String[] names, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 局部变量其他线程不可见:</span></span><br><span class="line">    List&lt;String&gt; ns = List.of(names);</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> n * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.names = ns;</span><br><span class="line">        <span class="built_in">this</span>.x += step;</span><br><span class="line">        <span class="built_in">this</span>.y += step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，深入理解多线程还需理解变量在栈上的存储方式，基本类型和引用类型的存储方式也不同。</p><h3 id="小结">小结</h3><p>多线程同时读写共享变量时，可能会造成逻辑错误，因此需要通过<code>synchronized</code>同步；</p><p>同步的本质就是给指定对象加锁，加锁后才能继续执行后续代码；</p><p>注意加锁对象必须是同一个实例；</p><p>对JVM定义的单个原子操作不需要同步。</p><p>我们知道Java程序依靠<code>synchronized</code>对线程进行同步，使用<code>synchronized</code>的时候，锁住的是哪个对象非常重要。</p><p>让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把<code>synchronized</code>逻辑封装起来。例如，我们编写一个计数器如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count -= n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，线程调用<code>add()</code>、<code>dec()</code>方法时，它不必关心同步逻辑，因为<code>synchronized</code>代码块在<code>add()</code>、<code>dec()</code>方法内部。并且，我们注意到，<code>synchronized</code>锁住的对象是<code>this</code>，即当前实例，这又使得创建多个<code>Counter</code>实例的时候，它们之间互不影响，可以并发执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">c1</span> <span class="operator">=</span> Counter();</span><br><span class="line"><span class="type">var</span> <span class="variable">c2</span> <span class="operator">=</span> Counter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对c1进行操作的线程:</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    c1.add();</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    c1.dec();</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对c2进行操作的线程:</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    c2.add();</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    c2.dec();</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>现在，对于<code>Counter</code>类，多线程可以正确调用。</p><p>如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe），上面的<code>Counter</code>类就是线程安全的。Java标准库的<code>java.lang.StringBuffer</code>也是线程安全的。</p><p>还有一些不变类，例如<code>String</code>，<code>Integer</code>，<code>LocalDate</code>，它们的所有成员变量都是<code>final</code>，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p><p>最后，类似<code>Math</code>这些只提供静态方法，没有成员变量的类，也是线程安全的。</p><p>除了上述几种少数情况，大部分类，例如<code>ArrayList</code>，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么<code>ArrayList</code>是可以安全地在线程间共享的。</p><p>我们再观察<code>Counter</code>的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们锁住的是<code>this</code>实例时，实际上可以用<code>synchronized</code>修饰这个方法。下面两种写法是等价的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123; <span class="comment">// 锁住this</span></span><br><span class="line">        count += n;</span><br><span class="line">    &#125; <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123; <span class="comment">// 锁住this</span></span><br><span class="line">    count += n;</span><br><span class="line">&#125; <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure><p>因此，用<code>synchronized</code>修饰的方法就是同步方法，它表示整个方法都必须用<code>this</code>实例加锁。</p><p>我们再思考一下，如果对一个静态方法添加<code>synchronized</code>修饰符，它锁住的是哪个对象？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>static</code>方法，是没有<code>this</code>实例的，因为<code>static</code>方法是针对类而不是实例。但是我们注意到任何一个类都有一个由JVM自动创建的<code>Class</code>实例，因此，对<code>static</code>方法添加<code>synchronized</code>，锁住的是该类的<code>Class</code>实例。上述<code>synchronized static</code>方法实际上相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Counter.class) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再考察<code>Counter</code>的<code>get()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它没有同步，因为读一个<code>int</code>变量不需要同步。</p><p>然而，如果我们把代码稍微改一下，返回一个包含两个<code>int</code>的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Pair <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Pair</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>();</span><br><span class="line">        p.first = first;</span><br><span class="line">        p.last = last;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就必须要同步了。</p><h3 id="小结-2">小结</h3><p>用<code>synchronized</code>修饰方法可以把整个方法变为同步代码块，<code>synchronized</code>方法加锁对象是<code>this</code>；</p><p>通过合理的设计和数据封装可以让一个类变为“线程安全”；</p><p>一个类没有特殊说明，默认不是thread-safe；</p><p>多线程能否安全访问某个非线程安全的实例，需要具体问题具体分析。</p><h2 id="死锁">死锁</h2><p>Java的线程锁是可重入的锁。</p><p>什么是可重入的锁？我们还是来看例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            dec(-n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        count += n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察<code>synchronized</code>修饰的<code>add()</code>方法，一旦线程执行到<code>add()</code>方法内部，说明它已经获取了当前实例的<code>this</code>锁。如果传入的<code>n &lt; 0</code>，将在<code>add()</code>方法内部调用<code>dec()</code>方法。由于<code>dec()</code>方法也需要获取<code>this</code>锁，现在问题来了：</p><p>对同一个线程，能否在获取到锁以后继续获取同一个锁？</p><p>答案是肯定的。JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做<strong>可重入锁</strong>。</p><p>由于Java的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出<code>synchronized</code>块，记录-1，减到0的时候，才会真正释放锁。</p><h3 id="死锁-2">死锁</h3><p>一个线程可以获取一个锁后，再继续获取另一个锁。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">        <span class="built_in">this</span>.value += m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">            <span class="built_in">this</span>.another += m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">        <span class="built_in">this</span>.another -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">            <span class="built_in">this</span>.value -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取多个锁的时候，不同线程获取多个不同对象的锁可能导致死锁。对于上述代码，线程1和线程2如果分别执行<code>add()</code>和<code>dec()</code>方法时：</p><ul><li>线程1：进入<code>add()</code>，获得<code>lockA</code>；</li><li>线程2：进入<code>dec()</code>，获得<code>lockB</code>。</li></ul><p>随后：</p><ul><li>线程1：准备获得<code>lockB</code>，失败，等待中；</li><li>线程2：准备获得<code>lockA</code>，失败，等待中。</li></ul><p>此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是死锁。</p><p>死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。</p><p>因此，在编写多线程应用时，要特别注意防止死锁。因为死锁一旦形成，就只能强制结束进程。</p><p>那么我们应该如何避免死锁呢？答案是：线程获取锁的顺序要一致。即严格按照先获取<code>lockA</code>，再获取<code>lockB</code>的顺序，改写<code>dec()</code>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">        <span class="built_in">this</span>.value -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">            <span class="built_in">this</span>.another -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习">练习</h3><p>请观察死锁的代码输出，然后修复。</p><p><a href="https://liaoxuefeng.com/books/java/threading/synchronize/dead-lock/thread-deadlock.zip">下载练习</a></p><h3 id="小结-3">小结</h3><p>Java的<code>synchronized</code>锁是可重入锁；</p><p>死锁产生的条件是多线程各自持有不同的锁，并互相试图获取对方已持有的锁，导致无限等待；</p><p>避免死锁的方法是多线程获取锁的顺序要一致。</p><hr><hr><p>在Java程序中，<code>synchronized</code>解决了多线程竞争的问题。例如，对于一个任务管理器，多个线程同时往队列中添加任务，可以用<code>synchronized</code>加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是<code>synchronized</code>并没有解决多线程协调的问题。</p><p>仍然以上面的<code>TaskQueue</code>为例，我们再编写一个<code>getTask()</code>方法取出队列的第一个任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码看上去没有问题：<code>getTask()</code>内部先判断队列是否为空，如果为空，就循环等待，直到另一个线程往队列中放入了一个任务，<code>while()</code>循环退出，就可以返回队列的元素了。</p><p>但实际上<code>while()</code>循环永远不会退出。因为线程在执行<code>while()</code>循环时，已经在<code>getTask()</code>入口获取了<code>this</code>锁，其他线程根本无法调用<code>addTask()</code>，因为<code>addTask()</code>执行条件也是获取<code>this</code>锁。</p><p>因此，执行上述代码，线程会在<code>getTask()</code>中因为死循环而100%占用CPU资源。</p><p>如果深入思考一下，我们想要的执行效果是：</p><ul><li>线程1可以调用<code>addTask()</code>不断往队列中添加任务；</li><li>线程2可以调用<code>getTask()</code>从队列中获取任务。如果队列为空，则<code>getTask()</code>应该等待，直到队列中至少有一个任务时再返回。</li></ul><p>因此，多线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。</p><p>对于上述<code>TaskQueue</code>，我们先改造<code>getTask()</code>方法，在条件不满足时，线程进入等待状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个线程执行到<code>getTask()</code>方法内部的<code>while</code>循环时，它必定已经获取到了<code>this</code>锁，此时，线程执行<code>while</code>条件判断，如果条件成立（队列为空），线程将执行<code>this.wait()</code>，进入等待状态。</p><p>这里的关键是：<code>wait()</code>方法必须在当前获取的锁对象上调用，这里获取的是<code>this</code>锁，因此调用<code>this.wait()</code>。</p><p>调用<code>wait()</code>方法后，线程进入等待状态，<code>wait()</code>方法不会返回，直到将来某个时刻，线程从等待状态被其他线程唤醒后，<code>wait()</code>方法才会返回，然后，继续执行下一条语句。</p><p>有些仔细的童鞋会指出：即使线程在<code>getTask()</code>内部等待，其他线程如果拿不到<code>this</code>锁，照样无法执行<code>addTask()</code>，肿么办？</p><p>这个问题的关键就在于<code>wait()</code>方法的执行机制非常复杂。首先，它不是一个普通的Java方法，而是定义在<code>Object</code>类的一个<code>native</code>方法，也就是由JVM的C代码实现的。其次，必须在<code>synchronized</code>块中才能调用<code>wait()</code>方法，因为<code>wait()</code>方法调用时，会<em>释放</em>线程获得的锁，<code>wait()</code>方法返回时，线程又会重新试图获得锁。</p><p>因此，只能在锁对象上调用<code>wait()</code>方法。因为在<code>getTask()</code>中，我们获得了<code>this</code>锁，因此，只能在<code>this</code>对象上调用<code>wait()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 释放this锁:</span></span><br><span class="line">        <span class="built_in">this</span>.wait();</span><br><span class="line">        <span class="comment">// 重新获取this锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个线程在<code>this.wait()</code>等待时，它就会释放<code>this</code>锁，从而使得其他线程能够在<code>addTask()</code>方法获得<code>this</code>锁。</p><p>现在我们面临第二个问题：如何让等待的线程被重新唤醒，然后从<code>wait()</code>方法返回？答案是在相同的锁对象上调用<code>notify()</code>方法。我们修改<code>addTask()</code>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.queue.add(s);</span><br><span class="line">    <span class="built_in">this</span>.notify(); <span class="comment">// 唤醒在this锁等待的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到在往队列中添加了任务后，线程立刻对<code>this</code>锁对象调用<code>notify()</code>方法，这个方法会唤醒一个正在<code>this</code>锁等待的线程（就是在<code>getTask()</code>中位于<code>this.wait()</code>的线程），从而使得等待线程从<code>this.wait()</code>方法返回。</p><p>我们来看一个完整的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">q</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskQueue</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行task:</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> q.getTask();</span><br><span class="line">                            System.out.println(<span class="string">&quot;execute task: &quot;</span> + s);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            ts.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">var</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 放入task:</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;t-&quot;</span> + Math.random();</span><br><span class="line">                System.out.println(<span class="string">&quot;add task: &quot;</span> + s);</span><br><span class="line">                q.addTask(s);</span><br><span class="line">                <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        add.start();</span><br><span class="line">        add.join();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t : ts) &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue.add(s);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，我们重点关注<code>addTask()</code>方法，内部调用了<code>this.notifyAll()</code>而不是<code>this.notify()</code>，使用<code>notifyAll()</code>将唤醒所有当前正在<code>this</code>锁等待的线程，而<code>notify()</code>只会唤醒其中一个（具体哪个依赖操作系统，有一定的随机性）。这是因为可能有多个线程正在<code>getTask()</code>方法内部的<code>wait()</code>中等待，使用<code>notifyAll()</code>将一次性全部唤醒。通常来说，<code>notifyAll()</code>更安全。有些时候，如果我们的代码逻辑考虑不周，用<code>notify()</code>会导致只唤醒了一个线程，而其他线程可能永远等待下去醒不过来了。</p><p>但是，注意到<code>wait()</code>方法返回时需要<em>重新</em>获得<code>this</code>锁。假设当前有3个线程被唤醒，唤醒后，首先要等待执行<code>addTask()</code>的线程结束此方法后，才能释放<code>this</code>锁，随后，这3个线程中只能有一个获取到<code>this</code>锁，剩下两个将继续等待。</p><p>再注意到我们在<code>while()</code>循环中调用<code>wait()</code>，而不是<code>if</code>语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法实际上是错误的，因为线程被唤醒时，需要再次获取<code>this</code>锁。多个线程被唤醒后，只有一个线程能获取<code>this</code>锁，此刻，该线程执行<code>queue.remove()</code>可以获取到队列的元素，然而，剩下的线程如果获取<code>this</code>锁后执行<code>queue.remove()</code>，此刻队列可能已经没有任何元素了，所以，要始终在<code>while</code>循环中<code>wait()</code>，并且每次被唤醒后拿到<code>this</code>锁就必须再次判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">    <span class="built_in">this</span>.wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，正确编写多线程代码是非常困难的，需要仔细考虑的条件非常多，任何一个地方考虑不周，都会导致多线程运行时不正常。</p><p><img src="https://liaoxuefeng.com/books/java/threading/synchronize/wait-notify/painful.jpg" alt="multithread"></p><h3 id="小结-4">小结</h3><p><code>wait</code>和<code>notify</code>用于多线程协调运行：</p><ul><li>在<code>synchronized</code>内部可以调用<code>wait()</code>使线程进入等待状态；</li><li>必须在已获得的锁对象上调用<code>wait()</code>方法；</li><li>在<code>synchronized</code>内部可以调用<code>notify()</code>或<code>notifyAll()</code>唤醒其他等待线程；</li><li>必须在已获得的锁对象上调用<code>notify()</code>或<code>notifyAll()</code>方法；</li><li>已唤醒的线程还需要重新获得锁后才能继续执行。</li></ul><h2 id="使用ReentrantLock">使用ReentrantLock</h2><p>从Java 5开始，引入了一个高级的处理并发的<code>java.util.concurrent</code>包，它提供了大量更高级的并发功能，能大大简化多线程程序的编写。</p><p>我们知道Java语言直接提供了<code>synchronized</code>关键字用于加锁，但这种锁一是很重，二是获取时必须一直等待，没有额外的尝试机制。</p><p><code>java.util.concurrent.locks</code>包提供的<code>ReentrantLock</code>用于替代<code>synchronized</code>加锁，我们来看一下传统的<code>synchronized</code>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用<code>ReentrantLock</code>替代，可以把代码改造为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>synchronized</code>是Java语言层面提供的语法，所以我们不需要考虑异常，而<code>ReentrantLock</code>是Java代码实现的锁，我们就必须先获取锁，然后在<code>finally</code>中正确释放锁。</p><p>顾名思义，<code>ReentrantLock</code>是可重入锁，它和<code>synchronized</code>一样，一个线程可以多次获取同一个锁。</p><p>和<code>synchronized</code>不同的是，<code>ReentrantLock</code>可以尝试获取锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，<code>tryLock()</code>返回<code>false</code>，程序就可以做一些额外处理，而不是无限等待下去。</p><p>所以，使用<code>ReentrantLock</code>比直接使用<code>synchronized</code>更安全，线程在<code>tryLock()</code>失败的时候不会导致死锁。</p><h3 id="小结-5">小结</h3><p><code>ReentrantLock</code>可以替代<code>synchronized</code>进行同步；</p><p><code>ReentrantLock</code>获取锁更安全；</p><p>必须先获取到锁，再进入<code>try &#123;...&#125;</code>代码块，最后使用<code>finally</code>保证释放锁；</p><p>可以使用<code>tryLock()</code>尝试获取锁。</p><hr><hr><h2 id="使用Condition">使用Condition</h2><p>使用<code>ReentrantLock</code>比直接使用<code>synchronized</code>更安全，可以替代<code>synchronized</code>进行线程同步。</p><p>但是，<code>synchronized</code>可以配合<code>wait</code>和<code>notify</code>实现线程在条件不满足时等待，条件满足时唤醒，用<code>ReentrantLock</code>我们怎么编写<code>wait</code>和<code>notify</code>的功能呢？</p><p>答案是使用<code>Condition</code>对象来实现<code>wait</code>和<code>notify</code>的功能。</p><p>我们仍然以<code>TaskQueue</code>为例，把前面用<code>synchronized</code>实现的功能通过<code>ReentrantLock</code>和<code>Condition</code>来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.remove();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，使用<code>Condition</code>时，引用的<code>Condition</code>对象必须从<code>Lock</code>实例的<code>newCondition()</code>返回，这样才能获得一个绑定了<code>Lock</code>实例的<code>Condition</code>实例。</p><p><code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和<code>synchronized</code>锁对象的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的，并且其行为也是一样的：</p><ul><li><code>await()</code>会释放当前锁，进入等待状态；</li><li><code>signal()</code>会唤醒某个等待线程；</li><li><code>signalAll()</code>会唤醒所有等待线程；</li><li>唤醒线程从<code>await()</code>返回后需要重新获得锁。</li></ul><p>此外，和<code>tryLock()</code>类似，<code>await()</code>可以在等待指定时间后，如果还没有被其他线程通过<code>signal()</code>或<code>signalAll()</code>唤醒，可以自己醒来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition.await(<span class="number">1</span>, TimeUnit.SECOND)) &#123;</span><br><span class="line">    <span class="comment">// 被其他线程唤醒</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 指定时间内没有被其他线程唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，使用<code>Condition</code>配合<code>Lock</code>，我们可以实现更灵活的线程同步。</p><h3 id="小结-6">小结</h3><p><code>Condition</code>可以替代<code>wait</code>和<code>notify</code>；</p><p><code>Condition</code>对象必须从<code>Lock</code>对象获取。</p><hr><hr><h2 id="使用ReadWriteLock">使用ReadWriteLock</h2><p>前面讲到的<code>ReentrantLock</code>保证了只有一个线程可以执行临界区代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inc</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] get() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有些时候，这种保护有点过头。因为我们发现，任何时刻，只允许一个线程修改，也就是调用<code>inc()</code>方法是必须获取锁，但是，<code>get()</code>方法只读取数据，不修改数据，它实际上允许多个线程同时调用。</p><p>实际上我们想要的是：允许多个线程同时读，但只要有一个线程在写，其他线程就必须等待：</p><table><thead><tr><th></th><th>读</th><th>写</th></tr></thead><tbody><tr><td>读</td><td>允许</td><td>不允许</td></tr><tr><td>写</td><td>不允许</td><td>不允许</td></tr></tbody></table><p>使用<code>ReadWriteLock</code>可以解决这个问题，它保证：</p><ul><li>只允许一个线程写入（其他线程既不能写入也不能读取）；</li><li>没有写入时，多个线程允许同时读（提高性能）。</li></ul><p>用<code>ReadWriteLock</code>实现这个功能十分容易。我们需要创建一个<code>ReadWriteLock</code>实例，然后分别获取读锁和写锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">// 注意: 一对读锁和写锁必须从同一个rwlock获取:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">rlock</span> <span class="operator">=</span> rwlock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">wlock</span> <span class="operator">=</span> rwlock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inc</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        wlock.lock(); <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            wlock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] get() &#123;</span><br><span class="line">        rlock.lock(); <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rlock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把读写操作分别用读锁和写锁来加锁，在读取时，多个线程可以同时获得读锁，这样就大大提高了并发读的执行效率。</p><p>使用<code>ReadWriteLock</code>时，适用条件是同一个数据，有大量线程读取，但仅有少数线程修改。</p><p>例如，一个论坛的帖子，回复可以看做写入操作，它是不频繁的，但是，浏览可以看做读取操作，是非常频繁的，这种情况就可以使用<code>ReadWriteLock</code>。</p><h3 id="小结-7">小结</h3><p>使用<code>ReadWriteLock</code>可以提高读取效率：</p><ul><li><code>ReadWriteLock</code>只允许一个线程写入；</li><li><code>ReadWriteLock</code>允许多个线程在没有写入时同时读取；</li><li><code>ReadWriteLock</code>适合读多写少的场景。</li></ul><hr><hr><p>前面介绍的<code>ReadWriteLock</code>可以解决多线程同时读，但只有一个线程能写的问题。</p><p>如果我们深入分析<code>ReadWriteLock</code>，会发现它有个潜在的问题：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。</p><p>要进一步提升并发执行效率，Java 8引入了新的读写锁：<code>StampedLock</code>。</p><p><code>StampedLock</code>和<code>ReadWriteLock</code>相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。</p><p>乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</p><p>我们来看例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">stampedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">double</span> deltaX, <span class="type">double</span> deltaY)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.writeLock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distanceFromOrigin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.tryOptimisticRead(); <span class="comment">// 获得一个乐观读锁</span></span><br><span class="line">        <span class="comment">// 注意下面两行代码不是原子操作</span></span><br><span class="line">        <span class="comment">// 假设x,y = (100,200)</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">currentX</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="comment">// 此处已读取到x=100，但x,y可能被写线程修改为(300,400)</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">currentY</span> <span class="operator">=</span> y;</span><br><span class="line">        <span class="comment">// 此处已读取到y，如果没有写入，读取是正确的(100,200)</span></span><br><span class="line">        <span class="comment">// 如果有写入，读取是错误的(100,400)</span></span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123; <span class="comment">// 检查乐观读锁后是否有其他写锁发生</span></span><br><span class="line">            stamp = stampedLock.readLock(); <span class="comment">// 获取一个悲观读锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和<code>ReadWriteLock</code>相比，写入的加锁是完全一样的，不同的是读取。注意到首先我们通过<code>tryOptimisticRead()</code>获取一个乐观读锁，并返回版本号。接着进行读取，读取完成后，我们通过<code>validate()</code>去验证版本号，如果在读取过程中没有写入，版本号不变，验证成功，我们就可以放心地继续后续操作。如果在读取过程中有写入，版本号会发生变化，验证将失败。在失败的时候，我们再通过获取悲观读锁再次读取。由于写入的概率不高，程序在绝大部分情况下可以通过乐观读锁获取数据，极少数情况下使用悲观读锁获取数据。</p><p>可见，<code>StampedLock</code>把读锁细分为乐观读和悲观读，能进一步提升并发效率。但这也是有代价的：一是代码更加复杂，二是<code>StampedLock</code>是不可重入锁，不能在一个线程中反复获取同一个锁。</p><p><code>StampedLock</code>还提供了更复杂的将悲观读锁升级为写锁的功能，它主要使用在if-then-update的场景：即先读，如果读的数据满足条件，就返回，如果读的数据不满足条件，再尝试写。</p><h3 id="小结-8">小结</h3><p><code>StampedLock</code>提供了乐观读锁，可取代<code>ReadWriteLock</code>以进一步提升并发性能；</p><p><code>StampedLock</code>是不可重入锁。</p><h2 id="使用Semaphore">使用Semaphore</h2><p>前面我们讲了各种锁的实现，本质上锁的目的是保护一种受限资源，保证同一时刻只有一个线程能访问（ReentrantLock），或者只有一个线程能写入（ReadWriteLock）。</p><p>还有一种受限资源，它需要保证同一时刻最多有N个线程能访问，比如同一时刻最多创建100个数据库连接，最多允许10个用户下载等。</p><p>这种限制数量的锁，如果用Lock数组来实现，就太麻烦了。</p><p>这种情况就可以使用<code>Semaphore</code>，例如，最多允许3个线程同时访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessLimitControl</span> &#123;</span><br><span class="line">    <span class="comment">// 任意时刻仅允许最多3个线程获取许可:</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">access</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 如果超过了许可数量,其他线程将在此等待:</span></span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">            <span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>Semaphore</code>先调用<code>acquire()</code>获取，然后通过<code>try ... finally</code>保证在<code>finally</code>中释放。</p><p>调用<code>acquire()</code>可能会进入等待，直到满足条件为止。也可以使用<code>tryAcquire()</code>指定等待时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (semaphore.tryAcquire(<span class="number">3</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="comment">// 指定等待时间3秒内获取到许可:</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        semaphore.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Semaphore</code>本质上就是一个信号计数器，用于限制同一时间的最大访问数量。</p><h3 id="小结-9">小结</h3><p>如果要对某一受限资源进行限流访问，可以使用<code>Semaphore</code>，保证同一时间最多N个线程访问受限资源。</p><hr><hr><h2 id="使用Concurrent集合">使用Concurrent集合</h2><p>我们在前面已经通过<code>ReentrantLock</code>和<code>Condition</code>实现了一个<code>BlockingQueue</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.remove();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BlockingQueue</code>的意思就是说，当一个线程调用这个<code>TaskQueue</code>的<code>getTask()</code>方法时，该方法内部可能会让线程变成等待状态，直到队列条件满足不为空，线程被唤醒后，<code>getTask()</code>方法才会返回。</p><p>因为<code>BlockingQueue</code>非常有用，所以我们不必自己编写，可以直接使用Java标准库的<code>java.util.concurrent</code>包提供的线程安全的集合：<code>ArrayBlockingQueue</code>。</p><p>除了<code>BlockingQueue</code>外，针对<code>List</code>、<code>Map</code>、<code>Set</code>、<code>Deque</code>等，<code>java.util.concurrent</code>包也提供了对应的并发集合类。我们归纳一下：</p><table><thead><tr><th>interface</th><th>non-thread-safe</th><th>thread-safe</th></tr></thead><tbody><tr><td>List</td><td>ArrayList</td><td>CopyOnWriteArrayList</td></tr><tr><td>Map</td><td>HashMap</td><td>ConcurrentHashMap</td></tr><tr><td>Set</td><td>HashSet / TreeSet</td><td>CopyOnWriteArraySet</td></tr><tr><td>Queue</td><td>ArrayDeque / LinkedList</td><td>ArrayBlockingQueue / LinkedBlockingQueue</td></tr><tr><td>Deque</td><td>ArrayDeque / LinkedList</td><td>LinkedBlockingDeque</td></tr></tbody></table><p>使用这些并发集合与使用非线程安全的集合类完全相同。我们以<code>ConcurrentHashMap</code>为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 在不同的线程读写:</span></span><br><span class="line">map.put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">map.get(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure><p>因为所有的同步和加锁的逻辑都在集合内部实现，对外部调用者来说，只需要正常按接口引用，其他代码和原来的非线程安全代码完全一样。即当我们需要多线程访问时，把：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>就可以了。</p><p><code>java.util.Collections</code>工具类还提供了一个旧的线程安全集合转换器，可以这么用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">unsafeMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">threadSafeMap</span> <span class="operator">=</span> Collections.synchronizedMap(unsafeMap);</span><br></pre></td></tr></table></figure><p>但是它实际上是用一个包装类包装了非线程安全的<code>Map</code>，然后对所有读写方法都用<code>synchronized</code>加锁，这样获得的线程安全集合的性能比<code>java.util.concurrent</code>集合要低很多，所以不推荐使用。</p><h3 id="小结-10">小结</h3><p>使用<code>java.util.concurrent</code>包提供的线程安全的并发集合可以大大简化多线程编程：</p><p>多线程同时读写并发集合是安全的；</p><p>尽量使用Java标准库提供的并发集合，避免自己编写同步代码。</p><hr><hr><h2 id="使用Atomic">使用Atomic</h2><p>Java的<code>java.util.concurrent</code>包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于<code>java.util.concurrent.atomic</code>包。</p><p>我们以<code>AtomicInteger</code>为例，它提供的主要操作有：</p><ul><li>增加值并返回新值：<code>int addAndGet(int delta)</code></li><li>加1后返回新值：<code>int incrementAndGet()</code></li><li>获取当前值：<code>int get()</code></li><li>用CAS方式设置：<code>int compareAndSet(int expect, int update)</code></li></ul><p>Atomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了CAS：Compare and Set。</p><p>如果我们自己通过CAS编写<code>incrementAndGet()</code>，它大概长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">(AtomicInteger <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = <span class="keyword">var</span>.get();</span><br><span class="line">        next = prev + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( ! <span class="keyword">var</span>.compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CAS是指，在这个操作中，如果<code>AtomicInteger</code>的当前值是<code>prev</code>，那么就更新为<code>next</code>，返回<code>true</code>。如果<code>AtomicInteger</code>的当前值不是<code>prev</code>，就什么也不干，返回<code>false</code>。通过CAS操作并配合<code>do ... while</code>循环，即使其他线程修改了<code>AtomicInteger</code>的值，最终的结果也是正确的。</p><p>我们利用<code>AtomicLong</code>可以编写一个多线程安全的全局唯一ID生成器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">    <span class="type">AtomicLong</span> <span class="variable">var</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getNextId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span>.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，我们并不需要直接用<code>do ... while</code>循环调用<code>compareAndSet</code>实现复杂的并发操作，而是用<code>incrementAndGet()</code>这样的封装好的方法，因此，使用起来非常简单。</p><p>在高度竞争的情况下，还可以使用Java 8提供的<code>LongAdder</code>和<code>LongAccumulator</code>。</p><h3 id="小结-11">小结</h3><p>使用<code>java.util.concurrent.atomic</code>提供的原子操作可以简化多线程编程：</p><ul><li>原子操作实现了无锁的线程安全；</li><li>适用于计数器，累加器等。</li></ul><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-多线程3</title>
      <link href="/2025/05/24/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B3/"/>
      <url>/2025/05/24/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B3/</url>
      
        <content type="html"><![CDATA[<p>Java语言虽然内置了多线程支持，启动一个新线程非常方便，但是，创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。</p><p>如果可以复用一组线程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌─────┐ execute  ┌──────────────────┐</span><br><span class="line">│Task1│─────────▶│ThreadPool        │</span><br><span class="line">├─────┤          │┌───────┐┌───────┐│</span><br><span class="line">│Task2│          ││Thread1││Thread2││</span><br><span class="line">├─────┤          │└───────┘└───────┘│</span><br><span class="line">│Task3│          │┌───────┐┌───────┐│</span><br><span class="line">├─────┤          ││Thread3││Thread4││</span><br><span class="line">│Task4│          │└───────┘└───────┘│</span><br><span class="line">├─────┤          └──────────────────┘</span><br><span class="line">│Task5│</span><br><span class="line">├─────┤</span><br><span class="line">│Task6│</span><br><span class="line">└─────┘</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>那么我们就可以把很多小任务让一组线程来执行，而不是一个任务对应一个新线程。这种能接收大量小任务并进行分发处理的就是线程池。</p><p>简单地说，线程池内部维护了若干个线程，没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。</p><p>Java标准库提供了<code>ExecutorService</code>接口表示线程池，它的典型用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建固定大小的线程池:</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 提交任务:</span></span><br><span class="line">executor.submit(task1);</span><br><span class="line">executor.submit(task2);</span><br><span class="line">executor.submit(task3);</span><br><span class="line">executor.submit(task4);</span><br><span class="line">executor.submit(task5);</span><br></pre></td></tr></table></figure><p>因为<code>ExecutorService</code>只是接口，Java标准库提供的几个常用实现类有：</p><ul><li>FixedThreadPool：线程数固定的线程池；</li><li>CachedThreadPool：线程数根据任务动态调整的线程池；</li><li>SingleThreadExecutor：仅单线程执行的线程池。</li></ul><p>创建这些线程池的方法都被封装到<code>Executors</code>这个类中。我们以<code>FixedThreadPool</code>为例，看看线程池的执行逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread-pool</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池:</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池:</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start task &quot;</span> + name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end task &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们观察执行结果，一次性放入6个任务，由于线程池只有固定的4个线程，因此，前4个任务会同时执行，等到有线程空闲后，才会执行后面的两个任务。</p><p>线程池在程序结束的时候要关闭。使用<code>shutdown()</code>方法关闭线程池的时候，它会等待正在执行的任务先完成，然后再关闭。<code>shutdownNow()</code>会立刻停止正在执行的任务，<code>awaitTermination()</code>则会等待指定的时间让线程池关闭。</p><p>如果我们把线程池改为<code>CachedThreadPool</code>，由于这个线程池的实现会根据任务数量动态调整线程池的大小，所以6个任务可一次性全部同时执行。</p><p>如果我们想把线程池的大小限制在4～10个之间动态调整怎么办？我们查看<code>Executors.newCachedThreadPool()</code>方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">            <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，想创建指定动态范围的线程池，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">        min, max,</span><br><span class="line">        <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure><h3 id="ScheduledThreadPool">ScheduledThreadPool</h3><p>还有一种任务，需要定期反复执行，例如，每秒刷新证券价格。这种任务本身固定，需要反复执行的，可以使用<code>ScheduledThreadPool</code>。放入<code>ScheduledThreadPool</code>的任务可以定期反复执行。</p><p>创建一个<code>ScheduledThreadPool</code>仍然是通过<code>Executors</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">ses</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>我们可以提交一次性任务，它会在指定延迟后只执行一次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1秒后执行一次性任务:</span></span><br><span class="line">ses.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;one-time&quot;</span>), <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>如果任务以固定的每3秒执行，我们可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2秒后开始执行定时任务，每3秒执行:</span></span><br><span class="line">ses.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;fixed-rate&quot;</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>如果任务以固定的3秒为间隔执行，我们可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2秒后开始执行定时任务，以3秒为间隔执行:</span></span><br><span class="line">ses.scheduleWithFixedDelay(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;fixed-delay&quot;</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>注意FixedRate和FixedDelay的区别。FixedRate是指任务总是以固定时间间隔触发，不管任务执行多长时间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">│░░░░   │░░░░░░ │░░░    │░░░░░  │░░░  </span><br><span class="line">├───────┼───────┼───────┼───────┼────▶</span><br><span class="line">│◀─────▶│◀─────▶│◀─────▶│◀─────▶│</span><br></pre></td></tr></table></figure><p>而FixedDelay是指，上一次任务执行完毕后，等待固定的时间间隔，再执行下一次任务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">│░░░│       │░░░░░│       │░░│       │░</span><br><span class="line">└───┼───────┼─────┼───────┼──┼───────┼──▶</span><br><span class="line">    │◀─────▶│     │◀─────▶│  │◀─────▶│</span><br></pre></td></tr></table></figure><p>因此，使用<code>ScheduledThreadPool</code>时，我们要根据需要选择执行一次、FixedRate执行还是FixedDelay执行。</p><p>细心的童鞋还可以思考下面的问题：</p><ul><li>在FixedRate模式下，假设每秒触发，如果某次任务执行时间超过1秒，后续任务会不会并发执行？</li><li>如果任务抛出了异常，后续任务是否继续执行？</li></ul><p>Java标准库还提供了一个<code>java.util.Timer</code>类，这个类也可以定期执行任务，但是，一个<code>Timer</code>会对应一个<code>Thread</code>，所以，一个<code>Timer</code>只能定期执行一个任务，多个定时任务必须启动多个<code>Timer</code>，而一个<code>ScheduledThreadPool</code>就可以调度多个定时任务，所以，我们完全可以用<code>ScheduledThreadPool</code>取代旧的<code>Timer</code>。</p><h3 id="练习">练习</h3><p>使用线程池复用线程。</p><p><a href="https://liaoxuefeng.com/books/java/threading/pool/thread-pool.zip">下载练习</a></p><h3 id="小结">小结</h3><p>JDK提供了<code>ExecutorService</code>实现了线程池功能：</p><ul><li>线程池内部维护一组线程，可以高效执行大量小任务；</li><li><code>Executors</code>提供了静态方法创建不同类型的<code>ExecutorService</code>；</li><li>必须调用<code>shutdown()</code>关闭<code>ExecutorService</code>；</li><li><code>ScheduledThreadPool</code>可以定期调度多个任务。</li></ul><h2 id="使用Future">使用Future</h2><p>在执行多个任务的时候，使用Java标准库提供的线程池是非常方便的。我们提交的任务只需要实现<code>Runnable</code>接口，就可以让线程池去执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.result = longTimeCalculation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Runnable</code>接口有个问题，它的方法没有返回值。如果任务需要一个返回结果，那么只能保存到变量，还要提供额外的方法读取，非常不便。所以，Java标准库还提供了一个<code>Callable</code>接口，和<code>Runnable</code>接口比，它多了一个返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> longTimeCalculation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且<code>Callable</code>接口是一个泛型接口，可以返回指定类型的结果。</p><p>现在的问题是，如何获得异步执行的结果？</p><p>如果仔细看<code>ExecutorService.submit()</code>方法，可以看到，它返回了一个<code>Future</code>类型，一个<code>Future</code>类型的实例代表一个未来能获取结果的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>); </span><br><span class="line"><span class="comment">// 定义任务:</span></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line"><span class="comment">// 提交任务并获得Future:</span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(task);</span><br><span class="line"><span class="comment">// 从Future获取异步执行返回的结果:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 可能阻塞</span></span><br></pre></td></tr></table></figure><p>当我们提交一个<code>Callable</code>任务后，我们会同时获得一个<code>Future</code>对象，然后，我们在主线程某个时刻调用<code>Future</code>对象的<code>get()</code>方法，就可以获得异步执行的结果。在调用<code>get()</code>时，如果异步任务已经完成，我们就直接获得结果。如果异步任务还没有完成，那么<code>get()</code>会阻塞，直到任务完成后才返回结果。</p><p>一个<code>Future&lt;V&gt;</code>接口表示一个未来可能会返回的结果，它定义的方法有：</p><ul><li><code>get()</code>：获取结果（可能会等待）</li><li><code>get(long timeout, TimeUnit unit)</code>：获取结果，但只等待指定的时间；</li><li><code>cancel(boolean mayInterruptIfRunning)</code>：取消当前任务；</li><li><code>isDone()</code>：判断任务是否已完成。</li></ul><h3 id="练习-2">练习</h3><p>使用Future获取异步执行结果。</p><p><a href="https://liaoxuefeng.com/books/java/threading/future/thread-future.zip">下载练习</a></p><h3 id="小结-2">小结</h3><p>对线程池提交一个<code>Callable</code>任务，可以获得一个<code>Future</code>对象；</p><p>可以用<code>Future</code>在将来某个时刻获取结果。</p><hr><hr><p>使用<code>Future</code>获得异步执行结果时，要么调用阻塞方法<code>get()</code>，要么轮询看<code>isDone()</code>是否为<code>true</code>，这两种方法都不是很好，因为主线程也会被迫等待。</p><p>从Java 8开始引入了<code>CompletableFuture</code>，它针对<code>Future</code>做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p><p>我们以获取股票价格为例，看看如何使用<code>CompletableFuture</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CompletableFuture</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建异步执行任务:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(Main::fetchPrice);</span><br><span class="line">        <span class="comment">// 如果执行成功:</span></span><br><span class="line">        cf.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 如果执行异常:</span></span><br><span class="line">        cf.exceptionally((e) -&gt; &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Double <span class="title function_">fetchPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;fetch price failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个<code>CompletableFuture</code>是通过<code>CompletableFuture.supplyAsync()</code>实现的，它需要一个实现了<code>Supplier</code>接口的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们用lambda语法简化了一下，直接传入<code>Main::fetchPrice</code>，因为<code>Main.fetchPrice()</code>静态方法的签名符合<code>Supplier</code>接口的定义（除了方法名外）。</p><p>紧接着，<code>CompletableFuture</code>已经被提交给默认的线程池执行了，我们需要定义的是<code>CompletableFuture</code>完成时和异常时需要回调的实例。完成时，<code>CompletableFuture</code>会调用<code>Consumer</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常时，<code>CompletableFuture</code>会调用<code>Function</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们都用lambda语法简化了代码。</p><p>可见<code>CompletableFuture</code>的优点是：</p><ul><li>异步任务结束时，会自动回调某个对象的方法；</li><li>异步任务出错时，会自动回调某个对象的方法；</li><li>主线程设置好回调后，不再关心异步任务的执行。</li></ul><p>如果只是实现了异步回调机制，我们还看不出<code>CompletableFuture</code>相比<code>Future</code>的优势。<code>CompletableFuture</code>更强大的功能是，多个<code>CompletableFuture</code>可以串行执行，例如，定义两个<code>CompletableFuture</code>，第一个<code>CompletableFuture</code>根据证券名称查询证券代码，第二个<code>CompletableFuture</code>根据证券代码查询证券价格，这两个<code>CompletableFuture</code>实现串行操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CompletableFuture</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 第一个任务:</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cfQuery = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// cfQuery成功后继续执行下一个任务:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetch = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice(code);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// cfFetch成功后打印结果:</span></span><br><span class="line">        cfFetch.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">queryCode</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;601857&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Double <span class="title function_">fetchPrice</span><span class="params">(String code)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了串行执行外，多个<code>CompletableFuture</code>还可以并行执行。例如，我们考虑这样的场景：</p><p>同时从新浪和网易查询证券代码，只要任意一个返回结果，就进行下一步查询价格，查询价格也同时从新浪和网易查询，只要任意一个返回结果，就完成操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CompletableFuture</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 两个CompletableFuture执行异步查询:</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cfQueryFromSina = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>, <span class="string">&quot;https://finance.sina.com.cn/code/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; cfQueryFrom163 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>, <span class="string">&quot;https://money.163.com/code/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用anyOf合并为一个新的CompletableFuture:</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; cfQuery = CompletableFuture.anyOf(cfQueryFromSina, cfQueryFrom163);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个CompletableFuture执行异步查询:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFromSina = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">&quot;https://finance.sina.com.cn/price/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFrom163 = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">&quot;https://money.163.com/price/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用anyOf合并为一个新的CompletableFuture:</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; cfFetch = CompletableFuture.anyOf(cfFetchFromSina, cfFetchFrom163);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终结果:</span></span><br><span class="line">        cfFetch.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">queryCode</span><span class="params">(String name, String url)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;query code from &quot;</span> + url + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;601857&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Double <span class="title function_">fetchPrice</span><span class="params">(String code, String url)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;query price from &quot;</span> + url + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述逻辑实现的异步查询规则实际上是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐ ┌─────────────┐</span><br><span class="line">│ Query Code  │ │ Query Code  │</span><br><span class="line">│  from sina  │ │  from 163   │</span><br><span class="line">└─────────────┘ └─────────────┘</span><br><span class="line">       │               │</span><br><span class="line">       └───────┬───────┘</span><br><span class="line">               ▼</span><br><span class="line">        ┌─────────────┐</span><br><span class="line">        │    anyOf    │</span><br><span class="line">        └─────────────┘</span><br><span class="line">               │</span><br><span class="line">       ┌───────┴────────┐</span><br><span class="line">       ▼                ▼</span><br><span class="line">┌─────────────┐  ┌─────────────┐</span><br><span class="line">│ Query Price │  │ Query Price │</span><br><span class="line">│  from sina  │  │  from 163   │</span><br><span class="line">└─────────────┘  └─────────────┘</span><br><span class="line">       │                │</span><br><span class="line">       └────────┬───────┘</span><br><span class="line">                ▼</span><br><span class="line">         ┌─────────────┐</span><br><span class="line">         │    anyOf    │</span><br><span class="line">         └─────────────┘</span><br><span class="line">                │</span><br><span class="line">                ▼</span><br><span class="line">         ┌─────────────┐</span><br><span class="line">         │Display Price│</span><br><span class="line">         └─────────────┘</span><br></pre></td></tr></table></figure><p>除了<code>anyOf()</code>可以实现“任意个<code>CompletableFuture</code>只要一个成功”，<code>allOf()</code>可以实现“所有<code>CompletableFuture</code>都必须成功”，这些组合操作可以实现非常复杂的异步流程控制。</p><p>最后我们注意<code>CompletableFuture</code>的命名规则：</p><ul><li><code>xxx()</code>：表示该方法将继续在已有的线程中执行；</li><li><code>xxxAsync()</code>：表示将异步在线程池中执行。</li></ul><h3 id="练习-3">练习</h3><p>使用CompletableFuture。</p><p><a href="https://liaoxuefeng.com/books/java/threading/completable-future/thread-completablefuture.zip">下载练习</a></p><h3 id="小结-3">小结</h3><p><code>CompletableFuture</code>可以指定异步处理流程：</p><ul><li><code>thenAccept()</code>处理正常结果；</li><li><code>exceptional()</code>处理异常结果；</li><li><code>thenApplyAsync()</code>用于串行化另一个<code>CompletableFuture</code>；</li><li><code>anyOf()</code>和<code>allOf()</code>用于并行化多个<code>CompletableFuture</code>。</li></ul><p>Java 7开始引入了一种新的Fork/Join线程池，它可以执行一种特殊的任务：把一个大任务拆成多个小任务并行执行。</p><p>我们举个例子：如果要计算一个超大数组的和，最简单的做法是用一个循环在一个线程内完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br></pre></td></tr></table></figure><p>还有一种方法，可以把数组拆成两部分，分别计算，最后加起来就是最终结果，这样可以用两个线程并行执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br></pre></td></tr></table></figure><p>如果拆成两部分还是很大，我们还可以继续拆，用4个线程并行执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┘</span><br></pre></td></tr></table></figure><p>这就是Fork/Join任务的原理：判断一个任务是否足够小，如果是，直接计算，否则，就分拆成几个小任务分别计算。这个过程可以反复“裂变”成一系列小任务。</p><p>我们来看如何使用Fork/Join对大数据进行并行求和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建2000个随机数组成的数组:</span></span><br><span class="line">        <span class="type">long</span>[] array = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">2000</span>];</span><br><span class="line">        <span class="type">long</span> <span class="variable">expectedSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = random();</span><br><span class="line">            expectedSum += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Expected sum: &quot;</span> + expectedSum);</span><br><span class="line">        <span class="comment">// fork/join:</span></span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, <span class="number">0</span>, array.length);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> ForkJoinPool.commonPool().invoke(task);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Fork/join sum: &quot;</span> + result + <span class="string">&quot; in &quot;</span> + (endTime - startTime) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">random</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SumTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="type">long</span>[] array;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    SumTask(<span class="type">long</span>[] array, <span class="type">int</span> start, <span class="type">int</span> end) &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// 如果任务足够小,直接计算:</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += <span class="built_in">this</span>.array[i];</span><br><span class="line">                <span class="comment">// 故意放慢计算速度:</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任务太大,一分为二:</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (end + start) / <span class="number">2</span>;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;split %d~%d ==&gt; %d~%d, %d~%d&quot;</span>, start, end, start, middle, middle, end));</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">subtask1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(<span class="built_in">this</span>.array, start, middle);</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">subtask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(<span class="built_in">this</span>.array, middle, end);</span><br><span class="line">        invokeAll(subtask1, subtask2);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">subresult1</span> <span class="operator">=</span> subtask1.join();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">subresult2</span> <span class="operator">=</span> subtask2.join();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> subresult1 + subresult2;</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + subresult1 + <span class="string">&quot; + &quot;</span> + subresult2 + <span class="string">&quot; ==&gt; &quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上述代码的执行过程，一个大的计算任务0~2000首先分裂为两个小任务0~1000和1000~2000，这两个小任务仍然太大，继续分裂为更小的0~500，500~1000，1000~1500，1500~2000，最后，计算结果被依次合并，得到最终结果。</p><p>因此，核心代码<code>SumTask</code>继承自<code>RecursiveTask</code>，在<code>compute()</code>方法中，关键是如何“分裂”出子任务并且提交子任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SumTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// “分裂”子任务:</span></span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">subtask1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(...);</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">subtask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(...);</span><br><span class="line">        <span class="comment">// invokeAll会并行运行两个子任务:</span></span><br><span class="line">        invokeAll(subtask1, subtask2);</span><br><span class="line">        <span class="comment">// 获得子任务的结果:</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">subresult1</span> <span class="operator">=</span> subtask1.join();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">subresult2</span> <span class="operator">=</span> subtask2.join();</span><br><span class="line">        <span class="comment">// 汇总结果:</span></span><br><span class="line">        <span class="keyword">return</span> subresult1 + subresult2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Fork/Join线程池在Java标准库中就有应用。Java标准库提供的<code>java.util.Arrays.parallelSort(array)</code>可以进行并行排序，它的原理就是内部通过Fork/Join对大数组分拆进行并行排序，在多核CPU上就可以大大提高排序的速度。</p><h3 id="练习-4">练习</h3><p>使用Fork/Join。</p><p><a href="https://liaoxuefeng.com/books/java/threading/fork-join/thread-forkjoin.zip">下载练习</a></p><h3 id="小结-4">小结</h3><p>Fork/Join是一种基于“分治”的算法：通过分解任务，并行执行，最后合并结果得到最终结果。</p><p><code>ForkJoinPool</code>线程池可以把一个大任务分拆成小任务并行执行，任务类必须继承自<code>RecursiveTask</code>或<code>RecursiveAction</code>。</p><p>使用Fork/Join模式可以进行并行计算以提高效率。</p><p>多线程是Java实现多任务的基础，<code>Thread</code>对象代表一个线程，我们可以在代码中调用<code>Thread.currentThread()</code>获取当前线程。例如，打印日志时，可以同时打印出当前线程的名字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log(<span class="string">&quot;start main...&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log(<span class="string">&quot;run task...&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log(<span class="string">&quot;print...&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        log(<span class="string">&quot;end main.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于多任务，Java标准库提供的线程池可以方便地执行这些任务，同时复用线程。Web应用程序就是典型的多任务应用，每个用户请求页面时，我们都会创建一个任务，类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    checkPermission();</span><br><span class="line">    doWork();</span><br><span class="line">    saveStatus();</span><br><span class="line">    sendResponse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，通过线程池去执行这些任务。</p><p>观察<code>process()</code>方法，它内部需要调用若干其他方法，同时，我们遇到一个问题：如何在一个线程内传递状态？</p><p><code>process()</code>方法需要传递的状态就是<code>User</code>实例。有的童鞋会想，简单地传入<code>User</code>就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    checkPermission(user);</span><br><span class="line">    doWork(user);</span><br><span class="line">    saveStatus(user);</span><br><span class="line">    sendResponse(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是往往一个方法又会调用其他很多方法，这样会导致<code>User</code>传递到所有地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    queryStatus(user);</span><br><span class="line">    checkStatus();</span><br><span class="line">    setNewStatus(user);</span><br><span class="line">    log();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种在一个线程中，横跨若干方法调用，需要传递的对象，我们通常称之为上下文（Context），它是一种状态，可以是用户身份、任务信息等。</p><p>给每个方法增加一个context参数非常麻烦，而且有些时候，如果调用链有无法修改源码的第三方库，<code>User</code>对象就传不进去了。</p><p>Java标准库提供了一个特殊的<code>ThreadLocal</code>，它可以在一个线程中传递同一个对象。</p><p><code>ThreadLocal</code>实例通常总是以静态字段初始化如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;User&gt; threadLocalUser = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>它的典型使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">processUser</span><span class="params">(user)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        threadLocalUser.set(user);</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">        log();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadLocalUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过设置一个<code>User</code>实例关联到<code>ThreadLocal</code>中，在移除之前，所有方法都可以随时获取到该<code>User</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">step1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> threadLocalUser.get();</span><br><span class="line">    log();</span><br><span class="line">    printUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">step2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> threadLocalUser.get();</span><br><span class="line">    checkUser(u.id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> threadLocalUser.get();</span><br><span class="line">    println(u.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到普通的方法调用一定是同一个线程执行的，所以，<code>step1()</code>、<code>step2()</code>以及<code>log()</code>方法内，<code>threadLocalUser.get()</code>获取的<code>User</code>对象是同一个实例。</p><p>实际上，可以把<code>ThreadLocal</code>看成一个全局<code>Map&lt;Thread, Object&gt;</code>：每个线程获取<code>ThreadLocal</code>变量时，总是使用<code>Thread</code>自身作为key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">threadLocalValue</span> <span class="operator">=</span> threadLocalMap.get(Thread.currentThread());</span><br></pre></td></tr></table></figure><p>因此，<code>ThreadLocal</code>相当于给每个线程都开辟了一个独立的存储空间，各个线程的<code>ThreadLocal</code>关联的实例互不干扰。</p><p>最后，特别注意<code>ThreadLocal</code>一定要在<code>finally</code>中清除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocalUser.set(user);</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocalUser.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果<code>ThreadLocal</code>没有被清除，该线程执行其他代码时，会把上一次的状态带进去。</p><p>为了保证能释放<code>ThreadLocal</code>关联的实例，我们可以通过<code>AutoCloseable</code>接口配合<code>try (resource) &#123;...&#125;</code>结构，让编译器自动为我们关闭。例如，一个保存了当前用户名的<code>ThreadLocal</code>可以封装为一个<code>UserContext</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserContext</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; ctx = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserContext</span><span class="params">(String user)</span> &#123;</span><br><span class="line">        ctx.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">currentUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        ctx.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，我们借助<code>try (resource) &#123;...&#125;</code>结构，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserContext</span>(<span class="string">&quot;Bob&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 可任意调用UserContext.currentUser():</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">currentUser</span> <span class="operator">=</span> UserContext.currentUser();</span><br><span class="line">&#125; <span class="comment">// 在此自动调用UserContext.close()方法释放ThreadLocal关联对象</span></span><br></pre></td></tr></table></figure><p>这样就在<code>UserContext</code>中完全封装了<code>ThreadLocal</code>，外部代码在<code>try (resource) &#123;...&#125;</code>内部可以随时调用<code>UserContext.currentUser()</code>获取当前线程绑定的用户名。</p><h3 id="练习-5">练习</h3><p>练习使用ThreadLocal。</p><p><a href="https://liaoxuefeng.com/books/java/threading/thread-local/thread-threadlocal.zip">下载练习</a></p><h3 id="小结-5">小结</h3><p><code>ThreadLocal</code>表示线程的“局部变量”，它确保每个线程的<code>ThreadLocal</code>变量都是各自独立的；</p><p><code>ThreadLocal</code>适合在一个线程的处理流程中保持上下文（避免了同一参数在所有方法中传递）；</p><p>使用<code>ThreadLocal</code>要用<code>try ... finally</code>结构，并在<code>finally</code>中清除。</p><p>虚拟线程（Virtual Thread）是Java 19引入的一种轻量级线程，它在很多其他语言中被称为协程、纤程、绿色线程、用户态线程等。</p><p>在理解虚拟线程前，我们先回顾一下线程的特点：</p><ul><li>线程是由操作系统创建并调度的资源；</li><li>线程切换会耗费大量CPU时间；</li><li>一个系统能同时调度的线程数量是有限的，通常在几百至几千级别。</li></ul><p>因此，我们说线程是一种重量级资源。在服务器端，对用户请求，通常都实现为一个线程处理一个请求。由于用户的请求数往往远超操作系统能同时调度的线程数量，所以通常使用线程池来尽量减少频繁创建和销毁线程的成本。</p><p>对于需要处理大量IO请求的任务来说，使用线程是低效的，因为一旦读写IO，线程就必须进入等待状态，直到IO数据返回。常见的IO操作包括：</p><ul><li>读写文件；</li><li>读写网络，例如HTTP请求；</li><li>读写数据库，本质上是通过JDBC实现网络调用。</li></ul><p>我们举个例子，一个处理HTTP请求的线程，它在读写网络、文件的时候就会进入等待状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Begin</span><br><span class="line">────────</span><br><span class="line">Blocking ──▶ Read HTTP Request</span><br><span class="line">Wait...</span><br><span class="line">Wait...</span><br><span class="line">Wait...</span><br><span class="line">────────</span><br><span class="line">Running</span><br><span class="line">────────</span><br><span class="line">Blocking ──▶ Read Config File</span><br><span class="line">Wait...</span><br><span class="line">────────</span><br><span class="line">Running</span><br><span class="line">────────</span><br><span class="line">Blocking ──▶ Read Database</span><br><span class="line">Wait...</span><br><span class="line">Wait...</span><br><span class="line">Wait...</span><br><span class="line">────────</span><br><span class="line">Running</span><br><span class="line">────────</span><br><span class="line">Blocking ──▶ Send HTTP Response</span><br><span class="line">Wait...</span><br><span class="line">Wait...</span><br><span class="line">────────</span><br><span class="line">End</span><br></pre></td></tr></table></figure><p>真正由CPU执行的代码消耗的时间非常少，线程的大部分时间都在等待IO。我们把这类任务称为IO密集型任务。</p><p>为了能高效执行IO密集型任务，Java从19开始引入了虚拟线程。虚拟线程的接口和普通线程是一样的，但是执行方式不一样。虚拟线程不是由操作系统调度，而是由普通线程调度，即成百上千个虚拟线程可以由一个普通线程调度。任何时刻，只能执行一个虚拟线程，但是，一旦该虚拟线程执行一个IO操作进入等待时，它会被立刻“挂起”，然后执行下一个虚拟线程。什么时候IO数据返回了，这个挂起的虚拟线程才会被再次调度。因此，若干个虚拟线程可以在一个普通线程中交替运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Begin</span><br><span class="line">───────────</span><br><span class="line">V1 Runing</span><br><span class="line">V1 Blocking ──▶ Read HTTP Request</span><br><span class="line">───────────</span><br><span class="line">V2 Runing</span><br><span class="line">V2 Blocking ──▶ Read HTTP Request</span><br><span class="line">───────────</span><br><span class="line">V3 Runing</span><br><span class="line">V3 Blocking ──▶ Read HTTP Request</span><br><span class="line">───────────</span><br><span class="line">V1 Runing</span><br><span class="line">V1 Blocking ──▶ Read Config File</span><br><span class="line">───────────</span><br><span class="line">V2 Runing</span><br><span class="line">V2 Blocking ──▶ Read Database</span><br><span class="line">───────────</span><br><span class="line">V1 Runing</span><br><span class="line">V1 Blocking ──▶ Read Database</span><br><span class="line">───────────</span><br><span class="line">V3 Runing</span><br><span class="line">V3 Blocking ──▶ Read Database</span><br><span class="line">───────────</span><br><span class="line">V2 Runing</span><br><span class="line">V2 Blocking ──▶ Send HTTP Response</span><br><span class="line">───────────</span><br><span class="line">V1 Runing</span><br><span class="line">V1 Blocking ──▶ Send HTTP Response</span><br><span class="line">───────────</span><br><span class="line">V3 Runing</span><br><span class="line">V3 Blocking ──▶ Send HTTP Response</span><br><span class="line">───────────</span><br><span class="line">End</span><br></pre></td></tr></table></figure><p>如果我们单独看一个虚拟线程的代码，在一个方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> &#123;</span><br><span class="line">    config = readConfigFile(<span class="string">&quot;./config.json&quot;</span>); <span class="comment">// #1</span></span><br><span class="line">    <span class="keyword">if</span> (config.useFullName) &#123;</span><br><span class="line">        name = req.firstName + <span class="string">&quot; &quot;</span> + req.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">    insertInto(db, name); <span class="comment">// #2</span></span><br><span class="line">    <span class="keyword">if</span> (config.cache) &#123;</span><br><span class="line">        redis.set(key, name); <span class="comment">// #3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及到IO读写的#1、#2、#3处，执行到这些地方的时候（进入相关的JNI方法内部时）会自动挂起，并切换到其他虚拟线程执行。等到数据返回后，当前虚拟线程会再次调度并执行，因此，代码看起来是同步执行，但实际上是异步执行的。</p><h3 id="使用虚拟线程">使用虚拟线程</h3><p>虚拟线程的接口和普通线程一样，唯一区别在于创建虚拟线程只能通过特定方法。</p><p>方法一：直接创建虚拟线程并运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入Runnable实例并立刻运行:</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">vt</span> <span class="operator">=</span> Thread.startVirtualThread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Start virtual thread...&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;End virtual thread.&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>方法二：创建虚拟线程但不自动运行，而是手动调用<code>start()</code>开始运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建VirtualThread:</span></span><br><span class="line">Thread.ofVirtual().unstarted(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Start virtual thread...&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;End virtual thread.&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 运行:</span></span><br><span class="line">vt.start();</span><br></pre></td></tr></table></figure><p>方法三：通过虚拟线程的ThreadFactory创建虚拟线程，然后手动调用<code>start()</code>开始运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建ThreadFactory:</span></span><br><span class="line"><span class="type">ThreadFactory</span> <span class="variable">tf</span> <span class="operator">=</span> Thread.ofVirtual().factory();</span><br><span class="line"><span class="comment">// 创建VirtualThread:</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">vt</span> <span class="operator">=</span> tf.newThread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Start virtual thread...&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;End virtual thread.&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 运行:</span></span><br><span class="line">vt.start();</span><br></pre></td></tr></table></figure><p>直接调用<code>start()</code>实际上是由<code>ForkJoinPool</code>的线程来调度的。我们也可以自己创建调度线程，然后运行虚拟线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建调度器:</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor();</span><br><span class="line"><span class="comment">// 创建大量虚拟线程并调度:</span></span><br><span class="line"><span class="type">ThreadFactory</span> <span class="variable">tf</span> <span class="operator">=</span> Thread.ofVirtual().factory();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++) &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">vt</span> <span class="operator">=</span> tf.newThread(() -&gt; &#123; ... &#125;);</span><br><span class="line">    executor.submit(vt);</span><br><span class="line">    <span class="comment">// 也可以直接传入Runnable或Callable:</span></span><br><span class="line">    executor.submit(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Start virtual thread...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;End virtual thread.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于虚拟线程属于非常轻量级的资源，因此，用时创建，用完就扔，不要池化虚拟线程。</p><p>最后注意，虚拟线程在Java 21正式发布，在Java 19/20是预览功能，默认关闭，需要添加参数<code>--enable-preview</code>启用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java --source 19 --enable-preview Main.java</span><br></pre></td></tr></table></figure><h3 id="使用限制">使用限制</h3><p>注意到只有以虚拟线程方式运行的代码，才会在执行IO操作时自动被挂起并切换到其他虚拟线程。普通线程的IO操作仍然会等待，例如，我们在<code>main()</code>方法中读写文件，是不会有调度和自动挂起的。</p><p>可以自动引发调度切换的操作包括：</p><ul><li>文件IO；</li><li>网络IO；</li><li>使用Concurrent库引发等待；</li><li>Thread.sleep()操作。</li></ul><p>这是因为JDK为了实现虚拟线程，已经对底层相关操作进行了修改，这样应用层的Java代码无需修改即可使用虚拟线程。无法自动切换的语言需要用户手动调用<code>await</code>来实现异步操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doWork</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">readFile</span>();</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">sendNetworkData</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在虚拟线程中，如果绕过JDK的IO接口，直接通过JNI读写文件或网络是无法实现调度的。此外，在<code>synchronized</code>块内部也无法调度。</p><h3 id="练习-6">练习</h3><p>使用虚拟线程调度10万个任务并观察耗时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++) &#123;</span><br><span class="line">            es.submit(() -&gt; &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        es.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再将<code>ExecutorService</code>改为线程池模式并对比结果。</p><p><a href="https://liaoxuefeng.com/books/java/threading/virtual-thread/thread-virtualthread.zip">下载练习</a></p><h3 id="小结-6">小结</h3><p>Java 19引入的虚拟线程是为了解决IO密集型任务的吞吐量，它可以高效通过少数线程去调度大量虚拟线程；</p><p>虚拟线程在执行到IO操作或Blocking操作时，会自动切换到其他虚拟线程执行，从而避免当前线程等待，能最大化线程的执行效率；</p><p>虚拟线程使用普通线程相同的接口，最大的好处是无需修改任何代码，就可以将现有的IO操作异步化获得更大的吞吐能力。</p><p>计算密集型任务不应使用虚拟线程，只能通过增加CPU核心解决，或者利用分布式计算资源。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-加密与安全</title>
      <link href="/2025/05/24/JAVA-%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
      <url>/2025/05/24/JAVA-%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>在计算机系统中，什么是加密与安全呢？</p><p>我们举个栗子：假设Bob要给Alice发一封邮件，在邮件传送的过程中，黑客可能会窃取到邮件的内容，所以需要防窃听。黑客还可能会篡改邮件的内容，Alice必须有能力识别出邮件有没有被篡改。最后，黑客可能假冒Bob给Alice发邮件，Alice必须有能力识别出伪造的邮件。</p><p>所以，应对潜在的安全威胁，需要做到三防：</p><ul><li>防窃听</li><li>防篡改</li><li>防伪造</li></ul><p><img src="https://liaoxuefeng.com/books/java/security/security.jpg" alt="java-security"></p><p>计算机加密技术就是为了实现上述目标，而现代计算机密码学理论是建立在严格的数学理论基础上的，密码学已经逐渐发展成一门科学。对于绝大多数开发者来说，设计一个安全的加密算法非常困难，验证一个加密算法是否安全更加困难，当前被认为安全的加密算法仅仅是迄今为止尚未被攻破。因此，要编写安全的计算机程序，我们要做到：</p><ul><li>不要自己设计山寨的加密算法；</li><li>不要自己实现已有的加密算法；</li><li>不要自己修改已有的加密算法。</li></ul><p>本章我们会介绍最常用的加密算法，以及如何通过Java代码实现。</p><p>要学习编码算法，我们先来看一看什么是编码。</p><p>ASCII码就是一种编码，字母<code>A</code>的编码是十六进制的<code>0x41</code>，字母<code>B</code>是<code>0x42</code>，以此类推：</p><table><thead><tr><th>字母</th><th>ASCII编码</th></tr></thead><tbody><tr><td>A</td><td>0x41</td></tr><tr><td>B</td><td>0x42</td></tr><tr><td>C</td><td>0x43</td></tr><tr><td>D</td><td>0x44</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>因为ASCII编码最多只能有128个字符，要想对更多的文字进行编码，就需要用Unicode。而中文的中使用Unicode编码就是<code>0x4e2d</code>，使用UTF-8则需要3个字节编码：</p><table><thead><tr><th>汉字</th><th>Unicode编码</th><th>UTF-8编码</th></tr></thead><tbody><tr><td>中</td><td>0x4e2d</td><td>0xe4b8ad</td></tr><tr><td>文</td><td>0x6587</td><td>0xe69687</td></tr><tr><td>编</td><td>0x7f16</td><td>0xe7bc96</td></tr><tr><td>码</td><td>0x7801</td><td>0xe7a081</td></tr><tr><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>因此，最简单的编码是直接给每个字符指定一个若干字节表示的整数，复杂一点的编码就需要根据一个已有的编码推算出来。</p><p>比如UTF-8编码，它是一种不定长编码，但可以从给定字符的Unicode编码推算出来。</p><h3 id="URL编码">URL编码</h3><p>URL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分，例如：</p><p><a href="https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87">https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87</a></p><p>之所以需要URL编码，是因为出于兼容性考虑，很多服务器只识别ASCII字符。但如果URL中包含中文、日文这些非ASCII字符怎么办？不要紧，URL编码有一套规则：</p><ul><li>如果字符是<code>A</code>~<code>Z</code>，<code>a</code>~<code>z</code>，<code>0</code>~<code>9</code>以及<code>-</code>、<code>_</code>、<code>.</code>、<code>*</code>，则保持不变；</li><li>如果是其他字符，先转换为UTF-8编码，然后对每个字节以<code>%XX</code>表示。</li></ul><p>例如：字符<code>中</code>的UTF-8编码是<code>0xe4b8ad</code>，因此，它的URL编码是<code>%E4%B8%AD</code>。URL编码总是大写。</p><p>Java标准库提供了一个<code>URLEncoder</code>类来对任意字符串进行URL编码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encoded</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;中文!&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(encoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的运行结果是<code>%E4%B8%AD%E6%96%87%21</code>，<code>中</code>的URL编码是<code>%E4%B8%AD</code>，<code>文</code>的URL编码是<code>%E6%96%87</code>，<code>!</code>虽然是ASCII字符，也要对其编码为<code>%21</code>。</p><p>和标准的URL编码稍有不同，URLEncoder把空格字符编码成<code>+</code>，而现在的URL编码标准要求空格被编码为<code>%20</code>，不过，服务器都可以处理这两种情况。</p><p>如果服务器收到URL编码的字符串，就可以对其进行解码，还原成原始字符串。Java标准库的<code>URLDecoder</code>就可以解码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">decoded</span> <span class="operator">=</span> URLDecoder.decode(<span class="string">&quot;%E4%B8%AD%E6%96%87%21&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(decoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要特别注意：URL编码是编码算法，不是加密算法。URL编码的目的是把任意文本数据编码为<code>%</code>前缀表示的文本，编码后的文本仅包含<code>A</code>~<code>Z</code>，<code>a</code>~<code>z</code>，<code>0</code>~<code>9</code>，<code>-</code>，<code>_</code>，<code>.</code>，<code>*</code>和<code>%</code>，便于浏览器和服务器处理。</p><h3 id="Base64编码">Base64编码</h3><p>URL编码是对字符进行编码，表示成<code>%xx</code>的形式，而Base64编码是对二进制数据进行编码，表示成文本格式。</p><p>Base64编码可以把任意长度的二进制数据变为纯文本，且只包含<code>A</code>~<code>Z</code>、<code>a</code>~<code>z</code>、<code>0</code>~<code>9</code>、<code>+</code>、<code>/</code>、<code>=</code>这些字符。它的原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。</p><p>举个例子：3个byte数据分别是<code>e4</code>、<code>b8</code>、<code>ad</code>，按6bit分组得到<code>39</code>、<code>0b</code>、<code>22</code>和<code>2d</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────┬───────────────┬───────────────┐</span><br><span class="line">│      e4       │      b8       │      ad       │</span><br><span class="line">└───────────────┴───────────────┴───────────────┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class="line">│1│1│1│0│0│1│0│0│1│0│1│1│1│0│0│0│1│0│1│0│1│1│0│1│</span><br><span class="line">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌───────────┬───────────┬───────────┬───────────┐</span><br><span class="line">│    39     │    0b     │    22     │    2d     │</span><br><span class="line">└───────────┴───────────┴───────────┴───────────┘</span><br></pre></td></tr></table></figure><p>因为6位整数的范围总是<code>0</code>~<code>63</code>，所以，能用64个字符表示：字符<code>A</code>~<code>Z</code>对应索引<code>0</code>~<code>25</code>，字符<code>a</code>~<code>z</code>对应索引<code>26</code>~<code>51</code>，字符<code>0</code>~<code>9</code>对应索引<code>52</code>~<code>61</code>，最后两个索引<code>62</code>、<code>63</code>分别用字符<code>+</code>和<code>/</code>表示。</p><p>在Java中，二进制数据就是<code>byte[]</code>数组。Java标准库提供了<code>Base64</code>来对<code>byte[]</code>数组进行编解码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] input = <span class="keyword">new</span> <span class="title class_">byte</span>[] &#123; (<span class="type">byte</span>) <span class="number">0xe4</span>, (<span class="type">byte</span>) <span class="number">0xb8</span>, (<span class="type">byte</span>) <span class="number">0xad</span> &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b64encoded</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(input);</span><br><span class="line">        System.out.println(b64encoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编码后得到<code>5Lit</code>4个字符。要对<code>Base64</code>解码，仍然用<code>Base64</code>这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] output = Base64.getDecoder().decode(<span class="string">&quot;5Lit&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(output)); <span class="comment">// [-28, -72, -83]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有的童鞋会问：如果输入的<code>byte[]</code>数组长度不是3的整数倍肿么办？这种情况下，需要对输入的末尾补一个或两个<code>0x00</code>，编码后，在结尾加一个<code>=</code>表示补充了1个<code>0x00</code>，加两个<code>=</code>表示补充了2个<code>0x00</code>，解码的时候，去掉末尾补充的一个或两个<code>0x00</code>即可。</p><p>实际上，因为编码后的长度加上<code>=</code>总是4的倍数，所以即使不加<code>=</code>也可以计算出原始输入的<code>byte[]</code>。Base64编码的时候可以用<code>withoutPadding()</code>去掉<code>=</code>，解码出来的结果是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] input = <span class="keyword">new</span> <span class="title class_">byte</span>[] &#123; (<span class="type">byte</span>) <span class="number">0xe4</span>, (<span class="type">byte</span>) <span class="number">0xb8</span>, (<span class="type">byte</span>) <span class="number">0xad</span>, <span class="number">0x21</span> &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b64encoded</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(input);</span><br><span class="line">        <span class="type">String</span> <span class="variable">b64encoded2</span> <span class="operator">=</span> Base64.getEncoder().withoutPadding().encodeToString(input);</span><br><span class="line">        System.out.println(b64encoded);</span><br><span class="line">        System.out.println(b64encoded2);</span><br><span class="line">        <span class="type">byte</span>[] output = Base64.getDecoder().decode(b64encoded2);</span><br><span class="line">        System.out.println(Arrays.toString(output));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为标准的Base64编码会出现<code>+</code>、<code>/</code>和<code>=</code>，所以不适合把Base64编码后的字符串放到URL中。一种针对URL的Base64编码可以在URL中使用的Base64编码，它仅仅是把<code>+</code>变成<code>-</code>，<code>/</code>变成<code>_</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] input = <span class="keyword">new</span> <span class="title class_">byte</span>[] &#123; <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x7f</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b64encoded</span> <span class="operator">=</span> Base64.getUrlEncoder().encodeToString(input);</span><br><span class="line">        System.out.println(b64encoded);</span><br><span class="line">        <span class="type">byte</span>[] output = Base64.getUrlDecoder().decode(b64encoded);</span><br><span class="line">        System.out.println(Arrays.toString(output));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Base64编码的目的是把二进制数据变成文本格式，这样在很多文本中就可以处理二进制数据。例如，电子邮件协议就是文本协议，如果要在电子邮件中添加一个二进制文件，就可以用Base64编码，然后以文本的形式传送。</p><p>Base64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1/3。</p><p>和URL编码一样，Base64编码是一种编码算法，不是加密算法。</p><p>如果把Base64的64个字符编码表换成32个、48个或者58个，就可以使用Base32编码，Base48编码和Base58编码。字符越少，编码的效率就会越低。</p><h3 id="小结">小结</h3><p>URL编码和Base64编码都是编码算法，它们不是加密算法；</p><p>URL编码的目的是把任意文本数据编码为%前缀表示的文本，便于浏览器和服务器处理；</p><p>Base64编码的目的是把任意二进制数据编码为文本，但编码后数据量会增加1/3。</p><p>哈希算法（Hash）又称摘要算法（Digest），它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。</p><p>哈希算法最重要的特点就是：</p><ul><li>相同的输入一定得到相同的输出；</li><li>不同的输入大概率得到不同的输出。</li></ul><p>哈希算法的目的就是为了验证原始数据是否被篡改。</p><p>Java字符串的<code>hashCode()</code>就是一个哈希算法，它的输入是任意字符串，输出是固定的4字节<code>int</code>整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span>.hashCode(); <span class="comment">// 0x5e918d2</span></span><br><span class="line"><span class="string">&quot;hello, java&quot;</span>.hashCode(); <span class="comment">// 0x7a9d88e8</span></span><br><span class="line"><span class="string">&quot;hello, bob&quot;</span>.hashCode(); <span class="comment">// 0xa0dbae2f</span></span><br></pre></td></tr></table></figure><p>两个相同的字符串永远会计算出相同的<code>hashCode</code>，否则基于<code>hashCode</code>定位的<code>HashMap</code>就无法正常工作。这也是为什么当我们自定义一个class时，覆写<code>equals()</code>方法时我们必须正确覆写<code>hashCode()</code>方法。</p><h3 id="哈希碰撞">哈希碰撞</h3><p>哈希碰撞是指，两个不同的输入得到了相同的输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;AaAaAa&quot;</span>.hashCode(); <span class="comment">// 0x7460e8c0</span></span><br><span class="line"><span class="string">&quot;BBAaBB&quot;</span>.hashCode(); <span class="comment">// 0x7460e8c0</span></span><br></pre></td></tr></table></figure><p>有童鞋会问：碰撞能不能避免？答案是不能。碰撞是一定会出现的，因为输出的字节长度是固定的，<code>String</code>的<code>hashCode()</code>输出是4字节整数，最多只有4294967296种输出，但输入的数据长度是不固定的，有无数种输入。所以，哈希算法是把一个无限的输入集合映射到一个有限的输出集合，必然会产生碰撞。</p><p>碰撞不可怕，我们担心的不是碰撞，而是碰撞的概率，因为碰撞概率的高低关系到哈希算法的安全性。一个安全的哈希算法必须满足：</p><ul><li>碰撞概率低；</li><li>不能猜测输出。</li></ul><p>不能猜测输出是指，输入的任意一个bit的变化会造成输出完全不同，这样就很难从输出反推输入（只能依靠暴力穷举）。假设一种哈希算法有如下规律：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hashA(&quot;java001&quot;) = &quot;123456&quot;</span><br><span class="line">hashA(&quot;java002&quot;) = &quot;123457&quot;</span><br><span class="line">hashA(&quot;java003&quot;) = &quot;123458&quot;</span><br></pre></td></tr></table></figure><p>那么很容易从输出<code>123459</code>反推输入，这种哈希算法就不安全。安全的哈希算法从输出是看不出任何规律的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hashB(&quot;java001&quot;) = &quot;123456&quot;</span><br><span class="line">hashB(&quot;java002&quot;) = &quot;580271&quot;</span><br><span class="line">hashB(&quot;java003&quot;) = ???</span><br></pre></td></tr></table></figure><p>常用的哈希算法有：</p><table><thead><tr><th>算法</th><th>输出长度（位）</th><th>输出长度（字节）</th></tr></thead><tbody><tr><td>MD5</td><td>128 bits</td><td>16 bytes</td></tr><tr><td>SHA-1</td><td>160 bits</td><td>20 bytes</td></tr><tr><td>RipeMD-160</td><td>160 bits</td><td>20 bytes</td></tr><tr><td>SHA-256</td><td>256 bits</td><td>32 bytes</td></tr><tr><td>SHA-512</td><td>512 bits</td><td>64 bytes</td></tr></tbody></table><p>根据碰撞概率，哈希算法的输出长度越长，就越难产生碰撞，也就越安全。</p><p>Java标准库提供了常用的哈希算法，并且有一套统一的接口。我们以MD5算法为例，看看如何对输入计算哈希：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.util.HexFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建一个MessageDigest实例:</span></span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="comment">// 反复调用update输入数据:</span></span><br><span class="line">        md.update(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        md.update(<span class="string">&quot;World&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[] result = md.digest(); <span class="comment">// 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6</span></span><br><span class="line">        System.out.println(HexFormat.of().formatHex(result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>MessageDigest</code>时，我们首先根据哈希算法获取一个<code>MessageDigest</code>实例，然后，反复调用<code>update(byte[])</code>输入数据。当输入结束后，调用<code>digest()</code>方法获得byte[]数组表示的摘要，最后，把它转换为十六进制的字符串。</p><p>运行上述代码，可以得到输入<code>HelloWorld</code>的MD5是<code>68e109f0f40ca72a15e05cc22786f8e6</code>。</p><h3 id="哈希算法的用途">哈希算法的用途</h3><p>因为相同的输入永远会得到相同的输出，因此，如果输入被修改了，得到的输出就会不同。</p><p>我们在网站上下载软件的时候，经常看到下载页显示的哈希：</p><p><img src="https://liaoxuefeng.com/books/java/security/hash/file-md5.jpg" alt="file-md5"></p><p>如何判断下载到本地的软件是原始的、未经篡改的文件？我们只需要自己计算一下本地文件的哈希值，再与官网公开的哈希值对比，如果相同，说明文件下载正确，否则，说明文件已被篡改。</p><p>哈希算法的另一个重要用途是存储用户口令。如果直接将用户的原始口令存放到数据库中，会产生极大的安全风险：</p><ul><li>数据库管理员能够看到用户明文口令；</li><li>数据库数据一旦泄漏，黑客即可获取用户明文口令。</li></ul><p>不存储用户的原始口令，那么如何对用户进行认证？</p><p>方法是存储用户口令的哈希，例如，MD5。</p><p>在用户输入原始口令后，系统计算用户输入的原始口令的MD5并与数据库存储的MD5对比，如果一致，说明口令正确，否则，口令错误。</p><p>因此，数据库存储用户名和口令的表内容应该像下面这样：</p><table><thead><tr><th>username</th><th>password</th></tr></thead><tbody><tr><td>bob</td><td>f30aa7a662c728b7407c54ae6bfd27d1</td></tr><tr><td>alice</td><td>25d55ad283aa400af464c76d713c07ad</td></tr><tr><td>tim</td><td>bed128365216c019988915ed3add75fb</td></tr></tbody></table><p>这样一来，数据库管理员看不到用户的原始口令。即使数据库泄漏，黑客也无法拿到用户的原始口令。想要拿到用户的原始口令，必须用暴力穷举的方法，一个口令一个口令地试，直到某个口令计算的MD5恰好等于指定值。</p><p>使用哈希口令时，还要注意防止彩虹表攻击。</p><p>什么是彩虹表？难道是这个：</p><p><img src="https://liaoxuefeng.com/books/java/security/hash/rainbow.jpg" alt="彩虹表"></p><p>上面讲到了，如果只拿到MD5，从MD5反推明文口令，只能使用暴力穷举的方法。</p><p>然而黑客并不笨，暴力穷举会消耗大量的算力和时间。但是，如果有一个预先计算好的常用口令和它们的MD5的对照表：</p><table><thead><tr><th>常用口令</th><th>MD5</th></tr></thead><tbody><tr><td>hello123</td><td>f30aa7a662c728b7407c54ae6bfd27d1</td></tr><tr><td>12345678</td><td>25d55ad283aa400af464c76d713c07ad</td></tr><tr><td>passw0rd</td><td>bed128365216c019988915ed3add75fb</td></tr><tr><td>19700101</td><td>570da6d5277a646f6552b8832012f5dc</td></tr><tr><td>…</td><td>…</td></tr><tr><td>20201231</td><td>6879c0ae9117b50074ce0a0d4c843060</td></tr></tbody></table><p>这个表就是彩虹表。如果用户使用了常用口令，黑客从MD5一下就能反查到原始口令：</p><p>bob的MD5：<code>f30aa7a662c728b7407c54ae6bfd27d1</code>，原始口令：<code>hello123</code>；</p><p>alice的MD5：<code>25d55ad283aa400af464c76d713c07ad</code>，原始口令：<code>12345678</code>；</p><p>tim的MD5：<code>bed128365216c019988915ed3add75fb</code>，原始口令：<code>passw0rd</code>。</p><p>这就是为什么不要使用常用密码，以及不要使用生日作为密码的原因。</p><p>即使用户使用了常用口令，我们也可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法称之为加盐（salt）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">digest = md5(salt+inputPassword)</span><br></pre></td></tr></table></figure><p>经过加盐处理的数据库表，内容如下：</p><table><thead><tr><th>username</th><th>salt</th><th>password</th></tr></thead><tbody><tr><td>bob</td><td>H1r0a</td><td>a5022319ff4c56955e22a74abcc2c210</td></tr><tr><td>alice</td><td>7$p2w</td><td>e5de688c99e961ed6e560b972dab8b6a</td></tr><tr><td>tim</td><td>z5Sk9</td><td>1eee304b92dc0d105904e7ab58fd2f64</td></tr></tbody></table><p>加盐的目的在于使黑客的彩虹表失效，即使用户使用常用口令，也无法从MD5反推原始口令。</p><h3 id="SHA-1">SHA-1</h3><p>SHA-1也是一种哈希算法，它的输出是160 bits，即20字节。SHA-1是由美国国家安全局开发的，SHA算法实际上是一个系列，包括SHA-0（已废弃）、SHA-1、SHA-256、SHA-512等。</p><p>在Java中使用SHA-1，和MD5完全一样，只需要把算法名称改为<code>&quot;SHA-1&quot;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.util.HexFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建一个MessageDigest实例:</span></span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA-1&quot;</span>);</span><br><span class="line">        <span class="comment">// 反复调用update输入数据:</span></span><br><span class="line">        md.update(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        md.update(<span class="string">&quot;World&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[] result = md.digest(); <span class="comment">// 20 bytes: db8ac1c259eb89d4a131b253bacfca5f319d54f2</span></span><br><span class="line">        System.out.println(HexFormat.of().formatHex(result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，计算SHA-256，我们需要传入名称<code>&quot;SHA-256&quot;</code>，计算SHA-512，我们需要传入名称<code>&quot;SHA-512&quot;</code>。Java标准库支持的所有哈希算法可以在<a href="https://docs.oracle.com/en/java/javase/21/docs/specs/security/standard-names.html#messagedigest-algorithms">这里</a>查到。</p><p>注意</p><p>MD5因为输出长度较短，短时间内破解是可能的，目前已经不推荐使用。</p><h3 id="小结-2">小结</h3><p>哈希算法可用于验证数据完整性，具有防篡改检测的功能；</p><p>常用的哈希算法有MD5、SHA-1等；</p><p>用哈希存储口令时要考虑彩虹表攻击。</p><h2 id="BouncyCastle">BouncyCastle</h2><p>我们知道，Java标准库提供了一系列常用的哈希算法。</p><p>但如果我们要用的某种算法，Java标准库没有提供怎么办？</p><p>方法一：自己写一个，难度很大；</p><p>方法二：找一个现成的第三方库，直接使用。</p><p><a href="https://www.bouncycastle.org/">BouncyCastle</a>就是一个提供了很多哈希算法和加密算法的第三方库。它提供了Java标准库没有的一些算法，例如，RipeMD160哈希算法。</p><p>我们来看一下如何使用BouncyCastle这个第三方提供的算法。</p><p>首先，我们必须把BouncyCastle提供的jar包放到classpath中。这个jar包就是<code>bcprov-jdk18on-xxx.jar</code>，可以从<a href="https://www.bouncycastle.org/latest_releases.html">官方网站</a>下载。</p><p>Java标准库的<code>java.security</code>包提供了一种标准机制，允许第三方提供商无缝接入。我们要使用BouncyCastle提供的RipeMD160算法，需要先把BouncyCastle注册一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 注册BouncyCastle:</span></span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>());</span><br><span class="line">        <span class="comment">// 按名称正常调用:</span></span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;RipeMD160&quot;</span>);</span><br><span class="line">        md.update(<span class="string">&quot;HelloWorld&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[] result = md.digest();</span><br><span class="line">        System.out.println(HexFormat.of().formatHex(result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，注册BouncyCastle是通过下面的语句实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>());</span><br></pre></td></tr></table></figure><p>注册只需要在启动时进行一次，后续就可以使用BouncyCastle提供的所有哈希算法和加密算法。</p><h3 id="练习">练习</h3><p>使用BouncyCastle提供的RipeMD160计算哈希。</p><p><a href="https://liaoxuefeng.com/books/java/security/bouncy-castle/encrypt-bc.zip">下载练习</a></p><h3 id="小结-3">小结</h3><p>BouncyCastle是一个开源的第三方算法提供商；</p><p>BouncyCastle提供了很多Java标准库没有提供的哈希算法和加密算法；</p><p>使用第三方算法前需要通过<code>Security.addProvider()</code>注册。</p><hr><hr><h2 id="Hmac算法">Hmac算法</h2><p>在前面讲到哈希算法时，我们说，存储用户的哈希口令时，要加盐存储，目的就在于抵御彩虹表攻击。</p><p>我们回顾一下哈希算法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">digest = hash(input)</span><br></pre></td></tr></table></figure><p>正是因为相同的输入会产生相同的输出，我们加盐的目的就在于，使得输入有所变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">digest = hash(salt + input)</span><br></pre></td></tr></table></figure><p>这个salt可以看作是一个额外的“认证码”，同样的输入，不同的认证码，会产生不同的输出。因此，要验证输出的哈希，必须同时提供“认证码”。</p><p>Hmac算法就是一种基于密钥的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。</p><p>Hmac算法总是和某种哈希算法配合起来用的。例如，我们使用MD5算法，对应的就是HmacMD5算法，它相当于“加盐”的MD5：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HmacMD5 ≈ md5(secure_random_key, input)</span><br></pre></td></tr></table></figure><p>因此，HmacMD5可以看作带有一个安全的key的MD5。使用HmacMD5而不是用MD5加salt，有如下好处：</p><ul><li>HmacMD5使用的key长度是64字节，更安全；</li><li>Hmac是标准算法，同样适用于SHA-1等其他哈希算法；</li><li>Hmac输出和原有的哈希算法长度一致。</li></ul><p>可见，Hmac本质上就是把key混入摘要的算法。验证此哈希时，除了原始的输入数据，还要提供key。</p><p>为了保证安全，我们不会自己指定key，而是通过Java标准库的KeyGenerator生成一个安全的随机的key。下面是使用HmacMD5的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HexFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">KeyGenerator</span> <span class="variable">keyGen</span> <span class="operator">=</span> KeyGenerator.getInstance(<span class="string">&quot;HmacMD5&quot;</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">key</span> <span class="operator">=</span> keyGen.generateKey();</span><br><span class="line">        <span class="comment">// 打印随机生成的key:</span></span><br><span class="line">        <span class="type">byte</span>[] skey = key.getEncoded();</span><br><span class="line">        System.out.println(HexFormat.of().formatHex(skey));</span><br><span class="line">        <span class="type">Mac</span> <span class="variable">mac</span> <span class="operator">=</span> Mac.getInstance(<span class="string">&quot;HmacMD5&quot;</span>);</span><br><span class="line">        mac.init(key);</span><br><span class="line">        mac.update(<span class="string">&quot;HelloWorld&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[] result = mac.doFinal();</span><br><span class="line">        System.out.println(HexFormat.of().formatHex(result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和MD5相比，使用HmacMD5的步骤是：</p><ol><li>通过名称<code>HmacMD5</code>获取<code>KeyGenerator</code>实例；</li><li>通过<code>KeyGenerator</code>创建一个<code>SecretKey</code>实例；</li><li>通过名称<code>HmacMD5</code>获取<code>Mac</code>实例；</li><li>用<code>SecretKey</code>初始化<code>Mac</code>实例；</li><li>对<code>Mac</code>实例反复调用<code>update(byte[])</code>输入数据；</li><li>调用<code>Mac</code>实例的<code>doFinal()</code>获取最终的哈希值。</li></ol><p>我们可以用Hmac算法取代原有的自定义的加盐算法，因此，存储用户名和口令的数据库结构如下：</p><table><thead><tr><th>username</th><th>secret_key (64 bytes)</th><th>password</th></tr></thead><tbody><tr><td>bob</td><td>a8c06e05f92e…5e16</td><td>7e0387872a57c85ef6dddbaa12f376de</td></tr><tr><td>alice</td><td>e6a343693985…f4be</td><td>c1f929ac2552642b302e739bc0cdbaac</td></tr><tr><td>tim</td><td>f27a973dfdc0…6003</td><td>af57651c3a8a73303515804d4af43790</td></tr></tbody></table><p>有了Hmac计算的哈希和<code>SecretKey</code>，我们想要验证怎么办？这时，<code>SecretKey</code>不能从<code>KeyGenerator</code>生成，而是从一个<code>byte[]</code>数组恢复：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HexFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] hkey = HexFormat.of().parseHex(</span><br><span class="line">                <span class="string">&quot;b648ee779d658c420420d86291ec70f5&quot;</span> + </span><br><span class="line">                <span class="string">&quot;cf97521c740330972697a8fad0b55f5c&quot;</span> + </span><br><span class="line">                <span class="string">&quot;5a7924e4afa99d8c5883e07d7c3f9ed0&quot;</span> + </span><br><span class="line">                <span class="string">&quot;76aa544d25ed2f5ceea59dcc122babc8&quot;</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(hkey, <span class="string">&quot;HmacMD5&quot;</span>);</span><br><span class="line">        <span class="type">Mac</span> <span class="variable">mac</span> <span class="operator">=</span> Mac.getInstance(<span class="string">&quot;HmacMD5&quot;</span>);</span><br><span class="line">        mac.init(key);</span><br><span class="line">        mac.update(<span class="string">&quot;HelloWorld&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[] result = mac.doFinal();</span><br><span class="line">        System.out.println(HexFormat.of().formatHex(result)); <span class="comment">// 4af40be7864efaae1473a4c601b650ae</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恢复<code>SecretKey</code>的语句就是<code>new SecretKeySpec(hkey, &quot;HmacMD5&quot;)</code>。</p><h3 id="小结-4">小结</h3><p>Hmac算法是一种标准的基于密钥的哈希算法，可以配合MD5、SHA-1等哈希算法，计算的摘要长度和原摘要算法长度相同。</p><hr><hr><p>对称加密算法就是传统的用一个密码进行加密和解密。例如，我们常用的WinZIP和WinRAR对压缩包的加密和解密，就是使用对称加密算法：</p><p><img src="https://liaoxuefeng.com/books/java/security/aes/winrar.jpg" alt="winrar"></p><p>从程序的角度看，所谓加密，就是这样一个函数，它接收密码和明文，然后输出密文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secret = encrypt(key, message);</span><br></pre></td></tr></table></figure><p>而解密则相反，它接收密码和密文，然后输出明文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plain = decrypt(key, secret);</span><br></pre></td></tr></table></figure><p>在软件开发中，常用的对称加密算法有：</p><table><thead><tr><th>算法</th><th>密钥长度</th><th>工作模式</th><th>填充模式</th></tr></thead><tbody><tr><td>DES</td><td>56/64</td><td>ECB/CBC/PCBC/CTR/…</td><td>NoPadding/PKCS5Padding/…</td></tr><tr><td>AES</td><td>128/192/256</td><td>ECB/CBC/PCBC/CTR/…</td><td>NoPadding/PKCS5Padding/PKCS7Padding/…</td></tr><tr><td>IDEA</td><td>128</td><td>ECB</td><td>PKCS5Padding/PKCS7Padding/…</td></tr></tbody></table><p>密钥长度直接决定加密强度，而工作模式和填充模式可以看成是对称加密算法的参数和格式选择。Java标准库提供的算法实现并不包括所有的工作模式和所有填充模式，但是通常我们只需要挑选常用的使用就可以了。</p><p>最后注意，DES算法由于密钥过短，可以在短时间内被暴力破解，所以现在已经不安全了。</p><h3 id="使用AES加密">使用AES加密</h3><p>AES算法是目前应用最广泛的加密算法。我们先用ECB模式加密并解密：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 原文:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Message: &quot;</span> + message);</span><br><span class="line">        <span class="comment">// 128位密钥 = 16 bytes Key:</span></span><br><span class="line">        <span class="type">byte</span>[] key = <span class="string">&quot;1234567890abcdef&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="type">byte</span>[] data = message.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] encrypted = encrypt(key, data);</span><br><span class="line">        System.out.println(<span class="string">&quot;Encrypted: &quot;</span> + Base64.getEncoder().encodeToString(encrypted));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="type">byte</span>[] decrypted = decrypt(key, encrypted);</span><br><span class="line">        System.out.println(<span class="string">&quot;Decrypted: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] encrypt(<span class="type">byte</span>[] key, <span class="type">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/ECB/PKCS5Padding&quot;</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, keySpec);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decrypt(<span class="type">byte</span>[] key, <span class="type">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/ECB/PKCS5Padding&quot;</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, keySpec);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java标准库提供的对称加密接口非常简单，使用时按以下步骤编写代码：</p><ol><li>根据算法名称/工作模式/填充模式获取Cipher实例；</li><li>根据算法名称初始化一个SecretKey实例，密钥必须是指定长度；</li><li>使用SecretKey初始化Cipher实例，并设置加密或解密模式；</li><li>传入明文或密文，获得密文或明文。</li></ol><p>ECB模式是最简单的AES加密模式，它只需要一个固定长度的密钥，固定的明文会生成固定的密文，这种一对一的加密方式会导致安全性降低，更好的方式是通过CBC模式，它需要一个随机数作为IV参数，这样对于同一份明文，每次生成的密文都不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 原文:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Message: &quot;</span> + message);</span><br><span class="line">        <span class="comment">// 256位密钥 = 32 bytes Key:</span></span><br><span class="line">        <span class="type">byte</span>[] key = <span class="string">&quot;1234567890abcdef1234567890abcdef&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="type">byte</span>[] data = message.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] encrypted = encrypt(key, data);</span><br><span class="line">        System.out.println(<span class="string">&quot;Encrypted: &quot;</span> + Base64.getEncoder().encodeToString(encrypted));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="type">byte</span>[] decrypted = decrypt(key, encrypted);</span><br><span class="line">        System.out.println(<span class="string">&quot;Decrypted: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] encrypt(<span class="type">byte</span>[] key, <span class="type">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        <span class="comment">// CBC模式需要生成一个16 bytes的initialization vector:</span></span><br><span class="line">        <span class="type">SecureRandom</span> <span class="variable">sr</span> <span class="operator">=</span> SecureRandom.getInstanceStrong();</span><br><span class="line">        <span class="type">byte</span>[] iv = sr.generateSeed(<span class="number">16</span>);</span><br><span class="line">        <span class="type">IvParameterSpec</span> <span class="variable">ivps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(iv);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivps);</span><br><span class="line">        <span class="type">byte</span>[] data = cipher.doFinal(input);</span><br><span class="line">        <span class="comment">// IV不需要保密，把IV和密文一起返回:</span></span><br><span class="line">        <span class="keyword">return</span> join(iv, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decrypt(<span class="type">byte</span>[] key, <span class="type">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="comment">// 把input分割成IV和密文:</span></span><br><span class="line">        <span class="type">byte</span>[] iv = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[input.length - <span class="number">16</span>];</span><br><span class="line">        System.arraycopy(input, <span class="number">0</span>, iv, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">        System.arraycopy(input, <span class="number">16</span>, data, <span class="number">0</span>, data.length);</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        <span class="type">IvParameterSpec</span> <span class="variable">ivps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(iv);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivps);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] join(<span class="type">byte</span>[] bs1, <span class="type">byte</span>[] bs2) &#123;</span><br><span class="line">        <span class="type">byte</span>[] r = <span class="keyword">new</span> <span class="title class_">byte</span>[bs1.length + bs2.length];</span><br><span class="line">        System.arraycopy(bs1, <span class="number">0</span>, r, <span class="number">0</span>, bs1.length);</span><br><span class="line">        System.arraycopy(bs2, <span class="number">0</span>, r, bs1.length, bs2.length);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CBC模式下，需要一个随机生成的16字节IV参数，必须使用<code>SecureRandom</code>生成。因为多了一个<code>IvParameterSpec</code>实例，因此，初始化方法需要调用<code>Cipher</code>的一个重载方法并传入<code>IvParameterSpec</code>。</p><p>观察输出，可以发现每次生成的IV不同，密文也不同。</p><h3 id="小结-5">小结</h3><p>对称加密算法使用同一个密钥进行加密和解密，常用算法有DES、AES和IDEA等；</p><p>密钥长度由算法设计决定，AES的密钥长度是128/192/256位；</p><p>使用对称加密算法需要指定算法名称、工作模式和填充模式。</p><p>上一节我们讲的AES加密，细心的童鞋可能会发现，密钥长度是固定的128/192/256位，而不是我们用WinZip/WinRAR那样，随便输入几位都可以。</p><p>这是因为对称加密算法决定了口令必须是固定长度，然后对明文进行分块加密。又因为安全需求，口令长度往往都是128位以上，即至少16个字符。</p><p>但是我们平时使用的加密软件，输入6位、8位都可以，难道加密方式不一样？</p><p>实际上用户输入的口令并不能直接作为AES的密钥进行加密（除非长度恰好是128/192/256位），并且用户输入的口令一般都有规律，安全性远远不如安全随机数产生的随机口令。因此，用户输入的口令，通常还需要使用PBE算法，采用随机数杂凑计算出真正的密钥，再进行加密。</p><p>PBE就是Password Based Encryption的缩写，它的作用如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key = generate(userPassword, secureRandomPassword);</span><br></pre></td></tr></table></figure><p>PBE的作用就是把用户输入的口令和一个安全随机的口令采用杂凑后计算出真正的密钥。以AES密钥为例，我们让用户输入一个口令，然后生成一个随机数，通过PBE算法计算出真正的AES口令，再进行加密，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 把BouncyCastle作为Provider添加到java.security:</span></span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>());</span><br><span class="line">        <span class="comment">// 原文:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">        <span class="comment">// 加密口令:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;hello12345&quot;</span>;</span><br><span class="line">        <span class="comment">// 16 bytes随机Salt:</span></span><br><span class="line">        <span class="type">byte</span>[] salt = SecureRandom.getInstanceStrong().generateSeed(<span class="number">16</span>);</span><br><span class="line">        System.out.println(HexFormat.of().formatHex(salt));</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="type">byte</span>[] data = message.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] encrypted = encrypt(password, salt, data);</span><br><span class="line">        System.out.println(<span class="string">&quot;encrypted: &quot;</span> + Base64.getEncoder().encodeToString(encrypted));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="type">byte</span>[] decrypted = decrypt(password, salt, encrypted);</span><br><span class="line">        System.out.println(<span class="string">&quot;decrypted: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] encrypt(String password, <span class="type">byte</span>[] salt, <span class="type">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="type">PBEKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PBEKeySpec</span>(password.toCharArray());</span><br><span class="line">        <span class="type">SecretKeyFactory</span> <span class="variable">skeyFactory</span> <span class="operator">=</span> SecretKeyFactory.getInstance(<span class="string">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">skey</span> <span class="operator">=</span> skeyFactory.generateSecret(keySpec);</span><br><span class="line">        <span class="type">PBEParameterSpec</span> <span class="variable">pbeps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PBEParameterSpec</span>(salt, <span class="number">1000</span>);</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, skey, pbeps);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decrypt(String password, <span class="type">byte</span>[] salt, <span class="type">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="type">PBEKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PBEKeySpec</span>(password.toCharArray());</span><br><span class="line">        <span class="type">SecretKeyFactory</span> <span class="variable">skeyFactory</span> <span class="operator">=</span> SecretKeyFactory.getInstance(<span class="string">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">skey</span> <span class="operator">=</span> skeyFactory.generateSecret(keySpec);</span><br><span class="line">        <span class="type">PBEParameterSpec</span> <span class="variable">pbeps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PBEParameterSpec</span>(salt, <span class="number">1000</span>);</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, skey, pbeps);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用PBE时，我们还需要引入BouncyCastle，并指定算法是<code>PBEwithSHA1and128bitAES-CBC-BC</code>。观察代码，实际上真正的AES密钥是调用<code>Cipher</code>的<code>init()</code>方法时同时传入<code>SecretKey</code>和<code>PBEParameterSpec</code>实现的。在创建<code>PBEParameterSpec</code>的时候，我们还指定了循环次数<code>1000</code>，循环次数越多，暴力破解需要的计算量就越大。</p><p>如果我们把salt和循环次数固定，就得到了一个通用的“口令”加密软件。如果我们把随机生成的salt存储在U盘，就得到了一个“口令”加USB Key的加密软件，它的好处在于，即使用户使用了一个非常弱的口令，没有USB Key仍然无法解密，因为USB Key存储的随机数密钥安全性非常高。</p><h3 id="小结-6">小结</h3><p>PBE算法通过用户口令和安全的随机salt计算出Key，然后再进行加密；</p><p>Key通过口令和安全的随机salt计算得出，大大提高了安全性；</p><p>PBE算法内部使用的仍然是标准对称加密算法（例如AES）。</p><h2 id="密钥交换算法">密钥交换算法</h2><p>对称加密算法解决了数据加密的问题。我们以AES加密为例，在现实世界中，小明要向路人甲发送一个加密文件，他可以先生成一个AES密钥，对文件进行加密，然后把加密文件发送给对方。因为对方要解密，就必须需要小明生成的密钥。</p><p>现在问题来了：如何传递密钥？</p><p>在不安全的信道上传递加密文件是没有问题的，因为黑客拿到加密文件没有用。但是，如何如何在不安全的信道上安全地传输密钥？</p><p>要解决这个问题，密钥交换算法即DH算法：Diffie-Hellman算法应运而生。</p><p>DH算法解决了密钥在双方不直接传递密钥的情况下完成密钥交换，这个神奇的交换原理完全由数学理论支持。</p><p>我们来看DH算法交换密钥的步骤。假设甲乙双方需要传递密钥，他们之间可以这么做：</p><ol><li>甲首先选择一个素数<code>p</code>，例如97，底数<code>g</code>是<code>p</code>的一个原根，例如5，随机数<code>a</code>，例如123，然后计算<code>A=g^a mod p</code>，结果是34，然后，甲发送<code>p＝97</code>，<code>g=5</code>，<code>A=34</code>给乙；</li><li>乙方收到后，也选择一个随机数<code>b</code>，例如，456，然后计算<code>B = g^b mod p</code>，结果是75，乙再同时计算<code>s = A^b mod p</code>，结果是22；</li><li>乙把计算的<code>B=75</code>发给甲，甲计算<code>s ＝ B^a mod p</code>，计算结果与乙算出的结果一样，都是22。</li></ol><p>所以最终双方协商出的密钥<code>s</code>是22。注意到这个密钥<code>s</code>并没有在网络上传输。而通过网络传输的<code>p</code>，<code>g</code>，<code>A</code>和<code>B</code>是无法推算出<code>s</code>的，因为实际算法选择的素数是非常大的。</p><p>所以，更确切地说，DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。</p><p>如果我们把<code>a</code>看成甲的私钥，<code>A</code>看成甲的公钥，<code>b</code>看成乙的私钥，<code>B</code>看成乙的公钥，DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，然后交换公钥，并根据自己的私钥和对方的公钥，生成最终的密钥<code>secretKey</code>，DH算法通过数学定律保证了双方各自计算出的<code>secretKey</code>是相同的。</p><p>使用Java实现DH算法的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyAgreement;</span><br><span class="line"><span class="keyword">import</span> java.util.HexFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Bob和Alice:</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">bob</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">alice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 各自生成KeyPair:</span></span><br><span class="line">        bob.generateKeyPair();</span><br><span class="line">        alice.generateKeyPair();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双方交换各自的PublicKey:</span></span><br><span class="line">        <span class="comment">// Bob根据Alice的PublicKey生成自己的本地密钥:</span></span><br><span class="line">        bob.generateSecretKey(alice.publicKey.getEncoded());</span><br><span class="line">        <span class="comment">// Alice根据Bob的PublicKey生成自己的本地密钥:</span></span><br><span class="line">        alice.generateSecretKey(bob.publicKey.getEncoded());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查双方的本地密钥是否相同:</span></span><br><span class="line">        bob.printKeys();</span><br><span class="line">        alice.printKeys();</span><br><span class="line">        <span class="comment">// 双方的SecretKey相同，后续通信将使用SecretKey作为密钥进行AES加解密...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PublicKey publicKey;</span><br><span class="line">    <span class="keyword">private</span> PrivateKey privateKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成本地KeyPair:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateKeyPair</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">KeyPairGenerator</span> <span class="variable">kpGen</span> <span class="operator">=</span> KeyPairGenerator.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">            kpGen.initialize(<span class="number">512</span>);</span><br><span class="line">            <span class="type">KeyPair</span> <span class="variable">kp</span> <span class="operator">=</span> kpGen.generateKeyPair();</span><br><span class="line">            <span class="built_in">this</span>.privateKey = kp.getPrivate();</span><br><span class="line">            <span class="built_in">this</span>.publicKey = kp.getPublic();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (GeneralSecurityException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateSecretKey</span><span class="params">(<span class="type">byte</span>[] receivedPubKeyBytes)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从byte[]恢复PublicKey:</span></span><br><span class="line">            <span class="type">X509EncodedKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(receivedPubKeyBytes);</span><br><span class="line">            <span class="type">KeyFactory</span> <span class="variable">kf</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">            <span class="type">PublicKey</span> <span class="variable">receivedPublicKey</span> <span class="operator">=</span> kf.generatePublic(keySpec);</span><br><span class="line">            <span class="comment">// 生成本地密钥:</span></span><br><span class="line">            <span class="type">KeyAgreement</span> <span class="variable">keyAgreement</span> <span class="operator">=</span> KeyAgreement.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">            keyAgreement.init(<span class="built_in">this</span>.privateKey); <span class="comment">// 自己的PrivateKey</span></span><br><span class="line">            keyAgreement.doPhase(receivedPublicKey, <span class="literal">true</span>); <span class="comment">// 对方的PublicKey</span></span><br><span class="line">            <span class="comment">// 生成SecretKey密钥:</span></span><br><span class="line">            <span class="built_in">this</span>.secretKey = keyAgreement.generateSecret();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (GeneralSecurityException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printKeys</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;Private key: &quot;</span> + HexFormat.of().formatHex(<span class="built_in">this</span>.privateKey.getEncoded()));</span><br><span class="line">        System.out.println(<span class="string">&quot;Public key: &quot;</span> + HexFormat.of().formatHex(<span class="built_in">this</span>.publicKey.getEncoded()));</span><br><span class="line">        System.out.println(<span class="string">&quot;Secret key: &quot;</span> + HexFormat.of().formatHex(<span class="built_in">this</span>.secretKey));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是DH算法并未解决中间人攻击，即甲乙双方并不能确保与自己通信的是否真的是对方。消除中间人攻击需要其他方法。</p><h3 id="练习-2">练习</h3><p>使用DH算法生成密钥。</p><p><a href="https://liaoxuefeng.com/books/java/security/dh/encrypt-dh.zip">下载练习</a></p><h3 id="小结-7">小结</h3><p>DH算法是一种密钥交换协议，通信双方通过不安全的信道协商密钥，然后进行对称加密传输。</p><p>DH算法没有解决中间人攻击。</p><hr><hr><p>从DH算法我们可以看到，公钥-私钥组成的密钥对是非常有用的加密方式，因为公钥是可以公开的，而私钥是完全保密的，由此奠定了非对称加密的基础。</p><p>非对称加密就是加密和解密使用的不是相同的密钥：只有同一个公钥-私钥对才能正常加解密。</p><p>因此，如果小明要加密一个文件发送给小红，他应该首先向小红索取她的公钥，然后，他用小红的公钥加密，把加密文件发送给小红，此文件只能由小红的私钥解开，因为小红的私钥在她自己手里，所以，除了小红，没有任何人能解开此文件。</p><p>非对称加密的典型算法就是RSA算法，它是由Ron Rivest，Adi Shamir，Leonard Adleman这三个哥们一起发明的，所以用他们仨的姓的首字母缩写表示。</p><p>非对称加密相比对称加密的显著优点在于，对称加密需要协商密钥，而非对称加密可以安全地公开各自的公钥，在N个人之间通信的时候：使用非对称加密只需要N个密钥对，每个人只管理自己的密钥对。而使用对称加密需要则需要<code>N*(N-1)/2</code>个密钥，因此每个人需要管理<code>N-1</code>个密钥，密钥管理难度大，而且非常容易泄漏。</p><p>既然非对称加密这么好，那我们抛弃对称加密，完全使用非对称加密行不行？也不行。因为非对称加密的缺点就是运算速度非常慢，比对称加密要慢很多。</p><p>所以，在实际应用的时候，非对称加密总是和对称加密一起使用。假设小明需要给小红需要传输加密文件，他俩首先交换了各自的公钥，然后：</p><ol><li>小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红；</li><li>小红用自己的RSA私钥解密得到AES口令；</li><li>双方使用这个共享的AES口令用AES加密通信。</li></ol><p>可见非对称加密实际上应用在第一步，即加密“AES口令”。这也是我们在浏览器中常用的HTTPS协议的做法，即浏览器和服务器先通过RSA交换AES口令，接下来双方通信实际上采用的是速度较快的AES对称加密，而不是缓慢的RSA非对称加密。</p><p>Java标准库提供了RSA算法的实现，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> java.util.HexFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 明文:</span></span><br><span class="line">        <span class="type">byte</span>[] plain = <span class="string">&quot;Hello, encrypt use RSA&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建公钥／私钥对:</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">alice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        <span class="comment">// 用Alice的公钥加密:</span></span><br><span class="line">        <span class="type">byte</span>[] pk = alice.getPublicKey();</span><br><span class="line">        System.out.println(<span class="string">&quot;public key: &quot;</span> + HexFormat.of().formatHex(pk));</span><br><span class="line">        <span class="type">byte</span>[] encrypted = alice.encrypt(plain);</span><br><span class="line">        System.out.println(<span class="string">&quot;encrypted: &quot;</span> + HexFormat.of().formatHex(encrypted));</span><br><span class="line">        <span class="comment">// 用Alice的私钥解密:</span></span><br><span class="line">        <span class="type">byte</span>[] sk = alice.getPrivateKey();</span><br><span class="line">        System.out.println(<span class="string">&quot;private key: &quot;</span> + HexFormat.of().formatHex(sk));</span><br><span class="line">        <span class="type">byte</span>[] decrypted = alice.decrypt(encrypted);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">// 私钥:</span></span><br><span class="line">    PrivateKey sk;</span><br><span class="line">    <span class="comment">// 公钥:</span></span><br><span class="line">    PublicKey pk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="comment">// 生成公钥／私钥对:</span></span><br><span class="line">        <span class="type">KeyPairGenerator</span> <span class="variable">kpGen</span> <span class="operator">=</span> KeyPairGenerator.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        kpGen.initialize(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">kp</span> <span class="operator">=</span> kpGen.generateKeyPair();</span><br><span class="line">        <span class="built_in">this</span>.sk = kp.getPrivate();</span><br><span class="line">        <span class="built_in">this</span>.pk = kp.getPublic();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把私钥导出为字节</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] getPrivateKey() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.sk.getEncoded();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把公钥导出为字节</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] getPublicKey() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.pk.getEncoded();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用公钥加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] encrypt(<span class="type">byte</span>[] message) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, <span class="built_in">this</span>.pk);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用私钥解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] decrypt(<span class="type">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, <span class="built_in">this</span>.sk);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RSA的公钥和私钥都可以通过<code>getEncoded()</code>方法获得以<code>byte[]</code>表示的二进制数据，并根据需要保存到文件中。要从<code>byte[]</code>数组恢复公钥或私钥，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] pkData = ...</span><br><span class="line"><span class="type">byte</span>[] skData = ...</span><br><span class="line"><span class="type">KeyFactory</span> <span class="variable">kf</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line"><span class="comment">// 恢复公钥:</span></span><br><span class="line"><span class="type">X509EncodedKeySpec</span> <span class="variable">pkSpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(pkData);</span><br><span class="line"><span class="type">PublicKey</span> <span class="variable">pk</span> <span class="operator">=</span> kf.generatePublic(pkSpec);</span><br><span class="line"><span class="comment">// 恢复私钥:</span></span><br><span class="line"><span class="type">PKCS8EncodedKeySpec</span> <span class="variable">skSpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(skData);</span><br><span class="line"><span class="type">PrivateKey</span> <span class="variable">sk</span> <span class="operator">=</span> kf.generatePrivate(skSpec);</span><br></pre></td></tr></table></figure><p>以RSA算法为例，它的密钥有256/512/1024/2048/4096等不同的长度。长度越长，密码强度越大，当然计算速度也越慢。</p><p>如果修改待加密的<code>byte[]</code>数据的大小，可以发现，使用512bit的RSA加密时，明文长度不能超过53字节，使用1024bit的RSA加密时，明文长度不能超过117字节，这也是为什么使用RSA的时候，总是配合AES一起使用，即用AES加密任意长度的明文，用RSA加密AES口令。</p><p>此外，只使用非对称加密算法不能防止中间人攻击。</p><h3 id="练习-3">练习</h3><p>使用RSA算法加密。</p><p><a href="https://liaoxuefeng.com/books/java/security/rsa/encrypt-rsa.zip">下载练习</a></p><h3 id="小结-8">小结</h3><p>非对称加密就是加密和解密使用的不是相同的密钥，只有同一个公钥-私钥对才能正常加解密；</p><p>只使用非对称加密算法不能防止中间人攻击。</p><h2 id="签名算法">签名算法</h2><p>我们使用非对称加密算法的时候，对于一个公钥-私钥对，通常是用公钥加密，私钥解密。</p><p>如果使用私钥加密，公钥解密是否可行呢？实际上是完全可行的。</p><p>不过我们再仔细想一想，私钥是保密的，而公钥是公开的，用私钥加密，那相当于所有人都可以用公钥解密。这个加密有什么意义？</p><p>这个加密的意义在于，如果小明用自己的私钥加密了一条消息，比如<code>小明喜欢小红</code>，然后他公开了加密消息，由于任何人都可以用小明的公钥解密，从而使得任何人都可以确认<code>小明喜欢小红</code>这条消息肯定是小明发出的，其他人不能伪造这个消息，小明也不能抵赖这条消息不是自己写的。</p><p>因此，私钥加密得到的密文实际上就是数字签名，要验证这个签名是否正确，只能用私钥持有者的公钥进行解密验证。使用数字签名的目的是为了确认某个信息确实是由某个发送方发送的，任何人都不可能伪造消息，并且，发送方也不能抵赖。</p><p>在实际应用的时候，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signature = encrypt(privateKey, sha256(message))</span><br></pre></td></tr></table></figure><p>对签名进行验证实际上就是用公钥解密：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash = decrypt(publicKey, signature)</span><br></pre></td></tr></table></figure><p>然后把解密后的哈希与原始消息的哈希进行对比。</p><p>因为用户总是使用自己的私钥进行签名，所以，私钥就相当于用户身份。而公钥用来给外部验证用户身份。</p><p>常用数字签名算法有：</p><ul><li>MD5withRSA</li><li>SHA1withRSA</li><li>SHA256withRSA</li></ul><p>它们实际上就是指定某种哈希算法进行RSA签名的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HexFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="comment">// 生成RSA公钥/私钥:</span></span><br><span class="line">        <span class="type">KeyPairGenerator</span> <span class="variable">kpGen</span> <span class="operator">=</span> KeyPairGenerator.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        kpGen.initialize(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">kp</span> <span class="operator">=</span> kpGen.generateKeyPair();</span><br><span class="line">        <span class="type">PrivateKey</span> <span class="variable">sk</span> <span class="operator">=</span> kp.getPrivate();</span><br><span class="line">        <span class="type">PublicKey</span> <span class="variable">pk</span> <span class="operator">=</span> kp.getPublic();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待签名的消息:</span></span><br><span class="line">        <span class="type">byte</span>[] message = <span class="string">&quot;Hello, I am Bob!&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用私钥签名:</span></span><br><span class="line">        <span class="type">Signature</span> <span class="variable">s</span> <span class="operator">=</span> Signature.getInstance(<span class="string">&quot;SHA1withRSA&quot;</span>);</span><br><span class="line">        s.initSign(sk);</span><br><span class="line">        s.update(message);</span><br><span class="line">        <span class="type">byte</span>[] signed = s.sign();</span><br><span class="line">        System.out.println(<span class="string">&quot;signature: &quot;</span> + HexFormat.of().formatHex(signed));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用公钥验证:</span></span><br><span class="line">        <span class="type">Signature</span> <span class="variable">v</span> <span class="operator">=</span> Signature.getInstance(<span class="string">&quot;SHA1withRSA&quot;</span>);</span><br><span class="line">        v.initVerify(pk);</span><br><span class="line">        v.update(message);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> v.verify(signed);</span><br><span class="line">        System.out.println(<span class="string">&quot;valid? &quot;</span> + valid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用其他公钥，或者验证签名的时候修改原始信息，都无法验证成功。</p><h3 id="DSA签名">DSA签名</h3><p>除了RSA可以签名外，还可以使用DSA算法进行签名。DSA是Digital Signature Algorithm的缩写，它使用ElGamal数字签名算法。</p><p>DSA只能配合SHA使用，常用的算法有：</p><ul><li>SHA1withDSA</li><li>SHA256withDSA</li><li>SHA512withDSA</li></ul><p>和RSA数字签名相比，DSA的优点是更快。</p><h3 id="ECDSA签名">ECDSA签名</h3><p>椭圆曲线签名算法ECDSA：Elliptic Curve Digital Signature Algorithm也是一种常用的签名算法，它的特点是可以从私钥推出公钥。比特币的签名算法就采用了ECDSA算法，使用标准椭圆曲线secp256k1。BouncyCastle提供了ECDSA的完整实现。</p><h3 id="练习-4">练习</h3><p>使用RSA算法进行签名。</p><p><a href="https://liaoxuefeng.com/books/java/security/sign/encrypt-rsasign.zip">下载练习</a></p><h3 id="小结-9">小结</h3><p>数字签名就是用发送方的私钥对原始数据进行签名，只有用发送方公钥才能通过签名验证。</p><p>数字签名用于：</p><ul><li>防止伪造；</li><li>防止抵赖；</li><li>检测篡改。</li></ul><p>常用的数字签名算法包括：MD5withRSA／SHA1withRSA／SHA256withRSA／SHA1withDSA／SHA256withDSA／SHA512withDSA／ECDSA等。</p><hr><hr><p>我们知道，摘要算法用来确保数据没有被篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。</p><p>因此，数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。</p><p>数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的。</p><p>我们在上网时常用的HTTPS协议就是数字证书的应用。浏览器会自动验证证书的有效性：</p><p><img src="https://liaoxuefeng.com/books/java/security/cert/https.jpg" alt="certificate"></p><p>要使用数字证书，首先需要创建证书。正常情况下，一个合法的数字证书需要经过CA签名，这需要认证域名并支付一定的费用。开发的时候，我们可以使用自签名的证书，这种证书可以正常开发调试，但不能对外作为服务使用，因为其他客户端并不认可未经CA签名的证书。</p><p>注：<a href="https://cloud.tencent.com/">腾讯云</a>可申请有效期1年的免费SSL证书，<a href="https://letsencrypt.org/">Let’s Encrypt</a>可申请有效期90天的免费SSL证书。</p><p>在Java程序中，数字证书存储在一种Java专用的key store文件中，JDK提供了一系列命令来创建和管理key store。我们用下面的命令创建一个key store，并设定口令123456：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -storepass 123456 -genkeypair -keyalg RSA -keysize 1024 -sigalg SHA1withRSA -validity 3650 -alias mycert -keystore my.keystore -dname &quot;CN=www.sample.com, OU=sample, O=sample, L=BJ, ST=BJ, C=CN&quot;</span><br></pre></td></tr></table></figure><p>几个主要的参数是：</p><ul><li>keyalg：指定RSA加密算法；</li><li>sigalg：指定SHA1withRSA签名算法；</li><li>validity：指定证书有效期3650天；</li><li>alias：指定证书在程序中引用的名称；</li><li>dname：最重要的<code>CN=www.sample.com</code>指定了<code>Common Name</code>，如果证书用在HTTPS中，这个名称必须与域名完全一致。</li></ul><p>执行上述命令，JDK会在当前目录创建一个<code>my.keystore</code>文件，并存储创建成功的一个私钥和一个证书，它的别名是<code>mycert</code>。</p><p>有了key store存储的证书，我们就可以通过数字证书进行加解密和签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> java.util.HexFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] message = <span class="string">&quot;Hello, use X.509 cert!&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 读取KeyStore:</span></span><br><span class="line">        <span class="type">KeyStore</span> <span class="variable">ks</span> <span class="operator">=</span> loadKeyStore(<span class="string">&quot;/my.keystore&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">// 读取私钥:</span></span><br><span class="line">        <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> (PrivateKey) ks.getKey(<span class="string">&quot;mycert&quot;</span>, <span class="string">&quot;123456&quot;</span>.toCharArray());</span><br><span class="line">        <span class="comment">// 读取证书:</span></span><br><span class="line">        <span class="type">X509Certificate</span> <span class="variable">certificate</span> <span class="operator">=</span> (X509Certificate) ks.getCertificate(<span class="string">&quot;mycert&quot;</span>);</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="type">byte</span>[] encrypted = encrypt(certificate, message);</span><br><span class="line">        System.out.println(<span class="string">&quot;encrypted: &quot;</span> + HexFormat.of().formatHex(encrypted));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="type">byte</span>[] decrypted = decrypt(privateKey, encrypted);</span><br><span class="line">        System.out.println(<span class="string">&quot;decrypted: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="comment">// 签名:</span></span><br><span class="line">        <span class="type">byte</span>[] sign = sign(privateKey, certificate, message);</span><br><span class="line">        System.out.println(<span class="string">&quot;signature: &quot;</span> + HexFormat.of().formatHex(sign));</span><br><span class="line">        <span class="comment">// 验证签名:</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">verified</span> <span class="operator">=</span> verify(certificate, message, sign);</span><br><span class="line">        System.out.println(<span class="string">&quot;verify: &quot;</span> + verified);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> KeyStore <span class="title function_">loadKeyStore</span><span class="params">(String keyStoreFile, String password)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> Main.class.getResourceAsStream(keyStoreFile)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;file not found in classpath: &quot;</span> + keyStoreFile);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">KeyStore</span> <span class="variable">ks</span> <span class="operator">=</span> KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class="line">            ks.load(input, password.toCharArray());</span><br><span class="line">            <span class="keyword">return</span> ks;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] encrypt(X509Certificate certificate, <span class="type">byte</span>[] message) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(certificate.getPublicKey().getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, certificate.getPublicKey());</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] decrypt(PrivateKey privateKey, <span class="type">byte</span>[] data) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(privateKey.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] sign(PrivateKey privateKey, X509Certificate certificate, <span class="type">byte</span>[] message)</span><br><span class="line">            <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> Signature.getInstance(certificate.getSigAlgName());</span><br><span class="line">        signature.initSign(privateKey);</span><br><span class="line">        signature.update(message);</span><br><span class="line">        <span class="keyword">return</span> signature.sign();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">verify</span><span class="params">(X509Certificate certificate, <span class="type">byte</span>[] message, <span class="type">byte</span>[] sig)</span> <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> Signature.getInstance(certificate.getSigAlgName());</span><br><span class="line">        signature.initVerify(certificate);</span><br><span class="line">        signature.update(message);</span><br><span class="line">        <span class="keyword">return</span> signature.verify(sig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们从key store直接读取了私钥-公钥对，私钥以<code>PrivateKey</code>实例表示，公钥以<code>X509Certificate</code>表示，实际上数字证书只包含公钥，因此，读取证书并不需要口令，只有读取私钥才需要。如果部署到Web服务器上，例如Nginx，需要把私钥导出为Private Key格式，把证书导出为X509Certificate格式。</p><p>以HTTPS协议为例，浏览器和服务器建立安全连接的步骤如下：</p><ol><li>浏览器向服务器发起请求，服务器向浏览器发送自己的数字证书；</li><li>浏览器用操作系统内置的Root CA来验证服务器的证书是否有效，如果有效，就使用该证书加密一个随机的AES口令并发送给服务器；</li><li>服务器用自己的私钥解密获得AES口令，并在后续通讯中使用AES加密。</li></ol><p>上述流程只是一种最常见的单向验证。如果服务器还要验证客户端，那么客户端也需要把自己的证书发送给服务器验证，这种场景常见于网银等。</p><p>注意：数字证书存储的是公钥，以及相关的证书链和算法信息。私钥必须严格保密，如果数字证书对应的私钥泄漏，就会造成严重的安全威胁。如果CA证书的私钥泄漏，那么该CA证书签发的所有证书将不可信。数字证书服务商<a href="https://en.wikipedia.org/wiki/DigiNotar">DigiNotar</a>就发生过私钥泄漏导致公司破产的事故。</p><h3 id="练习-5">练习</h3><p>使用数字证书实现消息加密。</p><p><a href="https://liaoxuefeng.com/books/java/security/cert/encrypt-cert.zip">下载练习</a></p><h3 id="小结-10">小结</h3><p>数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准；</p><p>数字证书采用链式签名管理，顶级的Root CA证书已内置在操作系统中；</p><p>数字证书存储的是公钥，可以安全公开，而私钥必须严格保密。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-正则表达式</title>
      <link href="/2025/05/24/JAVA-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2025/05/24/JAVA-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式简介">正则表达式简介</h2><p>在了解正则表达式之前，我们先看几个非常常见的问题：</p><ul><li>如何判断字符串是否是有效的电话号码？例如：<code>010-1234567</code>，<code>123ABC456</code>，<code>13510001000</code>等；</li><li>如何判断字符串是否是有效的电子邮件地址？例如：<code>test@example.com</code>，<code>test#example</code>等；</li><li>如何判断字符串是否是有效的时间？例如：<code>12:34</code>，<code>09:60</code>，<code>99:99</code>等。</li></ul><p>一种直观的想法是通过程序判断，这种方法需要为每种用例创建规则，然后用代码实现。下面是判断手机号的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isValidMobileNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// 是否是11位？</span></span><br><span class="line">    <span class="keyword">if</span> (s.length() != <span class="number">11</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每一位都是0~9：</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码仅仅做了非常粗略的判断，并未考虑首位数字不能为<code>0</code>等更详细的情况。</p><p>除了判断手机号，我们还需要判断电子邮件地址、电话、邮编等等：</p><ul><li>boolean isValidMobileNumber(String s) { … }</li><li>boolean isValidEmail(String s) { … }</li><li>boolean isValidPhoneNumber(String s) { … }</li><li>boolean isValidZipCode(String s) { … }</li><li>…</li></ul><p>为每一种判断逻辑编写代码实在是太繁琐了。有没有更简单的方法？</p><p>有！用正则表达式！</p><p>正则表达式可以用字符串来描述规则，并用来匹配字符串。例如，判断手机号，我们用正则表达式<code>\d&#123;11&#125;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isValidMobileNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.matches(<span class="string">&quot;\\d&#123;11&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用正则表达式的好处有哪些？一个正则表达式就是一个描述规则的字符串，所以，只需要编写正确的规则，我们就可以让正则表达式引擎去判断目标字符串是否符合规则。</p><p>正则表达式是一套标准，它可以用于任何语言。Java标准库的<code>java.util.regex</code>包内置了正则表达式引擎，在Java程序中使用正则表达式非常简单。</p><p>举个例子：要判断用户输入的年份是否是<code>20##</code>年，我们先写出规则如下：</p><p>一共有4个字符，分别是：<code>2</code>，<code>0</code>，<code>0~9任意数字</code>，<code>0~9任意数字</code>。</p><p>对应的正则表达式就是：<code>20\d\d</code>，其中<code>\d</code>表示任意一个数字。</p><p>把正则表达式转换为Java字符串就变成了<code>20\\d\\d</code>，注意Java字符串用<code>\\</code>表示<code>\</code>。</p><p>最后，用正则表达式匹配一个字符串的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// regex</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;20\\d\\d&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;2019&quot;</span>.matches(regex)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2100&quot;</span>.matches(regex)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，使用正则表达式，不必编写复杂的代码来判断，只需给出一个字符串表达的正则规则即可。</p><h3 id="小结">小结</h3><p>正则表达式是用字符串描述的一个匹配规则，使用正则表达式可以快速判断给定的字符串是否符合匹配规则；</p><p>Java标准库<code>java.util.regex</code>内建了正则表达式引擎。</p><hr><hr><p>正则表达式的匹配规则是从左到右按规则匹配。我们首先来看如何使用正则表达式来做精确匹配。</p><p>对于正则表达式<code>abc</code>来说，它只能精确地匹配字符串<code>&quot;abc&quot;</code>，不能匹配<code>&quot;ab&quot;</code>，<code>&quot;Abc&quot;</code>，<code>&quot;abcd&quot;</code>等其他任何字符串。</p><p>如果正则表达式有特殊字符，那就需要用<code>\</code>转义。例如，正则表达式<code>a\&amp;c</code>，其中<code>\&amp;</code>是用来匹配特殊字符<code>&amp;</code>的，它能精确匹配字符串<code>&quot;a&amp;c&quot;</code>，但不能匹配<code>&quot;ac&quot;</code>、<code>&quot;a-c&quot;</code>、<code>&quot;a&amp;&amp;c&quot;</code>等。</p><p>要注意正则表达式在Java代码中也是一个字符串，所以，对于正则表达式<code>a\&amp;c</code>来说，对应的Java字符串是<code>&quot;a\\&amp;c&quot;</code>，因为<code>\</code>也是Java字符串的转义字符，两个<code>\\</code>实际上表示的是一个<code>\</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// regex</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">re1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.matches(re1));</span><br><span class="line">        System.out.println(<span class="string">&quot;Abc&quot;</span>.matches(re1));</span><br><span class="line">        System.out.println(<span class="string">&quot;abcd&quot;</span>.matches(re1));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">re2</span> <span class="operator">=</span> <span class="string">&quot;a\\&amp;c&quot;</span>; <span class="comment">// 对应的正则是a\&amp;c</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a&amp;c&quot;</span>.matches(re2));</span><br><span class="line">        System.out.println(<span class="string">&quot;a-c&quot;</span>.matches(re2));</span><br><span class="line">        System.out.println(<span class="string">&quot;a&amp;&amp;c&quot;</span>.matches(re2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想匹配非ASCII字符，例如中文，那就用<code>\u####</code>的十六进制表示，例如：<code>a\u548cc</code>匹配字符串<code>&quot;a和c&quot;</code>，中文字符<code>和</code>的Unicode编码是<code>548c</code>。</p><h3 id="匹配任意字符">匹配任意字符</h3><p>精确匹配实际上用处不大，因为我们直接用<code>String.equals()</code>就可以做到。大多数情况下，我们想要的匹配规则更多的是模糊匹配。我们可以用<code>.</code>匹配一个任意字符。</p><p>例如，正则表达式<code>a.c</code>中间的<code>.</code>可以匹配一个任意字符，例如，下面的字符串都可以被匹配：</p><ul><li><code>&quot;abc&quot;</code>，因为<code>.</code>可以匹配字符<code>b</code>；</li><li><code>&quot;a&amp;c&quot;</code>，因为<code>.</code>可以匹配字符<code>&amp;</code>；</li><li><code>&quot;acc&quot;</code>，因为<code>.</code>可以匹配字符<code>c</code>。</li></ul><p>但它不能匹配<code>&quot;ac&quot;</code>、<code>&quot;a&amp;&amp;c&quot;</code>，因为<code>.</code>匹配一个字符且仅限一个字符。</p><h3 id="匹配数字">匹配数字</h3><p>用<code>.</code>可以匹配任意字符，这个口子开得有点大。如果我们只想匹配<code>0</code>~<code>9</code>这样的数字，可以用<code>\d</code>匹配。例如，正则表达式<code>00\d</code>可以匹配：</p><ul><li><code>&quot;007&quot;</code>，因为<code>\d</code>可以匹配字符<code>7</code>；</li><li><code>&quot;008&quot;</code>，因为<code>\d</code>可以匹配字符<code>8</code>。</li></ul><p>它不能匹配<code>&quot;00A&quot;</code>，<code>&quot;0077&quot;</code>，因为<code>\d</code>仅限单个数字字符。</p><h3 id="匹配常用字符">匹配常用字符</h3><p>用<code>\w</code>可以匹配一个字母、数字或下划线，w的意思是word。例如，<code>java\w</code>可以匹配：</p><ul><li><code>&quot;javac&quot;</code>，因为<code>\w</code>可以匹配英文字符<code>c</code>；</li><li><code>&quot;java9&quot;</code>，因为<code>\w</code>可以匹配数字字符<code>9</code>；。</li><li><code>&quot;java_&quot;</code>，因为<code>\w</code>可以匹配下划线<code>_</code>。</li></ul><p>它不能匹配<code>&quot;java#&quot;</code>，<code>&quot;java &quot;</code>，因为<code>\w</code>不能匹配<code>#</code>、空格等字符。</p><h3 id="匹配空格字符">匹配空格字符</h3><p>用<code>\s</code>可以匹配一个空格字符，注意空格字符不但包括空格 ，还包括tab字符（在Java中用<code>\t</code>表示）。例如，<code>a\sc</code>可以匹配：</p><ul><li><code>&quot;a c&quot;</code>，因为<code>\s</code>可以匹配空格字符 ；</li><li><code>&quot;a c&quot;</code>，因为<code>\s</code>可以匹配tab字符<code>\t</code>。</li></ul><p>它不能匹配<code>&quot;ac&quot;</code>，<code>&quot;abc&quot;</code>等。</p><h3 id="匹配非数字">匹配非数字</h3><p>用<code>\d</code>可以匹配一个数字，而<code>\D</code>则匹配一个非数字。例如，<code>00\D</code>可以匹配：</p><ul><li><code>&quot;00A&quot;</code>，因为<code>\D</code>可以匹配非数字字符<code>A</code>；</li><li><code>&quot;00#&quot;</code>，因为<code>\D</code>可以匹配非数字字符<code>#</code>。</li></ul><p><code>00\d</code>可以匹配的字符串<code>&quot;007&quot;</code>，<code>&quot;008&quot;</code>等，<code>00\D</code>是不能匹配的。</p><p>类似的，<code>\W</code>可以匹配<code>\w</code>不能匹配的字符，<code>\S</code>可以匹配<code>\s</code>不能匹配的字符，这几个正好是反着来的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// regex</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">re1</span> <span class="operator">=</span> <span class="string">&quot;java\\d&quot;</span>; <span class="comment">// 对应的正则是java\d</span></span><br><span class="line">        System.out.println(<span class="string">&quot;java9&quot;</span>.matches(re1));</span><br><span class="line">        System.out.println(<span class="string">&quot;java10&quot;</span>.matches(re1));</span><br><span class="line">        System.out.println(<span class="string">&quot;javac&quot;</span>.matches(re1));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">re2</span> <span class="operator">=</span> <span class="string">&quot;java\\D&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;javax&quot;</span>.matches(re2));</span><br><span class="line">        System.out.println(<span class="string">&quot;java#&quot;</span>.matches(re2));</span><br><span class="line">        System.out.println(<span class="string">&quot;java5&quot;</span>.matches(re2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重复匹配">重复匹配</h3><p>我们用<code>\d</code>可以匹配一个数字，例如，<code>A\d</code>可以匹配<code>&quot;A0&quot;</code>，<code>&quot;A1&quot;</code>，如果要匹配多个数字，比如<code>&quot;A380&quot;</code>，怎么办？</p><p>修饰符<code>*</code>可以匹配任意个字符，包括0个字符。我们用<code>A\d*</code>可以匹配：</p><ul><li><code>A</code>：因为<code>\d*</code>可以匹配0个数字；</li><li><code>A0</code>：因为<code>\d*</code>可以匹配1个数字<code>0</code>；</li><li><code>A380</code>：因为<code>\d*</code>可以匹配多个数字<code>380</code>。</li></ul><p>修饰符<code>+</code>可以匹配至少一个字符。我们用<code>A\d+</code>可以匹配：</p><ul><li><code>A0</code>：因为<code>\d+</code>可以匹配1个数字<code>0</code>；</li><li><code>A380</code>：因为<code>\d+</code>可以匹配多个数字<code>380</code>。</li></ul><p>但它无法匹配<code>&quot;A&quot;</code>，因为修饰符<code>+</code>要求至少一个字符。</p><p>修饰符<code>?</code>可以匹配0个或一个字符。我们用<code>A\d?</code>可以匹配：</p><ul><li><code>A</code>：因为<code>\d?</code>可以匹配0个数字；</li><li><code>A0</code>：因为<code>\d?</code>可以匹配1个数字<code>0</code>。</li></ul><p>但它无法匹配<code>&quot;A380&quot;</code>，因为修饰符<code>?</code>超过1个字符就不能匹配了。</p><p>如果我们想精确指定n个字符怎么办？用修饰符<code>&#123;n&#125;</code>就可以。<code>A\d&#123;3&#125;</code>可以精确匹配：</p><ul><li><code>A380</code>：因为<code>\d&#123;3&#125;</code>可以匹配3个数字<code>380</code>。</li></ul><p>如果我们想指定匹配n~m个字符怎么办？用修饰符<code>&#123;n,m&#125;</code>就可以。<code>A\d&#123;3,5&#125;</code>可以精确匹配：</p><ul><li><code>A380</code>：因为<code>\d&#123;3,5&#125;</code>可以匹配3个数字<code>380</code>；</li><li><code>A3800</code>：因为<code>\d&#123;3,5&#125;</code>可以匹配4个数字<code>3800</code>；</li><li><code>A38000</code>：因为<code>\d&#123;3,5&#125;</code>可以匹配5个数字<code>38000</code>。</li></ul><p>如果没有上限，那么修饰符<code>&#123;n,&#125;</code>就可以匹配至少n个字符。</p><h3 id="练习">练习</h3><p>请编写一个正则表达式匹配国内的电话号码规则：3~4位区号加7~8位电话，中间用<code>-</code>连接，例如：<code>010-12345678</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// regex</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">re</span> <span class="operator">=</span> <span class="string">&quot;\\d&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (String s : List.of(<span class="string">&quot;010-12345678&quot;</span>, <span class="string">&quot;020-9999999&quot;</span>, <span class="string">&quot;0755-7654321&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!s.matches(re)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;测试失败: &quot;</span> + s);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String s : List.of(<span class="string">&quot;010 12345678&quot;</span>, <span class="string">&quot;A20-9999999&quot;</span>, <span class="string">&quot;0755-7654.321&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.matches(re)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;测试失败: &quot;</span> + s);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试成功!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/reg-exp/match-rules/regex-tel.zip">下载练习</a></p><p>进阶：国内区号必须以0开头，而电话号码不能以0开头，试修改正则表达式，使之能更精确地匹配。</p><p>提示：<code>\d</code>和<code>\D</code>这种简单的规则暂时做不到，我们需要更复杂规则，后面会详细讲解。</p><h3 id="小结-2">小结</h3><p>单个字符的匹配规则如下：</p><table><thead><tr><th>正则表达式</th><th>规则</th><th>可以匹配</th></tr></thead><tbody><tr><td><code>A</code></td><td>指定字符</td><td><code>A</code></td></tr><tr><td><code>\u548c</code></td><td>指定Unicode字符</td><td><code>和</code></td></tr><tr><td><code>.</code></td><td>任意字符</td><td><code>a</code>，<code>b</code>，<code>&amp;</code>，<code>0</code></td></tr><tr><td><code>\d</code></td><td>数字0~9</td><td><code>0</code>~<code>9</code></td></tr><tr><td><code>\w</code></td><td>大小写字母，数字和下划线</td><td><code>a</code>~<code>z</code>，<code>A</code>~<code>Z</code>，<code>0</code>~<code>9</code>，<code>_</code></td></tr><tr><td><code>\s</code></td><td>空格、Tab键</td><td>空格，Tab</td></tr><tr><td><code>\D</code></td><td>非数字</td><td><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td></tr><tr><td><code>\W</code></td><td>非\w</td><td><code>&amp;</code>，<code>@</code>，<code>中</code>，……</td></tr><tr><td><code>\S</code></td><td>非\s</td><td><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td></tr></tbody></table><p>多个字符的匹配规则如下：</p><table><thead><tr><th>正则表达式</th><th>规则</th><th>可以匹配</th></tr></thead><tbody><tr><td><code>A*</code></td><td>任意个数字符</td><td>空，<code>A</code>，<code>AA</code>，<code>AAA</code>，……</td></tr><tr><td><code>A+</code></td><td>至少1个字符</td><td><code>A</code>，<code>AA</code>，<code>AAA</code>，……</td></tr><tr><td><code>A?</code></td><td>0个或1个字符</td><td>空，<code>A</code></td></tr><tr><td><code>A&#123;3&#125;</code></td><td>指定个数字符</td><td><code>AAA</code></td></tr><tr><td><code>A&#123;2,3&#125;</code></td><td>指定范围个数字符</td><td><code>AA</code>，<code>AAA</code></td></tr><tr><td><code>A&#123;2,&#125;</code></td><td>至少n个字符</td><td><code>AA</code>，<code>AAA</code>，<code>AAAA</code>，……</td></tr><tr><td><code>A&#123;0,3&#125;</code></td><td>最多n个字符</td><td>空，<code>A</code>，<code>AA</code>，<code>AAA</code></td></tr></tbody></table><h2 id="复杂匹配规则">复杂匹配规则</h2><h3 id="匹配开头和结尾">匹配开头和结尾</h3><p>用正则表达式进行多行匹配时，我们用<code>^</code>表示开头，<code>$</code>表示结尾。例如，<code>^A\d&#123;3&#125;$</code>，可以匹配<code>&quot;A001&quot;</code>、<code>&quot;A380&quot;</code>。</p><h3 id="匹配指定范围">匹配指定范围</h3><p>如果我们规定一个7~8位数字的电话号码不能以<code>0</code>开头，应该怎么写匹配规则呢？<code>\d&#123;7,8&#125;</code>是不行的，因为第一个<code>\d</code>可以匹配到<code>0</code>。</p><p>使用<code>[...]</code>可以匹配范围内的字符，例如，<code>[123456789]</code>可以匹配<code>1</code>~<code>9</code>，这样就可以写出上述电话号码的规则：<code>[123456789]\d&#123;6,7&#125;</code>。</p><p>把所有字符全列出来太麻烦，<code>[...]</code>还有一种写法，直接写<code>[1-9]</code>就可以。</p><p>要匹配大小写不限的十六进制数，比如<code>1A2b3c</code>，我们可以这样写：<code>[0-9a-fA-F]</code>，它表示一共可以匹配以下任意范围的字符：</p><ul><li><code>0-9</code>：字符<code>0</code>~<code>9</code>；</li><li><code>a-f</code>：字符<code>a</code>~<code>f</code>；</li><li><code>A-F</code>：字符<code>A</code>~<code>F</code>。</li></ul><p>如果要匹配6位十六进制数，前面讲过的<code>&#123;n&#125;</code>仍然可以继续配合使用：<code>[0-9a-fA-F]&#123;6&#125;</code>。</p><p><code>[...]</code>还有一种排除法，即不包含指定范围的字符。假设我们要匹配任意字符，但不包括数字，可以写<code>[^1-9]&#123;3&#125;</code>：</p><ul><li>可以匹配<code>&quot;ABC&quot;</code>，因为不包含字符<code>1</code>~<code>9</code>；</li><li>可以匹配<code>&quot;A00&quot;</code>，因为不包含字符<code>1</code>~<code>9</code>；</li><li>不能匹配<code>&quot;A01&quot;</code>，因为包含字符<code>1</code>；</li><li>不能匹配<code>&quot;A05&quot;</code>，因为包含字符<code>5</code>。</li></ul><h3 id="或规则匹配">或规则匹配</h3><p>用<code>|</code>连接的两个正则规则是<em>或</em>规则，例如，<code>AB|CD</code>表示可以匹配<code>AB</code>或<code>CD</code>。</p><p>我们来看这个正则表达式<code>java|php</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// regex</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">re</span> <span class="operator">=</span> <span class="string">&quot;java|php&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;java&quot;</span>.matches(re));</span><br><span class="line">        System.out.println(<span class="string">&quot;php&quot;</span>.matches(re));</span><br><span class="line">        System.out.println(<span class="string">&quot;go&quot;</span>.matches(re));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以匹配<code>&quot;java&quot;</code>或<code>&quot;php&quot;</code>，但无法匹配<code>&quot;go&quot;</code>。</p><p>要把<code>go</code>也加进来匹配，可以改写为<code>java|php|go</code>。</p><h3 id="使用括号">使用括号</h3><p>现在我们想要匹配字符串<code>learn java</code>、<code>learn php</code>和<code>learn go</code>怎么办？一个最简单的规则是<code>learn\sjava|learn\sphp|learn\sgo</code>，但是这个规则太复杂了，可以把公共部分提出来，然后用<code>(...)</code>把子规则括起来表示成<code>learn\s(java|php|go)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// regex</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">re</span> <span class="operator">=</span> <span class="string">&quot;learn\\s(java|php|go)&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;learn java&quot;</span>.matches(re));</span><br><span class="line">        System.out.println(<span class="string">&quot;learn Java&quot;</span>.matches(re));</span><br><span class="line">        System.out.println(<span class="string">&quot;learn php&quot;</span>.matches(re));</span><br><span class="line">        System.out.println(<span class="string">&quot;learn Go&quot;</span>.matches(re));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的规则仍然不能匹配<code>learn Java</code>、<code>learn Go</code>这样的字符串。试修改正则，使之能匹配大写字母开头的<code>learn Java</code>、<code>learn Php</code>、<code>learn Go</code>。</p><h3 id="小结-3">小结</h3><p>复杂匹配规则主要有：</p><table><thead><tr><th>正则表达式</th><th>规则</th><th>可以匹配</th></tr></thead><tbody><tr><td>^</td><td>开头</td><td>字符串开头</td></tr><tr><td>$</td><td>结尾</td><td>字符串结束</td></tr><tr><td>[ABC]</td><td>[…]内任意字符</td><td>A，B，C</td></tr><tr><td>[A-F0-9xy]</td><td>指定范围的字符</td><td><code>A</code>，……，<code>F</code>，<code>0</code>，……，<code>9</code>，<code>x</code>，<code>y</code></td></tr><tr><td>[^A-F]</td><td>指定范围外的任意字符</td><td>非<code>A</code>~<code>F</code></td></tr><tr><td>AB</td><td>CD</td><td>EF</td></tr></tbody></table><hr><hr><p>我们前面讲到的<code>(...)</code>可以用来把一个子规则括起来，这样写<code>learn\s(java|php|go)</code>就可以更方便地匹配长字符串了。</p><p>实际上<code>(...)</code>还有一个重要作用，就是分组匹配。</p><p>我们来看一下如何用正则匹配<code>区号-电话号</code>码这个规则。利用前面讲到的匹配规则，写出来很容易：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d&#123;3,4&#125;\-\d&#123;6,8&#125;</span><br></pre></td></tr></table></figure><p>虽然这个正则匹配规则很简单，但是往往匹配成功后，下一步是提取区号和电话号码，分别存入数据库。于是问题来了：如何提取匹配的子串？</p><p>当然可以用<code>String</code>提供的<code>indexOf()</code>和<code>substring()</code>这些方法，但它们从正则匹配的字符串中提取子串没有通用性，下一次要提取<code>learn\s(java|php)</code>还得改代码。</p><p>正确的方法是用<code>(...)</code>先把要提取的规则分组，把上述正则表达式变为<code>(\d&#123;3,4&#125;)\-(\d&#123;6,8&#125;)</code>。</p><p>现在问题又来了：匹配后，如何按括号提取子串？</p><p>现在我们没办法用<code>String.matches()</code>这样简单的判断方法了，必须引入<code>java.util.regex</code>包，用<code>Pattern</code>对象匹配，匹配后获得一个<code>Matcher</code>对象，如果匹配成功，就可以直接从<code>Matcher.group(index)</code>返回子串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (m.matches()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">g1</span> <span class="operator">=</span> m.group(<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">g2</span> <span class="operator">=</span> m.group(<span class="number">2</span>);</span><br><span class="line">            System.out.println(g1); <span class="comment">// 010</span></span><br><span class="line">            System.out.println(g2); <span class="comment">// 12345678</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，会得到两个匹配上的子串<code>010</code>和<code>12345678</code>。</p><p>要特别注意，<code>Matcher.group(index)</code>方法的参数用1表示第一个子串，2表示第二个子串。如果我们传入0会得到什么呢？答案是<code>010-12345678</code>，即整个正则匹配到的字符串。</p><h3 id="Pattern">Pattern</h3><p>我们在前面的代码中用到的正则表达式代码是<code>String.matches()</code>方法，而我们在分组提取的代码中用的是<code>java.util.regex</code>包里面的<code>Pattern</code>类和<code>Matcher</code>类。实际上这两种代码本质上是一样的，因为<code>String.matches()</code>方法内部调用的就是<code>Pattern</code>和<code>Matcher</code>类的方法。</p><p>但是反复使用<code>String.matches()</code>对同一个正则表达式进行多次匹配效率较低，因为每次都会创建出一样的<code>Pattern</code>对象。完全可以先创建出一个<code>Pattern</code>对象，然后反复使用，就可以实现编译一次，多次匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line">        pattern.matcher(<span class="string">&quot;010-12345678&quot;</span>).matches(); <span class="comment">// true</span></span><br><span class="line">        pattern.matcher(<span class="string">&quot;021-123456&quot;</span>).matches(); <span class="comment">// false</span></span><br><span class="line">        pattern.matcher(<span class="string">&quot;022#1234567&quot;</span>).matches(); <span class="comment">// false</span></span><br><span class="line">        <span class="comment">// 获得Matcher对象:</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">whole</span> <span class="operator">=</span> matcher.group(<span class="number">0</span>); <span class="comment">// &quot;010-12345678&quot;, 0表示匹配的整个字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">area</span> <span class="operator">=</span> matcher.group(<span class="number">1</span>); <span class="comment">// &quot;010&quot;, 1表示匹配的第1个子串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">tel</span> <span class="operator">=</span> matcher.group(<span class="number">2</span>); <span class="comment">// &quot;12345678&quot;, 2表示匹配的第2个子串</span></span><br><span class="line">            System.out.println(area);</span><br><span class="line">            System.out.println(tel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>Matcher</code>时，必须首先调用<code>matches()</code>判断是否匹配成功，匹配成功后，才能调用<code>group()</code>提取子串。</p><p>利用提取子串的功能，我们轻松获得了区号和号码两部分。</p><h3 id="练习-2">练习</h3><p>利用分组匹配，从字符串<code>&quot;23:01:59&quot;</code>提取时、分、秒。</p><p><a href="https://liaoxuefeng.com/books/java/reg-exp/group/regex-time.zip">下载练习</a></p><h3 id="小结-4">小结</h3><p>正则表达式用<code>(...)</code>分组可以通过<code>Matcher</code>对象快速提取子串：</p><ul><li><code>group(0)</code>表示匹配的整个字符串；</li><li><code>group(1)</code>表示第1个子串，<code>group(2)</code>表示第2个子串，以此类推。</li></ul><h2 id="非贪婪匹配">非贪婪匹配</h2><p>在介绍非贪婪匹配前，我们先看一个简单的问题：</p><p>给定一个字符串表示的数字，判断该数字末尾<code>0</code>的个数。例如：</p><ul><li><code>&quot;123000&quot;</code>：3个<code>0</code></li><li><code>&quot;10100&quot;</code>：2个<code>0</code></li><li><code>&quot;1001&quot;</code>：0个<code>0</code></li></ul><p>可以很容易地写出该正则表达式：<code>(\d+)(0*)</code>，Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d+)(0*)&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;1230000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;group1=&quot;</span> + matcher.group(<span class="number">1</span>)); <span class="comment">// &quot;1230000&quot;</span></span><br><span class="line">            System.out.println(<span class="string">&quot;group2=&quot;</span> + matcher.group(<span class="number">2</span>)); <span class="comment">// &quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而打印的第二个子串是空字符串<code>&quot;&quot;</code>。</p><p>实际上，我们期望分组匹配结果是：</p><table><thead><tr><th>input</th><th><code>\d+</code></th><th><code>0*</code></th></tr></thead><tbody><tr><td>123000</td><td>“123”</td><td>“000”</td></tr><tr><td>10100</td><td>“101”</td><td>“00”</td></tr><tr><td>1001</td><td>“1001”</td><td>“”</td></tr></tbody></table><p>但实际的分组匹配结果是这样的：</p><table><thead><tr><th>input</th><th><code>\d+</code></th><th><code>0*</code></th></tr></thead><tbody><tr><td>123000</td><td>“123000”</td><td>“”</td></tr><tr><td>10100</td><td>“10100”</td><td>“”</td></tr><tr><td>1001</td><td>“1001”</td><td>“”</td></tr></tbody></table><p>仔细观察上述实际匹配结果，实际上它是完全合理的，因为<code>\d+</code>确实可以匹配后面任意个<code>0</code>。</p><p>这是因为正则表达式默认使用贪婪匹配：任何一个规则，它总是尽可能多地向后匹配，因此，<code>\d+</code>总是会把后面的<code>0</code>包含进来。</p><p>要让<code>\d+</code>尽量少匹配，让<code>0*</code>尽量多匹配，我们就必须让<code>\d+</code>使用非贪婪匹配。在规则<code>\d+</code>后面加个<code>?</code>即可表示非贪婪匹配。我们改写正则表达式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d+?)(0*)&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;1230000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;group1=&quot;</span> + matcher.group(<span class="number">1</span>)); <span class="comment">// &quot;123&quot;</span></span><br><span class="line">            System.out.println(<span class="string">&quot;group2=&quot;</span> + matcher.group(<span class="number">2</span>)); <span class="comment">// &quot;0000&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，给定一个匹配规则，加上<code>?</code>后就变成了非贪婪匹配。</p><p>我们再来看这个正则表达式<code>(\d??)(9*)</code>，注意<code>\d?</code>表示匹配0个或1个数字，后面第二个<code>?</code>表示非贪婪匹配，因此，给定字符串<code>&quot;9999&quot;</code>，匹配到的两个子串分别是<code>&quot;&quot;</code>和<code>&quot;9999&quot;</code>，因为对于<code>\d?</code>来说，可以匹配1个<code>9</code>，也可以匹配0个<code>9</code>，但是因为后面的<code>?</code>表示非贪婪匹配，它就会尽可能少的匹配，结果是匹配了0个<code>9</code>。</p><h3 id="小结-5">小结</h3><p>正则表达式匹配默认使用贪婪匹配，可以使用<code>?</code>表示对某一规则进行非贪婪匹配；</p><p>注意区分<code>?</code>的含义：<code>\d??</code>。</p><hr><hr><h3 id="分割字符串">分割字符串</h3><p>使用正则表达式分割字符串可以实现更加灵活的功能。<code>String.split()</code>方法传入的正是正则表达式。我们来看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;a b c&quot;</span>.split(<span class="string">&quot;\\s&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span></span><br><span class="line"><span class="string">&quot;a b  c&quot;</span>.split(<span class="string">&quot;\\s&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;&quot;, &quot;c&quot; &#125;</span></span><br><span class="line"><span class="string">&quot;a, b ;; c&quot;</span>.split(<span class="string">&quot;[\\,\\;\\s]+&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span></span><br></pre></td></tr></table></figure><p>如果我们想让用户输入一组标签，然后把标签提取出来，因为用户的输入往往是不规范的，这时，使用合适的正则表达式，就可以消除多个空格、混合<code>,</code>和<code>;</code>这些不规范的输入，直接提取出规范的字符串。</p><h3 id="搜索字符串">搜索字符串</h3><p>使用正则表达式还可以搜索字符串，我们来看例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;the quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\wo\\w&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(s);</span><br><span class="line">        <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(m.start(), m.end());</span><br><span class="line">            System.out.println(sub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们获取到<code>Matcher</code>对象后，不需要调用<code>matches()</code>方法（因为匹配整个串肯定返回false），而是反复调用<code>find()</code>方法，在整个串中搜索能匹配上<code>\\wo\\w</code>规则的子串，并打印出来。这种方式比<code>String.indexOf()</code>要灵活得多，因为我们搜索的规则是3个字符：中间必须是<code>o</code>，前后两个必须是字符<code>[A-Za-z0-9_]</code>。</p><h3 id="替换字符串">替换字符串</h3><p>使用正则表达式替换字符串可以直接调用<code>String.replaceAll()</code>，它的第一个参数是正则表达式，第二个参数是待替换的字符串。我们还是来看例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// regex</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;The     quick\t\t brown   fox  jumps   over the  lazy dog.&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> s.replaceAll(<span class="string">&quot;\\s+&quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(r); <span class="comment">// &quot;The quick brown fox jumps over the lazy dog.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码把不规范的连续空格分隔的句子变成了规范的句子。可见，灵活使用正则表达式可以大大降低代码量。</p><h3 id="反向引用">反向引用</h3><p>如果我们要把搜索到的指定字符串按规则替换，比如前后各加一个<code>&lt;b&gt;xxxx&lt;/b&gt;</code>，这个时候，使用<code>replaceAll()</code>的时候，我们传入的第二个参数可以使用<code>$1</code>、<code>$2</code>来反向引用匹配到的子串。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// regex</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;the quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> s.replaceAll(<span class="string">&quot;\\s([a-z]&#123;4&#125;)\\s&quot;</span>, <span class="string">&quot; &lt;b&gt;$1&lt;/b&gt; &quot;</span>);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的运行结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the quick brown fox jumps &lt;b&gt;over&lt;/b&gt; the &lt;b&gt;lazy&lt;/b&gt; dog.</span><br></pre></td></tr></table></figure><p>它实际上把任何4字符单词的前后用<code>&lt;b&gt;xxxx&lt;/b&gt;</code>括起来。实现替换的关键就在于<code>&quot; &lt;b&gt;$1&lt;/b&gt; &quot;</code>，它用匹配的分组子串<code>([a-z]&#123;4&#125;)</code>替换了<code>$1</code>。</p><h3 id="练习-3">练习</h3><p>模板引擎是指，定义一个字符串作为模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, $&#123;name&#125;! You are learning $&#123;lang&#125;!</span><br></pre></td></tr></table></figure><p>其中，以<code>$&#123;key&#125;</code>表示的是变量，也就是将要被替换的内容。</p><p>当传入一个<code>Map&lt;String, String&gt;</code>给模板后，需要把对应的key替换为Map的value。</p><p>例如，传入<code>Map</code>为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Bob&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lang&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Java&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后，<code>$&#123;name&#125;</code>被替换为<code>Map</code>对应的值<code>Bob</code>，<code>$&#123;lang&#125;</code>被替换为<code>Map</code>对应的值<code>Java</code>，最终输出的结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Bob! You are learning Java!</span><br></pre></td></tr></table></figure><p>请编写一个简单的模板引擎，利用正则表达式实现这个功能。</p><p>提示：参考<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/regex/Matcher.html#appendReplacement%28java.lang.StringBuilder%2Cjava.lang.String%29">Matcher.appendReplacement()</a>方法。</p><p><a href="https://liaoxuefeng.com/books/java/reg-exp/search-replace/regex-template.zip">下载练习</a></p><h3 id="小结-6">小结</h3><p>使用正则表达式可以：</p><ul><li>分割字符串：<code>String.split()</code></li><li>搜索子串：<code>Matcher.find()</code></li><li>替换字符串：<code>String.replaceAll()</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-单元测试</title>
      <link href="/2025/05/24/JAVA-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2025/05/24/JAVA-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>什么是单元测试呢？单元测试就是针对最小的功能单元编写测试代码。Java程序最小的功能单元是方法，因此，对Java程序进行单元测试就是针对单个Java方法的测试。</p><p>单元测试有什么好处呢？在学习单元测试前，我们可以先了解一下测试驱动开发。</p><p>所谓测试驱动开发，是指先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码。在编写实现代码的过程中，一边写，一边测，什么时候测试全部通过了，那就表示编写的实现完成了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    编写接口</span><br><span class="line">     │</span><br><span class="line">     ▼</span><br><span class="line">    编写测试</span><br><span class="line">     │</span><br><span class="line">     ▼</span><br><span class="line">┌─▶ 编写实现</span><br><span class="line">│    │</span><br><span class="line">│ N  ▼</span><br><span class="line">└── 运行测试</span><br><span class="line">     │ Y</span><br><span class="line">     ▼</span><br><span class="line">    任务完成</span><br></pre></td></tr></table></figure><p>这就是传说中的……</p><p><img src="https://liaoxuefeng.com/books/java/unit-test/junit-test/tdd.jpg" alt="tdd"></p><p>当然，这是一种理想情况。大部分情况是我们已经编写了实现代码，需要对已有的代码进行测试。</p><p>我们先通过一个示例来看如何编写测试。假定我们编写了一个计算阶乘的类，它只有一个静态方法来计算阶乘：</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">fact</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            r = r * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要测试这个方法，一个很自然的想法是编写一个<code>main()</code>方法，然后运行一些测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fact(<span class="number">10</span>) == <span class="number">3628800</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;pass&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以通过运行<code>main()</code>方法来运行测试代码。</p><p>不过，使用<code>main()</code>方法测试有很多缺点：</p><p>一是只能有一个<code>main()</code>方法，不能把测试代码分离，二是没有打印出测试结果和期望结果，例如，<code>expected: 3628800, but actual: 123456</code>，三是很难编写一组通用的测试代码。</p><p>因此，我们需要一种测试框架，帮助我们编写测试。</p><h3 id="JUnit">JUnit</h3><p>JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计，使用最广泛。JUnit是事实上的单元测试的标准框架，任何Java开发者都应当学习并使用JUnit编写单元测试。</p><p>使用JUnit编写单元测试的好处在于，我们可以非常简单地组织测试代码，并随时运行它们，JUnit就会给出成功的测试和失败的测试，还可以生成测试报告，不仅包含测试的成功率，还可以统计测试的代码覆盖率，即被测试的代码本身有多少经过了测试。对于高质量的代码来说，测试覆盖率应该在80%以上。</p><p>此外，几乎所有的IDE工具都集成了JUnit，这样我们就可以直接在IDE中编写并运行JUnit测试。JUnit目前最新版本是5。</p><p>以Eclipse为例，当我们已经编写了一个<code>Factorial.java</code>文件后，我们想对其进行测试，需要编写一个对应的<code>FactorialTest.java</code>文件，以<code>Test</code>为后缀是一个惯例，并分别将其放入<code>src</code>和<code>test</code>目录中。最后，在<code>Project</code> - <code>Properties</code> - <code>Java Build Path</code> - <code>Libraries</code>中添加<code>JUnit 5</code>的库：</p><p><img src="https://liaoxuefeng.com/books/java/unit-test/junit-test/add-junit-lib.png" alt="junit-lib"></p><p>整个项目结构如下：</p><p><img src="https://liaoxuefeng.com/books/java/unit-test/junit-test/junit-proj.png" alt="junit-test-structure"></p><p>我们来看一下<code>FactorialTest.java</code>的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.learnjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactorialTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testFact</span><span class="params">()</span> &#123;</span><br><span class="line">        assertEquals(<span class="number">1</span>, Factorial.fact(<span class="number">1</span>));</span><br><span class="line">        assertEquals(<span class="number">2</span>, Factorial.fact(<span class="number">2</span>));</span><br><span class="line">        assertEquals(<span class="number">6</span>, Factorial.fact(<span class="number">3</span>));</span><br><span class="line">        assertEquals(<span class="number">3628800</span>, Factorial.fact(<span class="number">10</span>));</span><br><span class="line">        assertEquals(<span class="number">2432902008176640000L</span>, Factorial.fact(<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心测试方法<code>testFact()</code>加上了<code>@Test</code>注解，这是JUnit要求的，它会把带有<code>@Test</code>的方法识别为测试方法。在测试方法内部，我们用<code>assertEquals(1, Factorial.fact(1))</code>表示，期望<code>Factorial.fact(1)</code>返回<code>1</code>。<code>assertEquals(expected, actual)</code>是最常用的测试方法，它在<code>Assertion</code>类中定义。<code>Assertion</code>还定义了其他断言方法，例如：</p><ul><li><code>assertTrue()</code>: 期待结果为<code>true</code></li><li><code>assertFalse()</code>: 期待结果为<code>false</code></li><li><code>assertNotNull()</code>: 期待结果为非<code>null</code></li><li><code>assertArrayEquals()</code>: 期待结果为数组并与期望数组每个元素的值均相等</li><li>…</li></ul><p>运行单元测试非常简单。选中<code>FactorialTest.java</code>文件，点击<code>Run</code> - <code>Run As</code> - <code>JUnit Test</code>，Eclipse会自动运行这个JUnit测试，并显示结果：</p><p><img src="https://liaoxuefeng.com/books/java/unit-test/junit-test/junit-test-pass.png" alt="junit-test-ok"></p><p>如果测试结果与预期不符，<code>assertEquals()</code>会抛出异常，我们就会得到一个测试失败的结果：</p><p><img src="https://liaoxuefeng.com/books/java/unit-test/junit-test/junit-test-failed.png" alt="junit-test-failed"></p><p>在Failure Trace中，JUnit会告诉我们详细的错误结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">org.opentest4j.AssertionFailedError: expected: &lt;3628800&gt; but was: &lt;362880&gt;</span><br><span class="line">at org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:55)</span><br><span class="line">at org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:195)</span><br><span class="line">at org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:168)</span><br><span class="line">at org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:163)</span><br><span class="line">at org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:611)</span><br><span class="line">at com.itranswarp.learnjava.FactorialTest.testFact(FactorialTest.java:14)</span><br><span class="line">at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at ...</span><br></pre></td></tr></table></figure><p>第一行的失败信息的意思是期待结果<code>3628800</code>但是实际返回是<code>362880</code>，此时，我们要么修正实现代码，要么修正测试代码，直到测试通过为止。</p><p>使用浮点数时，由于浮点数无法精确地进行比较，因此，我们需要调用<code>assertEquals(double expected, double actual, double delta)</code>这个重载方法，指定一个误差值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(<span class="number">0.1</span>, Math.abs(<span class="number">1</span> - <span class="number">9</span> / <span class="number">10.0</span>), <span class="number">0.0000001</span>);</span><br></pre></td></tr></table></figure><h3 id="单元测试的好处">单元测试的好处</h3><p>单元测试可以确保单个方法按照正确预期运行，如果修改了某个方法的代码，只需确保其对应的单元测试通过，即可认为改动正确。此外，测试代码本身就可以作为示例代码，用来演示如何调用该方法。</p><p>使用JUnit进行单元测试，我们可以使用断言（<code>Assertion</code>）来测试期望结果，可以方便地组织和运行测试，并方便地查看测试结果。此外，JUnit既可以直接在IDE中运行，也可以方便地集成到Maven这些自动化工具中运行。</p><p>在编写单元测试的时候，我们要遵循一定的规范：</p><p>一是单元测试代码本身必须非常简单，能一下看明白，决不能再为测试代码编写测试；</p><p>二是每个单元测试应当互相独立，不依赖运行的顺序；</p><p>三是测试时不但要覆盖常用测试用例，还要特别注意测试边界条件，例如输入为<code>0</code>，<code>null</code>，空字符串<code>&quot;&quot;</code>等情况。</p><h3 id="练习">练习</h3><p>使用JUnit编写测试代码。</p><p><a href="https://liaoxuefeng.com/books/java/unit-test/junit-test/junit-test.zip">下载练习</a></p><h3 id="小结">小结</h3><p>JUnit是一个单元测试框架，专门用于运行我们编写的单元测试：</p><p>一个JUnit测试包含若干<code>@Test</code>方法，并使用<code>Assertions</code>进行断言，注意浮点数<code>assertEquals()</code>要指定<code>delta</code>。</p><p>在一个单元测试中，我们经常编写多个<code>@Test</code>方法，来分组、分类对目标代码进行测试。</p><p>在测试的时候，我们经常遇到一个对象需要初始化，测试完可能还需要清理的情况。如果每个<code>@Test</code>方法都写一遍这样的重复代码，显然比较麻烦。</p><p>JUnit提供了编写测试前准备、测试后清理的固定代码，我们称之为Fixture。</p><p>我们来看一个具体的<code>Calculator</code>的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">        n = n + x;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sub</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">        n = n - x;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的功能很简单，但是测试的时候，我们要先初始化对象，我们不必在每个测试方法中都写上初始化代码，而是通过<code>@BeforeEach</code>来初始化，通过<code>@AfterEach</code>来清理资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    Calculator calculator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.calculator = <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.calculator = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span> &#123;</span><br><span class="line">        assertEquals(<span class="number">100</span>, <span class="built_in">this</span>.calculator.add(<span class="number">100</span>));</span><br><span class="line">        assertEquals(<span class="number">150</span>, <span class="built_in">this</span>.calculator.add(<span class="number">50</span>));</span><br><span class="line">        assertEquals(<span class="number">130</span>, <span class="built_in">this</span>.calculator.add(-<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSub</span><span class="params">()</span> &#123;</span><br><span class="line">        assertEquals(-<span class="number">100</span>, <span class="built_in">this</span>.calculator.sub(<span class="number">100</span>));</span><br><span class="line">        assertEquals(-<span class="number">150</span>, <span class="built_in">this</span>.calculator.sub(<span class="number">50</span>));</span><br><span class="line">        assertEquals(-<span class="number">130</span>, <span class="built_in">this</span>.calculator.sub(-<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>CalculatorTest</code>测试中，有两个标记为<code>@BeforeEach</code>和<code>@AfterEach</code>的方法，它们会在运行每个<code>@Test</code>方法前后自动运行。</p><p>上面的测试代码在JUnit中运行顺序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method testMethod : findTestMethods(CalculatorTest.class)) &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalculatorTest</span>(); <span class="comment">// 创建Test实例</span></span><br><span class="line">    invokeBeforeEach(test);</span><br><span class="line">        invokeTestMethod(test, testMethod);</span><br><span class="line">    invokeAfterEach(test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，<code>@BeforeEach</code>和<code>@AfterEach</code>会“环绕”在每个<code>@Test</code>方法前后。</p><p>还有一些资源初始化和清理可能更加繁琐，而且会耗费较长的时间，例如初始化数据库。JUnit还提供了<code>@BeforeAll</code>和<code>@AfterAll</code>，它们在运行所有<code>@Test</code>前后运行，顺序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">invokeBeforeAll(CalculatorTest.class);</span><br><span class="line"><span class="keyword">for</span> (Method testMethod : findTestMethods(CalculatorTest.class)) &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalculatorTest</span>(); <span class="comment">// 创建Test实例</span></span><br><span class="line">    invokeBeforeEach(test);</span><br><span class="line">        invokeTestMethod(test, testMethod);</span><br><span class="line">    invokeAfterEach(test);</span><br><span class="line">&#125;</span><br><span class="line">invokeAfterAll(CalculatorTest.class);</span><br></pre></td></tr></table></figure><p>因为<code>@BeforeAll</code>和<code>@AfterAll</code>在所有<code>@Test</code>方法运行前后仅运行一次，因此，它们只能初始化静态变量，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Database db;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initDatabase</span><span class="params">()</span> &#123;</span><br><span class="line">        db = createDb(...);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dropDatabase</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，<code>@BeforeAll</code>和<code>@AfterAll</code>也只能标注在静态方法上。</p><p>因此，我们总结出编写Fixture的套路如下：</p><ol><li>对于实例变量，在<code>@BeforeEach</code>中初始化，在<code>@AfterEach</code>中清理，它们在各个<code>@Test</code>方法中互不影响，因为是不同的实例；</li><li>对于静态变量，在<code>@BeforeAll</code>中初始化，在<code>@AfterAll</code>中清理，它们在各个<code>@Test</code>方法中均是唯一实例，会影响各个<code>@Test</code>方法。</li></ol><p>大多数情况下，使用<code>@BeforeEach</code>和<code>@AfterEach</code>就足够了。只有某些测试资源初始化耗费时间太长，以至于我们不得不尽量“复用”时才会用到<code>@BeforeAll</code>和<code>@AfterAll</code>。</p><p>最后，注意到每次运行一个<code>@Test</code>方法前，JUnit首先创建一个<code>XxxTest</code>实例，因此，每个<code>@Test</code>方法内部的成员变量都是独立的，不能也无法把成员变量的状态从一个<code>@Test</code>方法带到另一个<code>@Test</code>方法。</p><h3 id="练习-2">练习</h3><p>使用Fixture编写单元测试。</p><p><a href="https://liaoxuefeng.com/books/java/unit-test/fixture/junit-fixture.zip">下载练习</a></p><h3 id="小结-2">小结</h3><p>编写Fixture是指针对每个<code>@Test</code>方法，编写<code>@BeforeEach</code>方法用于初始化测试资源，编写<code>@AfterEach</code>用于清理测试资源；</p><p>必要时，可以编写<code>@BeforeAll</code>和<code>@AfterAll</code>，使用静态变量来初始化耗时的资源，并且在所有<code>@Test</code>方法的运行前后仅执行一次。</p><h2 id="异常测试">异常测试</h2><p>在Java程序中，异常处理是非常重要的。</p><p>我们自己编写的方法，也经常抛出各种异常。对于可能抛出的异常进行测试，本身就是测试的重要环节。</p><p>因此，在编写JUnit测试的时候，除了正常的输入输出，我们还要特别针对可能导致异常的情况进行测试。</p><p>我们仍然用<code>Factorial</code>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">fact</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            r = r * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法入口，我们增加了对参数<code>n</code>的检查，如果为负数，则直接抛出<code>IllegalArgumentException</code>。</p><p>现在，我们希望对异常进行测试。在JUnit测试中，我们可以编写一个<code>@Test</code>方法专门测试异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testNegative</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThrows(IllegalArgumentException.class, <span class="keyword">new</span> <span class="title class_">Executable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            Factorial.fact(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JUnit提供<code>assertThrows()</code>来期望捕获一个指定的异常。第二个参数<code>Executable</code>封装了我们要执行的会产生异常的代码。当我们执行<code>Factorial.fact(-1)</code>时，必定抛出<code>IllegalArgumentException</code>。<code>assertThrows()</code>在捕获到指定异常时表示通过测试，未捕获到异常，或者捕获到的异常类型不对，均表示测试失败。</p><p>有些童鞋会觉得编写一个<code>Executable</code>的匿名类太繁琐了。实际上，Java 8开始引入了函数式编程，所有单方法接口都可以简写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testNegative</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThrows(IllegalArgumentException.class, () -&gt; &#123;</span><br><span class="line">        Factorial.fact(-<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述奇怪的<code>-&gt;</code>语法就是函数式接口的实现代码，我们会在后面详细介绍。现在，我们只需要通过这种固定的代码编写能抛出异常的语句即可。</p><h3 id="练习-3">练习</h3><p>观察<code>Factorial.fact()</code>方法，注意到由于<code>long</code>型整数有范围限制，当我们传入参数<code>21</code>时，得到的结果是<code>-4249290049419214848</code>，而不是期望的<code>51090942171709440000</code>，因此，当传入参数大于<code>20</code>时，<code>Factorial.fact()</code>方法应当抛出<code>ArithmeticException</code>。请编写测试并修改实现代码，确保测试通过。</p><p><a href="https://liaoxuefeng.com/books/java/unit-test/exception-test/junit-exception.zip">下载练习</a></p><h3 id="小结-3">小结</h3><p>测试异常可以使用<code>assertThrows()</code>，期待捕获到指定类型的异常；</p><p>对可能发生的每种类型的异常都必须进行测试。</p><hr><hr><p>在运行测试的时候，有些时候，我们需要排出某些<code>@Test</code>方法，不要让它运行，这时，我们就可以给它标记一个<code>@Disabled</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Disabled</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBug101</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这个测试不会运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么我们不直接注释掉<code>@Test</code>，而是要加一个<code>@Disabled</code>？这是因为注释掉<code>@Test</code>，JUnit就不知道这是个测试方法，而加上<code>@Disabled</code>，JUnit仍然识别出这是个测试方法，只是暂时不运行。它会在测试结果中显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tests run: 68, Failures: 2, Errors: 0, Skipped: 5</span><br></pre></td></tr></table></figure><p>类似<code>@Disabled</code>这种注解就称为条件测试（Conditional Test），JUnit根据不同的条件注解，决定是否运行当前的<code>@Test</code>方法。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConfigFile</span><span class="params">(String filename)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">os</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>).toLowerCase();</span><br><span class="line">        <span class="keyword">if</span> (os.contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;C:\\&quot;</span> + filename;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (os.contains(<span class="string">&quot;mac&quot;</span>) || os.contains(<span class="string">&quot;linux&quot;</span>) || os.contains(<span class="string">&quot;unix&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;/usr/local/&quot;</span> + filename;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们想要测试<code>getConfigFile()</code>这个方法，但是在Windows上跑，和在Linux上跑的代码路径不同，因此，针对两个系统的测试方法，其中一个只能在Windows上跑，另一个只能在Mac/Linux上跑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testWindows</span><span class="params">()</span> &#123;</span><br><span class="line">    assertEquals(<span class="string">&quot;C:\\test.ini&quot;</span>, config.getConfigFile(<span class="string">&quot;test.ini&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLinuxAndMac</span><span class="params">()</span> &#123;</span><br><span class="line">    assertEquals(<span class="string">&quot;/usr/local/test.cfg&quot;</span>, config.getConfigFile(<span class="string">&quot;test.cfg&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们给上述两个测试方法分别加上条件如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledOnOs(OS.WINDOWS)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testWindows</span><span class="params">()</span> &#123;</span><br><span class="line">    assertEquals(<span class="string">&quot;C:\\test.ini&quot;</span>, config.getConfigFile(<span class="string">&quot;test.ini&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledOnOs(&#123; OS.LINUX, OS.MAC &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLinuxAndMac</span><span class="params">()</span> &#123;</span><br><span class="line">    assertEquals(<span class="string">&quot;/usr/local/test.cfg&quot;</span>, config.getConfigFile(<span class="string">&quot;test.cfg&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@EnableOnOs</code>就是一个条件测试判断。</p><p>我们来看一些常用的条件测试：</p><p>不在Windows平台执行的测试，可以加上<code>@DisabledOnOs(OS.WINDOWS)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisabledOnOs(OS.WINDOWS)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testOnNonWindowsOs</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this test is disabled on windows</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能在Java 9或更高版本执行的测试，可以加上<code>@DisabledOnJre(JRE.JAVA_8)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisabledOnJre(JRE.JAVA_8)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testOnJava9OrAbove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this test is disabled on java 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能在64位操作系统上执行的测试，可以用<code>@EnabledIfSystemProperty</code>判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledIfSystemProperty(named = &quot;os.arch&quot;, matches = &quot;.*64.*&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testOnlyOn64bitSystem</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this test is only run on 64 bit system</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要传入环境变量<code>DEBUG=true</code>才能执行的测试，可以用<code>@EnabledIfEnvironmentVariable</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledIfEnvironmentVariable(named = &quot;DEBUG&quot;, matches = &quot;true&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testOnlyOnDebugMode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this test is only run on DEBUG=true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在JUnit中运行所有测试的时候，JUnit会给出执行的结果。在IDE中，我们能很容易地看到没有执行的测试：</p><p><img src="https://liaoxuefeng.com/books/java/unit-test/conditional-test/junit-conditional-test.png" alt="junit-conditional-test"></p><p>带有⊘标记的测试方法表示没有执行。</p><h3 id="练习-4">练习</h3><p>在JUnit测试中使用条件测试。</p><p><a href="https://liaoxuefeng.com/books/java/unit-test/conditional-test/junit-conditional.zip">下载练习</a></p><h3 id="小结-4">小结</h3><p>条件测试是根据某些注解在运行期让JUnit自动忽略某些测试。</p><p>如果待测试的输入和输出是一组数据，可以把测试数据组织起来，用不同的测试数据调用相同的测试方法，这就是参数化测试。</p><p>参数化测试和普通测试稍微不同的地方在于，一个测试方法需要接收至少一个参数，然后，传入一组参数反复运行。</p><p>JUnit提供了一个<code>@ParameterizedTest</code>注解，用来进行参数化测试。</p><p>假设我们想对<code>Math.abs()</code>进行测试，先用一组正数进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(ints = &#123; 0, 1, 5, 100 &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAbs</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    assertEquals(x, Math.abs(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再用一组负数进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(ints = &#123; -1, -5, -100 &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAbsNegative</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    assertEquals(-x, Math.abs(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到参数化测试的注解是<code>@ParameterizedTest</code>，而不是普通的<code>@Test</code>。</p><p>实际的测试场景往往没有这么简单。假设我们自己编写了一个<code>StringUtils.capitalize()</code>方法，它会把字符串的第一个字母变为大写，后续字母变为小写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">capitalize</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Character.toUpperCase(s.charAt(<span class="number">0</span>)) + s.substring(<span class="number">1</span>).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要用参数化测试的方法来测试，我们不但要给出输入，还要给出预期输出。因此，测试方法至少需要接收两个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCapitalize</span><span class="params">(String input, String result)</span> &#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在问题来了：参数如何传入？</p><p>最简单的方法是通过<code>@MethodSource</code>注解，它允许我们编写一个同名的静态方法来提供测试参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCapitalize</span><span class="params">(String input, String result)</span> &#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> List&lt;Arguments&gt; <span class="title function_">testCapitalize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> List.of( <span class="comment">// arguments:</span></span><br><span class="line">            Arguments.of(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;Abc&quot;</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.of(<span class="string">&quot;APPLE&quot;</span>, <span class="string">&quot;Apple&quot;</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.of(<span class="string">&quot;gooD&quot;</span>, <span class="string">&quot;Good&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很容易理解：静态方法<code>testCapitalize()</code>返回了一组测试参数，每个参数都包含两个<code>String</code>，正好作为测试方法的两个参数传入。</p><p>提示</p><p>如果静态方法和测试方法的名称不同，@MethodSource也允许指定方法名。但使用默认同名方法最方便。</p><p>另一种传入测试参数的方法是使用<code>@CsvSource</code>，它的每一个字符串表示一行，一行包含的若干参数用<code>,</code>分隔，因此，上述测试又可以改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvSource(&#123; &quot;abc, Abc&quot;, &quot;APPLE, Apple&quot;, &quot;gooD, Good&quot; &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCapitalize</span><span class="params">(String input, String result)</span> &#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有成百上千的测试输入，那么，直接写<code>@CsvSource</code>就很不方便。这个时候，我们可以把测试数据提到一个独立的CSV文件中，然后标注上<code>@CsvFileSource</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvFileSource(resources = &#123; &quot;/test-capitalize.csv&quot; &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCapitalizeUsingCsvFile</span><span class="params">(String input, String result)</span> &#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JUnit只在classpath中查找指定的CSV文件，因此，<code>test-capitalize.csv</code>这个文件要放到<code>test</code>目录下，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apple, Apple</span><br><span class="line">HELLO, Hello</span><br><span class="line">JUnit, Junit</span><br><span class="line">reSource, Resource</span><br></pre></td></tr></table></figure><h3 id="练习-5">练习</h3><p>对<code>StringUtils</code>进行参数化测试。</p><p><a href="https://liaoxuefeng.com/books/java/unit-test/parameterized-test/junit-parameterized.zip">下载练习</a></p><h3 id="小结-5">小结</h3><p>使用参数化测试，可以提供一组测试数据，对一个测试方法反复测试；</p><p>参数既可以在测试代码中写死，也可以通过<code>@CsvFileSource</code>放到外部的CSV文件中。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-日期与时间</title>
      <link href="/2025/05/24/JAVA-%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4/"/>
      <url>/2025/05/24/JAVA-%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>在计算机中，我们经常需要处理日期和时间。</p><p>这是日期：</p><ul><li>2019-11-20</li><li>2020-1-1</li></ul><p>这是时间：</p><ul><li>12:30:59</li><li>2020-1-1 20:21:59</li></ul><p>日期是指某一天，它不是连续变化的，而是应该被看成离散的。</p><p>而时间有两种概念，一种是不带日期的时间，例如，12:30:59。另一种是带日期的时间，例如，2020-1-1 20:21:59，只有这种带日期的时间能唯一确定某个时刻，不带日期的时间是无法确定一个唯一时刻的。</p><h3 id="本地时间">本地时间</h3><p>当我们说当前时刻是2019年11月20日早上8:15的时候，我们说的实际上是本地时间。在国内就是北京时间。在这个时刻，如果地球上不同地方的人们同时看一眼手表，他们各自的本地时间是不同的：</p><p><img src="https://liaoxuefeng.com/books/java/datetime/concept/localtime.jpg" alt="localtime"></p><p>所以，不同的时区，在同一时刻，本地时间是不同的。全球一共分为24个时区，伦敦所在的时区称为标准时区，其他时区按东／西偏移的小时区分，北京所在的时区是东八区。</p><h3 id="时区">时区</h3><p>因为光靠本地时间还无法唯一确定一个准确的时刻，所以我们还需要给本地时间加上一个时区。时区有好几种表示方式。</p><p>一种是以<code>GMT</code>或者<code>UTC</code>加时区偏移表示，例如：<code>GMT+08:00</code>或者<code>UTC+08:00</code>表示东八区。</p><p><code>GMT</code>和<code>UTC</code>可以认为基本是等价的，只是<code>UTC</code>使用更精确的原子钟计时，每隔几年会有一个闰秒，我们在开发程序的时候可以忽略两者的误差，因为计算机的时钟在联网的时候会自动与时间服务器同步时间。</p><p>另一种是缩写，例如，<code>CST</code>表示<code>China Standard Time</code>，也就是中国标准时间。但是<code>CST</code>也可以表示美国中部时间<code>Central Standard Time USA</code>，因此，缩写容易产生混淆，我们尽量不要使用缩写。</p><p>最后一种是以洲／城市表示，例如，<code>Asia/Shanghai</code>，表示上海所在地的时区。特别注意城市名称不是任意的城市，而是由国际标准组织规定的城市。</p><p>因为时区的存在，东八区的2019年11月20日早上8:15，和西五区的2019年11月19日晚上19:15，他们的时刻是相同的：</p><p><img src="https://liaoxuefeng.com/books/java/datetime/concept/same-time.jpg" alt="timezone"></p><p>时刻相同的意思就是，分别在两个时区的两个人，如果在这一刻通电话，他们各自报出自己手表上的时间，虽然本地时间是不同的，但是这两个时间表示的时刻是相同的。</p><h3 id="夏令时">夏令时</h3><p>时区还不是最复杂的，更复杂的是夏令时。所谓夏令时，就是夏天开始的时候，把时间往后拨1小时，夏天结束的时候，再把时间往前拨1小时。我们国家实行过一段时间夏令时，1992年就废除了，但是矫情的美国人到现在还在使用，所以时间换算更加复杂。</p><p><img src="https://liaoxuefeng.com/books/java/datetime/concept/dst-time.jpg" alt="daynight-saving"></p><p>因为涉及到夏令时，相同的时区，如果表示的方式不同，转换出的时间是不同的。我们举个栗子：</p><p>对于2019-11-20和2019-6-20两个日期来说，假设北京人在纽约：</p><ul><li>如果以<code>GMT</code>或者<code>UTC</code>作为时区，无论日期是多少，时间都是<code>19:00</code>；</li><li>如果以国家／城市表示，例如<code>America／NewYork</code>，虽然纽约也在西五区，但是，因为夏令时的存在，在不同的日期，<code>GMT</code>时间和纽约时间可能是不一样的：</li></ul><table><thead><tr><th>时区</th><th>2019-11-20</th><th>2019-6-20</th></tr></thead><tbody><tr><td>GMT-05:00</td><td>19:00</td><td>19:00</td></tr><tr><td>UTC-05:00</td><td>19:00</td><td>19:00</td></tr><tr><td>America/New_York</td><td>19:00</td><td>20:00</td></tr></tbody></table><p>实行夏令时的不同地区，进入和退出夏令时的时间很可能是不同的。同一个地区，根据历史上是否实行过夏令时，标准时间在不同年份换算成当地时间也是不同的。因此，计算夏令时，没有统一的公式，必须按照一组给定的规则来算，并且，该规则要定期更新。</p><p>注意</p><p>计算夏令时请使用标准库提供的相关类，不要试图自己计算夏令时。</p><h3 id="本地化">本地化</h3><p>在计算机中，通常使用<code>Locale</code>表示一个国家或地区的日期、时间、数字、货币等格式。<code>Locale</code>由<code>语言_国家</code>的字母缩写构成，例如，<code>zh_CN</code>表示中文+中国，<code>en_US</code>表示英文+美国。语言使用小写，国家使用大写。</p><p>对于日期来说，不同的Locale，例如，中国和美国的表示方式如下：</p><ul><li>zh_CN：2016-11-30</li><li>en_US：11/30/2016</li></ul><p>计算机用<code>Locale</code>在日期、时间、货币和字符串之间进行转换。一个电商网站会根据用户所在的<code>Locale</code>对用户显示如下：</p><table><thead><tr><th></th><th>中国用户</th><th>美国用户</th></tr></thead><tbody><tr><td>购买价格</td><td>12000.00</td><td>12,000.00</td></tr><tr><td>购买日期</td><td>2016-11-30</td><td>11/30/2016</td></tr></tbody></table><h3 id="小结">小结</h3><p>在编写日期和时间的程序前，我们要准确理解日期、时间和时刻的概念；</p><p>由于存在本地时间，我们需要理解时区的概念，并且必须牢记由于夏令时的存在，同一地区用<code>GMT/UTC</code>和城市表示的时区可能导致时间不同；</p><p>计算机通过<code>Locale</code>来针对当地用户习惯格式化日期、时间、数字、货币等。</p><p>在计算机中，应该如何表示日期和时间呢？</p><p>我们经常看到的日期和时间表示方式如下：</p><ul><li>2019-11-20 0:15:00 GMT+00:00</li><li>2019年11月20日8:15:00</li><li>11/19/2019 19:15:00 America/New_York</li></ul><p>如果直接以字符串的形式存储，那么不同的格式，不同的语言会让表示方式非常繁琐。</p><p>在理解日期和时间的表示方式之前，我们先要理解数据的存储和展示。</p><p>当我们定义一个整型变量并赋值时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">123400</span>;</span><br></pre></td></tr></table></figure><p>编译器会把上述字符串（程序源码就是一个字符串）编译成字节码。在程序的运行期，变量<code>n</code>指向的内存实际上是一个4字节区域：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──┬──┬──┬──┐</span><br><span class="line">│00│01│e2│08│</span><br><span class="line">└──┴──┴──┴──┘</span><br></pre></td></tr></table></figure><p>注意到计算机内存除了二进制的<code>0</code>/<code>1</code>外没有其他任何格式。上述十六进制是为了简化表示。</p><p>当我们用<code>System.out.println(n)</code>打印这个整数的时候，实际上<code>println()</code>这个方法在内部把<code>int</code>类型转换成<code>String</code>类型，然后打印出字符串<code>123400</code>。</p><p>类似的，我们也可以以十六进制的形式打印这个整数，或者，如果<code>n</code>表示一个价格，我们就以<code>$123,400.00</code>的形式来打印它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">123400</span>;</span><br><span class="line">        <span class="comment">// 123400</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">        <span class="comment">// 1e208</span></span><br><span class="line">        System.out.println(Integer.toHexString(n));</span><br><span class="line">        <span class="comment">// $123,400.00</span></span><br><span class="line">        System.out.println(NumberFormat.getCurrencyInstance(Locale.US).format(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，整数<code>123400</code>是数据的存储格式，它的存储格式非常简单。而我们打印的各种各样的字符串，则是数据的展示格式。展示格式有多种形式，但本质上它就是一个转换方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">toDisplay</span><span class="params">(<span class="type">int</span> n)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>理解了数据的存储和展示，我们回头看看以下几种日期和时间：</p><ul><li>2019-11-20 0:15:01 GMT+00:00</li><li>2019年11月20日8:15:01</li><li>11/19/2019 19:15:01 America/New_York</li></ul><p>它们实际上是数据的展示格式，分别按英国时区、中国时区、纽约时区对同一个时刻进行展示。而这个“同一个时刻”在计算机中存储的本质上只是一个整数，我们称它为<code>Epoch Time</code>。</p><p><code>Epoch Time</code>是计算从1970年1月1日零点（格林威治时区／GMT+00:00）到现在所经历的秒数，例如：</p><p><code>1574208900</code>表示从1970年1月1日零点GMT时区到该时刻一共经历了1574208900秒，换算成伦敦、北京和纽约时间分别是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1574208900 = 北京时间2019-11-20 8:15:00</span><br><span class="line">           = 伦敦时间2019-11-20 0:15:00</span><br><span class="line">           = 纽约时间2019-11-19 19:15:00</span><br></pre></td></tr></table></figure><p><img src="https://liaoxuefeng.com/books/java/datetime/date-calendar/localtime.jpg" alt="localtime"></p><p>因此，在计算机中，只需要存储一个整数<code>1574208900</code>表示某一时刻。当需要显示为某一地区的当地时间时，我们就把它格式化为一个字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">displayDateTime</span><span class="params">(<span class="type">int</span> n, String timezone)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p><code>Epoch Time</code>又称为时间戳，在不同的编程语言中，会有几种存储方式：</p><ul><li>以秒为单位的整数：1574208900，缺点是精度只能到秒；</li><li>以毫秒为单位的整数：1574208900123，最后3位表示毫秒数；</li><li>以秒为单位的浮点数：1574208900.123，小数点后面表示零点几秒。</li></ul><p>它们之间转换非常简单。而在Java程序中，时间戳通常是用<code>long</code>表示的毫秒数，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">1574208900123L</span>;</span><br></pre></td></tr></table></figure><p>转换成北京时间就是<code>2019-11-20T8:15:00.123</code>。要获取当前时间戳，可以使用<code>System.currentTimeMillis()</code>，这是Java程序获取时间戳最常用的方法。</p><h3 id="标准库API">标准库API</h3><p>我们再来看一下Java标准库提供的API。Java标准库有两套处理日期和时间的API：</p><ul><li>一套定义在<code>java.util</code>这个包里面，主要包括<code>Date</code>、<code>Calendar</code>和<code>TimeZone</code>这几个类；</li><li>一套新的API是在Java 8引入的，定义在<code>java.time</code>这个包里面，主要包括<code>LocalDateTime</code>、<code>ZonedDateTime</code>、<code>ZoneId</code>等。</li></ul><p>为什么会有新旧两套API呢？因为历史遗留原因，旧的API存在很多问题，所以引入了新的API。</p><p>那么我们能不能跳过旧的API直接用新的API呢？如果涉及到遗留代码就不行，因为很多遗留代码仍然使用旧的API，所以目前仍然需要对旧的API有一定了解，很多时候还需要在新旧两种对象之间进行转换。</p><p>本节我们快速讲解旧API的常用类型和方法。</p><h3 id="Date">Date</h3><p><code>java.util.Date</code>是用于表示一个日期和时间的对象，注意与<code>java.sql.Date</code>区分，后者用在数据库中。如果观察<code>Date</code>的源码，可以发现它实际上存储了一个<code>long</code>类型的以毫秒表示的时间戳：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Date</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, Cloneable, Comparable&lt;Date&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">long</span> fastTime;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看Date的基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前时间:</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(date.getYear() + <span class="number">1900</span>); <span class="comment">// 必须加上1900</span></span><br><span class="line">        System.out.println(date.getMonth() + <span class="number">1</span>); <span class="comment">// 0~11，必须加上1</span></span><br><span class="line">        System.out.println(date.getDate()); <span class="comment">// 1~31，不能加1</span></span><br><span class="line">        <span class="comment">// 转换为String:</span></span><br><span class="line">        System.out.println(date.toString());</span><br><span class="line">        <span class="comment">// 转换为GMT时区:</span></span><br><span class="line">        System.out.println(date.toGMTString());</span><br><span class="line">        <span class="comment">// 转换为本地时区:</span></span><br><span class="line">        System.out.println(date.toLocaleString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>getYear()</code>返回的年份必须加上<code>1900</code>，<code>getMonth()</code>返回的月份是<code>0</code>~<code>11</code>分别表示1~12月，所以要加1，而<code>getDate()</code>返回的日期范围是<code>1</code>~<code>31</code>，又不能加1。</p><p>打印本地时区表示的日期和时间时，不同的计算机可能会有不同的结果。如果我们想要针对用户的偏好精确地控制日期和时间的格式，就可以使用<code>SimpleDateFormat</code>对一个<code>Date</code>进行转换。它用预定义的字符串表示格式化：</p><ul><li>yyyy：年</li><li>MM：月</li><li>dd: 日</li><li>HH: 小时</li><li>mm: 分钟</li><li>ss: 秒</li></ul><p>我们来看如何以自定义的格式输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前时间:</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(sdf.format(date));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java的格式化预定义了许多不同的格式，我们以<code>MMM</code>和<code>E</code>为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前时间:</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;E MMM dd, yyyy&quot;</span>);</span><br><span class="line">        System.out.println(sdf.format(date));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码在不同的语言环境会打印出类似<code>Sun Sep 15, 2019</code>这样的日期。可以从<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/text/SimpleDateFormat.html">JDK文档</a>查看详细的格式说明。一般来说，字母越长，输出越长。以<code>M</code>为例，假设当前月份是9月：</p><ul><li><code>M</code>：输出<code>9</code></li><li><code>MM</code>：输出<code>09</code></li><li><code>MMM</code>：输出<code>Sep</code></li><li><code>MMMM</code>：输出<code>September</code></li></ul><p><code>Date</code>对象有几个严重的问题：它不能转换时区，除了<code>toGMTString()</code>可以按<code>GMT+0:00</code>输出外，<code>Date</code>总是以当前计算机系统的默认时区为基础进行输出。此外，我们也很难对日期和时间进行加减，计算两个日期相差多少天，计算某个月第一个星期一的日期等。</p><h3 id="Calendar">Calendar</h3><p><code>Calendar</code>可以用于获取并设置年、月、日、时、分、秒，它和<code>Date</code>比，主要多了一个可以做简单的日期和时间运算的功能。</p><p>我们来看<code>Calendar</code>的基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前时间:</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> c.get(Calendar.YEAR);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span> + c.get(Calendar.MONTH);</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> c.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">        <span class="type">int</span> <span class="variable">hh</span> <span class="operator">=</span> c.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">        <span class="type">int</span> <span class="variable">mm</span> <span class="operator">=</span> c.get(Calendar.MINUTE);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ss</span> <span class="operator">=</span> c.get(Calendar.SECOND);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ms</span> <span class="operator">=</span> c.get(Calendar.MILLISECOND);</span><br><span class="line">        System.out.println(y + <span class="string">&quot;-&quot;</span> + m + <span class="string">&quot;-&quot;</span> + d + <span class="string">&quot; &quot;</span> + w + <span class="string">&quot; &quot;</span> + hh + <span class="string">&quot;:&quot;</span> + mm + <span class="string">&quot;:&quot;</span> + ss + <span class="string">&quot;.&quot;</span> + ms);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>Calendar</code>获取年月日这些信息变成了<code>get(int field)</code>，返回的年份不必转换，返回的月份仍然要加1，返回的星期要特别注意，<code>1</code>~<code>7</code>分别表示周日，周一，……，周六。</p><p><code>Calendar</code>只有一种方式获取，即<code>Calendar.getInstance()</code>，而且一获取到就是当前时间。如果我们想给它设置成特定的一个日期和时间，就必须先清除所有字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前时间:</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 清除所有:</span></span><br><span class="line">        c.clear();</span><br><span class="line">        <span class="comment">// 设置2019年:</span></span><br><span class="line">        c.set(Calendar.YEAR, <span class="number">2019</span>);</span><br><span class="line">        <span class="comment">// 设置9月:注意8表示9月:</span></span><br><span class="line">        c.set(Calendar.MONTH, <span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 设置2日:</span></span><br><span class="line">        c.set(Calendar.DATE, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 设置时间:</span></span><br><span class="line">        c.set(Calendar.HOUR_OF_DAY, <span class="number">21</span>);</span><br><span class="line">        c.set(Calendar.MINUTE, <span class="number">22</span>);</span><br><span class="line">        c.set(Calendar.SECOND, <span class="number">23</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(c.getTime()));</span><br><span class="line">        <span class="comment">// 2019-09-02 21:22:23</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用<code>Calendar.getTime()</code>可以将一个<code>Calendar</code>对象转换成<code>Date</code>对象，然后就可以用<code>SimpleDateFormat</code>进行格式化了。</p><h3 id="TimeZone">TimeZone</h3><p><code>Calendar</code>和<code>Date</code>相比，它提供了时区转换的功能。时区用<code>TimeZone</code>对象表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TimeZone</span> <span class="variable">tzDefault</span> <span class="operator">=</span> TimeZone.getDefault(); <span class="comment">// 当前时区</span></span><br><span class="line">        <span class="type">TimeZone</span> <span class="variable">tzGMT9</span> <span class="operator">=</span> TimeZone.getTimeZone(<span class="string">&quot;GMT+09:00&quot;</span>); <span class="comment">// GMT+9:00时区</span></span><br><span class="line">        <span class="type">TimeZone</span> <span class="variable">tzNY</span> <span class="operator">=</span> TimeZone.getTimeZone(<span class="string">&quot;America/New_York&quot;</span>); <span class="comment">// 纽约时区</span></span><br><span class="line">        System.out.println(tzDefault.getID()); <span class="comment">// Asia/Shanghai</span></span><br><span class="line">        System.out.println(tzGMT9.getID()); <span class="comment">// GMT+09:00</span></span><br><span class="line">        System.out.println(tzNY.getID()); <span class="comment">// America/New_York</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时区的唯一标识是以字符串表示的ID，我们获取指定<code>TimeZone</code>对象也是以这个ID为参数获取，<code>GMT+09:00</code>、<code>Asia/Shanghai</code>都是有效的时区ID。要列出系统支持的所有ID，请使用<code>TimeZone.getAvailableIDs()</code>。</p><p>有了时区，我们就可以对指定时间进行转换。例如，下面的例子演示了如何将北京时间<code>2019-11-20 8:15:00</code>转换为纽约时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前时间:</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 清除所有:</span></span><br><span class="line">        c.clear();</span><br><span class="line">        <span class="comment">// 设置为北京时区:</span></span><br><span class="line">        c.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">        <span class="comment">// 设置年月日时分秒:</span></span><br><span class="line">        c.set(<span class="number">2019</span>, <span class="number">10</span> <span class="comment">/* 11月 */</span>, <span class="number">20</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 显示时间:</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        sdf.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">        System.out.println(sdf.format(c.getTime()));</span><br><span class="line">        <span class="comment">// 2019-11-19 19:15:00</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，利用<code>Calendar</code>进行时区转换的步骤是：</p><ol><li>清除所有字段；</li><li>设定指定时区；</li><li>设定日期和时间；</li><li>创建<code>SimpleDateFormat</code>并设定目标时区；</li><li>格式化获取的<code>Date</code>对象（注意<code>Date</code>对象无时区信息，时区信息存储在<code>SimpleDateFormat</code>中）。</li></ol><p>因此，本质上时区转换只能通过<code>SimpleDateFormat</code>在显示的时候完成。</p><p><code>Calendar</code>也可以对日期和时间进行简单的加减：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前时间:</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 清除所有:</span></span><br><span class="line">        c.clear();</span><br><span class="line">        <span class="comment">// 设置年月日时分秒:</span></span><br><span class="line">        c.set(<span class="number">2019</span>, <span class="number">10</span> <span class="comment">/* 11月 */</span>, <span class="number">20</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 加5天并减去2小时:</span></span><br><span class="line">        c.add(Calendar.DAY_OF_MONTH, <span class="number">5</span>);</span><br><span class="line">        c.add(Calendar.HOUR_OF_DAY, -<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 显示时间:</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> c.getTime();</span><br><span class="line">        System.out.println(sdf.format(d));</span><br><span class="line">        <span class="comment">// 2019-11-25 6:15:00</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-2">小结</h3><p>计算机表示的时间是以整数表示的时间戳存储的，即Epoch Time，Java使用<code>long</code>型来表示以毫秒为单位的时间戳，通过<code>System.currentTimeMillis()</code>获取当前时间戳。</p><p>Java有两套日期和时间的API：</p><ul><li>旧的Date、Calendar和TimeZone；</li><li>新的LocalDateTime、ZonedDateTime、ZoneId等。</li></ul><p>分别位于<code>java.util</code>和<code>java.time</code>包中。</p><p>从Java 8开始，<code>java.time</code>包提供了新的日期和时间API，主要涉及的类型有：</p><ul><li>本地日期和时间：<code>LocalDateTime</code>，<code>LocalDate</code>，<code>LocalTime</code>；</li><li>带时区的日期和时间：<code>ZonedDateTime</code>；</li><li>时刻：<code>Instant</code>；</li><li>时区：<code>ZoneId</code>，<code>ZoneOffset</code>；</li><li>时间间隔：<code>Duration</code>。</li></ul><p>以及一套新的用于取代<code>SimpleDateFormat</code>的格式化类型<code>DateTimeFormatter</code>。</p><p>和旧的API相比，新API严格区分了时刻、本地日期、本地时间和带时区的日期时间，并且，对日期和时间进行运算更加方便。</p><p>此外，新API修正了旧API不合理的常量设计：</p><ul><li>Month的范围用1~12表示1月到12月；</li><li>Week的范围用1~7表示周一到周日。</li></ul><p>最后，新API的类型几乎全部是不变类型（和String类似），可以放心使用不必担心被修改。</p><h3 id="LocalDateTime">LocalDateTime</h3><p>我们首先来看最常用的<code>LocalDateTime</code>，它表示一个本地日期和时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">d</span> <span class="operator">=</span> LocalDate.now(); <span class="comment">// 当前日期</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">t</span> <span class="operator">=</span> LocalTime.now(); <span class="comment">// 当前时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dt</span> <span class="operator">=</span> LocalDateTime.now(); <span class="comment">// 当前日期和时间</span></span><br><span class="line">        System.out.println(d); <span class="comment">// 严格按照ISO 8601格式打印</span></span><br><span class="line">        System.out.println(t); <span class="comment">// 严格按照ISO 8601格式打印</span></span><br><span class="line">        System.out.println(dt); <span class="comment">// 严格按照ISO 8601格式打印</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本地日期和时间通过now()获取到的总是以当前默认时区返回的，和旧API不同，<code>LocalDateTime</code>、<code>LocalDate</code>和<code>LocalTime</code>默认严格按照<a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>规定的日期和时间格式进行打印。</p><p>上述代码其实有一个小问题，在获取3个类型的时候，由于执行一行代码总会消耗一点时间，因此，3个类型的日期和时间很可能对不上（时间的毫秒数基本上不同）。为了保证获取到同一时刻的日期和时间，可以改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dt</span> <span class="operator">=</span> LocalDateTime.now(); <span class="comment">// 当前日期和时间</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">d</span> <span class="operator">=</span> dt.toLocalDate(); <span class="comment">// 转换到当前日期</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">t</span> <span class="operator">=</span> dt.toLocalTime(); <span class="comment">// 转换到当前时间</span></span><br></pre></td></tr></table></figure><p>反过来，通过指定的日期和时间创建<code>LocalDateTime</code>可以通过<code>of()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定日期和时间:</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">d2</span> <span class="operator">=</span> LocalDate.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">30</span>); <span class="comment">// 2019-11-30, 注意11=11月</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">t2</span> <span class="operator">=</span> LocalTime.of(<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>); <span class="comment">// 15:16:17</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dt2</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">30</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dt3</span> <span class="operator">=</span> LocalDateTime.of(d2, t2);</span><br></pre></td></tr></table></figure><p>因为严格按照ISO 8601的格式，因此，将字符串转换为<code>LocalDateTime</code>就可以传入标准格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dt</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2019-11-19T15:16:17&quot;</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">d</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2019-11-19&quot;</span>);</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">t</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;15:16:17&quot;</span>);</span><br></pre></td></tr></table></figure><p>注意ISO 8601规定的日期和时间分隔符是<code>T</code>。标准格式如下：</p><ul><li>日期：yyyy-MM-dd</li><li>时间：HH:mm:ss</li><li>带毫秒的时间：HH:mm:ss.SSS</li><li>日期和时间：yyyy-MM-dd’T’HH:mm:ss</li><li>带毫秒的日期和时间：yyyy-MM-dd’T’HH:mm:ss.SSS</li></ul><h3 id="DateTimeFormatter">DateTimeFormatter</h3><p>如果要自定义输出的格式，或者要把一个非ISO 8601格式的字符串解析成<code>LocalDateTime</code>，可以使用新的<code>DateTimeFormatter</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.format.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义格式化:</span></span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(dtf.format(LocalDateTime.now()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用自定义格式解析:</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dt2</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2019/11/30 15:16:17&quot;</span>, dtf);</span><br><span class="line">        System.out.println(dt2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LocalDateTime</code>提供了对日期和时间进行加减的非常简单的链式调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dt</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">26</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">59</span>);</span><br><span class="line">        System.out.println(dt);</span><br><span class="line">        <span class="comment">// 加5天减3小时:</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dt2</span> <span class="operator">=</span> dt.plusDays(<span class="number">5</span>).minusHours(<span class="number">3</span>);</span><br><span class="line">        System.out.println(dt2); <span class="comment">// 2019-10-31T17:30:59</span></span><br><span class="line">        <span class="comment">// 减1月:</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dt3</span> <span class="operator">=</span> dt2.minusMonths(<span class="number">1</span>);</span><br><span class="line">        System.out.println(dt3); <span class="comment">// 2019-09-30T17:30:59</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到月份加减会自动调整日期，例如从<code>2019-10-31</code>减去1个月得到的结果是<code>2019-09-30</code>，因为9月没有31日。</p><p>对日期和时间进行调整则使用<code>withXxx()</code>方法，例如：<code>withHour(15)</code>会把<code>10:11:12</code>变为<code>15:11:12</code>：</p><ul><li>调整年：withYear()</li><li>调整月：withMonth()</li><li>调整日：withDayOfMonth()</li><li>调整时：withHour()</li><li>调整分：withMinute()</li><li>调整秒：withSecond()</li></ul><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dt</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">26</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">59</span>);</span><br><span class="line">        System.out.println(dt);</span><br><span class="line">        <span class="comment">// 日期变为31日:</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dt2</span> <span class="operator">=</span> dt.withDayOfMonth(<span class="number">31</span>);</span><br><span class="line">        System.out.println(dt2); <span class="comment">// 2019-10-31T20:30:59</span></span><br><span class="line">        <span class="comment">// 月份变为9:</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dt3</span> <span class="operator">=</span> dt2.withMonth(<span class="number">9</span>);</span><br><span class="line">        System.out.println(dt3); <span class="comment">// 2019-09-30T20:30:59</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样注意到调整月份时，会相应地调整日期，即把<code>2019-10-31</code>的月份调整为<code>9</code>时，日期也自动变为<code>30</code>。</p><p>实际上，<code>LocalDateTime</code>还有一个通用的<code>with()</code>方法允许我们做更复杂的运算。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 本月第一天0:00时刻:</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">firstDay</span> <span class="operator">=</span> LocalDate.now().withDayOfMonth(<span class="number">1</span>).atStartOfDay();</span><br><span class="line">        System.out.println(firstDay);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本月最后1天:</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">lastDay</span> <span class="operator">=</span> LocalDate.now().with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">        System.out.println(lastDay);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下月第1天:</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">nextMonthFirstDay</span> <span class="operator">=</span> LocalDate.now().with(TemporalAdjusters.firstDayOfNextMonth());</span><br><span class="line">        System.out.println(nextMonthFirstDay);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本月第1个周一:</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">firstWeekday</span> <span class="operator">=</span> LocalDate.now().with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));</span><br><span class="line">        System.out.println(firstWeekday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于计算某个月第1个周日这样的问题，新的API可以轻松完成。</p><p>要判断两个<code>LocalDateTime</code>的先后，可以使用<code>isBefore()</code>、<code>isAfter()</code>方法，对于<code>LocalDate</code>和<code>LocalTime</code>类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">target</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">        System.out.println(now.isBefore(target));</span><br><span class="line">        System.out.println(LocalDate.now().isBefore(LocalDate.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>)));</span><br><span class="line">        System.out.println(LocalTime.now().isAfter(LocalTime.parse(<span class="string">&quot;08:15:00&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>LocalDateTime</code>无法与时间戳进行转换，因为<code>LocalDateTime</code>没有时区，无法确定某一时刻。后面我们要介绍的<code>ZonedDateTime</code>相当于<code>LocalDateTime</code>加时区的组合，它具有时区，可以与<code>long</code>表示的时间戳进行转换。</p><h3 id="Duration和Period">Duration和Period</h3><p><code>Duration</code>表示两个时刻之间的时间间隔。另一个类似的<code>Period</code>表示两个日期之间的天数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">start</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">end</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">19</span>, <span class="number">25</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="type">Duration</span> <span class="variable">d</span> <span class="operator">=</span> Duration.between(start, end);</span><br><span class="line">        System.out.println(d); <span class="comment">// PT1235H10M30S</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Period</span> <span class="variable">p</span> <span class="operator">=</span> LocalDate.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>).until(LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">9</span>));</span><br><span class="line">        System.out.println(p); <span class="comment">// P1M21D</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到两个<code>LocalDateTime</code>之间的差值使用<code>Duration</code>表示，类似<code>PT1235H10M30S</code>，表示1235小时10分钟30秒。而两个<code>LocalDate</code>之间的差值用<code>Period</code>表示，类似<code>P1M21D</code>，表示1个月21天。</p><p><code>Duration</code>和<code>Period</code>的表示方法也符合ISO 8601的格式，它以<code>P...T...</code>的形式表示，<code>P...T</code>之间表示日期间隔，<code>T</code>后面表示时间间隔。如果是<code>PT...</code>的格式表示仅有时间间隔。利用<code>ofXxx()</code>或者<code>parse()</code>方法也可以直接创建<code>Duration</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Duration</span> <span class="variable">d1</span> <span class="operator">=</span> Duration.ofHours(<span class="number">10</span>); <span class="comment">// 10 hours</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">d2</span> <span class="operator">=</span> Duration.parse(<span class="string">&quot;P1DT2H3M&quot;</span>); <span class="comment">// 1 day, 2 hours, 3 minutes</span></span><br></pre></td></tr></table></figure><p>有的童鞋可能发现Java 8引入的<code>java.time</code>API。怎么和一个开源的<a href="https://www.joda.org/">Joda Time</a>很像？难道JDK也开始抄袭开源了？其实正是因为开源的Joda Time设计很好，应用广泛，所以JDK团队邀请Joda Time的作者Stephen Colebourne共同设计了<code>java.time</code>API。</p><h3 id="小结-3">小结</h3><p>Java 8引入了新的日期和时间API，它们是不变类，默认按ISO 8601标准格式化和解析；</p><p>使用<code>LocalDateTime</code>可以非常方便地对日期和时间进行加减，或者调整日期和时间，它总是返回新对象；</p><p>使用<code>isBefore()</code>和<code>isAfter()</code>可以判断日期和时间的先后；</p><p>使用<code>Duration</code>和<code>Period</code>可以表示两个日期和时间的“区间间隔”。</p><p><code>LocalDateTime</code>总是表示本地日期和时间，要表示一个带时区的日期和时间，我们就需要<code>ZonedDateTime</code>。</p><p>可以简单地把<code>ZonedDateTime</code>理解成<code>LocalDateTime</code>加<code>ZoneId</code>。<code>ZoneId</code>是<code>java.time</code>引入的新的时区类，注意和旧的<code>java.util.TimeZone</code>区别。</p><p>要创建一个<code>ZonedDateTime</code>对象，有以下几种方法，一种是通过<code>now()</code>方法返回当前时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">zbj</span> <span class="operator">=</span> ZonedDateTime.now(); <span class="comment">// 默认时区</span></span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">zny</span> <span class="operator">=</span> ZonedDateTime.now(ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>)); <span class="comment">// 用指定时区获取当前时间</span></span><br><span class="line">        System.out.println(zbj);</span><br><span class="line">        System.out.println(zny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察打印的两个<code>ZonedDateTime</code>，发现它们时区不同，但表示的时间都是同一时刻（毫秒数不同是执行语句时的时间差）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-09-15T20:58:18.786182+08:00[Asia/Shanghai]</span><br><span class="line">2019-09-15T08:58:18.788860-04:00[America/New_York]</span><br></pre></td></tr></table></figure><p>另一种方式是通过给一个<code>LocalDateTime</code>附加一个<code>ZoneId</code>，就可以变成<code>ZonedDateTime</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2019</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>);</span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">zbj</span> <span class="operator">=</span> ldt.atZone(ZoneId.systemDefault());</span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">zny</span> <span class="operator">=</span> ldt.atZone(ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">        System.out.println(zbj);</span><br><span class="line">        System.out.println(zny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以这种方式创建的<code>ZonedDateTime</code>，它的日期和时间与<code>LocalDateTime</code>相同，但附加的时区不同，因此是两个不同的时刻：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-09-15T15:16:17+08:00[Asia/Shanghai]</span><br><span class="line">2019-09-15T15:16:17-04:00[America/New_York]</span><br></pre></td></tr></table></figure><h3 id="时区转换">时区转换</h3><p>要转换时区，首先我们需要有一个<code>ZonedDateTime</code>对象，然后，通过<code>withZoneSameInstant()</code>将关联时区转换到另一个时区，转换后日期和时间都会相应调整。</p><p>下面的代码演示了如何将北京时间转换为纽约时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 以中国时区获取当前时间:</span></span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">zbj</span> <span class="operator">=</span> ZonedDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">        <span class="comment">// 转换为纽约时间:</span></span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">zny</span> <span class="operator">=</span> zbj.withZoneSameInstant(ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">        System.out.println(zbj);</span><br><span class="line">        System.out.println(zny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要特别注意，时区转换的时候，由于夏令时的存在，不同的日期转换的结果很可能是不同的。这是北京时间9月15日的转换结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-09-15T21:05:50.187697+08:00[Asia/Shanghai]</span><br><span class="line">2019-09-15T09:05:50.187697-04:00[America/New_York]</span><br></pre></td></tr></table></figure><p>这是北京时间11月15日的转换结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-11-15T21:05:50.187697+08:00[Asia/Shanghai]</span><br><span class="line">2019-11-15T08:05:50.187697-05:00[America/New_York]</span><br></pre></td></tr></table></figure><p>两次转换后的纽约时间有1小时的夏令时时差。</p><p>注意</p><p>涉及到时区时，千万不要自己计算时差，否则难以正确处理夏令时。</p><p>有了<code>ZonedDateTime</code>，将其转换为本地时间就非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zdt</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> zdt.toLocalDateTime();</span><br></pre></td></tr></table></figure><p>转换为<code>LocalDateTime</code>时，直接丢弃了时区信息。</p><h3 id="练习">练习</h3><p>某航线从北京飞到纽约需要13小时20分钟，请根据北京起飞日期和时间计算到达纽约的当地日期和时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">departureAtBeijing</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2019</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">hours</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minutes</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">arrivalAtNewYork</span> <span class="operator">=</span> calculateArrivalAtNY(departureAtBeijing, hours, minutes);</span><br><span class="line">        System.out.println(departureAtBeijing + <span class="string">&quot; -&gt; &quot;</span> + arrivalAtNewYork);</span><br><span class="line">        <span class="comment">// test:</span></span><br><span class="line">        <span class="keyword">if</span> (!LocalDateTime.of(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">20</span>, <span class="number">0</span>)</span><br><span class="line">                .equals(calculateArrivalAtNY(LocalDateTime.of(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">13</span>, <span class="number">20</span>))) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;测试失败!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!LocalDateTime.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">20</span>, <span class="number">0</span>)</span><br><span class="line">                .equals(calculateArrivalAtNY(LocalDateTime.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">13</span>, <span class="number">20</span>))) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;测试失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> LocalDateTime <span class="title function_">calculateArrivalAtNY</span><span class="params">(LocalDateTime bj, <span class="type">int</span> h, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示：<code>ZonedDateTime</code>仍然提供了<code>plusDays()</code>等加减操作。</p><p><a href="https://liaoxuefeng.com/books/java/datetime/zoned-datetime/datetime-flight.zip">下载练习</a></p><h3 id="小结-4">小结</h3><p><code>ZonedDateTime</code>是带时区的日期和时间，可用于时区转换；</p><p><code>ZonedDateTime</code>和<code>LocalDateTime</code>可以相互转换。</p><h2 id="DateTimeFormatter-2">DateTimeFormatter</h2><p>使用旧的<code>Date</code>对象时，我们用<code>SimpleDateFormat</code>进行格式化显示。使用新的<code>LocalDateTime</code>或<code>ZonedDateTime</code>时，我们要进行格式化显示，就要使用<code>DateTimeFormatter</code>。</p><p>和<code>SimpleDateFormat</code>不同的是，<code>DateTimeFormatter</code>不但是不变对象，它还是线程安全的。线程的概念我们会在后面涉及到。现在我们只需要记住：因为<code>SimpleDateFormat</code>不是线程安全的，使用的时候，只能在方法内部创建新的局部变量。而<code>DateTimeFormatter</code>可以只创建一个实例，到处引用。</p><p>创建<code>DateTimeFormatter</code>时，我们仍然通过传入格式化字符串实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm&quot;</span>);</span><br></pre></td></tr></table></figure><p>格式化字符串的使用方式与<code>SimpleDateFormat</code>完全一致。</p><p>另一种创建<code>DateTimeFormatter</code>的方法是，传入格式化字符串时，同时指定<code>Locale</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;E, yyyy-MMMM-dd HH:mm&quot;</span>, Locale.US);</span><br></pre></td></tr></table></figure><p>这种方式可以按照<code>Locale</code>默认习惯格式化。我们来看实际效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.format.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">zdt</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">        <span class="type">var</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm ZZZZ&quot;</span>);</span><br><span class="line">        System.out.println(formatter.format(zdt));</span><br><span class="line"></span><br><span class="line">        <span class="type">var</span> <span class="variable">zhFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy MMM dd EE HH:mm&quot;</span>, Locale.CHINA);</span><br><span class="line">        System.out.println(zhFormatter.format(zdt));</span><br><span class="line"></span><br><span class="line">        <span class="type">var</span> <span class="variable">usFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;E, MMMM/dd/yyyy HH:mm&quot;</span>, Locale.US);</span><br><span class="line">        System.out.println(usFormatter.format(zdt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在格式化字符串中，如果需要输出固定字符，可以用<code>'xxx'</code>表示。</p><p>运行上述代码，分别以默认方式、中国地区和美国地区对当前时间进行显示，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019-09-15T23:16 GMT+08:00</span><br><span class="line">2019 9月 15 周日 23:16</span><br><span class="line">Sun, September/15/2019 23:16</span><br></pre></td></tr></table></figure><p>当我们直接调用<code>System.out.println()</code>对一个<code>ZonedDateTime</code>或者<code>LocalDateTime</code>实例进行打印的时候，实际上，调用的是它们的<code>toString()</code>方法，默认的<code>toString()</code>方法显示的字符串就是按照<code>ISO 8601</code>格式显示的，我们可以通过<code>DateTimeFormatter</code>预定义的几个静态变量来引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(DateTimeFormatter.ISO_DATE.format(ldt));</span><br><span class="line">System.out.println(DateTimeFormatter.ISO_DATE_TIME.format(ldt));</span><br></pre></td></tr></table></figure><p>得到的输出和<code>toString()</code>类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-09-15</span><br><span class="line">2019-09-15T23:16:51.56217</span><br></pre></td></tr></table></figure><h3 id="小结-5">小结</h3><p>对<code>ZonedDateTime</code>或<code>LocalDateTime</code>进行格式化，需要使用<code>DateTimeFormatter</code>类；</p><p><code>DateTimeFormatter</code>可以通过格式化字符串和<code>Locale</code>对日期和时间进行定制输出。</p><hr><hr><h2 id="Instant">Instant</h2><p>我们已经讲过，计算机存储的当前时间，本质上只是一个不断递增的整数。Java提供的<code>System.currentTimeMillis()</code>返回的就是以毫秒表示的当前时间戳。</p><p>这个当前时间戳在<code>java.time</code>中以<code>Instant</code>类型表示，我们用<code>Instant.now()</code>获取当前时间戳，效果和<code>System.currentTimeMillis()</code>类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">        System.out.println(now.getEpochSecond()); <span class="comment">// 秒</span></span><br><span class="line">        System.out.println(now.toEpochMilli()); <span class="comment">// 毫秒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的结果类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1568568760</span><br><span class="line">1568568760316</span><br></pre></td></tr></table></figure><p>实际上，<code>Instant</code>内部只有两个核心字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Instant</span> implements ... &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> seconds;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> nanos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个是以秒为单位的时间戳，一个是更精确的纳秒精度。它和<code>System.currentTimeMillis()</code>返回的<code>long</code>相比，只是多了更高精度的纳秒。</p><p>既然<code>Instant</code>就是时间戳，那么，给它附加上一个时区，就可以创建出<code>ZonedDateTime</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以指定时间戳创建Instant:</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">ins</span> <span class="operator">=</span> Instant.ofEpochSecond(<span class="number">1568568760</span>);</span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zdt</span> <span class="operator">=</span> ins.atZone(ZoneId.systemDefault());</span><br><span class="line">System.out.println(zdt); <span class="comment">// 2019-09-16T01:32:40+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure><p>可见，对于某一个时间戳，给它关联上指定的<code>ZoneId</code>，就得到了<code>ZonedDateTime</code>，继而可以获得了对应时区的<code>LocalDateTime</code>。</p><p>所以，<code>LocalDateTime</code>，<code>ZoneId</code>，<code>Instant</code>，<code>ZonedDateTime</code>和<code>long</code>都可以互相转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐</span><br><span class="line">│LocalDateTime│────┐</span><br><span class="line">└─────────────┘    │    ┌─────────────┐</span><br><span class="line">                   ├───▶│ZonedDateTime│</span><br><span class="line">┌─────────────┐    │    └─────────────┘</span><br><span class="line">│   ZoneId    │────┘           ▲</span><br><span class="line">└─────────────┘      ┌─────────┴─────────┐</span><br><span class="line">                     │                   │</span><br><span class="line">                     ▼                   ▼</span><br><span class="line">              ┌─────────────┐     ┌─────────────┐</span><br><span class="line">              │   Instant   │◀───▶│    long     │</span><br><span class="line">              └─────────────┘     └─────────────┘</span><br></pre></td></tr></table></figure><p>转换的时候，只需要留意<code>long</code>类型以毫秒还是秒为单位即可。</p><h3 id="小结-6">小结</h3><p><code>Instant</code>表示高精度时间戳，它可以和<code>ZonedDateTime</code>以及<code>long</code>互相转换。</p><hr><hr><p>由于Java提供了新旧两套日期和时间的API，除非涉及到遗留代码，否则我们应该坚持使用新的API。</p><p>如果需要与遗留代码打交道，如何在新旧API之间互相转换呢？</p><h3 id="旧API转新API">旧API转新API</h3><p>如果要把旧式的<code>Date</code>或<code>Calendar</code>转换为新API对象，可以通过<code>toInstant()</code>方法转换为<code>Instant</code>对象，再继续转换为<code>ZonedDateTime</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Date -&gt; Instant:</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">ins1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().toInstant();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calendar -&gt; Instant -&gt; ZonedDateTime:</span></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="type">Instant</span> <span class="variable">ins2</span> <span class="operator">=</span> calendar.toInstant();</span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zdt</span> <span class="operator">=</span> ins2.atZone(calendar.getTimeZone().toZoneId());</span><br></pre></td></tr></table></figure><p>从上面的代码还可以看到，旧的<code>TimeZone</code>提供了一个<code>toZoneId()</code>，可以把自己变成新的<code>ZoneId</code>。</p><h3 id="新API转旧API">新API转旧API</h3><p>如果要把新的<code>ZonedDateTime</code>转换为旧的API对象，只能借助<code>long</code>型时间戳做一个“中转”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZonedDateTime -&gt; long:</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zdt</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line"><span class="type">long</span> <span class="variable">ts</span> <span class="operator">=</span> zdt.toEpochSecond() * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// long -&gt; Date:</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(ts);</span><br><span class="line"></span><br><span class="line"><span class="comment">// long -&gt; Calendar:</span></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">calendar.clear();</span><br><span class="line">calendar.setTimeZone(TimeZone.getTimeZone(zdt.getZone().getId()));</span><br><span class="line">calendar.setTimeInMillis(zdt.toEpochSecond() * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>从上面的代码还可以看到，新的<code>ZoneId</code>转换为旧的<code>TimeZone</code>，需要借助<code>ZoneId.getId()</code>返回的<code>String</code>完成。</p><h3 id="在数据库中存储日期和时间">在数据库中存储日期和时间</h3><p>除了旧式的<code>java.util.Date</code>，我们还可以找到另一个<code>java.sql.Date</code>，它继承自<code>java.util.Date</code>，但会自动忽略所有时间相关信息。这个奇葩的设计原因要追溯到数据库的日期与时间类型。</p><p>在数据库中，也存在几种日期和时间类型：</p><ul><li><code>DATETIME</code>：表示日期和时间；</li><li><code>DATE</code>：仅表示日期；</li><li><code>TIME</code>：仅表示时间；</li><li><code>TIMESTAMP</code>：和<code>DATETIME</code>类似，但是数据库会在创建或者更新记录的时候同时修改<code>TIMESTAMP</code>。</li></ul><p>在使用Java程序操作数据库时，我们需要把数据库类型与Java类型映射起来。下表是数据库类型与Java新旧API的映射关系：</p><table><thead><tr><th>数据库</th><th>对应Java类（旧）</th><th>对应Java类（新）</th></tr></thead><tbody><tr><td>DATETIME</td><td>java.util.Date</td><td>LocalDateTime</td></tr><tr><td>DATE</td><td>java.sql.Date</td><td>LocalDate</td></tr><tr><td>TIME</td><td>java.sql.Time</td><td>LocalTime</td></tr><tr><td>TIMESTAMP</td><td>java.sql.Timestamp</td><td>LocalDateTime</td></tr></tbody></table><p>实际上，在数据库中，我们需要存储的最常用的是时刻（<code>Instant</code>），因为有了时刻信息，就可以根据用户自己选择的时区，显示出正确的本地时间。所以，最好的方法是直接用长整数<code>long</code>表示，在数据库中存储为<code>BIGINT</code>类型。</p><p>通过存储一个<code>long</code>型时间戳，我们可以编写一个<code>timestampToString()</code>的方法，非常简单地为不同用户以不同的偏好来显示不同的本地时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.format.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="number">1574208900000L</span>;</span><br><span class="line">        System.out.println(timestampToString(ts, Locale.CHINA, <span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">        System.out.println(timestampToString(ts, Locale.US, <span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">timestampToString</span><span class="params">(<span class="type">long</span> epochMilli, Locale lo, String zoneId)</span> &#123;</span><br><span class="line">        <span class="type">Instant</span> <span class="variable">ins</span> <span class="operator">=</span> Instant.ofEpochMilli(epochMilli);</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">f</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM, FormatStyle.SHORT);</span><br><span class="line">        <span class="keyword">return</span> f.withLocale(lo).format(ZonedDateTime.ofInstant(ins, ZoneId.of(zoneId)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上述方法进行调用，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019年11月20日 上午8:15</span><br><span class="line">Nov 19, 2019, 7:15 PM</span><br></pre></td></tr></table></figure><h3 id="小结-7">小结</h3><p>处理日期和时间时，尽量使用新的<code>java.time</code>包；</p><p>在数据库中存储时间戳时，尽量使用<code>long</code>型时间戳，它具有省空间，效率高，不依赖数据库的优点。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-IO</title>
      <link href="/2025/05/24/JAVA-IO/"/>
      <url>/2025/05/24/JAVA-IO/</url>
      
        <content type="html"><![CDATA[<p>IO是指Input/Output，即输入和输出。以内存为中心：</p><ul><li>Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。</li><li>Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。</li></ul><p>为什么要把数据读到内存才能处理这些数据？因为代码是在内存中运行的，数据也必须读到内存，最终的表示方式无非是byte数组，字符串等，都必须存放在内存里。</p><p>从Java代码来看，输入实际上就是从外部，例如，硬盘上的某个文件，把内容读到内存，并且以Java提供的某种数据类型表示，例如，<code>byte[]</code>，<code>String</code>，这样，后续代码才能处理这些数据。</p><p>因为内存有“易失性”的特点，所以必须把处理后的数据以某种方式输出，例如，写入到文件。Output实际上就是把Java表示的数据格式，例如，<code>byte[]</code>，<code>String</code>等输出到某个地方。</p><p>IO流是一种顺序读写数据的模式，它的特点是单向流动。数据类似自来水一样在水管中流动，所以我们把它称为IO流。</p><p><img src="https://liaoxuefeng.com/books/java/io/io.jpg" alt="java-io"></p><h3 id="InputStream-OutputStream">InputStream / OutputStream</h3><p>IO流以<code>byte</code>（字节）为最小单位，因此也称为<em>字节流</em>。例如，我们要从磁盘读入一个文件，包含6个字节，就相当于读入了6个字节的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">╔═══════════╗</span><br><span class="line">║  Memory   ║</span><br><span class="line">╚═══════════╝</span><br><span class="line">      ▲</span><br><span class="line">      │0x48</span><br><span class="line">      │0x65</span><br><span class="line">      │0x6c</span><br><span class="line">      │0x6c</span><br><span class="line">      │0x6f</span><br><span class="line">      │0x21</span><br><span class="line">╔═══════════╗</span><br><span class="line">║ Hard Disk ║</span><br><span class="line">╚═══════════╝</span><br></pre></td></tr></table></figure><p>这6个字节是按顺序读入的，所以是输入字节流。</p><p>反过来，我们把6个字节从内存写入磁盘文件，就是输出字节流：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">╔═══════════╗</span><br><span class="line">║  Memory   ║</span><br><span class="line">╚═══════════╝</span><br><span class="line">      │0x21</span><br><span class="line">      │0x6f</span><br><span class="line">      │0x6c</span><br><span class="line">      │0x6c</span><br><span class="line">      │0x65</span><br><span class="line">      │0x48</span><br><span class="line">      ▼</span><br><span class="line">╔═══════════╗</span><br><span class="line">║ Hard Disk ║</span><br><span class="line">╚═══════════╝</span><br></pre></td></tr></table></figure><p>在Java中，<code>InputStream</code>代表输入字节流，<code>OuputStream</code>代表输出字节流，这是最基本的两种IO流。</p><h3 id="Reader-Writer">Reader / Writer</h3><p>如果我们需要读写的是字符，并且字符不全是单字节表示的ASCII字符，那么，按照<code>char</code>来读写显然更方便，这种流称为<em>字符流</em>。</p><p>Java提供了<code>Reader</code>和<code>Writer</code>表示字符流，字符流传输的最小数据单位是<code>char</code>。</p><p>例如，我们把<code>char[]</code>数组<code>Hi你好</code>这4个字符用<code>Writer</code>字符流写入文件，并且使用UTF-8编码，得到的最终文件内容是8个字节，英文字符<code>H</code>和<code>i</code>各占一个字节，中文字符<code>你好</code>各占3个字节：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x48</span><br><span class="line">0x69</span><br><span class="line">0xe4bda0</span><br><span class="line">0xe5a5bd</span><br></pre></td></tr></table></figure><p>反过来，我们用<code>Reader</code>读取以UTF-8编码的这8个字节，会从<code>Reader</code>中得到<code>Hi你好</code>这4个字符。</p><p>因此，<code>Reader</code>和<code>Writer</code>本质上是一个能自动编解码的<code>InputStream</code>和<code>OutputStream</code>。</p><p>使用<code>Reader</code>，数据源虽然是字节，但我们读入的数据都是<code>char</code>类型的字符，原因是<code>Reader</code>内部把读入的<code>byte</code>做了解码，转换成了<code>char</code>。使用<code>InputStream</code>，我们读入的数据和原始二进制数据一模一样，是<code>byte[]</code>数组，但是我们可以自己把二进制<code>byte[]</code>数组按照某种编码转换为字符串。究竟使用<code>Reader</code>还是<code>InputStream</code>，要取决于具体的使用场景。如果数据源不是文本，就只能使用<code>InputStream</code>，如果数据源是文本，使用Reader更方便一些。<code>Writer</code>和<code>OutputStream</code>是类似的。</p><h3 id="同步和异步">同步和异步</h3><p>同步IO是指，读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。</p><p>而异步IO是指，读写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。</p><p>Java标准库的包<code>java.io</code>提供了同步IO，而<code>java.nio</code>则是异步IO。上面我们讨论的<code>InputStream</code>、<code>OutputStream</code>、<code>Reader</code>和<code>Writer</code>都是同步IO的抽象类，对应的具体实现类，以文件为例，有<code>FileInputStream</code>、<code>FileOutputStream</code>、<code>FileReader</code>和<code>FileWriter</code>。</p><p>本节我们只讨论Java的同步IO，即输入/输出流的IO模型。</p><h3 id="小结">小结</h3><p>IO流是一种流式的数据输入/输出模型：</p><ul><li>二进制数据以<code>byte</code>为最小单位在<code>InputStream</code>/<code>OutputStream</code>中单向流动；</li><li>字符数据以<code>char</code>为最小单位在<code>Reader</code>/<code>Writer</code>中单向流动。</li></ul><p>Java标准库的<code>java.io</code>包提供了同步IO功能：</p><ul><li>字节流接口：<code>InputStream</code>/<code>OutputStream</code>；</li><li>字符流接口：<code>Reader</code>/<code>Writer</code>。</li></ul><p>在计算机系统中，文件是非常重要的存储方式。Java的标准库<code>java.io</code>提供了<code>File</code>对象来操作文件和目录。</p><p>要构造一个<code>File</code>对象，需要传入文件路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Windows\\notepad.exe&quot;</span>);</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造File对象时，既可以传入绝对路径，也可以传入相对路径。绝对路径是以根目录开头的完整路径，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Windows\\notepad.exe&quot;</span>);</span><br></pre></td></tr></table></figure><p>注意Windows平台使用<code>\</code>作为路径分隔符，在Java字符串中需要用<code>\\</code>表示一个<code>\</code>。Linux平台使用<code>/</code>作为路径分隔符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/usr/bin/javac&quot;</span>);</span><br></pre></td></tr></table></figure><p>传入相对路径时，相对路径前面加上当前目录就是绝对路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设当前目录是C:\Docs</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;sub\\javac&quot;</span>); <span class="comment">// 绝对路径是C:\Docs\sub\javac</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.\\sub\\javac&quot;</span>); <span class="comment">// 绝对路径是C:\Docs\sub\javac</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;..\\sub\\javac&quot;</span>); <span class="comment">// 绝对路径是C:\sub\javac</span></span><br></pre></td></tr></table></figure><p>可以用<code>.</code>表示当前目录，<code>..</code>表示上级目录。</p><p>File对象有3种形式表示的路径，一种是<code>getPath()</code>，返回构造方法传入的路径，一种是<code>getAbsolutePath()</code>，返回绝对路径，一种是<code>getCanonicalPath</code>，它和绝对路径类似，但是返回的是规范路径。</p><p>什么是规范路径？我们看以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">        System.out.println(f.getPath());</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">        System.out.println(f.getCanonicalPath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绝对路径可以表示成<code>C:\Windows\System32\..\notepad.exe</code>，而规范路径就是把<code>.</code>和<code>..</code>转换成标准的绝对路径后的路径：<code>C:\Windows\notepad.exe</code>。</p><p>因为Windows和Linux的路径分隔符不同，File对象有一个静态变量用于表示当前平台的系统分隔符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(File.separator); <span class="comment">// 根据当前平台打印&quot;\&quot;或&quot;/&quot;</span></span><br></pre></td></tr></table></figure><h3 id="文件和目录">文件和目录</h3><p><code>File</code>对象既可以表示文件，也可以表示目录。特别要注意的是，构造一个<code>File</code>对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个<code>File</code>对象，并不会导致任何磁盘操作。只有当我们调用<code>File</code>对象的某些方法的时候，才真正进行磁盘操作。</p><p>例如，调用<code>isFile()</code>，判断该<code>File</code>对象是否是一个已存在的文件，调用<code>isDirectory()</code>，判断该<code>File</code>对象是否是一个已存在的目录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Windows&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Windows\\notepad.exe&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Windows\\nothing&quot;</span>);</span><br><span class="line">        System.out.println(f1.isFile());</span><br><span class="line">        System.out.println(f1.isDirectory());</span><br><span class="line">        System.out.println(f2.isFile());</span><br><span class="line">        System.out.println(f2.isDirectory());</span><br><span class="line">        System.out.println(f3.isFile());</span><br><span class="line">        System.out.println(f3.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>File</code>对象获取到一个文件时，还可以进一步判断文件的权限和大小：</p><ul><li><code>boolean canRead()</code>：是否可读；</li><li><code>boolean canWrite()</code>：是否可写；</li><li><code>boolean canExecute()</code>：是否可执行；</li><li><code>long length()</code>：文件字节大小。</li></ul><p>对目录而言，是否可执行表示能否列出它包含的文件和子目录。</p><h3 id="创建和删除文件">创建和删除文件</h3><p>当File对象表示一个文件时，可以通过<code>createNewFile()</code>创建一个新文件，用<code>delete()</code>删除该文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/path/to/file&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (file.createNewFile()) &#123;</span><br><span class="line">    <span class="comment">// 文件创建成功:</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="keyword">if</span> (file.delete()) &#123;</span><br><span class="line">        <span class="comment">// 删除文件成功:</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些时候，程序需要读写一些临时文件，File对象提供了<code>createTempFile()</code>来创建一个临时文件，以及<code>deleteOnExit()</code>在JVM退出时自动删除该文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> File.createTempFile(<span class="string">&quot;tmp-&quot;</span>, <span class="string">&quot;.txt&quot;</span>); <span class="comment">// 提供临时文件的前缀和后缀</span></span><br><span class="line">        f.deleteOnExit(); <span class="comment">// JVM退出时自动删除</span></span><br><span class="line">        System.out.println(f.isFile());</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历文件和目录">遍历文件和目录</h3><p>当File对象表示一个目录时，可以使用<code>list()</code>和<code>listFiles()</code>列出目录下的文件和子目录名。<code>listFiles()</code>提供了一系列重载方法，可以过滤不想要的文件和目录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Windows&quot;</span>);</span><br><span class="line">        File[] fs1 = f.listFiles(); <span class="comment">// 列出所有文件和子目录</span></span><br><span class="line">        printFiles(fs1);</span><br><span class="line">        File[] fs2 = f.listFiles(<span class="keyword">new</span> <span class="title class_">FilenameFilter</span>() &#123; <span class="comment">// 仅列出.exe文件</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> name.endsWith(<span class="string">&quot;.exe&quot;</span>); <span class="comment">// 返回true表示接受该文件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        printFiles(fs2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printFiles</span><span class="params">(File[] files)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和文件操作类似，File对象如果表示一个目录，可以通过以下方法创建和删除目录：</p><ul><li><code>boolean mkdir()</code>：创建当前File对象表示的目录；</li><li><code>boolean mkdirs()</code>：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；</li><li><code>boolean delete()</code>：删除当前File对象表示的目录，当前目录必须为空才能删除成功。</li></ul><h3 id="Path">Path</h3><p>Java标准库还提供了一个<code>Path</code>对象，它位于<code>java.nio.file</code>包。<code>Path</code>对象和<code>File</code>对象类似，但操作更加简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">p1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;project&quot;</span>, <span class="string">&quot;study&quot;</span>); <span class="comment">// 构造一个Path对象</span></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        <span class="type">Path</span> <span class="variable">p2</span> <span class="operator">=</span> p1.toAbsolutePath(); <span class="comment">// 转换为绝对路径</span></span><br><span class="line">        System.out.println(p2);</span><br><span class="line">        <span class="type">Path</span> <span class="variable">p3</span> <span class="operator">=</span> p2.normalize(); <span class="comment">// 转换为规范路径</span></span><br><span class="line">        System.out.println(p3);</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> p3.toFile(); <span class="comment">// 转换为File对象</span></span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="keyword">for</span> (Path p : Paths.get(<span class="string">&quot;..&quot;</span>).toAbsolutePath()) &#123; <span class="comment">// 可以直接遍历Path</span></span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要对目录进行复杂的拼接、遍历等操作，使用<code>Path</code>对象更方便。</p><h3 id="练习">练习</h3><p>请利用<code>File</code>对象列出指定目录下的所有子目录和文件，并按层次打印。</p><p>例如，输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Documents/</span><br><span class="line">  word/</span><br><span class="line">    1.docx</span><br><span class="line">    2.docx</span><br><span class="line">    work/</span><br><span class="line">      abc.doc</span><br><span class="line">  ppt/</span><br><span class="line">  other/</span><br></pre></td></tr></table></figure><p>如果不指定参数，则使用当前目录，如果指定参数，则使用指定目录。</p><p><a href="https://liaoxuefeng.com/books/java/io/file/io-file.zip">下载练习</a></p><h3 id="小结-2">小结</h3><p>Java标准库的<code>java.io.File</code>对象表示一个文件或者目录：</p><ul><li>创建<code>File</code>对象本身不涉及IO操作；</li><li>可以获取路径／绝对路径／规范路径：<code>getPath()</code>/<code>getAbsolutePath()</code>/<code>getCanonicalPath()</code>；</li><li>可以获取目录的文件和子目录：<code>list()</code>/<code>listFiles()</code>；</li><li>可以创建或删除文件和目录。</li></ul><p><code>InputStream</code>就是Java标准库提供的最基本的输入流。它位于<code>java.io</code>这个包里。<code>java.io</code>包提供了所有同步IO的功能。</p><p>要特别注意的一点是，<code>InputStream</code>并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是<code>int read()</code>，签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><p>这个方法会读取输入流的下一个字节，并返回字节表示的<code>int</code>值（0~255）。如果已读到末尾，返回<code>-1</code>表示不能继续读取了。</p><p><code>FileInputStream</code>是<code>InputStream</code>的一个子类。顾名思义，<code>FileInputStream</code>就是从文件流中读取数据。下面的代码演示了如何完整地读取一个<code>FileInputStream</code>的所有字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 创建一个FileInputStream对象:</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> input.read(); <span class="comment">// 反复调用read()方法，直到返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(n); <span class="comment">// 打印byte的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    input.close(); <span class="comment">// 关闭流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在计算机中，类似文件、网络端口这些资源，都是由操作系统统一管理的。应用程序在运行的过程中，如果打开了一个文件进行读写，完成后要及时地关闭，以便让操作系统把资源释放掉，否则，应用程序占用的资源会越来越多，不但白白占用内存，还会影响其他应用程序的运行。</p><p><code>InputStream</code>和<code>OutputStream</code>都是通过<code>close()</code>方法来关闭流。关闭流就会释放对应的底层资源。</p><p>我们还要注意到在读取或写入IO流的过程中，可能会发生错误，例如，文件不存在导致无法读取，没有写权限导致写入失败，等等，这些底层错误由Java虚拟机自动封装成<code>IOException</code>异常并抛出。因此，所有与IO操作相关的代码都必须正确处理<code>IOException</code>。</p><p>仔细观察上面的代码，会发现一个潜在的问题：如果读取过程中发生了IO错误，<code>InputStream</code>就没法正确地关闭，资源也就没法及时释放。</p><p>因此，我们需要用<code>try ... finally</code>来保证<code>InputStream</code>在无论是否发生IO错误的时候都能够正确地关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        input = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123; <span class="comment">// 利用while同时读取并判断</span></span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input != <span class="literal">null</span>) &#123; input.close(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>try ... finally</code>来编写上述代码会感觉比较复杂，更好的写法是利用Java 7引入的新的<code>try(resource)</code>的语法，只需要编写<code>try</code>语句，让编译器自动为我们关闭资源。推荐的写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，编译器并不会特别地为<code>InputStream</code>加上自动关闭。编译器只看<code>try(resource = ...)</code>中的对象是否实现了<code>java.lang.AutoCloseable</code>接口，如果实现了，就自动加上<code>finally</code>语句并调用<code>close()</code>方法。<code>InputStream</code>和<code>OutputStream</code>都实现了这个接口，因此，都可以用在<code>try(resource)</code>中。</p><h3 id="缓冲">缓冲</h3><p>在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。<code>InputStream</code>提供了两个重载方法来支持读取多个字节：</p><ul><li><code>int read(byte[] b)</code>：读取若干字节并填充到<code>byte[]</code>数组，返回读取的字节数</li><li><code>int read(byte[] b, int off, int len)</code>：指定<code>byte[]</code>数组的偏移量和最大填充数</li></ul><p>利用上述方法一次读取多个字节时，需要先定义一个<code>byte[]</code>数组作为缓冲区，<code>read()</code>方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。<code>read()</code>方法的返回值不再是字节的<code>int</code>值，而是返回实际读取了多少个字节。如果返回<code>-1</code>，表示没有更多的数据了。</p><p>利用缓冲区一次读取多个字节的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 定义1000个字节大小的缓冲区:</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read(buffer)) != -<span class="number">1</span>) &#123; <span class="comment">// 读取到缓冲区</span></span><br><span class="line">            System.out.println(<span class="string">&quot;read &quot;</span> + n + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞">阻塞</h3><p>在调用<code>InputStream</code>的<code>read()</code>方法读取数据时，我们说<code>read()</code>方法是阻塞（Blocking）的。它的意思是，对于下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">n = input.read(); <span class="comment">// 必须等待read()方法返回才能执行下一行代码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> n;</span><br></pre></td></tr></table></figure><p>执行到第二行代码时，必须等<code>read()</code>方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定<code>read()</code>方法调用到底要花费多长时间。</p><h3 id="InputStream实现类">InputStream实现类</h3><p>用<code>FileInputStream</code>可以从文件获取输入流，这是<code>InputStream</code>常用的一个实现类。此外，<code>ByteArrayInputStream</code>可以在内存中模拟一个<code>InputStream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = &#123; <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">33</span> &#125;;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(data)) &#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="type">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ByteArrayInputStream</code>实际上是把一个<code>byte[]</code>数组在内存中变成一个<code>InputStream</code>，虽然实际应用不多，但测试的时候，可以用它来构造一个<code>InputStream</code>。</p><p>举个例子：我们想从文件中读取所有字节，并转换成<code>char</code>然后拼成一个字符串，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\test\\README.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                sb.append((<span class="type">char</span>) n);</span><br><span class="line">            &#125;</span><br><span class="line">            s = sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要测试上面的程序，就真的需要在本地硬盘上放一个真实的文本文件。如果我们把代码稍微改造一下，提取一个<code>readAsString()</code>的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\test\\README.txt&quot;</span>)) &#123;</span><br><span class="line">            s = readAsString(input);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readAsString</span><span class="params">(InputStream input)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            sb.append((<span class="type">char</span>) n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个<code>String readAsString(InputStream input)</code>方法进行测试就相当简单，因为不一定要传入一个真的<code>FileInputStream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = &#123; <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">33</span> &#125;;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(data)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> readAsString(input);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readAsString</span><span class="params">(InputStream input)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            sb.append((<span class="type">char</span>) n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是面向抽象编程原则的应用：接受<code>InputStream</code>抽象类型，而不是具体的<code>FileInputStream</code>类型，从而使得代码可以处理<code>InputStream</code>的任意实现类。</p><h3 id="小结-3">小结</h3><p>Java标准库的<code>java.io.InputStream</code>定义了所有输入流的超类：</p><ul><li><code>FileInputStream</code>实现了文件流输入；</li><li><code>ByteArrayInputStream</code>在内存中模拟一个字节流输入。</li></ul><p>总是使用<code>try(resource)</code>来保证<code>InputStream</code>正确关闭。</p><p>和<code>InputStream</code>相反，<code>OutputStream</code>是Java标准库提供的最基本的输出流。</p><p>和<code>InputStream</code>类似，<code>OutputStream</code>也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是<code>void write(int b)</code>，签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><p>这个方法会写入一个字节到输出流。要注意的是，虽然传入的是<code>int</code>参数，但只会写入一个字节，即只写入<code>int</code>最低8位表示字节的部分（相当于<code>b &amp; 0xff</code>）。</p><p>和<code>InputStream</code>类似，<code>OutputStream</code>也提供了<code>close()</code>方法关闭输出流，以便释放系统资源。要特别注意：<code>OutputStream</code>还提供了一个<code>flush()</code>方法，它的目的是将缓冲区的内容真正输出到目的地。</p><p>为什么要有<code>flush()</code>？因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个<code>byte[]</code>数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以<code>OutputStream</code>有个<code>flush()</code>方法，能强制把缓冲区内容输出。</p><p>通常情况下，我们不需要调用这个<code>flush()</code>方法，因为缓冲区写满了<code>OutputStream</code>会自动调用它，并且，在调用<code>close()</code>方法关闭<code>OutputStream</code>之前，也会自动调用<code>flush()</code>方法。</p><p>但是，在某些情况下，我们必须手动调用<code>flush()</code>方法。举个栗子：</p><p>小明正在开发一款在线聊天软件，当用户输入一句话后，就通过<code>OutputStream</code>的<code>write()</code>方法写入网络流。小明测试的时候发现，发送方输入后，接收方根本收不到任何信息，怎么回事？</p><p>原因就在于写入网络流是先写入内存缓冲区，等缓冲区满了才会一次性发送到网络。如果缓冲区大小是4K，则发送方要敲几千个字符后，操作系统才会把缓冲区的内容发送出去，这个时候，接收方会一次性收到大量消息。</p><p>解决办法就是每输入一句话后，立刻调用<code>flush()</code>，不管当前缓冲区是否已满，强迫操作系统把缓冲区的内容立刻发送出去。</p><p>实际上，<code>InputStream</code>也有缓冲区。例如，从<code>FileInputStream</code>读取一个字节时，操作系统往往会一次性读取若干字节到缓冲区，并维护一个指针指向未读的缓冲区。然后，每次我们调用<code>int read()</code>读取下一个字节时，可以直接返回缓冲区的下一个字节，避免每次读一个字节都导致IO操作。当缓冲区全部读完后继续调用<code>read()</code>，则会触发操作系统的下一次读取并再次填满缓冲区。</p><h3 id="FileOutputStream">FileOutputStream</h3><p>我们以<code>FileOutputStream</code>为例，演示如何将若干个字节写入文件流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out/readme.txt&quot;</span>);</span><br><span class="line">    output.write(<span class="number">72</span>); <span class="comment">// H</span></span><br><span class="line">    output.write(<span class="number">101</span>); <span class="comment">// e</span></span><br><span class="line">    output.write(<span class="number">108</span>); <span class="comment">// l</span></span><br><span class="line">    output.write(<span class="number">108</span>); <span class="comment">// l</span></span><br><span class="line">    output.write(<span class="number">111</span>); <span class="comment">// o</span></span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次写入一个字节非常麻烦，更常见的方法是一次性写入若干字节。这时，可以用<code>OutputStream</code>提供的重载方法<code>void write(byte[])</code>来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out/readme.txt&quot;</span>);</span><br><span class="line">    output.write(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)); <span class="comment">// Hello</span></span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和<code>InputStream</code>一样，上述代码没有考虑到在发生异常的情况下如何正确地关闭资源。写入过程也会经常发生IO错误，例如，磁盘已满，无权限写入等等。我们需要用<code>try(resource)</code>来保证<code>OutputStream</code>在无论是否发生IO错误的时候都能够正确地关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out/readme.txt&quot;</span>)) &#123;</span><br><span class="line">        output.write(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)); <span class="comment">// Hello</span></span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞-2">阻塞</h3><p>和<code>InputStream</code>一样，<code>OutputStream</code>的<code>write()</code>方法也是阻塞的。</p><h3 id="OutputStream实现类">OutputStream实现类</h3><p>用<code>FileOutputStream</code>可以从文件获取输出流，这是<code>OutputStream</code>常用的一个实现类。此外，<code>ByteArrayOutputStream</code>可以在内存中模拟一个<code>OutputStream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] data;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>()) &#123;</span><br><span class="line">            output.write(<span class="string">&quot;Hello &quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            output.write(<span class="string">&quot;world!&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            data = output.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ByteArrayOutputStream</code>实际上是把一个<code>byte[]</code>数组在内存中变成一个<code>OutputStream</code>，虽然实际应用不多，但测试的时候，可以用它来构造一个<code>OutputStream</code>。</p><p>同时操作多个<code>AutoCloseable</code>资源时，在<code>try(resource) &#123; ... &#125;</code>语句中可以同时写出多个资源，用<code>;</code>隔开。例如，同时读写两个文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取input.txt，写入output.txt:</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line">     <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    input.transferTo(output); <span class="comment">// transferTo的作用是?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习-2">练习</h3><p>请利用<code>InputStream</code>和<code>OutputStream</code>，编写一个复制文件的程序，它可以带参数运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java CopyFile.java source.txt copy.txt</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/io/output-stream/io-copy.zip">下载练习</a></p><h3 id="小结-4">小结</h3><p>Java标准库的<code>java.io.OutputStream</code>定义了所有输出流的超类：</p><ul><li><code>FileOutputStream</code>实现了文件流输出；</li><li><code>ByteArrayOutputStream</code>在内存中模拟一个字节流输出。</li></ul><p>某些情况下需要手动调用<code>OutputStream</code>的<code>flush()</code>方法来强制输出缓冲区；</p><p>总是使用<code>try(resource)</code>来保证<code>OutputStream</code>正确关闭。</p><p>Java的IO标准库提供的<code>InputStream</code>根据来源可以包括：</p><ul><li><code>FileInputStream</code>：从文件读取数据，是最终数据源；</li><li><code>ServletInputStream</code>：从HTTP请求读取数据，是最终数据源；</li><li><code>Socket.getInputStream()</code>：从TCP连接读取数据，是最终数据源；</li><li>…</li></ul><p>如果我们要给<code>FileInputStream</code>添加缓冲功能，则可以从<code>FileInputStream</code>派生一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedFileInputStream <span class="keyword">extends</span> <span class="title class_">FileInputStream</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果要给<code>FileInputStream</code>添加计算签名的功能，类似的，也可以从<code>FileInputStream</code>派生一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DigestFileInputStream <span class="keyword">extends</span> <span class="title class_">FileInputStream</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果要给<code>FileInputStream</code>添加加密/解密功能，还是可以从<code>FileInputStream</code>派生一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CipherFileInputStream <span class="keyword">extends</span> <span class="title class_">FileInputStream</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果要给<code>FileInputStream</code>添加缓冲和签名的功能，那么我们还需要派生<code>BufferedDigestFileInputStream</code>。如果要给<code>FileInputStream</code>添加缓冲和加解密的功能，则需要派生<code>BufferedCipherFileInputStream</code>。</p><p>我们发现，给<code>FileInputStream</code>添加3种功能，至少需要3个子类。这3种功能的组合，又需要更多的子类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                          ┌─────────────────┐</span><br><span class="line">                          │ FileInputStream │</span><br><span class="line">                          └─────────────────┘</span><br><span class="line">                                   ▲</span><br><span class="line">             ┌───────────┬─────────┼─────────┬───────────┐</span><br><span class="line">             │           │         │         │           │</span><br><span class="line">┌───────────────────────┐│┌─────────────────┐│┌─────────────────────┐</span><br><span class="line">│BufferedFileInputStream│││DigestInputStream│││CipherFileInputStream│</span><br><span class="line">└───────────────────────┘│└─────────────────┘│└─────────────────────┘</span><br><span class="line">                         │                   │</span><br><span class="line">    ┌─────────────────────────────┐ ┌─────────────────────────────┐</span><br><span class="line">    │BufferedDigestFileInputStream│ │BufferedCipherFileInputStream│</span><br><span class="line">    └─────────────────────────────┘ └─────────────────────────────┘</span><br></pre></td></tr></table></figure><p>这还只是针对<code>FileInputStream</code>设计，如果针对另一种<code>InputStream</code>设计，很快会出现子类爆炸的情况。</p><p>因此，直接使用继承，为各种<code>InputStream</code>附加更多的功能，根本无法控制代码的复杂度，很快就会失控。</p><p>为了解决依赖继承会导致子类数量失控的问题，JDK首先将<code>InputStream</code>分为两大类：</p><p>一类是直接提供数据的基础<code>InputStream</code>，例如：</p><ul><li>FileInputStream</li><li>ByteArrayInputStream</li><li>ServletInputStream</li><li>…</li></ul><p>一类是提供额外附加功能的<code>InputStream</code>，例如：</p><ul><li>BufferedInputStream</li><li>DigestInputStream</li><li>CipherInputStream</li><li>…</li></ul><p>当我们需要给一个“基础”<code>InputStream</code>附加各种功能时，我们先确定这个能提供数据源的<code>InputStream</code>，因为我们需要的数据总得来自某个地方，例如，<code>FileInputStream</code>，数据来源自文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.gz&quot;</span>);</span><br></pre></td></tr></table></figure><p>紧接着，我们希望<code>FileInputStream</code>能提供缓冲的功能来提高读取的效率，因此我们用<code>BufferedInputStream</code>包装这个<code>InputStream</code>，得到的包装类型是<code>BufferedInputStream</code>，但它仍然被视为一个<code>InputStream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">buffered</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(file);</span><br></pre></td></tr></table></figure><p>最后，假设该文件已经用gzip压缩了，我们希望直接读取解压缩的内容，就可以再包装一个<code>GZIPInputStream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">gzip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GZIPInputStream</span>(buffered);</span><br></pre></td></tr></table></figure><p>无论我们包装多少次，得到的对象始终是<code>InputStream</code>，我们直接用<code>InputStream</code>来引用它，就可以正常读取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────┐</span><br><span class="line">│GZIPInputStream          │</span><br><span class="line">│┌───────────────────────┐│</span><br><span class="line">││BufferedFileInputStream││</span><br><span class="line">││┌─────────────────────┐││</span><br><span class="line">│││   FileInputStream   │││</span><br><span class="line">││└─────────────────────┘││</span><br><span class="line">│└───────────────────────┘│</span><br><span class="line">└─────────────────────────┘</span><br></pre></td></tr></table></figure><p>上述这种通过一个“基础”组件再叠加各种“附加”功能组件的模式，称之为Filter模式（或者装饰器模式：Decorator）。它可以让我们通过少量的类来实现各种功能的组合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">                 ┌─────────────┐</span><br><span class="line">                 │ InputStream │</span><br><span class="line">                 └─────────────┘</span><br><span class="line">                       ▲ ▲</span><br><span class="line">┌────────────────────┐ │ │ ┌─────────────────┐</span><br><span class="line">│  FileInputStream   │─┤ └─│FilterInputStream│</span><br><span class="line">└────────────────────┘ │   └─────────────────┘</span><br><span class="line">┌────────────────────┐ │     ▲ ┌───────────────────┐</span><br><span class="line">│ByteArrayInputStream│─┤     ├─│BufferedInputStream│</span><br><span class="line">└────────────────────┘ │     │ └───────────────────┘</span><br><span class="line">┌────────────────────┐ │     │ ┌───────────────────┐</span><br><span class="line">│ ServletInputStream │─┘     ├─│  DataInputStream  │</span><br><span class="line">└────────────────────┘       │ └───────────────────┘</span><br><span class="line">                             │ ┌───────────────────┐</span><br><span class="line">                             └─│CheckedInputStream │</span><br><span class="line">                               └───────────────────┘</span><br></pre></td></tr></table></figure><p>类似的，<code>OutputStream</code>也是以这种模式来提供各种功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">                  ┌─────────────┐</span><br><span class="line">                  │OutputStream │</span><br><span class="line">                  └─────────────┘</span><br><span class="line">                        ▲ ▲</span><br><span class="line">┌─────────────────────┐ │ │ ┌──────────────────┐</span><br><span class="line">│  FileOutputStream   │─┤ └─│FilterOutputStream│</span><br><span class="line">└─────────────────────┘ │   └──────────────────┘</span><br><span class="line">┌─────────────────────┐ │     ▲ ┌────────────────────┐</span><br><span class="line">│ByteArrayOutputStream│─┤     ├─│BufferedOutputStream│</span><br><span class="line">└─────────────────────┘ │     │ └────────────────────┘</span><br><span class="line">┌─────────────────────┐ │     │ ┌────────────────────┐</span><br><span class="line">│ ServletOutputStream │─┘     ├─│  DataOutputStream  │</span><br><span class="line">└─────────────────────┘       │ └────────────────────┘</span><br><span class="line">                              │ ┌────────────────────┐</span><br><span class="line">                              └─│CheckedOutputStream │</span><br><span class="line">                                └────────────────────┘</span><br></pre></td></tr></table></figure><h3 id="编写FilterInputStream">编写FilterInputStream</h3><p>我们也可以自己编写<code>FilterInputStream</code>，以便可以把自己的<code>FilterInputStream</code>“叠加”到任何一个<code>InputStream</code>中。</p><p>下面的例子演示了如何编写一个<code>CountInputStream</code>，它的作用是对输入的字节进行计数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="string">&quot;hello, world!&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">CountInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(data))) &#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="type">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Total read &quot;</span> + input.getBytesRead() + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountInputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterInputStream</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    CountInputStream(InputStream in) &#123;</span><br><span class="line">        <span class="built_in">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBytesRead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.read();</span><br><span class="line">        <span class="keyword">if</span> (n != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.read(b, off, len);</span><br><span class="line">        <span class="keyword">if</span> (n != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.count += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到在叠加多个<code>FilterInputStream</code>，我们只需要持有最外层的<code>InputStream</code>，并且，当最外层的<code>InputStream</code>关闭时（在<code>try(resource)</code>块的结束处自动关闭），内层的<code>InputStream</code>的<code>close()</code>方法也会被自动调用，并最终调用到最核心的“基础”<code>InputStream</code>，因此不存在资源泄露。</p><h3 id="小结-5">小结</h3><p>Java的IO标准库使用Filter模式为<code>InputStream</code>和<code>OutputStream</code>增加功能：</p><ul><li>可以把一个<code>InputStream</code>和任意个<code>FilterInputStream</code>组合；</li><li>可以把一个<code>OutputStream</code>和任意个<code>FilterOutputStream</code>组合。</li></ul><p>Filter模式可以在运行期动态增加功能（又称Decorator模式）。</p><h2 id="操作Zip">操作Zip</h2><p><code>ZipInputStream</code>是一种<code>FilterInputStream</code>，它可以直接读取zip包的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────┐</span><br><span class="line">│    InputStream    │</span><br><span class="line">└───────────────────┘</span><br><span class="line">          ▲</span><br><span class="line">          │</span><br><span class="line">┌───────────────────┐</span><br><span class="line">│ FilterInputStream │</span><br><span class="line">└───────────────────┘</span><br><span class="line">          ▲</span><br><span class="line">          │</span><br><span class="line">┌───────────────────┐</span><br><span class="line">│InflaterInputStream│</span><br><span class="line">└───────────────────┘</span><br><span class="line">          ▲</span><br><span class="line">          │</span><br><span class="line">┌───────────────────┐</span><br><span class="line">│  ZipInputStream   │</span><br><span class="line">└───────────────────┘</span><br><span class="line">          ▲</span><br><span class="line">          │</span><br><span class="line">┌───────────────────┐</span><br><span class="line">│  JarInputStream   │</span><br><span class="line">└───────────────────┘</span><br></pre></td></tr></table></figure><p>另一个<code>JarInputStream</code>是从<code>ZipInputStream</code>派生，它增加的主要功能是直接读取jar文件里面的<code>MANIFEST.MF</code>文件。因为本质上jar包就是zip包，只是额外附加了一些固定的描述文件。</p><h3 id="读取zip包">读取zip包</h3><p>我们来看看<code>ZipInputStream</code>的基本用法。</p><p>我们要创建一个<code>ZipInputStream</code>，通常是传入一个<code>FileInputStream</code>作为数据源，然后，循环调用<code>getNextEntry()</code>，直到返回<code>null</code>，表示zip流结束。</p><p>一个<code>ZipEntry</code>表示一个压缩文件或目录，如果是压缩文件，我们就用<code>read()</code>方法不断读取，直到返回<code>-1</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">ZipInputStream</span> <span class="variable">zip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(...))) &#123;</span><br><span class="line">    <span class="type">ZipEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((entry = zip.getNextEntry()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> entry.getName();</span><br><span class="line">        <span class="keyword">if</span> (!entry.isDirectory()) &#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = zip.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写入zip包">写入zip包</h3><p><code>ZipOutputStream</code>是一种<code>FilterOutputStream</code>，它可以直接写入内容到zip包。我们要先创建一个<code>ZipOutputStream</code>，通常是包装一个<code>FileOutputStream</code>，然后，每写入一个文件前，先调用<code>putNextEntry()</code>，然后用<code>write()</code>写入<code>byte[]</code>数据，写入完毕后调用<code>closeEntry()</code>结束这个文件的打包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">ZipOutputStream</span> <span class="variable">zip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(...))) &#123;</span><br><span class="line">    File[] files = ...</span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        zip.putNextEntry(<span class="keyword">new</span> <span class="title class_">ZipEntry</span>(file.getName()));</span><br><span class="line">        zip.write(Files.readAllBytes(file.toPath()));</span><br><span class="line">        zip.closeEntry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码没有考虑文件的目录结构。如果要实现目录层次结构，<code>new ZipEntry(name)</code>传入的<code>name</code>要用相对路径。</p><h3 id="小结-6">小结</h3><p><code>ZipInputStream</code>可以读取zip格式的流，<code>ZipOutputStream</code>可以把多份数据写入zip包；</p><p>配合<code>FileInputStream</code>和<code>FileOutputStream</code>就可以读写zip文件。</p><hr><hr><h2 id="读取classpath资源">读取classpath资源</h2><p>很多Java程序启动的时候，都需要读取配置文件。例如，从一个<code>.properties</code>文件中读取配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">conf</span> <span class="operator">=</span> <span class="string">&quot;C:\\conf\\default.properties&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(conf)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码要正常执行，必须在C盘创建<code>conf</code>目录，然后在目录里创建<code>default.properties</code>文件。但是，在Linux系统上，路径和Windows的又不一样。</p><p>因此，从磁盘的固定目录读取配置文件，不是一个好的办法。</p><p>有没有路径无关的读取文件的方式呢？</p><p>我们知道，Java存放<code>.class</code>的目录或jar包也可以包含任意其他类型的文件，例如：</p><ul><li>配置文件，例如<code>.properties</code>；</li><li>图片文件，例如<code>.jpg</code>；</li><li>文本文件，例如<code>.txt</code>，<code>.csv</code>；</li><li>……</li></ul><p>从classpath读取文件就可以避免不同环境下文件路径不一致的问题：如果我们把<code>default.properties</code>文件放到classpath中，就不用关心它的实际存放路径。</p><p>在classpath中的资源文件，路径总是以<code>／</code>开头，我们先获取当前的<code>Class</code>对象，然后调用<code>getResourceAsStream()</code>就可以直接从classpath读取任意的资源文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> getClass().getResourceAsStream(<span class="string">&quot;/default.properties&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>getResourceAsStream()</code>需要特别注意的一点是，如果资源文件不存在，它将返回<code>null</code>。因此，我们需要检查返回的<code>InputStream</code>是否为<code>null</code>，如果为<code>null</code>，表示资源文件在classpath中没有找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> getClass().getResourceAsStream(<span class="string">&quot;/default.properties&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (input != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(inputStreamFromClassPath(<span class="string">&quot;/default.properties&quot;</span>));</span><br><span class="line">props.load(inputStreamFromFile(<span class="string">&quot;./conf.properties&quot;</span>));</span><br></pre></td></tr></table></figure><p>这样读取配置文件，应用程序启动就更加灵活。</p><h3 id="小结-7">小结</h3><p>把资源存储在classpath中可以避免文件路径依赖；</p><p><code>Class</code>对象的<code>getResourceAsStream()</code>可以从classpath中读取指定资源；</p><p>根据classpath读取资源时，需要检查返回的<code>InputStream</code>是否为<code>null</code>。</p><hr><hr><p>序列化是指把一个Java对象变成二进制内容，本质上就是一个<code>byte[]</code>数组。</p><p>为什么要把Java对象序列化呢？因为序列化后可以把<code>byte[]</code>保存到文件中，或者把<code>byte[]</code>通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。</p><p>有序列化，就有反序列化，即把一个二进制内容（也就是<code>byte[]</code>数组）变回Java对象。有了反序列化，保存到文件中的<code>byte[]</code>数组又可以“变回”Java对象，或者从网络上读取<code>byte[]</code>并把它“变回”Java对象。</p><p>我们来看看如何把一个Java对象序列化。</p><p>一个Java对象要能序列化，必须实现一个特殊的<code>java.io.Serializable</code>接口，它的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Serializable</code>接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。</p><h3 id="序列化">序列化</h3><p>把一个Java对象变为<code>byte[]</code>数组，需要使用<code>ObjectOutputStream</code>。它负责把一个Java对象写入一个字节流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(buffer)) &#123;</span><br><span class="line">            <span class="comment">// 写入int:</span></span><br><span class="line">            output.writeInt(<span class="number">12345</span>);</span><br><span class="line">            <span class="comment">// 写入String:</span></span><br><span class="line">            output.writeUTF(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            <span class="comment">// 写入Object:</span></span><br><span class="line">            output.writeObject(Double.valueOf(<span class="number">123.456</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(buffer.toByteArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ObjectOutputStream</code>既可以写入基本类型，如<code>int</code>，<code>boolean</code>，也可以写入<code>String</code>（以UTF-8编码），还可以写入实现了<code>Serializable</code>接口的<code>Object</code>。</p><p>因为写入<code>Object</code>时需要大量的类型信息，所以写入的内容很大。</p><h3 id="反序列化">反序列化</h3><p>和<code>ObjectOutputStream</code>相反，<code>ObjectInputStream</code>负责从一个字节流读取Java对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(...)) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> input.readInt();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> input.readUTF();</span><br><span class="line">    <span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> (Double) input.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了能读取基本类型和<code>String</code>类型外，调用<code>readObject()</code>可以直接返回一个<code>Object</code>对象。要把它变成一个特定类型，必须强制转型。</p><p><code>readObject()</code>可能抛出的异常有：</p><ul><li><code>ClassNotFoundException</code>：没有找到对应的Class；</li><li><code>InvalidClassException</code>：Class不匹配。</li></ul><p>对于<code>ClassNotFoundException</code>，这种情况常见于一台电脑上的Java程序把一个Java对象，例如，<code>Person</code>对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序并没有定义<code>Person</code>类，所以无法反序列化。</p><p>对于<code>InvalidClassException</code>，这种情况常见于序列化的<code>Person</code>对象定义了一个<code>int</code>类型的<code>age</code>字段，但是反序列化时，<code>Person</code>类定义的<code>age</code>字段被改成了<code>long</code>类型，所以导致class不兼容。</p><p>为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的<code>serialVersionUID</code>静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变<code>serialVersionUID</code>的值，这样就能自动阻止不匹配的class版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">2709425275741743919L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要特别注意反序列化的几个重要特点：</p><p>反序列化时，由JVM直接构造出Java对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行。</p><h3 id="安全性">安全性</h3><p>因为Java的序列化机制可以导致一个实例能直接从<code>byte[]</code>数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的<code>byte[]</code>数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。</p><p>实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。</p><h3 id="小结-8">小结</h3><p>可序列化的Java对象必须实现<code>java.io.Serializable</code>接口，类似<code>Serializable</code>这样的空接口被称为“标记接口”（Marker Interface）；</p><p>反序列化时不调用构造方法，可设置<code>serialVersionUID</code>作为版本号（非必需）；</p><p>Java的序列化机制仅适用于Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON。</p><p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和<code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以<code>byte</code>为单位读取，而<code>Reader</code>是一个字符流，即以<code>char</code>为单位读取：</p><table><thead><tr><th>InputStream</th><th>Reader</th></tr></thead><tbody><tr><td>字节流，以<code>byte</code>为单位</td><td>字符流，以<code>char</code>为单位</td></tr><tr><td>读取字节（-1，0~255）：<code>int read()</code></td><td>读取字符（-1，0~65535）：<code>int read()</code></td></tr><tr><td>读到字节数组：<code>int read(byte[] b)</code></td><td>读到字符数组：<code>int read(char[] c)</code></td></tr></tbody></table><p><code>java.io.Reader</code>是所有字符输入流的超类，它最主要的方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><p>这个方法读取字符流的下一个字符，并返回字符表示的<code>int</code>，范围是<code>0</code>~<code>65535</code>。如果已读到末尾，返回<code>-1</code>。</p><h3 id="FileReader">FileReader</h3><p><code>FileReader</code>是<code>Reader</code>的一个子类，它可以打开文件并获取<code>Reader</code>。下面的代码演示了如何完整地读取一个<code>FileReader</code>的所有字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 创建一个FileReader对象:</span></span><br><span class="line">    <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/readme.txt&quot;</span>); <span class="comment">// 字符编码是???</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> reader.read(); <span class="comment">// 反复调用read()方法，直到返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((<span class="type">char</span>)n); <span class="comment">// 打印char</span></span><br><span class="line">    &#125;</span><br><span class="line">    reader.close(); <span class="comment">// 关闭流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们读取一个纯ASCII编码的文本文件，上述代码工作是没有问题的。但如果文件中包含中文，就会出现乱码，因为<code>FileReader</code>默认的编码与系统相关，例如，Windows系统的默认编码可能是<code>GBK</code>，打开一个<code>UTF-8</code>编码的文本文件就会出现乱码。</p><p>要避免乱码问题，我们需要在创建<code>FileReader</code>时指定编码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure><p>和<code>InputStream</code>类似，<code>Reader</code>也是一种资源，需要保证出错的时候也能正确关闭，所以我们需要用<code>try (resource)</code>来保证<code>Reader</code>在无论有没有IO错误的时候都能够正确地关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Reader</code>还提供了一次性读取若干字符并填充到<code>char[]</code>数组的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span>[] c)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure><p>它返回实际读入的字符个数，最大不超过<code>char[]</code>数组的长度。返回<code>-1</code>表示流结束。</p><p>利用这个方法，我们可以先设置一个缓冲区，然后，每次尽可能地填充缓冲区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">        <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = reader.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;read &quot;</span> + n + <span class="string">&quot; chars.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CharArrayReader">CharArrayReader</h3><p><code>CharArrayReader</code>可以在内存中模拟一个<code>Reader</code>，它的作用实际上是把一个<code>char[]</code>数组变成一个<code>Reader</code>，这和<code>ByteArrayInputStream</code>非常类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharArrayReader</span>(<span class="string">&quot;Hello&quot;</span>.toCharArray())) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringReader">StringReader</h3><p><code>StringReader</code>可以直接把<code>String</code>作为数据源，它和<code>CharArrayReader</code>几乎一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringReader</span>(<span class="string">&quot;Hello&quot;</span>)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InputStreamReader">InputStreamReader</h3><p><code>Reader</code>和<code>InputStream</code>有什么关系？</p><p>除了特殊的<code>CharArrayReader</code>和<code>StringReader</code>，普通的<code>Reader</code>实际上是基于<code>InputStream</code>构造的，因为<code>Reader</code>需要从<code>InputStream</code>中读入字节流（<code>byte</code>），然后，根据编码设置，再转换为<code>char</code>就可以实现字符流。如果我们查看<code>FileReader</code>的源码，它在内部实际上持有一个<code>FileInputStream</code>。</p><p>既然<code>Reader</code>本质上是一个基于<code>InputStream</code>的<code>byte</code>到<code>char</code>的转换器，那么，如果我们已经有一个<code>InputStream</code>，想把它转换为<code>Reader</code>，是完全可行的。<code>InputStreamReader</code>就是这样一个转换器，它可以把任何<code>InputStream</code>转换为<code>Reader</code>。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 持有InputStream:</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 变换为Reader:</span></span><br><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(input, <span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure><p>构造<code>InputStreamReader</code>时，我们需要传入<code>InputStream</code>，还需要指定编码，就可以得到一个<code>Reader</code>对象。上述代码可以通过<code>try (resource)</code>更简洁地改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码实际上就是<code>FileReader</code>的一种实现方式。</p><p>使用<code>try (resource)</code>结构时，当我们关闭<code>Reader</code>时，它会在内部自动调用<code>InputStream</code>的<code>close()</code>方法，所以，只需要关闭最外层的<code>Reader</code>对象即可。</p><p>提示</p><p>使用InputStreamReader，可以把一个InputStream转换成一个Reader。</p><h3 id="小结-9">小结</h3><p><code>Reader</code>定义了所有字符输入流的超类：</p><ul><li><code>FileReader</code>实现了文件字符流输入，使用时需要指定编码；</li><li><code>CharArrayReader</code>和<code>StringReader</code>可以在内存中模拟一个字符流输入。</li></ul><p><code>Reader</code>是基于<code>InputStream</code>构造的：可以通过<code>InputStreamReader</code>在指定编码的同时将任何<code>InputStream</code>转换为<code>Reader</code>；</p><p>总是使用<code>try (resource)</code>保证<code>Reader</code>正确关闭。</p><h2 id="Writer">Writer</h2><p><code>Reader</code>是带编码转换器的<code>InputStream</code>，它把<code>byte</code>转换为<code>char</code>，而<code>Writer</code>就是带编码转换器的<code>OutputStream</code>，它把<code>char</code>转换为<code>byte</code>并输出。</p><p><code>Writer</code>和<code>OutputStream</code>的区别如下：</p><table><thead><tr><th>OutputStream</th><th>Writer</th></tr></thead><tbody><tr><td>字节流，以<code>byte</code>为单位</td><td>字符流，以<code>char</code>为单位</td></tr><tr><td>写入字节（0~255）：<code>void write(int b)</code></td><td>写入字符（0~65535）：<code>void write(int c)</code></td></tr><tr><td>写入字节数组：<code>void write(byte[] b)</code></td><td>写入字符数组：<code>void write(char[] c)</code></td></tr><tr><td>无对应方法</td><td>写入String：<code>void write(String s)</code></td></tr></tbody></table><p><code>Writer</code>是所有字符输出流的超类，它提供的方法主要有：</p><ul><li>写入一个字符（0~65535）：<code>void write(int c)</code>；</li><li>写入字符数组的所有字符：<code>void write(char[] c)</code>；</li><li>写入String表示的所有字符：<code>void write(String s)</code>。</li></ul><h3 id="FileWriter">FileWriter</h3><p><code>FileWriter</code>就是向文件中写入字符流的<code>Writer</code>。它的使用方法和<code>FileReader</code>类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;readme.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    writer.write(<span class="string">&#x27;H&#x27;</span>); <span class="comment">// 写入单个字符</span></span><br><span class="line">    writer.write(<span class="string">&quot;Hello&quot;</span>.toCharArray()); <span class="comment">// 写入char[]</span></span><br><span class="line">    writer.write(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 写入String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CharArrayWriter">CharArrayWriter</h3><p><code>CharArrayWriter</code>可以在内存中创建一个<code>Writer</code>，它的作用实际上是构造一个缓冲区，可以写入<code>char</code>，最后得到写入的<code>char[]</code>数组，这和<code>ByteArrayOutputStream</code>非常类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">CharArrayWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharArrayWriter</span>()) &#123;</span><br><span class="line">    writer.write(<span class="number">65</span>);</span><br><span class="line">    writer.write(<span class="number">66</span>);</span><br><span class="line">    writer.write(<span class="number">67</span>);</span><br><span class="line">    <span class="type">char</span>[] data = writer.toCharArray(); <span class="comment">// &#123; &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27; &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringWriter">StringWriter</h3><p><code>StringWriter</code>也是一个基于内存的<code>Writer</code>，它和<code>CharArrayWriter</code>类似。实际上，<code>StringWriter</code>在内部维护了一个<code>StringBuffer</code>，并对外提供了<code>Writer</code>接口。</p><h3 id="OutputStreamWriter">OutputStreamWriter</h3><p>除了<code>CharArrayWriter</code>和<code>StringWriter</code>外，普通的Writer实际上是基于<code>OutputStream</code>构造的，它接收<code>char</code>，然后在内部自动转换成一个或多个<code>byte</code>，并写入<code>OutputStream</code>。因此，<code>OutputStreamWriter</code>就是一个将任意的<code>OutputStream</code>转换为<code>Writer</code>的转换器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;readme.txt&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码实际上就是<code>FileWriter</code>的一种实现方式。这和上一节的<code>InputStreamReader</code>是一样的。</p><h3 id="小结-10">小结</h3><p><code>Writer</code>定义了所有字符输出流的超类：</p><ul><li><code>FileWriter</code>实现了文件字符流输出；</li><li><code>CharArrayWriter</code>和<code>StringWriter</code>在内存中模拟一个字符流输出。</li></ul><p>使用<code>try (resource)</code>保证<code>Writer</code>正确关闭；</p><p><code>Writer</code>是基于<code>OutputStream</code>构造的，可以通过<code>OutputStreamWriter</code>将<code>OutputStream</code>转换为<code>Writer</code>，转换时需要指定编码。</p><hr><hr><h2 id="PrintStream和PrintWriter">PrintStream和PrintWriter</h2><p><code>PrintStream</code>是一种<code>FilterOutputStream</code>，它在<code>OutputStream</code>的接口上，额外提供了一些写入各种数据类型的方法：</p><ul><li>写入<code>int</code>：<code>print(int)</code></li><li>写入<code>boolean</code>：<code>print(boolean)</code></li><li>写入<code>String</code>：<code>print(String)</code></li><li>写入<code>Object</code>：<code>print(Object)</code>，实际上相当于<code>print(object.toString())</code></li><li>…</li></ul><p>以及对应的一组<code>println()</code>方法，它会自动加上换行符。</p><p>我们经常使用的<code>System.out.println()</code>实际上就是使用<code>PrintStream</code>打印各种数据。其中，<code>System.out</code>是系统默认提供的<code>PrintStream</code>，表示标准输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(<span class="number">12345</span>); <span class="comment">// 输出12345</span></span><br><span class="line">System.out.print(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 输出类似java.lang.Object@3c7a835a</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 输出Hello并换行</span></span><br></pre></td></tr></table></figure><p><code>System.err</code>是系统默认提供的标准错误输出。</p><p><code>PrintStream</code>和<code>OutputStream</code>相比，除了添加了一组<code>print()</code>/<code>println()</code>方法，可以打印各种数据类型，比较方便外，它还有一个额外的优点，就是不会抛出<code>IOException</code>，这样我们在编写代码的时候，就不必捕获<code>IOException</code>。</p><h3 id="PrintWriter">PrintWriter</h3><p><code>PrintStream</code>最终输出的总是byte数据，而<code>PrintWriter</code>则是扩展了<code>Writer</code>接口，它的<code>print()</code>/<code>println()</code>方法最终输出的是<code>char</code>数据。两者的使用方法几乎是一模一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>     &#123;</span><br><span class="line">        <span class="type">StringWriter</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(buffer)) &#123;</span><br><span class="line">            pw.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            pw.println(<span class="number">12345</span>);</span><br><span class="line">            pw.println(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-11">小结</h3><p><code>PrintStream</code>是一种能接收各种数据类型的输出，打印数据时比较方便：</p><ul><li><code>System.out</code>是标准输出；</li><li><code>System.err</code>是标准错误输出。</li></ul><p><code>PrintWriter</code>是基于<code>Writer</code>的输出。</p><hr><hr><h2 id="使用Files">使用Files</h2><p>从Java 7开始，提供了<code>Files</code>这个工具类，能极大地方便我们读写文件。</p><p>虽然<code>Files</code>是<code>java.nio</code>包里面的类，但他俩封装了很多读写文件的简单方法，例如，我们要把一个文件的全部内容读取为一个<code>byte[]</code>，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] data = Files.readAllBytes(Path.of(<span class="string">&quot;/path/to/file.txt&quot;</span>));</span><br></pre></td></tr></table></figure><p>如果是文本文件，可以把一个文件的全部内容读取为<code>String</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认使用UTF-8编码读取:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content1</span> <span class="operator">=</span> Files.readString(Path.of(<span class="string">&quot;/path/to/file.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 可指定编码:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content2</span> <span class="operator">=</span> Files.readString(Path.of(<span class="string">&quot;/path&quot;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;file.txt&quot;</span>), StandardCharsets.ISO_8859_1);</span><br><span class="line"><span class="comment">// 按行读取并返回每行内容:</span></span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(Path.of(<span class="string">&quot;/path/to/file.txt&quot;</span>));</span><br></pre></td></tr></table></figure><p>写入文件也非常方便：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入二进制文件:</span></span><br><span class="line"><span class="type">byte</span>[] data = ...</span><br><span class="line">Files.write(Path.of(<span class="string">&quot;/path/to/file.txt&quot;</span>), data);</span><br><span class="line"><span class="comment">// 写入文本并指定编码:</span></span><br><span class="line">Files.writeString(Path.of(<span class="string">&quot;/path/to/file.txt&quot;</span>), <span class="string">&quot;文本内容...&quot;</span>, StandardCharsets.ISO_8859_1);</span><br><span class="line"><span class="comment">// 按行写入文本:</span></span><br><span class="line">List&lt;String&gt; lines = ...</span><br><span class="line">Files.write(Path.of(<span class="string">&quot;/path/to/file.txt&quot;</span>), lines);</span><br></pre></td></tr></table></figure><p>此外，<code>Files</code>工具类还有<code>copy()</code>、<code>delete()</code>、<code>exists()</code>、<code>move()</code>等快捷方法操作文件和目录。</p><p>最后需要特别注意的是，<code>Files</code>提供的读写方法，受内存限制，只能读写小文件，例如配置文件等，不可一次读入几个G的大文件。读写大型文件仍然要使用文件流，每次只读写一部分文件内容。</p><h3 id="小结-12">小结</h3><p>对于简单的小文件读写操作，可以使用<code>Files</code>工具类简化代码。</p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-集合</title>
      <link href="/2025/05/24/JAVA-%E9%9B%86%E5%90%88/"/>
      <url>/2025/05/24/JAVA-%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="Java集合简介">Java集合简介</h2><p>什么是集合（Collection）？集合就是“由若干个确定的元素所构成的整体”。例如，5只小兔构成的集合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line"></span><br><span class="line">│   (\_(\     (\_/)     (\_/)     (\_/)      (\(\   │</span><br><span class="line">    ( -.-)    (•.•)     (&gt;.&lt;)     (^.^)     (=&#x27;.&#x27;)</span><br><span class="line">│  C(&quot;)_(&quot;)  (&quot;)_(&quot;)   (&quot;)_(&quot;)   (&quot;)_(&quot;)   O(_&quot;)&quot;)  │</span><br><span class="line"></span><br><span class="line">└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure><p>在数学中，我们经常遇到集合的概念。例如：</p><ul><li>有限集合：<ul><li>一个班所有的同学构成的集合；</li><li>一个网站所有的商品构成的集合；</li><li>…</li></ul></li><li>无限集合：<ul><li>全体自然数集合：1，2，3，……</li><li>有理数集合；</li><li>实数集合；</li><li>…</li></ul></li></ul><p>为什么要在计算机中引入集合呢？这是为了便于处理一组类似的数据，例如：</p><ul><li>计算所有同学的总成绩和平均成绩；</li><li>列举所有的商品名称和价格；</li><li>……</li></ul><p>在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] ss = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>]; <span class="comment">// 可以持有10个String对象</span></span><br><span class="line">ss[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 可以放入String对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> ss[<span class="number">0</span>]; <span class="comment">// 可以获取String对象</span></span><br></pre></td></tr></table></figure><p>既然Java提供了数组这种数据类型，可以充当集合，那么，我们为什么还需要其他集合类？这是因为数组有如下限制：</p><ul><li>数组初始化后大小不可变；</li><li>数组只能按索引顺序存取。</li></ul><p>因此，我们需要各种不同类型的集合类来处理不同的数据，例如：</p><ul><li>可变大小的顺序链表；</li><li>保证无重复元素的集合；</li><li>…</li></ul><h3 id="Collection">Collection</h3><p>Java标准库自带的<code>java.util</code>包提供了集合类：<code>Collection</code>，它是除<code>Map</code>外所有其他集合类的根接口。Java的<code>java.util</code>包主要提供了以下三种类型的集合：</p><ul><li><code>List</code>：一种有序列表的集合，例如，按索引排列的<code>Student</code>的<code>List</code>；</li><li><code>Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的<code>Student</code>的<code>Set</code>；</li><li><code>Map</code>：一种通过键值（key-value）查找的映射表集合，例如，根据<code>Student</code>的<code>name</code>查找对应<code>Student</code>的<code>Map</code>。</li></ul><p>Java集合的设计有几个特点：一是实现了接口和实现类相分离，例如，有序表的接口是<code>List</code>，具体的实现类有<code>ArrayList</code>，<code>LinkedList</code>等，二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 只能放入String类型</span></span><br></pre></td></tr></table></figure><p>最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p><p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p><ul><li><code>Hashtable</code>：一种线程安全的<code>Map</code>实现；</li><li><code>Vector</code>：一种线程安全的<code>List</code>实现；</li><li><code>Stack</code>：基于<code>Vector</code>实现的<code>LIFO</code>的栈。</li></ul><p>还有一小部分接口是遗留接口，也不应该继续使用：</p><ul><li><code>Enumeration&lt;E&gt;</code>：已被<code>Iterator&lt;E&gt;</code>取代。</li></ul><h3 id="小结">小结</h3><p>Java的集合类定义在<code>java.util</code>包中，支持泛型，主要提供了3种集合类，包括<code>List</code>，<code>Set</code>和<code>Map</code>。Java集合使用统一的<code>Iterator</code>遍历，尽量不要使用遗留接口。</p><hr><hr><p>在集合类中，<code>List</code>是最基础的一种集合：它是一种有序列表。</p><p><code>List</code>的行为和数组几乎完全相同：<code>List</code>内部按照放入元素的先后顺序存放，每个元素都可以通过索引确定自己的位置，<code>List</code>的索引和数组一样，从<code>0</code>开始。</p><p>数组和<code>List</code>类似，也是有序结构，如果我们使用数组，在添加和删除元素的时候，会非常不方便。例如，从一个已有的数组<code>&#123;'A', 'B', 'C', 'D', 'E'&#125;</code>中删除索引为<code>2</code>的元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌───┬───┬───┬───┬───┬───┐</span><br><span class="line">│ A │ B │ C │ D │ E │   │</span><br><span class="line">└───┴───┴───┴───┴───┴───┘</span><br><span class="line">              │   │</span><br><span class="line">          ┌───┘   │</span><br><span class="line">          │   ┌───┘</span><br><span class="line">          │   │</span><br><span class="line">          ▼   ▼</span><br><span class="line">┌───┬───┬───┬───┬───┬───┐</span><br><span class="line">│ A │ B │ D │ E │   │   │</span><br><span class="line">└───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>这个“删除”操作实际上是把<code>'C'</code>后面的元素依次往前挪一个位置，而“添加”操作实际上是把指定位置以后的元素都依次向后挪一个位置，腾出来的位置给新加的元素。这两种操作，用数组实现非常麻烦。</p><p>因此，在实际应用中，需要增删元素的有序列表，我们使用最多的是<code>ArrayList</code>。实际上，<code>ArrayList</code>在内部使用了数组来存储所有元素。例如，一个<code>ArrayList</code>拥有5个元素，实际数组大小为<code>6</code>（即有一个空位）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size=5</span><br><span class="line">┌───┬───┬───┬───┬───┬───┐</span><br><span class="line">│ A │ B │ C │ D │ E │   │</span><br><span class="line">└───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>当添加一个元素并指定索引到<code>ArrayList</code>时，<code>ArrayList</code>自动移动需要移动的元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size=5</span><br><span class="line">┌───┬───┬───┬───┬───┬───┐</span><br><span class="line">│ A │ B │   │ C │ D │ E │</span><br><span class="line">└───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>然后，往内部指定索引的数组位置添加一个元素，然后把<code>size</code>加<code>1</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size=6</span><br><span class="line">┌───┬───┬───┬───┬───┬───┐</span><br><span class="line">│ A │ B │ F │ C │ D │ E │</span><br><span class="line">└───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>继续添加元素，但是数组已满，没有空闲位置的时候，<code>ArrayList</code>先创建一个更大的新数组，然后把旧数组的所有元素复制到新数组，紧接着用新数组取代旧数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size=6</span><br><span class="line">┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">│ A │ B │ F │ C │ D │ E │   │   │   │   │   │   │</span><br><span class="line">└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>现在，新数组就有了空位，可以继续添加一个元素到数组末尾，同时<code>size</code>加<code>1</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size=7</span><br><span class="line">┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">│ A │ B │ F │ C │ D │ E │ G │   │   │   │   │   │</span><br><span class="line">└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>可见，<code>ArrayList</code>把添加和删除的操作封装起来，让我们操作<code>List</code>类似于操作数组，却不用关心内部元素如何移动。</p><p>我们考察<code>List&lt;E&gt;</code>接口，可以看到几个主要的接口方法：</p><ul><li>在末尾添加一个元素：<code>boolean add(E e)</code></li><li>在指定索引添加一个元素：<code>boolean add(int index, E e)</code></li><li>删除指定索引的元素：<code>E remove(int index)</code></li><li>删除某个元素：<code>boolean remove(Object e)</code></li><li>获取指定索引的元素：<code>E get(int index)</code></li><li>获取链表大小（包含元素的个数）：<code>int size()</code></li></ul><p>但是，实现<code>List</code>接口并非只能通过数组（即<code>ArrayList</code>的实现方式）来实现，另一种<code>LinkedList</code>通过“链表”也实现了List接口。在<code>LinkedList</code>中，它的内部每个元素都指向下一个元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        ┌───┬───┐   ┌───┬───┐   ┌───┬───┐   ┌───┬───┐</span><br><span class="line">HEAD ──▶│ A │ ●─┼──▶│ B │ ●─┼──▶│ C │ ●─┼──▶│ D │   │</span><br><span class="line">        └───┴───┘   └───┴───┘   └───┴───┘   └───┴───┘</span><br></pre></td></tr></table></figure><p>我们来比较一下<code>ArrayList</code>和<code>LinkedList</code>：</p><table><thead><tr><th></th><th>ArrayList</th><th>LinkedList</th></tr></thead><tbody><tr><td>获取指定元素</td><td>速度很快</td><td>需要从头开始查找元素</td></tr><tr><td>添加元素到末尾</td><td>速度很快</td><td>速度很快</td></tr><tr><td>在指定位置添加/删除</td><td>需要移动元素</td><td>不需要移动元素</td></tr><tr><td>内存占用</td><td>少</td><td>较大</td></tr></tbody></table><p>通常情况下，我们总是优先使用<code>ArrayList</code>。</p><h3 id="List的特点">List的特点</h3><p>使用<code>List</code>时，我们要关注<code>List</code>接口的规范。<code>List</code>接口允许我们添加重复的元素，即<code>List</code>内部的元素可以重复：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;apple&quot;</span>); <span class="comment">// size=1</span></span><br><span class="line">        list.add(<span class="string">&quot;pear&quot;</span>); <span class="comment">// size=2</span></span><br><span class="line">        list.add(<span class="string">&quot;apple&quot;</span>); <span class="comment">// 允许重复添加元素，size=3</span></span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>List</code>还允许添加<code>null</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;apple&quot;</span>); <span class="comment">// size=1</span></span><br><span class="line">        list.add(<span class="literal">null</span>); <span class="comment">// size=2</span></span><br><span class="line">        list.add(<span class="string">&quot;pear&quot;</span>); <span class="comment">// size=3</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">second</span> <span class="operator">=</span> list.get(<span class="number">1</span>); <span class="comment">// null</span></span><br><span class="line">        System.out.println(second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建List">创建List</h3><p>除了使用<code>ArrayList</code>和<code>LinkedList</code>，我们还可以通过<code>List</code>接口提供的<code>of()</code>方法，根据给定元素快速创建<code>List</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>但是<code>List.of()</code>方法不接受<code>null</code>值，如果传入<code>null</code>，会抛出<code>NullPointerException</code>异常。</p><h3 id="遍历List">遍历List</h3><p>和数组类型类似，我们要遍历一个<code>List</code>，完全可以用<code>for</code>循环根据索引配合<code>get(int)</code>方法遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种方式并不推荐，一是代码复杂，二是因为<code>get(int)</code>方法只有<code>ArrayList</code>的实现是高效的，换成<code>LinkedList</code>后，索引越大，访问速度越慢。</p><p>所以我们要始终坚持使用迭代器<code>Iterator</code>来访问<code>List</code>。<code>Iterator</code>本身也是一个对象，但它是由<code>List</code>的实例调用<code>iterator()</code>方法的时候创建的。<code>Iterator</code>对象知道如何遍历一个<code>List</code>，并且不同的<code>List</code>类型，返回的<code>Iterator</code>对象实现也是不同的，但总是具有最高的访问效率。</p><p><code>Iterator</code>对象有两个方法：<code>boolean hasNext()</code>判断是否有下一个元素，<code>E next()</code>返回下一个元素。因此，使用<code>Iterator</code>遍历<code>List</code>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有童鞋可能觉得使用<code>Iterator</code>访问<code>List</code>的代码比使用索引更复杂。但是，要记住，通过<code>Iterator</code>遍历<code>List</code>永远是最高效的方式。并且，由于<code>Iterator</code>遍历是如此常用，所以，Java的<code>for each</code>循环本身就可以帮我们使用<code>Iterator</code>遍历。把上面的代码再改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码就是我们编写遍历<code>List</code>的常见代码。</p><p>实际上，只要实现了<code>Iterable</code>接口的集合类都可以直接用<code>for each</code>循环来遍历，Java编译器本身并不知道如何遍历集合对象，但它会自动把<code>for each</code>循环变成<code>Iterator</code>的调用，原因就在于<code>Iterable</code>接口定义了一个<code>Iterator&lt;E&gt; iterator()</code>方法，强迫集合类必须返回一个<code>Iterator</code>实例。</p><h3 id="List和Array转换">List和Array转换</h3><p>把<code>List</code>变为<code>Array</code>有三种方法，第一种是调用<code>toArray()</code>方法直接返回一个<code>Object[]</code>数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        Object[] array = list.toArray();</span><br><span class="line">        <span class="keyword">for</span> (Object s : array) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法会丢失类型信息，所以实际应用很少。</p><p>第二种方式是给<code>toArray(T[])</code>传入一个类型相同的<code>Array</code>，<code>List</code>内部自动把元素复制到传入的<code>Array</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = List.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>);</span><br><span class="line">        Integer[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">for</span> (Integer n : array) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这个<code>toArray(T[])</code>方法的泛型参数<code>&lt;T&gt;</code>并不是<code>List</code>接口定义的泛型参数<code>&lt;E&gt;</code>，所以，我们实际上可以传入其他类型的数组，例如我们传入<code>Number</code>类型的数组，返回的仍然是<code>Number</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = List.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>);</span><br><span class="line">        Number[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">Number</span>[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">for</span> (Number n : array) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果我们传入类型不匹配的数组，例如，<code>String[]</code>类型的数组，由于<code>List</code>的元素是<code>Integer</code>，所以无法放入<code>String</code>数组，这个方法会抛出<code>ArrayStoreException</code>。</p><p>如果我们传入的数组大小和<code>List</code>实际的元素个数不一致怎么办？根据<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/List.html#toArray%28T%5B%5D%29">List接口</a>的文档，我们可以知道：</p><p>如果传入的数组不够大，那么<code>List</code>内部会创建一个新的刚好够大的数组，填充后返回；如果传入的数组比<code>List</code>元素还要多，那么填充完元素后，剩下的数组元素一律填充<code>null</code>。</p><p>实际上，最常用的是传入一个“恰好”大小的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[list.size()]);</span><br></pre></td></tr></table></figure><p>最后一种更简洁的写法是通过<code>List</code>接口定义的<code>T[] toArray(IntFunction&lt;T[]&gt; generator)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] array = list.toArray(Integer[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><p>这种函数式写法我们会在后续讲到。</p><p>反过来，把<code>Array</code>变为<code>List</code>就简单多了，通过<code>List.of(T...)</code>方法最简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List&lt;Integer&gt; list = List.of(array);</span><br></pre></td></tr></table></figure><p>对于JDK 11之前的版本，可以使用<code>Arrays.asList(T...)</code>方法把数组转换成<code>List</code>。</p><p>要注意的是，返回的<code>List</code>不一定就是<code>ArrayList</code>或者<code>LinkedList</code>，因为<code>List</code>只是一个接口，如果我们调用<code>List.of()</code>，它返回的是一个只读<code>List</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = List.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>);</span><br><span class="line">        list.add(<span class="number">999</span>); <span class="comment">// UnsupportedOperationException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对只读<code>List</code>调用<code>add()</code>、<code>remove()</code>方法会抛出<code>UnsupportedOperationException</code>。</p><h3 id="练习">练习</h3><p>给定一组连续的整数，例如：10，11，12，……，20，但其中缺失一个数字，试找出缺失的数字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造从start到end的序列：</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 随机删除List中的一个元素:</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">removed</span> <span class="operator">=</span> list.remove((<span class="type">int</span>) (Math.random() * list.size()));</span><br><span class="line">        <span class="type">int</span> <span class="variable">found</span> <span class="operator">=</span> findMissingNumber(start, end, list);</span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;missing number: &quot;</span> + found);</span><br><span class="line">        System.out.println(removed == found ? <span class="string">&quot;测试成功&quot;</span> : <span class="string">&quot;测试失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMissingNumber</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增强版：和上述题目一样，但整数不再有序，试找出缺失的数字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造从start到end的序列：</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 洗牌算法shuffle可以随机交换List中的元素位置:</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        <span class="comment">// 随机删除List中的一个元素:</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">removed</span> <span class="operator">=</span> list.remove((<span class="type">int</span>) (Math.random() * list.size()));</span><br><span class="line">        <span class="type">int</span> <span class="variable">found</span> <span class="operator">=</span> findMissingNumber(start, end, list);</span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;missing number: &quot;</span> + found);</span><br><span class="line">        System.out.println(removed == found ? <span class="string">&quot;测试成功&quot;</span> : <span class="string">&quot;测试失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMissingNumber</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/collection/list/coll-list.zip">下载练习</a></p><h3 id="小结-2">小结</h3><p><code>List</code>是按索引顺序访问的长度可变的有序表，优先使用<code>ArrayList</code>而不是<code>LinkedList</code>；</p><p>可以直接使用<code>for each</code>遍历<code>List</code>；</p><p><code>List</code>可以和<code>Array</code>相互转换。</p><p>我们知道<code>List</code>是一种有序链表：<code>List</code>内部按照放入元素的先后顺序存放，并且每个元素都可以通过索引确定自己的位置。</p><p><code>List</code>还提供了<code>boolean contains(Object o)</code>方法来判断<code>List</code>是否包含某个指定元素。此外，<code>int indexOf(Object o)</code>方法可以返回某个元素的索引，如果元素不存在，就返回<code>-1</code>。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(list.contains(<span class="string">&quot;C&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(list.contains(<span class="string">&quot;X&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;C&quot;</span>)); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;X&quot;</span>)); <span class="comment">// -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们注意一个问题，我们往<code>List</code>中添加的<code>&quot;C&quot;</code>和调用<code>contains(&quot;C&quot;)</code>传入的<code>&quot;C&quot;</code>是不是同一个实例？</p><p>如果这两个<code>&quot;C&quot;</code>不是同一个实例，这段代码是否还能得到正确的结果？我们可以改写一下代码测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(list.contains(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;C&quot;</span>))); <span class="comment">// true or false?</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;C&quot;</span>))); <span class="comment">// 2 or -1?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们传入的是<code>new String(&quot;C&quot;)</code>，所以一定是不同的实例。结果仍然符合预期，这是为什么呢？</p><p>因为<code>List</code>内部并不是通过<code>==</code>判断两个元素是否相等，而是使用<code>equals()</code>方法判断两个元素是否相等，例如<code>contains()</code>方法可以实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span> &#123;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; elementData.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，要正确使用<code>List</code>的<code>contains()</code>、<code>indexOf()</code>这些方法，放入的实例必须正确覆写<code>equals()</code>方法，否则，放进去的实例，查找不到。我们之所以能正常放入<code>String</code>、<code>Integer</code>这些对象，是因为Java标准库定义的这些类已经正确实现了<code>equals()</code>方法。</p><p>我们以<code>Person</code>对象为例，测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Person&gt; list = List.of(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Ming&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Hong&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        System.out.println(list.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>))); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不出意外，虽然放入了<code>new Person(&quot;Bob&quot;)</code>，但是用另一个<code>new Person(&quot;Bob&quot;)</code>查询不到，原因就是<code>Person</code>类没有覆写<code>equals()</code>方法。</p><h3 id="编写equals">编写equals</h3><p>如何正确编写<code>equals()</code>方法？<code>equals()</code>方法要求我们必须满足以下条件：</p><ul><li>自反性（Reflexive）：对于非<code>null</code>的<code>x</code>来说，<code>x.equals(x)</code>必须返回<code>true</code>；</li><li>对称性（Symmetric）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，则<code>y.equals(x)</code>也必须为<code>true</code>；</li><li>传递性（Transitive）：对于非<code>null</code>的<code>x</code>、<code>y</code>和<code>z</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，<code>y.equals(z)</code>也为<code>true</code>，那么<code>x.equals(z)</code>也必须为<code>true</code>；</li><li>一致性（Consistent）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，只要<code>x</code>和<code>y</code>状态不变，则<code>x.equals(y)</code>总是一致地返回<code>true</code>或者<code>false</code>；</li><li>对<code>null</code>的比较：即<code>x.equals(null)</code>永远返回<code>false</code>。</li></ul><p>上述规则看上去似乎非常复杂，但其实代码实现<code>equals()</code>方法是很简单的，我们以<code>Person</code>类为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们要定义“相等”的逻辑含义。对于<code>Person</code>类，如果<code>name</code>相等，并且<code>age</code>相等，我们就认为两个<code>Person</code>实例相等。</p><p>因此，编写<code>equals()</code>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person p) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name.equals(p.name) &amp;&amp; <span class="built_in">this</span>.age == p.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于引用字段比较，我们使用<code>equals()</code>，对于基本类型字段的比较，我们使用<code>==</code>。</p><p>如果<code>this.name</code>为<code>null</code>，那么<code>equals()</code>方法会报错，因此，需要继续改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person p) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">nameEquals</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.name == <span class="literal">null</span> &amp;&amp; p.name == <span class="literal">null</span>) &#123;</span><br><span class="line">            nameEquals = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.name != <span class="literal">null</span>) &#123;</span><br><span class="line">            nameEquals = <span class="built_in">this</span>.name.equals(p.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nameEquals &amp;&amp; <span class="built_in">this</span>.age == p.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>Person</code>有好几个引用类型的字段，上面的写法就太复杂了。要简化引用类型的比较，我们使用<code>Objects.equals()</code>静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(<span class="built_in">this</span>.name, p.name) &amp;&amp; <span class="built_in">this</span>.age == p.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们总结一下<code>equals()</code>方法的正确编写方法：</p><ol><li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li><li>用<code>instanceof</code>判断传入的待比较的<code>Object</code>是不是当前类型，如果是，继续比较，否则，返回<code>false</code>；</li><li>对引用类型用<code>Objects.equals()</code>比较，对基本类型直接用<code>==</code>比较。</li></ol><p>使用<code>Objects.equals()</code>比较两个引用类型是否相等的目的是省去了判断<code>null</code>的麻烦。两个引用类型都是<code>null</code>时它们也是相等的。</p><p>如果不调用<code>List</code>的<code>contains()</code>、<code>indexOf()</code>这些方法，那么放入的元素就不需要实现<code>equals()</code>方法。</p><h3 id="练习-2">练习</h3><p>给Person类增加equals方法，使得调用indexOf()方法返回正常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Person&gt; list = List.of(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao&quot;</span>, <span class="string">&quot;Ming&quot;</span>, <span class="number">18</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao&quot;</span>, <span class="string">&quot;Hong&quot;</span>, <span class="number">25</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Smith&quot;</span>, <span class="number">20</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">exist</span> <span class="operator">=</span> list.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Smith&quot;</span>, <span class="number">20</span>));</span><br><span class="line">        System.out.println(exist ? <span class="string">&quot;测试成功!&quot;</span> : <span class="string">&quot;测试失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String firstName, String lastName, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/collection/equals/coll-equals.zip">下载练习</a></p><h3 id="小结-3">小结</h3><p>在<code>List</code>中查找元素时，<code>List</code>的实现类通过元素的<code>equals()</code>方法比较两个元素是否相等，因此，放入的元素必须正确覆写<code>equals()</code>方法，Java标准库提供的<code>String</code>、<code>Integer</code>等已经覆写了<code>equals()</code>方法；</p><p>编写<code>equals()</code>方法可借助<code>Objects.equals()</code>判断。</p><p>如果不在<code>List</code>中查找元素，就不必覆写<code>equals()</code>方法。</p><p>我们知道，<code>List</code>是一种顺序列表，如果有一个存储学生<code>Student</code>实例的<code>List</code>，要在<code>List</code>中根据<code>name</code>查找某个指定的<code>Student</code>的分数，应该怎么办？</p><p>最简单的方法是遍历<code>List</code>并判断<code>name</code>是否相等，然后返回指定元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; list = ...</span><br><span class="line"><span class="type">Student</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">for</span> (Student s : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;Xiao Ming&quot;</span>.equals(s.name)) &#123;</span><br><span class="line">        target = s;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(target.score);</span><br></pre></td></tr></table></figure><p>这种需求其实非常常见，即通过一个键去查询对应的值。使用<code>List</code>来实现存在效率非常低的问题，因为平均需要扫描一半的元素才能确定，而<code>Map</code>这种键值（key-value）映射表的数据结构，作用就是能高效通过<code>key</code>快速查找<code>value</code>（元素）。</p><p>用<code>Map</code>来实现根据<code>name</code>查询某个<code>Student</code>的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="number">99</span>);</span><br><span class="line">        Map&lt;String, Student&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;Xiao Ming&quot;</span>, s); <span class="comment">// 将&quot;Xiao Ming&quot;和Student实例映射并关联</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">target</span> <span class="operator">=</span> map.get(<span class="string">&quot;Xiao Ming&quot;</span>); <span class="comment">// 通过key查找并返回映射的Student实例</span></span><br><span class="line">        System.out.println(target == s); <span class="comment">// true，同一个实例</span></span><br><span class="line">        System.out.println(target.score); <span class="comment">// 99</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">another</span> <span class="operator">=</span> map.get(<span class="string">&quot;Bob&quot;</span>); <span class="comment">// 通过另一个key查找</span></span><br><span class="line">        System.out.println(another); <span class="comment">// 未找到返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码可知：<code>Map&lt;K, V&gt;</code>是一种键-值映射表，当我们调用<code>put(K key, V value)</code>方法时，就把<code>key</code>和<code>value</code>做了映射并放入<code>Map</code>。当我们调用<code>V get(K key)</code>时，就可以通过<code>key</code>获取到对应的<code>value</code>。如果<code>key</code>不存在，则返回<code>null</code>。和<code>List</code>类似，<code>Map</code>也是一个接口，最常用的实现类是<code>HashMap</code>。</p><p>如果只是想查询某个<code>key</code>是否存在，可以调用<code>boolean containsKey(K key)</code>方法。</p><p>如果我们在存储<code>Map</code>映射关系的时候，对同一个key调用两次<code>put()</code>方法，分别放入不同的<code>value</code>，会有什么问题呢？例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">        map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">456</span>);</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;apple&quot;</span>)); <span class="comment">// 123</span></span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">789</span>); <span class="comment">// 再次放入apple作为key，但value变为789</span></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;apple&quot;</span>)); <span class="comment">// 789</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重复放入<code>key-value</code>并不会有任何问题，但是一个<code>key</code>只能关联一个<code>value</code>。在上面的代码中，一开始我们把<code>key</code>对象<code>&quot;apple&quot;</code>映射到<code>Integer</code>对象<code>123</code>，然后再次调用<code>put()</code>方法把<code>&quot;apple&quot;</code>映射到<code>789</code>，这时，原来关联的<code>value</code>对象<code>123</code>就被“冲掉”了。实际上，<code>put()</code>方法的签名是<code>V put(K key, V value)</code>，如果放入的<code>key</code>已经存在，<code>put()</code>方法会返回被删除的旧的<code>value</code>，否则，返回<code>null</code>。</p><p>始终牢记</p><p>Map中不存在重复的key，因为放入相同的key，只会把原有的key-value对应的value给替换掉。</p><p>此外，在一个<code>Map</code>中，虽然<code>key</code>不能重复，但<code>value</code>是可以重复的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">123</span>); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><h3 id="遍历Map">遍历Map</h3><p>对<code>Map</code>来说，要遍历<code>key</code>可以使用<code>for each</code>循环遍历<code>Map</code>实例的<code>keySet()</code>方法返回的<code>Set</code>集合，它包含不重复的<code>key</code>的集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">        map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">456</span>);</span><br><span class="line">        map.put(<span class="string">&quot;banana&quot;</span>, <span class="number">789</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时遍历<code>key</code>和<code>value</code>可以使用<code>for each</code>循环遍历<code>Map</code>对象的<code>entrySet()</code>集合，它包含每一个<code>key-value</code>映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">        map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">456</span>);</span><br><span class="line">        map.put(<span class="string">&quot;banana&quot;</span>, <span class="number">789</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Map</code>和<code>List</code>不同的是，<code>Map</code>存储的是<code>key-value</code>的映射关系，并且，它<em>不保证顺序</em>。在遍历的时候，遍历的顺序既不一定是<code>put()</code>时放入的<code>key</code>的顺序，也不一定是<code>key</code>的排序顺序。使用<code>Map</code>时，任何依赖顺序的逻辑都是不可靠的。以<code>HashMap</code>为例，假设我们放入<code>&quot;A&quot;</code>，<code>&quot;B&quot;</code>，<code>&quot;C&quot;</code>这3个<code>key</code>，遍历的时候，每个<code>key</code>会保证被遍历一次且仅遍历一次，但顺序完全没有保证，甚至对于不同的JDK版本，相同的代码遍历的输出顺序都是不同的！</p><p>注意</p><p>遍历Map时，不可假设输出的key是有序的！</p><h3 id="练习-3">练习</h3><p>请编写一个根据<code>name</code>查找<code>score</code>的程序，并利用<code>Map</code>充当缓存，以提高查找效率：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Student&gt; list = List.of(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">78</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">85</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Brush&quot;</span>, <span class="number">66</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Newton&quot;</span>, <span class="number">99</span>));</span><br><span class="line">        <span class="type">var</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Students</span>(list);</span><br><span class="line">        System.out.println(holder.getScore(<span class="string">&quot;Bob&quot;</span>) == <span class="number">78</span> ? <span class="string">&quot;测试成功!&quot;</span> : <span class="string">&quot;测试失败!&quot;</span>);</span><br><span class="line">        System.out.println(holder.getScore(<span class="string">&quot;Alice&quot;</span>) == <span class="number">85</span> ? <span class="string">&quot;测试成功!&quot;</span> : <span class="string">&quot;测试失败!&quot;</span>);</span><br><span class="line">        System.out.println(holder.getScore(<span class="string">&quot;Tom&quot;</span>) == -<span class="number">1</span> ? <span class="string">&quot;测试成功!&quot;</span> : <span class="string">&quot;测试失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Students</span> &#123;</span><br><span class="line">    List&lt;Student&gt; list;</span><br><span class="line">    Map&lt;String, Integer&gt; cache;</span><br><span class="line"></span><br><span class="line">    Students(List&lt;Student&gt; list) &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据name查找score，找到返回score，未找到返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getScore</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">// 先在Map中查找:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">score</span> <span class="operator">=</span> <span class="built_in">this</span>.cache.get(name);</span><br><span class="line">        <span class="keyword">if</span> (score == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> score == <span class="literal">null</span> ? -<span class="number">1</span> : score.intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Integer <span class="title function_">findInList</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> ss : <span class="built_in">this</span>.list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ss.name.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">return</span> ss.score;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    Student(String name, <span class="type">int</span> score) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/collection/map/coll-map.zip">下载练习</a></p><h3 id="小结-4">小结</h3><p><code>Map</code>是一种映射表，可以通过<code>key</code>快速查找<code>value</code>；</p><p>可以通过<code>for each</code>遍历<code>keySet()</code>，也可以通过<code>for each</code>遍历<code>entrySet()</code>，直接获取<code>key-value</code>；</p><p>最常用的一种<code>Map</code>实现是<code>HashMap</code>。</p><p>我们知道Map是一种键-值（key-value）映射表，可以通过key快速查找对应的value。</p><p>以<code>HashMap</code>为例，观察下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Person&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Ming&quot;</span>));</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Hong&quot;</span>));</span><br><span class="line">map.put(<span class="string">&quot;c&quot;</span>, <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Jun&quot;</span>));</span><br><span class="line"></span><br><span class="line">map.get(<span class="string">&quot;a&quot;</span>); <span class="comment">// Person(&quot;Xiao Ming&quot;)</span></span><br><span class="line">map.get(<span class="string">&quot;x&quot;</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p><code>HashMap</code>之所以能根据<code>key</code>直接拿到<code>value</code>，原因是它内部通过空间换时间的方法，用一个大数组存储所有<code>value</code>，并根据key直接计算出<code>value</code>应该存储在哪个索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  ┌───┐</span><br><span class="line">0 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">1 │ ●─┼───▶ Person(&quot;Xiao Ming&quot;)</span><br><span class="line">  ├───┤</span><br><span class="line">2 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">3 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">4 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">5 │ ●─┼───▶ Person(&quot;Xiao Hong&quot;)</span><br><span class="line">  ├───┤</span><br><span class="line">6 │ ●─┼───▶ Person(&quot;Xiao Jun&quot;)</span><br><span class="line">  ├───┤</span><br><span class="line">7 │   │</span><br><span class="line">  └───┘</span><br></pre></td></tr></table></figure><p>如果<code>key</code>的值为<code>&quot;a&quot;</code>，计算得到的索引总是<code>1</code>，因此返回<code>value</code>为<code>Person(&quot;Xiao Ming&quot;)</code>，如果<code>key</code>的值为<code>&quot;b&quot;</code>，计算得到的索引总是<code>5</code>，因此返回<code>value</code>为<code>Person(&quot;Xiao Hong&quot;)</code>，这样，就不必遍历整个数组，即可直接读取<code>key</code>对应的<code>value</code>。</p><p>当我们使用<code>key</code>存取<code>value</code>的时候，就会引出一个问题：</p><p>我们放入<code>Map</code>的<code>key</code>是字符串<code>&quot;a&quot;</code>，但是，当我们获取<code>Map</code>的<code>value</code>时，传入的变量不一定就是放入的那个<code>key</code>对象。</p><p>换句话讲，两个<code>key</code>应该是内容相同，但不一定是同一个对象。测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(key1, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        map.get(key2); <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">        System.out.println(key1 == key2); <span class="comment">// false</span></span><br><span class="line">        System.out.println(key1.equals(key2)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在<code>Map</code>的内部，对<code>key</code>做比较是通过<code>equals()</code>实现的，这一点和<code>List</code>查找元素需要正确覆写<code>equals()</code>是一样的，即正确使用<code>Map</code>必须保证：作为<code>key</code>的对象必须正确覆写<code>equals()</code>方法。</p><p>我们经常使用<code>String</code>作为<code>key</code>，因为<code>String</code>已经正确覆写了<code>equals()</code>方法。但如果我们放入的<code>key</code>是一个自己写的类，就必须保证正确覆写了<code>equals()</code>方法。</p><p>我们再思考一下<code>HashMap</code>为什么能通过<code>key</code>直接计算出<code>value</code>存储的索引。相同的<code>key</code>对象（使用<code>equals()</code>判断时返回<code>true</code>）必须要计算出相同的索引，否则，相同的<code>key</code>每次取出的<code>value</code>就不一定对。</p><p>通过<code>key</code>计算索引的方式就是调用<code>key</code>对象的<code>hashCode()</code>方法，它返回一个<code>int</code>整数。<code>HashMap</code>正是通过这个方法直接定位<code>key</code>对应的<code>value</code>的索引，继而直接返回<code>value</code>。</p><p>因此，正确使用<code>Map</code>必须保证：</p><ol><li>作为<code>key</code>的对象必须正确覆写<code>equals()</code>方法，相等的两个<code>key</code>实例调用<code>equals()</code>必须返回<code>true</code>；</li><li>作为<code>key</code>的对象还必须正确覆写<code>hashCode()</code>方法，且<code>hashCode()</code>方法要严格遵循以下规范：<ul><li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等；</li><li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等。</li></ul></li></ol><p>即对应两个实例<code>a</code>和<code>b</code>：</p><ul><li>如果<code>a</code>和<code>b</code>相等，那么<code>a.equals(b)</code>一定为<code>true</code>，则<code>a.hashCode()</code>必须等于<code>b.hashCode()</code>；</li><li>如果<code>a</code>和<code>b</code>不相等，那么<code>a.equals(b)</code>一定为<code>false</code>，则<code>a.hashCode()</code>和<code>b.hashCode()</code>尽量不要相等。</li></ul><p>上述第一条规范是正确性，必须保证实现，否则<code>HashMap</code>不能正常工作。</p><p>而第二条如果尽量满足，则可以保证查询效率，因为不同的对象，如果返回相同的<code>hashCode()</code>，会造成<code>Map</code>内部存储冲突，使存取的效率下降。</p><p>正确编写<code>equals()</code>的方法我们已经在<a href="https://liaoxuefeng.com/books/java/collection/equals/index.html">编写equals方法</a>一节中讲过了，以<code>Person</code>类为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把需要比较的字段找出来：</p><ul><li>firstName</li><li>lastName</li><li>age</li></ul><p>然后，引用类型使用<code>Objects.equals()</code>比较，基本类型使用<code>==</code>比较。</p><p>在正确实现<code>equals()</code>的基础上，我们还需要正确实现<code>hashCode()</code>，即上述3个字段分别相同的实例，<code>hashCode()</code>返回的<code>int</code>必须相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        h = <span class="number">31</span> * h + firstName.hashCode();</span><br><span class="line">        h = <span class="number">31</span> * h + lastName.hashCode();</span><br><span class="line">        h = <span class="number">31</span> * h + age;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>String</code>类已经正确实现了<code>hashCode()</code>方法，我们在计算<code>Person</code>的<code>hashCode()</code>时，反复使用<code>31*h</code>，这样做的目的是为了尽量把不同的<code>Person</code>实例的<code>hashCode()</code>均匀分布到整个<code>int</code>范围。</p><p>和实现<code>equals()</code>方法遇到的问题类似，如果<code>firstName</code>或<code>lastName</code>为<code>null</code>，上述代码工作起来就会抛<code>NullPointerException</code>。为了解决这个问题，我们在计算<code>hashCode()</code>的时候，经常借助<code>Objects.hash()</code>来计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(firstName, lastName, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，编写<code>equals()</code>和<code>hashCode()</code>遵循的原则是：</p><p><code>equals()</code>用到的用于比较的每一个字段，都必须在<code>hashCode()</code>中用于计算；<code>equals()</code>中没有使用到的字段，绝不可放在<code>hashCode()</code>中计算。</p><p>另外注意，对于放入<code>HashMap</code>的<code>value</code>对象，没有任何要求。</p><h3 id="延伸阅读">延伸阅读</h3><p>既然<code>HashMap</code>内部使用了数组，通过计算<code>key</code>的<code>hashCode()</code>直接定位<code>value</code>所在的索引，那么第一个问题来了：<code>hashCode()</code>返回的<code>int</code>范围高达±21亿，先不考虑负数，<code>HashMap</code>内部使用的数组得有多大？</p><p>实际上<code>HashMap</code>初始化时默认的数组大小只有16，任何<code>key</code>，无论它的<code>hashCode()</code>有多大，都可以简单地通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> key.hashCode() &amp; <span class="number">0xf</span>; <span class="comment">// 0xf = 15</span></span><br></pre></td></tr></table></figure><p>把索引确定在0 ~ 15，即永远不会超出数组范围，上述算法只是一种最简单的实现。</p><p>第二个问题：如果添加超过16个<code>key-value</code>到<code>HashMap</code>，数组不够用了怎么办？</p><p>添加超过一定数量的<code>key-value</code>时，<code>HashMap</code>会在内部自动扩容，每次扩容一倍，即长度为16的数组扩展为长度32，相应地，需要重新确定<code>hashCode()</code>计算的索引位置。例如，对长度为32的数组计算<code>hashCode()</code>对应的索引，计算方式要改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> key.hashCode() &amp; <span class="number">0x1f</span>; <span class="comment">// 0x1f = 31</span></span><br></pre></td></tr></table></figure><p>由于扩容会导致重新分布已有的<code>key-value</code>，所以，频繁扩容对<code>HashMap</code>的性能影响很大。如果我们确定要使用一个容量为<code>10000</code>个<code>key-value</code>的<code>HashMap</code>，更好的方式是创建<code>HashMap</code>时就指定容量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure><p>虽然指定容量是<code>10000</code>，但<code>HashMap</code>内部的数组长度总是2n，因此，实际数组长度被初始化为比<code>10000</code>大的<code>16384</code>（214）。</p><p>最后一个问题：如果不同的两个<code>key</code>，例如<code>&quot;a&quot;</code>和<code>&quot;b&quot;</code>，它们的<code>hashCode()</code>恰好是相同的（这种情况是完全可能的，因为不相等的两个实例，只要求<code>hashCode()</code>尽量不相等），那么，当我们放入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Ming&quot;</span>));</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Hong&quot;</span>));</span><br></pre></td></tr></table></figure><p>时，由于计算出的数组索引相同，后面放入的<code>&quot;Xiao Hong&quot;</code>会不会把<code>&quot;Xiao Ming&quot;</code>覆盖了？</p><p>当然不会！使用<code>Map</code>的时候，只要<code>key</code>不相同，它们映射的<code>value</code>就互不干扰。但是，在<code>HashMap</code>内部，确实可能存在不同的<code>key</code>，映射到相同的<code>hashCode()</code>，即相同的数组索引上，肿么办？</p><p>我们就假设<code>&quot;a&quot;</code>和<code>&quot;b&quot;</code>这两个<code>key</code>最终计算出的索引都是5，那么，在<code>HashMap</code>的数组中，实际存储的不是一个<code>Person</code>实例，而是一个<code>List</code>，它包含两个<code>Entry</code>，一个是<code>&quot;a&quot;</code>的映射，一个是<code>&quot;b&quot;</code>的映射：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  ┌───┐</span><br><span class="line">0 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">1 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">2 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">3 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">4 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">5 │ ●─┼───▶ List&lt;Entry&lt;String, Person&gt;&gt;</span><br><span class="line">  ├───┤</span><br><span class="line">6 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">7 │   │</span><br><span class="line">  └───┘</span><br></pre></td></tr></table></figure><p>在查找的时候，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> map.get(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>HashMap</code>内部通过<code>&quot;a&quot;</code>找到的实际上是<code>List&lt;Entry&lt;String, Person&gt;&gt;</code>，它还需要遍历这个<code>List</code>，并找到一个<code>Entry</code>，它的<code>key</code>字段是<code>&quot;a&quot;</code>，才能返回对应的<code>Person</code>实例。</p><p>我们把不同的<code>key</code>具有相同的<code>hashCode()</code>的情况称之为哈希冲突。在冲突的时候，一种最简单的解决办法是用<code>List</code>存储<code>hashCode()</code>相同的<code>key-value</code>。显然，如果冲突的概率越大，这个<code>List</code>就越长，<code>Map</code>的<code>get()</code>方法效率就越低，这就是为什么要尽量满足条件二：</p><p>提示</p><p>如果两个对象不相等，则两个对象的hashCode()尽量不要相等。</p><p><code>hashCode()</code>方法编写得越好，<code>HashMap</code>工作的效率就越高。</p><h3 id="小结-5">小结</h3><p>要正确使用<code>HashMap</code>，作为<code>key</code>的类必须正确覆写<code>equals()</code>和<code>hashCode()</code>方法；</p><p>一个类如果覆写了<code>equals()</code>，就必须覆写<code>hashCode()</code>，并且覆写规则是：</p><ul><li>如果<code>equals()</code>返回<code>true</code>，则<code>hashCode()</code>返回值必须相等；</li><li>如果<code>equals()</code>返回<code>false</code>，则<code>hashCode()</code>返回值尽量不要相等。</li></ul><p>实现<code>hashCode()</code>方法可以通过<code>Objects.hashCode()</code>辅助方法实现。</p><h2 id="使用EnumMap">使用EnumMap</h2><p>因为<code>HashMap</code>是一种通过对key计算<code>hashCode()</code>，通过空间换时间的方式，直接定位到value所在的内部数组的索引，因此，查找效率非常高。</p><p>如果作为key的对象是<code>enum</code>类型，那么，还可以使用Java集合库提供的一种<code>EnumMap</code>，它在内部以一个非常紧凑的数组存储value，并且根据<code>enum</code>类型的key直接定位到内部数组的索引，并不需要计算<code>hashCode()</code>，不但效率最高，而且没有额外的空间浪费。</p><p>我们以<code>DayOfWeek</code>这个枚举类型为例，为它做一个“翻译”功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.DayOfWeek;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;DayOfWeek, String&gt; map = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(DayOfWeek.class);</span><br><span class="line">        map.put(DayOfWeek.MONDAY, <span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.TUESDAY, <span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.WEDNESDAY, <span class="string">&quot;星期三&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.THURSDAY, <span class="string">&quot;星期四&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.FRIDAY, <span class="string">&quot;星期五&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.SATURDAY, <span class="string">&quot;星期六&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.SUNDAY, <span class="string">&quot;星期日&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        System.out.println(map.get(DayOfWeek.MONDAY));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>EnumMap</code>的时候，我们总是用<code>Map</code>接口来引用它，因此，实际上把<code>HashMap</code>和<code>EnumMap</code>互换，在客户端看来没有任何区别。</p><h3 id="小结-6">小结</h3><p>如果<code>Map</code>的key是<code>enum</code>类型，推荐使用<code>EnumMap</code>，既保证速度，也不浪费空间。</p><p>使用<code>EnumMap</code>的时候，根据面向抽象编程的原则，应持有<code>Map</code>接口。</p><hr><hr><p>我们已经知道，<code>HashMap</code>是一种以空间换时间的映射表，它的实现原理决定了内部的Key是无序的，即遍历<code>HashMap</code>的Key时，其顺序是不可预测的（但每个Key都会遍历一次且仅遍历一次）。</p><p>还有一种<code>Map</code>，它在内部会对Key进行排序，这种<code>Map</code>就是<code>SortedMap</code>。注意到<code>SortedMap</code>是接口，它的实现类是<code>TreeMap</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">       ┌───┐</span><br><span class="line">       │Map│</span><br><span class="line">       └───┘</span><br><span class="line">         ▲</span><br><span class="line">    ┌────┴─────┐</span><br><span class="line">    │          │</span><br><span class="line">┌───────┐ ┌─────────┐</span><br><span class="line">│HashMap│ │SortedMap│</span><br><span class="line">└───────┘ └─────────┘</span><br><span class="line">               ▲</span><br><span class="line">               │</span><br><span class="line">          ┌─────────┐</span><br><span class="line">          │ TreeMap │</span><br><span class="line">          └─────────┘</span><br></pre></td></tr></table></figure><p><code>SortedMap</code>保证遍历时以Key的顺序来进行排序。例如，放入的Key是<code>&quot;apple&quot;</code>、<code>&quot;pear&quot;</code>、<code>&quot;orange&quot;</code>，遍历的顺序一定是<code>&quot;apple&quot;</code>、<code>&quot;orange&quot;</code>、<code>&quot;pear&quot;</code>，因为<code>String</code>默认按字母排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;orange&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// apple, orange, pear</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>TreeMap</code>时，放入的Key必须实现<code>Comparable</code>接口。<code>String</code>、<code>Integer</code>这些类已经实现了<code>Comparable</code>接口，因此可以直接作为Key使用。作为Value的对象则没有任何要求。</p><p>如果作为Key的class没有实现<code>Comparable</code>接口，那么，必须在创建<code>TreeMap</code>时同时指定一个自定义排序算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;Person, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person p1, Person p2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> p1.name.compareTo(p2.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>), <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>), <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>), <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (Person key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &#123;Person: Bob&#125;, &#123;Person: Lily&#125;, &#123;Person: Tom&#125;</span></span><br><span class="line">        System.out.println(map.get(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>))); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    Person(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;Person: &quot;</span> + name + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>Comparator</code>接口要求实现一个比较方法，它负责比较传入的两个元素<code>a</code>和<code>b</code>，如果<code>a&lt;b</code>，则返回负数，通常是<code>-1</code>，如果<code>a==b</code>，则返回<code>0</code>，如果<code>a&gt;b</code>，则返回正数，通常是<code>1</code>。<code>TreeMap</code>内部根据比较结果对Key进行排序。</p><p>从上述代码执行结果可知，打印的Key确实是按照<code>Comparator</code>定义的顺序排序的。如果要根据Key查找Value，我们可以传入一个<code>new Person(&quot;Bob&quot;)</code>作为Key，它会返回对应的<code>Integer</code>值<code>2</code>。</p><p>另外，注意到<code>Person</code>类并未覆写<code>equals()</code>和<code>hashCode()</code>，因为<code>TreeMap</code>不使用<code>equals()</code>和<code>hashCode()</code>。</p><p>我们来看一个稍微复杂的例子：这次我们定义了<code>Student</code>类，并用分数<code>score</code>进行排序，高分在前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;Student, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student p1, Student p2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> p1.score &gt; p2.score ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">77</span>), <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">66</span>), <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">99</span>), <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (Student key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map.get(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">66</span>))); <span class="comment">// null?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> score;</span><br><span class="line">    Student(String name, <span class="type">int</span> score) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;&#123;%s: score=%d&#125;&quot;</span>, name, score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>for</code>循环中，我们确实得到了正确的顺序。但是，且慢！根据相同的Key：<code>new Student(&quot;Bob&quot;, 66)</code>进行查找时，结果为<code>null</code>！</p><p>这是怎么肥四？难道<code>TreeMap</code>有问题？遇到<code>TreeMap</code>工作不正常时，我们首先回顾Java编程基本规则：出现问题，不要怀疑Java标准库，要从自身代码找原因。</p><p>在这个例子中，<code>TreeMap</code>出现问题，原因其实出在这个<code>Comparator</code>上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student p1, Student p2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p1.score &gt; p2.score ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>p1.score</code>和<code>p2.score</code>不相等的时候，它的返回值是正确的，但是，在<code>p1.score</code>和<code>p2.score</code>相等的时候，它并没有返回<code>0</code>！这就是为什么<code>TreeMap</code>工作不正常的原因：<code>TreeMap</code>在比较两个Key是否相等时，依赖Key的<code>compareTo()</code>方法或者<code>Comparator.compare()</code>方法。在两个Key相等时，必须返回<code>0</code>。因此，修改代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student p1, Student p2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p1.score == p2.score) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1.score &gt; p2.score ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者直接借助<code>Integer.compare(int, int)</code>也可以返回正确的比较结果。</p><p>注意</p><p>使用TreeMap时，对Key的比较需要正确实现相等、大于和小于逻辑！</p><h3 id="小结-7">小结</h3><p><code>SortedMap</code>在遍历时严格按照Key的顺序遍历，最常用的实现类是<code>TreeMap</code>；</p><p>作为<code>SortedMap</code>的Key必须实现<code>Comparable</code>接口，或者传入<code>Comparator</code>；</p><p>要严格按照<code>compare()</code>规范实现比较逻辑，否则，<code>TreeMap</code>将不能正常工作。</p><p>在编写应用程序的时候，经常需要读写配置文件。例如，用户的设置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上次最后打开的文件:</span></span><br><span class="line"><span class="attr">last_open_file</span>=/data/hello.txt</span><br><span class="line"><span class="comment"># 自动保存文件的时间间隔:</span></span><br><span class="line"><span class="attr">auto_save_interval</span>=<span class="number">60</span></span><br></pre></td></tr></table></figure><p>配置文件的特点是，它的Key-Value一般都是<code>String</code>-<code>String</code>类型的，因此我们完全可以用<code>Map&lt;String, String&gt;</code>来表示它。</p><p>因为配置文件非常常用，所以Java集合库提供了一个<code>Properties</code>来表示一组“配置”。由于历史遗留原因，<code>Properties</code>内部本质上是一个<code>Hashtable</code>，但我们只需要用到<code>Properties</code>自身关于读写配置的接口。</p><h3 id="读取配置文件">读取配置文件</h3><p>用<code>Properties</code>读取配置文件非常简单。Java默认配置文件以<code>.properties</code>为扩展名，每行以<code>key=value</code>表示，以<code>#</code>课开头的是注释。以下是一个典型的配置文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># setting.properties</span><br><span class="line"></span><br><span class="line">last_open_file=/data/hello.txt</span><br><span class="line">auto_save_interval=<span class="number">60</span></span><br></pre></td></tr></table></figure><p>可以从文件系统读取这个<code>.properties</code>文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">f</span> <span class="operator">=</span> <span class="string">&quot;setting.properties&quot;</span>;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(<span class="keyword">new</span> <span class="title class_">java</span>.io.FileInputStream(f));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">filepath</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;last_open_file&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">interval</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;auto_save_interval&quot;</span>, <span class="string">&quot;120&quot;</span>);</span><br></pre></td></tr></table></figure><p>可见，用<code>Properties</code>读取配置文件，一共有三步：</p><ol><li>创建<code>Properties</code>实例；</li><li>调用<code>load()</code>读取文件；</li><li>调用<code>getProperty()</code>获取配置。</li></ol><p>调用<code>getProperty()</code>获取配置时，如果key不存在，将返回<code>null</code>。我们还可以提供一个默认值，这样，当key不存在的时候，就返回默认值。</p><p>也可以从classpath读取<code>.properties</code>文件，因为<code>load(InputStream)</code>方法接收一个<code>InputStream</code>实例，表示一个字节流，它不一定是文件流，也可以是从jar包中读取的资源流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(getClass().getResourceAsStream(<span class="string">&quot;/common/setting.properties&quot;</span>));</span><br></pre></td></tr></table></figure><p>试试从内存读取一个字节流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// properties</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">settings</span> <span class="operator">=</span> <span class="string">&quot;# test&quot;</span> + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;course=Java&quot;</span> + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;last_open_date=2019-08-07T12:35:01&quot;</span>;</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(settings.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        props.load(input);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;course: &quot;</span> + props.getProperty(<span class="string">&quot;course&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;last_open_date: &quot;</span> + props.getProperty(<span class="string">&quot;last_open_date&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;last_open_file: &quot;</span> + props.getProperty(<span class="string">&quot;last_open_file&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;auto_save: &quot;</span> + props.getProperty(<span class="string">&quot;auto_save&quot;</span>, <span class="string">&quot;60&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有多个<code>.properties</code>文件，可以反复调用<code>load()</code>读取，后读取的key-value会覆盖已读取的key-value：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(getClass().getResourceAsStream(<span class="string">&quot;/common/setting.properties&quot;</span>));</span><br><span class="line">props.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\conf\\setting.properties&quot;</span>));</span><br></pre></td></tr></table></figure><p>上面的代码演示了<code>Properties</code>的一个常用用法：可以把默认配置文件放到classpath中，然后，根据机器的环境编写另一个配置文件，覆盖某些默认的配置。</p><p><code>Properties</code>设计的目的是存储<code>String</code>类型的key－value，但<code>Properties</code>实际上是从<code>Hashtable</code>派生的，它的设计实际上是有问题的，但是为了保持兼容性，现在已经没法修改了。除了<code>getProperty()</code>和<code>setProperty()</code>方法外，还有从<code>Hashtable</code>继承下来的<code>get()</code>和<code>put()</code>方法，这些方法的参数签名是<code>Object</code>，我们在使用<code>Properties</code>的时候，不要去调用这些从<code>Hashtable</code>继承下来的方法。</p><h3 id="写入配置文件">写入配置文件</h3><p>如果通过<code>setProperty()</code>修改了<code>Properties</code>实例，可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用<code>store()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.setProperty(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;http://www.liaoxuefeng.com&quot;</span>);</span><br><span class="line">props.setProperty(<span class="string">&quot;language&quot;</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">props.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\conf\\setting.properties&quot;</span>), <span class="string">&quot;这是写入的properties注释&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="编码">编码</h3><p>早期版本的Java规定<code>.properties</code>文件编码是ASCII编码（ISO8859-1），如果涉及到中文就必须用<code>name=\u4e2d\u6587</code>来表示，非常别扭。从JDK9开始，Java的<code>.properties</code>文件可以使用UTF-8编码了。</p><p>不过，需要注意的是，由于<code>load(InputStream)</code>默认总是以ASCII编码读取字节流，所以会导致读到乱码。我们需要用另一个重载方法<code>load(Reader)</code>读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;settings.properties&quot;</span>, StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure><p>就可以正常读取中文。<code>InputStream</code>和<code>Reader</code>的区别是一个是字节流，一个是字符流。字符流在内存中已经以<code>char</code>类型表示了，不涉及编码问题。</p><h3 id="小结-8">小结</h3><p>Java集合库提供的<code>Properties</code>用于读写配置文件<code>.properties</code>。<code>.properties</code>文件可以使用UTF-8编码；</p><p>可以从文件系统、classpath或其他任何地方读取<code>.properties</code>文件；</p><p>读写<code>Properties</code>时，注意仅使用<code>getProperty()</code>和<code>setProperty()</code>方法，不要调用继承而来的<code>get()</code>和<code>put()</code>等方法。</p><p>我们知道，<code>Map</code>用于存储key-value的映射，对于充当key的对象，是不能重复的，并且，不但需要正确覆写<code>equals()</code>方法，还要正确覆写<code>hashCode()</code>方法。</p><p>如果我们只需要存储不重复的key，并不需要存储映射的value，那么就可以使用<code>Set</code>。</p><p><code>Set</code>用于存储不重复的元素集合，它主要提供以下几个方法：</p><ul><li>将元素添加进<code>Set&lt;E&gt;</code>：<code>boolean add(E e)</code></li><li>将元素从<code>Set&lt;E&gt;</code>删除：<code>boolean remove(Object e)</code></li><li>判断是否包含元素：<code>boolean contains(Object e)</code></li></ul><p>我们来看几个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        System.out.println(set.add(<span class="string">&quot;abc&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(set.add(<span class="string">&quot;xyz&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(set.add(<span class="string">&quot;xyz&quot;</span>)); <span class="comment">// false，添加失败，因为元素已存在</span></span><br><span class="line">        System.out.println(set.contains(<span class="string">&quot;xyz&quot;</span>)); <span class="comment">// true，元素存在</span></span><br><span class="line">        System.out.println(set.contains(<span class="string">&quot;XYZ&quot;</span>)); <span class="comment">// false，元素不存在</span></span><br><span class="line">        System.out.println(set.remove(<span class="string">&quot;hello&quot;</span>)); <span class="comment">// false，删除失败，因为元素不存在</span></span><br><span class="line">        System.out.println(set.size()); <span class="comment">// 2，一共两个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Set</code>实际上相当于只存储key、不存储value的<code>Map</code>。我们经常用<code>Set</code>用于去除重复元素。</p><p>因为放入<code>Set</code>的元素和<code>Map</code>的key类似，都要正确实现<code>equals()</code>和<code>hashCode()</code>方法，否则该元素无法正确地放入<code>Set</code>。</p><p>最常用的<code>Set</code>实现类是<code>HashSet</code>，实际上，<code>HashSet</code>仅仅是对<code>HashMap</code>的一个简单封装，它的核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 持有一个HashMap:</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;E, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放入HashMap的value:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT) == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o) == PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Set</code>接口并不保证有序，而<code>SortedSet</code>接口则保证元素是有序的：</p><ul><li><code>HashSet</code>是无序的，因为它实现了<code>Set</code>接口，并没有实现<code>SortedSet</code>接口；</li><li><code>TreeSet</code>是有序的，因为它实现了<code>SortedSet</code>接口。</li></ul><p>用一张图表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">       ┌───┐</span><br><span class="line">       │Set│</span><br><span class="line">       └───┘</span><br><span class="line">         ▲</span><br><span class="line">    ┌────┴─────┐</span><br><span class="line">    │          │</span><br><span class="line">┌───────┐ ┌─────────┐</span><br><span class="line">│HashSet│ │SortedSet│</span><br><span class="line">└───────┘ └─────────┘</span><br><span class="line">               ▲</span><br><span class="line">               │</span><br><span class="line">          ┌─────────┐</span><br><span class="line">          │ TreeSet │</span><br><span class="line">          └─────────┘</span><br></pre></td></tr></table></figure><p>我们来看<code>HashSet</code>的输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意输出的顺序既不是添加的顺序，也不是<code>String</code>排序的顺序，在不同版本的JDK中，这个顺序也可能是不同的。</p><p>把<code>HashSet</code>换成<code>TreeSet</code>，在遍历<code>TreeSet</code>时，输出就是有序的，这个顺序是元素的排序顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>TreeSet</code>和使用<code>TreeMap</code>的要求一样，添加的元素必须正确实现<code>Comparable</code>接口，如果没有实现<code>Comparable</code>接口，那么创建<code>TreeSet</code>时必须传入一个<code>Comparator</code>对象。</p><h3 id="练习-4">练习</h3><p>在聊天软件中，发送方发送消息时，遇到网络超时后就会自动重发，因此，接收方可能会收到重复的消息，在显示给用户看的时候，需要首先去重。请练习使用<code>Set</code>去除重复的消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Message&gt; received = List.of(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="number">1</span>, <span class="string">&quot;Hello!&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="number">2</span>, <span class="string">&quot;发工资了吗？&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="number">2</span>, <span class="string">&quot;发工资了吗？&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="number">3</span>, <span class="string">&quot;去哪吃饭？&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="number">3</span>, <span class="string">&quot;去哪吃饭？&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="number">4</span>, <span class="string">&quot;Bye&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        List&lt;Message&gt; displayMessages = process(received);</span><br><span class="line">        <span class="keyword">for</span> (Message message : displayMessages) &#123;</span><br><span class="line">            System.out.println(message.text);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;Message&gt; <span class="title function_">process</span><span class="params">(List&lt;Message&gt; received)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 按sequence去除重复消息</span></span><br><span class="line">        <span class="keyword">return</span> received;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> sequence;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String text;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Message</span><span class="params">(<span class="type">int</span> sequence, String text)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sequence = sequence;</span><br><span class="line">        <span class="built_in">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-9">小结</h3><p><code>Set</code>用于存储不重复的元素集合：</p><ul><li>放入<code>HashSet</code>的元素与作为<code>HashMap</code>的key要求相同；</li><li>放入<code>TreeSet</code>的元素与作为<code>TreeMap</code>的Key要求相同。</li></ul><p>利用<code>Set</code>可以去除重复元素；</p><p>遍历<code>SortedSet</code>按照元素的排序顺序遍历，也可以自定义排序算法。</p><p>队列（<code>Queue</code>）是一种经常使用的集合。<code>Queue</code>实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和<code>List</code>的区别在于，<code>List</code>可以在任意位置添加和删除元素，而<code>Queue</code>只有两个操作：</p><ul><li>把元素添加到队列末尾；</li><li>从队列头部取出元素。</li></ul><p>超市的收银台就是一个队列：</p><p><img src="https://liaoxuefeng.com/books/java/collection/queue/queue.jpg" alt="queue"></p><p>在Java的标准库中，队列接口<code>Queue</code>定义了以下几个方法：</p><ul><li><code>int size()</code>：获取队列长度；</li><li><code>boolean add(E)</code>/<code>boolean offer(E)</code>：添加元素到队尾；</li><li><code>E remove()</code>/<code>E poll()</code>：获取队首元素并从队列中删除；</li><li><code>E element()</code>/<code>E peek()</code>：获取队首元素但并不从队列中删除。</li></ul><p>对于具体的实现类，有的Queue有最大队列长度限制，有的Queue没有。注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的。我们用一个表格总结如下：</p><table><thead><tr><th></th><th>throw Exception</th><th>返回false或null</th></tr></thead><tbody><tr><td>添加元素到队尾</td><td>add(E e)</td><td>boolean offer(E e)</td></tr><tr><td>取队首元素并删除</td><td>E remove()</td><td>E poll()</td></tr><tr><td>取队首元素但不删除</td><td>E element()</td><td>E peek()</td></tr></tbody></table><p>举个栗子，假设我们有一个队列，对它做一个添加操作，如果调用<code>add()</code>方法，当添加失败时（可能超过了队列的容量），它会抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; q = ...</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    q.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IllegalStateException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们调用<code>offer()</code>方法来添加元素，当添加失败时，它不会抛异常，而是返回<code>false</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; q = ...</span><br><span class="line"><span class="keyword">if</span> (q.offer(<span class="string">&quot;Apple&quot;</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要从<code>Queue</code>中取出队首元素时，如果当前<code>Queue</code>是一个空队列，调用<code>remove()</code>方法，它会抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; q = ...</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> q.remove();</span><br><span class="line">    System.out.println(<span class="string">&quot;获取成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IllegalStateException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;获取失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们调用<code>poll()</code>方法来取出队首元素，当获取失败时，它不会抛异常，而是返回<code>null</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; q = ...</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> q.poll();</span><br><span class="line"><span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;获取成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;获取失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，两套方法可以根据需要来选择使用。</p><p>注意：不要把<code>null</code>添加到队列中，否则<code>poll()</code>方法返回<code>null</code>时，很难确定是取到了<code>null</code>元素还是队列为空。</p><p>接下来我们以<code>poll()</code>和<code>peek()</code>为例来说说“获取并删除”与“获取但不删除”的区别。对于<code>Queue</code>来说，每次调用<code>poll()</code>，都会获取队首元素，并且获取到的元素已经从队列中被删除了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">        q.offer(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        q.offer(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        q.offer(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="comment">// 从队列取出元素:</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// apple</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// pear</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// banana</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// null,因为队列是空的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用<code>peek()</code>，因为获取队首元素时，并不会从队列中删除这个元素，所以可以反复获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">        q.offer(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        q.offer(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        q.offer(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="comment">// 队首永远都是apple，因为peek()不会删除它:</span></span><br><span class="line">        System.out.println(q.peek()); <span class="comment">// apple</span></span><br><span class="line">        System.out.println(q.peek()); <span class="comment">// apple</span></span><br><span class="line">        System.out.println(q.peek()); <span class="comment">// apple</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，我们还可以发现，<code>LinkedList</code>即实现了<code>List</code>接口，又实现了<code>Queue</code>接口，但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个List:</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 这是一个Queue:</span></span><br><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>始终按照面向抽象编程的原则编写代码，可以大大提高代码的质量。</p><h3 id="小结-10">小结</h3><p>队列<code>Queue</code>实现了一个先进先出（FIFO）的数据结构：</p><ul><li>通过<code>add()</code>/<code>offer()</code>方法将元素添加到队尾；</li><li>通过<code>remove()</code>/<code>poll()</code>从队首获取元素并删除；</li><li>通过<code>element()</code>/<code>peek()</code>从队首获取元素但不删除。</li></ul><p>要避免把<code>null</code>添加到队列。</p><p>我们知道，<code>Queue</code>是一个先进先出（FIFO）的队列。</p><p>在银行柜台办业务时，我们假设只有一个柜台在办理业务，但是办理业务的人很多，怎么办？</p><p>可以每个人先取一个号，例如：<code>A1</code>、<code>A2</code>、<code>A3</code>……然后，按照号码顺序依次办理，实际上这就是一个<code>Queue</code>。</p><p>如果这时来了一个VIP客户，他的号码是<code>V1</code>，虽然当前排队的是<code>A10</code>、<code>A11</code>、<code>A12</code>……但是柜台下一个呼叫的客户号码却是<code>V1</code>。</p><p>这个时候，我们发现，要实现“VIP插队”的业务，用<code>Queue</code>就不行了，因为<code>Queue</code>会严格按FIFO的原则取出队首元素。我们需要的是优先队列：<code>PriorityQueue</code>。</p><p><code>PriorityQueue</code>和<code>Queue</code>的区别在于，它的出队顺序与元素的优先级有关，对<code>PriorityQueue</code>调用<code>remove()</code>或<code>poll()</code>方法，返回的总是优先级最高的元素。</p><p>要使用<code>PriorityQueue</code>，我们就必须给每个元素定义“优先级”。我们以实际代码为例，先看看<code>PriorityQueue</code>的行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">        q.offer(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        q.offer(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        q.offer(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// apple</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// banana</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// pear</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// null,因为队列为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们放入的顺序是<code>&quot;apple&quot;</code>、<code>&quot;pear&quot;</code>、<code>&quot;banana&quot;</code>，但是取出的顺序却是<code>&quot;apple&quot;</code>、<code>&quot;banana&quot;</code>、<code>&quot;pear&quot;</code>，这是因为从字符串的排序看，<code>&quot;apple&quot;</code>排在最前面，<code>&quot;pear&quot;</code>排在最后面。</p><p>因此，放入<code>PriorityQueue</code>的元素，必须实现<code>Comparable</code>接口，<code>PriorityQueue</code>会根据元素的排序顺序决定出队的优先级。</p><p>如果我们要放入的元素并没有实现<code>Comparable</code>接口怎么办？<code>PriorityQueue</code>允许我们提供一个<code>Comparator</code>对象来判断两个元素的顺序。我们以银行排队业务为例，实现一个<code>PriorityQueue</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Queue&lt;User&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">UserComparator</span>());</span><br><span class="line">        <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;A1&quot;</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;A2&quot;</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Boss&quot;</span>, <span class="string">&quot;V1&quot;</span>));</span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Boss/V1</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Bob/A1</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Alice/A2</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// null,因为队列为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(User u1, User u2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (u1.number.charAt(<span class="number">0</span>) == u2.number.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span></span><br><span class="line">            <span class="keyword">return</span> u1.number.compareTo(u2.number);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u1.number.charAt(<span class="number">0</span>) == <span class="string">&#x27;V&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// u1的号码是V开头,优先级高:</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, String number)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;/&quot;</span> + number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现<code>PriorityQueue</code>的关键在于提供的<code>UserComparator</code>对象，它负责比较两个元素的大小（较小的在前）。<code>UserComparator</code>总是把<code>V</code>开头的号码优先返回，只有在开头相同的时候，才比较号码大小。</p><p>上面的<code>UserComparator</code>的比较逻辑其实还是有问题的，它会把<code>A10</code>排在<code>A2</code>的前面，请尝试修复该错误。</p><h3 id="小结-11">小结</h3><p><code>PriorityQueue</code>实现了一个优先队列：从队首获取元素时，总是获取优先级最高的元素；</p><p><code>PriorityQueue</code>默认按元素比较的顺序排序（必须实现<code>Comparable</code>接口），也可以通过<code>Comparator</code>自定义排序算法（元素就不必实现<code>Comparable</code>接口）。</p><h2 id="使用Deque">使用Deque</h2><p>我们知道，<code>Queue</code>是队列，只能一头进，另一头出。</p><p>如果把条件放松一下，允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名<code>Deque</code>。</p><p>Java集合提供了接口<code>Deque</code>来实现一个双端队列，它的功能是：</p><ul><li>既可以添加到队尾，也可以添加到队首；</li><li>既可以从队首获取，又可以从队尾获取。</li></ul><p>我们来比较一下<code>Queue</code>和<code>Deque</code>出队和入队的方法：</p><table><thead><tr><th></th><th>Queue</th><th>Deque</th></tr></thead><tbody><tr><td>添加元素到队尾</td><td>add(E e) / offer(E e)</td><td>addLast(E e) / offerLast(E e)</td></tr><tr><td>取队首元素并删除</td><td>E remove() / E poll()</td><td>E removeFirst() / E pollFirst()</td></tr><tr><td>取队首元素但不删除</td><td>E element() / E peek()</td><td>E getFirst() / E peekFirst()</td></tr><tr><td>添加元素到队首</td><td>无</td><td>addFirst(E e) / offerFirst(E e)</td></tr><tr><td>取队尾元素并删除</td><td>无</td><td>E removeLast() / E pollLast()</td></tr><tr><td>取队尾元素但不删除</td><td>无</td><td>E getLast() / E peekLast()</td></tr></tbody></table><p>对于添加元素到队尾的操作，<code>Queue</code>提供了<code>add()</code>/<code>offer()</code>方法，而<code>Deque</code>提供了<code>addLast()</code>/<code>offerLast()</code>方法。添加元素到队首、取队尾元素的操作在<code>Queue</code>中不存在，在<code>Deque</code>中由<code>addFirst()</code>/<code>removeLast()</code>等方法提供。</p><p>注意到<code>Deque</code>接口实际上扩展自<code>Queue</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Deque</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Queue</span>&lt;E&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，<code>Queue</code>提供的<code>add()</code>/<code>offer()</code>方法在<code>Deque</code>中也可以使用，但是，使用<code>Deque</code>，最好不要调用<code>offer()</code>，而是调用<code>offerLast()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Deque&lt;String&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        deque.offerLast(<span class="string">&quot;A&quot;</span>); <span class="comment">// A</span></span><br><span class="line">        deque.offerLast(<span class="string">&quot;B&quot;</span>); <span class="comment">// A &lt;- B</span></span><br><span class="line">        deque.offerFirst(<span class="string">&quot;C&quot;</span>); <span class="comment">// C &lt;- A &lt;- B</span></span><br><span class="line">        System.out.println(deque.pollFirst()); <span class="comment">// C, 剩下A &lt;- B</span></span><br><span class="line">        System.out.println(deque.pollLast()); <span class="comment">// B, 剩下A</span></span><br><span class="line">        System.out.println(deque.pollFirst()); <span class="comment">// A</span></span><br><span class="line">        System.out.println(deque.pollFirst()); <span class="comment">// null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接写<code>deque.offer()</code>，我们就需要思考，<code>offer()</code>实际上是<code>offerLast()</code>，我们明确地写上<code>offerLast()</code>，不需要思考就能一眼看出这是添加到队尾。</p><p>因此，使用<code>Deque</code>，推荐总是明确调用<code>offerLast()</code>/<code>offerFirst()</code>或者<code>pollFirst()</code>/<code>pollLast()</code>方法。</p><p><code>Deque</code>是一个接口，它的实现类有<code>ArrayDeque</code>和<code>LinkedList</code>。</p><p>我们发现<code>LinkedList</code>真是一个全能选手，它即是<code>List</code>，又是<code>Queue</code>，还是<code>Deque</code>。但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐的写法:</span></span><br><span class="line">LinkedList&lt;String&gt; d1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">d1.offerLast(<span class="string">&quot;z&quot;</span>);</span><br><span class="line"><span class="comment">// 推荐的写法：</span></span><br><span class="line">Deque&lt;String&gt; d2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">d2.offerLast(<span class="string">&quot;z&quot;</span>);</span><br></pre></td></tr></table></figure><p>可见面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类。</p><h3 id="小结-12">小结</h3><p><code>Deque</code>实现了一个双端队列（Double Ended Queue），它可以：</p><ul><li>将元素添加到队尾或队首：<code>addLast()</code>/<code>offerLast()</code>/<code>addFirst()</code>/<code>offerFirst()</code>；</li><li>从队首／队尾获取元素并删除：<code>removeFirst()</code>/<code>pollFirst()</code>/<code>removeLast()</code>/<code>pollLast()</code>；</li><li>从队首／队尾获取元素但不删除：<code>getFirst()</code>/<code>peekFirst()</code>/<code>getLast()</code>/<code>peekLast()</code>；</li><li>总是调用<code>xxxFirst()</code>/<code>xxxLast()</code>以便与<code>Queue</code>的方法区分开；</li><li>避免把<code>null</code>添加到队列。</li></ul><hr><hr><p>栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。</p><p>什么是LIFO呢？我们先回顾一下<code>Queue</code>的特点FIFO：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">           ────────────────────────</span><br><span class="line">  (\(\       (\(\    (\(\    (\(\       (\(\</span><br><span class="line"> (=&#x27;.&#x27;) ──▶ (=&#x27;.&#x27;)  (=&#x27;.&#x27;)  (=&#x27;.&#x27;) ──▶ (=&#x27;.&#x27;)</span><br><span class="line">O(_&quot;)&quot;)    O(_&quot;)&quot;) O(_&quot;)&quot;) O(_&quot;)&quot;)    O(_&quot;)&quot;)</span><br><span class="line">           ────────────────────────</span><br></pre></td></tr></table></figure><p>所谓FIFO，是最先进队列的元素一定最早出队列，而LIFO是最后进<code>Stack</code>的元素一定最早出<code>Stack</code>。如何做到这一点呢？只需要把队列的一端封死：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">            ───────────────────────────────┐</span><br><span class="line">  (\(\        (\(\    (\(\    (\(\    (\(\ │</span><br><span class="line"> (=&#x27;.&#x27;) ◀──▶ (=&#x27;.&#x27;)  (=&#x27;.&#x27;)  (=&#x27;.&#x27;)  (=&#x27;.&#x27;)│</span><br><span class="line">O(_&quot;)&quot;)     O(_&quot;)&quot;) O(_&quot;)&quot;) O(_&quot;)&quot;) O(_&quot;)&quot;)│</span><br><span class="line">            ───────────────────────────────┘</span><br></pre></td></tr></table></figure><p>因此，<code>Stack</code>是这样一种数据结构：只能不断地往<code>Stack</code>中压入（push）元素，最后进去的必须最早弹出（pop）来：</p><p><img src="https://liaoxuefeng.com/books/java/collection/stack/stack.jpg" alt="donuts-stack"></p><p><code>Stack</code>只有入栈和出栈的操作：</p><ul><li>把元素压栈：<code>push(E)</code>；</li><li>把栈顶的元素“弹出”：<code>pop()</code>；</li><li>取栈顶元素但不弹出：<code>peek()</code>。</li></ul><p>在Java中，我们用<code>Deque</code>可以实现<code>Stack</code>的功能：</p><ul><li>把元素压栈：<code>push(E)</code>/<code>addFirst(E)</code>；</li><li>把栈顶的元素“弹出”：<code>pop()</code>/<code>removeFirst()</code>；</li><li>取栈顶元素但不弹出：<code>peek()</code>/<code>peekFirst()</code>。</li></ul><p>为什么Java的集合类没有单独的<code>Stack</code>接口呢？因为有个遗留类名字就叫<code>Stack</code>，出于兼容性考虑，所以没办法创建<code>Stack</code>接口，只能用<code>Deque</code>接口来“模拟”一个<code>Stack</code>了。</p><p>当我们把<code>Deque</code>作为<code>Stack</code>使用时，注意只调用<code>push()</code>/<code>pop()</code>/<code>peek()</code>方法，不要调用<code>addFirst()</code>/<code>removeFirst()</code>/<code>peekFirst()</code>方法，这样代码更加清晰。</p><h3 id="Stack的作用">Stack的作用</h3><p>Stack在计算机中使用非常广泛，JVM在处理Java方法调用的时候就会通过栈这种数据结构维护方法调用的层次。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    foo(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">foo</span><span class="params">(x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;F-&quot;</span> + bar(x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM会创建方法调用栈，每调用一个方法时，先将参数压栈，然后执行对应的方法；当方法返回时，返回值压栈，调用方法通过出栈操作获得方法返回值。</p><p>因为方法调用栈有容量限制，嵌套调用过多会造成栈溢出，即引发<code>StackOverflowError</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试无限递归调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        increase(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">increase</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> increase(x) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看一个<code>Stack</code>的用途：对整数进行进制的转换就可以利用栈。</p><p>例如，我们要把一个<code>int</code>整数<code>12500</code>转换为十六进制表示的字符串，如何实现这个功能？</p><p>首先我们准备一个空栈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">└───┘</span><br></pre></td></tr></table></figure><p>然后计算12500÷16=781…4，余数是<code>4</code>，把余数<code>4</code>压栈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">│ 4 │</span><br><span class="line">└───┘</span><br></pre></td></tr></table></figure><p>然后计算781÷16=48…13，余数是<code>13</code>，<code>13</code>的十六进制用字母<code>D</code>表示，把余数<code>D</code>压栈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">│ D │</span><br><span class="line">│ 4 │</span><br><span class="line">└───┘</span><br></pre></td></tr></table></figure><p>然后计算48÷16=3…0，余数是<code>0</code>，把余数<code>0</code>压栈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">│ 0 │</span><br><span class="line">│ D │</span><br><span class="line">│ 4 │</span><br><span class="line">└───┘</span><br></pre></td></tr></table></figure><p>最后计算3÷16=0…3，余数是<code>3</code>，把余数<code>3</code>压栈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">│   │</span><br><span class="line">│ 3 │</span><br><span class="line">│ 0 │</span><br><span class="line">│ D │</span><br><span class="line">│ 4 │</span><br><span class="line">└───┘</span><br></pre></td></tr></table></figure><p>当商是<code>0</code>的时候，计算结束，我们把栈的所有元素依次弹出，组成字符串<code>30D4</code>，这就是十进制整数<code>12500</code>的十六进制表示的字符串。</p><h3 id="计算中缀表达式">计算中缀表达式</h3><p>在编写程序的时候，我们使用的带括号的数学表达式实际上是中缀表达式，即运算符在中间，例如：<code>1 + 2 * (9 - 5)</code>。</p><p>但是计算机执行表达式的时候，它并不能直接计算中缀表达式，而是通过编译器把中缀表达式转换为后缀表达式，例如：<code>1 2 9 5 - * +</code>。</p><p>这个编译过程就会用到栈。我们先跳过编译这一步（涉及运算优先级，代码比较复杂），看看如何通过栈计算后缀表达式。</p><p>计算后缀表达式不考虑优先级，直接从左到右依次计算，因此计算起来简单。首先准备一个空的栈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">└───┘</span><br></pre></td></tr></table></figure><p>然后我们依次扫描后缀表达式<code>1 2 9 5 - * +</code>，遇到数字<code>1</code>，就直接扔到栈里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">│ 1 │</span><br><span class="line">└───┘</span><br></pre></td></tr></table></figure><p>紧接着，遇到数字<code>2</code>，<code>9</code>，<code>5</code>，也扔到栈里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">│   │</span><br><span class="line">│ 5 │</span><br><span class="line">│ 9 │</span><br><span class="line">│ 2 │</span><br><span class="line">│ 1 │</span><br><span class="line">└───┘</span><br></pre></td></tr></table></figure><p>接下来遇到减号时，弹出栈顶的两个元素，并计算<code>9-5=4</code>，把结果<code>4</code>压栈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">│ 4 │</span><br><span class="line">│ 2 │</span><br><span class="line">│ 1 │</span><br><span class="line">└───┘</span><br></pre></td></tr></table></figure><p>接下来遇到<code>*</code>号时，弹出栈顶的两个元素，并计算<code>2*4=8</code>，把结果<code>8</code>压栈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">│ 8 │</span><br><span class="line">│ 1 │</span><br><span class="line">└───┘</span><br></pre></td></tr></table></figure><p>接下来遇到<code>+</code>号时，弹出栈顶的两个元素，并计算<code>1+8=9</code>，把结果<code>9</code>压栈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">│   │</span><br><span class="line">│ 9 │</span><br><span class="line">└───┘</span><br></pre></td></tr></table></figure><p>扫描结束后，没有更多的计算了，弹出栈的唯一一个元素，得到计算结果<code>9</code>。</p><h3 id="练习-5">练习</h3><p>请利用Stack把一个给定的整数转换为十六进制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转十六进制</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">hex</span> <span class="operator">=</span> toHex(<span class="number">12500</span>);</span><br><span class="line">        <span class="keyword">if</span> (hex.equalsIgnoreCase(<span class="string">&quot;30D4&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;测试通过&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;测试失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">toHex</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进阶练习：</p><p>请利用Stack把字符串中缀表达式编译为后缀表达式，然后再利用栈执行后缀表达式获得计算结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高难度练习，慎重选择！</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="string">&quot;1 + 2 * (9 - 5)&quot;</span>;</span><br><span class="line">        <span class="type">SuffixExpression</span> <span class="variable">se</span> <span class="operator">=</span> compile(exp);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> se.execute();</span><br><span class="line">        System.out.println(exp + <span class="string">&quot; = &quot;</span> + result + <span class="string">&quot; &quot;</span> + (result == <span class="number">1</span> + <span class="number">2</span> * (<span class="number">9</span> - <span class="number">5</span>) ? <span class="string">&quot;✓&quot;</span> : <span class="string">&quot;✗&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> SuffixExpression <span class="title function_">compile</span><span class="params">(String exp)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SuffixExpression</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuffixExpression</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进阶练习2：</p><p>请把带变量的中缀表达式编译为后缀表达式，执行后缀表达式时，传入变量的值并获得计算结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超高难度练习，慎重选择！</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="string">&quot;x + 2 * (y - 5)&quot;</span>;</span><br><span class="line">        <span class="type">SuffixExpression</span> <span class="variable">se</span> <span class="operator">=</span> compile(exp);</span><br><span class="line">        Map&lt;String, Integer&gt; env = Map.of(<span class="string">&quot;x&quot;</span>, <span class="number">1</span>, <span class="string">&quot;y&quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> se.execute(env);</span><br><span class="line">        System.out.println(exp + <span class="string">&quot; = &quot;</span> + result + <span class="string">&quot; &quot;</span> + (result == <span class="number">1</span> + <span class="number">2</span> * (<span class="number">9</span> - <span class="number">5</span>) ? <span class="string">&quot;✓&quot;</span> : <span class="string">&quot;✗&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> SuffixExpression <span class="title function_">compile</span><span class="params">(String exp)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SuffixExpression</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuffixExpression</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">execute</span><span class="params">(Map&lt;String, Integer&gt; env)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/collection/stack/coll-stack.zip">下载练习</a></p><h3 id="小结-13">小结</h3><p>栈（Stack）是一种后进先出（LIFO）的数据结构，操作栈的元素的方法有：</p><ul><li>把元素压栈：<code>push(E)</code>；</li><li>把栈顶的元素“弹出”：<code>pop(E)</code>；</li><li>取栈顶元素但不弹出：<code>peek(E)</code>。</li></ul><p>在Java中，我们用<code>Deque</code>可以实现<code>Stack</code>的功能，注意只调用<code>push()</code>/<code>pop()</code>/<code>peek()</code>方法，避免调用<code>Deque</code>的其他方法；</p><p>不要使用遗留类<code>Stack</code>。</p><p>Java的集合类都可以使用<code>for each</code>循环，<code>List</code>、<code>Set</code>和<code>Queue</code>会迭代每个元素，<code>Map</code>会迭代每个key。以<code>List</code>为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，Java编译器并不知道如何遍历<code>List</code>。上述代码能够编译通过，只是因为编译器把<code>for each</code>循环通过<code>Iterator</code>改写为了普通的<code>for</code>循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">     System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把这种通过<code>Iterator</code>对象遍历集合的模式称为迭代器。</p><p>使用迭代器的好处在于，调用方总是以统一的方式遍历各种集合类型，而不必关心它们内部的存储结构。</p><p>例如，我们虽然知道<code>ArrayList</code>在内部是以数组形式存储元素，并且，它还提供了<code>get(int)</code>方法。虽然我们可以用<code>for</code>循环遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样一来，调用方就必须知道集合的内部存储结构。并且，如果把<code>ArrayList</code>换成<code>LinkedList</code>，<code>get(int)</code>方法耗时会随着index的增加而增加。如果把<code>ArrayList</code>换成<code>Set</code>，上述代码就无法编译，因为<code>Set</code>内部没有索引。</p><p>用<code>Iterator</code>遍历就没有上述问题，因为<code>Iterator</code>对象是集合对象自己在内部创建的，它自己知道如何高效遍历内部的数据集合，调用方则获得了统一的代码，编译器才能把标准的<code>for each</code>循环自动转换为<code>Iterator</code>遍历。</p><p>如果我们自己编写了一个集合类，想要使用<code>for each</code>循环，只需满足以下条件：</p><ul><li>集合类实现<code>Iterable</code>接口，该接口要求返回一个<code>Iterator</code>对象；</li><li>用<code>Iterator</code>对象迭代集合内部数据。</li></ul><p>这里的关键在于，集合类通过调用<code>iterator()</code>方法，返回一个<code>Iterator</code>对象，这个对象必须自己知道如何遍历该集合。</p><p>一个简单的<code>Iterator</code>示例如下，它总是以倒序遍历集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iterator</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ReverseList&lt;String&gt; rlist = <span class="keyword">new</span> <span class="title class_">ReverseList</span>&lt;&gt;();</span><br><span class="line">        rlist.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        rlist.add(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">        rlist.add(<span class="string">&quot;Pear&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : rlist) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReverseList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReverseIterator</span>(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ReverseIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">        ReverseIterator(<span class="type">int</span> index) &#123;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">return</span> ReverseList.<span class="built_in">this</span>.list.get(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然<code>ReverseList</code>和<code>ReverseIterator</code>的实现类稍微比较复杂，但是，注意到这是底层集合库，只需编写一次。而调用方则完全按<code>for each</code>循环编写代码，根本不需要知道集合内部的存储逻辑和遍历逻辑。</p><p>在编写<code>Iterator</code>的时候，我们通常可以用一个内部类来实现<code>Iterator</code>接口，这个内部类可以直接访问对应的外部类的所有字段和方法。例如，上述代码中，内部类<code>ReverseIterator</code>可以用<code>ReverseList.this</code>获得当前外部类的<code>this</code>引用，然后，通过这个<code>this</code>引用就可以访问<code>ReverseList</code>的所有字段和方法。</p><h3 id="小结-14">小结</h3><p><code>Iterator</code>是一种抽象的数据访问模型。使用<code>Iterator</code>模式进行迭代的好处有：</p><ul><li>对任何集合都采用同一种访问模型；</li><li>调用者对集合内部结构一无所知；</li><li>集合类返回的<code>Iterator</code>对象知道如何迭代。</li></ul><p>Java提供了标准的迭代器模型，即集合类实现<code>java.util.Iterable</code>接口，返回<code>java.util.Iterator</code>实例。</p><p><code>Collections</code>是JDK提供的工具类，同样位于<code>java.util</code>包中。它提供了一系列静态方法，能更方便地操作各种集合。</p><p>注意</p><p>Collections结尾多了一个s，不是Collection！</p><p>我们一般看方法名和参数就可以确认<code>Collections</code>提供的该方法的功能。例如，对于以下静态方法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static boolean addAll(Collection&lt;? super T&gt; c, T... elements) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p><code>addAll()</code>方法可以给一个<code>Collection</code>类型的集合添加若干元素。因为方法签名是<code>Collection</code>，所以我们可以传入<code>List</code>，<code>Set</code>等各种集合类型。</p><h3 id="创建空集合">创建空集合</h3><p>对于旧版的JDK，可以使用<code>Collections</code>提供的一系列方法来创建空集合：</p><ul><li>创建空List：<code>List&lt;T&gt; emptyList()</code></li><li>创建空Map：<code>Map&lt;K, V&gt; emptyMap()</code></li><li>创建空Set：<code>Set&lt;T&gt; emptySet()</code></li></ul><p>要注意到返回的空集合是不可变集合，无法向其中添加或删除元素。</p><p>新版的JDK≥9可以直接使用<code>List.of()</code>、<code>Map.of()</code>、<code>Set.of()</code>来创建空集合。</p><h3 id="创建单元素集合">创建单元素集合</h3><p>对于旧版的JDK，<code>Collections</code>提供了一系列方法来创建一个单元素集合：</p><ul><li>创建一个元素的List：<code>List&lt;T&gt; singletonList(T o)</code></li><li>创建一个元素的Map：<code>Map&lt;K, V&gt; singletonMap(K key, V value)</code></li><li>创建一个元素的Set：<code>Set&lt;T&gt; singleton(T o)</code></li></ul><p>要注意到返回的单元素集合也是不可变集合，无法向其中添加或删除元素。</p><p>新版的JDK≥9可以直接使用<code>List.of(T...)</code>、<code>Map.of(T...)</code>、<code>Set.of(T...)</code>来创建任意个元素的集合。</p><h3 id="排序">排序</h3><p><code>Collections</code>可以对<code>List</code>进行排序。因为排序会直接修改<code>List</code>元素的位置，因此必须传入可变<code>List</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">        <span class="comment">// 排序前:</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="comment">// 排序后:</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洗牌">洗牌</h3><p><code>Collections</code>提供了洗牌算法，即传入一个有序的<code>List</code>，可以随机打乱<code>List</code>内部元素的顺序，效果相当于让计算机洗牌：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 洗牌前:</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// 洗牌:</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        <span class="comment">// 洗牌后:</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不可变集合">不可变集合</h3><p><code>Collections</code>还提供了一组方法把可变集合封装成不可变集合：</p><ul><li>封装成不可变List：<code>List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code></li><li>封装成不可变Set：<code>Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)</code></li><li>封装成不可变Map：<code>Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></li></ul><p>这种封装实际上是通过创建一个代理对象，拦截掉所有修改方法实现的。我们来看看效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; mutable = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        mutable.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        mutable.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        <span class="comment">// 变为不可变集合:</span></span><br><span class="line">        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class="line">        immutable.add(<span class="string">&quot;orange&quot;</span>); <span class="comment">// UnsupportedOperationException!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，继续对原始的可变<code>List</code>进行增删是可以的，并且，会直接影响到封装后的“不可变”<code>List</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; mutable = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        mutable.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        mutable.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        <span class="comment">// 变为不可变集合:</span></span><br><span class="line">        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class="line">        mutable.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">        System.out.println(immutable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，如果我们希望把一个可变<code>List</code>封装成不可变<code>List</code>，那么，返回不可变<code>List</code>后，最好立刻扔掉可变<code>List</code>的引用，这样可以保证后续操作不会意外改变原始对象，从而造成“不可变”<code>List</code>变化了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; mutable = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        mutable.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        mutable.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        <span class="comment">// 变为不可变集合:</span></span><br><span class="line">        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class="line">        <span class="comment">// 立刻扔掉mutable的引用:</span></span><br><span class="line">        mutable = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(immutable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全集合">线程安全集合</h3><p><code>Collections</code>还提供了一组方法，可以把线程不安全的集合变为线程安全的集合：</p><ul><li>变为线程安全的List：<code>List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code></li><li>变为线程安全的Set：<code>Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)</code></li><li>变为线程安全的Map：<code>Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code></li></ul><p>多线程的概念我们会在后面讲。因为从Java 5开始，引入了更高效的并发集合类，所以上述这几个同步方法已经没有什么用了。</p><h3 id="小结-15">小结</h3><p><code>Collections</code>类提供了一组工具方法来方便使用集合类：</p><ul><li>创建空集合；</li><li>创建单元素集合；</li><li>创建不可变集合；</li><li>排序／洗牌等操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-泛型</title>
      <link href="/2025/05/24/java/JAVA-%E6%B3%9B%E5%9E%8B/"/>
      <url>/2025/05/24/java/JAVA-%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>在讲解什么是泛型之前，我们先观察Java标准库提供的<code>ArrayList</code>，它可以看作“可变长度”的数组，因为用起来比数组更方便。</p><p>实际上<code>ArrayList</code>内部就是一个<code>Object[]</code>数组，配合存储一个当前分配的长度，就可以充当“可变数组”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object e)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用上述<code>ArrayList</code>存储<code>String</code>类型，会有这么几个缺点：</p><ul><li>需要强制转型；</li><li>不方便，易出错。</li></ul><p>例如，代码必须这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">// 获取到Object，必须强制转型为String:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> (String) list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>很容易出现ClassCastException，因为容易“误转型”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>));</span><br><span class="line"><span class="comment">// ERROR: ClassCastException:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">second</span> <span class="operator">=</span> (String) list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>要解决上述问题，我们可以为<code>String</code>单独编写一种<code>ArrayList</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringArrayList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String e)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，存入的必须是<code>String</code>，取出的也一定是<code>String</code>，不需要强制转型，因为编译器会强制检查放入的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 编译错误: 不允许放入非String类型:</span></span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>));</span><br></pre></td></tr></table></figure><p>问题暂时解决。</p><p>然而，新的问题是，如果要存储<code>Integer</code>，还需要为<code>Integer</code>单独编写一种<code>ArrayList</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerArrayList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Integer e)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，还需要为其他所有class单独编写一种<code>ArrayList</code>：</p><ul><li>LongArrayList</li><li>DoubleArrayList</li><li>PersonArrayList</li><li>…</li></ul><p>这是不可能的，JDK的class就有上千个，而且它还不知道其他人编写的class。</p><p>为了解决新的问题，我们必须把<code>ArrayList</code>变成一种模板：<code>ArrayList&lt;T&gt;</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T e)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>T</code>可以是任何class。这样一来，我们就实现了：编写一次模版，可以创建任意类型的<code>ArrayList</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建可以存储String的ArrayList:</span></span><br><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">// 创建可以存储Float的ArrayList:</span></span><br><span class="line">ArrayList&lt;Float&gt; floatList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Float&gt;();</span><br><span class="line"><span class="comment">// 创建可以存储Person的ArrayList:</span></span><br><span class="line">ArrayList&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br></pre></td></tr></table></figure><p>因此，泛型就是定义一种模板，例如<code>ArrayList&lt;T&gt;</code>，然后在代码中为用到的类创建对应的<code>ArrayList&lt;类型&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>由编译器针对类型作检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strList.add(<span class="string">&quot;hello&quot;</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> strList.get(<span class="number">0</span>); <span class="comment">// OK</span></span><br><span class="line">strList.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>)); <span class="comment">// compile error!</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> strList.get(<span class="number">0</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>这样一来，既实现了编写一次，万能匹配，又通过编译器保证了类型安全：这就是泛型。</p><h3 id="向上转型">向上转型</h3><p>在Java标准库中的<code>ArrayList&lt;T&gt;</code>实现了<code>List&lt;T&gt;</code>接口，它可以向上转型为<code>List&lt;T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;T&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>即类型<code>ArrayList&lt;T&gt;</code>可以向上转型为<code>List&lt;T&gt;</code>。</p><p>要<em>特别注意</em>：不能把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>ArrayList&lt;Number&gt;</code>或<code>List&lt;Number&gt;</code>。</p><p>这是为什么呢？假设<code>ArrayList&lt;Integer&gt;</code>可以向上转型为<code>ArrayList&lt;Number&gt;</code>，观察一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建ArrayList&lt;Integer&gt;类型：</span></span><br><span class="line">ArrayList&lt;Integer&gt; integerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// 添加一个Integer：</span></span><br><span class="line">integerList.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>));</span><br><span class="line"><span class="comment">// “向上转型”为ArrayList&lt;Number&gt;：</span></span><br><span class="line">ArrayList&lt;Number&gt; numberList = integerList;</span><br><span class="line"><span class="comment">// 添加一个Float，因为Float也是Number：</span></span><br><span class="line">numberList.add(<span class="keyword">new</span> <span class="title class_">Float</span>(<span class="number">12.34</span>));</span><br><span class="line"><span class="comment">// 从ArrayList&lt;Integer&gt;获取索引为1的元素（即添加的Float）：</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> integerList.get(<span class="number">1</span>); <span class="comment">// ClassCastException!</span></span><br></pre></td></tr></table></figure><p>我们把一个<code>ArrayList&lt;Integer&gt;</code>转型为<code>ArrayList&lt;Number&gt;</code>类型后，这个<code>ArrayList&lt;Number&gt;</code>就可以接受<code>Float</code>类型，因为<code>Float</code>是<code>Number</code>的子类。但是，<code>ArrayList&lt;Number&gt;</code>实际上和<code>ArrayList&lt;Integer&gt;</code>是同一个对象，也就是<code>ArrayList&lt;Integer&gt;</code>类型，它不可能接受<code>Float</code>类型， 所以在获取<code>Integer</code>的时候将产生<code>ClassCastException</code>。</p><p>实际上，编译器为了避免这种错误，根本就不允许把<code>ArrayList&lt;Integer&gt;</code>转型为<code>ArrayList&lt;Number&gt;</code>。</p><p>特别注意</p><p><code>ArrayList&lt;Integer&gt;</code>和<code>ArrayList&lt;Number&gt;</code>两者完全没有继承关系。</p><p>用一个图来表示泛型的继承关系，就是<code>T</code>不变时，可以向上转型，<code>T</code>本身不能向上转型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  List&lt;Integer&gt;     ArrayList&lt;Number&gt;</span><br><span class="line">    ▲                            ▲</span><br><span class="line">    │                            │</span><br><span class="line">    │                            X</span><br><span class="line">    │                            │</span><br><span class="line">ArrayList&lt;Integer&gt;  ArrayList&lt;Integer&gt;</span><br></pre></td></tr></table></figure><h3 id="小结">小结</h3><p>泛型就是编写模板代码来适应任意类型；</p><p>泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查；</p><p>注意泛型的继承关系：可以把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>List&lt;Integer&gt;</code>（<code>T</code>不能变！），但不能把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>ArrayList&lt;Number&gt;</code>（<code>T</code>不能变成父类）。</p><p>使用<code>ArrayList</code>时，如果不定义泛型类型时，泛型类型实际上就是<code>Object</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器警告:</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> (String) list.get(<span class="number">0</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">second</span> <span class="operator">=</span> (String) list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>此时，只能把<code>&lt;T&gt;</code>当作<code>Object</code>使用，没有发挥泛型的优势。</p><p>当我们定义泛型类型<code>&lt;String&gt;</code>后，<code>List&lt;T&gt;</code>的泛型接口变为强类型<code>List&lt;String&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无编译器警告:</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="comment">// 无强制转型:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">second</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>当我们定义泛型类型<code>&lt;Number&gt;</code>后，<code>List&lt;T&gt;</code>的泛型接口变为强类型<code>List&lt;Number&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">12.34</span>));</span><br><span class="line"><span class="type">Number</span> <span class="variable">first</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line"><span class="type">Number</span> <span class="variable">second</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>编译器如果能自动推断出泛型类型，就可以省略后面的泛型类型。例如，对于下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br></pre></td></tr></table></figure><p>编译器看到泛型类型<code>List&lt;Number&gt;</code>就可以自动推断出后面的<code>ArrayList&lt;T&gt;</code>的泛型类型必须是<code>ArrayList&lt;Number&gt;</code>，因此，可以把代码简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span></span><br><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="泛型接口">泛型接口</h3><p>除了<code>ArrayList&lt;T&gt;</code>使用了泛型，还可以在接口中使用泛型。例如，<code>Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code>Comparable&lt;T&gt;</code>这个泛型接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回负数: 当前实例比参数o小</span></span><br><span class="line"><span class="comment">     * 返回0: 当前实例与参数o相等</span></span><br><span class="line"><span class="comment">     * 返回正数: 当前实例比参数o大</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以直接对<code>String</code>数组进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] ss = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Pear&quot;</span> &#125;;</span><br><span class="line">        Arrays.sort(ss);</span><br><span class="line">        System.out.println(Arrays.toString(ss));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为<code>String</code>本身已经实现了<code>Comparable&lt;String&gt;</code>接口。如果换成我们自定义的<code>Person</code>类型试试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Person[] ps = <span class="keyword">new</span> <span class="title class_">Person</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">61</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">88</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">75</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(ps);</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    Person(String name, <span class="type">int</span> score) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="string">&quot;,&quot;</span> + <span class="built_in">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，我们会得到<code>ClassCastException</code>，即无法将<code>Person</code>转型为<code>Comparable</code>。我们修改代码，让<code>Person</code>实现<code>Comparable&lt;T&gt;</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Person[] ps = <span class="keyword">new</span> <span class="title class_">Person</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">61</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">88</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">75</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(ps);</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt; &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    Person(String name, <span class="type">int</span> score) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="string">&quot;,&quot;</span> + <span class="built_in">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，可以正确实现按<code>name</code>进行排序。</p><p>也可以修改比较逻辑，例如，按<code>score</code>从高到低排序。请自行修改测试。</p><h3 id="小结-2">小结</h3><p>使用泛型时，把泛型参数<code>&lt;T&gt;</code>替换为需要的class类型，例如：<code>ArrayList&lt;String&gt;</code>，<code>ArrayList&lt;Number&gt;</code>等；</p><p>可以省略编译器能自动推断出的类型，例如：<code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>；</p><p>不指定泛型参数类型时，编译器会给出警告，且只能将<code>&lt;T&gt;</code>视为<code>Object</code>类型；</p><p>可以在接口中定义泛型类型，实现此接口的类必须实现正确的泛型类型。</p><p>编写泛型类比普通类要复杂。通常来说，泛型类一般用在集合类中，例如<code>ArrayList&lt;T&gt;</code>，我们很少需要编写泛型类。</p><p>如果我们确实需要编写一个泛型类，那么，应该如何编写它？</p><p>可以按照以下步骤来编写一个泛型类。</p><p>首先，按照某种类型，例如：<code>String</code>，来编写类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String first;</span><br><span class="line">    <span class="keyword">private</span> String last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(String first, String last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，标记所有的特定类型，这里是<code>String</code>，把特定类型<code>String</code>替换为<code>T</code>，并申明<code>&lt;T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熟练后即可直接从<code>T</code>开始编写。</p><h3 id="静态方法">静态方法</h3><p>编写泛型类时，要特别注意，泛型类型<code>&lt;T&gt;</code>不能用于静态方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对静态方法使用&lt;T&gt;:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Pair&lt;T&gt; <span class="title function_">create</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;T&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会导致编译错误，我们无法在静态方法<code>create()</code>的方法参数和返回类型上使用泛型类型<code>T</code>。</p><p>有些同学在网上搜索发现，可以在<code>static</code>修饰符后面加一个<code>&lt;T&gt;</code>，编译就能通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以编译通过:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Pair&lt;T&gt; <span class="title function_">create</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;T&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但实际上，这个<code>&lt;T&gt;</code>和<code>Pair&lt;T&gt;</code>类型的<code>&lt;T&gt;</code>已经没有任何关系了。</p><p>对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的<code>create()</code>静态方法，我们应该把它改为另一种泛型类型，例如，<code>&lt;K&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态泛型方法应该使用其他类型区分:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K&gt; Pair&lt;K&gt; <span class="title function_">create</span><span class="params">(K first, K last)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;K&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样才能清楚地将静态方法的泛型类型和实例类型的泛型类型区分开。</p><h3 id="多个泛型类型">多个泛型类型</h3><p>泛型还可以定义多种类型。例如，我们希望<code>Pair</code>不总是存储两个类型一样的对象，就可以使用类型<code>&lt;T, K&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T, K&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> K last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, K last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getLast</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，需要指出两种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String, Integer&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;test&quot;</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>Java标准库的<code>Map&lt;K, V&gt;</code>就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。</p><h3 id="小结-3">小结</h3><p>编写泛型时，需要定义泛型类型<code>&lt;T&gt;</code>；</p><p>静态方法不能引用泛型类型<code>&lt;T&gt;</code>，必须定义其他类型（例如<code>&lt;K&gt;</code>）来实现静态泛型方法；</p><p>泛型可以同时定义多种类型，例如<code>Map&lt;K, V&gt;</code>。</p><p>泛型是一种类似”模板代码“的技术，不同语言的泛型实现方式不一定相同。</p><p>Java语言的泛型实现方式是擦拭法（Type Erasure）。</p><p>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。</p><p>例如，我们编写了一个泛型类<code>Pair&lt;T&gt;</code>，这是编译器看到的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而虚拟机根本不知道泛型。这是虚拟机执行的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(Object first, Object last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，Java使用擦拭法实现泛型，导致了：</p><ul><li>编译器把类型<code>&lt;T&gt;</code>视为<code>Object</code>；</li><li>编译器根据<code>&lt;T&gt;</code>实现安全的强制转型。</li></ul><p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br></pre></td></tr></table></figure><p>而虚拟机执行的代码并没有泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pair</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> (String) p.getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> (String) p.getLast();</span><br></pre></td></tr></table></figure><p>所以，Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型<code>T</code>视为<code>Object</code>处理，但是，在需要转型的时候，编译器会根据<code>T</code>的类型自动为我们实行安全地强制转型。</p><p>了解了Java泛型的实现方式——擦拭法，我们就知道了Java泛型的局限：</p><p>局限一：<code>&lt;T&gt;</code>不能是基本类型，例如<code>int</code>，因为实际类型是<code>Object</code>，<code>Object</code>类型无法持有基本类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;<span class="type">int</span>&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>局限二：无法取得带泛型的<code>Class</code>。观察以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Pair&lt;String&gt; p1 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        Pair&lt;Integer&gt; p2 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> p1.getClass();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> p2.getClass();</span><br><span class="line">        System.out.println(c1==c2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(c1==Pair.class); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>T</code>是<code>Object</code>，我们对<code>Pair&lt;String&gt;</code>和<code>Pair&lt;Integer&gt;</code>类型获取<code>Class</code>时，获取到的是同一个<code>Class</code>，也就是<code>Pair</code>类的<code>Class</code>。</p><p>换句话说，所有泛型实例，无论<code>T</code>的类型是什么，<code>getClass()</code>返回同一个<code>Class</code>实例，因为编译后它们全部都是<code>Pair&lt;Object&gt;</code>。</p><p>局限三：无法判断带泛型的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line"><span class="comment">// Compile error:</span></span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Pair&lt;String&gt;) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因和前面一样，并不存在<code>Pair&lt;String&gt;.class</code>，而是只有唯一的<code>Pair.class</code>。</p><p>局限四：不能实例化<code>T</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Compile error:</span></span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        last = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码无法通过编译，因为构造方法的两行语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">last = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br></pre></td></tr></table></figure><p>擦拭后实际上变成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">last = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p>这样一来，创建<code>new Pair&lt;String&gt;()</code>和创建<code>new Pair&lt;Integer&gt;()</code>就全部成了<code>Object</code>，显然编译器要阻止这种类型不对的代码。</p><p>要实例化<code>T</code>类型，我们必须借助额外的<code>Class&lt;T&gt;</code>参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        first = clazz.newInstance();</span><br><span class="line">        last = clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码借助<code>Class&lt;T&gt;</code>参数并通过反射来实例化<code>T</code>类型，使用的时候，也必须传入<code>Class&lt;T&gt;</code>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(String.class);</span><br></pre></td></tr></table></figure><p>因为传入了<code>Class&lt;String&gt;</code>的实例，所以我们借助<code>String.class</code>就可以实例化<code>String</code>类型。</p><h3 id="不恰当的覆写方法">不恰当的覆写方法</h3><p>有些时候，一个看似正确定义的方法会无法通过编译。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span> == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为，定义的<code>equals(T t)</code>方法实际上会被擦拭成<code>equals(Object t)</code>，而这个方法是继承自<code>Object</code>的，编译器会阻止一个实际上会变成覆写的泛型方法定义。</p><p>换个方法名，避开与<code>Object.equals(Object)</code>的冲突就可以成功编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">same</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span> == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型继承">泛型继承</h3><p>一个类可以继承自一个泛型类。例如：父类的类型是<code>Pair&lt;Integer&gt;</code>，子类的类型是<code>IntPair</code>，可以这么继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntPair</span> <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;Integer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，因为子类<code>IntPair</code>并没有泛型类型，所以，正常使用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntPair</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntPair</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>前面讲了，我们无法获取<code>Pair&lt;T&gt;</code>的<code>T</code>类型，即给定一个变量<code>Pair&lt;Integer&gt; p</code>，无法从<code>p</code>中获取到<code>Integer</code>类型。</p><p>但是，在父类是泛型类型的情况下，编译器就必须把类型<code>T</code>（对<code>IntPair</code>来说，也就是<code>Integer</code>类型）保存到子类的class文件中，不然编译器就不知道<code>IntPair</code>只能存取<code>Integer</code>这种类型。</p><p>在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：<code>IntPair</code>可以获取到父类的泛型类型<code>Integer</code>。获取父类的泛型类型代码比较复杂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;IntPair&gt; clazz = IntPair.class;</span><br><span class="line">        <span class="type">Type</span> <span class="variable">t</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            <span class="type">ParameterizedType</span> <span class="variable">pt</span> <span class="operator">=</span> (ParameterizedType) t;</span><br><span class="line">            Type[] types = pt.getActualTypeArguments(); <span class="comment">// 可能有多个泛型类型</span></span><br><span class="line">            <span class="type">Type</span> <span class="variable">firstType</span> <span class="operator">=</span> types[<span class="number">0</span>]; <span class="comment">// 取第一个泛型类型</span></span><br><span class="line">            Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType;</span><br><span class="line">            System.out.println(typeClass); <span class="comment">// Integer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntPair</span> <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IntPair</span><span class="params">(Integer first, Integer last)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为Java引入了泛型，所以，只用<code>Class</code>来标识类型已经不够了。实际上，Java的类型系统结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                      ┌────┐</span><br><span class="line">                      │Type│</span><br><span class="line">                      └────┘</span><br><span class="line">                         ▲</span><br><span class="line">                         │</span><br><span class="line">   ┌────────────┬────────┴─────────┬───────────────┐</span><br><span class="line">   │            │                  │               │</span><br><span class="line">┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐</span><br><span class="line">│Class││ParameterizedType││GenericArrayType││WildcardType│</span><br><span class="line">└─────┘└─────────────────┘└────────────────┘└────────────┘</span><br></pre></td></tr></table></figure><h3 id="小结-4">小结</h3><p>Java的泛型是采用擦拭法实现的；</p><p>擦拭法决定了泛型<code>&lt;T&gt;</code>：</p><ul><li>不能是基本类型，例如：<code>int</code>；</li><li>不能获取带泛型类型的<code>Class</code>，例如：<code>Pair&lt;String&gt;.class</code>；</li><li>不能判断带泛型类型的类型，例如：<code>x instanceof Pair&lt;String&gt;</code>；</li><li>不能实例化<code>T</code>类型，例如：<code>new T()</code>。</li></ul><p>泛型方法要防止重复定义方法，例如：<code>public boolean equals(T obj)</code>；</p><p>子类可以获取父类的泛型类型<code>&lt;T&gt;</code>。</p><p>我们前面已经讲到了泛型的继承关系：<code>Pair&lt;Integer&gt;</code>不是<code>Pair&lt;Number&gt;</code>的子类。</p><p>假设我们定义了<code>Pair&lt;T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>然后，我们又针对<code>Pair&lt;Number&gt;</code>类型写了一个静态方法，它接收的参数类型是<code>Pair&lt;Number&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PairHelper</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(Pair&lt;Number&gt; p)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">        <span class="type">Number</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是可以正常编译的。使用的时候，我们传入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> PairHelper.add(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;Number&gt;(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>注意：传入的类型是<code>Pair&lt;Number&gt;</code>，实际参数类型是<code>(Integer, Integer)</code>。</p><p>既然实际参数是<code>Integer</code>类型，试试传入<code>Pair&lt;Integer&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(Pair&lt;Number&gt; p)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">        <span class="type">Number</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接运行，会得到一个编译错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incompatible types: Pair&lt;Integer&gt; cannot be converted to Pair&lt;Number&gt;</span><br></pre></td></tr></table></figure><p>原因很明显，因为<code>Pair&lt;Integer&gt;</code>不是<code>Pair&lt;Number&gt;</code>的子类，因此，<code>add(Pair&lt;Number&gt;)</code>不接受参数类型<code>Pair&lt;Integer&gt;</code>。</p><p>但是从<code>add()</code>方法的代码可知，传入<code>Pair&lt;Integer&gt;</code>是完全符合内部代码的类型规范，因为语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Number</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line"><span class="type">Number</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br></pre></td></tr></table></figure><p>实际类型是<code>Integer</code>，引用类型是<code>Number</code>，没有问题。问题在于方法参数类型定死了只能传入<code>Pair&lt;Number&gt;</code>。</p><p>有没有办法使得方法参数接受<code>Pair&lt;Integer&gt;</code>？办法是有的，这就是使用<code>Pair&lt;? extends Number&gt;</code>使得方法接收所有泛型类型为<code>Number</code>或<code>Number</code>子类的<code>Pair</code>类型。我们把代码改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(Pair&lt;? extends Number&gt; p)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">        <span class="type">Number</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，给方法传入<code>Pair&lt;Integer&gt;</code>类型时，它符合参数<code>Pair&lt;? extends Number&gt;</code>类型。这种使用<code>&lt;? extends Number&gt;</code>的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型<code>T</code>的上界限定在<code>Number</code>了。</p><p>除了可以传入<code>Pair&lt;Integer&gt;</code>类型，我们还可以传入<code>Pair&lt;Double&gt;</code>类型，<code>Pair&lt;BigDecimal&gt;</code>类型等等，因为<code>Double</code>和<code>BigDecimal</code>都是<code>Number</code>的子类。</p><p>如果我们考察对<code>Pair&lt;? extends Number&gt;</code>类型调用<code>getFirst()</code>方法，实际的方法签名变成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; getFirst();</span><br></pre></td></tr></table></figure><p>即返回值是<code>Number</code>或<code>Number</code>的子类，因此，可以安全赋值给<code>Number</code>类型的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Number</span> <span class="variable">x</span> <span class="operator">=</span> p.getFirst();</span><br></pre></td></tr></table></figure><p>然后，我们不可预测实际类型就是<code>Integer</code>，例如，下面的代码是无法通过编译的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> p.getFirst();</span><br></pre></td></tr></table></figure><p>这是因为实际的返回类型可能是<code>Integer</code>，也可能是<code>Double</code>或者其他类型，编译器只能确定类型一定是<code>Number</code>的子类（包括<code>Number</code>类型本身），但具体类型无法确定。</p><p>我们再来考察一下<code>Pair&lt;T&gt;</code>的<code>set</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(Pair&lt;? extends Number&gt; p)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">        <span class="type">Number</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br><span class="line">        p.setFirst(<span class="keyword">new</span> <span class="title class_">Integer</span>(first.intValue() + <span class="number">100</span>));</span><br><span class="line">        p.setLast(<span class="keyword">new</span> <span class="title class_">Integer</span>(last.intValue() + <span class="number">100</span>));</span><br><span class="line">        <span class="keyword">return</span> p.getFirst().intValue() + p.getLast().intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(T first)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLast</span><span class="params">(T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不出意外，我们会得到一个编译错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">incompatible types: Integer cannot be converted to CAP#1</span><br><span class="line">where CAP#1 is a fresh type-variable:</span><br><span class="line">    CAP#1 extends Number from capture of ? extends Number</span><br></pre></td></tr></table></figure><p>编译错误发生在<code>p.setFirst()</code>传入的参数是<code>Integer</code>类型。有些童鞋会问了，既然<code>p</code>的定义是<code>Pair&lt;? extends Number&gt;</code>，那么<code>setFirst(? extends Number)</code>为什么不能传入<code>Integer</code>？</p><p>原因还在于擦拭法。如果我们传入的<code>p</code>是<code>Pair&lt;Double&gt;</code>，显然它满足参数定义<code>Pair&lt;? extends Number&gt;</code>，然而，<code>Pair&lt;Double&gt;</code>的<code>setFirst()</code>显然无法接受<code>Integer</code>类型。</p><p>这就是<code>&lt;? extends Number&gt;</code>通配符的一个重要限制：方法参数签名<code>setFirst(? extends Number)</code>无法传递任何<code>Number</code>的子类型给<code>setFirst(? extends Number)</code>。</p><p>这里唯一的例外是可以给方法参数传入<code>null</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.setFirst(<span class="literal">null</span>); <span class="comment">// ok, 但是后面会抛出NullPointerException</span></span><br><span class="line">p.getFirst().intValue(); <span class="comment">// NullPointerException</span></span><br></pre></td></tr></table></figure><h3 id="extends通配符的作用">extends通配符的作用</h3><p>如果我们考察Java标准库的<code>java.util.List&lt;T&gt;</code>接口，它实现的是一个类似“可变数组”的列表，主要功能包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>; <span class="comment">// 获取个数</span></span><br><span class="line">    T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>; <span class="comment">// 根据索引获取指定元素</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span>; <span class="comment">// 添加一个新元素</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(T t)</span>; <span class="comment">// 删除一个已有元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，让我们定义一个方法来处理列表的每个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumOfList</span><span class="params">(List&lt;? extends Integer&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">        sum = sum + n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么我们定义的方法参数类型是<code>List&lt;? extends Integer&gt;</code>而不是<code>List&lt;Integer&gt;</code>？从方法内部代码看，传入<code>List&lt;? extends Integer&gt;</code>或者<code>List&lt;Integer&gt;</code>是完全一样的，但是，注意到<code>List&lt;? extends Integer&gt;</code>的限制：</p><ul><li>允许调用<code>get()</code>方法获取<code>Integer</code>的引用；</li><li>不允许调用<code>set(? extends Integer)</code>方法并传入任何<code>Integer</code>的引用（<code>null</code>除外）。</li></ul><p>因此，方法参数类型<code>List&lt;? extends Integer&gt;</code>表明了该方法内部只会读取<code>List</code>的元素，不会修改<code>List</code>的元素（因为无法调用<code>add(? extends Integer)</code>、<code>remove(? extends Integer)</code>这些方法。换句话说，这是一个对参数<code>List&lt;? extends Integer&gt;</code>进行只读的方法（恶意调用<code>set(null)</code>除外）。</p><h3 id="使用extends限定T类型">使用extends限定T类型</h3><p>在定义泛型类型<code>Pair&lt;T&gt;</code>的时候，也可以使用<code>extends</code>通配符来限定<code>T</code>的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>现在，我们只能定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Number&gt; p1 = <span class="literal">null</span>;</span><br><span class="line">Pair&lt;Integer&gt; p2 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Pair&lt;Double&gt; p3 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>因为<code>Number</code>、<code>Integer</code>和<code>Double</code>都符合<code>&lt;T extends Number&gt;</code>。</p><p>非<code>Number</code>类型将无法通过编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; p1 = <span class="literal">null</span>; <span class="comment">// compile error!</span></span><br><span class="line">Pair&lt;Object&gt; p2 = <span class="literal">null</span>; <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>因为<code>String</code>、<code>Object</code>都不符合<code>&lt;T extends Number&gt;</code>，因为它们不是<code>Number</code>类型或<code>Number</code>的子类。</p><h3 id="小结-5">小结</h3><p>使用类似<code>&lt;? extends Number&gt;</code>通配符作为方法参数时表示：</p><ul><li>方法内部可以调用获取<code>Number</code>引用的方法，例如：<code>Number n = obj.getFirst();</code>；</li><li>方法内部无法调用传入<code>Number</code>引用的方法（<code>null</code>除外），例如：<code>obj.setFirst(Number n);</code>。</li></ul><p>即一句话总结：使用<code>extends</code>通配符表示可以读，不能写。</p><p>使用类似<code>&lt;T extends Number&gt;</code>定义泛型类时表示：</p><ul><li>泛型类型限定为<code>Number</code>以及<code>Number</code>的子类。</li></ul><p>我们前面已经讲到了泛型的继承关系：<code>Pair&lt;Integer&gt;</code>不是<code>Pair&lt;Number&gt;</code>的子类。</p><p>考察下面的<code>set</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Pair&lt;Integer&gt; p, Integer first, Integer last)</span> &#123;</span><br><span class="line">    p.setFirst(first);</span><br><span class="line">    p.setLast(last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入<code>Pair&lt;Integer&gt;</code>是允许的，但是传入<code>Pair&lt;Number&gt;</code>是不允许的。</p><p>和<code>extends</code>通配符相反，这次，我们希望接受<code>Pair&lt;Integer&gt;</code>类型，以及<code>Pair&lt;Number&gt;</code>、<code>Pair&lt;Object&gt;</code>，因为<code>Number</code>和<code>Object</code>是<code>Integer</code>的父类，<code>setFirst(Number)</code>和<code>setFirst(Object)</code>实际上允许接受<code>Integer</code>类型。</p><p>我们使用<code>super</code>通配符来改写这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Pair&lt;? <span class="built_in">super</span> Integer&gt; p, Integer first, Integer last)</span> &#123;</span><br><span class="line">    p.setFirst(first);</span><br><span class="line">    p.setLast(last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>Pair&lt;? super Integer&gt;</code>表示，方法参数接受所有泛型类型为<code>Integer</code>或<code>Integer</code>父类的<code>Pair</code>类型。</p><p>下面的代码可以被正常编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Pair&lt;Number&gt; p1 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">12.3</span>, <span class="number">4.56</span>);</span><br><span class="line">        Pair&lt;Integer&gt; p2 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        setSame(p1, <span class="number">100</span>);</span><br><span class="line">        setSame(p2, <span class="number">200</span>);</span><br><span class="line">        System.out.println(p1.getFirst() + <span class="string">&quot;, &quot;</span> + p1.getLast());</span><br><span class="line">        System.out.println(p2.getFirst() + <span class="string">&quot;, &quot;</span> + p2.getLast());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setSame</span><span class="params">(Pair&lt;? <span class="built_in">super</span> Integer&gt; p, Integer n)</span> &#123;</span><br><span class="line">        p.setFirst(n);</span><br><span class="line">        p.setLast(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(T first)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLast</span><span class="params">(T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考察<code>Pair&lt;? super Integer&gt;</code>的<code>setFirst()</code>方法，它的方法签名实际上是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(? <span class="built_in">super</span> Integer)</span>;</span><br></pre></td></tr></table></figure><p>因此，可以安全地传入<code>Integer</code>类型。</p><p>再考察<code>Pair&lt;? super Integer&gt;</code>的<code>getFirst()</code>方法，它的方法签名实际上是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? <span class="built_in">super</span> Integer <span class="title function_">getFirst</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>这里注意到我们无法使用<code>Integer</code>类型来接收<code>getFirst()</code>的返回值，即下面的语句将无法通过编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> p.getFirst();</span><br></pre></td></tr></table></figure><p>因为如果传入的实际类型是<code>Pair&lt;Number&gt;</code>，编译器无法将<code>Number</code>类型转型为<code>Integer</code>。</p><p>注意：虽然<code>Number</code>是一个抽象类，我们无法直接实例化它。但是，即便<code>Number</code>不是抽象类，这里仍然无法通过编译。此外，传入<code>Pair&lt;Object&gt;</code>类型时，编译器也无法将<code>Object</code>类型转型为<code>Integer</code>。</p><p>唯一可以接收<code>getFirst()</code>方法返回值的是<code>Object</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> p.getFirst();</span><br></pre></td></tr></table></figure><p>因此，使用<code>&lt;? super Integer&gt;</code>通配符表示：</p><ul><li>允许调用<code>set(? super Integer)</code>方法传入<code>Integer</code>的引用；</li><li>不允许调用<code>get()</code>方法获得<code>Integer</code>的引用。</li></ul><p>唯一例外是可以获取<code>Object</code>的引用：<code>Object o = p.getFirst()</code>。</p><p>换句话说，使用<code>&lt;? super Integer&gt;</code>通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。</p><h3 id="对比extends和super通配符">对比extends和super通配符</h3><p>我们再回顾一下<code>extends</code>通配符。作为方法参数，<code>&lt;? extends T&gt;</code>类型和<code>&lt;? super T&gt;</code>类型的区别在于：</p><ul><li><code>&lt;? extends T&gt;</code>允许调用读方法<code>T get()</code>获取<code>T</code>的引用，但不允许调用写方法<code>set(T)</code>传入<code>T</code>的引用（传入<code>null</code>除外）；</li><li><code>&lt;? super T&gt;</code>允许调用写方法<code>set(T)</code>传入<code>T</code>的引用，但不允许调用读方法<code>T get()</code>获取<code>T</code>的引用（获取<code>Object</code>除外）。</li></ul><p>一个是允许读不允许写，另一个是允许写不允许读。</p><p>先记住上面的结论，我们来看Java标准库的<code>Collections</code>类定义的<code>copy()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collections</span> &#123;</span><br><span class="line">    <span class="comment">// 把src的每个元素复制到dest中:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;src.size(); i++) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> src.get(i);</span><br><span class="line">            dest.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用是把一个<code>List</code>的每个元素依次添加到另一个<code>List</code>中。它的第一个参数是<code>List&lt;? super T&gt;</code>，表示目标<code>List</code>，第二个参数<code>List&lt;? extends T&gt;</code>，表示要复制的<code>List</code>。我们可以简单地用<code>for</code>循环实现复制。在<code>for</code>循环中，我们可以看到，对于类型<code>&lt;? extends T&gt;</code>的变量<code>src</code>，我们可以安全地获取类型<code>T</code>的引用，而对于类型<code>&lt;? super T&gt;</code>的变量<code>dest</code>，我们可以安全地传入<code>T</code>的引用。</p><p>这个<code>copy()</code>方法的定义就完美地展示了<code>extends</code>和<code>super</code>的意图：</p><ul><li><code>copy()</code>方法内部不会读取<code>dest</code>，因为不能调用<code>dest.get()</code>来获取<code>T</code>的引用；</li><li><code>copy()</code>方法内部也不会修改<code>src</code>，因为不能调用<code>src.add(T)</code>。</li></ul><p>这是由编译器检查来实现的。如果在方法代码中意外修改了<code>src</code>，或者意外读取了<code>dest</code>，就会导致一个编译错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collections</span> &#123;</span><br><span class="line">    <span class="comment">// 把src的每个元素复制到dest中:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> dest.get(<span class="number">0</span>); <span class="comment">// compile error!</span></span><br><span class="line">        src.add(t); <span class="comment">// compile error!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>copy()</code>方法的另一个好处是可以安全地把一个<code>List&lt;Integer&gt;</code>添加到<code>List&lt;Number&gt;</code>，但是无法反过来添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy List&lt;Integer&gt; to List&lt;Number&gt; ok:</span></span><br><span class="line">List&lt;Number&gt; numList = ...;</span><br><span class="line">List&lt;Integer&gt; intList = ...;</span><br><span class="line">Collections.copy(numList, intList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ERROR: cannot copy List&lt;Number&gt; to List&lt;Integer&gt;:</span></span><br><span class="line">Collections.copy(intList, numList);</span><br></pre></td></tr></table></figure><p>而这些都是通过<code>super</code>和<code>extends</code>通配符，并由编译器强制检查来实现的。</p><h3 id="PECS原则">PECS原则</h3><p>何时使用<code>extends</code>，何时使用<code>super</code>？为了便于记忆，我们可以用PECS原则：Producer Extends Consumer Super。</p><p>即：如果需要返回<code>T</code>，它是生产者（Producer），要使用<code>extends</code>通配符；如果需要写入<code>T</code>，它是消费者（Consumer），要使用<code>super</code>通配符。</p><p>还是以<code>Collections</code>的<code>copy()</code>方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collections</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;src.size(); i++) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> src.get(i); <span class="comment">// src是producer</span></span><br><span class="line">            dest.add(t); <span class="comment">// dest是consumer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要返回<code>T</code>的<code>src</code>是生产者，因此声明为<code>List&lt;? extends T&gt;</code>，需要写入<code>T</code>的<code>dest</code>是消费者，因此声明为<code>List&lt;? super T&gt;</code>。</p><h3 id="无限定通配符">无限定通配符</h3><p>我们已经讨论了<code>&lt;? extends T&gt;</code>和<code>&lt;? super T&gt;</code>作为方法参数的作用。实际上，Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个<code>?</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sample</span><span class="params">(Pair&lt;?&gt; p)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>&lt;?&gt;</code>通配符既没有<code>extends</code>，也没有<code>super</code>，因此：</p><ul><li>不允许调用<code>set(T)</code>方法并传入引用（<code>null</code>除外）；</li><li>不允许调用<code>T get()</code>方法并获取<code>T</code>引用（只能获取<code>Object</code>引用）。</li></ul><p>换句话说，既不能读，也不能写，那只能做一些<code>null</code>判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNull</span><span class="params">(Pair&lt;?&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() == <span class="literal">null</span> || p.getLast() == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数情况下，可以引入泛型参数<code>&lt;T&gt;</code>消除<code>&lt;?&gt;</code>通配符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">isNull</span><span class="params">(Pair&lt;T&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() == <span class="literal">null</span> || p.getLast() == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;?&gt;</code>通配符有一个独特的特点，就是：<code>Pair&lt;?&gt;</code>是所有<code>Pair&lt;T&gt;</code>的超类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        Pair&lt;?&gt; p2 = p; <span class="comment">// 安全地向上转型</span></span><br><span class="line">        System.out.println(p2.getFirst() + <span class="string">&quot;, &quot;</span> + p2.getLast());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(T first)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLast</span><span class="params">(T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是可以正常编译运行的，因为<code>Pair&lt;Integer&gt;</code>是<code>Pair&lt;?&gt;</code>的子类，可以安全地向上转型。</p><h3 id="小结-6">小结</h3><p>使用类似<code>&lt;? super Integer&gt;</code>通配符作为方法参数时表示：</p><ul><li>方法内部可以调用传入<code>Integer</code>引用的方法，例如：<code>obj.setFirst(Integer n);</code>；</li><li>方法内部无法调用获取<code>Integer</code>引用的方法（<code>Object</code>除外），例如：<code>Integer n = obj.getFirst();</code>。</li></ul><p>即使用<code>super</code>通配符表示只能写不能读。</p><p>使用<code>extends</code>和<code>super</code>通配符要遵循PECS原则。</p><p>无限定通配符<code>&lt;?&gt;</code>很少使用，可以用<code>&lt;T&gt;</code>替换，同时它是所有<code>&lt;T&gt;</code>类型的超类。</p><p>Java的部分反射API也是泛型。例如：<code>Class&lt;T&gt;</code>就是泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compile warning:</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> String.class;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// no warning:</span></span><br><span class="line">Class&lt;String&gt; clazz = String.class;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> clazz.newInstance();</span><br></pre></td></tr></table></figure><p>调用<code>Class</code>的<code>getSuperclass()</code>方法返回的<code>Class</code>类型是<code>Class&lt;? super T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;? <span class="built_in">super</span> String&gt; sup = String.class.getSuperclass();</span><br></pre></td></tr></table></figure><p>构造方法<code>Constructor&lt;T&gt;</code>也是泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Integer&gt; clazz = Integer.class;</span><br><span class="line">Constructor&lt;Integer&gt; cons = clazz.getConstructor(<span class="type">int</span>.class);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> cons.newInstance(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>我们可以声明带泛型的数组，但不能用<code>new</code>操作符创建带泛型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] ps = <span class="literal">null</span>; <span class="comment">// ok</span></span><br><span class="line">Pair&lt;String&gt;[] ps = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String&gt;[<span class="number">2</span>]; <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>必须通过强制转型实现带泛型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>使用泛型数组要特别小心，因为数组实际上在运行期没有泛型，编译器可以强制检查变量<code>ps</code>，因为它的类型是泛型数组。但是，编译器不会检查变量<code>arr</code>，因为它不是泛型数组。因为这两个变量实际上指向同一个数组，所以，操作<code>arr</code>可能导致从<code>ps</code>获取元素时报错，例如，以下代码演示了不安全地使用带泛型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pair[] arr = <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">2</span>];</span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr;</span><br><span class="line"></span><br><span class="line">ps[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String&gt;(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;Integer&gt;(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClassCastException:</span></span><br><span class="line">Pair&lt;String&gt; p = ps[<span class="number">1</span>];</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> p.getFirst();</span><br></pre></td></tr></table></figure><p>要安全地使用泛型数组，必须扔掉<code>arr</code>的引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>上面的代码中，由于拿不到原始数组的引用，就只能对泛型数组<code>ps</code>进行操作，这种操作就是安全的。</p><p>带泛型的数组实际上是编译器的类型擦除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pair[] arr = <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">2</span>];</span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr;</span><br><span class="line"></span><br><span class="line">System.out.println(ps.getClass() == Pair[].class); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> (String) arr[<span class="number">0</span>].getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> ps[<span class="number">0</span>].getFirst();</span><br></pre></td></tr></table></figure><p>所以我们不能直接创建泛型数组<code>T[]</code>，因为擦拭后代码变为<code>Object[]</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compile error:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Abc</span>&lt;T&gt; &#123;</span><br><span class="line">    T[] createArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须借助<code>Class&lt;T&gt;</code>来创建泛型数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T[] createArray(Class&lt;T&gt; cls) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) Array.newInstance(cls, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以利用可变参数创建泛型数组<code>T[]</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayHelper</span> &#123;</span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;</span><br><span class="line">        <span class="keyword">return</span> objs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String[] ss = ArrayHelper.asArray(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">Integer[] ns = ArrayHelper.asArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="谨慎使用泛型可变参数">谨慎使用泛型可变参数</h3><p>在上面的例子中，我们看到，通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;</span><br><span class="line">    <span class="keyword">return</span> objs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>似乎可以安全地创建一个泛型数组。但实际上，这种方法非常危险。以下代码来自《Effective Java》的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr = asArray(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="comment">// ClassCastException:</span></span><br><span class="line">        String[] firstTwo = pickTwo(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(firstTwo));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;K&gt; K[] pickTwo(K k1, K k2, K k3) &#123;</span><br><span class="line">        <span class="keyword">return</span> asArray(k1, k2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;</span><br><span class="line">        <span class="keyword">return</span> objs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用<code>asArray(T...)</code>似乎没有问题，但是在另一个方法中，我们返回一个泛型数组就会产生<code>ClassCastException</code>，原因还是因为擦拭法，在<code>pickTwo()</code>方法内部，编译器无法检测<code>K[]</code>的正确类型，因此返回了<code>Object[]</code>。</p><p>如果仔细观察，可以发现编译器对所有可变泛型参数都会发出警告，除非确认完全没有问题，才可以用<code>@SafeVarargs</code>消除警告。</p><p>注意</p><p>如果在方法内部创建了泛型数组，最好不要将它返回给外部使用。</p><p>更详细的解释请参考《<a href="https://www.oreilly.com/library/view/effective-java-3rd/9780134686097/">Effective Java</a>》“Item 32: Combine generics and varargs judiciously”。</p><h3 id="小结-7">小结</h3><p>部分反射API是泛型，例如：<code>Class&lt;T&gt;</code>，<code>Constructor&lt;T&gt;</code>；</p><p>可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型；</p><p>可以通过<code>Array.newInstance(Class&lt;T&gt;, int)</code>创建<code>T[]</code>数组，需要强制转型；</p><p>同时使用泛型和可变参数时需要特别小心。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-注解</title>
      <link href="/2025/05/24/java/JAVA-%E6%B3%A8%E8%A7%A3/"/>
      <url>/2025/05/24/java/JAVA-%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="使用注解">使用注解</h2><p>什么是注解（Annotation）？注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this is a component:</span></span><br><span class="line"><span class="meta">@Resource(&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(<span class="meta">@Param</span> String name)</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p><h3 id="注解的作用">注解的作用</h3><p>从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。</p><p>Java的注解可以分为三类：</p><p>第一类是由编译器使用的注解，例如：</p><ul><li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li><li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li></ul><p>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</p><p>第二类是由工具处理<code>.class</code>文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p><p>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p><p>定义一个注解时，还可以定义配置参数。配置参数可以包括：</p><ul><li>所有基本类型；</li><li>String；</li><li>枚举类型；</li><li>基本类型、String、Class以及枚举的数组。</li></ul><p>因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。</p><p>注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。</p><p>此外，大部分注解会有一个名为<code>value</code>的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。</p><p>如果只写注解，相当于全部使用默认值。</p><p>举个栗子，对以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="meta">@Check(min=0, max=100, value=55)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check(value=99)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check(99)</span> <span class="comment">// @Check(value=99)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Check</code>就是一个注解。第一个<code>@Check(min=0, max=100, value=55)</code>明确定义了三个参数，第二个<code>@Check(value=99)</code>只定义了一个<code>value</code>参数，它实际上和<code>@Check(99)</code>是完全一样的。最后一个<code>@Check</code>表示所有参数都使用默认值。</p><h3 id="小结">小结</h3><p>注解（Annotation）是Java语言用于工具处理的标注：</p><p>注解可以配置参数，没有指定配置的参数使用默认值；</p><p>如果参数名称是<code>value</code>，且只有一个参数，那么可以省略参数名称。</p><hr><hr><p>Java语言使用<code>@interface</code>语法来定义注解（<code>Annotation</code>），它的格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的参数类似无参数方法，可以用<code>default</code>设定一个默认值（强烈推荐）。最常用的参数应当命名为<code>value</code>。</p><h3 id="元注解">元注解</h3><p>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p><h4 id="Target">@Target</h4><p>最常用的元注解是<code>@Target</code>。使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p><ul><li>类或接口：<code>ElementType.TYPE</code>；</li><li>字段：<code>ElementType.FIELD</code>；</li><li>方法：<code>ElementType.METHOD</code>；</li><li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li><li>方法参数：<code>ElementType.PARAMETER</code>。</li></ul><p>例如，定义注解<code>@Report</code>可用在方法上，我们必须添加一个<code>@Target(ElementType.METHOD)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义注解<code>@Report</code>可用在方法或字段上，可以把<code>@Target</code>注解参数变为数组<code>&#123; ElementType.METHOD, ElementType.FIELD &#125;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;</span></span><br><span class="line"><span class="meta">    ElementType.METHOD,</span></span><br><span class="line"><span class="meta">    ElementType.FIELD</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上<code>@Target</code>定义的<code>value</code>是<code>ElementType[]</code>数组，只有一个元素时，可以省略数组的写法。</p><h4 id="Retention">@Retention</h4><p>另一个重要的元注解<code>@Retention</code>定义了<code>Annotation</code>的生命周期：</p><ul><li>仅编译期：<code>RetentionPolicy.SOURCE</code>；</li><li>仅class文件：<code>RetentionPolicy.CLASS</code>；</li><li>运行期：<code>RetentionPolicy.RUNTIME</code>。</li></ul><p>如果<code>@Retention</code>不存在，则该<code>Annotation</code>默认为<code>CLASS</code>。因为通常我们自定义的<code>Annotation</code>都是<code>RUNTIME</code>，所以，务必要加上<code>@Retention(RetentionPolicy.RUNTIME)</code>这个元注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Repeatable">@Repeatable</h4><p>使用<code>@Repeatable</code>这个元注解可以定义<code>Annotation</code>是否可重复。这个注解应用不是特别广泛。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repeatable(Reports.class)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Reports &#123;</span><br><span class="line">    Report[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过<code>@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个<code>@Report</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Report(type=1, level=&quot;debug&quot;)</span></span><br><span class="line"><span class="meta">@Report(type=2, level=&quot;warning&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Inherited">@Inherited</h4><p>使用<code>@Inherited</code>定义子类是否可继承父类定义的<code>Annotation</code>。<code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用的时候，如果一个类用到了<code>@Report</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Report(type=1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则它的子类默认也定义了该注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何定义Annotation">如何定义Annotation</h3><p>我们总结一下定义<code>Annotation</code>的步骤：</p><p>第一步，用<code>@interface</code>定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，添加参数、默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值。</p><p>第三步，用元注解配置注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p><h3 id="小结-2">小结</h3><p>Java使用<code>@interface</code>定义注解；</p><p>可定义多个参数和默认值，核心参数使用<code>value</code>名称；</p><p>必须设置<code>@Target</code>来指定<code>Annotation</code>可以应用的范围；</p><p>应当设置<code>@Retention(RetentionPolicy.RUNTIME)</code>便于运行期读取该<code>Annotation</code>。</p><p>Java的注解本身对代码逻辑没有任何影响。根据<code>@Retention</code>的配置：</p><ul><li><code>SOURCE</code>类型的注解在编译期就被丢掉了；</li><li><code>CLASS</code>类型的注解仅保存在class文件中，它们不会被加载进JVM；</li><li><code>RUNTIME</code>类型的注解会被加载进JVM，并且在运行期可以被程序读取。</li></ul><p>如何使用注解完全由工具决定。<code>SOURCE</code>类型的注解主要由编译器使用，因此我们一般只使用，不编写。<code>CLASS</code>类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有<code>RUNTIME</code>类型的注解不但要使用，还经常需要编写。</p><p>因此，我们只讨论如何读取<code>RUNTIME</code>类型的注解。</p><p>因为注解定义后也是一种<code>class</code>，所有的注解都继承自<code>java.lang.annotation.Annotation</code>，因此，读取注解，需要使用反射API。</p><p>Java提供的使用反射API读取<code>Annotation</code>的方法包括：</p><p>判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p><ul><li>Class.isAnnotationPresent(Class)</li><li>Field.isAnnotationPresent(Class)</li><li>Method.isAnnotationPresent(Class)</li><li>Constructor.isAnnotationPresent(Class)</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断@Report是否存在于Person类:</span></span><br><span class="line">Person.class.isAnnotationPresent(Report.class);</span><br></pre></td></tr></table></figure><p>使用反射API读取Annotation：</p><ul><li>Class.getAnnotation(Class)</li><li>Field.getAnnotation(Class)</li><li>Method.getAnnotation(Class)</li><li>Constructor.getAnnotation(Class)</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Person定义的@Report注解:</span></span><br><span class="line"><span class="type">Report</span> <span class="variable">report</span> <span class="operator">=</span> Person.class.getAnnotation(Report.class);</span><br><span class="line"><span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> report.type();</span><br><span class="line"><span class="type">String</span> <span class="variable">level</span> <span class="operator">=</span> report.level();</span><br></pre></td></tr></table></figure><p>使用反射API读取<code>Annotation</code>有两种方法。方法一是先判断<code>Annotation</code>是否存在，如果存在，就直接读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Person.class;</span><br><span class="line"><span class="keyword">if</span> (cls.isAnnotationPresent(Report.class)) &#123;</span><br><span class="line">    <span class="type">Report</span> <span class="variable">report</span> <span class="operator">=</span> cls.getAnnotation(Report.class);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法是直接读取<code>Annotation</code>，如果<code>Annotation</code>不存在，将返回<code>null</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Person.class;</span><br><span class="line"><span class="type">Report</span> <span class="variable">report</span> <span class="operator">=</span> cls.getAnnotation(Report.class);</span><br><span class="line"><span class="keyword">if</span> (report != <span class="literal">null</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取方法、字段和构造方法的<code>Annotation</code>和Class类似。但要读取方法参数的<code>Annotation</code>就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。例如，对于以下方法定义的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(<span class="meta">@NotNull</span> <span class="meta">@Range(max=5)</span> String name, <span class="meta">@NotNull</span> String prefix)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要读取方法参数的注解，我们先用反射获取<code>Method</code>实例，然后读取方法参数的所有注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Method实例:</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="comment">// 获取所有参数的Annotation:</span></span><br><span class="line">Annotation[][] annos = m.getParameterAnnotations();</span><br><span class="line"><span class="comment">// 第一个参数（索引为0）的所有Annotation:</span></span><br><span class="line">Annotation[] annosOfName = annos[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (Annotation anno : annosOfName) &#123;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> Range r) &#123; <span class="comment">// @Range注解</span></span><br><span class="line">        r.max();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> NotNull n) &#123; <span class="comment">// @NotNull注解</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用注解-2">使用注解</h3><p>注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为<code>@Test</code>的方法。</p><p>我们来看一个<code>@Range</code>注解，我们希望用它来定义一个<code>String</code>字段的规则：字段长度满足<code>@Range</code>的参数定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">max</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在某个JavaBean中，我们可以使用该注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Range(min=1, max=20)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Range(max=10)</span></span><br><span class="line">    <span class="keyword">public</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。这里，我们编写一个<code>Person</code>实例的检查方法，它可以检查<code>Person</code>实例的<code>String</code>字段长度是否满足<code>@Range</code>的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">check</span><span class="params">(Person person)</span> <span class="keyword">throws</span> IllegalArgumentException, ReflectiveOperationException &#123;</span><br><span class="line">    <span class="comment">// 遍历所有Field:</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : person.getClass().getFields()) &#123;</span><br><span class="line">        <span class="comment">// 获取Field定义的@Range:</span></span><br><span class="line">        <span class="type">Range</span> <span class="variable">range</span> <span class="operator">=</span> field.getAnnotation(Range.class);</span><br><span class="line">        <span class="comment">// 如果@Range存在:</span></span><br><span class="line">        <span class="keyword">if</span> (range != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取Field的值:</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(person);</span><br><span class="line">            <span class="comment">// 如果值是String:</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">                <span class="comment">// 判断值是否满足@Range的min/max:</span></span><br><span class="line">                <span class="keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid field: &quot;</span> + field.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，我们通过<code>@Range</code>注解，配合<code>check()</code>方法，就可以完成<code>Person</code>实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。</p><h3 id="练习">练习</h3><p>使用<code>@Range</code>注解来检查Java Bean的字段。如果字段类型是<code>String</code>，就检查<code>String</code>的长度，如果字段是<code>int</code>，就检查<code>int</code>的范围。</p><p><a href="https://liaoxuefeng.com/books/java/annotation/process-annotation/annotation-range-check.zip">下载练习</a></p><h3 id="小结-3">小结</h3><p>可以在运行期通过反射读取<code>RUNTIME</code>类型的注解，注意千万不要漏写<code>@Retention(RetentionPolicy.RUNTIME)</code>，否则运行期无法读取到该注解。</p><p>可以通过程序处理注解来实现相应的功能：</p><ul><li>对JavaBean的属性值按规则进行检查；</li><li>JUnit会自动运行<code>@Test</code>标记的测试方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-反射</title>
      <link href="/2025/05/24/java/JAVA-%E5%8F%8D%E5%B0%84/"/>
      <url>/2025/05/24/java/JAVA-%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>什么是反射？</p><p>反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。</p><p>正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">import</span> com.itranswarp.learnjava.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    String <span class="title function_">getFullName</span><span class="params">(Person p)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果不能获得<code>Person</code>类，只有一个<code>Object</code>实例，比如这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getFullName</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么办？有童鞋会说：强制转型啊！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getFullName</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">    <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强制转型的时候，你会发现一个问题：编译上面的代码，仍然需要引用<code>Person</code>类。不然，去掉<code>import</code>语句，你看能不能编译通过？</p><p>所以，反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</p><p><img src="https://liaoxuefeng.com/books/java/reflection/reflection.jpg" alt="reflection"></p><p>除了<code>int</code>等基本类型外，Java的其他类型全部都是<code>class</code>（包括<code>interface</code>）。例如：</p><ul><li><code>String</code></li><li><code>Object</code></li><li><code>Runnable</code></li><li><code>Exception</code></li><li>…</li></ul><p>仔细思考，我们可以得出结论：<code>class</code>（包括<code>interface</code>）的本质是数据类型（<code>Type</code>）。无继承关系的数据类型无法赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Number</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">123.456</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">123.456</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>而<code>class</code>是由JVM在执行过程中动态加载的。JVM在第一次读取到一种<code>class</code>类型时，将其加载进内存。</p><p>每加载一种<code>class</code>，JVM就为其创建一个<code>Class</code>类型的实例，并关联起来。注意：这里的<code>Class</code>类型是一个名叫<code>Class</code>的<code>class</code>。它长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Class</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Class</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以<code>String</code>类为例，当JVM加载<code>String</code>类时，它首先读取<code>String.class</code>文件到内存，然后，为<code>String</code>类创建一个<code>Class</code>实例并关联起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span>(String);</span><br></pre></td></tr></table></figure><p>这个<code>Class</code>实例是JVM内部创建的，如果我们查看JDK源码，可以发现<code>Class</code>类的构造方法是<code>private</code>，只有JVM能创建<code>Class</code>实例，我们自己的Java程序是无法创建<code>Class</code>实例的。</p><p>所以，JVM持有的每个<code>Class</code>实例都指向一个数据类型（<code>class</code>或<code>interface</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │────▶ String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name = &quot;java.lang.String&quot;  │</span><br><span class="line">└───────────────────────────┘</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │────▶ Random</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name = &quot;java.util.Random&quot;  │</span><br><span class="line">└───────────────────────────┘</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │────▶ Runnable</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name = &quot;java.lang.Runnable&quot;│</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure><p>一个<code>Class</code>实例包含了该<code>class</code>的所有完整信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │────▶ String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name = &quot;java.lang.String&quot;  │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│package = &quot;java.lang&quot;      │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│super = &quot;java.lang.Object&quot; │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│interface = CharSequence...│</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│field = value[],hash,...   │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│method = indexOf()...      │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure><p>由于JVM为每个加载的<code>class</code>创建了对应的<code>Class</code>实例，并在实例中保存了该<code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息。</p><p>这种通过<code>Class</code>实例获取<code>class</code>信息的方法称为反射（Reflection）。</p><p>如何获取一个<code>class</code>的<code>Class</code>实例？有三个方法：</p><p>方法一：直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class;</span><br></pre></td></tr></table></figure><p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> s.getClass();</span><br></pre></td></tr></table></figure><p>方法三：如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure><p>因为<code>Class</code>实例在JVM中是唯一的，所以，上述方法获取的<code>Class</code>实例是同一个实例。可以用<code>==</code>比较两个<code>Class</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls1</span> <span class="operator">=</span> String.class;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls2</span> <span class="operator">=</span> s.getClass();</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">sameClass</span> <span class="operator">=</span> cls1 == cls2; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注意一下<code>Class</code>实例比较和<code>instanceof</code>的差别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Integer; <span class="comment">// true，因为n是Integer类型</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Number; <span class="comment">// true，因为n是Number类型的子类</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> n.getClass() == Integer.class; <span class="comment">// true，因为n.getClass()返回Integer.class</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> n.getClass();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Number.class;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b4</span> <span class="operator">=</span> c1 == c2; <span class="comment">// false，因为Integer.class != Number.class</span></span><br></pre></td></tr></table></figure><p>用<code>instanceof</code>不但匹配指定类型，还匹配指定类型的子类。而用<code>==</code>判断<code>class</code>实例可以精确地判断数据类型，但不能作子类型比较。</p><p>通常情况下，我们应该用<code>instanceof</code>判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个<code>class</code>的时候，我们才使用<code>==</code>判断<code>class</code>实例。</p><p>因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个<code>Object</code>实例时，我们可以通过反射获取该<code>Object</code>的<code>class</code>信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printObjectInfo</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> obj.getClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要从<code>Class</code>实例获取获取的基本信息，参考下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printClassInfo(<span class="string">&quot;&quot;</span>.getClass());</span><br><span class="line">        printClassInfo(Runnable.class);</span><br><span class="line">        printClassInfo(java.time.Month.class);</span><br><span class="line">        printClassInfo(String[].class);</span><br><span class="line">        printClassInfo(<span class="type">int</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printClassInfo</span><span class="params">(Class cls)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Class name: &quot;</span> + cls.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Simple name: &quot;</span> + cls.getSimpleName());</span><br><span class="line">        <span class="keyword">if</span> (cls.getPackage() != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Package name: &quot;</span> + cls.getPackage().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;is interface: &quot;</span> + cls.isInterface());</span><br><span class="line">        System.out.println(<span class="string">&quot;is enum: &quot;</span> + cls.isEnum());</span><br><span class="line">        System.out.println(<span class="string">&quot;is array: &quot;</span> + cls.isArray());</span><br><span class="line">        System.out.println(<span class="string">&quot;is primitive: &quot;</span> + cls.isPrimitive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到数组（例如<code>String[]</code>）也是一种类，而且不同于<code>String.class</code>，它的类名是<code>[Ljava.lang.String;</code>。此外，JVM为每一种基本类型如<code>int</code>也创建了<code>Class</code>实例，通过<code>int.class</code>访问。</p><p>如果获取到了一个<code>Class</code>实例，我们就可以通过该<code>Class</code>实例来创建对应类型的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取String的Class实例:</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class;</span><br><span class="line"><span class="comment">// 创建一个String实例:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) cls.newInstance();</span><br></pre></td></tr></table></figure><p>上述代码相当于<code>new String()</code>。通过<code>Class.newInstance()</code>可以创建类实例，它的局限是：只能调用<code>public</code>的无参数构造方法。带参数的构造方法，或者非<code>public</code>的构造方法都无法通过<code>Class.newInstance()</code>被调用。</p><h3 id="动态加载">动态加载</h3><p>JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            create(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行<code>Main.java</code>时，由于用到了<code>Main</code>，因此，JVM首先会把<code>Main.class</code>加载到内存。然而，并不会加载<code>Person.class</code>，除非程序执行到<code>create()</code>方法，JVM发现需要加载<code>Person</code>类时，才会首次加载<code>Person.class</code>。如果没有执行<code>create()</code>方法，那么<code>Person.class</code>根本就不会被加载。</p><p>这就是JVM动态加载<code>class</code>的特性。</p><p>动态加载<code>class</code>的特性对于Java程序非常重要。利用JVM动态加载<code>class</code>的特性，我们才能在运行期根据条件加载不同的实现类。例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。利用JVM动态加载特性，大致的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Commons Logging优先使用Log4j:</span></span><br><span class="line"><span class="type">LogFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (isClassPresent(<span class="string">&quot;org.apache.logging.log4j.Logger&quot;</span>)) &#123;</span><br><span class="line">    factory = createLog4j();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory = createJdkLog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isClassPresent</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是为什么我们只需要把Log4j的jar包放到classpath中，Commons Logging就会自动使用Log4j的原因。</p><h3 id="小结">小结</h3><p>JVM为每个加载的<code>class</code>及<code>interface</code>创建了对应的<code>Class</code>实例来保存<code>class</code>及<code>interface</code>的所有信息；</p><p>获取一个<code>class</code>对应的<code>Class</code>实例后，就可以获取该<code>class</code>的所有信息；</p><p>通过Class实例获取<code>class</code>信息的方法称为反射（Reflection）；</p><p>JVM总是动态加载<code>class</code>，可以在运行期根据条件来控制加载class。</p><p>对任意的一个<code>Object</code>实例，只要我们获取了它的<code>Class</code>，就可以获取它的一切信息。</p><p>我们先看看如何通过<code>Class</code>实例获取字段信息。<code>Class</code>类提供了以下几个方法来获取字段：</p><ul><li>Field getField(name)：根据字段名获取某个public的field（包括父类）</li><li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li><li>Field[] getFields()：获取所有public的field（包括父类）</li><li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li></ul><p>我们来看一下示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">stdClass</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// 获取public字段&quot;score&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;score&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取继承的public字段&quot;name&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取private字段&quot;grade&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredField(<span class="string">&quot;grade&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先获取<code>Student</code>的<code>Class</code>实例，然后，分别获取<code>public</code>字段、继承的<code>public</code>字段以及<code>private</code>字段，打印出的<code>Field</code>类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int Student.score</span><br><span class="line">public java.lang.String Person.name</span><br><span class="line">private int Student.grade</span><br></pre></td></tr></table></figure><p>一个<code>Field</code>对象包含了一个字段的所有信息：</p><ul><li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li><li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li><li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><p>以<code>String</code>类的<code>value</code>字段为例，它的定义是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用反射获取该字段的信息，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">f.getName(); <span class="comment">// &quot;value&quot;</span></span><br><span class="line">f.getType(); <span class="comment">// class [B 表示byte[]类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isPublic(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(m); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="获取字段值">获取字段值</h3><p>利用反射拿到字段的一个<code>Field</code>实例只是第一步，我们还可以拿到一个实例对应的该字段的值。</p><p>例如，对于一个<code>Person</code>实例，我们可以先拿到<code>name</code>字段对应的<code>Field</code>，再获取这个实例的<code>name</code>字段的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> p.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> f.get(p);</span><br><span class="line">        System.out.println(value); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码先获取<code>Class</code>实例，再获取<code>Field</code>实例，然后，用<code>Field.get(Object)</code>获取指定实例的指定字段的值。</p><p>运行代码，如果不出意外，会得到一个<code>IllegalAccessException</code>，这是因为<code>name</code>被定义为一个<code>private</code>字段，正常情况下，<code>Main</code>类无法访问<code>Person</code>类的<code>private</code>字段。要修复错误，可以将<code>private</code>改为<code>public</code>，或者，在调用<code>Object value = f.get(p);</code>前，先写一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>调用<code>Field.setAccessible(true)</code>的意思是，别管这个字段是不是<code>public</code>，一律允许访问。</p><p>可以试着加上上述语句，再运行代码，就可以打印出<code>private</code>字段的值。</p><p>有童鞋会问：如果使用反射可以获取<code>private</code>字段的值，那么类的封装还有什么意义？</p><p>答案是正常情况下，我们总是通过<code>p.name</code>来访问<code>Person</code>的<code>name</code>字段，编译器会根据<code>public</code>、<code>protected</code>和<code>private</code>决定是否允许访问字段，这样就达到了数据封装的目的。</p><p>而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。</p><p>此外，<code>setAccessible(true)</code>可能会失败。如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p><h3 id="设置字段值">设置字段值</h3><p>通过Field实例既然可以获取到指定实例的字段值，自然也可以设置字段的值。</p><p>设置字段值是通过<code>Field.set(Object, Object)</code>实现的，其中第一个<code>Object</code>参数是指定的实例，第二个<code>Object</code>参数是待修改的值。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> p.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        f.set(p, <span class="string">&quot;Xiao Hong&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Hong&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，打印的<code>name</code>字段从<code>Xiao Ming</code>变成了<code>Xiao Hong</code>，说明通过反射可以直接修改字段的值。</p><p>同样的，修改非<code>public</code>字段，需要首先调用<code>setAccessible(true)</code>。</p><h3 id="练习">练习</h3><p>利用反射给字段赋值。</p><p><a href="https://liaoxuefeng.com/books/java/reflection/field/reflect-field.zip">下载练习</a></p><h3 id="小结-2">小结</h3><p>Java的反射API提供的<code>Field</code>类封装了字段的所有信息：</p><p>通过<code>Class</code>实例的方法可以获取<code>Field</code>实例：<code>getField()</code>，<code>getFields()</code>，<code>getDeclaredField()</code>，<code>getDeclaredFields()</code>；</p><p>通过Field实例可以获取字段信息：<code>getName()</code>，<code>getType()</code>，<code>getModifiers()</code>；</p><p>通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用<code>setAccessible(true)</code>来访问非<code>public</code>字段。</p><p>通过反射读写字段是一种非常规方法，它会破坏对象的封装。</p><p>我们已经能通过<code>Class</code>实例获取所有<code>Field</code>对象，同样的，可以通过<code>Class</code>实例获取所有<code>Method</code>信息。<code>Class</code>类提供了以下几个方法来获取<code>Method</code>：</p><ul><li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li><li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li></ul><p>我们来看一下示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">stdClass</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// 获取public方法getScore，参数为String:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getScore&quot;</span>, String.class));</span><br><span class="line">        <span class="comment">// 获取继承的public方法getName，无参数:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getName&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取private方法getGrade，参数为int:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredMethod(<span class="string">&quot;getGrade&quot;</span>, <span class="type">int</span>.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getGrade</span><span class="params">(<span class="type">int</span> year)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先获取<code>Student</code>的<code>Class</code>实例，然后，分别获取<code>public</code>方法、继承的<code>public</code>方法以及<code>private</code>方法，打印出的<code>Method</code>类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int Student.getScore(java.lang.String)</span><br><span class="line">public java.lang.String Person.getName()</span><br><span class="line">private int Student.getGrade(int)</span><br></pre></td></tr></table></figure><p>一个<code>Method</code>对象包含一个方法的所有信息：</p><ul><li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li><li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li><li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li><li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><h3 id="调用方法">调用方法</h3><p>当我们获取到一个<code>Method</code>对象时，就可以对它进行调用。我们以下面的代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> s.substring(<span class="number">6</span>); <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure><p>如果用反射来调用<code>substring</code>方法，需要以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> String.class.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r); <span class="comment">// &quot;world&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>substring()</code>有两个重载方法，我们获取的是<code>String substring(int)</code>这个方法。思考一下如何获取<code>String substring(int, int)</code>方法。</p><p>对<code>Method</code>实例调用<code>invoke</code>就相当于调用该方法，<code>invoke</code>的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。</p><h3 id="调用静态方法">调用静态方法</h3><p>如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以<code>invoke</code>方法传入的第一个参数永远为<code>null</code>。我们以<code>Integer.parseInt(String)</code>为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取Integer.parseInt(String)方法，参数为String:</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> Integer.class.getMethod(<span class="string">&quot;parseInt&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// 调用该静态方法并获取结果:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> (Integer) m.invoke(<span class="literal">null</span>, <span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用非public方法">调用非public方法</h3><p>和Field类似，对于非public方法，我们虽然可以通过<code>Class.getDeclaredMethod()</code>获取该方法实例，但直接对其调用将得到一个<code>IllegalAccessException</code>。为了调用非public方法，我们通过<code>Method.setAccessible(true)</code>允许其调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> p.getClass().getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        m.invoke(p, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，<code>setAccessible(true)</code>可能会失败。如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p><h3 id="多态">多态</h3><p>我们来考察这样一种情况：一个<code>Person</code>类定义了<code>hello()</code>方法，并且它的子类<code>Student</code>也覆写了<code>hello()</code>方法，那么，从<code>Person.class</code>获取的<code>Method</code>，作用于<code>Student</code>实例时，调用的方法到底是哪个？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取Person的hello方法:</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">h</span> <span class="operator">=</span> Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// 对Student实例调用hello方法:</span></span><br><span class="line">        h.invoke(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，发现打印出的是<code>Student:hello</code>，因此，使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。上述的反射代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">m.invoke(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br></pre></td></tr></table></figure><p>实际上相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">p.hello();</span><br></pre></td></tr></table></figure><h3 id="练习-2">练习</h3><p>利用反射调用方法。</p><p><a href="https://liaoxuefeng.com/books/java/reflection/method/reflect-method.zip">下载练习</a></p><h3 id="小结-3">小结</h3><p>Java的反射API提供的Method对象封装了方法的所有信息：</p><p>通过<code>Class</code>实例的方法可以获取<code>Method</code>实例：<code>getMethod()</code>，<code>getMethods()</code>，<code>getDeclaredMethod()</code>，<code>getDeclaredMethods()</code>；</p><p>通过<code>Method</code>实例可以获取方法信息：<code>getName()</code>，<code>getReturnType()</code>，<code>getParameterTypes()</code>，<code>getModifiers()</code>；</p><p>通过<code>Method</code>实例可以调用某个对象的方法：<code>Object invoke(Object instance, Object... parameters)</code>；</p><p>通过设置<code>setAccessible(true)</code>来访问非<code>public</code>方法；</p><p>通过反射调用方法时，仍然遵循多态原则。</p><h2 id="调用构造方法">调用构造方法</h2><p>我们通常使用<code>new</code>操作符创建新的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure><p>如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> Person.class.newInstance();</span><br></pre></td></tr></table></figure><p>调用<code>Class.newInstance()</code>的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过<code>Class.newInstance()</code>来调用。</p><p>为了调用任意的构造方法，Java的反射API提供了<code>Constructor</code>对象，它包含一个构造方法的所有信息，可以创建一个实例。<code>Constructor</code>对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons1</span> <span class="operator">=</span> Integer.class.getConstructor(<span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons2</span> <span class="operator">=</span> Integer.class.getConstructor(String.class);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> (Integer) cons2.newInstance(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Class实例获取Constructor的方法如下：</p><ul><li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li><li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li></ul><p>注意<code>Constructor</code>总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。</p><p>调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败。</p><h3 id="小结-4">小结</h3><p><code>Constructor</code>对象封装了构造方法的所有信息；</p><p>通过<code>Class</code>实例的方法可以获取<code>Constructor</code>实例：<code>getConstructor()</code>，<code>getConstructors()</code>，<code>getDeclaredConstructor()</code>，<code>getDeclaredConstructors()</code>；</p><p>通过<code>Constructor</code>实例可以创建一个实例对象：<code>newInstance(Object... parameters)</code>； 通过设置<code>setAccessible(true)</code>来访问非<code>public</code>构造方法。</p><hr><hr><p>当我们获取到某个<code>Class</code>对象时，实际上就获取到了一个类的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class; <span class="comment">// 获取到String的Class</span></span><br></pre></td></tr></table></figure><p>还可以用实例的<code>getClass()</code>方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> s.getClass(); <span class="comment">// s是String，因此获取到String的Class</span></span><br></pre></td></tr></table></figure><p>最后一种获取<code>Class</code>的方法是通过<code>Class.forName(&quot;&quot;)</code>，传入<code>Class</code>的完整类名获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">s</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure><p>这三种方式获取的<code>Class</code>实例都是同一个实例，因为JVM对每个加载的<code>Class</code>只创建一个<code>Class</code>实例来表示它的类型。</p><h3 id="获取父类的Class">获取父类的Class</h3><p>有了<code>Class</code>实例，我们还可以获取它的父类的<code>Class</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">i</span> <span class="operator">=</span> Integer.class;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">n</span> <span class="operator">=</span> i.getSuperclass();</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">o</span> <span class="operator">=</span> n.getSuperclass();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(o.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，可以看到，<code>Integer</code>的父类类型是<code>Number</code>，<code>Number</code>的父类是<code>Object</code>，<code>Object</code>的父类是<code>null</code>。除<code>Object</code>外，其他任何非<code>interface</code>的<code>Class</code>都必定存在一个父类类型。</p><h3 id="获取interface">获取interface</h3><p>由于一个类可能实现一个或多个接口，通过<code>Class</code>我们就可以查询到实现的接口类型。例如，查询<code>Integer</code>实现的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">s</span> <span class="operator">=</span> Integer.class;</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码可知，<code>Integer</code>实现的接口有：</p><ul><li>java.lang.Comparable</li><li>java.lang.constant.Constable</li><li>java.lang.constant.ConstantDesc</li></ul><p>要特别注意：<code>getInterfaces()</code>只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">s</span> <span class="operator">=</span> Integer.class.getSuperclass();</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Integer</code>的父类是<code>Number</code>，<code>Number</code>实现的接口是<code>java.io.Serializable</code>。</p><p>此外，对所有<code>interface</code>的<code>Class</code>调用<code>getSuperclass()</code>返回的是<code>null</code>，获取接口的父接口要用<code>getInterfaces()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(java.io.DataInputStream.class.getSuperclass()); <span class="comment">// java.io.FilterInputStream，因为DataInputStream继承自FilterInputStream</span></span><br><span class="line">System.out.println(java.io.Closeable.class.getSuperclass()); <span class="comment">// null，对接口调用getSuperclass()总是返回null，获取接口的父接口要用getInterfaces()</span></span><br></pre></td></tr></table></figure><p>如果一个类没有实现任何<code>interface</code>，那么<code>getInterfaces()</code>返回空数组。</p><h3 id="继承关系">继承关系</h3><p>当我们判断一个实例是否是某个类型时，正常情况下，使用<code>instanceof</code>操作符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">n</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isDouble</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Double; <span class="comment">// false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isInteger</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Integer; <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isNumber</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Number; <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isSerializable</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> java.io.Serializable; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果是两个<code>Class</code>实例，要判断一个向上转型是否成立，可以调用<code>isAssignableFrom()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Integer</span></span><br><span class="line"><span class="comment">// Number n = ?</span></span><br><span class="line">Number.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line"><span class="comment">// Object o = ?</span></span><br><span class="line">Object.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Object</span></span><br><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Number.class); <span class="comment">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure><h3 id="小结-5">小结</h3><p>通过<code>Class</code>对象可以获取继承关系：</p><ul><li><code>Class getSuperclass()</code>：获取父类类型；</li><li><code>Class[] getInterfaces()</code>：获取当前类实现的所有接口。</li></ul><p>通过<code>Class</code>对象的<code>isAssignableFrom()</code>方法可以判断一个向上转型是否可以实现。</p><h2 id="动态代理">动态代理</h2><p>我们来比较Java的<code>class</code>和<code>interface</code>的区别：</p><ul><li>可以实例化<code>class</code>（非<code>abstract</code>）；</li><li>不能实例化<code>interface</code>。</li></ul><p>所有<code>interface</code>类型的变量总是通过某个实例向上转型并赋值给接口类型变量的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CharSequence</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure><p>有没有可能不编写实现类，直接在运行期创建某个<code>interface</code>的实例呢？</p><p>这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个<code>interface</code>的实例。</p><p>什么叫运行期动态创建？听起来好像很复杂。所谓动态代理，是和静态相对应的。我们来看静态代码怎么写：</p><p>定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Good morning, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建实例，转型为接口并调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloWorld</span>();</span><br><span class="line">hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br></pre></td></tr></table></figure><p>这种方式就是我们通常编写代码的方式。</p><p>还有一种方式是动态代码，我们仍然先定义了接口<code>Hello</code>，但是我们并不去编写实现类，而是直接通过JDK提供的一个<code>Proxy.newProxyInstance()</code>创建了一个<code>Hello</code>接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。</p><p>一个最简单的动态代理实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;morning&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Good morning, &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Hello.class &#125;, <span class="comment">// 传入要实现的接口</span></span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行期动态创建一个<code>interface</code>实例的方法如下：</p><ol><li>定义一个<code>InvocationHandler</code>实例，它负责实现接口的方法调用；</li><li>通过<code>Proxy.newProxyInstance()</code>创建<code>interface</code>实例，它需要3个参数：<ol><li>使用的<code>ClassLoader</code>，通常就是接口类的<code>ClassLoader</code>；</li><li>需要实现的接口数组，至少需要传入一个接口进去；</li><li>用来处理接口方法调用的<code>InvocationHandler</code>实例。</li></ol></li><li>将返回的<code>Object</code>强制转型为接口。</li></ol><p>动态代理实际上是JVM在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloDynamicProxy</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    InvocationHandler handler;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloDynamicProxy</span><span class="params">(InvocationHandler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        handler.invoke(</span><br><span class="line">           <span class="built_in">this</span>,</span><br><span class="line">           Hello.class.getMethod(<span class="string">&quot;morning&quot;</span>, String.class),</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; name &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是JVM帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。</p><h3 id="小结-6">小结</h3><p>Java标准库提供了动态代理功能，允许在运行期动态创建一个接口的实例；</p><p>动态代理是通过<code>Proxy</code>创建代理对象，然后将接口方法“代理”给<code>InvocationHandler</code>完成的。</p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-异常处理</title>
      <link href="/2025/05/23/java/JAVA-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2025/05/23/java/JAVA-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在计算机程序运行的过程中，总是会出现各种各样的错误。</p><p>有一些错误是用户造成的，比如，希望用户输入一个<code>int</code>类型的年龄，但是用户的输入是<code>abc</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设用户输入了abc：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(s); <span class="comment">// NumberFormatException!</span></span><br></pre></td></tr></table></figure><p>程序想要读写某个文件的内容，但是用户已经把它删除了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户删除了该文件：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> readFile(<span class="string">&quot;C:\\abc.txt&quot;</span>); <span class="comment">// FileNotFoundException!</span></span><br></pre></td></tr></table></figure><p>还有一些错误是随机出现，并且永远不可能避免的。比如：</p><ul><li>网络突然断了，连接不到远程服务器；</li><li>内存耗尽，程序崩溃了；</li><li>用户点“打印”，但根本没有打印机；</li><li>……</li></ul><p>所以，一个健壮的程序必须处理各种各样的错误。</p><p>所谓错误，就是程序调用某个函数的时候，如果失败了，就表示出错。</p><p>调用方如何获知调用失败的信息？有两种方法：</p><p>方法一：约定返回错误码。</p><p>例如，处理一个文件，如果返回<code>0</code>，表示成功，返回其他整数，表示约定的错误码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> processFile(<span class="string">&quot;C:\\test.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (code == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// ok:</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// error:</span></span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// file not found:</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// no read permission:</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// unknown error:</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为使用<code>int</code>类型的错误码，想要处理就非常麻烦。这种方式常见于底层C函数。</p><p>方法二：在语言层面上提供一个异常处理机制。</p><p>Java内置了一套异常处理机制，总是使用异常来表示错误。</p><p>异常是一种<code>class</code>，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> processFile(“C:\\test.txt”);</span><br><span class="line">    <span class="comment">// ok:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// file not found:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">    <span class="comment">// no read permission:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// io error:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// other error:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为Java的异常是<code>class</code>，它的继承关系如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">                     ┌───────────┐</span><br><span class="line">                     │  Object   │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                           │</span><br><span class="line">                     ┌───────────┐</span><br><span class="line">                     │ Throwable │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                 ┌─────────┴─────────┐</span><br><span class="line">                 │                   │</span><br><span class="line">           ┌───────────┐       ┌───────────┐</span><br><span class="line">           │   Error   │       │ Exception │</span><br><span class="line">           └───────────┘       └───────────┘</span><br><span class="line">                 ▲                   ▲</span><br><span class="line">         ┌───────┘              ┌────┴──────────┐</span><br><span class="line">         │                      │               │</span><br><span class="line">┌─────────────────┐    ┌─────────────────┐┌───────────┐</span><br><span class="line">│OutOfMemoryError │... │RuntimeException ││IOException│...</span><br><span class="line">└─────────────────┘    └─────────────────┘└───────────┘</span><br><span class="line">                                ▲</span><br><span class="line">                    ┌───────────┴─────────────┐</span><br><span class="line">                    │                         │</span><br><span class="line">         ┌─────────────────────┐ ┌─────────────────────────┐</span><br><span class="line">         │NullPointerException │ │IllegalArgumentException │...</span><br><span class="line">         └─────────────────────┘ └─────────────────────────┘</span><br></pre></td></tr></table></figure><p>从继承关系可知：<code>Throwable</code>是异常体系的根，它继承自<code>Object</code>。<code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>，<code>Error</code>表示严重的错误，程序对此一般无能为力，例如：</p><ul><li><code>OutOfMemoryError</code>：内存耗尽</li><li><code>NoClassDefFoundError</code>：无法加载某个Class</li><li><code>StackOverflowError</code>：栈溢出</li></ul><p>而<code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p><p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p><ul><li><code>NumberFormatException</code>：数值类型的格式错误</li><li><code>FileNotFoundException</code>：未找到文件</li><li><code>SocketException</code>：读取网络失败</li></ul><p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p><ul><li><code>NullPointerException</code>：对某个<code>null</code>的对象调用方法或字段</li><li><code>IndexOutOfBoundsException</code>：数组索引越界</li></ul><p><code>Exception</code>又分为两大类：</p><ol><li><code>RuntimeException</code>以及它的子类；</li><li>非<code>RuntimeException</code>（包括<code>IOException</code>、<code>ReflectiveOperationException</code>等等）</li></ol><p>Java规定：</p><ul><li>必须捕获的异常，包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类，这种类型的异常称为Checked Exception。</li><li>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</li></ul><p>注意</p><p>编译器对RuntimeException及其子类不做强制捕获要求，不是指应用程序本身不应该捕获并处理RuntimeException。是否需要捕获，具体问题具体分析。</p><h3 id="捕获异常">捕获异常</h3><p>捕获异常使用<code>try...catch</code>语句，把可能发生异常的代码放到<code>try &#123;...&#125;</code>中，然后使用<code>catch</code>捕获对应的<code>Exception</code>及其子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try...catch</span></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:</span></span><br><span class="line">            System.out.println(e); <span class="comment">// 打印异常信息</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(); <span class="comment">// 尝试使用默认编码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不捕获<code>UnsupportedEncodingException</code>，会出现编译失败的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try...catch</span></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会报错，错误信息类似：unreported exception UnsupportedEncodingException; must be caught or declared to be thrown，并且准确地指出需要捕获的语句是<code>return s.getBytes(&quot;GBK&quot;);</code>。意思是说，像<code>UnsupportedEncodingException</code>这样的Checked Exception，必须被捕获。</p><p>这是因为<code>String.getBytes(String)</code>方法定义是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getBytes(String charsetName) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法定义的时候，使用<code>throws Xxx</code>表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。</p><p>在<code>toGBK()</code>方法中，因为调用了<code>String.getBytes(String)</code>方法，就必须捕获<code>UnsupportedEncodingException</code>。我们也可以不捕获它，而是在方法定义处用throws表示<code>toGBK()</code>方法可能会抛出<code>UnsupportedEncodingException</code>，就可以让<code>toGBK()</code>方法通过编译器检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try...catch</span></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码仍然会得到编译错误，但这一次，编译器提示的不是调用<code>return s.getBytes(&quot;GBK&quot;);</code>的问题，而是<code>byte[] bs = toGBK(&quot;中文&quot;);</code>。因为在<code>main()</code>方法中，调用<code>toGBK()</code>，没有捕获它声明的可能抛出的<code>UnsupportedEncodingException</code>。</p><p>修复方法是在<code>main()</code>方法中捕获异常并处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try...catch</span></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">            System.out.println(Arrays.toString(bs));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，只要是方法声明的Checked Exception，不在调用层捕获，也必须在更高的调用层捕获。所有未捕获的异常，最终也必须在<code>main()</code>方法中捕获，不会出现漏写<code>try</code>的情况。这是由编译器保证的。<code>main()</code>方法也是最后捕获<code>Exception</code>的机会。</p><p>如果是测试代码，上面的写法就略显麻烦。如果不想写任何<code>try</code>代码，可以直接把<code>main()</code>方法定义为<code>throws Exception</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try...catch</span></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>main()</code>方法声明了可能抛出<code>Exception</code>，也就声明了可能抛出所有的<code>Exception</code>，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。</p><p>还有一些童鞋喜欢在<code>toGBK()</code>内部“消化”异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 什么也不干</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>这种捕获后不处理的方式是非常不好的，即使真的什么也做不了，也要先把异常记录下来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 先记下来再说:</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>所有异常都可以调用<code>printStackTrace()</code>方法打印异常栈，这是一个简单有用的快速打印异常的方法。</p><h3 id="小结">小结</h3><p>Java使用异常来表示错误，并通过<code>try ... catch</code>捕获异常；</p><p>Java的异常是<code>class</code>，并且从<code>Throwable</code>继承；</p><p><code>Error</code>是无需捕获的严重错误，<code>Exception</code>是应该捕获的可处理的错误；</p><p><code>RuntimeException</code>无需强制捕获，非<code>RuntimeException</code>（Checked Exception）需强制捕获，或者用<code>throws</code>声明；</p><p>不推荐捕获了异常但不进行任何处理。</p><p>在Java中，凡是可能抛出异常的语句，都可以用<code>try ... catch</code>捕获。把可能发生异常的语句放在<code>try &#123; ... &#125;</code>中，然后使用<code>catch</code>捕获对应的<code>Exception</code>及其子类。</p><h3 id="多catch语句">多catch语句</h3><p>可以使用多个<code>catch</code>语句，每个<code>catch</code>分别捕获对应的<code>Exception</code>及其子类。JVM在捕获到异常后，会从上到下匹配<code>catch</code>语句，匹配到某个<code>catch</code>后，执行<code>catch</code>代码块，然后<em>不再</em>继续匹配。</p><p>简单地说就是：多个<code>catch</code>语句只有一个能被执行。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在多个<code>catch</code>的时候，<code>catch</code>的顺序非常重要：子类必须写在前面。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123; <span class="comment">// 永远捕获不到</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的代码，<code>UnsupportedEncodingException</code>异常是永远捕获不到的，因为它是<code>IOException</code>的子类。当抛出<code>UnsupportedEncodingException</code>异常时，会被<code>catch (IOException e) &#123; ... &#125;</code>捕获并执行。</p><p>因此，正确的写法是把子类放到前面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="finally语句">finally语句</h3><p>无论是否有异常发生，如果我们都希望执行一些语句，例如清理工作，怎么写？</p><p>可以把执行语句写若干遍：正常执行的放到<code>try</code>中，每个<code>catch</code>再写一遍。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码无论是否发生异常，都会执行<code>System.out.println(&quot;END&quot;);</code>这条语句。</p><p>那么如何消除这些重复的代码？Java的<code>try ... catch</code>机制还提供了<code>finally</code>语句，<code>finally</code>语句块保证有无错误都会执行。上述代码可以改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>finally</code>有几个特点：</p><ol><li><code>finally</code>语句不是必须的，可写可不写；</li><li><code>finally</code>总是最后执行。</li></ol><p>如果没有发生异常，就正常执行<code>try &#123; ... &#125;</code>语句块，然后执行<code>finally</code>。如果发生了异常，就中断执行<code>try &#123; ... &#125;</code>语句块，然后跳转执行匹配的<code>catch</code>语句块，最后执行<code>finally</code>。</p><p>可见，<code>finally</code>是用来保证一些代码必须执行的。</p><p>某些情况下，可以没有<code>catch</code>，只使用<code>try ... finally</code>结构。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为方法声明了可能抛出的异常，所以可以不写<code>catch</code>。</p><h3 id="捕获多种异常">捕获多种异常</h3><p>如果某些异常的处理逻辑相同，但是异常本身不存在继承关系，那么就得编写多条<code>catch</code>子句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为处理<code>IOException</code>和<code>NumberFormatException</code>的代码是相同的，所以我们可以把它两用<code>|</code>合并到一起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | NumberFormatException e) &#123;</span><br><span class="line">        <span class="comment">// IOException或NumberFormatException</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习">练习</h3><p>用<code>try ... catch</code>捕获异常并处理。</p><p><a href="https://liaoxuefeng.com/books/java/exception/catch-exception/exception-catch.zip">下载练习</a></p><h3 id="小结-2">小结</h3><p>捕获异常时，多个<code>catch</code>语句的匹配顺序非常重要，子类必须放在前面；</p><p><code>finally</code>语句保证了有无异常都会执行，它是可选的；</p><p>一个<code>catch</code>语句也可以匹配多个非继承关系的异常。</p><h3 id="异常的传播">异常的传播</h3><p>当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个<code>try ... catch</code>被捕获为止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exception</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process1</span><span class="params">()</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process2</span><span class="params">()</span> &#123;</span><br><span class="line">        Integer.parseInt(<span class="literal">null</span>); <span class="comment">// 会抛出NumberFormatException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>printStackTrace()</code>可以打印出方法的调用栈，类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NumberFormatException: <span class="literal">null</span></span><br><span class="line">    at java.base/java.lang.Integer.parseInt(Integer.java:<span class="number">614</span>)</span><br><span class="line">    at java.base/java.lang.Integer.parseInt(Integer.java:<span class="number">770</span>)</span><br><span class="line">    at Main.process2(Main.java:<span class="number">16</span>)</span><br><span class="line">    at Main.process1(Main.java:<span class="number">12</span>)</span><br><span class="line">    at Main.main(Main.java:<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><code>printStackTrace()</code>对于调试错误非常有用，上述信息表示：<code>NumberFormatException</code>是在<code>java.lang.Integer.parseInt</code>方法中被抛出的，从下往上看，调用层次依次是：</p><ol><li><code>main()</code>调用<code>process1()</code>；</li><li><code>process1()</code>调用<code>process2()</code>；</li><li><code>process2()</code>调用<code>Integer.parseInt(String)</code>；</li><li><code>Integer.parseInt(String)</code>调用<code>Integer.parseInt(String, int)</code>。</li></ol><p>查看<code>Integer.java</code>源码可知，抛出异常的方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parseInt</span><span class="params">(String s, <span class="type">int</span> radix)</span> <span class="keyword">throws</span> NumberFormatException &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NumberFormatException</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且，每层调用均给出了源代码的行号，可直接定位。</p><h3 id="抛出异常">抛出异常</h3><p>当发生错误时，例如，用户输入了非法的字符，我们就可以抛出异常。</p><p>如何抛出异常？参考<code>Integer.parseInt()</code>方法，抛出异常分两步：</p><ol><li>创建某个<code>Exception</code>的实例；</li><li>用<code>throw</code>语句抛出。</li></ol><p>下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">NullPointerException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，绝大部分抛出异常的代码都会合并写成一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个方法捕获了某个异常后，又在<code>catch</code>子句中抛出新的异常，就相当于把抛出的异常类型“转换”了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process1</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>process2()</code>抛出<code>NullPointerException</code>后，被<code>process1()</code>捕获，然后抛出<code>IllegalArgumentException()</code>。</p><p>如果在<code>main()</code>中捕获<code>IllegalArgumentException</code>，我们看看打印的异常栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exception</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的异常栈类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException</span><br><span class="line">    at Main.process1(Main.java:15)</span><br><span class="line">    at Main.main(Main.java:5)</span><br></pre></td></tr></table></figure><p>这说明新的异常丢失了原始异常信息，我们已经看不到原始异常<code>NullPointerException</code>的信息了。</p><p>为了能追踪到完整的异常栈，在构造异常的时候，把原始的<code>Exception</code>实例传进去，新的<code>Exception</code>就可以持有原始<code>Exception</code>信息。对上述代码改进如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exception</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，打印出的异常栈类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: java.lang.NullPointerException</span><br><span class="line">    at Main.process1(Main.java:15)</span><br><span class="line">    at Main.main(Main.java:5)</span><br><span class="line">Caused by: java.lang.NullPointerException</span><br><span class="line">    at Main.process2(Main.java:20)</span><br><span class="line">    at Main.process1(Main.java:13)</span><br></pre></td></tr></table></figure><p>注意到<code>Caused by: Xxx</code>，说明捕获的<code>IllegalArgumentException</code>并不是造成问题的根源，根源在于<code>NullPointerException</code>，是在<code>Main.process2()</code>方法抛出的。</p><p>在代码中获取原始异常可以使用<code>Throwable.getCause()</code>方法。如果返回<code>null</code>，说明已经是“根异常”了。</p><p>有了完整的异常栈的信息，我们才能快速定位并修复代码的问题。</p><p>最佳实践</p><p>捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场！</p><p>如果我们在<code>try</code>或者<code>catch</code>语句块中抛出异常，<code>finally</code>语句是否会执行？例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exception</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer.parseInt(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catched&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">catched</span><br><span class="line">finally</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: java.lang.NumberFormatException: For input string: &quot;abc&quot;</span><br><span class="line">    at Main.main(Main.java:8)</span><br><span class="line">Caused by: java.lang.NumberFormatException: For input string: &quot;abc&quot;</span><br><span class="line">    at ...</span><br></pre></td></tr></table></figure><p>第一行打印了<code>catched</code>，说明进入了<code>catch</code>语句块。第二行打印了<code>finally</code>，说明执行了<code>finally</code>语句块。</p><p>因此，在<code>catch</code>中抛出异常，不会影响<code>finally</code>的执行。JVM会先执行<code>finally</code>，然后抛出异常。</p><h3 id="异常屏蔽">异常屏蔽</h3><p>如果在执行<code>finally</code>语句时抛出异常，那么，<code>catch</code>语句的异常还能否继续抛出？例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exception</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer.parseInt(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catched&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，发现异常信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">catched</span><br><span class="line">finally</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException</span><br><span class="line">    at Main.main(Main.java:11)</span><br></pre></td></tr></table></figure><p>这说明<code>finally</code>抛出异常后，原来在<code>catch</code>中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）。</p><p>在极少数的情况下，我们需要获知所有的异常。如何保存所有的异常信息？方法是先用<code>origin</code>变量保存原始异常，然后调用<code>Throwable.addSuppressed()</code>，把原始异常添加进来，最后在<code>finally</code>抛出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exception</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">origin</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Integer.parseInt(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            origin = e;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">            <span class="keyword">if</span> (origin != <span class="literal">null</span>) &#123;</span><br><span class="line">                e.addSuppressed(origin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>catch</code>和<code>finally</code>都抛出了异常时，虽然<code>catch</code>的异常被屏蔽了，但是，<code>finally</code>抛出的异常仍然包含了它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException</span><br><span class="line">    at Main.main(Main.java:11)</span><br><span class="line">Suppressed: java.lang.NumberFormatException: For input string: &quot;abc&quot;</span><br><span class="line">    at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)</span><br><span class="line">    at java.base/java.lang.Integer.parseInt(Integer.java:652)</span><br><span class="line">    at java.base/java.lang.Integer.parseInt(Integer.java:770)</span><br><span class="line">    at Main.main(Main.java:6)</span><br></pre></td></tr></table></figure><p>通过<code>Throwable.getSuppressed()</code>可以获取所有的<code>Suppressed Exception</code>。</p><p>绝大多数情况下，在<code>finally</code>中不要抛出异常。因此，我们通常不需要关心<code>Suppressed Exception</code>。</p><h3 id="提问时贴出异常">提问时贴出异常</h3><p>异常打印的详细的栈信息是找出问题的关键，许多初学者在提问时只贴代码，不贴异常，相当于只报案不给线索，福尔摩斯也无能为力。</p><p>还有的童鞋只贴部分异常信息，最关键的<code>Caused by: xxx</code>给省略了，这都属于不正确的提问方式，得改。</p><h3 id="练习-2">练习</h3><p>如果传入的参数为负，则抛出<code>IllegalArgumentException</code>。</p><p><a href="https://liaoxuefeng.com/books/java/exception/throw-exception/exception-throw.zip">下载练习</a></p><h3 id="小结-3">小结</h3><p>调用<code>printStackTrace()</code>可以打印异常的传播栈，对于调试非常有用；</p><p>捕获异常并再次抛出新的异常时，应该持有原始异常信息；</p><p>通常不要在<code>finally</code>中抛出异常。如果在<code>finally</code>中抛出异常，应该原始异常加入到原有异常中。调用方可通过<code>Throwable.getSuppressed()</code>获取所有添加的<code>Suppressed Exception</code>。</p><h2 id="自定义异常">自定义异常</h2><p>Java标准库定义的常用异常包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Exception</span><br><span class="line">├─ RuntimeException</span><br><span class="line">│  ├─ NullPointerException</span><br><span class="line">│  ├─ IndexOutOfBoundsException</span><br><span class="line">│  ├─ SecurityException</span><br><span class="line">│  └─ IllegalArgumentException</span><br><span class="line">│     └─ NumberFormatException</span><br><span class="line">├─ IOException</span><br><span class="line">│  ├─ UnsupportedCharsetException</span><br><span class="line">│  ├─ FileNotFoundException</span><br><span class="line">│  └─ SocketException</span><br><span class="line">├─ ParseException</span><br><span class="line">├─ GeneralSecurityException</span><br><span class="line">├─ SQLException</span><br><span class="line">└─ TimeoutException</span><br></pre></td></tr></table></figure><p>当我们在代码中需要抛出异常时，尽量使用JDK已定义的异常类型。例如，参数检查不合法，应该抛出<code>IllegalArgumentException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process1</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (age &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。</p><p>一个常见的做法是自定义一个<code>BaseException</code>作为“根异常”，然后，派生出各种业务类型的异常。</p><p><code>BaseException</code>需要从一个适合的<code>Exception</code>派生，通常建议从<code>RuntimeException</code>派生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他业务类型的异常就可以从<code>BaseException</code>派生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserNotFoundException</span> <span class="keyword">extends</span> <span class="title class_">BaseException</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFailedException</span> <span class="keyword">extends</span> <span class="title class_">BaseException</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>自定义的<code>BaseException</code>应该提供多个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述构造方法实际上都是原样照抄<code>RuntimeException</code>。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。</p><h3 id="练习-3">练习</h3><p>请从<code>BaseException</code>派生自定义异常。</p><p><a href="https://liaoxuefeng.com/books/java/exception/custom-exception/exception-custom.zip">下载练习</a></p><h3 id="小结-4">小结</h3><p>抛出异常时，尽量复用JDK已定义的异常类型；</p><p>自定义异常体系时，推荐从<code>RuntimeException</code>派生“根异常”，再派生出业务异常；</p><p>自定义异常时，应该提供多种构造方法。</p><hr><hr><p>在所有的<code>RuntimeException</code>异常中，Java程序员最熟悉的恐怕就是<code>NullPointerException</code>了。</p><p><code>NullPointerException</code>即空指针异常，俗称NPE。如果一个对象为<code>null</code>，调用其方法或访问其字段就会产生<code>NullPointerException</code>，这个异常通常是由JVM抛出的，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NullPointerException</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(s.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针这个概念实际上源自C语言，Java语言中并无指针。我们定义的变量实际上是引用，Null Pointer更确切地说是Null Reference，不过两者区别不大。</p><h3 id="处理NullPointerException">处理NullPointerException</h3><p>如果遇到<code>NullPointerException</code>，我们应该如何处理？首先，必须明确，<code>NullPointerException</code>是一种代码逻辑错误，遇到<code>NullPointerException</code>，遵循原则是早暴露，早修复，严禁使用<code>catch</code>来隐藏这种编码错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例: 捕获NullPointerException</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    transferMoney(from, to, amount);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的编码习惯可以极大地降低<code>NullPointerException</code>的产生，例如：</p><p>成员变量在定义时初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用空字符串<code>&quot;&quot;</code>而不是默认的<code>null</code>可避免很多<code>NullPointerException</code>，编写业务逻辑时，用空字符串<code>&quot;&quot;</code>表示未填写比<code>null</code>安全得多。</p><p>返回空字符串<code>&quot;&quot;</code>、空数组而不是<code>null</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] readLinesFromFile(String file) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getFileSize(file) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回空数组而不是null:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以使得调用方无需检查结果是否为<code>null</code>。</p><p>如果调用方一定要根据<code>null</code>判断，比如返回<code>null</code>表示文件不存在，那么考虑返回<code>Optional&lt;T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title function_">readFromFile</span><span class="params">(String file)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fileExist(file)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样调用方必须通过<code>Optional.isPresent()</code>判断是否有结果。</p><h3 id="定位NullPointerException">定位NullPointerException</h3><p>如果产生了<code>NullPointerException</code>，例如，调用<code>a.b.c.x()</code>时产生了<code>NullPointerException</code>，原因可能是：</p><ul><li><code>a</code>是<code>null</code>；</li><li><code>a.b</code>是<code>null</code>；</li><li><code>a.b.c</code>是<code>null</code>；</li></ul><p>确定到底是哪个对象是<code>null</code>以前只能打印这样的日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(a.b);</span><br><span class="line">System.out.println(a.b.c);</span><br></pre></td></tr></table></figure><p>从Java 14开始，如果产生了<code>NullPointerException</code>，JVM可以给出详细的信息告诉我们<code>null</code>对象到底是谁。我们来看例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        System.out.println(p.address.city.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String[] name = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    String city;</span><br><span class="line">    String street;</span><br><span class="line">    String zipcode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在<code>NullPointerException</code>的详细信息中看到类似<code>... because &quot;&lt;local1&gt;.address.city&quot; is null</code>，意思是<code>city</code>字段为<code>null</code>，这样我们就能快速定位问题所在。</p><p>这种增强的<code>NullPointerException</code>详细信息是Java 14新增的功能，但默认是关闭的，我们可以给JVM添加一个<code>-XX:+ShowCodeDetailsInExceptionMessages</code>参数启用它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+ShowCodeDetailsInExceptionMessages Main.java</span><br></pre></td></tr></table></figure><h3 id="小结-5">小结</h3><p><code>NullPointerException</code>是Java代码常见的逻辑错误，应当早暴露，早修复；</p><p>可以启用Java 14的增强异常信息来查看<code>NullPointerException</code>的详细错误信息。</p><h2 id="使用断言">使用断言</h2><p>断言（Assertion）是一种调试程序的方式。在Java中，使用<code>assert</code>关键字来实现断言。</p><p>我们先看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> Math.abs(-<span class="number">123.45</span>);</span><br><span class="line">    <span class="keyword">assert</span> x &gt;= <span class="number">0</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句<code>assert x &gt;= 0;</code>即为断言，断言条件<code>x &gt;= 0</code>预期为<code>true</code>。如果计算结果为<code>false</code>，则断言失败，抛出<code>AssertionError</code>。</p><p>使用<code>assert</code>语句时，还可以添加一个可选的断言消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">&quot;x must &gt;= 0&quot;</span>;</span><br></pre></td></tr></table></figure><p>这样，断言失败的时候，<code>AssertionError</code>会带上消息<code>x must &gt;= 0</code>，更加便于调试。</p><p>Java断言的特点是：断言失败时会抛出<code>AssertionError</code>，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。</p><p>对于可恢复的程序错误，不应该使用断言。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> arr != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该抛出异常并在上层捕获：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;array cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在程序中使用<code>assert</code>时，例如，一个简单的断言：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assert</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">assert</span> x &gt; <span class="number">0</span>;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断言<code>x</code>必须大于<code>0</code>，实际上<code>x</code>为<code>-1</code>，断言肯定失败。执行上述代码，发现程序并未抛出<code>AssertionError</code>，而是正常打印了<code>x</code>的值。</p><p>这是怎么回事？为什么<code>assert</code>语句不起作用？</p><p>这是因为JVM默认关闭断言指令，即遇到<code>assert</code>语句就自动忽略了，不执行。</p><p>要执行<code>assert</code>语句，必须给Java虚拟机传递<code>-enableassertions</code>（可简写为<code>-ea</code>）参数启用断言。所以，上述程序必须在命令行下运行才有效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ java -ea Main.java</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.AssertionError</span><br><span class="line">at Main.main(Main.java:5)</span><br></pre></td></tr></table></figure><p>还可以有选择地对特定地类启用断言，命令行参数是：<code>-ea:com.itranswarp.sample.Main</code>，表示只对<code>com.itranswarp.sample.Main</code>这个类启用断言。</p><p>或者对特定地包启用断言，命令行参数是：<code>-ea:com.itranswarp.sample...</code>（注意结尾有3个<code>.</code>），表示对<code>com.itranswarp.sample</code>这个包启动断言。</p><p>实际开发中，很少使用断言。更好的方法是编写单元测试，后续我们会讲解<code>JUnit</code>的使用。</p><h3 id="小结-6">小结</h3><p>断言是一种调试方式，断言失败会抛出<code>AssertionError</code>，只能在开发和测试阶段启用断言；</p><p>对可恢复的错误不能使用断言，而应该抛出异常；</p><p>断言很少被使用，更好的方法是编写单元测试。</p><hr><hr><h2 id="使用JDK-Logging">使用JDK Logging</h2><p>在编写程序的过程中，发现程序运行结果与预期不符，怎么办？当然是用<code>System.out.println()</code>打印出执行过程中的某些变量，观察每一步的结果与代码逻辑是否符合，然后有针对性地修改代码。</p><p>代码改好了怎么办？当然是删除没有用的<code>System.out.println()</code>语句了。</p><p>如果改代码又改出问题怎么办？再加上<code>System.out.println()</code>。</p><p>反复这么搞几次，很快大家就发现使用<code>System.out.println()</code>非常麻烦。</p><p>怎么办？</p><p>解决方法是使用日志。</p><p>那什么是日志？日志就是Logging，它的目的是为了取代<code>System.out.println()</code>。</p><p>输出日志，而不是用<code>System.out.println()</code>，有以下几个好处：</p><ol><li>可以设置输出样式，避免自己每次都写<code>&quot;ERROR: &quot; + var</code>；</li><li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；</li><li>可以被重定向到文件，这样可以在程序运行结束后查看日志；</li><li>可以按包名控制日志级别，只输出某些包打的日志；</li><li>可以……</li></ol><p>总之就是好处很多啦。</p><p>那如何使用日志？</p><p>因为Java标准库内置了日志包<code>java.util.logging</code>，我们可以直接用。先看一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// logging</span></span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getGlobal();</span><br><span class="line">        logger.info(<span class="string">&quot;start process...&quot;</span>);</span><br><span class="line">        logger.warning(<span class="string">&quot;memory is running out...&quot;</span>);</span><br><span class="line">        logger.fine(<span class="string">&quot;ignored.&quot;</span>);</span><br><span class="line">        logger.severe(<span class="string">&quot;process will be terminated...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，得到类似如下的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mar 02, 2019 6:32:13 PM Hello main</span><br><span class="line">INFO: start process...</span><br><span class="line">Mar 02, 2019 6:32:13 PM Hello main</span><br><span class="line">WARNING: memory is running out...</span><br><span class="line">Mar 02, 2019 6:32:13 PM Hello main</span><br><span class="line">SEVERE: process will be terminated...</span><br></pre></td></tr></table></figure><p>对比可见，使用日志最大的好处是，它自动打印了时间、调用类、调用方法等很多有用的信息。</p><p>再仔细观察发现，4条日志，只打印了3条，<code>logger.fine()</code>没有打印。这是因为，日志的输出可以设定级别。JDK的Logging定义了7个日志级别，从严重到普通：</p><ul><li>SEVERE</li><li>WARNING</li><li>INFO</li><li>CONFIG</li><li>FINE</li><li>FINER</li><li>FINEST</li></ul><p>因为默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。</p><p>使用Java标准库内置的Logging有以下局限：</p><p>Logging系统在JVM启动时读取配置文件并完成初始化，一旦开始运行<code>main()</code>方法，就无法修改配置；</p><p>配置不太方便，需要在JVM启动时传递参数<code>-Djava.util.logging.config.file=&lt;config-file-name&gt;</code>。</p><p>因此，Java标准库内置的Logging使用并不是非常广泛。更方便的日志系统我们稍后介绍。</p><h3 id="练习-4">练习</h3><p>使用<code>logger.severe()</code>打印异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(Main.class.getName());</span><br><span class="line">        logger.info(<span class="string">&quot;Start process...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="string">&quot;&quot;</span>.getBytes(<span class="string">&quot;invalidCharsetName&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 使用logger.severe()打印异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;Process end.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/exception/jdk-logging/logging-jdk.zip">下载练习</a></p><h3 id="小结-7">小结</h3><p>日志是为了替代<code>System.out.println()</code>，可以定义格式，重定向到文件等；</p><p>日志可以存档，便于追踪问题；</p><p>日志记录可以按级别分类，便于打开或关闭某些级别；</p><p>可以根据配置文件调整日志，无需修改代码；</p><p>Java标准库提供了<code>java.util.logging</code>来实现日志功能。</p><hr><hr><p>和Java标准库提供的日志不同，Commons Logging是一个第三方日志库，它是由Apache创建的日志模块。</p><p>Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging。</p><p>使用Commons Logging只需要和两个类打交道，并且只有两步：</p><p>第一步，通过<code>LogFactory</code>获取<code>Log</code>类的实例； 第二步，使用<code>Log</code>实例的方法打日志。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.getLog(Main.class);</span><br><span class="line">        log.info(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;end.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，肯定会得到编译错误，类似<code>error: package org.apache.commons.logging does not exist</code>（找不到<code>org.apache.commons.logging</code>这个包）。因为Commons Logging是一个第三方提供的库，所以，必须先把它<a href="https://commons.apache.org/proper/commons-logging/download_logging.cgi">下载</a>下来。下载后，解压，找到<code>commons-logging-1.2.jar</code>这个文件，再把Java源码<code>Main.java</code>放到一个目录下，例如<code>work</code>目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">work</span><br><span class="line">├─ commons-logging-1.2.jar</span><br><span class="line">└─ Main.java</span><br></pre></td></tr></table></figure><p>然后用<code>javac</code>编译<code>Main.java</code>，编译的时候要指定<code>classpath</code>，不然编译器找不到我们引用的<code>org.apache.commons.logging</code>包。编译命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -cp commons-logging-1.2.jar Main.java</span><br></pre></td></tr></table></figure><p>如果编译成功，那么当前目录下就会多出一个<code>Main.class</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">work</span><br><span class="line">├─ commons-logging-1.2.jar</span><br><span class="line">├─ Main.java</span><br><span class="line">└─ Main.class</span><br></pre></td></tr></table></figure><p>现在可以执行这个<code>Main.class</code>，使用<code>java</code>命令，也必须指定<code>classpath</code>，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp .;commons-logging-1.2.jar Main</span><br></pre></td></tr></table></figure><p>注意到传入的<code>classpath</code>有两部分：一个是<code>.</code>，一个是<code>commons-logging-1.2.jar</code>，用<code>;</code>分割。<code>.</code>表示当前目录，如果没有这个<code>.</code>，JVM不会在当前目录搜索<code>Main.class</code>，就会报错。</p><p>如果在Linux或macOS下运行，注意<code>classpath</code>的分隔符不是<code>;</code>，而是<code>:</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp .:commons-logging-1.2.jar Main</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mar 02, 2019 7:15:31 PM Main main</span><br><span class="line">INFO: start...</span><br><span class="line">Mar 02, 2019 7:15:31 PM Main main</span><br><span class="line">WARNING: end.</span><br></pre></td></tr></table></figure><p>Commons Logging定义了6个日志级别：</p><ul><li>FATAL</li><li>ERROR</li><li>WARNING</li><li>INFO</li><li>DEBUG</li><li>TRACE</li></ul><p>默认级别是<code>INFO</code>。</p><p>使用Commons Logging时，如果在静态方法中引用<code>Log</code>，通常直接定义一个静态类型变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在静态方法中引用Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.getLog(Main.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实例方法中引用<code>Log</code>，通常定义一个实例变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在实例方法中引用Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到实例变量log的获取方式是<code>LogFactory.getLog(getClass())</code>，虽然也可以用<code>LogFactory.getLog(Person.class)</code>，但是前一种方式有个非常大的好处，就是子类可以直接使用该<code>log</code>实例。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在子类中使用父类实例化的log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Java类的动态特性，子类获取的<code>log</code>字段实际上相当于<code>LogFactory.getLog(Student.class)</code>，但却是从父类继承而来，并且无需改动代码。</p><p>此外，Commons Logging的日志方法，例如<code>info()</code>，除了标准的<code>info(String)</code>外，还提供了一个非常有用的重载方法：<code>info(String, Throwable)</code>，这使得记录异常更加简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;got exception!&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习-5">练习</h3><p>使用<code>log.error(String, Throwable)</code>打印异常。</p><p><a href="https://liaoxuefeng.com/books/java/exception/commons-logging/logging-commons.zip">下载练习</a></p><h3 id="小结-8">小结</h3><p>Commons Logging是使用最广泛的日志模块；</p><p>Commons Logging的API非常简单；</p><p>Commons Logging可以自动检测并使用其他日志模块。</p><p>前面介绍了Commons Logging，可以作为“日志接口”来使用。而真正的“日志实现”可以使用Log4j。</p><p>Log4j是一种非常流行的日志框架，最新版本是2.x。</p><p>Log4j是一个组件化设计的日志系统，它的架构大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">log.info(&quot;User signed in.&quot;);</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> ├──▶│ Appender │───▶│  Filter  │───▶│  Layout  │───▶│ Console  │</span><br><span class="line"> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> ├──▶│ Appender │───▶│  Filter  │───▶│  Layout  │───▶│   File   │</span><br><span class="line"> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> └──▶│ Appender │───▶│  Filter  │───▶│  Layout  │───▶│  Socket  │</span><br><span class="line">     └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br></pre></td></tr></table></figure><p>当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地。例如：</p><ul><li>console：输出到屏幕；</li><li>file：输出到文件；</li><li>socket：通过网络输出到远程计算机；</li><li>jdbc：输出到数据库</li></ul><p>在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出。例如，仅输出<code>ERROR</code>级别的日志。</p><p>最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。</p><p>上述结构虽然复杂，但我们在实际使用的时候，并不需要关心Log4j的API，而是通过配置文件来配置它。</p><p>以XML配置为例，使用Log4j的时候，我们把一个<code>log4j2.xml</code>的文件放到<code>classpath</code>下就可以让Log4j读取配置文件并按照我们的配置来输出日志。下面是一个配置文件的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义日志格式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;log.pattern&quot;</span>&gt;</span>%d&#123;MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125;%n%msg%n%n<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义文件名变量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.filename&quot;</span>&gt;</span>log/err.log<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.pattern&quot;</span>&gt;</span>log/err.%i.log.gz<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义Appender，即目的地 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到屏幕 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;err&quot;</span> <span class="attr">bufferedIO</span>=<span class="string">&quot;true&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;file.err.filename&#125;&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;file.err.pattern&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 根据文件大小自动切割日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;1 MB&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 保留最近10份 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对info级别的日志，输出到console --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;err&quot;</span> <span class="attr">level</span>=<span class="string">&quot;error&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然配置Log4j比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是<code>INFO</code>级别的日志，会自动输出到屏幕，而<code>ERROR</code>级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j就会自动切割新的日志文件，并最多保留10份。</p><p>有了配置文件还不够，因为Log4j也是一个第三方库，我们需要从<a href="https://logging.apache.org/log4j/2.x/download.html">这里</a>下载Log4j，解压后，把以下3个jar包放到<code>classpath</code>中：</p><ul><li>log4j-api-2.x.jar</li><li>log4j-core-2.x.jar</li><li>log4j-jcl-2.x.jar</li></ul><p>因为Commons Logging会自动发现并使用Log4j，所以，把上一节下载的<code>commons-logging-1.2.jar</code>也放到<code>classpath</code>中。</p><p>要打印日志，只需要按Commons Logging的写法写，不需要改动任何代码，就可以得到Log4j的日志输出，类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">03-03 12:09:45.880 [main] INFO  com.itranswarp.learnjava.Main</span><br><span class="line">Start process...</span><br></pre></td></tr></table></figure><h3 id="最佳实践">最佳实践</h3><p>在开发阶段，始终使用Commons Logging接口来写入日志，并且开发阶段无需引入Log4j。如果需要把日志写入文件，只需要把正确的配置文件和Log4j相关的jar包放入<code>classpath</code>，就可以自动把日志切换成使用Log4j写入，无需修改任何代码。</p><h3 id="练习-6">练习</h3><p>根据配置文件，观察Log4j写入的日志文件。</p><p><a href="https://liaoxuefeng.com/books/java/exception/log4j/logging-log4j.zip">下载练习</a></p><h3 id="小结-9">小结</h3><p>通过Commons Logging实现日志，不需要修改代码即可使用Log4j；</p><p>使用Log4j只需要把log4j2.xml和相关jar放入classpath；</p><p>如果要更换Log4j，只需要移除log4j2.xml和相关jar；</p><p>只有扩展Log4j时，才需要引用Log4j的接口（例如，将日志加密写入数据库的功能，需要自己开发）。</p><p>前面介绍了Commons Logging和Log4j这一对好基友，它们一个负责充当日志API，一个负责实现日志底层，搭配使用非常便于开发。</p><p>有的童鞋可能还听说过SLF4J和Logback。这两个东东看上去也像日志，它们又是啥？</p><p>其实SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现。</p><p>为什么有了Commons Logging和Log4j，又会蹦出来SLF4J和Logback？这是因为Java有着非常悠久的开源历史，不但OpenJDK本身是开源的，而且我们用到的第三方库，几乎全部都是开源的。开源生态丰富的一个特定就是，同一个功能，可以找到若干种互相竞争的开源库。</p><p>因为对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback。</p><p>我们先来看看SLF4J对Commons Logging的接口有何改进。在Commons Logging中，我们要打印日志，有时候得这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">log.info(<span class="string">&quot;Set score &quot;</span> + score + <span class="string">&quot; for Person &quot;</span> + p.getName() + <span class="string">&quot; ok.&quot;</span>);</span><br></pre></td></tr></table></figure><p>拼字符串是一个非常麻烦的事情，所以SLF4J的日志接口改进成这样了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">logger.info(<span class="string">&quot;Set score &#123;&#125; for Person &#123;&#125; ok.&quot;</span>, score, p.getName());</span><br></pre></td></tr></table></figure><p>我们靠猜也能猜出来，SLF4J的日志接口传入的是一个带占位符的字符串，用后面的变量自动替换占位符，所以看起来更加自然。</p><p>如何使用SLF4J？它的接口实际上和Commons Logging几乎一模一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下Commons Logging和SLF4J的接口：</p><table><thead><tr><th>Commons Logging</th><th>SLF4J</th></tr></thead><tbody><tr><td>org.apache.commons.logging.Log</td><td>org.slf4j.Logger</td></tr><tr><td>org.apache.commons.logging.LogFactory</td><td>org.slf4j.LoggerFactory</td></tr></tbody></table><p>不同之处就是<code>Log</code>变成了<code>Logger</code>，<code>LogFactory</code>变成了<code>LoggerFactory</code>。</p><p>使用SLF4J和Logback和前面讲到的使用Commons Logging加Log4j是类似的，先分别下载<a href="https://www.slf4j.org/download.html">SLF4J</a>和<a href="https://logback.qos.ch/download.html">Logback</a>，然后把以下jar包放到classpath下：</p><ul><li>slf4j-api-1.7.x.jar</li><li>logback-classic-1.2.x.jar</li><li>logback-core-1.2.x.jar</li></ul><p>然后使用SLF4J的<code>Logger</code>和<code>LoggerFactory</code>即可。</p><p>和Log4j类似，我们仍然需要一个Logback的配置文件，把<code>logback.xml</code>放到classpath下，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">file</span>&gt;</span>log/output.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>log/output.log.%i<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MaxFileSize</span>&gt;</span>1MB<span class="tag">&lt;/<span class="name">MaxFileSize</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行即可获得类似如下的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13:15:25.328 [main] INFO  com.itranswarp.learnjava.Main - Start process...</span><br></pre></td></tr></table></figure><p>从目前的趋势来看，越来越多的开源项目从Commons Logging加Log4j转向了SLF4J加Logback。</p><h3 id="练习-7">练习</h3><p>根据配置文件，观察Logback写入的日志文件。</p><p><a href="https://liaoxuefeng.com/books/java/exception/slf4j-logback/logging-slf4j.zip">下载练习</a></p><h3 id="小结-10">小结</h3><p>SLF4J和Logback可以取代Commons Logging和Log4j；</p><p>始终使用SLF4J的接口写入日志，使用Logback只需要配置，不需要修改代码。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-面向对象编程-核心类</title>
      <link href="/2025/05/23/java/JAVA-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E6%A0%B8%E5%BF%83%E7%B1%BB/"/>
      <url>/2025/05/23/java/JAVA-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E6%A0%B8%E5%BF%83%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="String">String</h3><p>在Java中，<code>String</code>是一个引用类型，它本身也是一个<code>class</code>。但是，Java编译器对<code>String</code>有特殊处理，即可以直接用<code>&quot;...&quot;</code>来表示一个字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello!&quot;</span>;</span><br></pre></td></tr></table></figure><p>实际上字符串在<code>String</code>内部是通过一个<code>char[]</code>数组表示的，因此，按下面的写法也是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;!&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure><p>因为<code>String</code>太常用了，所以Java提供了<code>&quot;...&quot;</code>这种字符串字面量表示方法。</p><p>Java字符串的一个重要特点就是字符串<em>不可变</em>。这种不可变性是通过内部的<code>private final char[]</code>字段，以及没有任何修改<code>char[]</code>的方法实现的。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        s = s.toUpperCase();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面代码的输出，试解释字符串内容是否改变。</p><h3 id="字符串比较">字符串比较</h3><p>当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用<code>equals()</code>方法而不能用<code>==</code>。</p><p>我们看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从表面上看，两个字符串用<code>==</code>和<code>equals()</code>比较都为<code>true</code>，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然<code>s1</code>和<code>s2</code>的引用就是相同的。</p><p>所以，这种<code>==</code>比较返回<code>true</code>纯属巧合。换一种写法，<code>==</code>比较就会失败：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;HELLO&quot;</span>.toLowerCase();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：两个字符串比较，必须总是使用<code>equals()</code>方法。</p><p>要忽略大小写比较，使用<code>equalsIgnoreCase()</code>方法。</p><p><code>String</code>类还提供了多种方法来搜索子串、提取子串。常用的方法有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否包含子串:</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.contains(<span class="string">&quot;ll&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注意到<code>contains()</code>方法的参数是<code>CharSequence</code>而不是<code>String</code>，因为<code>CharSequence</code>是<code>String</code>实现的一个接口。</p><p>搜索子串的更多的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.indexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.lastIndexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.startsWith(<span class="string">&quot;He&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.endsWith(<span class="string">&quot;lo&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>提取子串的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>); <span class="comment">// &quot;llo&quot;</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>, <span class="number">4</span>); <span class="string">&quot;ll&quot;</span></span><br></pre></td></tr></table></figure><p>注意索引号是从<code>0</code>开始的。</p><h3 id="去除首尾空白字符">去除首尾空白字符</h3><p>使用<code>trim()</code>方法可以移除字符串首尾空白字符。空白字符包括空格，<code>\t</code>，<code>\r</code>，<code>\n</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;  \tHello\r\n &quot;</span>.trim(); <span class="comment">// &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure><p>注意：<code>trim()</code>并没有改变字符串的内容，而是返回了一个新字符串。</p><p>另一个<code>strip()</code>方法也可以移除字符串首尾空白字符。它和<code>trim()</code>不同的是，类似中文的空格字符<code>\u3000</code>也会被移除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;\u3000Hello\u3000&quot;</span>.strip(); <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.stripLeading(); <span class="comment">// &quot;Hello &quot;</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.stripTrailing(); <span class="comment">// &quot; Hello&quot;</span></span><br></pre></td></tr></table></figure><p><code>String</code>还提供了<code>isEmpty()</code>和<code>isBlank()</code>来判断字符串是否为空和空白字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.isEmpty(); <span class="comment">// true，因为字符串长度为0</span></span><br><span class="line"><span class="string">&quot;  &quot;</span>.isEmpty(); <span class="comment">// false，因为字符串长度不为0</span></span><br><span class="line"><span class="string">&quot;  \n&quot;</span>.isBlank(); <span class="comment">// true，因为只包含空白字符</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.isBlank(); <span class="comment">// false，因为包含非空白字符</span></span><br></pre></td></tr></table></figure><h3 id="替换子串">替换子串</h3><p>要在字符串中替换子串，有两种方法。一种是根据字符或字符串替换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s.replace(<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;w&#x27;</span>); <span class="comment">// &quot;hewwo&quot;，所有字符&#x27;l&#x27;被替换为&#x27;w&#x27;</span></span><br><span class="line">s.replace(<span class="string">&quot;ll&quot;</span>, <span class="string">&quot;~~&quot;</span>); <span class="comment">// &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot;</span></span><br></pre></td></tr></table></figure><p>另一种是通过正则表达式替换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;A,,B;C ,D&quot;</span>;</span><br><span class="line">s.replaceAll(<span class="string">&quot;[\\,\\;\\s]+&quot;</span>, <span class="string">&quot;,&quot;</span>); <span class="comment">// &quot;A,B,C,D&quot;</span></span><br></pre></td></tr></table></figure><p>上面的代码通过正则表达式，把匹配的子串统一替换为<code>&quot;,&quot;</code>。关于正则表达式的用法我们会在后面详细讲解。</p><h3 id="分割字符串">分割字符串</h3><p>要分割字符串，使用<code>split()</code>方法，并且传入的也是正则表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;A,B,C,D&quot;</span>;</span><br><span class="line">String[] ss = s.split(<span class="string">&quot;\\,&quot;</span>); <span class="comment">// &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="拼接字符串">拼接字符串</h3><p>拼接字符串使用静态方法<code>join()</code>，它用指定的字符串连接字符串数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.join(<span class="string">&quot;***&quot;</span>, arr); <span class="comment">// &quot;A***B***C&quot;</span></span><br></pre></td></tr></table></figure><h3 id="格式化字符串">格式化字符串</h3><p>字符串提供了<code>formatted()</code>方法和<code>format()</code>静态方法，可以传入其他参数，替换占位符，然后生成新的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hi %s, your score is %d!&quot;</span>;</span><br><span class="line">        System.out.println(s.formatted(<span class="string">&quot;Alice&quot;</span>, <span class="number">80</span>));</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Hi %s, your score is %.2f!&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">59.5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几个占位符，后面就传入几个参数。参数类型要和占位符一致。我们经常用这个方法来格式化信息。常用的占位符有：</p><ul><li><code>%s</code>：显示字符串；</li><li><code>%d</code>：显示整数；</li><li><code>%x</code>：显示十六进制整数；</li><li><code>%f</code>：显示浮点数。</li></ul><p>占位符还可以带格式，例如<code>%.2f</code>表示显示两位小数。如果你不确定用啥占位符，那就始终用<code>%s</code>，因为<code>%s</code>可以显示任何数据类型。要查看完整的格式化语法，请参考<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Formatter.html#syntax">JDK文档</a>。</p><h3 id="类型转换">类型转换</h3><p>要把任意基本类型或引用类型转换为字符串，可以使用静态方法<code>valueOf()</code>。这是一个重载方法，编译器会根据参数自动选择合适的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String.valueOf(<span class="number">123</span>); <span class="comment">// &quot;123&quot;</span></span><br><span class="line">String.valueOf(<span class="number">45.67</span>); <span class="comment">// &quot;45.67&quot;</span></span><br><span class="line">String.valueOf(<span class="literal">true</span>); <span class="comment">// &quot;true&quot;</span></span><br><span class="line">String.valueOf(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 类似java.lang.Object@636be97c</span></span><br></pre></td></tr></table></figure><p>要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为<code>int</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;123&quot;</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;ff&quot;</span>, <span class="number">16</span>); <span class="comment">// 按十六进制转换，255</span></span><br></pre></td></tr></table></figure><p>把字符串转换为<code>boolean</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;FALSE&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>要特别注意，<code>Integer</code>有个<code>getInteger(String)</code>方法，它不是将字符串转换为<code>int</code>，而是把该字符串对应的系统变量转换为<code>Integer</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer.getInteger(<span class="string">&quot;java.version&quot;</span>); <span class="comment">// 版本号，11</span></span><br></pre></td></tr></table></figure><h3 id="转换为char">转换为char[]</h3><p><code>String</code>和<code>char[]</code>类型可以互相转换，方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] cs = <span class="string">&quot;Hello&quot;</span>.toCharArray(); <span class="comment">// String -&gt; char[]</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs); <span class="comment">// char[] -&gt; String</span></span><br></pre></td></tr></table></figure><p>如果修改了<code>char[]</code>数组，<code>String</code>并不会改变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String &lt;-&gt; char[]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs = <span class="string">&quot;Hello&quot;</span>.toCharArray();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        cs[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为通过<code>new String(char[])</code>创建新的<code>String</code>实例时，它并不会直接引用传入的<code>char[]</code>数组，而是会复制一份，所以，修改外部的<code>char[]</code>数组不会影响<code>String</code>实例内部的<code>char[]</code>数组，因为这是两个不同的数组。</p><p>从<code>String</code>的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用。</p><p>例如，下面的代码设计了一个<code>Score</code>类保存一组学生的成绩：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int[]</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] scores = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">88</span>, <span class="number">77</span>, <span class="number">51</span>, <span class="number">66</span> &#125;;</span><br><span class="line">        <span class="type">Score</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Score</span>(scores);</span><br><span class="line">        s.printScores();</span><br><span class="line">        scores[<span class="number">2</span>] = <span class="number">99</span>;</span><br><span class="line">        s.printScores();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] scores;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(<span class="type">int</span>[] scores)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.scores = scores;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScores</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Arrays.toString(scores));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察两次输出，由于<code>Score</code>内部直接引用了外部传入的<code>int[]</code>数组，这会造成外部代码对<code>int[]</code>数组的修改，影响到<code>Score</code>类的字段。如果外部代码不可信，这就会造成安全隐患。</p><p>请修复<code>Score</code>的构造方法，使得外部代码对数组的修改不影响<code>Score</code>实例的<code>int[]</code>字段。</p><h3 id="字符编码">字符编码</h3><p>在早期的计算机系统中，为了给字符编码，美国国家标准学会（American National Standard Institute：ANSI）制定了一套英文字母、数字和常用符号的编码，它占用一个字节，编码范围从<code>0</code>到<code>127</code>，最高位始终为<code>0</code>，称为<code>ASCII</code>编码。例如，字符<code>'A'</code>的编码是<code>0x41</code>，字符<code>'1'</code>的编码是<code>0x31</code>。</p><p>如果要把汉字也纳入计算机编码，很显然一个字节是不够的。<code>GB2312</code>标准使用两个字节表示一个汉字，其中第一个字节的最高位始终为<code>1</code>，以便和<code>ASCII</code>编码区分开。例如，汉字<code>'中'</code>的<code>GB2312</code>编码是<code>0xd6d0</code>。</p><p>类似的，日文有<code>Shift_JIS</code>编码，韩文有<code>EUC-KR</code>编码，这些编码因为标准不统一，同时使用，就会产生冲突。</p><p>为了统一全球所有语言的编码，全球统一码联盟发布了<code>Unicode</code>编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。</p><p><code>Unicode</code>编码需要两个或者更多字节表示，我们可以比较中英文字符在<code>ASCII</code>、<code>GB2312</code>和<code>Unicode</code>的编码：</p><p>英文字符<code>'A'</code>的<code>ASCII</code>编码和<code>Unicode</code>编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         ┌────┐</span><br><span class="line">ASCII:   │ 41 │</span><br><span class="line">         └────┘</span><br><span class="line">         ┌────┬────┐</span><br><span class="line">Unicode: │ 00 │ 41 │</span><br><span class="line">         └────┴────┘</span><br></pre></td></tr></table></figure><p>英文字符的<code>Unicode</code>编码就是简单地在前面添加一个<code>00</code>字节。</p><p>中文字符<code>'中'</code>的<code>GB2312</code>编码和<code>Unicode</code>编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         ┌────┬────┐</span><br><span class="line">GB2312:  │ d6 │ d0 │</span><br><span class="line">         └────┴────┘</span><br><span class="line">         ┌────┬────┐</span><br><span class="line">Unicode: │ 4e │ 2d │</span><br><span class="line">         └────┴────┘</span><br></pre></td></tr></table></figure><p>那我们经常使用的<code>UTF-8</code>又是什么编码呢？因为英文字符的<code>Unicode</code>编码高字节总是<code>00</code>，包含大量英文的文本会浪费空间，所以，出现了<code>UTF-8</code>编码，它是一种变长编码，用来把固定长度的<code>Unicode</code>编码变成1～4字节的变长编码。通过<code>UTF-8</code>编码，英文字符<code>'A'</code>的<code>UTF-8</code>编码变为<code>0x41</code>，正好和<code>ASCII</code>码一致，而中文<code>'中'</code>的<code>UTF-8</code>编码为3字节<code>0xe4b8ad</code>。</p><p><code>UTF-8</code>编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为<code>UTF-8</code>编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。</p><p>在Java中，<code>char</code>类型实际上就是两个字节的<code>Unicode</code>编码。如果我们要手动把字符串转换成其他编码，可以这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] b1 = <span class="string">&quot;Hello&quot;</span>.getBytes(); <span class="comment">// 按系统默认编码转换，不推荐</span></span><br><span class="line"><span class="type">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// 按UTF-8编码转换</span></span><br><span class="line"><span class="type">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;GBK&quot;</span>); <span class="comment">// 按GBK编码转换</span></span><br><span class="line"><span class="type">byte</span>[] b3 = <span class="string">&quot;Hello&quot;</span>.getBytes(StandardCharsets.UTF_8); <span class="comment">// 按UTF-8编码转换</span></span><br></pre></td></tr></table></figure><p>注意：转换编码后，就不再是<code>char</code>类型，而是<code>byte</code>类型表示的数组。</p><p>如果要把已知编码的<code>byte[]</code>转换为<code>String</code>，可以这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] b = ...</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="string">&quot;GBK&quot;</span>); <span class="comment">// 按GBK转换</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, StandardCharsets.UTF_8); <span class="comment">// 按UTF-8转换</span></span><br></pre></td></tr></table></figure><p>始终牢记：Java的<code>String</code>和<code>char</code>在内存中总是以Unicode编码表示。</p><h3 id="延伸阅读">延伸阅读</h3><p>对于不同版本的JDK，<code>String</code>类在内存中有不同的优化方式。具体来说，早期JDK版本的<code>String</code>总是以<code>char[]</code>存储，它的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而较新的JDK版本的<code>String</code>则以<code>byte[]</code>存储：如果<code>String</code>仅包含ASCII字符，则每个<code>byte</code>存储一个字符，否则，每两个<code>byte</code>存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的<code>String</code>通常仅包含ASCII字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder; <span class="comment">// 0 = LATIN1, 1 = UTF16</span></span><br></pre></td></tr></table></figure><p>对于使用者来说，<code>String</code>内部的优化不影响任何已有代码，因为它的<code>public</code>方法签名是不变的。</p><h3 id="小结">小结</h3><p>Java字符串<code>String</code>是不可变对象；</p><p>字符串操作不改变原字符串内容，而是返回新字符串；</p><p>常用的字符串操作：提取子串、查找、替换、大小写转换等；</p><p>Java使用Unicode编码表示<code>String</code>和<code>char</code>；</p><p>转换编码就是将<code>String</code>和<code>byte[]</code>转换，需要指定编码；</p><p>转换为<code>byte[]</code>时，始终优先考虑<code>UTF-8</code>编码。</p><p>Java编译器对<code>String</code>做了特殊处理，使得我们可以直接用<code>+</code>拼接字符串。</p><p>考察下面的循环代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    s = s + <span class="string">&quot;,&quot;</span> + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。</p><p>为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个可变对象，可以预分配缓冲区，这样，往<code>StringBuilder</code>中新增字符时，不会创建新的临时对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure><p><code>StringBuilder</code>还可以进行链式操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">1024</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;Mr &quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;!&quot;</span>)</span><br><span class="line">          .insert(<span class="number">0</span>, <span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们查看<code>StringBuilder</code>的源码，可以发现，进行链式操作的关键是，定义的<code>append()</code>方法会返回<code>this</code>，这样，就可以不断调用自身的其他方法。</p><p>仿照<code>StringBuilder</code>，我们也可以设计支持链式操作的类。例如，一个可以不断增加的计数器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Adder</span> <span class="variable">adder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adder</span>();</span><br><span class="line">        adder.add(<span class="number">3</span>)</span><br><span class="line">             .add(<span class="number">5</span>)</span><br><span class="line">             .inc()</span><br><span class="line">             .add(<span class="number">10</span>);</span><br><span class="line">        System.out.println(adder.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Adder <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        sum += n;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Adder <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">        sum ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：对于普通的字符串<code>+</code>操作，并不需要我们将其改写为<code>StringBuilder</code>，因为Java编译器在编译时就自动把多个连续的<code>+</code>操作编码为<code>StringConcatFactory</code>的操作。在运行期，<code>StringConcatFactory</code>会自动把字符串连接操作优化为数组复制或者<code>StringBuilder</code>操作。</p><p>你可能还听说过<code>StringBuffer</code>，这是Java早期的一个<code>StringBuilder</code>的线程安全版本，它通过同步来保证多个线程操作<code>StringBuffer</code>也是安全的，但是同步会带来执行速度的下降。</p><p><code>StringBuilder</code>和<code>StringBuffer</code>接口完全相同，现在完全没有必要使用<code>StringBuffer</code>。</p><h3 id="练习">练习</h3><p>请使用<code>StringBuilder</code>构造一个<code>INSERT</code>语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] fields = &#123; <span class="string">&quot;name&quot;</span>, <span class="string">&quot;position&quot;</span>, <span class="string">&quot;salary&quot;</span> &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">table</span> <span class="operator">=</span> <span class="string">&quot;employee&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">insert</span> <span class="operator">=</span> buildInsertSql(table, fields);</span><br><span class="line">        System.out.println(insert);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO employee (name, position, salary) VALUES (?, ?, ?)&quot;</span>;</span><br><span class="line">        System.out.println(s.equals(insert) ? <span class="string">&quot;测试成功&quot;</span> : <span class="string">&quot;测试失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">buildInsertSql</span><span class="params">(String table, String[] fields)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/oop/core/string-builder/core-stringbuilder.zip">下载练习</a></p><h3 id="小结-2">小结</h3><p><code>StringBuilder</code>是可变对象，用来高效拼接字符串；</p><p><code>StringBuilder</code>可以支持链式操作，实现链式操作的关键是返回实例本身；</p><p><code>StringBuffer</code>是<code>StringBuilder</code>的线程安全版本，现在很少使用。</p><h2 id="StringJoiner">StringJoiner</h2><p>要高效拼接字符串，应该使用<code>StringBuilder</code>。</p><p>很多时候，我们拼接的字符串像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出: Hello Bob, Alice, Grace!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sb.append(name).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意去掉最后的&quot;, &quot;:</span></span><br><span class="line">        sb.delete(sb.length() - <span class="number">2</span>, sb.length());</span><br><span class="line">        sb.append(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似用分隔符拼接数组的需求很常见，所以Java标准库还提供了一个<code>StringJoiner</code>来干这个事：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.StringJoiner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sj.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>慢着！用<code>StringJoiner</code>的结果少了前面的<code>&quot;Hello &quot;</code>和结尾的<code>&quot;!&quot;</code>！遇到这种情况，需要给<code>StringJoiner</code>指定“开头”和“结尾”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.StringJoiner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;Hello &quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sj.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String-join">String.join()</h3><p><code>String</code>还提供了一个静态方法<code>join()</code>，这个方法在内部使用了<code>StringJoiner</code>来拼接字符串，在不需要指定“开头”和“结尾”的时候，用<code>String.join()</code>更方便：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line"><span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> String.join(<span class="string">&quot;, &quot;</span>, names);</span><br></pre></td></tr></table></figure><h3 id="练习-2">练习</h3><p>请使用<code>StringJoiner</code>构造一个<code>SELECT</code>语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.StringJoiner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] fields = &#123; <span class="string">&quot;name&quot;</span>, <span class="string">&quot;position&quot;</span>, <span class="string">&quot;salary&quot;</span> &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">table</span> <span class="operator">=</span> <span class="string">&quot;employee&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">select</span> <span class="operator">=</span> buildSelectSql(table, fields);</span><br><span class="line">        System.out.println(select);</span><br><span class="line">        System.out.println(<span class="string">&quot;SELECT name, position, salary FROM employee&quot;</span>.equals(select) ? <span class="string">&quot;测试成功&quot;</span> : <span class="string">&quot;测试失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">buildSelectSql</span><span class="params">(String table, String[] fields)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/oop/core/string-joiner/core-stringjoiner.zip">下载练习</a></p><h3 id="小结-3">小结</h3><p>用指定分隔符拼接字符串数组时，使用<code>StringJoiner</code>或者<code>String.join()</code>更方便；</p><p>用<code>StringJoiner</code>拼接字符串时，还可以额外附加一个“开头”和“结尾”。</p><hr><hr><p>我们已经知道，Java的数据类型分两种：</p><ul><li>基本类型：<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>boolean</code>，<code>float</code>，<code>double</code>，<code>char</code>；</li><li>引用类型：所有<code>class</code>和<code>interface</code>类型。</li></ul><p>引用类型可以赋值为<code>null</code>，表示空，但基本类型不能赋值为<code>null</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>那么，如何把一个基本类型视为对象（引用类型）？</p><p>比如，想要把<code>int</code>基本类型变成一个引用类型，我们可以定义一个<code>Integer</code>类，它只包含一个实例字段<code>int</code>，这样，<code>Integer</code>类就可以视为<code>int</code>的包装类（Wrapper Class）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Integer</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好了<code>Integer</code>类，我们就可以把<code>int</code>和<code>Integer</code>互相转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">99</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> n2.intValue();</span><br></pre></td></tr></table></figure><p>实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：</p><table><thead><tr><th>基本类型</th><th>对应的引用类型</th></tr></thead><tbody><tr><td>boolean</td><td>java.lang.Boolean</td></tr><tr><td>byte</td><td>java.lang.Byte</td></tr><tr><td>short</td><td>java.lang.Short</td></tr><tr><td>int</td><td>java.lang.Integer</td></tr><tr><td>long</td><td>java.lang.Long</td></tr><tr><td>float</td><td>java.lang.Float</td></tr><tr><td>double</td><td>java.lang.Double</td></tr><tr><td>char</td><td>java.lang.Character</td></tr></tbody></table><p>我们可以直接使用，并不需要自己去定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 通过new操作符创建Integer实例(不推荐使用,会有编译警告):</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">        <span class="comment">// 通过静态方法valueOf(int)创建Integer实例:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> Integer.valueOf(i);</span><br><span class="line">        <span class="comment">// 通过静态方法valueOf(String)创建Integer实例:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n3</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        System.out.println(n3.intValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Auto-Boxing">Auto Boxing</h3><p>因为<code>int</code>和<code>Integer</code>可以互相转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> Integer.valueOf(i);</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> n.intValue();</span><br></pre></td></tr></table></figure><p>所以，Java编译器可以帮助我们自动在<code>int</code>和<code>Integer</code>之间转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 编译器自动使用Integer.valueOf(int)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> n; <span class="comment">// 编译器自动使用Integer.intValue()</span></span><br></pre></td></tr></table></figure><p>这种直接把<code>int</code>变为<code>Integer</code>的赋值写法，称为自动装箱（Auto Boxing），反过来，把<code>Integer</code>变为<code>int</code>的赋值写法，称为自动拆箱（Auto Unboxing）。</p><p>注意</p><p>自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。</p><p>装箱和拆箱会影响代码的执行效率，因为编译后的<code>class</code>代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报<code>NullPointerException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NullPointerException</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不变类">不变类</h3><p>所有的包装类型都是不变类。我们查看<code>Integer</code>的源码可知，它的核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，一旦创建了<code>Integer</code>对象，该对象就是不变的。</p><p>对两个<code>Integer</code>实例进行比较要特别注意：绝对不能用<code>==</code>比较，因为<code>Integer</code>是引用类型，必须使用<code>equals()</code>比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// == or equals?</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">99999</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">99999</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;x == y: &quot;</span> + (x==y)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;m == n: &quot;</span> + (m==n)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;x.equals(y): &quot;</span> + x.equals(y)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;m.equals(n): &quot;</span> + m.equals(n)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细观察结果的童鞋可以发现，<code>==</code>比较，较小的两个相同的<code>Integer</code>返回<code>true</code>，较大的两个相同的<code>Integer</code>返回<code>false</code>，这是因为<code>Integer</code>是不变类，编译器把<code>Integer x = 127;</code>自动变为<code>Integer x = Integer.valueOf(127);</code>，为了节省内存，<code>Integer.valueOf()</code>对于较小的数，始终返回相同的实例，因此，<code>==</code>比较“恰好”为<code>true</code>，但我们<em>绝不能</em>因为Java标准库的<code>Integer</code>内部有缓存优化就用<code>==</code>比较，必须用<code>equals()</code>方法比较两个<code>Integer</code>。</p><p>最佳实践</p><p>按照语义编程，而不是针对特定的底层实现去“优化”。</p><p>因为<code>Integer.valueOf()</code>可能始终返回同一个<code>Integer</code>实例，因此，在我们自己创建<code>Integer</code>的时候，以下两种方法：</p><ul><li>方法1：<code>Integer n = new Integer(100);</code></li><li>方法2：<code>Integer n = Integer.valueOf(100);</code></li></ul><p>方法2更好，因为方法1总是创建新的<code>Integer</code>实例，方法2把内部优化留给<code>Integer</code>的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。</p><p>我们把能创建“新”对象的静态方法称为静态工厂方法。<code>Integer.valueOf()</code>就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</p><p>最佳实践</p><p>创建新对象时，优先选用静态工厂方法而不是new操作符。</p><p>如果我们考察<code>Byte.valueOf()</code>方法的源码，可以看到，标准库返回的<code>Byte</code>实例全部是缓存实例，但调用者并不关心静态工厂方法以何种方式创建新实例还是直接返回缓存的实例。</p><h3 id="进制转换">进制转换</h3><p><code>Integer</code>类本身还提供了大量方法，例如，最常用的静态方法<code>parseInt()</code>可以把字符串解析成一个整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;100&quot;</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;100&quot;</span>, <span class="number">16</span>); <span class="comment">// 256,因为按16进制解析</span></span><br></pre></td></tr></table></figure><p><code>Integer</code>还可以把整数格式化为指定进制的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Integer.toString(<span class="number">100</span>)); <span class="comment">// &quot;100&quot;,表示为10进制</span></span><br><span class="line">        System.out.println(Integer.toString(<span class="number">100</span>, <span class="number">36</span>)); <span class="comment">// &quot;2s&quot;,表示为36进制</span></span><br><span class="line">        System.out.println(Integer.toHexString(<span class="number">100</span>)); <span class="comment">// &quot;64&quot;,表示为16进制</span></span><br><span class="line">        System.out.println(Integer.toOctalString(<span class="number">100</span>)); <span class="comment">// &quot;144&quot;,表示为8进制</span></span><br><span class="line">        System.out.println(Integer.toBinaryString(<span class="number">100</span>)); <span class="comment">// &quot;1100100&quot;,表示为2进制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：上述方法的输出都是<code>String</code>，在计算机内存中，只用二进制表示，不存在十进制或十六进制的表示方法。<code>int n = 100</code>在内存中总是以4字节的二进制表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌────────┬────────┬────────┬────────┐</span><br><span class="line">│00000000│00000000│00000000│01100100│</span><br><span class="line">└────────┴────────┴────────┴────────┘</span><br></pre></td></tr></table></figure><p>我们经常使用的<code>System.out.println(n);</code>是依靠核心库自动把整数格式化为10进制输出并显示在屏幕上，使用<code>Integer.toHexString(n)</code>则通过核心库自动把整数格式化为16进制。</p><p>这里我们注意到程序设计的一个重要原则：数据的存储和显示要分离。</p><p>Java的包装类型还定义了一些有用的静态变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">t</span> <span class="operator">=</span> Boolean.TRUE;</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">f</span> <span class="operator">=</span> Boolean.FALSE;</span><br><span class="line"><span class="comment">// int可表示的最大/最小值:</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MAX_VALUE; <span class="comment">// 2147483647</span></span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MIN_VALUE; <span class="comment">// -2147483648</span></span><br><span class="line"><span class="comment">// long类型占用的bit和byte数量:</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sizeOfLong</span> <span class="operator">=</span> Long.SIZE; <span class="comment">// 64 (bits)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">bytesOfLong</span> <span class="operator">=</span> Long.BYTES; <span class="comment">// 8 (bytes)</span></span><br></pre></td></tr></table></figure><p>最后，所有的整数和浮点数的包装类型都继承自<code>Number</code>，因此，可以非常方便地直接通过包装类型获取各种基本类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上转型为Number:</span></span><br><span class="line"><span class="type">Number</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">999</span>);</span><br><span class="line"><span class="comment">// 获取byte, int, long, float, double:</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> num.byteValue();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num.intValue();</span><br><span class="line"><span class="type">long</span> <span class="variable">ln</span> <span class="operator">=</span> num.longValue();</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> num.floatValue();</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> num.doubleValue();</span><br></pre></td></tr></table></figure><h3 id="处理无符号整型">处理无符号整型</h3><p>在Java中，并没有无符号整型（Unsigned）的基本数据类型。<code>byte</code>、<code>short</code>、<code>int</code>和<code>long</code>都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。</p><p>例如，byte是有符号整型，范围是<code>-128</code>~<code>+127</code>，但如果把<code>byte</code>看作无符号整型，它的范围就是<code>0</code>~<code>255</code>。我们把一个负的<code>byte</code>按无符号整型转换为<code>int</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Byte</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">x</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        System.out.println(Byte.toUnsignedInt(x)); <span class="comment">// 255</span></span><br><span class="line">        System.out.println(Byte.toUnsignedInt(y)); <span class="comment">// 127</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>byte</code>的<code>-1</code>的二进制表示是<code>11111111</code>，以无符号整型转换后的<code>int</code>就是<code>255</code>。</p><p>类似的，可以把一个<code>short</code>按unsigned转换为<code>int</code>，把一个<code>int</code>按unsigned转换为<code>long</code>。</p><h3 id="小结-4">小结</h3><p>Java核心库提供的包装类型可以把基本类型包装为<code>class</code>；</p><p>自动装箱和自动拆箱都是在编译期完成的（JDK&gt;=1.5）；</p><p>装箱和拆箱会影响执行效率，且拆箱时可能发生<code>NullPointerException</code>；</p><p>包装类型的比较必须使用<code>equals()</code>；</p><p>整数和浮点数的包装类型都继承自<code>Number</code>；</p><p>包装类型提供了大量实用方法。</p><p>在Java中，有很多<code>class</code>的定义都符合这样的规范：</p><ul><li>若干<code>private</code>实例字段；</li><li>通过<code>public</code>方法来读写实例字段。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.age; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123; <span class="built_in">this</span>.age = age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果读写方法符合以下这种命名规范：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="keyword">public</span> Type <span class="title function_">getXyz</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 写方法:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setXyz</span><span class="params">(Type value)</span></span><br></pre></td></tr></table></figure><p>那么这种<code>class</code>被称为<code>JavaBean</code>：</p><p><img src="https://liaoxuefeng.com/books/java/oop/core/javabean/javabean.jpg" alt="java-bean"></p><p>上面的字段是<code>xyz</code>，那么读写方法名分别以<code>get</code>和<code>set</code>开头，并且后接大写字母开头的字段名<code>Xyz</code>，因此两个读写方法名分别是<code>getXyz()</code>和<code>setXyz()</code>。</p><p><code>boolean</code>字段比较特殊，它的读方法一般命名为<code>isXyz()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isChild</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 写方法:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setChild</span><span class="params">(<span class="type">boolean</span> value)</span></span><br></pre></td></tr></table></figure><p>我们通常把一组对应的读方法（<code>getter</code>）和写方法（<code>setter</code>）称为属性（<code>property</code>）。例如，<code>name</code>属性：</p><ul><li>对应的读方法是<code>String getName()</code></li><li>对应的写方法是<code>setName(String)</code></li></ul><p>只有<code>getter</code>的属性称为只读属性（read-only），例如，定义一个age只读属性：</p><ul><li>对应的读方法是<code>int getAge()</code></li><li>无对应的写方法<code>setAge(int)</code></li></ul><p>类似的，只有<code>setter</code>的属性称为只写属性（write-only）。</p><p>很明显，只读属性很常见，只写属性不常见。</p><p>属性只需要定义<code>getter</code>和<code>setter</code>方法，不一定需要对应的字段。例如，<code>child</code>只读属性定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.age; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123; <span class="built_in">this</span>.age = age; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isChild</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age &lt;= <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>getter</code>和<code>setter</code>也是一种数据封装的方法。</p><h3 id="JavaBean的作用">JavaBean的作用</h3><p>JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。</p><p>通过IDE，可以快速生成<code>getter</code>和<code>setter</code>。例如，在Eclipse中，先输入以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，点击右键，在弹出的菜单中选择“Source”，“Generate Getters and Setters”，在弹出的对话框中选中需要生成<code>getter</code>和<code>setter</code>方法的字段，点击确定即可由IDE自动完成所有方法代码。</p><h3 id="枚举JavaBean属性">枚举JavaBean属性</h3><p>要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的<code>Introspector</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.beans.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BeanInfo</span> <span class="variable">info</span> <span class="operator">=</span> Introspector.getBeanInfo(Person.class);</span><br><span class="line">        <span class="keyword">for</span> (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123;</span><br><span class="line">            System.out.println(pd.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + pd.getReadMethod());</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + pd.getWriteMethod());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，可以列出所有的属性，以及对应的读写方法。注意<code>class</code>属性是从<code>Object</code>继承的<code>getClass()</code>方法带来的。</p><h3 id="小结-5">小结</h3><p>JavaBean是一种符合命名规范的<code>class</code>，它通过<code>getter</code>和<code>setter</code>来定义属性；</p><p>属性是一种通用的叫法，并非Java语法规定；</p><p>可以利用IDE快速生成<code>getter</code>和<code>setter</code>；</p><p>使用<code>Introspector.getBeanInfo()</code>可以获取属性列表。</p><p>在Java中，我们可以通过<code>static final</code>来定义常量。例如，我们希望定义周一到周日这7个常量，可以用7个不同的<code>int</code>表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SUN</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MON</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TUE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WED</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THU</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FRI</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SAT</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用常量的时候，可以这么引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (day == Weekday.SAT || day == Weekday.SUN) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> work at home</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以把常量定义为字符串类型，例如，定义3种颜色的常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RED</span> <span class="operator">=</span> <span class="string">&quot;r&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GREEN</span> <span class="operator">=</span> <span class="string">&quot;g&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BLUE</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用常量的时候，可以这么引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">color</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="keyword">if</span> (Color.RED.equals(color)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是<code>int</code>常量还是<code>String</code>常量，使用这些常量来表示一组枚举值的时候，有一个严重的问题就是，编译器无法检查每个值的合理性。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (weekday == <span class="number">6</span> || weekday == <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == Weekday.MON) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码编译和运行均不会报错，但存在两个问题：</p><ul><li>注意到<code>Weekday</code>定义的常量范围是<code>0</code>~<code>6</code>，并不包含<code>7</code>，编译器无法检查不在枚举中的<code>int</code>值；</li><li>定义的常量仍可与其他变量比较，但其用途并非是枚举星期值。</li></ul><h3 id="enum">enum</h3><p>为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用<code>enum</code>来定义枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enum</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day == Weekday.SAT || day == Weekday.SUN) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到定义枚举类是通过关键字<code>enum</code>实现的，我们只需依次列出枚举的常量名。</p><p>和<code>int</code>定义的常量相比，使用<code>enum</code>定义枚举有如下好处：</p><p>首先，<code>enum</code>常量本身带有类型信息，即<code>Weekday.SUN</code>类型是<code>Weekday</code>，编译器会自动检查出类型错误。例如，下面的语句不可能编译通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (day == Weekday.SUN) &#123; <span class="comment">// Compile error: bad operand types for binary operator &#x27;==&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，不可能引用到非枚举的值，因为无法通过编译。</p><p>最后，不同类型的枚举不能互相比较或者赋值，因为类型不符。例如，不能给一个<code>Weekday</code>枚举类型的变量赋值为<code>Color</code>枚举类型的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Weekday</span> <span class="variable">x</span> <span class="operator">=</span> Weekday.SUN; <span class="comment">// ok!</span></span><br><span class="line"><span class="type">Weekday</span> <span class="variable">y</span> <span class="operator">=</span> Color.RED; <span class="comment">// Compile error: incompatible types</span></span><br></pre></td></tr></table></figure><p>这就使得编译器可以在编译期自动检查出所有可能的潜在错误。</p><h3 id="enum的比较">enum的比较</h3><p>使用<code>enum</code>定义的枚举类是一种引用类型。前面我们讲到，引用类型比较，要使用<code>equals()</code>方法，如果使用<code>==</code>比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用<code>equals()</code>方法，但<code>enum</code>类型可以例外。</p><p>这是因为<code>enum</code>类型的每个常量在JVM中只有一个唯一实例，所以可以直接用<code>==</code>比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (day == Weekday.FRI) &#123; <span class="comment">// ok!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (day.equals(Weekday.SUN)) &#123; <span class="comment">// ok, but more code!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="enum类型">enum类型</h3><p>通过<code>enum</code>定义的枚举类，和其他的<code>class</code>有什么区别？</p><p>答案是没有任何区别。<code>enum</code>定义的类型就是<code>class</code>，只不过它有以下几个特点：</p><ul><li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li><li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li><li>定义的每个实例都是引用类型的唯一实例；</li><li>可以将<code>enum</code>类型用于<code>switch</code>语句。</li></ul><p>例如，我们定义的<code>Color</code>枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器编译出的<code>class</code>大概就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Color</span> <span class="keyword">extends</span> <span class="title class_">Enum</span> &#123; <span class="comment">// 继承自Enum，标记为final class</span></span><br><span class="line">    <span class="comment">// 每个实例均为全局唯一:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Color</span> <span class="variable">RED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Color</span> <span class="variable">GREEN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Color</span> <span class="variable">BLUE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line">    <span class="comment">// private构造方法，确保外部无法调用new操作符:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Color</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，编译后的<code>enum</code>类和普通<code>class</code>并没有任何区别。但是我们自己无法按定义普通<code>class</code>那样来定义<code>enum</code>，必须使用<code>enum</code>关键字，这是Java语法规定的。</p><p>因为<code>enum</code>是一个<code>class</code>，每个枚举的值都是<code>class</code>实例，因此，这些实例有一些方法：</p><h4 id="name">name()</h4><p>返回常量名，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Weekday.SUN.name(); <span class="comment">// &quot;SUN&quot;</span></span><br></pre></td></tr></table></figure><h4 id="ordinal">ordinal()</h4><p>返回定义的常量的顺序，从0开始计数，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Weekday.MON.ordinal(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>改变枚举常量定义的顺序就会导致<code>ordinal()</code>返回值发生变化。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>的<code>ordinal</code>就是不同的。如果在代码中编写了类似<code>if(x.ordinal()==1)</code>这样的语句，就要保证<code>enum</code>的枚举顺序不能变。新增的常量必须放在最后。</p><p>有些童鞋会想，<code>Weekday</code>的枚举常量如果要和<code>int</code>转换，使用<code>ordinal()</code>不是非常方便？比如这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">task</span> <span class="operator">=</span> Weekday.MON.ordinal() + <span class="string">&quot;/ppt&quot;</span>;</span><br><span class="line">saveToFile(task);</span><br></pre></td></tr></table></figure><p>但是，如果不小心修改了枚举的顺序，编译器是无法检查出这种逻辑错误的。要编写健壮的代码，就不要依靠<code>ordinal()</code>的返回值。因为<code>enum</code>本身是<code>class</code>，所以我们可以定义<code>private</code>的构造方法，并且，给每个枚举常量添加字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enum</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day.dayValue == <span class="number">6</span> || day.dayValue == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON(<span class="number">1</span>), TUE(<span class="number">2</span>), WED(<span class="number">3</span>), THU(<span class="number">4</span>), FRI(<span class="number">5</span>), SAT(<span class="number">6</span>), SUN(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> dayValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Weekday</span><span class="params">(<span class="type">int</span> dayValue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dayValue = dayValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就无需担心顺序的变化，新增枚举常量时，也需要指定一个<code>int</code>值。</p><p>注意</p><p>枚举类的字段也可以是非final类型，即可以在运行期修改，但是不推荐这样做！</p><p>默认情况下，对枚举常量调用<code>toString()</code>会返回和<code>name()</code>一样的字符串。但是，<code>toString()</code>可以被覆写，而<code>name()</code>则不行。我们可以给<code>Weekday</code>添加<code>toString()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enum</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day.dayValue == <span class="number">6</span> || day.dayValue == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON(<span class="number">1</span>, <span class="string">&quot;星期一&quot;</span>), TUE(<span class="number">2</span>, <span class="string">&quot;星期二&quot;</span>), WED(<span class="number">3</span>, <span class="string">&quot;星期三&quot;</span>), THU(<span class="number">4</span>, <span class="string">&quot;星期四&quot;</span>), FRI(<span class="number">5</span>, <span class="string">&quot;星期五&quot;</span>), SAT(<span class="number">6</span>, <span class="string">&quot;星期六&quot;</span>), SUN(<span class="number">0</span>, <span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> dayValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String chinese;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Weekday</span><span class="params">(<span class="type">int</span> dayValue, String chinese)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dayValue = dayValue;</span><br><span class="line">        <span class="built_in">this</span>.chinese = chinese;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.chinese;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>覆写<code>toString()</code>的目的是在输出时更有可读性。</p><p>注意</p><p>判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！</p><h3 id="switch">switch</h3><p>最后，枚举类可以应用在<code>switch</code>语句中。因为枚举类天生具有类型信息和有限个枚举常量，所以比<code>int</code>、<code>String</code>类型更适合用在<code>switch</code>语句中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">switch</span>(day) &#123;</span><br><span class="line">        <span class="keyword">case</span> MON:</span><br><span class="line">        <span class="keyword">case</span> TUE:</span><br><span class="line">        <span class="keyword">case</span> WED:</span><br><span class="line">        <span class="keyword">case</span> THU:</span><br><span class="line">        <span class="keyword">case</span> FRI:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at office!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SAT:</span><br><span class="line">        <span class="keyword">case</span> SUN:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at home!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;cannot process &quot;</span> + day);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上<code>default</code>语句，可以在漏写某个枚举常量时自动报错，从而及时发现错误。</p><h3 id="小结-6">小结</h3><p>Java使用<code>enum</code>定义枚举类型，它被编译器编译为<code>final class Xxx extends Enum &#123; … &#125;</code>；</p><p>通过<code>name()</code>获取常量定义的字符串，注意不要使用<code>toString()</code>；</p><p>通过<code>ordinal()</code>返回常量定义的顺序（无实质意义）；</p><p>可以为<code>enum</code>编写构造方法、字段和方法</p><p><code>enum</code>的构造方法要声明为<code>private</code>，字段强烈建议声明为<code>final</code>；</p><p><code>enum</code>适合用在<code>switch</code>语句中。</p><p>使用<code>String</code>、<code>Integer</code>等类型的时候，这些类型都是不变类，一个不变类具有以下特点：</p><ol><li>定义class时使用<code>final</code>，无法派生子类；</li><li>每个字段使用<code>final</code>，保证创建实例后无法修改任何字段。</li></ol><p>假设我们希望定义一个<code>Point</code>类，有<code>x</code>、<code>y</code>两个变量，同时它是一个不变类，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">x</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">y</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了保证不变类的比较，还需要正确覆写<code>equals()</code>和<code>hashCode()</code>方法，这样才能在集合类中正常使用。后续我们会详细讲解正确覆写<code>equals()</code>和<code>hashCode()</code>，这里演示<code>Point</code>不变类的写法目的是，这些代码写起来都非常简单，但是很繁琐。</p><h3 id="record">record</h3><p>从Java 14开始，引入了新的<code>Record</code>类。我们定义<code>Record</code>类时，使用关键字<code>record</code>。把上述<code>Point</code>类改写为<code>Record</code>类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Record</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        System.out.println(p.x());</span><br><span class="line">        System.out.println(p.y());</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>仔细观察<code>Point</code>的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>把上述定义改写为class，相当于以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Point</span> <span class="keyword">extends</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">x</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">y</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Point[x=%s, y=%s]&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了用<code>final</code>修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写<code>toString()</code>、<code>equals()</code>和<code>hashCode()</code>方法。</p><p>换句话说，使用<code>record</code>关键字，可以一行写出一个不变类。</p><p>和<code>enum</code>类似，我们自己不能直接从<code>Record</code>派生，只能通过<code>record</code>关键字由编译器实现继承。</p><h3 id="构造方法">构造方法</h3><p>编译器默认按照<code>record</code>声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么问题来了，如果我们要检查参数，应该怎么办？</p><p>假设<code>Point</code>类的<code>x</code>、<code>y</code>不允许负数，我们就得给<code>Point</code>的构造方法加上检查逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Point &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到方法<code>public Point &#123;...&#125;</code>被称为Compact Constructor，它的目的是让我们编写检查逻辑，编译器最终生成的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Point</span> <span class="keyword">extends</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">// 这是我们编写的Compact Constructor:</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这是编译器继续生成的赋值代码:</span></span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为<code>record</code>的<code>Point</code>仍然可以添加静态方法。一种常用的静态方法是<code>of()</code>方法，用来创建<code>Point</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title function_">of</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title function_">of</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Point</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们可以写出更简洁的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">z</span> <span class="operator">=</span> Point.of();</span><br><span class="line"><span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> Point.of(<span class="number">123</span>, <span class="number">456</span>);</span><br></pre></td></tr></table></figure><h3 id="小结-7">小结</h3><p>从Java 14开始，提供新的<code>record</code>关键字，可以非常方便地定义Data Class：</p><ul><li>使用<code>record</code>定义的是不变类；</li><li>可以编写Compact Constructor对参数进行验证；</li><li>可以定义静态方法。</li></ul><h2 id="BigInteger">BigInteger</h2><p>在Java中，由CPU原生提供的整型最大范围是64位<code>long</code>型整数。使用<code>long</code>型整数可以直接通过CPU指令进行计算，速度非常快。</p><p>如果我们使用的整数范围超过了<code>long</code>型怎么办？这个时候，就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code>就是用来表示任意大小的整数。<code>BigInteger</code>内部用一个<code>int[]</code>数组来模拟一个非常大的整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">System.out.println(bi.pow(<span class="number">5</span>)); <span class="comment">// 2867971860299718107233761438093672048294900000</span></span><br></pre></td></tr></table></figure><p>对<code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12345678901234567890&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">sum</span> <span class="operator">=</span> i1.add(i2); <span class="comment">// 12345678902469135780</span></span><br></pre></td></tr></table></figure><p>和<code>long</code>型整数运算比，<code>BigInteger</code>不会有范围限制，但缺点是速度比较慢。</p><p>也可以把<code>BigInteger</code>转换成<code>long</code>型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;123456789000&quot;</span>);</span><br><span class="line">System.out.println(i.longValue()); <span class="comment">// 123456789000</span></span><br><span class="line">System.out.println(i.multiply(i).longValueExact()); <span class="comment">// java.lang.ArithmeticException: BigInteger out of long range</span></span><br></pre></td></tr></table></figure><p>使用<code>longValueExact()</code>方法时，如果超出了<code>long</code>型的范围，会抛出<code>ArithmeticException</code>。</p><p><code>BigInteger</code>和<code>Integer</code>、<code>Long</code>一样，也是不可变类，并且也继承自<code>Number</code>类。因为<code>Number</code>定义了转换为基本类型的几个方法：</p><ul><li>转换为<code>byte</code>：<code>byteValue()</code></li><li>转换为<code>short</code>：<code>shortValue()</code></li><li>转换为<code>int</code>：<code>intValue()</code></li><li>转换为<code>long</code>：<code>longValue()</code></li><li>转换为<code>float</code>：<code>floatValue()</code></li><li>转换为<code>double</code>：<code>doubleValue()</code></li></ul><p>因此，通过上述方法，可以把<code>BigInteger</code>转换成基本类型。如果<code>BigInteger</code>表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常。</p><p>如果<code>BigInteger</code>的值甚至超过了<code>float</code>的最大范围（3.4x1038），那么返回的float是什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BigInteger to float</span></span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;999999&quot;</span>).pow(<span class="number">99</span>);</span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> n.floatValue();</span><br><span class="line">        System.out.println(f); <span class="comment">// Infinity</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-8">小结</h3><p><code>BigInteger</code>用于表示任意大小的整数；</p><p><code>BigInteger</code>是不变类，并且继承自<code>Number</code>；</p><p>将<code>BigInteger</code>转换成基本类型时可使用<code>longValueExact()</code>等方法保证结果准确。</p><hr><hr><p>和<code>BigInteger</code>类似，<code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bd = new BigDecimal(&quot;123.4567&quot;);</span><br><span class="line">System.out.println(bd.multiply(bd)); // 15241.55677489</span><br></pre></td></tr></table></figure><p><code>BigDecimal</code>用<code>scale()</code>表示小数位数，例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = new BigDecimal(&quot;123.45&quot;);</span><br><span class="line">BigDecimal d2 = new BigDecimal(&quot;123.4500&quot;);</span><br><span class="line">BigDecimal d3 = new BigDecimal(&quot;1234500&quot;);</span><br><span class="line">System.out.println(d1.scale()); // 2,两位小数</span><br><span class="line">System.out.println(d2.scale()); // 4</span><br><span class="line">System.out.println(d3.scale()); // 0</span><br></pre></td></tr></table></figure><p>通过<code>BigDecimal</code>的<code>stripTrailingZeros()</code>方法，可以将一个<code>BigDecimal</code>格式化为一个相等的，但去掉了末尾0的<code>BigDecimal</code>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = new BigDecimal(&quot;123.4500&quot;);</span><br><span class="line">BigDecimal d2 = d1.stripTrailingZeros();</span><br><span class="line">System.out.println(d1.scale()); // 4</span><br><span class="line">System.out.println(d2.scale()); // 2,因为去掉了00</span><br><span class="line"></span><br><span class="line">BigDecimal d3 = new BigDecimal(&quot;1234500&quot;);</span><br><span class="line">BigDecimal d4 = d3.stripTrailingZeros();</span><br><span class="line">System.out.println(d3.scale()); // 0</span><br><span class="line">System.out.println(d4.scale()); // -2</span><br></pre></td></tr></table></figure><p>如果一个<code>BigDecimal</code>的<code>scale()</code>返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0。</p><p>可以对一个<code>BigDecimal</code>设置它的<code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.math.RoundingMode;</span><br><span class="line">----</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BigDecimal d1 = new BigDecimal(&quot;123.456789&quot;);</span><br><span class="line">        BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568</span><br><span class="line">        BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567</span><br><span class="line">        System.out.println(d2);</span><br><span class="line">        System.out.println(d3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = new BigDecimal(&quot;123.456&quot;);</span><br><span class="line">BigDecimal d2 = new BigDecimal(&quot;23.456789&quot;);</span><br><span class="line">BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入</span><br><span class="line">BigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽</span><br></pre></td></tr></table></figure><p>还可以对<code>BigDecimal</code>做除法的同时求余数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.math.BigDecimal;</span><br><span class="line">----</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BigDecimal n = new BigDecimal(&quot;12.345&quot;);</span><br><span class="line">        BigDecimal m = new BigDecimal(&quot;0.12&quot;);</span><br><span class="line">        BigDecimal[] dr = n.divideAndRemainder(m);</span><br><span class="line">        System.out.println(dr[0]); // 102</span><br><span class="line">        System.out.println(dr[1]); // 0.105</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>divideAndRemainder()</code>方法时，返回的数组包含两个<code>BigDecimal</code>，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个<code>BigDecimal</code>是否是整数倍数：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal n = new BigDecimal(&quot;12.75&quot;);</span><br><span class="line">BigDecimal m = new BigDecimal(&quot;0.15&quot;);</span><br><span class="line">BigDecimal[] dr = n.divideAndRemainder(m);</span><br><span class="line">if (dr[1].signum() == 0) &#123;</span><br><span class="line">    // n是m的整数倍</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较BigDecimal">比较BigDecimal</h3><p>在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.456&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.45600&quot;</span>);</span><br><span class="line">System.out.println(d1.equals(d2)); <span class="comment">// false,因为scale不同</span></span><br><span class="line">System.out.println(d1.equals(d2.stripTrailingZeros())); <span class="comment">// true,因为d2去除尾部0后scale变为3</span></span><br><span class="line">System.out.println(d1.compareTo(d2)); <span class="comment">// 0 = 相等, -1 = d1 &lt; d2, 1 = d1 &gt; d2</span></span><br></pre></td></tr></table></figure><p>必须使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p><p>注意</p><p>总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！</p><p>如果查看<code>BigDecimal</code>的源码，可以发现，实际上一个<code>BigDecimal</code>是通过一个<code>BigInteger</code>和一个<code>scale</code>来表示的，即<code>BigInteger</code>表示一个完整的整数，而<code>scale</code>表示小数位数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimal</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;BigDecimal&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger intVal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BigDecimal</code>也是从<code>Number</code>继承的，也是不可变对象。</p><h3 id="小结-9">小结</h3><p><code>BigDecimal</code>用于表示精确的小数，常用于财务计算；</p><p>比较<code>BigDecimal</code>的值是否相等，必须使用<code>compareTo()</code>而不能使用<code>equals()</code>。</p><p>Java的核心库提供了大量的现成的类供我们使用。本节我们介绍几个常用的工具类。</p><h3 id="Math">Math</h3><p>顾名思义，<code>Math</code>类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算：</p><p>求绝对值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.abs(-<span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line">Math.abs(-<span class="number">7.8</span>); <span class="comment">// 7.8</span></span><br></pre></td></tr></table></figure><p>取最大或最小值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.max(<span class="number">100</span>, <span class="number">99</span>); <span class="comment">// 100</span></span><br><span class="line">Math.min(<span class="number">1.2</span>, <span class="number">2.3</span>); <span class="comment">// 1.2</span></span><br></pre></td></tr></table></figure><p>计算xy次方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(<span class="number">2</span>, <span class="number">10</span>); <span class="comment">// 2的10次方=1024</span></span><br></pre></td></tr></table></figure><p>计算 x\sqrt x：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.sqrt(<span class="number">2</span>); <span class="comment">// 1.414...</span></span><br></pre></td></tr></table></figure><p>计算ex次方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.exp(<span class="number">2</span>); <span class="comment">// 7.389...</span></span><br></pre></td></tr></table></figure><p>计算以e为底的对数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.log(<span class="number">4</span>); <span class="comment">// 1.386...</span></span><br></pre></td></tr></table></figure><p>计算以10为底的对数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.log10(<span class="number">100</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>三角函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.sin(<span class="number">3.14</span>); <span class="comment">// 0.00159...</span></span><br><span class="line">Math.cos(<span class="number">3.14</span>); <span class="comment">// -0.9999...</span></span><br><span class="line">Math.tan(<span class="number">3.14</span>); <span class="comment">// -0.0015...</span></span><br><span class="line">Math.asin(<span class="number">1.0</span>); <span class="comment">// 1.57079...</span></span><br><span class="line">Math.acos(<span class="number">1.0</span>); <span class="comment">// 0.0</span></span><br></pre></td></tr></table></figure><p>Math还提供了几个数学常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> Math.PI; <span class="comment">// 3.14159...</span></span><br><span class="line"><span class="type">double</span> <span class="variable">e</span> <span class="operator">=</span> Math.E; <span class="comment">// 2.7182818...</span></span><br><span class="line">Math.sin(Math.PI / <span class="number">6</span>); <span class="comment">// sin(π/6) = 0.5</span></span><br></pre></td></tr></table></figure><p>生成一个随机数x，x的范围是<code>0 &lt;= x &lt; 1</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.random(); <span class="comment">// 0.53907... 每次都不一样</span></span><br></pre></td></tr></table></figure><p>如果我们要生成一个区间在<code>[MIN, MAX)</code>的随机数，可以借助<code>Math.random()</code>实现，计算如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间在[MIN, MAX)的随机数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> Math.random(); <span class="comment">// x的范围是[0,1)</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> x * (max - min) + min; <span class="comment">// y的范围是[10,50)</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">long</span>) y; <span class="comment">// n的范围是[10,50)的整数</span></span><br><span class="line">        System.out.println(y);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些同学可能注意到Java标准库还提供了一个<code>StrictMath</code>，它提供了和<code>Math</code>几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，<code>StrictMath</code>保证所有平台计算结果都是完全相同的，而<code>Math</code>会尽量针对平台优化计算速度，所以，绝大多数情况下，使用<code>Math</code>就足够了。</p><h3 id="HexFormat">HexFormat</h3><p>在处理<code>byte[]</code>数组时，我们经常需要与十六进制字符串转换，自己写起来比较麻烦，用Java标准库提供的<code>HexFormat</code>则可以方便地帮我们转换。</p><p>要将<code>byte[]</code>数组转换为十六进制字符串，可以用<code>formatHex()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HexFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="string">&quot;Hello&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">HexFormat</span> <span class="variable">hf</span> <span class="operator">=</span> HexFormat.of();</span><br><span class="line">        <span class="type">String</span> <span class="variable">hexData</span> <span class="operator">=</span> hf.formatHex(data); <span class="comment">// 48656c6c6f</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要定制转换格式，则使用定制的<code>HexFormat</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分隔符为空格，添加前缀0x，大写字母:</span></span><br><span class="line"><span class="type">HexFormat</span> <span class="variable">hf</span> <span class="operator">=</span> HexFormat.ofDelimiter(<span class="string">&quot; &quot;</span>).withPrefix(<span class="string">&quot;0x&quot;</span>).withUpperCase();</span><br><span class="line">hf.formatHex(<span class="string">&quot;Hello&quot;</span>.getBytes())); <span class="comment">// 0x48 0x65 0x6C 0x6C 0x6F</span></span><br></pre></td></tr></table></figure><p>从十六进制字符串到<code>byte[]</code>数组转换，使用<code>parseHex()</code>方法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte[] bs = HexFormat.of().parseHex(&quot;48656c6c6f&quot;);</span><br></pre></td></tr></table></figure><h3 id="Random">Random</h3><p><code>Random</code>用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p><p>要生成一个随机数，可以使用<code>nextInt()</code>、<code>nextLong()</code>、<code>nextFloat()</code>、<code>nextDouble()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">r.nextInt(); <span class="comment">// 2071575453,每次都不一样</span></span><br><span class="line">r.nextInt(<span class="number">10</span>); <span class="comment">// 5,生成一个[0,10)之间的int</span></span><br><span class="line">r.nextLong(); <span class="comment">// 8811649292570369305,每次都不一样</span></span><br><span class="line">r.nextFloat(); <span class="comment">// 0.54335...生成一个[0,1)之间的float</span></span><br><span class="line">r.nextDouble(); <span class="comment">// 0.3716...生成一个[0,1)之间的double</span></span><br></pre></td></tr></table></figure><p>有童鞋问，每次运行程序，生成的随机数都是不同的，没看出<em>伪随机数</em>的特性来。</p><p>这是因为我们创建<code>Random</code>实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。</p><p>如果我们在创建<code>Random</code>实例时指定一个种子，就会得到完全确定的随机数序列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">12345</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(r.nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 51, 80, 41, 28, 55...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们使用的<code>Math.random()</code>实际上内部调用了<code>Random</code>类，所以它也是伪随机数，只是我们无法指定种子。</p><h3 id="SecureRandom">SecureRandom</h3><p>有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，<code>SecureRandom</code>就是用来创建安全的随机数的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SecureRandom</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">System.out.println(sr.nextInt(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p><code>SecureRandom</code>无法指定种子，它使用RNG（random number generator）算法。JDK的<code>SecureRandom</code>实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SecureRandom</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sr = SecureRandom.getInstanceStrong(); <span class="comment">// 获取高强度安全随机数生成器</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            sr = <span class="keyword">new</span> <span class="title class_">SecureRandom</span>(); <span class="comment">// 获取普通的安全随机数生成器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line">        sr.nextBytes(buffer); <span class="comment">// 用安全随机数填充buffer</span></span><br><span class="line">        System.out.println(Arrays.toString(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SecureRandom</code>的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p><p>在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用<code>SecureRandom</code>来产生安全的随机数。</p><p>注意</p><p>需要使用安全随机数的时候，必须使用SecureRandom，绝不能使用Random！</p><h3 id="小结-10">小结</h3><p>Java提供的常用工具类有：</p><ul><li>Math：数学计算</li><li>HexFormat：格式化十六进制数</li><li>Random：生成伪随机数</li><li>SecureRandom：生成安全的随机数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-面向对象编程-基础</title>
      <link href="/2025/05/23/java/JAVA-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/05/23/java/JAVA-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>Java是一种面向对象的编程语言。面向对象编程，英文是Object-Oriented Programming，简称OOP。</p><p>那什么是面向对象编程？</p><p>和面向对象编程不同的，是面向过程编程。面向过程编程，是把模型分解成一步一步的过程。比如，老板告诉你，要编写一个TODO任务，必须按照以下步骤一步一步来：</p><ol><li>读取文件；</li><li>编写TODO；</li><li>保存文件。</li></ol><p>而面向对象编程，顾名思义，你得首先有个对象：</p><p>有了对象后，就可以和对象进行互动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GirlFriend</span> <span class="variable">gf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GirlFriend</span>();</span><br><span class="line">gf.name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">gf.send(<span class="string">&quot;flowers&quot;</span>);</span><br></pre></td></tr></table></figure><p>因此，面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。</p><p>在本章中，我们将讨论：</p><p>面向对象的基本概念，包括：</p><ul><li>类</li><li>实例</li><li>方法</li></ul><p>面向对象的实现方式，包括：</p><ul><li>继承</li><li>多态</li></ul><p>Java语言本身提供的机制，包括：</p><ul><li>package</li><li>classpath</li><li>jar</li></ul><p>以及Java标准库提供的核心类，包括：</p><ul><li>字符串</li><li>包装类型</li><li>JavaBean</li><li>枚举</li><li>常用工具类</li></ul><p>通过本章的学习，完全可以理解并掌握面向对象的基本思想，但不保证能找到对象。</p><hr><p>面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。</p><p>现实世界中，我们定义了“人”这种抽象概念，而具体的人则是“小明”、“小红”、“小军”等一个个具体的人。所以，“人”可以定义为一个类（class），而具体的人则是实例（instance）：</p><table><thead><tr><th>现实世界</th><th>计算机模型</th><th>Java代码</th></tr></thead><tbody><tr><td>人</td><td>类 / class</td><td>class Person { }</td></tr><tr><td>小明</td><td>实例 / ming</td><td>Person ming = new Person()</td></tr><tr><td>小红</td><td>实例 / hong</td><td>Person hong = new Person()</td></tr><tr><td>小军</td><td>实例 / jun</td><td>Person jun = new Person()</td></tr></tbody></table><p>同样的，“书”也是一种抽象的概念，所以它是类，而《Java核心技术》、《Java编程思想》、《Java学习笔记》则是实例：</p><table><thead><tr><th>现实世界</th><th>计算机模型</th><th>Java代码</th></tr></thead><tbody><tr><td>书</td><td>类 / class</td><td>class Book { }</td></tr><tr><td>Java核心技术</td><td>实例 / book1</td><td>Book book1 = new Book()</td></tr><tr><td>Java编程思想</td><td>实例 / book2</td><td>Book book2 = new Book()</td></tr><tr><td>Java学习笔记</td><td>实例 / book3</td><td>Book book3 = new Book()</td></tr></tbody></table><h3 id="class和instance">class和instance</h3><p>所以，只要理解了class和instance的概念，基本上就明白了什么是面向对象编程。</p><p>class是一种对象模版，它定义了如何创建实例，因此，class本身就是一种数据类型：</p><p><img src="https://liaoxuefeng.com/books/java/oop/basic/class.jpg" alt="class"></p><p>而instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同：</p><p><img src="https://liaoxuefeng.com/books/java/oop/basic/instances.jpg" alt="instances"></p><h3 id="定义class">定义class</h3><p>在Java中，创建一个类，例如，给这个类命名为<code>Person</code>，就是定义一个<code>class</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个<code>class</code>可以包含多个字段（<code>field</code>），字段用来描述一个类的特征。上面的<code>Person</code>类，我们定义了两个字段，一个是<code>String</code>类型的字段，命名为<code>name</code>，一个是<code>int</code>类型的字段，命名为<code>age</code>。因此，通过<code>class</code>，把一组数据汇集到一个对象上，实现了数据封装。</p><p><code>public</code>是用来修饰字段的，它表示这个字段可以被外部访问。</p><p>我们再看另一个<code>Book</code>类的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String author;</span><br><span class="line">    <span class="keyword">public</span> String isbn;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请指出<code>Book</code>类的各个字段。</p><h3 id="创建实例">创建实例</h3><p>定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符。</p><p>new操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">ming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure><p>上述代码创建了一个Person类型的实例，并通过变量<code>ming</code>指向它。</p><p>注意区分<code>Person ming</code>是定义<code>Person</code>类型的变量<code>ming</code>，而<code>new Person()</code>是创建<code>Person</code>实例。</p><p>有了指向这个实例的变量，我们就可以通过这个变量来操作实例。访问实例变量可以用<code>变量.字段</code>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ming.name = <span class="string">&quot;Xiao Ming&quot;</span>; <span class="comment">// 对字段name赋值</span></span><br><span class="line">ming.age = <span class="number">12</span>; <span class="comment">// 对字段age赋值</span></span><br><span class="line">System.out.println(ming.name); <span class="comment">// 访问字段name</span></span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">hong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">hong.name = <span class="string">&quot;Xiao Hong&quot;</span>;</span><br><span class="line">hong.age = <span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>上述两个变量分别指向两个不同的实例，它们在内存中的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">            ┌──────────────────┐</span><br><span class="line">ming ──────▶│Person instance   │</span><br><span class="line">            ├──────────────────┤</span><br><span class="line">            │name = &quot;Xiao Ming&quot;│</span><br><span class="line">            │age = 12          │</span><br><span class="line">            └──────────────────┘</span><br><span class="line">            ┌──────────────────┐</span><br><span class="line">hong ──────▶│Person instance   │</span><br><span class="line">            ├──────────────────┤</span><br><span class="line">            │name = &quot;Xiao Hong&quot;│</span><br><span class="line">            │age = 15          │</span><br><span class="line">            └──────────────────┘</span><br></pre></td></tr></table></figure><p>两个<code>instance</code>拥有<code>class</code>定义的<code>name</code>和<code>age</code>字段，且各自都有一份独立的数据，互不干扰。</p><p>注意</p><p>一个Java源文件可以包含多个类的定义，但只能定义一个public类，且public类名必须与文件名一致。如果要定义多个public类，必须拆到多个Java源文件中。</p><h3 id="练习">练习</h3><p>请定义一个City类，该class具有如下字段:</p><ul><li>name: 名称，String类型</li><li>latitude: 纬度，double类型</li><li>longitude: 经度，double类型</li></ul><p>实例化几个City并赋值，然后打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// City</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">City</span> <span class="variable">bj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>();</span><br><span class="line">        bj.name = <span class="string">&quot;Beijing&quot;</span>;</span><br><span class="line">        bj.latitude = <span class="number">39.903</span>;</span><br><span class="line">        bj.longitude = <span class="number">116.401</span>;</span><br><span class="line">        System.out.println(bj.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;location: &quot;</span> + bj.latitude + <span class="string">&quot;, &quot;</span> + bj.longitude);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">City</span> &#123;</span><br><span class="line">    ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结">小结</h3><p>在OOP中，<code>class</code>和<code>instance</code>是“模版”和“实例”的关系；</p><p>定义<code>class</code>就是定义了一种数据类型，对应的<code>instance</code>是这种数据类型的实例；</p><p><code>class</code>定义的<code>field</code>，在每个<code>instance</code>都会拥有各自的<code>field</code>，且互不干扰；</p><p>通过<code>new</code>操作符创建新的<code>instance</code>，然后用变量指向它，即可通过变量来引用这个<code>instance</code>；</p><p>访问实例字段的方法是<code>变量名.字段名</code>；</p><p>指向<code>instance</code>的变量都是引用变量。</p><p>一个<code>class</code>可以包含多个<code>field</code>，例如，我们给<code>Person</code>类就定义了两个<code>field</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，直接把<code>field</code>用<code>public</code>暴露给外部可能会破坏封装性。比如，代码可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">ming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">ming.name = <span class="string">&quot;Xiao Ming&quot;</span>;</span><br><span class="line">ming.age = -<span class="number">99</span>; <span class="comment">// age设置为负数 </span></span><br></pre></td></tr></table></figure><p>显然，直接操作<code>field</code>，容易造成逻辑混乱。为了避免外部代码直接去访问<code>field</code>，我们可以用<code>private</code>修饰<code>field</code>，拒绝外部访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试试<code>private</code>修饰的<code>field</code>有什么效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// private field</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">ming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        ming.name = <span class="string">&quot;Xiao Ming&quot;</span>; <span class="comment">// 对字段name赋值</span></span><br><span class="line">        ming.age = <span class="number">12</span>; <span class="comment">// 对字段age赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是编译报错？把访问<code>field</code>的赋值语句去了就可以正常编译了。</p><p>把<code>field</code>从<code>public</code>改成<code>private</code>，外部代码不能访问这些<code>field</code>，那我们定义这些<code>field</code>有什么用？怎么才能给它赋值？怎么才能读取它的值？</p><p>所以我们需要使用方法（<code>method</code>）来让外部代码可以间接修改<code>field</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// private field</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">ming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        ming.setName(<span class="string">&quot;Xiao Ming&quot;</span>); <span class="comment">// 设置name</span></span><br><span class="line">        ming.setAge(<span class="number">12</span>); <span class="comment">// 设置age</span></span><br><span class="line">        System.out.println(ming.getName() + <span class="string">&quot;, &quot;</span> + ming.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invalid age value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然外部代码不能直接修改<code>private</code>字段，但是，外部代码可以调用方法<code>setName()</code>和<code>setAge()</code>来间接修改<code>private</code>字段。在方法内部，我们就有机会检查参数对不对。比如，<code>setAge()</code>就会检查传入的参数，参数超出了范围，直接报错。这样，外部代码就没有任何机会把<code>age</code>设置成不合理的值。</p><p>对<code>setName()</code>方法同样可以做检查，例如，不允许传入<code>null</code>和空字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span> || name.isBlank()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invalid name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.name = name.strip(); <span class="comment">// 去掉首尾空格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，外部代码不能直接读取<code>private</code>字段，但可以通过<code>getName()</code>和<code>getAge()</code>间接获取<code>private</code>字段的值。</p><p>所以，一个类通过定义方法，就可以给外部代码暴露一些操作的接口，同时，内部自己保证逻辑一致性。</p><p>调用方法的语法是<code>实例变量.方法名(参数);</code>。一个方法调用就是一个语句，所以不要忘了在末尾加<code>;</code>。例如：<code>ming.setName(&quot;Xiao Ming&quot;);</code>。</p><h3 id="定义方法">定义方法</h3><p>从上面的代码可以看出，定义方法的语法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 方法返回类型 方法名(方法参数列表) &#123;</span><br><span class="line">    若干方法语句;</span><br><span class="line">    <span class="keyword">return</span> 方法返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法返回值通过<code>return</code>语句实现，如果没有返回值，返回类型设置为<code>void</code>，可以省略<code>return</code>。</p><h3 id="private方法">private方法</h3><p>有<code>public</code>方法，自然就有<code>private</code>方法。和<code>private</code>字段一样，<code>private</code>方法不允许外部调用，那我们定义<code>private</code>方法有什么用？</p><p>定义<code>private</code>方法的理由是内部方法是可以调用<code>private</code>方法的。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// private method</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">ming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        ming.setBirth(<span class="number">2008</span>);</span><br><span class="line">        System.out.println(ming.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> birth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBirth</span><span class="params">(<span class="type">int</span> birth)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> calcAge(<span class="number">2019</span>); <span class="comment">// 调用private方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private方法:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calcAge</span><span class="params">(<span class="type">int</span> currentYear)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentYear - <span class="built_in">this</span>.birth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上述代码，<code>calcAge()</code>是一个<code>private</code>方法，外部代码无法调用，但是，内部方法<code>getAge()</code>可以调用它。</p><p>此外，我们还注意到，这个<code>Person</code>类只定义了<code>birth</code>字段，没有定义<code>age</code>字段，获取<code>age</code>时，通过方法<code>getAge()</code>返回的是一个实时计算的值，并非存储在某个字段的值。这说明方法可以封装一个类的对外接口，调用方不需要知道也不关心<code>Person</code>实例在内部到底有没有<code>age</code>字段。</p><h3 id="this变量">this变量</h3><p>在方法内部，可以使用一个隐含的变量<code>this</code>，它始终指向当前实例。因此，通过<code>this.field</code>就可以访问当前实例的字段。</p><p>如果没有命名冲突，可以省略<code>this</code>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name; <span class="comment">// 相当于this.name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上<code>this</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// 前面的this不可少，少了就变成局部变量name了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法参数">方法参数</h3><p>方法可以包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNameAndAge</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用这个<code>setNameAndAge()</code>方法时，必须有两个参数，且第一个参数必须为<code>String</code>，第二个参数必须为<code>int</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">ming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">ming.setNameAndAge(<span class="string">&quot;Xiao Ming&quot;</span>); <span class="comment">// 编译错误：参数个数不对</span></span><br><span class="line">ming.setNameAndAge(<span class="number">12</span>, <span class="string">&quot;Xiao Ming&quot;</span>); <span class="comment">// 编译错误：参数类型不对</span></span><br></pre></td></tr></table></figure><h3 id="可变参数">可变参数</h3><p>可变参数用<code>类型...</code>定义，可变参数相当于数组类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Group</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String[] names;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNames</span><span class="params">(String... names)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.names = names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>setNames()</code>就定义了一个可变参数。调用时，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Group</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Group</span>();</span><br><span class="line">g.setNames(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="string">&quot;Xiao Hong&quot;</span>, <span class="string">&quot;Xiao Jun&quot;</span>); <span class="comment">// 传入3个String</span></span><br><span class="line">g.setNames(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="string">&quot;Xiao Hong&quot;</span>); <span class="comment">// 传入2个String</span></span><br><span class="line">g.setNames(<span class="string">&quot;Xiao Ming&quot;</span>); <span class="comment">// 传入1个String</span></span><br><span class="line">g.setNames(); <span class="comment">// 传入0个String</span></span><br></pre></td></tr></table></figure><p>完全可以把可变参数改写为<code>String[]</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Group</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String[] names;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNames</span><span class="params">(String[] names)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.names = names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，调用方需要自己先构造<code>String[]</code>，比较麻烦。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Group</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Group</span>();</span><br><span class="line">g.setNames(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;Xiao Ming&quot;</span>, <span class="string">&quot;Xiao Hong&quot;</span>, <span class="string">&quot;Xiao Jun&quot;</span>&#125;); <span class="comment">// 传入1个String[]</span></span><br></pre></td></tr></table></figure><p>另一个问题是，调用方可以传入<code>null</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Group</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Group</span>();</span><br><span class="line">g.setNames(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>而可变参数可以保证无法传入<code>null</code>，因为传入0个参数时，接收到的实际值是一个空数组而不是<code>null</code>。</p><h3 id="参数绑定">参数绑定</h3><p>调用方把参数传递给实例方法时，调用时传递的值会按参数位置一一绑定。</p><p>那什么是参数绑定？</p><p>我们先观察一个基本类型参数的传递：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型参数绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">15</span>; <span class="comment">// n的值为15</span></span><br><span class="line">        p.setAge(n); <span class="comment">// 传入n的值</span></span><br><span class="line">        System.out.println(p.getAge()); <span class="comment">// 15</span></span><br><span class="line">        n = <span class="number">20</span>; <span class="comment">// n的值改为20</span></span><br><span class="line">        System.out.println(p.getAge()); <span class="comment">// 15还是20?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，从结果可知，修改外部的局部变量<code>n</code>，不影响实例<code>p</code>的<code>age</code>字段，原因是<code>setAge()</code>方法获得的参数，复制了<code>n</code>的值，因此，<code>p.age</code>和局部变量<code>n</code>互不影响。</p><p>结论：基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。</p><p>我们再看一个传递引用参数的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用类型参数绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        String[] fullname = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;Homer&quot;</span>, <span class="string">&quot;Simpson&quot;</span> &#125;;</span><br><span class="line">        p.setName(fullname); <span class="comment">// 传入fullname数组</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Homer Simpson&quot;</span></span><br><span class="line">        fullname[<span class="number">0</span>] = <span class="string">&quot;Bart&quot;</span>; <span class="comment">// fullname数组的第一个元素修改为&quot;Bart&quot;</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Homer Simpson&quot;还是&quot;Bart Simpson&quot;?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String[] name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name[<span class="number">0</span>] + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.name[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String[] name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>setName()</code>的参数现在是一个数组。一开始，把<code>fullname</code>数组传进去，然后，修改<code>fullname</code>数组的内容，结果发现，实例<code>p</code>的字段<code>p.name</code>也被修改了！</p><p>结论</p><p>引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。</p><p>有了上面的结论，我们再看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用类型参数绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">bob</span> <span class="operator">=</span> <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">        p.setName(bob); <span class="comment">// 传入bob变量</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Bob&quot;</span></span><br><span class="line">        bob = <span class="string">&quot;Alice&quot;</span>; <span class="comment">// bob改名为Alice</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Bob&quot;还是&quot;Alice&quot;?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要怀疑引用参数绑定的机制，试解释为什么上面的代码两次输出都是<code>&quot;Bob&quot;</code>。</p><h3 id="练习-2">练习</h3><p>给<code>Person</code>类增加<code>getAge</code>/<code>setAge</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">ming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        ming.setName(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        ming.setAge(<span class="number">12</span>);</span><br><span class="line">        System.out.println(ming.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/oop/basic/method/oop-method.zip">下载练习</a></p><h3 id="小结-2">小结</h3><ul><li><p>方法可以让外部代码安全地访问实例字段；</p></li><li><p>方法是一组执行语句，并且可以执行任意逻辑；</p></li><li><p>方法内部遇到return时返回，void表示不返回任何值（注意和返回null不同）；</p></li><li><p>外部代码通过public方法操作实例，内部代码可以调用private方法；</p></li><li><p>理解方法的参数绑定。</p></li></ul><h2 id="方法重载">方法重载</h2><p>在一个类中，我们可以定义多个方法。如果有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成<em>同名</em>方法。例如，在<code>Hello</code>类中，定义多个<code>hello()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hi, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法名相同，但各自的参数不同，称为方法重载（<code>Overload</code>）。</p><p>注意：方法重载的返回值类型通常都是相同的。</p><p>方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。</p><p>举个例子，<code>String</code>类提供了多个重载方法<code>indexOf()</code>，可以查找子串：</p><ul><li><code>int indexOf(int ch)</code>：根据字符的Unicode码查找；</li><li><code>int indexOf(String str)</code>：根据字符串查找；</li><li><code>int indexOf(int ch, int fromIndex)</code>：根据字符查找，但指定起始位置；</li><li><code>int indexOf(String str, int fromIndex)</code>根据字符串查找，但指定起始位置。</li></ul><p>试一试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String.indexOf()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Test string&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> s.indexOf(<span class="string">&#x27;t&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> s.indexOf(<span class="string">&quot;st&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> s.indexOf(<span class="string">&quot;st&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">        System.out.println(n3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习-3">练习</h3><p>给<code>Person</code>增加重载方法<code>setName(String, String)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">ming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">hong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        ming.setName(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 给Person增加重载方法setName(String, String):</span></span><br><span class="line">        hong.setName(<span class="string">&quot;Xiao&quot;</span>, <span class="string">&quot;Hong&quot;</span>);</span><br><span class="line">        System.out.println(ming.getName());</span><br><span class="line">        System.out.println(hong.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/oop/basic/overload/oop-overload.zip">下载练习</a></p><h3 id="小结-3">小结</h3><p>方法重载是指多个方法的方法名相同，但各自的参数不同；</p><p>重载方法应该完成类似的功能，参考<code>String</code>的<code>indexOf()</code>；</p><p>重载方法返回值类型应该相同。</p><hr><hr><p>在前面的章节中，我们已经定义了<code>Person</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，假设需要定义一个<code>Student</code>类，字段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细观察，发现<code>Student</code>类包含了<code>Person</code>类已有的字段和方法，只是多出了一个<code>score</code>字段和相应的<code>getScore()</code>、<code>setScore()</code>方法。</p><p>能不能在<code>Student</code>中不要写重复的代码？</p><p>这个时候，继承就派上用场了。</p><p>继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让<code>Student</code>从<code>Person</code>继承时，<code>Student</code>就获得了<code>Person</code>的所有功能，我们只需要为<code>Student</code>编写新增的功能。</p><p>Java使用<code>extends</code>关键字来实现继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 不要重复name和age字段/方法,</span></span><br><span class="line">    <span class="comment">// 只需要定义新增score字段/方法:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，通过继承，<code>Student</code>只需要编写额外的功能，不再需要重复代码。</p><p>注意</p><p>子类自动获得了父类的所有字段，严禁定义与父类重名的字段！</p><p>在OOP的术语中，我们把<code>Person</code>称为超类（super class），父类（parent class），基类（base class），把<code>Student</code>称为子类（subclass），扩展类（extended class）。</p><h3 id="继承树">继承树</h3><p>注意到我们在定义<code>Person</code>的时候，没有写<code>extends</code>。在Java中，没有明确写<code>extends</code>的类，编译器会自动加上<code>extends Object</code>。所以，任何类，除了<code>Object</code>，都会继承自某个类。下图是<code>Person</code>、<code>Student</code>的继承树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌───────────┐</span><br><span class="line">│  Object   │</span><br><span class="line">└───────────┘</span><br><span class="line">      ▲</span><br><span class="line">      │</span><br><span class="line">┌───────────┐</span><br><span class="line">│  Person   │</span><br><span class="line">└───────────┘</span><br><span class="line">      ▲</span><br><span class="line">      │</span><br><span class="line">┌───────────┐</span><br><span class="line">│  Student  │</span><br><span class="line">└───────────┘</span><br></pre></td></tr></table></figure><p>Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有<code>Object</code>特殊，它没有父类。</p><p>类似的，如果我们定义一个继承自<code>Person</code>的<code>Teacher</code>，它们的继承树关系如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">       ┌───────────┐</span><br><span class="line">       │  Object   │</span><br><span class="line">       └───────────┘</span><br><span class="line">             ▲</span><br><span class="line">             │</span><br><span class="line">       ┌───────────┐</span><br><span class="line">       │  Person   │</span><br><span class="line">       └───────────┘</span><br><span class="line">          ▲     ▲</span><br><span class="line">          │     │</span><br><span class="line">          │     │</span><br><span class="line">┌───────────┐ ┌───────────┐</span><br><span class="line">│  Student  │ │  Teacher  │</span><br><span class="line">└───────────┘ └───────────┘</span><br></pre></td></tr></table></figure><h3 id="protected">protected</h3><p>继承有个特点，就是子类无法访问父类的<code>private</code>字段或者<code>private</code>方法。例如，<code>Student</code>类就无法访问<code>Person</code>类的<code>name</code>和<code>age</code>字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name; <span class="comment">// 编译错误：无法访问name字段</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把<code>private</code>改为<code>protected</code>。用<code>protected</code>修饰的字段可以被子类访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name; <span class="comment">// OK!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，<code>protected</code>关键字可以把字段和方法的访问权限控制在继承树内部，一个<code>protected</code>字段和方法可以被其子类，以及子类的子类所访问，后面我们还会详细讲解。</p><h3 id="super">super</h3><p><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + <span class="built_in">super</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，这里使用<code>super.name</code>，或者<code>this.name</code>，或者<code>name</code>，效果都是一样的。编译器会自动定位到父类的<code>name</code>字段。</p><p>但是，在某些时候，就必须使用<code>super</code>。我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// super</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="number">12</span>, <span class="number">89</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的代码，会得到一个编译错误，大意是在<code>Student</code>的构造方法中，无法调用<code>Person</code>的构造方法。</p><p>这是因为在Java中，任何<code>class</code>的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句<code>super();</code>，所以，<code>Student</code>类的构造方法实际上是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 自动调用父类的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，<code>Person</code>类并没有无参数的构造方法，因此，编译失败。</p><p>解决方法是调用<code>Person</code>类存在的某个构造方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age); <span class="comment">// 调用父类的构造方法Person(String, int)</span></span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以正常编译了！</p><p>因此我们得出结论：如果父类没有默认的构造方法，子类就必须显式调用<code>super()</code>并给出参数以便让编译器定位到父类的一个合适的构造方法。</p><p>这里还顺带引出了另一个问题：即子类<em>不会继承</em>任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</p><h3 id="阻止继承">阻止继承</h3><p>正常情况下，只要某个class没有<code>final</code>修饰符，那么任何类都可以从该class继承。</p><p>从Java 15开始，允许使用<code>sealed</code>修饰class，并通过<code>permits</code>明确写出能够从该class继承的子类名称。</p><p>例如，定义一个<code>Shape</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Shape</span> <span class="keyword">permits</span> Rect, Circle, Triangle &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述<code>Shape</code>类就是一个<code>sealed</code>类，它只允许指定的3个类继承它。如果写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Rect</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>是没问题的，因为<code>Rect</code>出现在<code>Shape</code>的<code>permits</code>列表中。但是，如果定义一个<code>Ellipse</code>就会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Ellipse</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;...&#125;</span><br><span class="line"><span class="comment">// Compile error: class is not allowed to extend sealed class: Shape</span></span><br></pre></td></tr></table></figure><p>原因是<code>Ellipse</code>并未出现在<code>Shape</code>的<code>permits</code>列表中。这种<code>sealed</code>类主要用于一些框架，防止继承被滥用。</p><p><code>sealed</code>类在Java 15中目前是预览状态，要启用它，必须使用参数<code>--enable-preview</code>和<code>--source 15</code>。</p><h3 id="向上转型">向上转型</h3><p>如果一个引用变量的类型是<code>Student</code>，那么它可以指向一个<code>Student</code>类型的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure><p>如果一个引用类型的变量是<code>Person</code>，那么它可以指向一个<code>Person</code>类型的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure><p>现在问题来了：如果<code>Student</code>是从<code>Person</code>继承下来的，那么，一个引用类型为<code>Person</code>的变量，能否指向<code>Student</code>类型的实例？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">// ???</span></span><br></pre></td></tr></table></figure><p>测试一下就可以发现，这种指向是允许的！</p><p>这是因为<code>Student</code>继承自<code>Person</code>，因此，它拥有<code>Person</code>的全部功能。<code>Person</code>类型的变量，如果指向<code>Student</code>类型的实例，对它进行操作，是没有问题的！</p><p>这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。</p><p>向上转型实际上是把一个子类型安全地变为更加抽象的父类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> s; <span class="comment">// upcasting, ok</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> p; <span class="comment">// upcasting, ok</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> s; <span class="comment">// upcasting, ok</span></span><br></pre></td></tr></table></figure><p>注意到继承树是<code>Student &gt; Person &gt; Object</code>，所以，可以把<code>Student</code>类型转型为<code>Person</code>，或者更高层次的<code>Object</code>。</p><h3 id="向下转型">向下转型</h3><p>和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">// upcasting, ok</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> (Student) p1; <span class="comment">// ok</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> (Student) p2; <span class="comment">// runtime error! ClassCastException!</span></span><br></pre></td></tr></table></figure><p>如果测试上面的代码，可以发现：</p><p><code>Person</code>类型<code>p1</code>实际指向<code>Student</code>实例，<code>Person</code>类型变量<code>p2</code>实际指向<code>Person</code>实例。在向下转型的时候，把<code>p1</code>转型为<code>Student</code>会成功，因为<code>p1</code>确实指向<code>Student</code>实例，把<code>p2</code>转型为<code>Student</code>会失败，因为<code>p2</code>的实际类型是<code>Person</code>，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。</p><p>因此，向下转型很可能会失败。失败的时候，Java虚拟机会报<code>ClassCastException</code>。</p><p>为了避免向下转型出错，Java提供了<code>instanceof</code>操作符，可以先判断一个实例究竟是不是某种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Student); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">n</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(n <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>instanceof</code>实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为<code>null</code>，那么对任何<code>instanceof</code>的判断都为<code>false</code>。</p><p>利用<code>instanceof</code>，在向下转型前可以先判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">    <span class="comment">// 只有判断成功才会向下转型:</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) p; <span class="comment">// 一定会成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从Java 14开始，判断<code>instanceof</code>后，可以直接转型为指定变量，避免再次强制转型。例如，对于以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) obj;</span><br><span class="line">    System.out.println(s.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instanceof variable:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">            <span class="comment">// 可以直接使用变量s:</span></span><br><span class="line">            System.out.println(s.toUpperCase());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种使用<code>instanceof</code>的写法更加简洁。</p><h3 id="区分继承和组合">区分继承和组合</h3><p>在使用继承时，我们要注意逻辑一致性。</p><p>考察下面的<code>Book</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>Book</code>类也有<code>name</code>字段，那么，我们能不能让<code>Student</code>继承自<code>Book</code>呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，从逻辑上讲，这是不合理的，<code>Student</code>不应该从<code>Book</code>继承，而应该从<code>Person</code>继承。</p><p>究其原因，是因为<code>Student</code>是<code>Person</code>的一种，它们是is关系，而<code>Student</code>并不是<code>Book</code>。实际上<code>Student</code>和<code>Book</code>的关系是has关系。</p><p>具有has关系不应该使用继承，而是使用组合，即<code>Student</code>可以持有一个<code>Book</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Book book;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，继承是is关系，组合是has关系。</p><h3 id="练习-4">练习</h3><p>定义<code>PrimaryStudent</code>，从<code>Student</code>继承，并新增一个<code>grade</code>字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小红&quot;</span>, <span class="number">20</span>, <span class="number">99</span>);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 定义PrimaryStudent，从Student继承，新增grade字段:</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrimaryStudent</span>(<span class="string">&quot;小军&quot;</span>, <span class="number">9</span>, <span class="number">100</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(ps.getScore());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123; <span class="built_in">this</span>.age = age; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123; <span class="keyword">return</span> score; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrimaryStudent</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/oop/basic/inherit/oop-inherit.zip">下载练习</a></p><h3 id="小结-4">小结</h3><p>继承是面向对象编程的一种强大的代码复用方式；</p><p>Java只允许单继承，所有类最终的根类是<code>Object</code>；</p><p><code>protected</code>允许子类访问父类的字段和方法；</p><p>子类的构造方法可以通过<code>super()</code>调用父类的构造方法；</p><p>可以安全地向上转型为更抽象的类型；</p><p>可以强制向下转型，最好借助<code>instanceof</code>判断；</p><p>子类和父类的关系是is，has关系不能用继承。</p><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。</p><p>例如，在<code>Person</code>类中，我们定义了<code>run()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person.run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子类<code>Student</code>中，覆写这个<code>run()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student.run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Override和Overload不同的是，如果方法签名不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是<code>Override</code>。</p><p>注意</p><p>方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 不是Override，因为参数不同:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String s)</span> &#123; … &#125;</span><br><span class="line">    <span class="comment">// 不是Override，因为返回值不同:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">run</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上<code>@Override</code>可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// Compile error!</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String s)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是<code>@Override</code>不是必需的。</p><p>在上一节中，我们已经知道，引用变量的声明类型可能与其实际类型不符，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure><p>现在，我们考虑一种情况，如果子类覆写了父类的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        p.run(); <span class="comment">// 应该打印Person.run还是Student.run?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person.run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student.run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，一个实际类型为<code>Student</code>，引用类型为<code>Person</code>的变量，调用其<code>run()</code>方法，调用的是<code>Person</code>还是<code>Student</code>的<code>run()</code>方法？</p><p>运行一下上面的代码就可以知道，实际上调用的方法是<code>Student</code>的<code>run()</code>方法。因此可得出结论：</p><p>Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。</p><p>这个非常重要的特性在面向对象编程中称之为多态。它的英文拼写非常复杂：Polymorphic。</p><h3 id="多态">多态</h3><p>多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">p.run(); <span class="comment">// 无法确定运行时究竟调用哪个run()方法</span></span><br></pre></td></tr></table></figure><p>有同学会说，从上面的代码一看就明白，肯定调用的是<code>Student</code>的<code>run()</code>方法啊。</p><p>但是，假设我们编写这样一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTwice</span><span class="params">(Person p)</span> &#123;</span><br><span class="line">    p.run();</span><br><span class="line">    p.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它传入的参数类型是<code>Person</code>，我们是无法知道传入的参数实际类型究竟是<code>Person</code>，还是<code>Student</code>，还是<code>Person</code>的其他子类例如<code>Teacher</code>，因此，也无法确定调用的是不是<code>Person</code>类定义的<code>run()</code>方法。</p><p>所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？</p><p>我们还是来举例子。</p><p>假设我们定义一种收入，需要给它报税，那么先定义一个<code>Income</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Income</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">double</span> income;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> income * <span class="number">0.1</span>; <span class="comment">// 税率10%</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于工资收入，可以减去一个基数，那么我们可以从<code>Income</code>派生出<code>SalaryIncome</code>，并覆写<code>getTax()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Salary</span> <span class="keyword">extends</span> <span class="title class_">Income</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (income &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (income - <span class="number">5000</span>) * <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你享受国务院特殊津贴，那么按照规定，可以全部免税：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StateCouncilSpecialAllowance</span> <span class="keyword">extends</span> <span class="title class_">Income</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">totalTax</span><span class="params">(Income... incomes)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Income income: incomes) &#123;</span><br><span class="line">        total = total + income.getTax();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Polymorphic</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:</span></span><br><span class="line">        Income[] incomes = <span class="keyword">new</span> <span class="title class_">Income</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Income</span>(<span class="number">3000</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Salary</span>(<span class="number">7500</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StateCouncilSpecialAllowance</span>(<span class="number">15000</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(totalTax(incomes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">totalTax</span><span class="params">(Income... incomes)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Income income: incomes) &#123;</span><br><span class="line">            total = total + income.getTax();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Income</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">double</span> income;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Income</span><span class="params">(<span class="type">double</span> income)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.income = income;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> income * <span class="number">0.1</span>; <span class="comment">// 税率10%</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Salary</span> <span class="keyword">extends</span> <span class="title class_">Income</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Salary</span><span class="params">(<span class="type">double</span> income)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(income);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (income &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (income - <span class="number">5000</span>) * <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StateCouncilSpecialAllowance</span> <span class="keyword">extends</span> <span class="title class_">Income</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StateCouncilSpecialAllowance</span><span class="params">(<span class="type">double</span> income)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(income);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察<code>totalTax()</code>方法：利用多态，<code>totalTax()</code>方法只需要和<code>Income</code>打交道，它完全不需要知道<code>Salary</code>和<code>StateCouncilSpecialAllowance</code>的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从<code>Income</code>派生，然后正确覆写<code>getTax()</code>方法就可以。把新的类型传入<code>totalTax()</code>，不需要修改任何代码。</p><p>可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。</p><h3 id="覆写Object方法">覆写Object方法</h3><p>因为所有的<code>class</code>最终都继承自<code>Object</code>，而<code>Object</code>定义了几个重要的方法：</p><ul><li><code>toString()</code>：把instance输出为<code>String</code>；</li><li><code>equals()</code>：判断两个instance是否逻辑相等；</li><li><code>hashCode()</code>：计算一个instance的哈希值。</li></ul><p>在必要的情况下，我们可以覆写<code>Object</code>的这几个方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 显示更有意义的字符串:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person:name=&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较是否相等:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">// 当且仅当o为Person类型:</span></span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">            <span class="comment">// 并且name字段相同时，返回true:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name.equals(p.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算hash:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用super">调用super</h3><p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类的hello()方法:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.hello() + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="final">final</h3><p>继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// compile error: 不允许覆写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为<code>final</code>。用<code>final</code>修饰的类不能被继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile error: 不允许继承自Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个类的实例字段，同样可以用<code>final</code>修饰。用<code>final</code>修饰的字段在初始化后不能被修改。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Unamed&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对<code>final</code>字段重新赋值会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.name = <span class="string">&quot;New Name&quot;</span>; <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>可以在构造方法中初始化final字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法更为常用，因为可以保证实例一旦创建，其<code>final</code>字段就不可修改。</p><h3 id="练习-5">练习</h3><p>给一个有工资收入和稿费收入的小伙伴算税。</p><p><a href="https://liaoxuefeng.com/books/java/oop/basic/polymorphic/oop-polymorphic.zip">下载练习</a></p><h3 id="小结-5">小结</h3><p>子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为；</p><p>Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；</p><p><code>final</code>修饰符有多种作用：</p><ul><li><code>final</code>修饰的方法可以阻止被覆写；</li><li><code>final</code>修饰的class可以阻止被继承；</li><li><code>final</code>修饰的field必须在创建对象时初始化，随后不可修改。</li></ul><p>由于多态的存在，每个子类都可以覆写父类的方法，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>Person</code>类派生的<code>Student</code>和<code>Teacher</code>都可以覆写<code>run()</code>方法。</p><p>如果父类<code>Person</code>的<code>run()</code>方法没有实际意义，能否去掉方法的执行语句？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>; <span class="comment">// Compile Error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是不行，会导致编译错误，因为定义方法的时候，必须实现方法的语句。</p><p>能不能去掉父类的<code>run()</code>方法？</p><p>答案还是不行，因为去掉父类的<code>run()</code>方法，就失去了多态的特性。例如，<code>runTwice()</code>就无法编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTwice</span><span class="params">(Person p)</span> &#123;</span><br><span class="line">    p.run(); <span class="comment">// Person没有run()方法，会导致编译错误</span></span><br><span class="line">    p.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把一个方法声明为<code>abstract</code>，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，<code>Person</code>类也无法被实例化。编译器会告诉我们，无法编译<code>Person</code>类，因为它包含抽象方法。</p><p>必须把<code>Person</code>类本身也声明为<code>abstract</code>，才能正确编译它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类">抽象类</h3><p>如果一个<code>class</code>定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用<code>abstract</code>修饰。</p><p>因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。</p><p>使用<code>abstract</code>修饰的类就是抽象类。我们无法实例化一个抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><p>无法实例化的抽象类有什么用？</p><p>因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。</p><p>例如，<code>Person</code>类定义了抽象方法<code>run()</code>，那么，在实现子类<code>Student</code>的时候，就必须覆写<code>run()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// abstract class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student.run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面向抽象编程">面向抽象编程</h3><p>当我们定义了抽象类<code>Person</code>，以及具体的<code>Student</code>、<code>Teacher</code>子类的时候，我们可以通过抽象类<code>Person</code>类型去引用具体的子类的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br></pre></td></tr></table></figure><p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心<code>Person</code>类型变量的具体子类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不关心Person变量的具体子类型:</span></span><br><span class="line">s.run();</span><br><span class="line">t.run();</span><br></pre></td></tr></table></figure><p>同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样不关心新的子类是如何实现run()方法的：</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">e.run();</span><br></pre></td></tr></table></figure><p>这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p><p>面向抽象编程的本质就是：</p><ul><li>上层代码只定义规范（例如：<code>abstract class Person</code>）；</li><li>不需要子类就可以实现业务逻辑（正常编译）；</li><li>具体的业务逻辑由不同的子类实现，调用者并不关心。</li></ul><h3 id="练习-6">练习</h3><p>用抽象类给一个有工资收入和稿费收入的小伙伴算税。</p><p><a href="https://liaoxuefeng.com/books/java/oop/basic/abstract-class/oop-abstractclass.zip">下载练习</a></p><h3 id="小结-6">小结</h3><p>通过<code>abstract</code>定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；</p><p>定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法；</p><p>如果不实现抽象方法，则该子类仍是一个抽象类；</p><p>面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。</p><p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p><p>如果一个抽象类没有字段，所有方法全部都是抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以把该抽象类改写为接口：<code>interface</code>。</p><p>在Java中，使用<code>interface</code>可以声明一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样）。</p><p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个<code>interface</code>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Hello &#123; <span class="comment">// 实现了两个interface</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="术语">术语</h3><p>注意区分术语：</p><p>Java的接口特指<code>interface</code>的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。</p><p>抽象类和接口的对比如下：</p><table><thead><tr><th></th><th>abstract class</th><th>interface</th></tr></thead><tbody><tr><td>继承</td><td>只能extends一个class</td><td>可以implements多个interface</td></tr><tr><td>字段</td><td>可以定义实例字段</td><td>不能定义实例字段</td></tr><tr><td>抽象方法</td><td>可以定义抽象方法</td><td>可以定义抽象方法</td></tr><tr><td>非抽象方法</td><td>可以定义非抽象方法</td><td>可以定义default方法</td></tr></tbody></table><h3 id="接口继承">接口继承</h3><p>一个<code>interface</code>可以继承自另一个<code>interface</code>。<code>interface</code>继承自<code>interface</code>使用<code>extends</code>，它相当于扩展了接口的方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，<code>Person</code>接口继承自<code>Hello</code>接口，因此，<code>Person</code>接口现在实际上有3个抽象方法签名，其中一个来自继承的<code>Hello</code>接口。</p><h3 id="继承关系">继承关系</h3><p>合理设计<code>interface</code>和<code>abstract class</code>的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在<code>abstract class</code>中，具体逻辑放到各个子类，而接口层次代表抽象程度。可以参考Java的集合类定义的一组接口、抽象类以及具体子类的继承关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────┐</span><br><span class="line">│   Iterable    │</span><br><span class="line">└───────────────┘</span><br><span class="line">        ▲                ┌───────────────────┐</span><br><span class="line">        │                │      Object       │</span><br><span class="line">┌───────────────┐        └───────────────────┘</span><br><span class="line">│  Collection   │                  ▲</span><br><span class="line">└───────────────┘                  │</span><br><span class="line">        ▲     ▲          ┌───────────────────┐</span><br><span class="line">        │     └──────────│AbstractCollection │</span><br><span class="line">┌───────────────┐        └───────────────────┘</span><br><span class="line">│     List      │                  ▲</span><br><span class="line">└───────────────┘                  │</span><br><span class="line">              ▲          ┌───────────────────┐</span><br><span class="line">              └──────────│   AbstractList    │</span><br><span class="line">                         └───────────────────┘</span><br><span class="line">                                ▲     ▲</span><br><span class="line">                                │     │</span><br><span class="line">                                │     │</span><br><span class="line">                     ┌────────────┐ ┌────────────┐</span><br><span class="line">                     │ ArrayList  │ │ LinkedList │</span><br><span class="line">                     └────────────┘ └────────────┘</span><br></pre></td></tr></table></figure><p>在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">// 用List接口引用具体子类的实例</span></span><br><span class="line"><span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> list; <span class="comment">// 向上转型为Collection接口</span></span><br><span class="line"><span class="type">Iterable</span> <span class="variable">it</span> <span class="operator">=</span> coll; <span class="comment">// 向上转型为Iterable接口</span></span><br></pre></td></tr></table></figure><h3 id="default方法">default方法</h3><p>在接口中，可以定义<code>default</code>方法。例如，把<code>Person</code>接口的<code>run()</code>方法改为<code>default</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类可以不必覆写<code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p><p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p><h3 id="练习-7">练习</h3><p>用接口给一个有工资收入和稿费收入的小伙伴算税。</p><p><a href="https://liaoxuefeng.com/books/java/oop/basic/interface/oop-interface.zip">下载练习</a></p><h3 id="小结-7">小结</h3><p>Java的接口（interface）定义了纯抽象规范，一个类可以实现多个接口；</p><p>接口也是数据类型，适用于向上转型和向下转型；</p><p>接口的所有方法都是抽象方法，接口不能定义实例字段；</p><p>接口可以定义<code>default</code>方法（JDK&gt;=1.8）。</p><p>在一个<code>class</code>中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。</p><p>还有一种字段，是用<code>static</code>修饰的字段，称为静态字段：<code>static field</code>。</p><p>实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 定义静态字段number:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static field</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">ming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">hong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Hong&quot;</span>, <span class="number">15</span>);</span><br><span class="line">        ming.number = <span class="number">88</span>;</span><br><span class="line">        System.out.println(hong.number);</span><br><span class="line">        hong.number = <span class="number">99</span>;</span><br><span class="line">        System.out.println(ming.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了，原因是静态字段并不属于实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        ┌──────────────────┐</span><br><span class="line">ming ──▶│Person instance   │</span><br><span class="line">        ├──────────────────┤</span><br><span class="line">        │name = &quot;Xiao Ming&quot;│</span><br><span class="line">        │age = 12          │</span><br><span class="line">        │number ───────────┼──┐    ┌─────────────┐</span><br><span class="line">        └──────────────────┘  │    │Person class │</span><br><span class="line">                              │    ├─────────────┤</span><br><span class="line">                              ├───▶│number = 99  │</span><br><span class="line">        ┌──────────────────┐  │    └─────────────┘</span><br><span class="line">hong ──▶│Person instance   │  │</span><br><span class="line">        ├──────────────────┤  │</span><br><span class="line">        │name = &quot;Xiao Hong&quot;│  │</span><br><span class="line">        │age = 15          │  │</span><br><span class="line">        │number ───────────┼──┘</span><br><span class="line">        └──────────────────┘</span><br></pre></td></tr></table></figure><p>虽然实例可以访问静态字段，但是它们指向的其实都是<code>Person class</code>的静态字段。所以，所有实例共享一个静态字段。</p><p>因此，不推荐用<code>实例变量.静态字段</code>去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为<code>类名.静态字段</code>来访问静态对象。</p><p>推荐用类名来访问静态字段。可以把静态字段理解为描述<code>class</code>本身的字段。对于上面的代码，更好的写法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.number = <span class="number">99</span>;</span><br><span class="line">System.out.println(Person.number);</span><br></pre></td></tr></table></figure><h3 id="静态方法">静态方法</h3><p>有静态字段，就有静态方法。用<code>static</code>修饰的方法称为静态方法。</p><p>调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static method</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Person.setNumber(<span class="number">99</span>);</span><br><span class="line">        System.out.println(Person.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        number = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为静态方法属于<code>class</code>而不属于实例，因此，静态方法内部，无法访问<code>this</code>变量，也无法访问实例字段，它只能访问静态字段。</p><p>通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。</p><p>通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。</p><p>静态方法经常用于工具类。例如：</p><ul><li>Arrays.sort()</li><li>Math.random()</li></ul><p>静态方法也经常用于辅助方法。注意到Java程序的入口<code>main()</code>也是静态方法。</p><h3 id="接口的静态字段">接口的静态字段</h3><p>因为<code>interface</code>是一个纯抽象类，所以它不能定义实例字段。但是，<code>interface</code>是可以有静态字段的，并且静态字段必须为<code>final</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MALE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FEMALE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，因为<code>interface</code>的字段只能是<code>public static final</code>类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 编译器会自动加上public static final:</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">MALE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">FEMALE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会自动把该字段变为<code>public static final</code>类型。</p><h3 id="练习-8">练习</h3><p>给<code>Person</code>类增加一个静态字段<code>count</code>和静态方法<code>getCount()</code>，统计实例创建的个数。</p><p><a href="https://liaoxuefeng.com/books/java/oop/basic/static/oop-static.zip">下载练习</a></p><h3 id="小结-8">小结</h3><p>静态字段属于所有实例“共享”的字段，实际上是属于<code>class</code>的字段；</p><p>调用静态方法不需要实例，无法访问<code>this</code>，但可以访问静态字段和其他静态方法；</p><p>静态方法常用于工具类和辅助方法。</p><p>在前面的代码中，我们把类和接口命名为<code>Person</code>、<code>Student</code>、<code>Hello</code>等简单名字。</p><p>在现实中，如果小明写了一个<code>Person</code>类，小红也写了一个<code>Person</code>类，现在，小白既想用小明的<code>Person</code>，也想用小红的<code>Person</code>，怎么办？</p><p>如果小军写了一个<code>Arrays</code>类，恰好JDK也自带了一个<code>Arrays</code>类，如何解决类名冲突？</p><p>在Java中，我们使用<code>package</code>来解决名字冲突。</p><p>Java定义了一种名字空间，称之为包：<code>package</code>。一个类总是属于某个包，类名（比如<code>Person</code>）只是一个简写，真正的完整类名是<code>包名.类名</code>。</p><p>例如：</p><p>小明的<code>Person</code>类存放在包<code>ming</code>下面，因此，完整类名是<code>ming.Person</code>；</p><p>小红的<code>Person</code>类存放在包<code>hong</code>下面，因此，完整类名是<code>hong.Person</code>；</p><p>小军的<code>Arrays</code>类存放在包<code>mr.jun</code>下面，因此，完整类名是<code>mr.jun.Arrays</code>；</p><p>JDK的<code>Arrays</code>类存放在包<code>java.util</code>下面，因此，完整类名是<code>java.util.Arrays</code>。</p><p>在定义<code>class</code>的时候，我们需要在第一行声明这个<code>class</code>属于哪个包。</p><p>小明的<code>Person.java</code>文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ming; <span class="comment">// 申明包名ming</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小军的<code>Arrays.java</code>文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mr.jun; <span class="comment">// 申明包名mr.jun</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Arrays</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。</p><p>包可以是多层结构，用<code>.</code>隔开。例如：<code>java.util</code>。</p><p>特别注意</p><p>包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</p><p>没有定义包名的<code>class</code>，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。</p><p>我们还需要按照包结构把上面的Java文件组织起来。假设以<code>package_sample</code>作为根目录，<code>src</code>作为源码目录，那么所有文件结构就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ src</span><br><span class="line">    ├─ hong</span><br><span class="line">    │  └─ Person.java</span><br><span class="line">    │  ming</span><br><span class="line">    │  └─ Person.java</span><br><span class="line">    └─ mr</span><br><span class="line">       └─ jun</span><br><span class="line">          └─ Arrays.java</span><br></pre></td></tr></table></figure><p>即所有Java文件对应的目录层次要和包的层次一致。</p><p>编译后的<code>.class</code>文件也需要按照包结构存放。如果使用IDE，把编译后的<code>.class</code>文件放到<code>bin</code>目录下，那么，编译的文件结构就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ bin</span><br><span class="line">   ├─ hong</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   │  ming</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   └─ mr</span><br><span class="line">      └─ jun</span><br><span class="line">         └─ Arrays.class</span><br></pre></td></tr></table></figure><h3 id="包作用域">包作用域</h3><p>位于同一个包的类，可以访问包作用域的字段和方法。不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。例如，<code>Person</code>类定义在<code>hello</code>包下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 包作用域:</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Main</code>类也定义在<code>hello</code>包下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.hello(); <span class="comment">// 可以调用，因为Main和Person在同一个包</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="import">import</h3><p>在一个<code>class</code>中，我们总会引用其他的<code>class</code>。例如，小明的<code>ming.Person</code>类，如果要引用小军的<code>mr.jun.Arrays</code>类，他有三种写法：</p><p>第一种，直接写出完整类名，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写完整类名: mr.jun.Arrays</span></span><br><span class="line">        mr.jun.<span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mr</span>.jun.Arrays();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，每次写完整类名比较痛苦。</p><p>因此，第二种写法是用<code>import</code>语句，导入小军的<code>Arrays</code>，然后写简单类名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入完整类名:</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写简单类名: Arrays</span></span><br><span class="line">        <span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arrays</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的所有<code>class</code>都导入进来（但不包括子包的<code>class</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入mr.jun包的所有class:</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arrays</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一般不推荐这种写法，因为在导入了多个包后，很难看出<code>Arrays</code>类属于哪个包。</p><p>还有一种<code>import static</code>的语法，它可以导入一个类的静态字段和静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入System类的所有静态字段和静态方法:</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 相当于调用System.out.println(…)</span></span><br><span class="line">        out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>import static</code>很少使用。</p><p>Java编译器最终编译出的<code>.class</code>文件只使用<em>完整类名</em>，因此，在代码中，当编译器遇到一个<code>class</code>名称时：</p><ul><li>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</li><li>如果是简单类名，按下面的顺序依次查找：<ul><li>查找当前<code>package</code>是否存在这个<code>class</code>；</li><li>查找<code>import</code>的包是否包含这个<code>class</code>；</li><li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li></ul></li></ul><p>如果按照上面的规则还无法确定类名，则编译报错。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.Format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        java.util.List list; <span class="comment">// ok，使用完整类名 -&gt; java.util.List</span></span><br><span class="line">        <span class="type">Format</span> <span class="variable">format</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// ok，使用import的类 -&gt; java.text.Format</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hi&quot;</span>; <span class="comment">// ok，使用java.lang包的String -&gt; java.lang.String</span></span><br><span class="line">        System.out.println(s); <span class="comment">// ok，使用java.lang包的System -&gt; java.lang.System</span></span><br><span class="line">        <span class="type">MessageFormat</span> <span class="variable">mf</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 编译错误：无法找到MessageFormat: MessageFormat cannot be resolved to a type</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，编写class的时候，编译器会自动帮我们做两个import动作：</p><ul><li>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</li><li>默认自动<code>import java.lang.*</code>。</li></ul><p>注意</p><p>自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。</p><p>如果有两个<code>class</code>名称相同，例如，<code>mr.jun.Arrays</code>和<code>java.util.Arrays</code>，那么只能<code>import</code>其中一个，另一个必须写完整类名。</p><h3 id="最佳实践">最佳实践</h3><p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：</p><ul><li>org.apache</li><li>org.apache.commons.log</li><li>com.liaoxuefeng.sample</li></ul><p>子包就可以根据功能自行命名。</p><p>要注意不要和<code>java.lang</code>包的类重名，即自己的类不要使用这些名字：</p><ul><li>String</li><li>System</li><li>Runtime</li><li>…</li></ul><p>要注意也不要和JDK常用类重名：</p><ul><li>java.util.List</li><li>java.text.Format</li><li>java.math.BigInteger</li><li>…</li></ul><h3 id="编译和运行">编译和运行</h3><p>假设我们创建了如下的目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">work</span><br><span class="line">├── bin</span><br><span class="line">└── src</span><br><span class="line">    └── com</span><br><span class="line">        └── itranswarp</span><br><span class="line">            ├── sample</span><br><span class="line">            │   └── Main.java</span><br><span class="line">            └── world</span><br><span class="line">                └── Person.java</span><br></pre></td></tr></table></figure><p>其中，<code>bin</code>目录用于存放编译后的<code>class</code>文件，<code>src</code>目录按包结构存放Java源码，我们怎么一次性编译这些Java源码呢？</p><p>首先，确保当前目录是<code>work</code>目录，即存放<code>src</code>和<code>bin</code>的父目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">bin src</span><br></pre></td></tr></table></figure><p>然后，编译<code>src</code>目录下的所有Java文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javac -d ./bin src/**/*.java</span><br></pre></td></tr></table></figure><p>命令行<code>-d</code>指定输出的<code>class</code>文件存放<code>bin</code>目录，后面的参数<code>src/**/*.java</code>表示<code>src</code>目录下的所有<code>.java</code>文件，包括任意深度的子目录。</p><p>注意：Windows不支持<code>**</code>这种搜索全部子目录的做法，所以在Windows下编译必须依次列出所有<code>.java</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\work&gt; javac -d bin src\com\itranswarp\sample\Main.java src\com\itranswarp\world\Persion.java</span><br></pre></td></tr></table></figure><p>使用Windows的PowerShell可以利用<code>Get-ChildItem</code>来列出指定目录下的所有<code>.java</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\work&gt; (Get-ChildItem -Path .\src -Recurse -Filter *.java).FullName</span><br><span class="line">C:\work\src\com\itranswarp\sample\Main.java</span><br><span class="line">C:\work\src\com\itranswarp\world\Person.java</span><br></pre></td></tr></table></figure><p>因此，编译命令可写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\work&gt; javac -d .\bin (Get-ChildItem -Path .\src -Recurse -Filter *.java).FullName</span><br></pre></td></tr></table></figure><p>如果编译无误，则<code>javac</code>命令没有任何输出。可以在<code>bin</code>目录下看到如下<code>class</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bin</span><br><span class="line">└── com</span><br><span class="line">    └── itranswarp</span><br><span class="line">        ├── sample</span><br><span class="line">        │   └── Main.class</span><br><span class="line">        └── world</span><br><span class="line">            └── Person.class</span><br></pre></td></tr></table></figure><p>现在，我们就可以直接运行<code>class</code>文件了。根据当前目录的位置确定classpath，例如，当前目录仍为<code>work</code>，则classpath为<code>bin</code>或者<code>./bin</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java -cp bin com.itranswarp.sample.Main </span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><h3 id="练习-9">练习</h3><p>请按如下包结构创建工程项目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">oop-package</span><br><span class="line">└── src</span><br><span class="line">    └── com</span><br><span class="line">        └── itranswarp</span><br><span class="line">            ├── sample</span><br><span class="line">            │   └── Main.java</span><br><span class="line">            └── world</span><br><span class="line">                └── Person.java</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/oop/basic/package/oop-package.zip">下载练习</a></p><h3 id="小结-9">小结</h3><p>Java内建的<code>package</code>机制是为了避免<code>class</code>命名冲突；</p><p>JDK的核心类使用<code>java.lang</code>包，编译器会自动导入；</p><p>JDK的其它常用类定义在<code>java.util.*</code>，<code>java.math.*</code>，<code>java.text.*</code>，……；</p><p>包名推荐使用倒置的域名，例如<code>org.apache</code>。</p><p>在Java中，我们经常看到<code>public</code>、<code>protected</code>、<code>private</code>这些修饰符。在Java中，这些修饰符可以用来限定访问作用域。</p><h3 id="public">public</h3><p>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他任何类访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>Hello</code>是<code>public</code>，因此，可以被其他包的类访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Main可以访问Hello</span></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义为<code>public</code>的<code>field</code>、<code>method</code>可以被其他类访问，前提是首先有访问<code>class</code>的权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>hi()</code>方法是<code>public</code>，可以被其他类调用，前提是首先要能访问<code>Hello</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">        h.hi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="private">private</h3><p>定义为<code>private</code>的<code>field</code>、<code>method</code>无法被其他类访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="comment">// 不能被其他类调用:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，确切地说，<code>private</code>访问权限被限定在<code>class</code>的内部，而且与方法声明顺序<em>无关</em>。推荐把<code>private</code>方法放到后面，因为<code>public</code>方法定义了类对外提供的功能，阅读代码的时候，应该先关注<code>public</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问<code>private</code>的权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// private</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        i.hi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private方法:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类:</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">            Main.hello();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义在一个<code>class</code>内部的<code>class</code>称为嵌套类（<code>nested class</code>），Java支持好几种嵌套类。</p><h3 id="protected-2">protected</h3><p><code>protected</code>作用于继承关系。定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="comment">// protected方法:</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>protected</code>方法可以被继承的类访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> <span class="keyword">extends</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 可以访问protected方法:</span></span><br><span class="line">        hi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="package">package</h3><p>最后，包作用域是指一个类允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"><span class="comment">// package权限的类:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="comment">// package权限的方法:</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要在同一个包，就可以访问<code>package</code>权限的<code>class</code>、<code>field</code>和<code>method</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 可以访问package权限的类:</span></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">        <span class="comment">// 可以调用package权限的方法:</span></span><br><span class="line">        h.hi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，包名必须完全一致，包没有父子关系，<code>com.apache</code>和<code>com.apache.abc</code>是不同的包。</p><h3 id="局部变量">局部变量</h3><p>在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">(String name)</span> &#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> name.toLowerCase(); <span class="comment">// 2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length(); <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">10</span>) &#123; <span class="comment">// 4</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">10</span> - len; <span class="comment">// 5</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123; <span class="comment">// 6</span></span><br><span class="line">                System.out.println(); <span class="comment">// 7</span></span><br><span class="line">            &#125; <span class="comment">// 8</span></span><br><span class="line">        &#125; <span class="comment">// 9</span></span><br><span class="line">    &#125; <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们观察上面的<code>hi()</code>方法代码：</p><ul><li>方法参数name是局部变量，它的作用域是整个方法，即1 ~ 10；</li><li>变量s的作用域是定义处到方法结束，即2 ~ 10；</li><li>变量len的作用域是定义处到方法结束，即3 ~ 10；</li><li>变量p的作用域是定义处到if块结束，即5 ~ 9；</li><li>变量i的作用域是for循环，即6 ~ 8。</li></ul><p>使用局部变量时，应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量。</p><h3 id="final-2">final</h3><p>Java还提供了一个<code>final</code>修饰符。<code>final</code>与访问权限不冲突，它有很多作用。</p><p>用<code>final</code>修饰<code>class</code>可以阻止被继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法被继承:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">(<span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>final</code>修饰<code>method</code>可以阻止被子类覆写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="comment">// 无法被覆写:</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>final</code>修饰<code>field</code>可以阻止被重新赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = <span class="number">1</span>; <span class="comment">// error!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>final</code>修饰局部变量可以阻止被重新赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        t = <span class="number">1</span>; <span class="comment">// error!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最佳实践-2">最佳实践</h3><p>如果不确定是否需要<code>public</code>，就不声明为<code>public</code>，即尽可能少地暴露对外的字段和方法。</p><p>把方法定义为<code>package</code>权限有助于测试，因为测试类和被测试类只要位于同一个<code>package</code>，测试代码就可以访问被测试类的<code>package</code>权限方法。</p><p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同。</p><h3 id="小结-10">小结</h3><p>Java内建的访问权限包括<code>public</code>、<code>protected</code>、<code>private</code>和<code>package</code>权限；</p><p>Java在方法内部定义的变量是局部变量，局部变量的作用域从变量声明开始，到一个块结束；</p><p><code>final</code>修饰符不是访问权限，它可以修饰<code>class</code>、<code>field</code>和<code>method</code>；</p><p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。</p><p>在Java程序中，通常情况下，我们把不同的类组织在不同的包下面，对于一个包下面的类来说，它们是在同一层次，没有父子关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang</span><br><span class="line">├── Math</span><br><span class="line">├── Runnable</span><br><span class="line">├── String</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure><p>还有一种类，它被定义在另一个类的内部，所以称为内部类（Nested Class）。Java的内部类分为好几种，通常情况用得不多，但也需要了解它们是如何使用的。</p><h3 id="Inner-Class">Inner Class</h3><p>如果一个类定义在另一个类的内部，这个类就是Inner Class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="comment">// 定义了一个Inner Class</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述定义的<code>Outer</code>是一个普通类，而<code>Inner</code>是一个Inner Class，它与普通类有个最大的不同，就是Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inner class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(<span class="string">&quot;Nested&quot;</span>); <span class="comment">// 实例化一个Outer</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>(); <span class="comment">// 实例化一个Inner</span></span><br><span class="line">        inner.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上述代码，要实例化一个<code>Inner</code>，我们必须首先创建一个<code>Outer</code>的实例，然后，调用<code>Outer</code>实例的<code>new</code>来创建<code>Inner</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br></pre></td></tr></table></figure><p>这是因为Inner Class除了有一个<code>this</code>指向它自己，还隐含地持有一个Outer Class实例，可以用<code>Outer.this</code>访问这个实例。所以，实例化一个Inner Class不能脱离Outer实例。</p><p>Inner Class和普通Class相比，除了能引用Outer实例外，还有一个额外的“特权”，就是可以修改Outer Class的<code>private</code>字段，因为Inner Class的作用域在Outer Class内部，所以能访问Outer Class的<code>private</code>字段和方法。</p><p>观察Java编译器编译后的<code>.class</code>文件可以发现，<code>Outer</code>类被编译为<code>Outer.class</code>，而<code>Inner</code>类被编译为<code>Outer$Inner.class</code>。</p><h3 id="Anonymous-Class">Anonymous Class</h3><p>还有一种定义Inner Class的方法，它不需要在Outer Class中明确地定义这个Class，而是在方法内部，通过匿名类（Anonymous Class）来定义。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Anonymous Class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(<span class="string">&quot;Nested&quot;</span>);</span><br><span class="line">        outer.asyncHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">asyncHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="built_in">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察<code>asyncHello()</code>方法，我们在方法内部实例化了一个<code>Runnable</code>。<code>Runnable</code>本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了<code>Runnable</code>接口的匿名类，并且通过<code>new</code>实例化该匿名类，然后转型为<code>Runnable</code>。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="comment">// 实现必要的抽象方法...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>匿名类和Inner Class一样，可以访问Outer Class的<code>private</code>字段和方法。之所以我们要定义匿名类，是因为在这里我们通常不关心类名，比直接定义Inner Class可以少写很多代码。</p><p>观察Java编译器编译后的<code>.class</code>文件可以发现，<code>Outer</code>类被编译为<code>Outer.class</code>，而匿名类被编译为<code>Outer$1.class</code>。如果有多个匿名类，Java编译器会将每个匿名类依次命名为<code>Outer$1</code>、<code>Outer$2</code>、<code>Outer$3</code>……</p><p>除了接口外，匿名类也完全可以继承自普通类。观察以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Anonymous Class</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, String&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#125;; <span class="comment">// 匿名类!</span></span><br><span class="line">        HashMap&lt;String, String&gt; map3 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">                put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(map3.get(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map1</code>是一个普通的<code>HashMap</code>实例，但<code>map2</code>是一个匿名类实例，只是该匿名类继承自<code>HashMap</code>。<code>map3</code>也是一个继承自<code>HashMap</code>的匿名类实例，并且添加了<code>static</code>代码块来初始化数据。观察编译输出可发现<code>Main$1.class</code>和<code>Main$2.class</code>两个匿名类文件。</p><h3 id="Static-Nested-Class">Static Nested Class</h3><p>最后一种内部类和Inner Class类似，但是使用<code>static</code>修饰，称为静态内部类（Static Nested Class）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Static Nested Class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.<span class="type">StaticNested</span> <span class="variable">sn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticNested();</span><br><span class="line">        sn.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;OUTER&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticNested</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.NAME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>static</code>修饰的内部类和Inner Class有很大的不同，它不再依附于<code>Outer</code>的实例，而是一个完全独立的类，因此无法引用<code>Outer.this</code>，但它可以访问<code>Outer</code>的<code>private</code>静态字段和静态方法。如果把<code>StaticNested</code>移到<code>Outer</code>之外，就失去了访问<code>private</code>的权限。</p><h3 id="小结-11">小结</h3><p>Java的内部类可分为Inner Class、Anonymous Class和Static Nested Class三种；</p><p>Inner Class和Anonymous Class本质上是相同的，都必须依附于Outer Class的实例，即隐含地持有<code>Outer.this</code>实例，并拥有Outer Class的<code>private</code>访问权限；</p><p>Static Nested Class是独立类，但拥有Outer Class的<code>private</code>访问权限。</p><p>在Java中，我们经常听到<code>classpath</code>这个东西。网上有很多关于“如何设置classpath”的文章，但大部分设置都不靠谱。</p><p>到底什么是<code>classpath</code>？</p><p><code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索<code>class</code>。</p><p>因为Java是编译型语言，源码文件是<code>.java</code>，而编译后的<code>.class</code>文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个<code>abc.xyz.Hello</code>的类，应该去哪搜索对应的<code>Hello.class</code>文件。</p><p>所以，<code>classpath</code>就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用<code>;</code>分隔，带空格的目录用<code>&quot;&quot;</code>括起来，可能长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\work\project1\bin;C:\shared;&quot;D:\My Documents\project1\bin&quot;</span><br></pre></td></tr></table></figure><p>在Linux系统上，用<code>:</code>分隔，可能长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin</span><br></pre></td></tr></table></figure><p>现在我们假设<code>classpath</code>是<code>.;C:\work\project1\bin;C:\shared</code>，当JVM在加载<code>abc.xyz.Hello</code>这个类时，会依次查找：</p><ul><li>&lt;当前目录&gt;\abc\xyz\Hello.class</li><li>C:\work\project1\bin\abc\xyz\Hello.class</li><li>C:\shared\abc\xyz\Hello.class</li></ul><p>注意到<code>.</code>代表当前目录。如果JVM在某个路径下找到了对应的<code>class</code>文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。</p><p><code>classpath</code>的设定方法有两种：</p><p>在系统环境变量中设置<code>classpath</code>环境变量，不推荐；</p><p>在启动JVM时设置<code>classpath</code>变量，推荐。</p><p>我们强烈<em>不推荐</em>在系统环境变量中设置<code>classpath</code>，那样会污染整个系统环境。在启动JVM时设置<code>classpath</code>才是推荐的做法。实际上就是给<code>java</code>命令传入<code>-classpath</code>参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello</span><br></pre></td></tr></table></figure><p>或者使用<code>-cp</code>的简写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello</span><br></pre></td></tr></table></figure><p>没有设置系统环境变量，也没有传入<code>-cp</code>参数，那么JVM默认的<code>classpath</code>为<code>.</code>，即当前目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java abc.xyz.Hello</span><br></pre></td></tr></table></figure><p>上述命令告诉JVM只在当前目录搜索<code>Hello.class</code>。</p><p>在IDE中运行Java程序，IDE自动传入的<code>-cp</code>参数是当前工程的<code>bin</code>目录和引入的jar包。</p><p>通常，我们在自己编写的<code>class</code>中，会引用Java核心库的<code>class</code>，例如，<code>String</code>、<code>ArrayList</code>等。这些<code>class</code>应该上哪去找？</p><p>有很多“如何设置classpath”的文章会告诉你把JVM自带的<code>rt.jar</code>放入<code>classpath</code>，但事实上，根本不需要告诉JVM如何去Java核心库查找<code>class</code>，JVM怎么可能笨到连自己的核心库在哪都不知道！</p><p>注意</p><p>不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库！</p><p>更好的做法是，不要设置<code>classpath</code>！默认的当前目录<code>.</code>对于绝大多数情况都够用了。</p><p>假设我们有一个编译后的<code>Hello.class</code>，它的包名是<code>com.example</code>，当前目录是<code>C:\work</code>，那么，目录结构必须如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\work</span><br><span class="line">└─ com</span><br><span class="line">   └─ example</span><br><span class="line">      └─ Hello.class</span><br></pre></td></tr></table></figure><p>运行这个<code>Hello.class</code>必须在当前目录下使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\work&gt; java -cp . com.example.Hello</span><br></pre></td></tr></table></figure><p>JVM根据classpath设置的<code>.</code>在当前目录下查找<code>com.example.Hello</code>，即实际搜索文件必须位于<code>com/example/Hello.class</code>。如果指定的<code>.class</code>文件不存在，或者目录结构和包名对不上，均会报错。</p><h3 id="jar包">jar包</h3><p>如果有很多<code>.class</code>文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。</p><p>jar包就是用来干这个事的，它可以把<code>package</code>组织的目录层级，以及各个目录下的所有文件（包括<code>.class</code>文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。</p><p>jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的<code>class</code>，就可以把jar包放到<code>classpath</code>中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ./hello.jar abc.xyz.Hello</span><br></pre></td></tr></table></figure><p>这样JVM会自动在<code>hello.jar</code>文件里去搜索某个类。</p><p>那么问题来了：如何创建jar包？</p><p>因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从<code>.zip</code>改为<code>.jar</code>，一个jar包就创建成功。</p><p>假设编译输出的目录结构是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ bin</span><br><span class="line">   ├─ hong</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   │  ming</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   └─ mr</span><br><span class="line">      └─ jun</span><br><span class="line">         └─ Arrays.class</span><br></pre></td></tr></table></figure><p>这里需要特别注意的是，jar包里的第一层目录，不能是<code>bin</code>，而应该是<code>hong</code>、<code>ming</code>、<code>mr</code>。如果在Windows的资源管理器中看，应该长这样：</p><p><img src="https://liaoxuefeng.com/books/java/oop/basic/classpath-jar/good-jar.jpg" alt="hello.zip.ok"></p><p>如果长这样：</p><p><img src="https://liaoxuefeng.com/books/java/oop/basic/classpath-jar/bad-jar.jpg" alt="hello.zip.invalid"></p><p>上面的<code>hello.zip</code>包含有<code>bin</code>目录，说明打包打得有问题，JVM仍然无法从jar包中查找正确的<code>class</code>，原因是<code>hong.Person</code>必须按<code>hong/Person.class</code>存放，而不是<code>bin/hong/Person.class</code>。</p><p>jar包还可以包含一个特殊的<code>/META-INF/MANIFEST.MF</code>文件，<code>MANIFEST.MF</code>是纯文本，可以指定<code>Main-Class</code>和其它信息。JVM会自动读取这个<code>MANIFEST.MF</code>文件，如果存在<code>Main-Class</code>，我们就不必在命令行指定启动的类名，而是用更方便的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar hello.jar</span><br></pre></td></tr></table></figure><p>在大型项目中，不可能手动编写<code>MANIFEST.MF</code>文件，再手动创建jar包。Java社区提供了大量的开源构建工具，例如<a href="https://liaoxuefeng.com/books/java/maven/index.html">Maven</a>，可以非常方便地创建jar包。</p><h3 id="小结-12">小结</h3><p>JVM通过环境变量<code>classpath</code>决定搜索<code>class</code>的路径和顺序；</p><p>强烈建议<strong>不要设置</strong>系统环境变量<code>classpath</code>，建议始终通过<code>-cp</code>命令传入；</p><p>jar包本质上是zip格式，相当于目录，可以包含很多<code>.class</code>文件，方便下载和使用；</p><p><code>MANIFEST.MF</code>文件可以提供jar包的信息，如<code>Main-Class</code>，这样可以直接运行jar包。</p><p>在Java开发中，许多童鞋经常被各种版本的JDK搞得晕头转向，本节我们就来详细讲解Java程序编译后的class文件版本问题。</p><p>我们通常说的Java 8，Java 11，Java 17，是指JDK的版本，也就是JVM的版本，更确切地说，就是<code>java.exe</code>这个程序的版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version &quot;17&quot; 2021-09-14 LTS</span><br></pre></td></tr></table></figure><p>而每个版本的JVM，它能执行的class文件版本也不同。例如，Java 11对应的class文件版本是55，而Java 17对应的class文件版本是61。</p><p>如果用Java 11编译一个Java程序，输出的class文件版本默认就是55，这个class既可以在Java 11上运行，也可以在Java 17上运行，因为Java 17支持的class文件版本是61，表示“最多支持到版本61”。</p><p>如果用Java 17编译一个Java程序，输出的class文件版本默认就是61，它可以在Java 17、Java 18上运行，但不可能在Java 11上运行，因为Java 11支持的class版本最多到55。如果使用低于Java 17的JVM运行，会得到一个<code>UnsupportedClassVersionError</code>，错误信息类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.UnsupportedClassVersionError: Xxx has been compiled by a more recent version of the Java Runtime...</span><br></pre></td></tr></table></figure><p>只要看到<code>UnsupportedClassVersionError</code>就表示当前要加载的class文件版本超过了JVM的能力，必须使用更高版本的JVM才能运行。</p><p>打个比方，用Word 2013保存一个Word文件，这个文件也可以在Word 2016上打开。但反过来，用Word 2016保存一个Word文件，就无法使用Word 2013打开。</p><p>但是，且慢，用Word 2016也可以保存一个格式为Word 2013的文件，这样保存的Word文件就可以用低版本的Word 2013打开，但前提是保存时必须明确指定文件格式兼容Word 2013。</p><p>类似的，对应到JVM的class文件，我们也可以用Java 17编译一个Java程序，指定输出的class版本要兼容Java 11（即class版本55），这样编译生成的class文件就可以在Java &gt;=11的环境中运行。</p><p>指定编译输出有两种方式，一种是在<code>javac</code>命令行中用参数<code>--release</code>设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javac --release 11 Main.java</span><br></pre></td></tr></table></figure><p>参数<code>--release 11</code>表示源码兼容Java 11，编译的class输出版本为Java 11兼容，即class版本55。</p><p>第二种方式是用参数<code>--source</code>指定源码版本，用参数<code>--target</code>指定输出class版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javac --source 9 --target 11 Main.java</span><br></pre></td></tr></table></figure><p>上述命令如果使用Java 17的JDK编译，它会把源码视为Java 9兼容版本，并输出class为Java 11兼容版本。注意<code>--release</code>参数和<code>--source --target</code>参数只能二选一，不能同时设置。</p><p>然而，指定版本如果低于当前的JDK版本，会有一些潜在的问题。例如，我们用Java 17编译<code>Hello.java</code>，参数设置<code>--source 9</code>和<code>--target 11</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>.indent(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用低于Java 11的JVM运行<code>Hello</code>会得到一个<code>LinkageError</code>，因为无法加载<code>Hello.class</code>文件，而用Java 11运行<code>Hello</code>会得到一个<code>NoSuchMethodError</code>，因为<code>String.indent()</code>方法是从Java 12才添加进来的，Java 11的<code>String</code>版本根本没有<code>indent()</code>方法。</p><p>注意</p><p>如果使用–release 11则会在编译时检查该方法是否在Java 11中存在。</p><p>因此，如果运行时的JVM版本是Java 11，则编译时也最好使用Java 11，而不是用高版本的JDK编译输出低版本的class。</p><p>如果使用<code>javac</code>编译时不指定任何版本参数，那么相当于使用<code>--release 当前版本</code>编译，即源码版本和输出版本均为当前版本。</p><p>在开发阶段，多个版本的JDK可以同时安装，当前使用的JDK版本可由<code>JAVA_HOME</code>环境变量切换。</p><h3 id="源码版本">源码版本</h3><p>在编写源代码的时候，我们通常会预设一个源码的版本。在编译的时候，如果用<code>--source</code>或<code>--release</code>指定源码版本，则使用指定的源码版本检查语法。</p><p>例如，使用了lambda表达式的源码版本至少要为8才能编译，使用了<code>var</code>关键字的源码版本至少要为10才能编译，使用<code>switch</code>表达式的源码版本至少要为12才能编译，且12和13版本需要启用<code>--enable-preview</code>参数。</p><h3 id="小结-13">小结</h3><p>高版本的JDK可编译输出低版本兼容的class文件，但需注意，低版本的JDK可能不存在高版本JDK添加的类和方法，导致运行时报错。</p><p>运行时使用哪个JDK版本，编译时就尽量使用同一版本的JDK编译源码。</p><p>从Java 9开始，JDK又引入了模块（Module）。</p><p>什么是模块？这要从Java 9之前的版本说起。</p><p>我们知道，<code>.class</code>文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆<code>.class</code>文件，很不便于管理，所以，<code>jar</code>文件就是<code>class</code>文件的容器。</p><p>在Java 9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫<code>rt.jar</code>，一共有60多M。</p><p>如果是自己开发的程序，除了一个自己的<code>app.jar</code>以外，还需要一堆第三方的jar包，运行一个Java程序，一般来说，命令行写这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main</span><br></pre></td></tr></table></figure><p>注意</p><p>JVM自带的标准库rt.jar不要写到classpath中，写了反而会干扰JVM的正常运行。</p><p>如果漏写了某个运行时需要用到的jar，那么在运行期极有可能抛出<code>ClassNotFoundException</code>。</p><p>所以，jar只是用于存放class的容器，它并不关心class之间的依赖。</p><p>从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果<code>a.jar</code>必须依赖另一个<code>b.jar</code>才能运行，那我们应该给<code>a.jar</code>加点说明啥的，让程序在编译和运行的时候能自动定位到<code>b.jar</code>，这种自带“依赖关系”的class容器就是模块。</p><p>为了表明Java模块化的决心，从Java 9开始，原有的Java标准库已经由一个单一巨大的<code>rt.jar</code>分拆成了几十个模块，这些模块以<code>.jmod</code>扩展名标识，可以在<code>$JAVA_HOME/jmods</code>目录下找到它们：</p><ul><li>java.base.jmod</li><li>java.compiler.jmod</li><li>java.datatransfer.jmod</li><li>java.desktop.jmod</li><li>…</li></ul><p>这些<code>.jmod</code>文件每一个都是一个模块，模块名就是文件名。例如：模块<code>java.base</code>对应的文件就是<code>java.base.jmod</code>。模块之间的依赖关系已经被写入到模块内的<code>module-info.class</code>文件了。所有的模块都直接或间接地依赖<code>java.base</code>模块，只有<code>java.base</code>模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从<code>Object</code>直接或间接继承而来。</p><p>把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。</p><h3 id="编写模块">编写模块</h3><p>那么，我们应该如何编写模块呢？还是以具体的例子来说。首先，创建模块和原有的创建Java项目是完全一样的，以<code>oop-module</code>工程为例，它的目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">oop-module</span><br><span class="line">├── bin</span><br><span class="line">├── build.sh</span><br><span class="line">└── src</span><br><span class="line">    ├── com</span><br><span class="line">    │   └── itranswarp</span><br><span class="line">    │       └── sample</span><br><span class="line">    │           ├── Greeting.java</span><br><span class="line">    │           └── Main.java</span><br><span class="line">    └── module-info.java</span><br></pre></td></tr></table></figure><p>其中，<code>bin</code>目录存放编译后的class文件，<code>src</code>目录存放源码，按包名的目录结构存放，仅仅在<code>src</code>目录下多了一个<code>module-info.java</code>这个文件，这就是模块的描述文件。在这个模块中，它长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> hello.world &#123;</span><br><span class="line"><span class="keyword">requires</span> java.base; <span class="comment">// 可不写，任何模块都会自动引入java.base</span></span><br><span class="line"><span class="keyword">requires</span> java.xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>module</code>是关键字，后面的<code>hello.world</code>是模块的名称，它的命名规范与包一致。花括号的<code>requires xxx;</code>表示这个模块需要引用的其他模块名。除了<code>java.base</code>可以被自动引入外，这里我们引入了一个<code>java.xml</code>的模块。</p><p>当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，<code>Main.java</code>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.sample;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须引入java.xml模块后才能使用其中的类:</span></span><br><span class="line"><span class="keyword">import</span> javax.xml.XMLConstants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Greeting</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Greeting</span>();</span><br><span class="line">System.out.println(g.hello(XMLConstants.XML_NS_PREFIX));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把<code>requires java.xml;</code>从<code>module-info.java</code>中去掉，编译将报错。可见，模块的重要作用就是声明依赖关系。</p><p>下面，我们用JDK提供的命令行工具来编译并创建模块。</p><p>首先，我们把工作目录切换到<code>oop-module</code>，在当前目录下编译所有的<code>.java</code>文件，并存放到<code>bin</code>目录下，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java</span><br></pre></td></tr></table></figure><p>如果编译成功，现在项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">oop-module</span><br><span class="line">├── bin</span><br><span class="line">│   ├── com</span><br><span class="line">│   │   └── itranswarp</span><br><span class="line">│   │       └── sample</span><br><span class="line">│   │           ├── Greeting.class</span><br><span class="line">│   │           └── Main.class</span><br><span class="line">│   └── module-info.class</span><br><span class="line">└── src</span><br><span class="line">    ├── com</span><br><span class="line">    │   └── itranswarp</span><br><span class="line">    │       └── sample</span><br><span class="line">    │           ├── Greeting.java</span><br><span class="line">    │           └── Main.java</span><br><span class="line">    └── module-info.java</span><br></pre></td></tr></table></figure><p>注意到<code>src</code>目录下的<code>module-info.java</code>被编译到<code>bin</code>目录下的<code>module-info.class</code>。</p><p>下一步，我们需要把bin目录下的所有class文件先打包成jar，在打包的时候，注意传入<code>--main-class</code>参数，让这个jar包能自己定位<code>main</code>方法所在的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .</span><br></pre></td></tr></table></figure><p>现在我们就在当前目录下得到了<code>hello.jar</code>这个jar包，它和普通jar包并无区别，可以直接使用命令<code>java -jar hello.jar</code>来运行它。但是我们的目标是创建模块，所以，继续使用JDK自带的<code>jmod</code>命令把一个jar包转换成模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jmod create --class-path hello.jar hello.jmod</span><br></pre></td></tr></table></figure><p>于是，在当前目录下我们又得到了<code>hello.jmod</code>这个模块文件，这就是最后打包出来的传说中的模块！</p><h3 id="运行模块">运行模块</h3><p>要运行一个jar，我们使用<code>java -jar xxx.jar</code>命令。要运行一个模块，我们只需要指定模块名。试试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java --module-path hello.jmod --module hello.world</span><br></pre></td></tr></table></figure><p>结果是一个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error occurred during initialization of boot layer</span><br><span class="line">java.lang.module.FindException: JMOD format not supported at execution time: hello.jmod</span><br></pre></td></tr></table></figure><p>原因是<code>.jmod</code>不能被放入<code>--module-path</code>中。换成<code>.jar</code>就没问题了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java --module-path hello.jar --module hello.world</span><br><span class="line">Hello, xml!</span><br></pre></td></tr></table></figure><p>那我们辛辛苦苦创建的<code>hello.jmod</code>有什么用？答案是我们可以用它来打包JRE。</p><h3 id="打包JRE">打包JRE</h3><p>前面讲了，为了支持模块化，Java 9首先带头把自己的一个巨大无比的<code>rt.jar</code>拆成了几十个<code>.jmod</code>模块，原因就是，运行Java程序的时候，实际上我们用到的JDK模块，并没有那么多。不需要的模块，完全可以删除。</p><p>过去发布一个Java应用程序，要运行它，必须下载一个完整的JRE，再运行jar包。而完整的JRE块头很大，有100多M。怎么给JRE瘦身呢？</p><p>现在，JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪JRE呢？并不是说把系统安装的JRE给删掉部分模块，而是“复制”一份JRE，但只带上用到的模块。为此，JDK提供了<code>jlink</code>命令来干这件事。命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/</span><br></pre></td></tr></table></figure><p>我们在<code>--module-path</code>参数指定了我们自己的模块<code>hello.jmod</code>，然后，在<code>--add-modules</code>参数中指定了我们用到的3个模块<code>java.base</code>、<code>java.xml</code>和<code>hello.world</code>，用<code>,</code>分隔。最后，在<code>--output</code>参数指定输出目录。</p><p>现在，在当前目录下，我们可以找到<code>jre</code>目录，这是一个完整的并且带有我们自己<code>hello.jmod</code>模块的JRE。试试直接运行这个JRE：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jre/bin/java --module hello.world</span><br><span class="line">Hello, xml!</span><br></pre></td></tr></table></figure><p>要分发我们自己的Java应用程序，只需要把这个<code>jre</code>目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。</p><h3 id="访问权限">访问权限</h3><p>前面我们讲过，Java的class访问权限分为public、protected、private和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整。</p><p>确切地说，class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包。</p><p>举个例子：我们编写的模块<code>hello.world</code>用到了模块<code>java.xml</code>的一个类<code>javax.xml.XMLConstants</code>，我们之所以能直接使用这个类，是因为模块<code>java.xml</code>的<code>module-info.java</code>中声明了若干导出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> java.xml &#123;</span><br><span class="line">    <span class="keyword">exports</span> java.xml;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.catalog;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.datatype;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的<code>hello.world</code>模块中的<code>com.itranswarp.sample.Greeting</code>类，我们必须将其导出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> hello.world &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.itranswarp.sample;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">requires</span> java.base;</span><br><span class="line"><span class="keyword">requires</span> java.xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，模块进一步隔离了代码的访问权限。</p><h3 id="练习-10">练习</h3><p>请下载并练习如何打包模块和JRE。</p><p><a href="https://liaoxuefeng.com/books/java/oop/basic/module/oop-module.zip">下载练习</a></p><h3 id="小结-14">小结</h3><p>Java 9引入的模块目的是为了管理依赖；</p><p>使用模块可以按需打包JRE；</p><p>使用模块对类的访问权限有了进一步限制。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA快速入门教程</title>
      <link href="/2025/05/23/java/JAVA%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2025/05/23/java/JAVA%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Java最早是由SUN公司（已被Oracle收购）的<a href="https://en.wikipedia.org/wiki/James_Gosling">詹姆斯·高斯林</a>（高司令，人称Java之父）在上个世纪90年代初开发的一种编程语言，最初被命名为Oak，目标是针对小型家电设备的嵌入式应用，结果市场没啥反响。谁料到互联网的崛起，让Oak重新焕发了生机，于是SUN公司改造了Oak，在1995年以Java的名称正式发布，原因是Oak已经被人注册了，因此SUN注册了Java这个商标。随着互联网的高速发展，Java逐渐成为最重要的网络编程语言。</p><p>Java介于编译型语言和解释型语言之间。编译型语言如C、C++，代码是直接编译成机器码执行，但是不同的平台（x86、ARM等）CPU的指令集不同，因此，需要编译出每一种平台的对应机器码。解释型语言如Python、Ruby没有这个问题，可以由解释器直接加载源码然后运行，代价是运行效率太低。而Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。当然，这是针对Java开发者而言。对于虚拟机，需要为每个平台分别开发。为了保证不同平台、不同公司开发的虚拟机都能正确执行Java字节码，SUN公司制定了一系列的Java虚拟机规范。从实践的角度看，JVM的兼容性做得非常好，低版本的Java字节码完全可以正常运行在高版本的JVM上。</p><p>随着Java的发展，SUN给Java又分出了三个不同版本：</p><ul><li>Java SE：Standard Edition</li><li>Java EE：Enterprise Edition</li><li>Java ME：Micro Edition</li></ul><p>这三者之间有啥关系呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│Java EE                    │</span><br><span class="line">│    ┌────────────────────┐ │</span><br><span class="line">│    │Java SE             │ │</span><br><span class="line">│    │    ┌─────────────┐ │ │</span><br><span class="line">│    │    │   Java ME   │ │ │</span><br><span class="line">│    │    └─────────────┘ │ │</span><br><span class="line">│    └────────────────────┘ │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure><p>简单来说，Java SE就是标准版，包含标准的JVM和标准库，而Java EE是企业版，它只是在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等，Java EE的应用使用的虚拟机和Java SE完全相同。</p><p>Java ME就和Java SE不同，它是一个针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用，Java ME的虚拟机也是“瘦身版”。</p><p>毫无疑问，Java SE是整个Java平台的核心，而Java EE是进一步学习Web应用所必须的。我们熟悉的Spring等框架都是Java EE开源生态系统的一部分。不幸的是，Java ME从来没有真正流行起来，反而是Android开发成为了移动平台的标准之一，因此，没有特殊需求，不建议学习Java ME。</p><p>因此我们推荐的Java学习路线图如下：</p><ol><li>首先要学习Java SE，掌握Java语言本身、Java核心开发技术以及Java标准库的使用；</li><li>如果继续学习Java EE，那么Spring框架、数据库开发、分布式架构就是需要学习的；</li><li>如果要学习大数据开发，那么Hadoop、Spark、Flink这些大数据平台就是需要学习的，他们都基于Java或Scala开发；</li><li>如果想要学习移动开发，那么就深入Android平台，掌握Android App开发。</li></ol><p>无论怎么选择，Java SE的核心技术是基础，这个教程的目的就是让你完全精通Java SE并掌握Java EE！</p><h3 id="Java版本">Java版本</h3><p>从1996年发布1.0版本开始，到目前为止，最新的Java版本是Java 21：</p><table><thead><tr><th>时间</th><th>版本</th></tr></thead><tbody><tr><td>1996</td><td>1.0</td></tr><tr><td>1997</td><td>1.1</td></tr><tr><td>1998</td><td>1.2</td></tr><tr><td>2000</td><td>1.3</td></tr><tr><td>2002</td><td>1.4</td></tr><tr><td>2004</td><td>1.5 / 5.0</td></tr><tr><td>2005</td><td>1.6 / 6.0</td></tr><tr><td>2011</td><td>1.7 / 7.0</td></tr><tr><td>2014</td><td>1.8 / 8.0</td></tr><tr><td>2017/9</td><td>1.9 / 9.0</td></tr><tr><td>2018/3</td><td>10</td></tr><tr><td>2018/9</td><td>11</td></tr><tr><td>2019/3</td><td>12</td></tr><tr><td>2019/9</td><td>13</td></tr><tr><td>2020/3</td><td>14</td></tr><tr><td>2020/9</td><td>15</td></tr><tr><td>2021/3</td><td>16</td></tr><tr><td>2021/9</td><td>17</td></tr><tr><td>2022/3</td><td>18</td></tr><tr><td>2022/9</td><td>19</td></tr><tr><td>2023/3</td><td>20</td></tr><tr><td>2023/9</td><td>21</td></tr><tr><td>2024/3</td><td>22</td></tr><tr><td>2024/9</td><td>23</td></tr></tbody></table><p>本教程使用的Java版本是最新版的<strong>Java 23</strong>。</p><h3 id="名词解释">名词解释</h3><p>初学者学Java，经常听到JDK、JRE这些名词，它们到底是啥？</p><ul><li>JDK：Java Development Kit</li><li>JRE：Java Runtime Environment</li></ul><p>简单地说，JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。</p><p>二者关系如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> ┌─    ┌──────────────────────────────────┐</span><br><span class="line"> │     │     Compiler, debugger, etc.     │</span><br><span class="line"> │     └──────────────────────────────────┘</span><br><span class="line">JDK ┌─ ┌──────────────────────────────────┐</span><br><span class="line"> │  │  │                                  │</span><br><span class="line"> │ JRE │      JVM + Runtime Library       │</span><br><span class="line"> │  │  │                                  │</span><br><span class="line"> └─ └─ └──────────────────────────────────┘</span><br><span class="line">       ┌───────┐┌───────┐┌───────┐┌───────┐</span><br><span class="line">       │Windows││ Linux ││ macOS ││others │</span><br><span class="line">       └───────┘└───────┘└───────┘└───────┘</span><br></pre></td></tr></table></figure><p>要学习Java开发，当然需要安装JDK了。</p><p>那JSR、JCP……又是啥？</p><ul><li>JSR规范：Java Specification Request</li><li>JCP组织：Java Community Process</li></ul><p>为了保证Java语言的规范性，SUN公司搞了一个JSR规范，凡是想给Java平台加一个功能，比如说访问数据库的功能，大家要先创建一个JSR规范，定义好接口，这样，各个数据库厂商都按照规范写出Java驱动程序，开发者就不用担心自己写的数据库代码在MySQL上能跑，却不能跑在PostgreSQL上。</p><p>所以JSR是一系列的规范，从JVM的内存模型到Web程序接口，全部都标准化了。而负责审核JSR的组织就是JCP。</p><p>一个JSR规范发布时，为了让大家有个参考，还要同时发布一个“参考实现”，以及一个“兼容性测试套件”：</p><ul><li>RI：Reference Implementation</li><li>TCK：Technology Compatibility Kit</li></ul><p>比如有人提议要搞一个基于Java开发的消息服务器，这个提议很好啊，但是光有提议还不行，得贴出真正能跑的代码，这就是RI。如果有其他人也想开发这样一个消息服务器，如何保证这些消息服务器对开发者来说接口、功能都是相同的？所以还得提供TCK。</p><p>通常来说，RI只是一个“能跑”的正确的代码，它不追求速度，所以，如果真正要选择一个Java的消息服务器，一般是没人用RI的，大家都会选择一个有竞争力的商用或开源产品。</p><p>参考：Java消息服务JMS的JSR：<a href="https://jcp.org/en/jsr/detail?id=914">https://jcp.org/en/jsr/detail?id=914</a></p><p>要开始学习Java编程，我们需要首先搭建开发环境。</p><p>本节我们介绍如何安装JDK，在命令行编译Java程序，以及如何使用IDE来开发Java。</p><h2 id="安装JDK">安装JDK</h2><p>因为Java程序必须运行在JVM之上，所以，我们第一件事情就是安装JDK。</p><p>搜索JDK 23，确保从<a href="https://www.oracle.com/java/technologies/downloads/">Oracle的官网</a>下载最新的稳定版JDK：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Java SE Development Kit 23 downloads</span><br><span class="line"></span><br><span class="line">Linux  macOS  Windows</span><br><span class="line">              -------</span><br><span class="line"></span><br><span class="line">x64 Compressed Archive      Download</span><br><span class="line">x64 Installer               Download</span><br><span class="line">x64 MSI Installer           Download</span><br></pre></td></tr></table></figure><p>选择合适的操作系统与安装包，找到Java SE 23的下载链接<code>Download</code>，下载安装即可。Windows优先选<code>x64 MSI Installer</code>，Linux和macOS要根据自己电脑的CPU是ARM还是x86来选择合适的安装包。</p><h3 id="设置环境变量">设置环境变量</h3><p>安装完JDK后，需要设置一个<code>JAVA_HOME</code>的环境变量，它指向JDK的安装目录。在Windows下，它是安装目录，类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk-23</span><br></pre></td></tr></table></figure><p>在macOS下，它在<code>~/.bash_profile</code>或<code>~/.zprofile</code>里，它是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=`/usr/libexec/java_home -v 23`</span><br></pre></td></tr></table></figure><p>然后，把<code>JAVA_HOME</code>的<code>bin</code>目录附加到系统环境变量<code>PATH</code>上。在Windows下，它长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Path=%JAVA_HOME%\bin;&lt;现有的其他路径&gt;</span><br></pre></td></tr></table></figure><p>在macOS下，它在<code>~/.bash_profile</code>或<code>~/.zprofile</code>里，长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>把<code>JAVA_HOME</code>的<code>bin</code>目录添加到<code>PATH</code>中是为了在任意文件夹下都可以运行<code>java</code>。打开PowerShell窗口，输入命令<code>java -version</code>，如果一切正常，你会看到如下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────┐</span><br><span class="line">│Windows PowerShell                                 - □ x │</span><br><span class="line">├─────────────────────────────────────────────────────────┤</span><br><span class="line">│Windows PowerShell                                       │</span><br><span class="line">│Copyright (C) Microsoft Corporation. All rights reserved.│</span><br><span class="line">│                                                         │</span><br><span class="line">│PS C:\Users\liaoxuefeng&gt; java -version                   │</span><br><span class="line">│java version &quot;23&quot; ...                                    │</span><br><span class="line">│Java(TM) SE Runtime Environment                          │</span><br><span class="line">│Java HotSpot(TM) 64-Bit Server VM                        │</span><br><span class="line">│                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>如果你看到的版本号不是<code>23</code>，而是<code>15</code>、<code>1.8</code>之类，说明系统存在多个JDK，且默认JDK不是JDK 23，需要把JDK 23提到<code>PATH</code>前面。</p><p>如果你得到一个错误输出：“无法将“java”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────┐</span><br><span class="line">│Windows PowerShell                                 - □ x │</span><br><span class="line">├─────────────────────────────────────────────────────────┤</span><br><span class="line">│Windows PowerShell                                       │</span><br><span class="line">│Copyright (C) Microsoft Corporation. All rights reserved.│</span><br><span class="line">│                                                         │</span><br><span class="line">│PS C:\Users\liaoxuefeng&gt; java -version                   │</span><br><span class="line">│java : The term &#x27;java&#x27; is not recognized as ...          │</span><br><span class="line">│...                                                      │</span><br><span class="line">│    + FullyQualifiedErrorId : CommandNotFoundException   │</span><br><span class="line">│                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>这是因为系统无法找到Java虚拟机的程序<code>java.exe</code>，需要检查<code>JAVA_HOME</code>和<code>PATH</code>的配置。</p><p>可以参考<a href="https://www.java.com/zh-CN/download/help/path.html">如何设置或更改PATH系统变量</a>。</p><h3 id="JDK">JDK</h3><p>细心的童鞋还可以在<code>JAVA_HOME</code>的<code>bin</code>目录下找到很多可执行文件：</p><ul><li>java：这个可执行程序其实就是JVM，运行Java程序，就是启动JVM，然后让JVM执行指定的编译后的代码；</li><li>javac：这是Java的编译器，它用于把Java源码文件（以<code>.java</code>后缀结尾）编译为Java字节码文件（以<code>.class</code>后缀结尾）；</li><li>jar：用于把一组<code>.class</code>文件打包成一个<code>.jar</code>文件，便于发布；</li><li>javadoc：用于从Java源码中自动提取注释并生成文档；</li><li>jdb：Java调试器，用于开发阶段的运行调试。</li></ul><hr><hr><p>我们来编写第一个Java程序。</p><p>打开文本编辑器，输入以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个Java程序中，你总能找到一个类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>的定义，这个定义被称为class（类），这里的类名是<code>Hello</code>，大小写敏感，<code>class</code>用来定义一个类，<code>public</code>表示这个类是公开的，<code>public</code>、<code>class</code>都是Java的关键字，必须小写，<code>Hello</code>是类的名字，按照习惯，首字母<code>H</code>要大写。而花括号<code>&#123;&#125;</code>中间则是类的定义。</p><p>注意到类的定义中，我们定义了一个名为<code>main</code>的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法是可执行的代码块，一个方法除了方法名<code>main</code>，还有用<code>()</code>括起来的方法参数，这里的<code>main</code>方法有一个参数，参数类型是<code>String[]</code>，参数名是<code>args</code>，<code>public</code>、<code>static</code>用来修饰方法，这里表示它是一个公开的静态方法，<code>void</code>是方法的返回类型，而花括号<code>&#123;&#125;</code>中间的就是方法的代码。</p><p>方法的代码每一行用<code>;</code>结束，这里只有一行代码，就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br></pre></td></tr></table></figure><p>它用来打印一个字符串到屏幕上。</p><p>Java规定，某个类定义的<code>public static void main(String[] args)</code>是Java程序的固定入口方法，因此，Java程序总是从<code>main</code>方法开始执行。</p><p>注意到Java源码的缩进不是必须的，但是用缩进后，格式好看，很容易看出代码块的开始和结束，缩进一般是4个空格或者一个tab。</p><p>最后，当我们把代码保存为文件时，文件名必须是<code>Hello.java</code>，而且文件名也要注意大小写，因为要和我们定义的类名<code>Hello</code>完全保持一致。</p><h3 id="如何运行Java程序">如何运行Java程序</h3><p>Java源码本质上是一个文本文件，我们需要先用<code>javac</code>把<code>Hello.java</code>编译成字节码文件<code>Hello.class</code>，然后，用<code>java</code>命令执行这个字节码文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────────┐</span><br><span class="line">│    Hello.java    │◀── source code</span><br><span class="line">└──────────────────┘</span><br><span class="line">          │ compile</span><br><span class="line">          ▼</span><br><span class="line">┌──────────────────┐</span><br><span class="line">│   Hello.class    │◀── byte code</span><br><span class="line">└──────────────────┘</span><br><span class="line">          │ execute</span><br><span class="line">          ▼</span><br><span class="line">┌──────────────────┐</span><br><span class="line">│    Run on JVM    │</span><br><span class="line">└──────────────────┘</span><br></pre></td></tr></table></figure><p>因此，可执行文件<code>javac</code>是编译器，而可执行文件<code>java</code>就是虚拟机。</p><p>第一步，在保存<code>Hello.java</code>的目录下执行命令<code>javac Hello.java</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javac Hello.java</span><br></pre></td></tr></table></figure><p>如果源代码无误，上述命令不会有任何输出，而当前目录下会产生一个<code>Hello.class</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">Hello.classHello.java</span><br></pre></td></tr></table></figure><p>第二步，执行<code>Hello.class</code>，使用命令<code>java Hello</code>（注意不是<code>java Hello.class</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java Hello</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><p>注意：给虚拟机传递的参数<code>Hello</code>是我们定义的类名，虚拟机自动查找对应的class文件并执行。</p><p>如果执行<code>java Hello</code>报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ java Hello</span><br><span class="line">Error: Could not find or load main class Hello</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: Hello</span><br></pre></td></tr></table></figure><p>出现<code>ClassNotFoundException</code>信息，说明在当前目录下并没有<code>Hello.class</code>这个文件，请切换到<code>Hello.class</code>的目录，然后执行<code>java Hello</code>。</p><p>有一些童鞋可能知道，直接运行<code>java Hello.java</code>也是可以的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java Hello.java </span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><p>这是从Java 11开始新增的一个功能，它可以直接运行一个单文件源码！</p><p>需要注意的是，在实际项目中，单个不依赖第三方库的Java源码是非常罕见的，所以，绝大多数情况下，我们无法直接运行一个Java源码文件，原因是它需要依赖其他的库。</p><h3 id="小结">小结</h3><p>一个Java源码只能定义一个<code>public</code>类型的class，并且class名称和文件名要完全一致；</p><p>使用<code>javac</code>可以将<code>.java</code>源码编译成<code>.class</code>字节码；</p><p>使用<code>java</code>可以运行一个已编译的Java程序，参数是类名。</p><p>IDE是集成开发环境：Integrated Development Environment的缩写。</p><p>使用IDE的好处在于，可以把编写代码、组织项目、编译、运行、调试等放到一个环境中运行，能极大地提高开发效率。</p><p>IDE提升开发效率主要靠以下几点：</p><ul><li>编辑器的自动提示，可以大大提高敲代码的速度；</li><li>代码修改后可以自动重新编译，并直接运行；</li><li>可以方便地进行断点调试。</li></ul><p>目前，流行的用于Java开发的IDE有：</p><h3 id="Eclipse">Eclipse</h3><p><a href="https://www.eclipse.org/">Eclipse</a>是由IBM开发并捐赠给开源社区的一个IDE，也是目前应用最广泛的IDE。Eclipse的特点是它本身是Java开发的，并且基于插件结构，即使是对Java开发的支持也是通过插件JDT实现的。</p><p>除了用于Java开发，Eclipse配合插件也可以作为C/C++开发环境、PHP开发环境、Rust开发环境等。</p><h3 id="IntelliJ-Idea">IntelliJ Idea</h3><p><a href="https://www.jetbrains.com/idea/">IntelliJ Idea</a>是由JetBrains公司开发的一个功能强大的IDE，分为免费版和商用付费版。JetBrains公司的IDE平台也是基于IDE平台+语言插件的模式，支持Python开发环境、Ruby开发环境、PHP开发环境等，这些开发环境也分为免费版和付费版。</p><h3 id="NetBeans">NetBeans</h3><p><a href="https://netbeans.org/">NetBeans</a>是最早由SUN开发的开源IDE，由于使用人数较少，目前已不再流行。</p><h3 id="使用Eclipse">使用Eclipse</h3><p>你可以使用任何IDE进行Java学习和开发。我们不讨论任何关于IDE的优劣，本教程使用Eclipse作为开发演示环境，原因在于：</p><ul><li>完全免费使用；</li><li>所有功能完全满足Java开发需求。</li></ul><h3 id="安装Eclipse">安装Eclipse</h3><p>Eclipse的发行版提供了预打包的开发环境，包括Java、JavaEE、C++、PHP、Rust等。从<a href="https://www.eclipse.org/downloads/packages/">这里</a>下载：</p><p>我们需要下载的版本是Eclipse IDE for Java Developers：</p><p><img src="https://liaoxuefeng.com/books/java/quick-start/dev-env/ide/eclipse-jdt.jpg" alt="eclipse-jdt"></p><p>根据操作系统是Windows、Mac还是Linux，从右边选择对应的下载链接。</p><p>注意</p><p>教程从头到尾并不需要用到Enterprise Java的功能，所以不需要下载Eclipse IDE for Enterprise Java Developers</p><h3 id="设置Eclipse">设置Eclipse</h3><p>下载并安装完成后，我们启动Eclipse，对IDE环境做一个基本设置：</p><p>选择菜单“Eclipse/Window”-“Preferences”，打开配置对话框：</p><p><img src="https://liaoxuefeng.com/books/java/quick-start/dev-env/ide/eclipse-pref.jpg" alt="eclipse-pref"></p><p>我们需要调整以下设置项：</p><h4 id="General-Editors-Text-Editors">General &gt; Editors &gt; Text Editors</h4><p>钩上“Show line numbers”，这样编辑器会显示行号；</p><h4 id="General-Workspace">General &gt; Workspace</h4><p>钩上“Refresh using native hooks or polling”，这样Eclipse会自动刷新文件夹的改动；</p><p>对于“Text file encoding”，如果Default不是<code>UTF-8</code>，一定要改为“Other：UTF-8”，所有文本文件均使用<code>UTF-8</code>编码；</p><p>对于“New text file line delimiter”，建议使用Unix，即换行符使用<code>\n</code>而不是Windows的<code>\r\n</code>。</p><p><img src="https://liaoxuefeng.com/books/java/quick-start/dev-env/ide/eclipse-encoding.png" alt="workspace-utf-8"></p><h4 id="Java-Compiler">Java &gt; Compiler</h4><p>将“Compiler compliance level”设置为<code>20</code>，本教程的所有代码均使用Java 20的语法，并且编译到Java 20的版本。</p><p>去掉“Use default compliance settings”并钩上“Enable preview features for Java 20”，这样我们就可以使用Java 20的预览功能。</p><p>注意</p><p>如果Compiler compliance level没有22这个选项，请更新到最新版Eclipse。如果更新后还是没有22，打开Help - Eclipse Marketplace，搜索Java 22 Support安装后重启即可。</p><h4 id="Java-Installed-JREs">Java &gt; Installed JREs</h4><p>在Installed JREs中应该看到Java SE 20，如果还有其他的JRE，可以删除，以确保Java SE 20是默认的JRE。</p><h3 id="Eclipse-IDE结构">Eclipse IDE结构</h3><p>打开Eclipse后，整个IDE由若干个区域组成：</p><p><img src="https://liaoxuefeng.com/books/java/quick-start/dev-env/ide/eclipse-workspace.jpg" alt="eclipse-workspace"></p><ul><li>中间可编辑的文本区（见1）是编辑器，用于编辑源码；</li><li>分布在左右和下方的是视图：<ul><li>Package Exploroer（见2）是Java项目的视图</li><li>Console（见3）是命令行输出视图</li><li>Outline（见4）是当前正在编辑的Java源码的结构视图</li></ul></li><li>视图可以任意组合，然后把一组视图定义成一个Perspective（见5），Eclipse预定义了Java、Debug等几个Perspective，用于快速切换。</li></ul><h3 id="新建Java项目">新建Java项目</h3><p>在Eclipse菜单选择“File”-“New”-“Java Project”，填入<code>HelloWorld</code>，JRE选择<code>Java SE 22</code>：</p><p><img src="https://liaoxuefeng.com/books/java/quick-start/dev-env/ide/eclipse-new-java-proj.jpg" alt="new-java-project"></p><p>暂时不要勾选“Create module-info.java file”，因为模块化机制我们后面才会讲到：</p><p><img src="https://liaoxuefeng.com/books/java/quick-start/dev-env/ide/eclipse-new-java-proj-2.png" alt="new-java-project-2"></p><p>点击“Finish”就成功创建了一个名为<code>HelloWorld</code>的Java工程。</p><h3 id="新建Java文件并运行">新建Java文件并运行</h3><p>展开<code>HelloWorld</code>工程，选中源码目录<code>src</code>，点击右键，在弹出菜单中选择“New”-“Class”：</p><p><img src="https://liaoxuefeng.com/books/java/quick-start/dev-env/ide/eclipse-new-class.png" alt="new-java-class"></p><p>在弹出的对话框中，<code>Name</code>一栏填入<code>Hello</code>：</p><p><img src="https://liaoxuefeng.com/books/java/quick-start/dev-env/ide/eclipse-new-class-2.png" alt="new-hello-class"></p><p>点击”Finish“，就自动在<code>src</code>目录下创建了一个名为<code>Hello.java</code>的源文件。我们双击打开这个源文件，填上代码：</p><p><img src="https://liaoxuefeng.com/books/java/quick-start/dev-env/ide/eclipse-edit.jpg" alt="hello-java-source"></p><p>保存，然后选中文件<code>Hello.java</code>，点击右键，在弹出的菜单中选中“Run As…”-“Java Application”：</p><p><img src="https://liaoxuefeng.com/books/java/quick-start/dev-env/ide/eclipse-run.jpg" alt="run-as-java-application"></p><p>在<code>Console</code>窗口中就可以看到运行结果：</p><p><img src="https://liaoxuefeng.com/books/java/quick-start/dev-env/ide/eclipse-result.png" alt="console"></p><p>如果没有在主界面中看到<code>Console</code>窗口，请选中菜单“Window”-“Show View”-“Console”，即可显示。</p><p>我们先剖析一个完整的Java程序，它的基本结构是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以用来自动创建文档的注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 向屏幕输出文本:</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">        <span class="comment">/* 多行注释开始</span></span><br><span class="line"><span class="comment">        注释内容</span></span><br><span class="line"><span class="comment">        注释结束 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// class定义结束</span></span><br></pre></td></tr></table></figure><p>因为Java是面向对象的语言，一个程序的基本单位就是<code>class</code>，<code>class</code>是关键字，这里定义的<code>class</code>名字就是<code>Hello</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123; <span class="comment">// 类名是Hello</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="comment">// class定义结束</span></span><br></pre></td></tr></table></figure><p>类名要求：</p><ul><li>类名必须以英文字母开头，后接字母，数字和下划线的组合</li><li>习惯以大写字母开头</li></ul><p>要注意遵守命名习惯，好的类命名：</p><ul><li>Hello</li><li>NoteBook</li><li>VRPlayer</li></ul><p>不好的类命名：</p><ul><li>hello</li><li>Good123</li><li>Note_Book</li><li>_World</li></ul><p>注意到<code>public</code>是访问修饰符，表示该<code>class</code>是公开的。</p><p>不写<code>public</code>，也能正确编译，但是这个类将无法从命令行执行。</p><p>在<code>class</code>内部，可以定义若干方法（method）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; <span class="comment">// 方法名是main</span></span><br><span class="line">        <span class="comment">// 方法代码...</span></span><br><span class="line">    &#125; <span class="comment">// 方法定义结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法定义了一组执行语句，方法内部的代码将会被依次顺序执行。</p><p>这里的方法名是<code>main</code>，返回值是<code>void</code>，表示没有任何返回值。</p><p>我们注意到<code>public</code>除了可以修饰<code>class</code>外，也可以修饰方法。而关键字<code>static</code>是另一个修饰符，它表示静态方法，后面我们会讲解方法的类型，目前，我们只需要知道，Java入口程序规定的方法必须是静态方法，方法名必须为<code>main</code>，括号内的参数必须是String数组。</p><p>方法名也有命名规则，命名和<code>class</code>一样，但是首字母小写：</p><p>好的方法命名：</p><ul><li>main</li><li>goodMorning</li><li>playVR</li></ul><p>不好的方法命名：</p><ul><li>Main</li><li>good123</li><li>good_morning</li><li>_playVR</li></ul><p>在方法内部，语句才是真正的执行代码。Java的每一行语句必须以分号结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>); <span class="comment">// 语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java程序中，注释是一种给人阅读的文本，不是程序的一部分，所以编译器会自动忽略注释。</p><p>Java有3种注释，第一种是单行注释，以双斜线开头，直到这一行的结尾结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是注释...</span></span><br></pre></td></tr></table></figure><p>而多行注释以<code>/*</code>星号开头，以<code>*/</code>结束，可以有多行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是注释</span></span><br><span class="line"><span class="comment">blablabla...</span></span><br><span class="line"><span class="comment">这也是注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>还有一种特殊的多行注释，以<code>/**</code>开头，以<code>*/</code>结束，如果有多行，每行通常以星号开头：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以用来自动创建文档的注释</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> liaoxuefeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种特殊的多行注释需要写在类和方法的定义处，可以用于自动创建文档。</p><p>Java程序对格式没有明确的要求，多几个空格或者回车不影响程序的正确性，但是我们要养成良好的编程习惯，注意遵守Java社区约定的编码格式。</p><p>那约定的编码格式有哪些要求呢？其实我们在前面介绍的Eclipse IDE提供了快捷键<code>Ctrl+Shift+F</code>（macOS是<code>⌘+⇧+F</code>）帮助我们快速格式化代码的功能，Eclipse就是按照约定的编码格式对代码进行格式化的，所以只需要看看格式化后的代码长啥样就行了。具体的代码格式要求可以在Eclipse的设置中<code>Java</code>-<code>Code Style</code>查看。</p><h3 id="变量">变量</h3><p>什么是变量？</p><p>变量就是初中数学的代数的概念，例如一个简单的方程，x，y都是变量：</p><p>在Java中，变量分为两种：基本类型的变量和引用类型的变量。</p><p>我们先讨论基本类型的变量。</p><p>在Java中，变量必须先定义后使用，在定义变量的时候，可以给它一个初始值。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>上述语句定义了一个整型<code>int</code>类型的变量，名称为<code>x</code>，初始值为<code>1</code>。</p><p>不写初始值，就相当于给它指定了默认值。默认值总是<code>0</code>。</p><p>来看一个完整的定义变量，然后打印变量值的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并打印变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 定义int类型变量x，并赋予初始值100</span></span><br><span class="line">        System.out.println(x); <span class="comment">// 打印该变量的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量的一个重要特点是可以重新赋值。例如，对变量<code>x</code>，先赋值<code>100</code>，再赋值<code>200</code>，观察两次打印的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重新赋值变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 定义int类型变量x，并赋予初始值100</span></span><br><span class="line">        System.out.println(x); <span class="comment">// 打印该变量的值，观察是否为100</span></span><br><span class="line">        x = <span class="number">200</span>; <span class="comment">// 重新赋值为200</span></span><br><span class="line">        System.out.println(x); <span class="comment">// 打印该变量的值，观察是否为200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到第一次定义变量<code>x</code>的时候，需要指定变量类型<code>int</code>，因此使用语句<code>int x = 100;</code>。而第二次重新赋值的时候，变量<code>x</code>已经存在了，不能再重复定义，因此不能指定变量类型<code>int</code>，必须使用语句<code>x = 200;</code>。</p><p>变量不但可以重新赋值，还可以赋值给其他变量。让我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量之间的赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 定义变量n，同时赋值为100</span></span><br><span class="line">        System.out.println(<span class="string">&quot;n = &quot;</span> + n); <span class="comment">// 打印n的值</span></span><br><span class="line"></span><br><span class="line">        n = <span class="number">200</span>; <span class="comment">// 变量n赋值为200</span></span><br><span class="line">        System.out.println(<span class="string">&quot;n = &quot;</span> + n); <span class="comment">// 打印n的值</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> n; <span class="comment">// 变量x赋值为n（n的值为200，因此赋值后x的值也是200）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;x = &quot;</span> + x); <span class="comment">// 打印x的值</span></span><br><span class="line"></span><br><span class="line">        x = x + <span class="number">100</span>; <span class="comment">// 变量x赋值为x+100（x的值为200，因此赋值后x的值是200+100=300）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;x = &quot;</span> + x); <span class="comment">// 打印x的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;n = &quot;</span> + n); <span class="comment">// 再次打印n的值，n应该是200还是300？</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一行一行地分析代码执行流程：</p><p>执行<code>int n = 100;</code>，该语句定义了变量<code>n</code>，同时赋值为<code>100</code>，因此，JVM在内存中为变量<code>n</code>分配一个“存储单元”，填入值<code>100</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      n</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">│   │100│   │   │   │   │   │</span><br><span class="line">└───┴───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>执行<code>n = 200;</code>时，JVM把<code>200</code>写入变量<code>n</code>的存储单元，因此，原有的值被覆盖，现在<code>n</code>的值为<code>200</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      n</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">│   │200│   │   │   │   │   │</span><br><span class="line">└───┴───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>执行<code>int x = n;</code>时，定义了一个新的变量<code>x</code>，同时对<code>x</code>赋值，因此，JVM需要<em>新分配</em>一个存储单元给变量<code>x</code>，并写入和变量<code>n</code>一样的值，结果是变量<code>x</code>的值也变为<code>200</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      n           x</span><br><span class="line">      │           │</span><br><span class="line">      ▼           ▼</span><br><span class="line">┌───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">│   │200│   │   │200│   │   │</span><br><span class="line">└───┴───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>执行<code>x = x + 100;</code>时，JVM首先计算等式右边的值<code>x + 100</code>，结果为<code>300</code>（因为此刻<code>x</code>的值为<code>200</code>），然后，将结果<code>300</code>写入<code>x</code>的存储单元，因此，变量<code>x</code>最终的值变为<code>300</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      n           x</span><br><span class="line">      │           │</span><br><span class="line">      ▼           ▼</span><br><span class="line">┌───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">│   │200│   │   │300│   │   │</span><br><span class="line">└───┴───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>可见，变量可以反复赋值。注意，等号<code>=</code>是赋值语句，不是数学意义上的相等，否则无法解释<code>x = x + 100</code>。</p><h3 id="基本数据类型">基本数据类型</h3><p>基本数据类型是CPU可以直接进行运算的类型。Java定义了以下几种基本数据类型：</p><ul><li>整数类型：byte，short，int，long</li><li>浮点数类型：float，double</li><li>字符类型：char</li><li>布尔类型：boolean</li></ul><p>Java定义的这些基本数据类型有什么区别呢？要了解这些区别，我们就必须简单了解一下计算机内存的基本结构。</p><p>计算机内存的最小存储单元是字节（byte），一个字节就是一个8位二进制数，即8个bit。它的二进制表示范围从<code>00000000</code>~<code>11111111</code>，换算成十进制是0~255，换算成十六进制是<code>00</code>~<code>ff</code>。</p><p>内存单元从0开始编号，称为内存地址。每个内存单元可以看作一间房间，内存地址就是门牌号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  0   1   2   3   4   5   6  ...</span><br><span class="line">┌───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">│   │   │   │   │   │   │   │...</span><br><span class="line">└───┴───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>一个字节是1byte，1024字节是1K，1024K是1M，1024M是1G，1024G是1T。一个拥有4T内存的计算机的字节数量就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4T = 4 x 1024G</span><br><span class="line">   = 4 x 1024 x 1024M</span><br><span class="line">   = 4 x 1024 x 1024 x 1024K</span><br><span class="line">   = 4 x 1024 x 1024 x 1024 x 1024</span><br><span class="line">   = 4398046511104</span><br></pre></td></tr></table></figure><p>不同的数据类型占用的字节数不一样。我们看一下Java基本数据类型占用的字节数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">       ┌───┐</span><br><span class="line">  byte │   │</span><br><span class="line">       └───┘</span><br><span class="line">       ┌───┬───┐</span><br><span class="line"> short │   │   │</span><br><span class="line">       └───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┐</span><br><span class="line">   int │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">  long │   │   │   │   │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┴───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┐</span><br><span class="line"> float │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">double │   │   │   │   │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┴───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┐</span><br><span class="line">  char │   │   │</span><br><span class="line">       └───┴───┘</span><br></pre></td></tr></table></figure><p><code>byte</code>恰好就是一个字节，而<code>long</code>和<code>double</code>需要8个字节。</p><h3 id="整型">整型</h3><p>对于整型类型，Java只定义了带符号的整型，因此，最高位的bit表示符号位（0表示正数，1表示负数）。各种整型能表示的最大范围如下：</p><ul><li>byte：-128 ~ 127</li><li>short: -32768 ~ 32767</li><li>int: -2147483648 ~ 2147483647</li><li>long: -9223372036854775808 ~ 9223372036854775807</li></ul><p>我们来看定义整型的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义整型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2147483647</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> -<span class="number">2147483648</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">2_000_000_000</span>; <span class="comment">// 加下划线更容易识别</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">0xff0000</span>; <span class="comment">// 十六进制表示的16711680</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i5</span> <span class="operator">=</span> <span class="number">0b1000000000</span>; <span class="comment">// 二进制表示的512</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">9000000000000000000L</span>; <span class="comment">// long型的结尾需要加L</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">900</span>; <span class="comment">// 没有加L，此处900为int，但int类型可以赋值给long</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i6</span> <span class="operator">=</span> <span class="number">900L</span>; <span class="comment">// 错误：不能把long型赋值给int</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别注意：同一个数的不同进制的表示是完全相同的，例如<code>15</code>=<code>0xf</code>＝<code>0b1111</code>。</p><h3 id="浮点型">浮点型</h3><p>浮点类型的数就是小数，因为小数用科学计数法表示的时候，小数点是可以“浮动”的，如1234.5可以表示成12.345x102，也可以表示成1.2345x103，所以称为浮点数。</p><p>下面是定义浮点数的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">3.14f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">3.14e38f</span>; <span class="comment">// 科学计数法表示的3.14x10^38</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="number">1.0</span>; <span class="comment">// 错误：不带f结尾的是double类型，不能赋值给float</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.79e308</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> -<span class="number">1.79e308</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="number">4.9e-324</span>; <span class="comment">// 科学计数法表示的4.9x10^-324</span></span><br></pre></td></tr></table></figure><p>对于<code>float</code>类型，需要加上<code>f</code>后缀。</p><p>浮点数可表示的范围非常大，<code>float</code>类型可最大表示3.4x1038，而<code>double</code>类型可最大表示1.79x10308。</p><h3 id="布尔类型">布尔类型</h3><p>布尔类型<code>boolean</code>只有<code>true</code>和<code>false</code>两个值，布尔类型总是关系运算的计算结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isGreater</span> <span class="operator">=</span> <span class="number">5</span> &gt; <span class="number">3</span>; <span class="comment">// 计算结果为true</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isAdult</span> <span class="operator">=</span> age &gt;= <span class="number">18</span>; <span class="comment">// 计算结果为false</span></span><br></pre></td></tr></table></figure><p>Java语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要1 bit，但是通常JVM内部会把<code>boolean</code>表示为4字节整数。</p><h3 id="字符类型">字符类型</h3><p>字符类型<code>char</code>表示一个字符。Java的<code>char</code>类型除了可表示标准的ASCII外，还可以表示一个Unicode字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">zh</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(zh);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>char</code>类型使用单引号<code>'</code>，且仅有一个字符，要和双引号<code>&quot;</code>的字符串类型区分开。</p><h3 id="引用类型">引用类型</h3><p>除了上述基本类型的变量，剩下的都是引用类型。例如，引用类型最常用的就是<code>String</code>字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure><p>引用类型的变量类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置，后续我们介绍类的概念时会详细讨论。</p><h3 id="常量">常量</h3><p>定义变量的时候，如果加上<code>final</code>修饰符，这个变量就变成了常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>; <span class="comment">// PI是一个常量</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">5.0</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> PI * r * r;</span><br><span class="line">PI = <span class="number">300</span>; <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。</p><p>常量的作用是用有意义的变量名来避免魔术数字（Magic number），例如，不要在代码中到处写<code>3.14</code>，而是定义一个常量。如果将来需要提高计算精度，我们只需要在常量的定义处修改，例如，改成<code>3.1416</code>，而不必在所有地方替换<code>3.14</code>。</p><p>为了和变量区分开来，根据习惯，常量名通常<strong>全部大写</strong>。</p><h3 id="var关键字">var关键字</h3><p>有些时候，类型的名字太长，写起来比较麻烦。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure><p>这个时候，如果想省略变量类型，可以使用<code>var</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure><p>编译器会根据赋值语句自动推断出变量<code>sb</code>的类型是<code>StringBuilder</code>。对编译器来说，语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure><p>实际上会自动变成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure><p>因此，使用<code>var</code>定义变量，仅仅是少写了变量类型而已。</p><h3 id="变量的作用范围">变量的作用范围</h3><p>在Java中，多行语句用<code>&#123; ... &#125;</code>括起来。很多控制语句，例如条件判断和循环，都以<code>&#123; ... &#125;</code>作为它们自身的范围，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &#123; <span class="comment">// if开始</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (...) &#123; <span class="comment">// while 开始</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (...) &#123; <span class="comment">// if开始</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="comment">// if结束</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="comment">// while结束</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// if结束</span></span><br></pre></td></tr></table></figure><p>只要正确地嵌套这些<code>&#123; ... &#125;</code>，编译器就能识别出语句块的开始和结束。而在语句块中定义的变量，它有一个作用域，就是从定义处开始，到语句块结束。超出了作用域引用这些变量，编译器会报错。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 变量i从这里开始定义</span></span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 变量x从这里开始定义</span></span><br><span class="line">        ...</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>; <span class="comment">// 变量s从这里开始定义</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="comment">// 变量s作用域到此结束</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 注意，这是一个新的变量s，它和上面的变量同名，</span></span><br><span class="line">        <span class="comment">// 但是因为作用域不同，它们是两个不同的变量:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="comment">// 变量x和s作用域到此结束</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// 变量i作用域到此结束</span></span><br></pre></td></tr></table></figure><p>定义变量时，要遵循作用域最小化原则，尽量将变量定义在尽可能小的作用域，并且，不要重复使用变量名。</p><h3 id="小结-2">小结</h3><p>Java提供了两种变量类型：基本类型和引用类型</p><p>基本类型包括整型，浮点型，布尔型，字符型。</p><p>变量可重新赋值，等号是赋值语句，不是数学意义的等号。</p><p>常量在初始化后不可重新赋值，使用常量便于理解程序意图。</p><p>Java的整数运算遵循四则运算规则，可以使用任意嵌套的小括号。四则运算规则和初等数学一致。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 四则运算</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="number">100</span> + <span class="number">200</span>) * (<span class="number">99</span> - <span class="number">88</span>); <span class="comment">// 3300</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">7</span> * (<span class="number">5</span> + (i - <span class="number">9</span>)); <span class="comment">// 23072</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">12345</span> / <span class="number">67</span>; <span class="comment">// 184</span></span><br></pre></td></tr></table></figure><p>求余运算使用<code>%</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">12345</span> % <span class="number">67</span>; <span class="comment">// 12345÷67的余数是17</span></span><br></pre></td></tr></table></figure><p>特别注意：整数的除法对于除数为0时运行时将报错，但编译不会报错。</p><h3 id="溢出">溢出</h3><p>要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出<em>不会出错</em>，却会得到一个奇怪的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运算溢出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2147483640</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x + y;</span><br><span class="line">        System.out.println(sum); <span class="comment">// -2147483641</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要解释上述结果，我们把整数<code>2147483640</code>和<code>15</code>换成二进制做加法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  0111 1111 1111 1111 1111 1111 1111 1000</span><br><span class="line">+ 0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line">-----------------------------------------</span><br><span class="line">  1000 0000 0000 0000 0000 0000 0000 0111</span><br></pre></td></tr></table></figure><p>由于最高位计算结果为<code>1</code>，因此，加法结果变成了一个负数。</p><p>要解决上面的问题，可以把<code>int</code>换成<code>long</code>类型，由于<code>long</code>可表示的整型范围更大，所以结果就不会溢出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2147483640</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> x + y;</span><br><span class="line">System.out.println(sum); <span class="comment">// 2147483655</span></span><br></pre></td></tr></table></figure><p>还有一种简写的运算符，即<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，它们的使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n += <span class="number">100</span>; <span class="comment">// 3409, 相当于 n = n + 100;</span></span><br><span class="line">n -= <span class="number">100</span>; <span class="comment">// 3309, 相当于 n = n - 100;</span></span><br></pre></td></tr></table></figure><h3 id="自增-自减">自增/自减</h3><p>Java还提供了<code>++</code>运算和<code>--</code>运算，它们可以对一个整数进行加1和减1的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自增/自减运算</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3300</span>;</span><br><span class="line">        n++; <span class="comment">// 3301, 相当于 n = n + 1;</span></span><br><span class="line">        n--; <span class="comment">// 3300, 相当于 n = n - 1;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span> + (++n); <span class="comment">// 不要这么写</span></span><br><span class="line">        System.out.println(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>++</code>写在前面和后面计算结果是不同的，<code>++n</code>表示先加1再引用n，<code>n++</code>表示先引用n再加1。不建议把<code>++</code>运算混入到常规运算中，容易自己把自己搞懵了。</p><h3 id="移位运算">移位运算</h3><p>在计算机中，整数总是以二进制的形式表示。例如，<code>int</code>类型的整数<code>7</code>使用4字节表示的二进制如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000 0000000 0000000 00000111</span><br></pre></td></tr></table></figure><p>可以对整数进行移位运算。对整数<code>7</code>左移1位将得到整数<code>14</code>，左移两位将得到整数<code>28</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">7</span>;       <span class="comment">// 00000000 00000000 00000000 00000111 = 7</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> n &lt;&lt; <span class="number">1</span>;  <span class="comment">// 00000000 00000000 00000000 00001110 = 14</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> n &lt;&lt; <span class="number">2</span>;  <span class="comment">// 00000000 00000000 00000000 00011100 = 28</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> n &lt;&lt; <span class="number">28</span>; <span class="comment">// 01110000 00000000 00000000 00000000 = 1879048192</span></span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> n &lt;&lt; <span class="number">29</span>; <span class="comment">// 11100000 00000000 00000000 00000000 = -536870912</span></span><br></pre></td></tr></table></figure><p>左移29位时，由于最高位变成<code>1</code>，因此结果变成了负数。</p><p>类似的，对整数28进行右移，结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">7</span>;       <span class="comment">// 00000000 00000000 00000000 00000111 = 7</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> n &gt;&gt; <span class="number">1</span>;  <span class="comment">// 00000000 00000000 00000000 00000011 = 3</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> n &gt;&gt; <span class="number">2</span>;  <span class="comment">// 00000000 00000000 00000000 00000001 = 1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> n &gt;&gt; <span class="number">3</span>;  <span class="comment">// 00000000 00000000 00000000 00000000 = 0</span></span><br></pre></td></tr></table></figure><p>如果对一个负数进行右移，最高位的<code>1</code>不动，结果仍然是一个负数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">536870912</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> n &gt;&gt; <span class="number">1</span>;  <span class="comment">// 11110000 00000000 00000000 00000000 = -268435456</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> n &gt;&gt; <span class="number">2</span>;  <span class="comment">// 11111000 00000000 00000000 00000000 = -134217728</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> n &gt;&gt; <span class="number">28</span>; <span class="comment">// 11111111 11111111 11111111 11111110 = -2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> n &gt;&gt; <span class="number">29</span>; <span class="comment">// 11111111 11111111 11111111 11111111 = -1</span></span><br></pre></td></tr></table></figure><p>还有一种无符号的右移运算，使用<code>&gt;&gt;&gt;</code>，它的特点是不管符号位，右移后高位总是补<code>0</code>，因此，对一个负数进行<code>&gt;&gt;&gt;</code>右移，它会变成正数，原因是最高位的<code>1</code>变成了<code>0</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">536870912</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> n &gt;&gt;&gt; <span class="number">1</span>;  <span class="comment">// 01110000 00000000 00000000 00000000 = 1879048192</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> n &gt;&gt;&gt; <span class="number">2</span>;  <span class="comment">// 00111000 00000000 00000000 00000000 = 939524096</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> n &gt;&gt;&gt; <span class="number">29</span>; <span class="comment">// 00000000 00000000 00000000 00000111 = 7</span></span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> n &gt;&gt;&gt; <span class="number">31</span>; <span class="comment">// 00000000 00000000 00000000 00000001 = 1</span></span><br></pre></td></tr></table></figure><p>对<code>byte</code>和<code>short</code>类型进行移位时，会首先转换为<code>int</code>再进行位移。</p><p>仔细观察可发现，左移实际上就是不断地×2，右移实际上就是不断地÷2。</p><h3 id="位运算">位运算</h3><p>位运算是按位进行与、或、非和异或的运算。我们先来看看针对单个bit的位运算。</p><p>与运算的规则是，必须两个数同时为<code>1</code>，结果才为<code>1</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0</span> &amp; <span class="number">0</span>; <span class="comment">// 0</span></span><br><span class="line">n = <span class="number">0</span> &amp; <span class="number">1</span>; <span class="comment">// 0</span></span><br><span class="line">n = <span class="number">1</span> &amp; <span class="number">0</span>; <span class="comment">// 0</span></span><br><span class="line">n = <span class="number">1</span> &amp; <span class="number">1</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>或运算的规则是，只要任意一个为<code>1</code>，结果就为<code>1</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0</span> | <span class="number">0</span>; <span class="comment">// 0</span></span><br><span class="line">n = <span class="number">0</span> | <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">n = <span class="number">1</span> | <span class="number">0</span>; <span class="comment">// 1</span></span><br><span class="line">n = <span class="number">1</span> | <span class="number">1</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>非运算的规则是，<code>0</code>和<code>1</code>互换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = ~<span class="number">0</span>; <span class="comment">// 1</span></span><br><span class="line">n = ~<span class="number">1</span>; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>异或运算的规则是，如果两个数不同，结果为<code>1</code>，否则为<code>0</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0</span> ^ <span class="number">0</span>; <span class="comment">// 0</span></span><br><span class="line">n = <span class="number">0</span> ^ <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">n = <span class="number">1</span> ^ <span class="number">0</span>; <span class="comment">// 1</span></span><br><span class="line">n = <span class="number">1</span> ^ <span class="number">1</span>; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>Java没有单个bit的数据类型。在Java中，对两个整数进行位运算，实际上就是按位对齐，然后依次对每一位进行运算。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位运算</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">167776589</span>; <span class="comment">// 00001010 00000000 00010001 01001101</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">167776512</span>; <span class="comment">// 00001010 00000000 00010001 00000000</span></span><br><span class="line">                         <span class="comment">// &amp; -----------------------------------</span></span><br><span class="line">                           <span class="comment">// 00001010 00000000 00010001 00000000</span></span><br><span class="line">        System.out.println(i &amp; n); <span class="comment">// 167776512</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述按位与运算实际上可以看作两个整数表示的IP地址<code>10.0.17.77</code>和<code>10.0.17.0</code>，通过与运算，可以快速判断一个IP是否在给定的网段内。</p><h3 id="运算优先级">运算优先级</h3><p>在Java的计算表达式中，运算优先级从高到低依次是：</p><ul><li><code>()</code></li><li><code>!</code> <code>~</code> <code>++</code> <code>--</code></li><li><code>*</code> <code>/</code> <code>%</code></li><li><code>+</code> <code>-</code></li><li><code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&gt;&gt;&gt;</code></li><li><code>&amp;</code></li><li><code>|</code></li><li><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code></li></ul><p>记不住也没关系，只需要加括号就可以保证运算的优先级正确。</p><h3 id="类型自动提升与强制转型">类型自动提升与强制转型</h3><p>在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。例如，<code>short</code>和<code>int</code>计算，结果总是<code>int</code>，原因是<code>short</code>首先自动被转型为<code>int</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型自动提升与强制转型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1234</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">123456</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> s + i; <span class="comment">// s自动转型为int</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">y</span> <span class="operator">=</span> s + i; <span class="comment">// 编译错误!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以将结果强制转型，即将大范围的整数转型为小范围的整数。强制转型使用<code>(类型)</code>，例如，将<code>int</code>强制转型为<code>short</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">12345</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> (<span class="type">short</span>) i; <span class="comment">// 12345</span></span><br></pre></td></tr></table></figure><p>要注意，超出范围的强制转型会得到错误的结果，原因是转型时，<code>int</code>的两个高位字节直接被扔掉，仅保留了低位的两个字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强制转型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1234567</span>;</span><br><span class="line">        <span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> (<span class="type">short</span>) i1; <span class="comment">// -10617</span></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">12345678</span>;</span><br><span class="line">        <span class="type">short</span> <span class="variable">s2</span> <span class="operator">=</span> (<span class="type">short</span>) i2; <span class="comment">// 24910</span></span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，强制转型的结果很可能是错的。</p><h3 id="练习">练习</h3><p>计算前N个自然数的和可以根据公式：</p><p>请根据公式计算前N个自然数的和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算前N个自然数的和</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> sum = 1 + 2 + ... + n</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> ???;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        System.out.println(sum == <span class="number">5050</span> ? <span class="string">&quot;测试通过&quot;</span> : <span class="string">&quot;测试失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/quick-start/basic/integer/basic-integer.zip">下载练习</a></p><h3 id="小结-3">小结</h3><p>整数运算的结果永远是精确的；</p><p>运算结果会自动提升；</p><p>可以强制转型，但超出范围的强制转型会得到错误的结果；</p><p>应该选择合适范围的整型（<code>int</code>或<code>long</code>），没有必要为了节省内存而使用<code>byte</code>和<code>short</code>进行整数运算。</p><p>浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算。</p><p>在计算机中，浮点数虽然表示的范围大，但是，浮点数有个非常重要的特点，就是浮点数常常无法精确表示。</p><p>举个例子：</p><p>浮点数<code>0.1</code>在计算机中就无法精确表示，因为十进制的<code>0.1</code>换算成二进制是一个无限循环小数，很显然，无论使用<code>float</code>还是<code>double</code>，都只能存储一个<code>0.1</code>的近似值。但是，<code>0.5</code>这个浮点数又可以精确地表示。</p><p>因为浮点数常常无法精确表示，因此，浮点数运算会产生误差：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浮点数运算误差</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1.0</span> / <span class="number">10</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span> - <span class="number">9.0</span> / <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 观察x和y是否相等:</span></span><br><span class="line">        System.out.println(x);</span><br><span class="line">        System.out.println(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较x和y是否相等，先计算其差的绝对值:</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> Math.abs(x - y);</span><br><span class="line"><span class="comment">// 再判断绝对值是否足够小:</span></span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">    <span class="comment">// 可以认为相等</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浮点数在内存的表示方法和整数比更加复杂。Java的浮点数完全遵循<a href="https://standards.ieee.org/ieee/754/6210/">IEEE-754</a>标准，这也是绝大多数计算机平台都支持的浮点数标准表示方法。</p><h3 id="类型提升">类型提升</h3><p>如果参与运算的两个数其中一个是整型，那么整型可以自动提升到浮点型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型提升</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.2</span> + <span class="number">24.0</span> / n; <span class="comment">// 6.0</span></span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要特别注意，在一个复杂的四则运算中，两个整数的运算不会出现自动提升的情况。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.2</span> + <span class="number">24</span> / <span class="number">5</span>; <span class="comment">// 结果不是 6.0 而是 5.2</span></span><br></pre></td></tr></table></figure><p>计算结果为<code>5.2</code>，原因是编译器计算<code>24 / 5</code>这个子表达式时，按两个整数进行运算，结果仍为整数<code>4</code>。</p><p>要修复这个计算结果，可以将<code>24 / 5</code>改为<code>24.0 / 5</code>。由于<code>24.0</code>是浮点数，因此，计算除法时自动将<code>5</code>提升为浮点数。</p><h3 id="溢出-2">溢出</h3><p>整数运算在除数为<code>0</code>时会报错，而浮点数运算在除数为<code>0</code>时，不会报错，但会返回几个特殊值：</p><ul><li><code>NaN</code>表示Not a Number</li><li><code>Infinity</code>表示无穷大</li><li><code>-Infinity</code>表示负无穷大</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">0.0</span> / <span class="number">0</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">1.0</span> / <span class="number">0</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> -<span class="number">1.0</span> / <span class="number">0</span>; <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure><p>这三种特殊值在实际运算中很少碰到，我们只需要了解即可。</p><h3 id="强制转型">强制转型</h3><p>可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">12.3</span>; <span class="comment">// 12</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">12.7</span>; <span class="comment">// 12</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> (<span class="type">int</span>) -<span class="number">12.7</span>; <span class="comment">// -12</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n4</span> <span class="operator">=</span> (<span class="type">int</span>) (<span class="number">12.7</span> + <span class="number">0.5</span>); <span class="comment">// 13</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n5</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1.2e20</span>; <span class="comment">// 2147483647</span></span><br></pre></td></tr></table></figure><p>如果要进行四舍五入，可以对浮点数加上<code>0.5</code>再强制转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 四舍五入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">2.6</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) (d + <span class="number">0.5</span>);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习-2">练习</h3><p>根据一元二次方程 ax2+bx+c=0ax^2+bx+c=0 的求根公式：</p><p>计算出一元二次方程的两个解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一元二次方程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3.0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">4.0</span>;</span><br><span class="line">        <span class="comment">// 求平方根可用 Math.sqrt():</span></span><br><span class="line">        <span class="comment">// System.out.println(Math.sqrt(2)); ==&gt; 1.414</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="type">double</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        System.out.println(r1);</span><br><span class="line">        System.out.println(r2);</span><br><span class="line">        System.out.println(r1 == <span class="number">1</span> &amp;&amp; r2 == -<span class="number">4</span> ? <span class="string">&quot;测试通过&quot;</span> : <span class="string">&quot;测试失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/quick-start/basic/float/basic-float.zip">下载练习</a></p><h3 id="小结-4">小结</h3><p>浮点数常常无法精确表示，并且浮点数的运算结果可能有误差；</p><p>比较两个浮点数通常比较它们的差的绝对值是否小于一个特定值；</p><p>整型和浮点型运算时，整型会自动提升为浮点型；</p><p>可以将浮点型强制转为整型，但超出范围后将始终返回整型的最大值。</p><h2 id="布尔运算">布尔运算</h2><p>对于布尔类型<code>boolean</code>，永远只有<code>true</code>和<code>false</code>两个值。</p><p>布尔运算是一种关系运算，包括以下几类：</p><ul><li>比较运算符：<code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code>，<code>==</code>，<code>!=</code></li><li>与运算 <code>&amp;&amp;</code></li><li>或运算 <code>||</code></li><li>非运算 <code>!</code></li></ul><p>下面是一些示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isGreater</span> <span class="operator">=</span> <span class="number">5</span> &gt; <span class="number">3</span>; <span class="comment">// true</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isZero</span> <span class="operator">=</span> age == <span class="number">0</span>; <span class="comment">// false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isNonZero</span> <span class="operator">=</span> !isZero; <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isAdult</span> <span class="operator">=</span> age &gt;= <span class="number">18</span>; <span class="comment">// false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isTeenager</span> <span class="operator">=</span> age &gt;<span class="number">6</span> &amp;&amp; age &lt;<span class="number">18</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>关系运算符的优先级从高到低依次是：</p><ul><li><code>!</code></li><li><code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code></li><li><code>==</code>，<code>!=</code></li><li><code>&amp;&amp;</code></li><li><code>||</code></li></ul><h3 id="短路运算">短路运算</h3><p>布尔运算的一个重要特点是短路运算。如果一个布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果。</p><p>因为<code>false &amp;&amp; x</code>的结果总是<code>false</code>，无论<code>x</code>是<code>true</code>还是<code>false</code>，因此，与运算在确定第一个值为<code>false</code>后，不再继续计算，而是直接返回<code>false</code>。</p><p>我们考察以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 短路运算</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span> &lt; <span class="number">3</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> b &amp;&amp; (<span class="number">5</span> / <span class="number">0</span> &gt; <span class="number">0</span>); <span class="comment">// 此处 5 / 0 不会报错</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有短路运算，<code>&amp;&amp;</code>后面的表达式会由于除数为<code>0</code>而报错，但实际上该语句并未报错，原因在于与运算是短路运算符，提前计算出了结果<code>false</code>。</p><p>如果变量<code>b</code>的值为<code>true</code>，则表达式变为<code>true &amp;&amp; (5 / 0 &gt; 0)</code>。因为无法进行短路运算，该表达式必定会由于除数为<code>0</code>而报错，可以自行测试。</p><p>类似的，对于<code>||</code>运算，只要能确定第一个值为<code>true</code>，后续计算也不再进行，而是直接返回<code>true</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">true</span> || (<span class="number">5</span> / <span class="number">0</span> &gt; <span class="number">0</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="三元运算符">三元运算符</h3><p>Java还提供一个三元运算符<code>b ? x : y</code>，它根据第一个布尔表达式的结果，分别返回后续两个表达式之一的计算结果。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三元运算</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> n &gt;= <span class="number">0</span> ? n : -n;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述语句的意思是，判断<code>n &gt;= 0</code>是否成立，如果为<code>true</code>，则返回<code>n</code>，否则返回<code>-n</code>。这实际上是一个求绝对值的表达式。</p><p>注意到三元运算<code>b ? x : y</code>会首先计算<code>b</code>，如果<code>b</code>为<code>true</code>，则只计算<code>x</code>，否则，只计算<code>y</code>。此外，<code>x</code>和<code>y</code>的类型必须相同，因为返回值不是<code>boolean</code>，而是<code>x</code>和<code>y</code>之一。</p><h3 id="练习-3">练习</h3><p>判断指定年龄是否是小学生（6～12岁）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 布尔运算</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">        <span class="comment">// primary student的定义: 6~12岁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isPrimaryStudent</span> <span class="operator">=</span> ???;</span><br><span class="line">        System.out.println(isPrimaryStudent ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/quick-start/basic/boolean/basic-boolean.zip">下载练习</a></p><h3 id="小结-5">小结</h3><p>与运算和或运算是短路运算；</p><p>三元运算<code>b ? x : y</code>后面的类型必须相同，三元运算也是“短路运算”，只计算<code>x</code>或<code>y</code>。</p><hr><hr><p>在Java中，字符和字符串是两个不同的类型。</p><h3 id="字符类型-2">字符类型</h3><p>字符类型<code>char</code>是基本数据类型，它是<code>character</code>的缩写。一个<code>char</code>保存一个Unicode字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>;</span><br></pre></td></tr></table></figure><p>因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个<code>char</code>类型表示，它们都占用两个字节。要显示一个字符的Unicode编码，只需将<code>char</code>类型直接赋值给<code>int</code>类型即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 字母“A”的Unicodde编码是65</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>; <span class="comment">// 汉字“中”的Unicode编码是20013</span></span><br></pre></td></tr></table></figure><p>还可以直接用转义字符<code>\u</code>+Unicode编码来表示一个字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意是十六进制:</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&#x27;\u0041&#x27;</span>; <span class="comment">// &#x27;A&#x27;，因为十六进制0041 = 十进制65</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="string">&#x27;\u4e2d&#x27;</span>; <span class="comment">// &#x27;中&#x27;，因为十六进制4e2d = 十进制20013</span></span><br></pre></td></tr></table></figure><h3 id="字符串类型">字符串类型</h3><p>和<code>char</code>类型不同，字符串类型<code>String</code>是引用类型，我们用双引号<code>&quot;...&quot;</code>表示字符串。一个字符串可以存储0个到任意个字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 空字符串，包含0个字符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span>; <span class="comment">// 包含一个字符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ABC&quot;</span>; <span class="comment">// 包含3个字符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;中文 ABC&quot;</span>; <span class="comment">// 包含6个字符，其中有一个空格</span></span><br></pre></td></tr></table></figure><p>因为字符串使用双引号<code>&quot;...&quot;</code>表示开始和结束，那如果字符串本身恰好包含一个<code>&quot;</code>字符怎么表示？例如，<code>&quot;abc&quot;xyz&quot;</code>，编译器就无法判断中间的引号究竟是字符串的一部分还是表示字符串结束。这个时候，我们需要借助转义字符<code>\</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc\&quot;xyz&quot;</span>; <span class="comment">// 包含7个字符: a, b, c, &quot;, x, y, z</span></span><br></pre></td></tr></table></figure><p>因为<code>\</code>是转义字符，所以，两个<code>\\</code>表示一个<code>\</code>字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc\\xyz&quot;</span>; <span class="comment">// 包含7个字符: a, b, c, \, x, y, z</span></span><br></pre></td></tr></table></figure><p>常见的转义字符包括：</p><ul><li><code>\&quot;</code> 表示字符<code>&quot;</code></li><li><code>\'</code> 表示字符<code>'</code></li><li><code>\\</code> 表示字符<code>\</code></li><li><code>\n</code> 表示换行符</li><li><code>\r</code> 表示回车符</li><li><code>\t</code> 表示Tab</li><li><code>\u####</code> 表示一个Unicode编码的字符</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;ABC\n\u4e2d\u6587&quot;</span>; <span class="comment">// 包含6个字符: A, B, C, 换行符, 中, 文</span></span><br></pre></td></tr></table></figure><h3 id="字符串连接">字符串连接</h3><p>Java的编译器对字符串做了特殊照顾，可以使用<code>+</code>连接任意字符串和其他数据类型，这样极大地方便了字符串的处理。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串连接</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> s1 + <span class="string">&quot; &quot;</span> + s2 + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">        System.out.println(s); <span class="comment">// Hello world!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用<code>+</code>连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串连接</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;age is &quot;</span> + age;</span><br><span class="line">        System.out.println(s); <span class="comment">// age is 25</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多行字符串">多行字符串</h3><p>如果我们要表示多行字符串，使用+号连接会非常不方便：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;first line \n&quot;</span></span><br><span class="line">         + <span class="string">&quot;second line \n&quot;</span></span><br><span class="line">         + <span class="string">&quot;end&quot;</span>;</span><br></pre></td></tr></table></figure><p>从Java 13开始，字符串可以用<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>表示多行字符串（Text Blocks）了。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                   SELECT * FROM</span></span><br><span class="line"><span class="string">                     users</span></span><br><span class="line"><span class="string">                   WHERE id &gt; 100</span></span><br><span class="line"><span class="string">                   ORDER BY name DESC</span></span><br><span class="line"><span class="string">                   &quot;&quot;&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述多行字符串实际上是5行，在最后一个<code>DESC</code>后面还有一个<code>\n</code>。如果我们不想在字符串末尾加一个<code>\n</code>，就需要这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">           SELECT * FROM</span></span><br><span class="line"><span class="string">             users</span></span><br><span class="line"><span class="string">           WHERE id &gt; 100</span></span><br><span class="line"><span class="string">           ORDER BY name DESC&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><p>还需要注意到，多行字符串前面共同的空格会被去掉，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">...........SELECT * FROM</span></span><br><span class="line"><span class="string">...........  users</span></span><br><span class="line"><span class="string">...........WHERE id &gt; 100</span></span><br><span class="line"><span class="string">...........ORDER BY name DESC</span></span><br><span class="line"><span class="string">...........&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><p>用<code>.</code>标注的空格都会被去掉。</p><p>如果多行字符串的排版不规则，那么，去掉的空格就会变成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">.........  SELECT * FROM</span></span><br><span class="line"><span class="string">.........    users</span></span><br><span class="line"><span class="string">.........WHERE id &gt; 100</span></span><br><span class="line"><span class="string">.........  ORDER BY name DESC</span></span><br><span class="line"><span class="string">.........  &quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><p>即总是以最短的行首空格为基准。</p><h3 id="不可变特性">不可变特性</h3><p>Java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变。考察以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串不可变</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(s); <span class="comment">// 显示 hello</span></span><br><span class="line">        s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        System.out.println(s); <span class="comment">// 显示 world</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察执行结果，难道字符串<code>s</code>变了吗？其实变的不是字符串，而是变量<code>s</code>的“指向”。</p><p>执行<code>String s = &quot;hello&quot;;</code>时，JVM虚拟机先创建字符串<code>&quot;hello&quot;</code>，然后，把字符串变量<code>s</code>指向它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      s</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌───┬───────────┬───┐</span><br><span class="line">│   │  &quot;hello&quot;  │   │</span><br><span class="line">└───┴───────────┴───┘</span><br></pre></td></tr></table></figure><p>紧接着，执行<code>s = &quot;world&quot;;</code>时，JVM虚拟机先创建字符串<code>&quot;world&quot;</code>，然后，把字符串变量<code>s</code>指向它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      s ──────────────┐</span><br><span class="line">                      │</span><br><span class="line">                      ▼</span><br><span class="line">┌───┬───────────┬───┬───────────┬───┐</span><br><span class="line">│   │  &quot;hello&quot;  │   │  &quot;world&quot;  │   │</span><br><span class="line">└───┴───────────┴───┴───────────┴───┘</span><br></pre></td></tr></table></figure><p>原来的字符串<code>&quot;hello&quot;</code>还在，只是我们无法通过变量<code>s</code>访问它而已。因此，字符串的不可变是指字符串内容不可变。至于变量，可以一会指向字符串<code>&quot;hello&quot;</code>，一会指向字符串<code>&quot;world&quot;</code>。</p><p>理解了引用类型的“指向”后，试解释下面的代码输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串不可变</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> s;</span><br><span class="line">        s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        System.out.println(t); <span class="comment">// t是&quot;hello&quot;还是&quot;world&quot;?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空值null">空值null</h3><p>引用类型的变量可以指向一个空值<code>null</code>，它表示不存在，即该变量不指向任何对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// s1是null</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1; <span class="comment">// s2也是null</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">// s3指向空字符串，不是null</span></span><br></pre></td></tr></table></figure><p>注意要区分空值<code>null</code>和空字符串<code>&quot;&quot;</code>，空字符串是一个有效的字符串对象，它不等于<code>null</code>。</p><h3 id="练习-4">练习</h3><p>请将一组int值视为字符的Unicode编码，然后将它们拼成一个字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 请将下面一组int值视为字符的Unicode码，把它们拼成一个字符串：</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">72</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">105</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">65281</span>;</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span></span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> a + b + c;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/quick-start/basic/string/basic-char-string.zip">下载练习</a></p><h3 id="小结-6">小结</h3><p>Java的字符类型<code>char</code>是基本类型，字符串类型<code>String</code>是引用类型；</p><p>基本类型的变量是“持有”某个数值，引用类型的变量是“指向”某个对象；</p><p>引用类型的变量可以是空值<code>null</code>；</p><p>要区分空值<code>null</code>和空字符串<code>&quot;&quot;</code>。</p><p>如果我们有一组类型相同的变量，例如，5位同学的成绩，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 5位同学的成绩:</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">68</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">79</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">91</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n4</span> <span class="operator">=</span> <span class="number">85</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n5</span> <span class="operator">=</span> <span class="number">62</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但其实没有必要定义5个<code>int</code>变量。可以使用数组来表示“一组”<code>int</code>类型。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 5位同学的成绩:</span></span><br><span class="line">        <span class="type">int</span>[] ns = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        ns[<span class="number">0</span>] = <span class="number">68</span>;</span><br><span class="line">        ns[<span class="number">1</span>] = <span class="number">79</span>;</span><br><span class="line">        ns[<span class="number">2</span>] = <span class="number">91</span>;</span><br><span class="line">        ns[<span class="number">3</span>] = <span class="number">85</span>;</span><br><span class="line">        ns[<span class="number">4</span>] = <span class="number">62</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个数组类型的变量，使用数组类型“类型[]”，例如，<code>int[]</code>。和单个基本类型变量不同，数组变量初始化必须使用<code>new int[5]</code>表示创建一个可容纳5个<code>int</code>元素的数组。</p><p>Java的数组有几个特点：</p><ul><li>数组所有元素初始化为默认值，整型都是<code>0</code>，浮点型是<code>0.0</code>，布尔型是<code>false</code>；</li><li>数组一旦创建后，大小就不可改变。</li></ul><p>要访问数组中的某一个元素，需要使用索引。数组索引从<code>0</code>开始，例如，5个元素的数组，索引范围是<code>0</code>~<code>4</code>。</p><p>可以修改数组中的某一个元素，使用赋值语句，例如，<code>ns[1] = 79;</code>。</p><p>可以用<code>数组变量.length</code>获取数组大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 5位同学的成绩:</span></span><br><span class="line">        <span class="type">int</span>[] ns = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        System.out.println(ns.length); <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组是引用类型，在使用索引访问数组元素时，如果索引超出范围，运行时将报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 5位同学的成绩:</span></span><br><span class="line">        <span class="type">int</span>[] ns = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        System.out.println(ns[n]); <span class="comment">// 索引n不能超出范围</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以在定义数组时直接指定初始化的元素，这样就不必写出数组大小，而是由编译器自动推算数组大小。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 5位同学的成绩:</span></span><br><span class="line">        <span class="type">int</span>[] ns = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">68</span>, <span class="number">79</span>, <span class="number">91</span>, <span class="number">85</span>, <span class="number">62</span> &#125;;</span><br><span class="line">        System.out.println(ns.length); <span class="comment">// 编译器自动推算数组大小为5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以进一步简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ns = &#123; <span class="number">68</span>, <span class="number">79</span>, <span class="number">91</span>, <span class="number">85</span>, <span class="number">62</span> &#125;;</span><br></pre></td></tr></table></figure><p>注意数组是引用类型，并且数组大小不可变。我们观察下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 5位同学的成绩:</span></span><br><span class="line">        <span class="type">int</span>[] ns;</span><br><span class="line">        ns = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">68</span>, <span class="number">79</span>, <span class="number">91</span>, <span class="number">85</span>, <span class="number">62</span> &#125;;</span><br><span class="line">        System.out.println(ns.length); <span class="comment">// 5</span></span><br><span class="line">        ns = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        System.out.println(ns.length); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组大小变了吗？看上去好像是变了，但其实根本没变。</p><p>对于数组<code>ns</code>来说，执行<code>ns = new int[] &#123; 68, 79, 91, 85, 62 &#125;;</code>时，它指向一个5个元素的数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     ns</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">│   │68 │79 │91 │85 │62 │   │</span><br><span class="line">└───┴───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>执行<code>ns = new int[] &#123; 1, 2, 3 &#125;;</code>时，它指向一个<em>新的</em>3个元素的数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     ns ──────────────────────┐</span><br><span class="line">                              │</span><br><span class="line">                              ▼</span><br><span class="line">┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">│   │68 │79 │91 │85 │62 │   │ 1 │ 2 │ 3 │   │</span><br><span class="line">└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>但是，原有的5个元素的数组并没有改变，只是无法通过变量<code>ns</code>引用到它们而已。</p><h3 id="字符串数组">字符串数组</h3><p>如果数组元素不是基本类型，而是一个引用类型，那么，修改数组元素会有哪些不同？</p><p>字符串是引用类型，因此我们先定义一个字符串数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;</span><br><span class="line">    <span class="string">&quot;ABC&quot;</span>, <span class="string">&quot;XYZ&quot;</span>, <span class="string">&quot;zoo&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于<code>String[]</code>类型的数组变量<code>names</code>，它实际上包含3个元素，但每个元素都指向某个字符串对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          ┌─────────────────────────┐</span><br><span class="line">    names │   ┌─────────────────────┼───────────┐</span><br><span class="line">      │   │   │                     │           │</span><br><span class="line">      ▼   │   │                     ▼           ▼</span><br><span class="line">┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┐</span><br><span class="line">│   │░░░│░░░│░░░│   │ &quot;ABC&quot; │   │ &quot;XYZ&quot; │   │ &quot;zoo&quot; │   │</span><br><span class="line">└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┘</span><br><span class="line">      │                 ▲</span><br><span class="line">      └─────────────────┘</span><br></pre></td></tr></table></figure><p>对<code>names[1]</code>进行赋值，例如<code>names[1] = &quot;cat&quot;;</code>，效果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          ┌─────────────────────────────────────────────────┐</span><br><span class="line">    names │   ┌─────────────────────────────────┐           │</span><br><span class="line">      │   │   │                                 │           │</span><br><span class="line">      ▼   │   │                                 ▼           ▼</span><br><span class="line">┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┬───────┬───┐</span><br><span class="line">│   │░░░│░░░│░░░│   │ &quot;ABC&quot; │   │ &quot;XYZ&quot; │   │ &quot;zoo&quot; │   │ &quot;cat&quot; │   │</span><br><span class="line">└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┴───────┴───┘</span><br><span class="line">      │                 ▲</span><br><span class="line">      └─────────────────┘</span><br></pre></td></tr></table></figure><p>这里注意到原来<code>names[1]</code>指向的字符串<code>&quot;XYZ&quot;</code>并没有改变，仅仅是将<code>names[1]</code>的引用从指向<code>&quot;XYZ&quot;</code>改成了指向<code>&quot;cat&quot;</code>，其结果是字符串<code>&quot;XYZ&quot;</code>再也无法通过<code>names[1]</code>访问到了。</p><p>对“指向”有了更深入的理解后，试解释如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;ABC&quot;</span>, <span class="string">&quot;XYZ&quot;</span>, <span class="string">&quot;zoo&quot;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> names[<span class="number">1</span>];</span><br><span class="line">        names[<span class="number">1</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">        System.out.println(s); <span class="comment">// s是&quot;XYZ&quot;还是&quot;cat&quot;?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-7">小结</h3><p>数组是同一数据类型的集合，数组一旦创建后，大小就不可变；</p><p>可以通过索引访问数组元素，但索引超出范围将报错；</p><p>数组元素可以是值类型（如<code>int</code>）或引用类型（如<code>String</code>），但数组本身是引用类型；</p><h3 id="输出">输出</h3><p>在前面的代码中，我们总是使用<code>System.out.println()</code>来向屏幕输出一些内容。</p><p><code>println</code>是print line的缩写，表示输出并换行。因此，如果输出后不想换行，可以用<code>print()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;A,&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;B,&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;C.&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意观察上述代码的执行效果。</p><h3 id="格式化输出">格式化输出</h3><p>Java还提供了格式化输出的功能。为什么要格式化输出？因为计算机表示的数据不一定适合人来阅读：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式化输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">12900000</span>;</span><br><span class="line">        System.out.println(d); <span class="comment">// 1.29E7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要把数据显示成我们期望的格式，就需要使用格式化输出的功能。格式化输出使用<code>System.out.printf()</code>，通过使用占位符<code>%?</code>，<code>printf()</code>可以把后面的参数格式化成指定格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式化输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3.1415926</span>;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%.2f\n&quot;</span>, d); <span class="comment">// 显示两位小数3.14</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%.4f\n&quot;</span>, d); <span class="comment">// 显示4位小数3.1416</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java的格式化功能提供了多种占位符，可以把各种数据类型“格式化”成指定的字符串：</p><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%d</td><td>格式化输出整数</td></tr><tr><td>%x</td><td>格式化输出十六进制整数</td></tr><tr><td>%f</td><td>格式化输出浮点数</td></tr><tr><td>%e</td><td>格式化输出科学计数法表示的浮点数</td></tr><tr><td>%s</td><td>格式化字符串</td></tr></tbody></table><p>注意，由于<code>%</code>表示占位符，因此，连续两个<code>%%</code>表示一个<code>%</code>字符本身。</p><p>占位符本身还可以有更详细的格式化参数。下面的例子把一个整数格式化成十六进制，并用0补足8位：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式化输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">12345000</span>;</span><br><span class="line">        System.out.printf(<span class="string">&quot;n=%d, hex=%08x&quot;</span>, n, n); <span class="comment">// 注意，两个%占位符必须传入两个数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细的格式化参数请参考JDK文档<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Formatter.html#syntax">java.util.Formatter</a></p><h3 id="输入">输入</h3><p>和输出相比，Java的输入就要复杂得多。</p><p>我们先看一个从控制台读取一个字符串和一个整数的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">// 创建Scanner对象</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Input your name: &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.nextLine(); <span class="comment">// 读取一行输入并获取字符串</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Input your age: &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// 读取一行输入并获取整数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;Hi, %s, you are %d\n&quot;</span>, name, age); <span class="comment">// 格式化输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们通过<code>import</code>语句导入<code>java.util.Scanner</code>，<code>import</code>是导入某个类的语句，必须放到Java源代码的开头，后面我们在Java的<code>package</code>中会详细讲解如何使用<code>import</code>。</p><p>然后，创建<code>Scanner</code>对象并传入<code>System.in</code>。<code>System.out</code>代表标准输出流，而<code>System.in</code>代表标准输入流。直接使用<code>System.in</code>读取用户输入虽然是可以的，但需要更复杂的代码，而通过<code>Scanner</code>就可以简化后续的代码。</p><p>有了<code>Scanner</code>对象后，要读取用户输入的字符串，使用<code>scanner.nextLine()</code>，要读取用户输入的整数，使用<code>scanner.nextInt()</code>。<code>Scanner</code>会自动转换数据类型，因此不必手动转换。</p><p>要测试输入，必须从命令行读取用户输入，因此，需要走编译、执行的流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javac Main.java</span><br></pre></td></tr></table></figure><p>这个程序编译时如果有警告，可以暂时忽略它，在后面学习IO的时候再详细解释。编译成功后，执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ java Main</span><br><span class="line">Input your name: Bob ◀── 输入 Bob</span><br><span class="line">Input your age: 12   ◀── 输入 12</span><br><span class="line">Hi, Bob, you are 12  ◀── 输出</span><br></pre></td></tr></table></figure><p>根据提示分别输入一个字符串和整数后，我们得到了格式化的输出。</p><h3 id="练习-5">练习</h3><p>请帮小明同学设计一个程序，输入上次考试成绩（int）和本次考试成绩（int），然后输出成绩提高的百分比，保留两位小数位（例如，21.75%）。</p><p><a href="https://liaoxuefeng.com/books/java/quick-start/flow/input-output/flow-input-output.zip">下载练习</a></p><h3 id="小结-8">小结</h3><p>Java提供的输出包括：<code>System.out.println()</code> / <code>print()</code> / <code>printf()</code>，其中<code>printf()</code>可以格式化输出；</p><p>Java提供Scanner对象来方便输入，读取对应的类型可以使用：<code>scanner.nextLine()</code> / <code>nextInt()</code> / <code>nextDouble()</code> / …</p><p>在Java程序中，如果要根据条件来决定是否执行某一段代码，就需要<code>if</code>语句。</p><p><code>if</code>语句的基本语法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件) &#123;</span><br><span class="line">    <span class="comment">// 条件满足时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据<code>if</code>的计算结果（<code>true</code>还是<code>false</code>），JVM决定是否执行<code>if</code>语句块（即花括号{}包含的所有语句）。</p><p>让我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件判断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">70</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;及格了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当条件<code>n &gt;= 60</code>计算结果为<code>true</code>时，<code>if</code>语句块被执行，将打印<code>&quot;及格了&quot;</code>，否则，<code>if</code>语句块将被跳过。修改<code>n</code>的值可以看到执行效果。</p><p>注意到<code>if</code>语句包含的块可以包含多条语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件判断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">70</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;及格了&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜你&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>if</code>语句块只有一行语句时，可以省略花括号{}：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件判断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">70</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">60</span>)</span><br><span class="line">            System.out.println(<span class="string">&quot;及格了&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，省略花括号并不总是一个好主意。假设某个时候，突然想给<code>if</code>语句块增加一条语句时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件判断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">60</span>)</span><br><span class="line">            System.out.println(<span class="string">&quot;及格了&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜你&quot;</span>); <span class="comment">// 注意这条语句不是if语句块的一部分</span></span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于使用缩进格式，很容易把两行语句都看成<code>if</code>语句的执行块，但实际上只有第一行语句是<code>if</code>的执行块。在使用git这些版本控制系统自动合并时更容易出问题，所以不推荐忽略花括号的写法。</p><h3 id="else">else</h3><p><code>if</code>语句还可以编写一个<code>else &#123; ... &#125;</code>，当条件判断为<code>false</code>时，将执行<code>else</code>的语句块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件判断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">70</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;及格了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;挂科了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改上述代码<code>n</code>的值，观察<code>if</code>条件为<code>true</code>或<code>false</code>时，程序执行的语句块。</p><p>注意，<code>else</code>不是必须的。</p><p>还可以用多个<code>if ... else if ...</code>串联。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件判断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">70</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;及格了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;挂科了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>串联的效果其实相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">    <span class="comment">// n &gt;= 90为true:</span></span><br><span class="line">    System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// n &gt;= 90为false:</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">        <span class="comment">// n &gt;= 60为true:</span></span><br><span class="line">        System.out.println(<span class="string">&quot;及格了&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// n &gt;= 60为false:</span></span><br><span class="line">        System.out.println(<span class="string">&quot;挂科了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在串联使用多个<code>if</code>时，要<em>特别注意</em>判断顺序。观察下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件判断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;及格了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;挂科了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行发现，<code>n = 100</code>时，满足条件<code>n &gt;= 90</code>，但输出的不是<code>&quot;优秀&quot;</code>，而是<code>&quot;及格了&quot;</code>，原因是<code>if</code>语句从上到下执行时，先判断<code>n &gt;= 60</code>成功后，后续<code>else</code>不再执行，因此，<code>if (n &gt;= 90)</code>没有机会执行了。</p><p>正确的方式是按照判断范围从大到小依次判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从大到小依次判断：</span></span><br><span class="line"><span class="keyword">if</span> (n &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者改写成从小到大依次判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从小到大依次判断：</span></span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">60</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">90</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>if</code>时，还要特别注意边界条件。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件判断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">90</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">90</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;及格了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;挂科了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们期望90分或更高为“优秀”，上述代码输出的却是“及格”，原因是<code>&gt;</code>和<code>&gt;=</code>效果是不同的。</p><p>前面讲过了浮点数在计算机中常常无法精确表示，并且计算可能出现误差，因此，判断浮点数相等用<code>==</code>判断不靠谱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件判断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> - <span class="number">9.0</span> / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0.1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x is 0.1&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x is NOT 0.1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的方法是利用差值小于某个临界值来判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件判断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> - <span class="number">9.0</span> / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(x - <span class="number">0.1</span>) &lt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x is 0.1&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x is NOT 0.1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断引用类型相等">判断引用类型相等</h3><p>在Java中，判断值类型的变量是否相等，可以使用<code>==</code>运算符。但是，判断引用类型的变量是否相等，<code>==</code>表示“引用是否相等”，或者说，是否指向同一个对象。例如，下面的两个String类型，它们的内容是相同的，但是，分别指向不同的对象，用<code>==</code>判断，结果为<code>false</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件判断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;HELLO&quot;</span>.toLowerCase();</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        <span class="keyword">if</span> (s1 == s2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s1 == s2&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s1 != s2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要判断引用类型的变量内容是否相等，必须使用<code>equals()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件判断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;HELLO&quot;</span>.toLowerCase();</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        <span class="keyword">if</span> (s1.equals(s2)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s1 equals s2&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s1 not equals s2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：执行语句<code>s1.equals(s2)</code>时，如果变量<code>s1</code>为<code>null</code>，会报<code>NullPointerException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件判断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (s1.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要避免<code>NullPointerException</code>错误，可以利用短路运算符<code>&amp;&amp;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件判断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (s1 != <span class="literal">null</span> &amp;&amp; s1.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以把一定不是<code>null</code>的对象<code>&quot;hello&quot;</code>放到前面：例如：<code>if (&quot;hello&quot;.equals(s)) &#123; ... &#125;</code>。</p><h3 id="练习-6">练习</h3><p>请用<code>if ... else</code>编写一个程序，用于计算体质指数BMI，并打印结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BMI = 体重(kg) / 身高(m)的平方</span><br></pre></td></tr></table></figure><p>BMI结果：</p><ul><li>过轻：低于18.5</li><li>正常：18.5 ~ 25</li><li>过重：25 ~ 28</li><li>肥胖：28 ~ 32</li><li>非常肥胖：高于32</li></ul><p><a href="https://liaoxuefeng.com/books/java/quick-start/flow/if/flow-if.zip">下载练习</a></p><h3 id="小结-9">小结</h3><p><code>if ... else</code>可以做条件判断，<code>else</code>是可选的；</p><p>不推荐省略花括号<code>&#123;&#125;</code>；</p><p>多个<code>if ... else</code>串联要特别注意判断顺序；</p><p>要注意<code>if</code>的边界条件；</p><p>要注意浮点数判断相等不能直接用<code>==</code>运算符；</p><p>引用类型判断内容相等要使用<code>equals()</code>，注意避免<code>NullPointerException</code>。</p><p>除了<code>if</code>语句外，还有一种条件判断，是根据某个表达式的结果，分别去执行不同的分支。</p><p>例如，在游戏中，让用户选择选项：</p><ol><li>单人模式</li><li>多人模式</li><li>退出游戏</li></ol><p>这时，<code>switch</code>语句就派上用场了。</p><p><code>switch</code>语句根据<code>switch (表达式)</code>计算的结果，跳转到匹配的<code>case</code>结果，然后继续执行后续语句，直到遇到<code>break</code>结束执行。</p><p>我们看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">option</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected 1&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected 2&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected 3&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改<code>option</code>的值分别为<code>1</code>、<code>2</code>、<code>3</code>，观察执行结果。</p><p>如果<code>option</code>的值没有匹配到任何<code>case</code>，例如<code>option = 99</code>，那么，<code>switch</code>语句不会执行任何语句。这时，可以给<code>switch</code>语句加一个<code>default</code>，当没有匹配到任何<code>case</code>时，执行<code>default</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">option</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">        <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected 1&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected 2&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected 3&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected other&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把<code>switch</code>语句翻译成<code>if</code>语句，那么上述的代码相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (option == <span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Selected 1&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == <span class="number">2</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Selected 2&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == <span class="number">3</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Selected 3&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Selected other&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比<code>if ... else if</code>语句，对于多个<code>==</code>判断的情况，使用<code>switch</code>结构更加清晰。</p><p>同时注意，上述“翻译”只有在<code>switch</code>语句中对每个<code>case</code>正确编写了<code>break</code>语句才能对应得上。</p><p>使用<code>switch</code>时，注意<code>case</code>语句并没有花括号<code>&#123;&#125;</code>，而且，<code>case</code>语句具有“<em>穿透性</em>”，漏写<code>break</code>将导致意想不到的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">option</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected 1&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected 2&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected 3&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected other&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>option = 2</code>时，将依次输出<code>&quot;Selected 2&quot;</code>、<code>&quot;Selected 3&quot;</code>、<code>&quot;Selected other&quot;</code>，原因是从匹配到<code>case 2</code>开始，后续语句将全部执行，直到遇到<code>break</code>语句。因此，任何时候都不要忘记写<code>break</code>。</p><p>如果有几个<code>case</code>语句执行的是同一组语句块，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">option</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected 1&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected 2, 3&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected other&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>switch</code>语句时，只要保证有<code>break</code>，<code>case</code>的顺序不影响程序逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (option) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是仍然建议按照自然顺序排列，便于阅读。</p><p><code>switch</code>语句还可以匹配字符串。字符串匹配时，是比较“内容相等”。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected apple&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;pear&quot;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected pear&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;mango&quot;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected mango&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;No fruit selected&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch</code>语句还可以使用枚举类型，枚举类型我们在后面讲解。</p><h3 id="编译检查">编译检查</h3><p>使用IDE时，可以自动检查是否漏写了<code>break</code>语句和<code>default</code>语句，方法是打开IDE的编译检查。</p><p>在Eclipse中，选择<code>Preferences</code> - <code>Java</code> - <code>Compiler</code> - <code>Errors/Warnings</code> - <code>Potential programming problems</code>，将以下检查标记为Warning：</p><ul><li>‘switch’ is missing ‘default’ case：缺少<code>default</code>语句时警告；</li><li>‘switch’ case fall-through：某个<code>case</code>缺少<code>break</code>时警告。</li></ul><p>在Idea中，选择<code>Preferences</code> - <code>Editor</code> - <code>Inspections</code> - <code>Java</code> - <code>Control flow issues</code>，将以下检查标记为Warning：</p><ul><li>‘switch’ statement without ‘default’ branch：缺少<code>default</code>语句时警告；</li><li>Fallthrough in ‘switch’ statement：某个<code>case</code>缺少<code>break</code>时警告。</li></ul><p>当<code>switch</code>语句存在问题时，即可在IDE中获得警告提示。</p><p><img src="https://liaoxuefeng.com/books/java/quick-start/flow/switch/switch-note.jpg" alt="switch-note"></p><h3 id="switch表达式">switch表达式</h3><p>使用<code>switch</code>时，如果遗漏了<code>break</code>，就会造成严重的逻辑错误，而且不易在源代码中发现错误。从Java 12开始，<code>switch</code>语句升级为更简洁的表达式语法，使用类似模式匹配（Pattern Matching）的方法，保证只有一种路径会被执行，并且不需要<code>break</code>语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span> -&gt; System.out.println(<span class="string">&quot;Selected apple&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;pear&quot;</span> -&gt; System.out.println(<span class="string">&quot;Selected pear&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;mango&quot;</span> -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected mango&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Good choice!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;No fruit selected&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意新语法使用<code>-&gt;</code>，如果有多条语句，需要用<code>&#123;&#125;</code>括起来。不要写<code>break</code>语句，因为新语法只会执行匹配的语句，<em>没有</em>穿透效应。</p><p>很多时候，我们还可能用<code>switch</code>语句给某个变量赋值。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> opt;</span><br><span class="line"><span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;apple&quot;</span>:</span><br><span class="line">    opt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;pear&quot;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;mango&quot;</span>:</span><br><span class="line">    opt = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    opt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用新的<code>switch</code>语法，不但不需要<code>break</code>，还可以直接返回值。把上面的代码改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span> -&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;mango&quot;</span> -&gt; <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; <span class="number">0</span>;</span><br><span class="line">        &#125;; <span class="comment">// 注意赋值语句要以;结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;opt = &quot;</span> + opt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以获得更简洁的代码。</p><h3 id="yield">yield</h3><p>大多数时候，在<code>switch</code>表达式内部，我们会返回简单的值。</p><p>但是，如果需要复杂的语句，我们也可以写很多语句，放到<code>&#123;...&#125;</code>里，然后，用<code>yield</code>返回一个值作为<code>switch</code>语句的返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// yield</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="string">&quot;orange&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span> -&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;mango&quot;</span> -&gt; <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> fruit.hashCode();</span><br><span class="line">                <span class="keyword">yield</span> code; <span class="comment">// switch语句返回值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;opt = &quot;</span> + opt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习-7">练习</h3><p>使用<code>switch</code>实现一个简单的石头、剪子、布游戏。</p><p><a href="https://liaoxuefeng.com/books/java/quick-start/flow/switch/flow-switch.zip">下载练习</a></p><h3 id="小结-10">小结</h3><p><code>switch</code>语句可以做多重选择，然后执行匹配的<code>case</code>语句后续代码；</p><p><code>switch</code>的计算结果必须是整型、字符串或枚举类型；</p><p>注意千万不要漏写<code>break</code>，建议打开<code>fall-through</code>警告；</p><p>总是写上<code>default</code>，建议打开<code>missing default</code>警告；</p><p>从Java 14开始，<code>switch</code>语句正式升级为表达式，不再需要<code>break</code>，并且允许使用<code>yield</code>返回值。</p><h2 id="while循环">while循环</h2><p>循环语句就是让计算机根据条件做循环计算，在条件满足时继续循环，条件不满足时退出循环。</p><p>例如，计算从1到100的和：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 + 3 + 4 + … + 100 = ?</span><br></pre></td></tr></table></figure><p>除了用数列公式外，完全可以让计算机做100次循环累加。因为计算机的特点是计算速度非常快，我们让计算机循环一亿次也用不到1秒，所以很多计算的任务，人去算是算不了的，但是计算机算，使用循环这种简单粗暴的方法就可以快速得到结果。</p><p>我们先看Java提供的<code>while</code>条件循环。它的基本用法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件表达式) &#123;</span><br><span class="line">    循环语句</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继续执行后续代码</span></span><br></pre></td></tr></table></figure><p><code>while</code>循环在每次循环开始前，首先判断条件是否成立。如果计算结果为<code>true</code>，就把循环体内的语句执行一遍，如果计算结果为<code>false</code>，那就直接跳到<code>while</code>循环的末尾，继续往下执行。</p><p>我们用while循环来累加1到100，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// while</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 累加的和，初始化为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &lt;= <span class="number">100</span>) &#123; <span class="comment">// 循环条件是n &lt;= 100</span></span><br><span class="line">            sum = sum + n; <span class="comment">// 把n累加到sum中</span></span><br><span class="line">            n ++; <span class="comment">// n自身加1</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum); <span class="comment">// 5050</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>while</code>循环是先判断循环条件，再循环，因此，有可能一次循环都不做。</p><p>对于循环条件判断，以及自增变量的处理，要特别注意边界条件。思考一下下面的代码为何没有获得正确结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// while</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            sum = sum + n;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果循环条件永远满足，那这个循环就变成了死循环。死循环将导致100%的CPU占用，用户会感觉电脑运行缓慢，所以要避免编写死循环代码。</p><p>如果循环条件的逻辑写得有问题，也会造成意料之外的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// while</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = sum + n;</span><br><span class="line">            n ++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(n); <span class="comment">// -2147483648</span></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表面上看，上面的<code>while</code>循环是一个死循环，但是，Java的<code>int</code>类型有最大值，达到最大值后，再加1会变成负数，结果，意外退出了<code>while</code>循环。</p><h3 id="练习-8">练习</h3><p>使用<code>while</code>计算从<code>m</code>到<code>n</code>的和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// while</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 使用while计算M+...+N:</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/quick-start/flow/while/flow-while.zip">下载练习</a></p><h3 id="小结-11">小结</h3><p><code>while</code>循环先判断循环条件是否满足，再执行循环语句；</p><p><code>while</code>循环可能一次都不执行；</p><p>编写循环时要注意循环条件，并避免死循环。</p><hr><hr><p>在Java中，<code>while</code>循环是先判断循环条件，再执行循环。而另一种<code>do while</code>循环则是先执行循环，再判断条件，条件满足时继续循环，条件不满足时退出。它的用法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    执行循环语句</span><br><span class="line">&#125; <span class="keyword">while</span> (条件表达式);</span><br></pre></td></tr></table></figure><p>可见，<code>do while</code>循环会至少循环一次。</p><p>我们把对1到100的求和用<code>do while</code>循环改写一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// do-while</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            sum = sum + n;</span><br><span class="line">            n ++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (n &lt;= <span class="number">100</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>do while</code>循环时，同样要注意循环条件的判断。</p><h3 id="练习-9">练习</h3><p>使用<code>do while</code>循环计算从<code>m</code>到<code>n</code>的和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// do while</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 使用do while计算M+...+N:</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/quick-start/flow/do-while/flow-do-while.zip">下载练习</a></p><h3 id="小结-12">小结</h3><p><code>do while</code>先执行循环，再判断条件；</p><p><code>do while</code>循环会至少执行一次。</p><p>除了<code>while</code>和<code>do while</code>循环，Java使用最广泛的是<code>for</code>循环。</p><p><code>for</code>循环的功能非常强大，它使用计数器实现循环。<code>for</code>循环会先初始化计数器，然后，在每次循环前检测循环条件，在每次循环后更新计数器。计数器变量通常命名为<code>i</code>。</p><p>我们把1到100求和用<code>for</code>循环改写一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>for</code>循环执行前，会先执行初始化语句<code>int i=1</code>，它定义了计数器变量<code>i</code>并赋初始值为<code>1</code>，然后，循环前先检查循环条件<code>i&lt;=100</code>，循环后自动执行<code>i++</code>，因此，和<code>while</code>循环相比，<code>for</code>循环把更新计数器的代码统一放到了一起。在<code>for</code>循环的循环体内部，不需要去更新变量<code>i</code>。</p><p>因此，<code>for</code>循环的用法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始条件; 循环检测条件; 循环后更新计数器) &#123;</span><br><span class="line">    <span class="comment">// 执行语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们要对一个整型数组的所有元素求和，可以用<code>for</code>循环实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ns.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, ns[i] = &quot;</span> + ns[i]);</span><br><span class="line">            sum = sum + ns[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sum = &quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的循环条件是<code>i&lt;ns.length</code>。因为<code>ns</code>数组的长度是<code>5</code>，因此，当循环<code>5</code>次后，<code>i</code>的值被更新为<code>5</code>，就不满足循环条件，因此<code>for</code>循环结束。</p><p>思考</p><p>如果把循环条件改为i&lt;=ns.length，会出现什么问题？</p><p>注意<code>for</code>循环的初始化计数器总是会被执行，并且<code>for</code>循环也可能循环0次。</p><p>使用<code>for</code>循环时，千万不要在循环体内修改计数器！在循环体中修改计数器常常导致莫名其妙的逻辑错误。对于下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ns.length; i++) &#123;</span><br><span class="line">            System.out.println(ns[i]);</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然不会报错，但是，数组元素只打印了一半，原因是循环内部的<code>i = i + 1</code>导致了计数器变量每次循环实际上加了<code>2</code>（因为<code>for</code>循环还会自动执行<code>i++</code>）。因此，在<code>for</code>循环中，不要修改计数器的值。计数器的初始化、判断条件、每次循环后的更新条件统一放到<code>for()</code>语句中可以一目了然。</p><p>如果希望只访问索引号为偶数的数组元素，应该把<code>for</code>循环改写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ns.length; i=i+<span class="number">2</span>) &#123;</span><br><span class="line">    System.out.println(ns[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过更新计数器的语句<code>i=i+2</code>就达到了这个效果，从而避免了在循环体内去修改变量<code>i</code>。</p><p>使用<code>for</code>循环时，计数器变量<code>i</code>要尽量定义在<code>for</code>循环中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ns.length; i++) &#123;</span><br><span class="line">    System.out.println(ns[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无法访问i</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i; <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>如果变量<code>i</code>定义在<code>for</code>循环外：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;ns.length; i++) &#123;</span><br><span class="line">    System.out.println(ns[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 仍然可以使用i</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;</span><br></pre></td></tr></table></figure><p>那么，退出<code>for</code>循环后，变量<code>i</code>仍然可以被访问，这就破坏了变量应该把访问范围缩到最小的原则。</p><h3 id="灵活使用for循环">灵活使用for循环</h3><p><code>for</code>循环还可以缺少初始化语句、循环条件和每次循环更新语句，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不设置结束条件:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; ; i++) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不设置结束条件和更新语句:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; ;) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 什么都不设置:</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常不推荐这样写，但是，某些情况下，是可以省略<code>for</code>循环的某些语句的。</p><h3 id="for-each循环">for each循环</h3><p><code>for</code>循环经常用来遍历数组，因为通过计数器可以根据索引来访问数组的每个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ns.length; i++) &#123;</span><br><span class="line">    System.out.println(ns[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，很多时候，我们实际上真正想要访问的是数组每个元素的值。Java还提供了另一种<code>for each</code>循环，它可以更简单地遍历数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for each</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : ns) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和<code>for</code>循环相比，<code>for each</code>循环的变量n不再是计数器，而是直接对应到数组的每个元素。<code>for each</code>循环的写法也更简洁。但是，<code>for each</code>循环无法指定遍历顺序，也无法获取数组的索引。</p><p>除了数组外，<code>for each</code>循环能够遍历所有“可迭代”的数据类型，包括后面会介绍的<code>List</code>、<code>Map</code>等。</p><h3 id="练习1">练习1</h3><p>给定一个数组，请用<code>for</code>循环倒序输出每一个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=?; ???; ???) &#123;</span><br><span class="line">            System.out.println(ns[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习2">练习2</h3><p>利用<code>for each</code>循环对数组每个元素求和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for each</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (???) &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum); <span class="comment">// 55</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习3">练习3</h3><p>圆周率π可以使用公式计算：</p><p>请利用<code>for</code>循环计算π：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (???) &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(pi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/quick-start/flow/for/flow-for.zip">下载练习</a></p><h3 id="小结-13">小结</h3><p><code>for</code>循环通过计数器可以实现复杂循环；</p><p><code>for each</code>循环可以直接遍历数组的每个元素；</p><p>最佳实践：计数器变量定义在<code>for</code>循环内部，循环体内部不修改计数器；</p><h2 id="break和continue">break和continue</h2><p>无论是<code>while</code>循环还是<code>for</code>循环，有两个特别的语句可以使用，就是<code>break</code>语句和<code>continue</code>语句。</p><h3 id="break">break</h3><p>在循环过程中，可以使用<code>break</code>语句跳出当前循环。我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// break</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; ; i++) &#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>for</code>循环计算从1到100时，我们并没有在<code>for()</code>中设置循环退出的检测条件。但是，在循环内部，我们用<code>if</code>判断，如果<code>i==100</code>，就通过<code>break</code>退出循环。</p><p>因此，<code>break</code>语句通常都是配合<code>if</code>语句使用。要特别注意，<code>break</code>语句总是跳出自己所在的那一层循环。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// break</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=<span class="number">10</span>; j++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;j = &quot;</span> + j);</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= i) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// break跳到这里</span></span><br><span class="line">            System.out.println(<span class="string">&quot;breaked&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是两个<code>for</code>循环嵌套。因为<code>break</code>语句位于内层的<code>for</code>循环，因此，它会跳出内层<code>for</code>循环，但不会跳出外层<code>for</code>循环。</p><h3 id="continue">continue</h3><p><code>break</code>会跳出当前循环，也就是整个循环都不会执行了。而<code>continue</code>则是提前结束本次循环，直接继续执行下次循环。我们看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// continue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;begin i = &quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// continue语句会结束本次循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">            System.out.println(<span class="string">&quot;end i = &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum); <span class="comment">// 25</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意观察<code>continue</code>语句的效果。当<code>i</code>为奇数时，完整地执行了整个循环，因此，会打印<code>begin i=1</code>和<code>end i=1</code>。在i为偶数时，<code>continue</code>语句会提前结束本次循环，因此，会打印<code>begin i=2</code>但不会打印<code>end i=2</code>。</p><p>在多层嵌套的循环中，<code>continue</code>语句同样是结束本次自己所在的循环。</p><h3 id="小结-14">小结</h3><p><code>break</code>语句可以跳出当前循环；</p><p><code>break</code>语句通常配合<code>if</code>，在满足条件时提前结束整个循环；</p><p><code>break</code>语句总是跳出最近的一层循环；</p><p><code>continue</code>语句可以提前结束本次循环；</p><p><code>continue</code>语句通常配合<code>if</code>，在满足条件时提前结束本次循环。</p><hr><hr><p>我们在Java程序基础里介绍了数组这种数据类型。有了数组，我们还需要来操作它。而数组最常见的一个操作就是遍历。</p><p>通过<code>for</code>循环就可以遍历数组。因为数组的每个元素都可以通过索引来访问，因此，使用标准的<code>for</code>循环可以完成一个数组的遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ns.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ns[i];</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了实现<code>for</code>循环遍历，初始条件为<code>i=0</code>，因为索引总是从<code>0</code>开始，继续循环的条件为<code>i&lt;ns.length</code>，因为当<code>i=ns.length</code>时，<code>i</code>已经超出了索引范围（索引范围是<code>0</code> ~ <code>ns.length-1</code>），每次循环后，<code>i++</code>。</p><p>第二种方式是使用<code>for each</code>循环，直接迭代数组的每个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : ns) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：在<code>for (int n : ns)</code>循环中，变量<code>n</code>直接拿到<code>ns</code>数组的元素，而不是索引。</p><p>显然<code>for each</code>循环更加简洁。但是，<code>for each</code>循环无法拿到数组的索引，因此，到底用哪一种<code>for</code>循环，取决于我们的需要。</p><h3 id="打印数组内容">打印数组内容</h3><p>直接打印数组变量，得到的是数组在JVM中的引用地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">System.out.println(ns); <span class="comment">// 类似 [I@7852e922</span></span><br></pre></td></tr></table></figure><p>这并没有什么意义，因为我们希望打印的数组的元素内容。因此，使用<code>for each</code>循环来打印它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : ns) &#123;</span><br><span class="line">    System.out.print(n + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>for each</code>循环打印也很麻烦。幸好Java标准库提供了<code>Arrays.toString()</code>，可以快速打印数组内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习-10">练习</h3><p>请按倒序遍历数组并打印每个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line">        <span class="comment">// 倒序打印数组元素:</span></span><br><span class="line">        <span class="keyword">for</span> (???) &#123;</span><br><span class="line">            System.out.println(???);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/quick-start/array-op/loop/array-loop.zip">下载练习</a></p><h3 id="小结-15">小结</h3><p>遍历数组可以使用<code>for</code>循环，<code>for</code>循环可以访问数组索引，<code>for each</code>循环直接迭代每个数组元素，但无法获取索引；</p><p>使用<code>Arrays.toString()</code>可以快速获取数组内容。</p><p>对数组进行排序是程序中非常基本的需求。常用的排序算法有冒泡排序、插入排序和快速排序等。</p><p>我们来看一下如何使用冒泡排序算法对一个整型数组从小到大进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">28</span>, <span class="number">12</span>, <span class="number">89</span>, <span class="number">73</span>, <span class="number">65</span>, <span class="number">18</span>, <span class="number">96</span>, <span class="number">50</span>, <span class="number">8</span>, <span class="number">36</span> &#125;;</span><br><span class="line">        <span class="comment">// 排序前:</span></span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ns.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; ns.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ns[j] &gt; ns[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 交换ns[j]和ns[j+1]:</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ns[j];</span><br><span class="line">                    ns[j] = ns[j+<span class="number">1</span>];</span><br><span class="line">                    ns[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序后:</span></span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序的特点是，每一轮循环后，最大的一个数被交换到末尾，因此，下一轮循环就可以“刨除”最后的数，每一轮循环都比上一轮循环的结束位置靠前一位。</p><p>另外，注意到交换两个变量的值必须借助一个临时变量。像这么写是错误的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// x现在是2</span></span><br><span class="line">y = x; <span class="comment">// y现在还是2</span></span><br></pre></td></tr></table></figure><p>正确的写法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> x; <span class="comment">// 把x的值保存在临时变量t中, t现在是1</span></span><br><span class="line">x = y; <span class="comment">// x现在是2</span></span><br><span class="line">y = t; <span class="comment">// y现在是t的值1</span></span><br></pre></td></tr></table></figure><p>实际上，Java的标准库已经内置了排序功能，我们只需要调用JDK提供的<code>Arrays.sort()</code>就可以排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">28</span>, <span class="number">12</span>, <span class="number">89</span>, <span class="number">73</span>, <span class="number">65</span>, <span class="number">18</span>, <span class="number">96</span>, <span class="number">50</span>, <span class="number">8</span>, <span class="number">36</span> &#125;;</span><br><span class="line">        Arrays.sort(ns);</span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须注意，对数组排序实际上修改了数组本身。例如，排序前的数组是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ns = &#123; <span class="number">9</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure><p>在内存中，这个整型数组表示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      ┌───┬───┬───┬───┐</span><br><span class="line">ns───▶│ 9 │ 3 │ 6 │ 5 │</span><br><span class="line">      └───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>当我们调用<code>Arrays.sort(ns);</code>后，这个整型数组在内存中变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      ┌───┬───┬───┬───┐</span><br><span class="line">ns───▶│ 3 │ 5 │ 6 │ 9 │</span><br><span class="line">      └───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>即变量<code>ns</code>指向的数组内容已经被改变了。</p><p>如果对一个字符串数组进行排序，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] ns = &#123; <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>排序前，这个数组在内存中表示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                   ┌──────────────────────────────────┐</span><br><span class="line">               ┌───┼──────────────────────┐           │</span><br><span class="line">               │   │                      ▼           ▼</span><br><span class="line">         ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐</span><br><span class="line">ns ─────▶│░░░│░░░│░░░│   │&quot;banana&quot;│   │&quot;apple&quot;│   │&quot;pear&quot;│   │</span><br><span class="line">         └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘</span><br><span class="line">           │                 ▲</span><br><span class="line">           └─────────────────┘</span><br></pre></td></tr></table></figure><p>调用<code>Arrays.sort(ns);</code>排序后，这个数组在内存中表示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                   ┌──────────────────────────────────┐</span><br><span class="line">               ┌───┼──────────┐                       │</span><br><span class="line">               │   │          ▼                       ▼</span><br><span class="line">         ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐</span><br><span class="line">ns ─────▶│░░░│░░░│░░░│   │&quot;banana&quot;│   │&quot;apple&quot;│   │&quot;pear&quot;│   │</span><br><span class="line">         └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘</span><br><span class="line">           │                              ▲</span><br><span class="line">           └──────────────────────────────┘</span><br></pre></td></tr></table></figure><p>原来的3个字符串在内存中均没有任何变化，但是<code>ns</code>数组的每个元素指向变化了。</p><h3 id="练习-11">练习</h3><p>请思考如何实现对数组进行降序排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 降序排序</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">28</span>, <span class="number">12</span>, <span class="number">89</span>, <span class="number">73</span>, <span class="number">65</span>, <span class="number">18</span>, <span class="number">96</span>, <span class="number">50</span>, <span class="number">8</span>, <span class="number">36</span> &#125;;</span><br><span class="line">        <span class="comment">// 排序前:</span></span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="comment">// 排序后:</span></span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">        <span class="keyword">if</span> (Arrays.toString(ns).equals(<span class="string">&quot;[96, 89, 73, 65, 50, 36, 28, 18, 12, 8]&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;测试成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;测试失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/quick-start/array-op/sort/array-sort.zip">下载练习</a></p><h3 id="小结-16">小结</h3><p>常用的排序算法有冒泡排序、插入排序和快速排序等；</p><p>冒泡排序使用两层<code>for</code>循环实现排序；</p><p>交换两个变量的值需要借助一个临时变量；</p><p>可以直接使用Java标准库提供的<code>Arrays.sort()</code>进行排序；</p><p>对数组排序会直接修改数组本身。</p><h3 id="二维数组">二维数组</h3><p>二维数组就是数组的数组。定义一个二维数组如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] ns = &#123;</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">            &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">            &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(ns.length); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>ns</code>包含3个数组，因此，<code>ns.length</code>为<code>3</code>。实际上<code>ns</code>在内存中的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                    ┌───┬───┬───┬───┐</span><br><span class="line">         ┌───┐  ┌──▶│ 1 │ 2 │ 3 │ 4 │</span><br><span class="line">ns ─────▶│░░░│──┘   └───┴───┴───┴───┘</span><br><span class="line">         ├───┤      ┌───┬───┬───┬───┐</span><br><span class="line">         │░░░│─────▶│ 5 │ 6 │ 7 │ 8 │</span><br><span class="line">         ├───┤      └───┴───┴───┴───┘</span><br><span class="line">         │░░░│──┐   ┌───┬───┬───┬───┐</span><br><span class="line">         └───┘  └──▶│ 9 │10 │11 │12 │</span><br><span class="line">                    └───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>如果我们定义一个普通数组<code>arr0</code>，然后把<code>ns[0]</code>赋值给它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] ns = &#123;</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">            &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">            &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span>[] arr0 = ns[<span class="number">0</span>];</span><br><span class="line">        System.out.println(arr0.length); <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上<code>arr0</code>就获取了<code>ns</code>数组的第0个元素。因为<code>ns</code>数组的每个元素也是一个数组，因此，<code>arr0</code>指向的数组就是<code>&#123; 1, 2, 3, 4 &#125;</code>。在内存中，结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">            arr0 ─────┐</span><br><span class="line">                      ▼</span><br><span class="line">                    ┌───┬───┬───┬───┐</span><br><span class="line">         ┌───┐  ┌──▶│ 1 │ 2 │ 3 │ 4 │</span><br><span class="line">ns ─────▶│░░░│──┘   └───┴───┴───┴───┘</span><br><span class="line">         ├───┤      ┌───┬───┬───┬───┐</span><br><span class="line">         │░░░│─────▶│ 5 │ 6 │ 7 │ 8 │</span><br><span class="line">         ├───┤      └───┴───┴───┴───┘</span><br><span class="line">         │░░░│──┐   ┌───┬───┬───┬───┐</span><br><span class="line">         └───┘  └──▶│ 9 │10 │11 │12 │</span><br><span class="line">                    └───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>访问二维数组的某个元素需要使用<code>array[row][col]</code>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ns[<span class="number">1</span>][<span class="number">2</span>]); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>二维数组的每个数组元素的长度并不要求相同，例如，可以这么定义<code>ns</code>数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] ns = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">    &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个二维数组在内存中的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                    ┌───┬───┬───┬───┐</span><br><span class="line">         ┌───┐  ┌──▶│ 1 │ 2 │ 3 │ 4 │</span><br><span class="line">ns ─────▶│░░░│──┘   └───┴───┴───┴───┘</span><br><span class="line">         ├───┤      ┌───┬───┐</span><br><span class="line">         │░░░│─────▶│ 5 │ 6 │</span><br><span class="line">         ├───┤      └───┴───┘</span><br><span class="line">         │░░░│──┐   ┌───┬───┬───┐</span><br><span class="line">         └───┘  └──▶│ 7 │ 8 │ 9 │</span><br><span class="line">                    └───┴───┴───┘</span><br></pre></td></tr></table></figure><p>要打印一个二维数组，可以使用两层嵌套的for循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] arr : ns) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">        System.out.print(n);</span><br><span class="line">        System.out.print(<span class="string">&#x27;, &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用Java标准库的<code>Arrays.deepToString()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] ns = &#123;</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">            &#123; <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">            &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(Arrays.deepToString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三维数组">三维数组</h3><p>三维数组就是二维数组的数组。可以这么定义一个三维数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][][] ns = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="number">10</span>, <span class="number">11</span>&#125;,</span><br><span class="line">        &#123;<span class="number">12</span>, <span class="number">13</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>&#125;,</span><br><span class="line">        &#123;<span class="number">17</span>, <span class="number">18</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它在内存中的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">                              ┌───┬───┬───┐</span><br><span class="line">                   ┌───┐  ┌──▶│ 1 │ 2 │ 3 │</span><br><span class="line">               ┌──▶│░░░│──┘   └───┴───┴───┘</span><br><span class="line">               │   ├───┤      ┌───┬───┬───┐</span><br><span class="line">               │   │░░░│─────▶│ 4 │ 5 │ 6 │</span><br><span class="line">               │   ├───┤      └───┴───┴───┘</span><br><span class="line">               │   │░░░│──┐   ┌───┬───┬───┐</span><br><span class="line">        ┌───┐  │   └───┘  └──▶│ 7 │ 8 │ 9 │</span><br><span class="line">ns ────▶│░░░│──┘              └───┴───┴───┘</span><br><span class="line">        ├───┤      ┌───┐      ┌───┬───┐</span><br><span class="line">        │░░░│─────▶│░░░│─────▶│10 │11 │</span><br><span class="line">        ├───┤      ├───┤      └───┴───┘</span><br><span class="line">        │░░░│──┐   │░░░│──┐   ┌───┬───┐</span><br><span class="line">        └───┘  │   └───┘  └──▶│12 │13 │</span><br><span class="line">               │              └───┴───┘</span><br><span class="line">               │   ┌───┐      ┌───┬───┬───┐</span><br><span class="line">               └──▶│░░░│─────▶│14 │15 │16 │</span><br><span class="line">                   ├───┤      └───┴───┴───┘</span><br><span class="line">                   │░░░│──┐   ┌───┬───┐</span><br><span class="line">                   └───┘  └──▶│17 │18 │</span><br><span class="line">                              └───┴───┘</span><br></pre></td></tr></table></figure><p>如果我们要访问三维数组的某个元素，例如，<code>ns[2][0][1]</code>，只需要顺着定位找到对应的最终元素<code>15</code>即可。</p><p>理论上，我们可以定义任意的N维数组。但在实际应用中，除了二维数组在某些时候还能用得上，更高维度的数组很少使用。</p><h3 id="练习-12">练习</h3><p>使用二维数组可以表示一组学生的各科成绩，请计算所有学生的平均分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 用二维数组表示的学生成绩:</span></span><br><span class="line">        <span class="type">int</span>[][] scores = &#123;</span><br><span class="line">                &#123; <span class="number">82</span>, <span class="number">90</span>, <span class="number">91</span> &#125;, <span class="comment">// 学生甲的语数英成绩</span></span><br><span class="line">                &#123; <span class="number">68</span>, <span class="number">72</span>, <span class="number">64</span> &#125;, <span class="comment">// 学生乙的语数英成绩</span></span><br><span class="line">                &#123; <span class="number">95</span>, <span class="number">91</span>, <span class="number">89</span> &#125;, <span class="comment">// ...</span></span><br><span class="line">                &#123; <span class="number">67</span>, <span class="number">52</span>, <span class="number">60</span> &#125;,</span><br><span class="line">                &#123; <span class="number">79</span>, <span class="number">81</span>, <span class="number">85</span> &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="type">double</span> <span class="variable">average</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        System.out.println(average);</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(average - <span class="number">77.733333</span>) &lt; <span class="number">0.000001</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;测试成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;测试失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://liaoxuefeng.com/books/java/quick-start/array-op/multi-dim/array-average.zip">下载练习</a></p><h3 id="小结-17">小结</h3><p>二维数组就是数组的数组，三维数组就是二维数组的数组；</p><p>多维数组的每个数组元素长度都不要求相同；</p><p>打印多维数组可以使用<code>Arrays.deepToString()</code>；</p><p>最常见的多维数组是二维数组，访问二维数组的一个元素使用<code>array[row][col]</code>。</p><p>Java程序的入口是<code>main</code>方法，而<code>main</code>方法可以接受一个命令行参数，它是一个<code>String[]</code>数组。</p><p>这个命令行参数由JVM接收用户输入并传给<code>main</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">            System.out.println(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以利用接收到的命令行参数，根据不同的参数执行不同的代码。例如，实现一个<code>-version</code>参数，打印程序版本号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;-version&quot;</span>.equals(arg)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;v 1.0&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个程序必须在命令行执行，我们先编译它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javac Main.java</span><br></pre></td></tr></table></figure><p>然后，执行的时候，给它传递一个<code>-version</code>参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java Main -version</span><br><span class="line">v 1.0</span><br></pre></td></tr></table></figure><p>这样，程序就可以根据传入的命令行参数，作出不同的响应。</p><h3 id="小结-18">小结</h3><p>命令行参数类型是<code>String[]</code>数组；</p><p>命令行参数由JVM接收用户输入并传给<code>main</code>方法；</p><p>如何解析命令行参数需要由程序自己实现。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程的核心思想</title>
      <link href="/2025/05/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/"/>
      <url>/2025/05/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>函数式编程最近几年越炒越热，有函数式编程的语言鄙视没有函数式编程的语言，纯函数式编程的语言鄙视不纯的函数式编程的语言。</p><p>那么，到底什么是函数式编程，函数式编程的核心思想又是什么？</p><p>函数式编程的第一个特点就是可以把函数作为参数传递给另一个函数，也就是所谓的高阶函数。例如，对数组进行排序，可以传入一个排序函数作为参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123; <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Apple&quot;</span> &#125;;</span><br><span class="line">Arrays.sort(array, String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure><p>函数式编程的第二个特点就是可以返回一个函数，这样就可以实现闭包或者惰性计算：</p><p>以上两个特点还仅仅是简化了代码。从代码的可维护性上讲，函数式编程最大的好处是引用透明，即函数运行的结果只依赖于输入的参数，而不依赖于外部状态，因此，我们常常说函数式编程没有副作用。</p><p>没有副作用有个巨大的好处，就是函数内部无状态，即输入确定，输出就是确定的，容易测试和维护。</p><p>很多初学者容易纠结“纯”函数式语言，认为只有Haskell这种消除了变量和副作用的语言才是正宗的函数式编程。还有人甚至认为纯函数不能有任何IO操作，包括打行日志都不行。</p><p>其实这种纠结是没有意义的，因为计算机底层就是一个完全可变的内存和不可预测输入的系统，追求完美的无副作用是不现实的，我们只需要理解函数式编程的思想，把业务逻辑做到“无副作用”，至于有变量、打日志、读缓存这些无关紧要的“副作用”，根本不用担心，不需要解决，也几乎没法解决。</p><p>我们来举个栗子。</p><p>比如一个财务软件，需要一个函数专门计算个人所得税，输入是一个<code>IncomeRecord</code>，输出是个税金额：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">calculateIncomeTax</span><span class="params">(IncomeRecord record)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又假设<code>IncomeRecord</code>长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncomeRecord</span> &#123;</span><br><span class="line">    String id; <span class="comment">// 身份证号</span></span><br><span class="line">    String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="type">double</span> salary; <span class="comment">// 工资</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先不考虑五险一金这些乱七八糟的东西，我们只关注如何计算个税。为了简化，我们假设直接扣除一个免征额后按20%计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">calculateIncomeTax</span><span class="params">(IncomeRecord record)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">3500</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">tax</span> <span class="operator">=</span> record.salary &lt;= threshold ? <span class="number">0</span> : (record.salary - threshold) * <span class="number">0.2</span>;</span><br><span class="line">    <span class="keyword">return</span> tax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个程序在2018年9月1号前是没问题的，问题是2018年9月1号后起征点调整到了5000，那2018年8月和2018年9月，计算结果应该不一样。怎么改？</p><p>普通开发者的改法：那还不简单？直接获取当前日期，返回正确的起征点就行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">calculateIncomeTax</span><span class="params">(IncomeRecord record)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">threshold</span> <span class="operator">=</span> today() &lt; date(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">1</span>) ? <span class="number">3500</span> : <span class="number">5000</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">tax</span> <span class="operator">=</span> record.salary &lt;= threshold ? <span class="number">0</span> : (record.salary - threshold) * <span class="number">0.2</span>;</span><br><span class="line">    <span class="keyword">return</span> tax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序是没错，问题是：</p><p>同样的输入，8月31号跑，和9月1号跑，结果不一样，难道会计要在9月1号做8月份的工资条，必须把电脑的时间先调到8月份？</p><p>用函数式编程的观点思考一下，就发现问题所在：</p><p><code>today()</code>这个函数，返回结果与时间有关，这就造成了<code>calculateIncomeTax()</code>不再是一个纯函数，它与当前时间相关了。</p><p>那怎么把<code>calculateIncomeTax()</code>恢复成一个纯函数，同时要支持起征点调整？</p><p>方法是把时间相关的变量作为参数传进来，例如，给<code>IncomeRecord</code>增加几个字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncomeRecord</span> &#123;</span><br><span class="line">    String id; <span class="comment">// 身份证号</span></span><br><span class="line">    String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="type">double</span> salary; <span class="comment">// 工资</span></span><br><span class="line">    <span class="type">int</span> year; <span class="comment">// 年</span></span><br><span class="line">    <span class="type">int</span> month; <span class="comment">// 月</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以消除<code>today()</code>的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">calculateIncomeTax</span><span class="params">(IncomeRecord record)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">threshold</span> <span class="operator">=</span> date(record.year, record.month) &lt; date(<span class="number">2018</span>, <span class="number">9</span>) ? <span class="number">3500</span> : <span class="number">5000</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">tax</span> <span class="operator">=</span> record.salary &lt;= threshold ? <span class="number">0</span> : (record.salary - threshold) * <span class="number">0.2</span>;</span><br><span class="line">    <span class="keyword">return</span> tax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>calculateIncomeTax()</code>又变成了一个纯函数，会计就不用改电脑时间了。</p><p>是不是觉得这个例子太简单了？其实简单的函数如果都能写成有状态的，那么复杂的业务逻辑必然写成一锅粥。</p><p>举个复杂的栗子：</p><p>对于一个股票交易系统，如果我们把输入定义为：开盘前所有股民的现金和持股，以及交易时段的所有订单，那么，输出就是收盘后所有股民的现金和持股：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StockStatus <span class="title function_">process</span><span class="params">(StockStatus old, List&lt;Order&gt; orders)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (Order order : orders) &#123;</span><br><span class="line">        ...</span><br><span class="line">        sendExchangeResult(...); <span class="comment">// 给每一笔成交发送信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然这是一个纯函数，虽然在处理过程中，这个函数会给股民朋友发送各种心跳消息。</p><p>如果把交易系统的模型设计成这样一个纯函数，那么理论上我们只需要从股市开市的那一天开始，把所有订单全部处理一遍，就可以正确得到今天收盘后的状态。</p><p>或者说，只要取任意一天开盘前的系统状态的备份（就是整个数据库的备份），把当天的订单重新处理一遍，就得到了当天收盘的状态。这个过程可以做任意次，结果不变，因此，非常适合验证代码的修改是否影响了业务流程。</p><p>那么问题来了，交易系统中有无数和时间相关的状态，怎么处理成纯函数？这个模型的处理，可比计算个税复杂多了。</p><p>这就是函数式编程的精髓：业务系统模型无状态。模型的好坏，直接影响到代码的正确性、可靠性、稳定性，以及是否需要996。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile教程</title>
      <link href="/2025/05/23/makefile%E6%95%99%E7%A8%8B/"/>
      <url>/2025/05/23/makefile%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>Linux的<code>make</code>程序用来自动化编译大型源码，很多时候，我们在Linux下编译安装软件，只需要敲一个<code>make</code>就可以全自动完成，非常方便。</p><p><code>make</code>能自动化完成这些工作，是因为项目提供了一个<code>Makefile</code>文件，它负责告诉<code>make</code>，应该如何编译和链接程序。</p><p><code>Makefile</code>相当于Java项目的<code>pom.xml</code>，Node工程的<code>package.json</code>，Rust项目的<code>Cargo.toml</code>，不同之处在于，<code>make</code>虽然最初是针对C语言开发，但它实际上并不限定C语言，而是可以应用到任意项目，甚至不是编程语言。此外，<code>make</code>主要用于Unix/Linux环境的自动化开发，掌握<code>Makefile</code>的写法，可以更好地在Linux环境下做开发，也可以为后续开发Linux内核做好准备。</p><p>在本教程中，我们将由浅入深，一步一步学习如何编写<code>Makefile</code>，完全针对零基础小白，只需要提前掌握如何使用Linux命令。</p><hr><hr><p>在Linux环境下，当我们输入<code>make</code>命令时，它就在当前目录查找一个名为<code>Makefile</code>的文件，然后，根据这个文件定义的规则，自动化地执行任意命令，包括编译命令。</p><p><code>Makefile</code>这个单词，顾名思义，就是指如何生成文件。</p><p>我们举个例子：在当前目录下，有3个文本文件：<code>a.txt</code>，<code>b.txt</code>和<code>c.txt</code>。</p><p>现在，我们要合并<code>a.txt</code>与<code>b.txt</code>，生成中间文件<code>m.txt</code>，再用中间文件<code>m.txt</code>与<code>c.txt</code>合并，生成最终的目标文件<code>x.txt</code>，整个逻辑如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌─────┐ ┌─────┐ ┌─────┐</span><br><span class="line">│a.txt│ │b.txt│ │c.txt│</span><br><span class="line">└─────┘ └─────┘ └─────┘</span><br><span class="line">   │       │       │</span><br><span class="line">   └───┬───┘       │</span><br><span class="line">       │           │</span><br><span class="line">       ▼           │</span><br><span class="line">    ┌─────┐        │</span><br><span class="line">    │m.txt│        │</span><br><span class="line">    └─────┘        │</span><br><span class="line">       │           │</span><br><span class="line">       └─────┬─────┘</span><br><span class="line">             │</span><br><span class="line">             ▼</span><br><span class="line">          ┌─────┐</span><br><span class="line">          │x.txt│</span><br><span class="line">          └─────┘</span><br></pre></td></tr></table></figure><p>根据上述逻辑，我们来编写<code>Makefile</code>。</p><h3 id="规则">规则</h3><p><code>Makefile</code>由若干条规则（Rule）构成，每一条规则指出一个目标文件（Target），若干依赖文件（prerequisites），以及生成目标文件的命令。</p><p>例如，要生成<code>m.txt</code>，依赖<code>a.txt</code>与<code>b.txt</code>，规则如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 目标文件: 依赖文件1 依赖文件2</span><br><span class="line">m.txt: a.txt b.txt</span><br><span class="line">cat a.txt b.txt &gt; m.txt</span><br></pre></td></tr></table></figure><p>一条规则的格式为<code>目标文件: 依赖文件1 依赖文件2 ...</code>，紧接着，以Tab开头的是命令，用来生成目标文件。上述规则使用<code>cat</code>命令合并了<code>a.txt</code>与<code>b.txt</code>，并写入到<code>m.txt</code>。用什么方式生成目标文件<code>make</code>并不关心，因为命令完全是我们自己写的，可以是编译命令，也可以是<code>cp</code>、<code>mv</code>等任何命令。</p><p>以<code>#</code>开头的是注释，会被<code>make</code>命令忽略。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：Makefile的规则中，命令必须以Tab开头，不能是空格。</span><br></pre></td></tr></table></figure><p>类似的，我们写出生成<code>x.txt</code>的规则如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x.txt: m.txt c.txt</span><br><span class="line">cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure><p>由于<code>make</code>执行时，默认执行第一条规则，所以，我们把规则<code>x.txt</code>放到前面。完整的<code>Makefile</code>如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x.txt: m.txt c.txt</span><br><span class="line">cat m.txt c.txt &gt; x.txt</span><br><span class="line"></span><br><span class="line">m.txt: a.txt b.txt</span><br><span class="line">cat a.txt b.txt &gt; m.txt</span><br></pre></td></tr></table></figure><p>在当前目录创建<code>a.txt</code>、<code>b.txt</code>和<code>c.txt</code>，输入一些内容，执行<code>make</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cat a.txt b.txt &gt; m.txt</span><br><span class="line">cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure><p><code>make</code>默认执行第一条规则，也就是创建<code>x.txt</code>，但是由于<code>x.txt</code>依赖的文件<code>m.txt</code>不存在（另一个依赖<code>c.txt</code>已存在），故需要先执行规则<code>m.txt</code>创建出<code>m.txt</code>文件，再执行规则<code>x.txt</code>。执行完成后，当前目录下生成了两个文件<code>m.txt</code>和<code>x.txt</code>。</p><p>可见，<code>Makefile</code>定义了一系列规则，每个规则在满足依赖文件的前提下执行命令，就能创建出一个目标文件，这就是英文Make file的意思。</p><p>把默认执行的规则放第一条，其他规则的顺序是无关紧要的，因为<code>make</code>执行时自动判断依赖。</p><p>此外，<code>make</code>会打印出执行的每一条命令，便于我们观察执行顺序以便调试。</p><p>如果我们再次运行<code>make</code>，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">make: `x.txt&#x27; is up to date.</span><br></pre></td></tr></table></figure><p><code>make</code>检测到<code>x.txt</code>已经是最新版本，无需再次执行，因为<code>x.txt</code>的创建时间晚于它依赖的<code>m.txt</code>和<code>c.txt</code>的最后修改时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make使用文件的创建和修改时间来判断是否应该更新一个目标文件。</span><br></pre></td></tr></table></figure><p>修改<code>c.txt</code>后，运行<code>make</code>，会触发<code>x.txt</code>的更新：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure><p>但并不会触发<code>m.txt</code>的更新，原因是<code>m.txt</code>的依赖<code>a.txt</code>与<code>b.txt</code>并未更新，所以，<code>make</code>只会根据<code>Makefile</code>去执行那些必要的规则，并不会把所有规则都无脑执行一遍。</p><p>在编译大型程序时，全量编译往往需要几十分钟甚至几个小时。全量编译完成后，如果仅修改了几个文件，再全部重新编译完全没有必要，用<code>Makefile</code>实现增量编译就十分节省时间。</p><p>当然，是否能正确地实现增量更新，取决于我们的规则写得对不对，<code>make</code>本身并不会检查规则逻辑是否正确。</p><h3 id="伪目标">伪目标</h3><p>因为<code>m.txt</code>与<code>x.txt</code>都是自动生成的文件，所以，可以安全地删除。</p><p>删除时，我们也不希望手动删除，而是编写一个<code>clean</code>规则来删除它们：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">rm -f m.txt</span><br><span class="line">rm -f x.txt</span><br></pre></td></tr></table></figure><p><code>clean</code>规则与我们前面编写的规则有所不同，它没有依赖文件，因此，要执行<code>clean</code>，必须用命令<code>make clean</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make clean</span><br><span class="line">rm -f m.txt</span><br><span class="line">rm -f x.txt</span><br></pre></td></tr></table></figure><p>然而，在执行<code>clean</code>时，我们并没有创建一个名为<code>clean</code>的文件，所以，因为目标文件<code>clean</code>不存在，每次运行<code>make clean</code>，都会执行这个规则的命令。</p><p>如果我们手动创建一个<code>clean</code>的文件，这个<code>clean</code>规则就不会执行了！</p><p>如果我们希望<code>make</code>把<code>clean</code>不要视为文件，可以添加一个标识：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f m.txt</span><br><span class="line">rm -f x.txt</span><br></pre></td></tr></table></figure><p>此时，<code>clean</code>就不被视为一个文件，而是伪目标（Phony Target）。</p><p>大型项目通常会提供<code>clean</code>、<code>install</code>这些约定俗成的伪目标名称，方便用户快速执行特定任务。</p><p>一般来说，并不需要用<code>.PHONY</code>标识<code>clean</code>等约定俗成的伪目标名称，除非有人故意搞破坏，手动创建名字叫<code>clean</code>的文件。</p><h3 id="执行多条命令">执行多条命令</h3><p>一个规则可以有多条命令，例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd:</span></span><br><span class="line">pwd</span><br><span class="line">cd ..</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure><p>执行<code>cd</code>规则：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make cd</span><br><span class="line">pwd</span><br><span class="line">/home/ubuntu/makefile-tutorial/v1</span><br><span class="line">cd ..</span><br><span class="line">pwd</span><br><span class="line">/home/ubuntu/makefile-tutorial/v1</span><br></pre></td></tr></table></figure><p>观察输出，发现<code>cd ..</code>命令执行后，并未改变当前目录，两次输出的<code>pwd</code>是一样的，这是因为<code>make</code>针对每条命令，都会创建一个独立的Shell环境，类似<code>cd ..</code>这样的命令，并不会影响当前目录。</p><p>解决办法是把多条命令以<code>;</code>分隔，写到一行：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">pwd; cd ..; pwd;</span><br></pre></td></tr></table></figure><p>再执行<code>cd_ok</code>目标就得到了预期结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make cd_ok</span><br><span class="line">pwd; cd ..; pwd</span><br><span class="line">/home/ubuntu/makefile-tutorial/v1</span><br><span class="line">/home/ubuntu/makefile-tutorial</span><br></pre></td></tr></table></figure><p>可以使用<code>\</code>把一行语句拆成多行，便于浏览：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">pwd; \</span><br><span class="line">cd ..; \</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure><p>另一种执行多条命令的语法是用<code>&amp;&amp;</code>，它的好处是当某条命令失败时，后续命令不会继续执行：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">cd .. &amp;&amp; pwd</span><br></pre></td></tr></table></figure><h3 id="控制打印">控制打印</h3><p>默认情况下，<code>make</code>会打印出它执行的每一条命令。如果我们不想打印某一条命令，可以在命令前加上<code>@</code>，表示不打印命令（但是仍然会执行）：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">no_output:</span></span><br><span class="line">@echo &#x27;not display&#x27;</span><br><span class="line">echo &#x27;will display&#x27;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make no_output</span><br><span class="line">not display</span><br><span class="line">echo &#x27;will display&#x27;</span><br><span class="line">will display</span><br></pre></td></tr></table></figure><p>注意命令<code>echo 'not display'</code>本身没有打印，但命令仍然会执行，并且执行的结果仍然正常打印。</p><h3 id="控制错误">控制错误</h3><p><code>make</code>在执行命令时，会检查每一条命令的返回值，如果返回错误（非0值），就会中断执行。</p><p>例如，不使用<code>-f</code>删除一个不存在的文件会报错：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">has_error:</span></span><br><span class="line">rm zzz.txt</span><br><span class="line">echo &#x27;ok&#x27;</span><br></pre></td></tr></table></figure><p>执行上述目标，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make has_error</span><br><span class="line">rm zzz.txt</span><br><span class="line">rm: zzz.txt: No such file or directory</span><br><span class="line">make: *** [has_error] Error 1</span><br></pre></td></tr></table></figure><p>由于命令<code>rm zzz.txt</code>报错，导致后面的命令<code>echo 'ok'</code>并不会执行，<code>make</code>打印出错误，然后退出。</p><p>有些时候，我们想忽略错误，继续执行后续命令，可以在需要忽略错误的命令前加上<code>-</code>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ignore_error:</span></span><br><span class="line">-rm zzz.txt</span><br><span class="line">echo &#x27;ok&#x27;</span><br></pre></td></tr></table></figure><p>执行上述目标，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make ignore_error</span><br><span class="line">rm zzz.txt</span><br><span class="line">rm: zzz.txt: No such file or directory</span><br><span class="line">make: [ignore_error] Error 1 (ignored)</span><br><span class="line">echo &#x27;ok&#x27;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p><code>make</code>检测到<code>rm zzz.txt</code>报错，并打印错误，但显示<code>(ignored)</code>，然后继续执行后续命令。</p><p>对于执行可能出错，但不影响逻辑的命令，可以用<code>-</code>忽略。</p><h3 id="参考源码">参考源码</h3><p>可以从<a href="https://github.com/michaelliao/makefile-tutorial/tree/main/v1">GitHub</a>下载源码。</p><h3 id="小结">小结</h3><p>编写<code>Makefile</code>就是编写一系列规则，用来告诉<code>make</code>如何执行这些规则，最终生成我们期望的目标文件。</p><p>查看官方手册：</p><ul><li><a href="https://www.gnu.org/software/make/manual/html_node/Rules.html">编写规则</a></li><li><a href="https://www.gnu.org/software/make/manual/html_node/Execution.html">执行命令</a></li><li><a href="https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html">伪目标</a></li></ul><h2 id="编译C程序">编译C程序</h2><p>C程序的编译通常分两步：</p><ol><li>将每个<code>.c</code>文件编译为<code>.o</code>文件；</li><li>将所有<code>.o</code>文件链接为最终的可执行文件。</li></ol><p>我们假设如下的一个C项目，包含<code>hello.c</code>、<code>hello.h</code>和<code>main.c</code>。</p><p><code>hello.c</code>内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hello.h</code>内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p><code>main.c</code>内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start...\n&quot;</span>);</span><br><span class="line">    hello();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>main.c</code>引用了头文件<code>hello.h</code>。我们很容易梳理出需要生成的文件，逻辑如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌───────┐ ┌───────┐ ┌───────┐</span><br><span class="line">│hello.c│ │main.c │ │hello.h│</span><br><span class="line">└───────┘ └───────┘ └───────┘</span><br><span class="line">    │         │         │</span><br><span class="line">    │         └────┬────┘</span><br><span class="line">    │              │</span><br><span class="line">    ▼              ▼</span><br><span class="line">┌───────┐      ┌───────┐</span><br><span class="line">│hello.o│      │main.o │</span><br><span class="line">└───────┘      └───────┘</span><br><span class="line">    │              │</span><br><span class="line">    └───────┬──────┘</span><br><span class="line">            │</span><br><span class="line">            ▼</span><br><span class="line">       ┌─────────┐</span><br><span class="line">       │world.out│</span><br><span class="line">       └─────────┘</span><br></pre></td></tr></table></figure><p>假定最终生成的可执行文件是<code>world.out</code>，中间步骤还需要生成<code>hello.o</code>和<code>main.o</code>两个文件。根据上述依赖关系，我们可以很容易地写出<code>Makefile</code>如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成可执行文件:</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 hello.c:</span></span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">cc -c hello.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 main.c:</span></span><br><span class="line"><span class="section">main.o: main.c hello.h</span></span><br><span class="line">cc -c main.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o world.out</span><br></pre></td></tr></table></figure><p>执行<code>make</code>，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -c main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><p>在当前目录下可以看到<code>hello.o</code>、<code>main.o</code>以及最终的可执行程序<code>world.out</code>。执行<code>world.out</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./world.out </span><br><span class="line">start...</span><br><span class="line">hello, world!</span><br><span class="line">exit.</span><br></pre></td></tr></table></figure><p>与我们预期相符。</p><p>修改<code>hello.c</code>，把输出改为<code>&quot;hello, bob!\n&quot;</code>，再执行<code>make</code>，观察输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><p>仅重新编译了<code>hello.c</code>，并未编译<code>main.c</code>。由于<code>hello.o</code>已更新，所以，仍然要重新生成<code>world.out</code>。执行<code>world.out</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./world.out </span><br><span class="line">start...</span><br><span class="line">hello, bob!</span><br><span class="line">exit.</span><br></pre></td></tr></table></figure><p>与我们预期相符。</p><p>修改<code>hello.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int 变为 void:</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>以及<code>hello.c</code>，再次执行<code>make</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -c main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><p>会触发<code>main.c</code>的编译，因为<code>main.c</code>依赖<code>hello.h</code>。</p><p>执行<code>make clean</code>会删除所有的<code>.o</code>文件，以及可执行文件<code>world.out</code>，再次执行<code>make</code>就会强制全量编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make clean &amp;&amp; make</span><br><span class="line">rm -f *.o world.out</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -c main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><p>这个简单的<code>Makefile</code>使我们能自动化编译C程序，十分方便。</p><p>不过，随着越来越多的<code>.c</code>文件被添加进来，如何高效维护<code>Makefile</code>的规则？我们后面继续讲解。</p><h3 id="参考源码-2">参考源码</h3><p>可以从<a href="https://github.com/michaelliao/makefile-tutorial/tree/main/v2">GitHub</a>下载源码。</p><h3 id="小结-2">小结</h3><p>在<code>Makefile</code>正确定义规则后，我们就能用<code>make</code>自动化编译C程序。</p><hr><hr><h2 id="使用隐式规则">使用隐式规则</h2><p>我们仍然以上一节的C项目为例，当我们添加越来越多的<code>.c</code>文件时，就需要编写越来越多的规则来生成<code>.o</code>文件。</p><p>实际上，有的同学可能发现了，即使我们把<code>.o</code>的规则删掉，也能正常编译：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只保留生成 world.out 的规则:</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o world.out</span><br></pre></td></tr></table></figure><p>执行<code>make</code>，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc    -c -o hello.o hello.c</span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><p>我们没有定义<code>hello.o</code>和<code>main.o</code>的规则，为什么<code>make</code>也能正常创建这两个文件？</p><p>因为<code>make</code>最初就是为了编译C程序而设计的，为了免去重复创建编译<code>.o</code>文件的规则，<code>make</code>内置了隐式规则（Implicit Rule），即遇到一个<code>xyz.o</code>时，如果没有找到对应的规则，就自动应用一个隐式规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">xyz.o: xyz.c</span></span><br><span class="line">cc -c -o xyz.o xyz.c</span><br></pre></td></tr></table></figure><p><code>make</code>针对C、C++、ASM、Fortran等程序内置了一系列隐式规则，可以参考官方手册查看。</p><p>对于C程序来说，使用隐式规则有一个潜在问题，那就是无法跟踪<code>.h</code>文件的修改。如果我们修改了<code>hello.h</code>的定义，由于隐式规则<code>main.o: main.c</code>并不会跟踪<code>hello.h</code>的修改，导致<code>main.c</code>不会被重新编译，这个问题我们放到后面解决。</p><h3 id="参考源码-3">参考源码</h3><p>可以从<a href="https://github.com/michaelliao/makefile-tutorial/tree/main/v3">GitHub</a>下载源码。</p><h3 id="小结-3">小结</h3><p>针对C、C++、ASM、Fortran等程序，<code>make</code>内置了一系列隐式规则，使用隐式规则可减少大量重复的通用编译规则。</p><p>查看官方手册：</p><ul><li><a href="https://www.gnu.org/software/make/manual/html_node/Using-Implicit.html">使用隐式规则</a></li></ul><hr><hr><p>当我们在<code>Makefile</code>中重复写很多文件名时，一来容易写错，二来如果要改名，要全部替换，费时费力。</p><p>编程语言使用变量（Variable）来解决反复引用的问题，类似的，在<code>Makefile</code>中，也可以使用变量来解决重复问题。</p><p>以上一节的<code>Makefile</code>为例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o world.out</span><br></pre></td></tr></table></figure><p>编译的最终文件<code>world.out</code>重复出现了3次，因此，完全可以定义一个变量来替换它：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: hello.o main.o</span><br><span class="line">cc -o <span class="variable">$(TARGET)</span> hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><p>变量定义用<code>变量名 = 值</code>或者<code>变量名 := 值</code>，通常变量名全大写。引用变量用<code>$(变量名)</code>，非常简单。</p><p>注意到<code>hello.o main.o</code>这个“列表”也重复了，我们也可以用变量来替换：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OBJS = hello.o main.o</span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><p>如果有一种方式能让<code>make</code>自动生成<code>hello.o main.o</code>这个“列表”，就更好了。注意到每个<code>.o</code>文件是由对应的<code>.c</code>文件编译产生的，因此，可以让<code>make</code>先获取<code>.c</code>文件列表，再替换，得到<code>.o</code>文件列表：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $(wildcard *.c) 列出当前目录下的所有 .c 文件: hello.c main.c</span></span><br><span class="line"><span class="comment"># 用函数 patsubst 进行模式替换得到: hello.o main.o</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><p>这样，我们每添加一个<code>.c</code>文件，不需要修改<code>Makefile</code>，变量<code>OBJS</code>会自动更新。</p><p>思考：为什么我们不能直接定义<code>OBJS = $(wildcard *.o)</code>让<code>make</code>列出所有<code>.o</code>文件？</p><h3 id="内置变量">内置变量</h3><p>我们还可以用变量<code>$(CC)</code>替换命令<code>cc</code>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line"><span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure><p>没有定义变量<code>CC</code>也可以引用它，因为它是<code>make</code>的内置变量（Builtin Variables），表示C编译器的名字，默认值是<code>cc</code>，我们也可以修改它，例如使用交叉编译时，指定编译器：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC = riscv64-linux-gnu-gcc</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="自动变量">自动变量</h3><p>在<code>Makefile</code>中，经常可以看到<code>$@</code>、<code>$&lt;</code>这样的变量，这种变量称为自动变量（Automatic Variable），它们在一个规则中自动指向某个值。</p><p>例如，<code>$@</code>表示目标文件，<code>$^</code>表示所有依赖文件，因此，我们可以这么写：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">cc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure><p>在没有歧义时可以写<code>$@</code>，也可以写<code>$(@)</code>，有歧义时必须用括号，例如<code>$(@D)</code>。</p><p>为了更好地调试，我们还可以把变量打印出来：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">@echo &#x27;$<span class="variable">$@</span> = <span class="variable">$@</span>&#x27; <span class="comment"># 变量 $@ 表示target</span></span><br><span class="line">@echo &#x27;$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>&#x27; <span class="comment"># 变量 $&lt; 表示第一个依赖项</span></span><br><span class="line">@echo &#x27;$<span class="variable">$^</span> = <span class="variable">$^</span>&#x27; <span class="comment"># 变量 $^ 表示所有依赖项</span></span><br><span class="line">cc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure><p>执行结果输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$@ = world.out</span><br><span class="line">$&lt; = hello.o</span><br><span class="line">$^ = hello.o main.o</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><h3 id="参考源码-4">参考源码</h3><p>可以从<a href="https://github.com/michaelliao/makefile-tutorial/tree/main/v4">GitHub</a>下载源码。</p><h3 id="小结-4">小结</h3><p>使用变量可以让<code>Makefile</code>更加容易维护。</p><p>查看官方手册：</p><ul><li><a href="https://www.gnu.org/software/make/manual/html_node/Using-Variables.html">如何使用变量</a></li><li><a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">自动变量</a></li></ul><h2 id="使用模式规则">使用模式规则</h2><p>前面我们讲了使用隐式规则可以让<code>make</code>在必要时自动创建<code>.o</code>文件的规则，但<code>make</code>的隐式规则的命令是固定的，对于<code>xyz.o: xyz.c</code>，它实际上是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure><p>能修改的只有变量<code>$(CC)</code>和<code>$(CFLAGS)</code>。如果要执行多条命令，使用隐式规则就不行了。</p><p>这时，我们可以自定义模式规则（Pattern Rules），它允许<code>make</code>匹配模式规则，如果匹配上了，就自动创建一条模式规则。</p><p>我们修改上一节的<code>Makefile</code>如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式匹配规则：当make需要目标 xyz.o 时，自动生成一条 xyz.o: xyz.c 规则:</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">@echo &#x27;compiling <span class="variable">$&lt;</span>...&#x27;</span><br><span class="line">cc -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><p>当<code>make</code>执行<code>world.out: hello.o main.o</code>时，发现没有<code>hello.o</code>文件，于是需要查找以<code>hello.o</code>为目标的规则，结果匹配到模式规则<code>%.o: %.c</code>，于是<code>make</code>自动根据模式规则为我们动态创建了如下规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">@echo &#x27;compiling <span class="variable">$&lt;</span>...&#x27;</span><br><span class="line">cc -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure><p>查找<code>main.o</code>也是类似的匹配过程，于是我们执行<code>make</code>，就可以用模式规则完成编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">compiling hello.c...</span><br><span class="line">cc -c -o hello.o hello.c</span><br><span class="line">compiling main.c...</span><br><span class="line">cc -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><p>模式规则的命令完全由我们自己定义，因此，它比隐式规则更灵活。</p><p>但是，模式规则仍然没有解决修改<code>hello.h</code>头文件不会触发<code>main.c</code>重新编译的问题，这个依赖问题我们继续放到后面解决。</p><p>最后注意，模式规则是按需生成，如果我们在当前目录创建一个<code>zzz.o</code>文件，因为<code>make</code>并不会在执行过程中用到它，所以并不会自动生成<code>zzz.o: zzz.c</code>这个规则。</p><h3 id="参考源码-5">参考源码</h3><p>可以从<a href="https://github.com/michaelliao/makefile-tutorial/tree/main/v5">GitHub</a>下载源码。</p><h3 id="小结-5">小结</h3><p>使用模式规则可以灵活地按需动态创建规则，它比隐式规则更灵活。</p><p>查看官方手册：</p><ul><li><a href="https://www.gnu.org/software/make/manual/html_node/Pattern-Intro.html">模式规则</a></li></ul><hr><hr><p>前面我们讲了隐式规则和模式规则，这两种规则都可以解决自动把<code>.c</code>文件编译成<code>.o</code>文件，但都无法解决<code>.c</code>文件依赖<code>.h</code>文件的问题。</p><p>因为一个<code>.c</code>文件依赖哪个<code>.h</code>文件必须要分析文件内容才能确定，没有一个简单的文件名映射规则。</p><p>但是，要识别出<code>.c</code>文件的头文件依赖，可以用GCC提供的<code>-MM</code>参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cc -MM main.c</span><br><span class="line">main.o: main.c hello.h</span><br></pre></td></tr></table></figure><p>上述输出告诉我们，编译<code>main.o</code>依赖<code>main.c</code>和<code>hello.h</code>两个文件。</p><p>因此，我们可以利用GCC的这个功能，对每个<code>.c</code>文件都生成一个依赖项，通常我们把它保存到<code>.d</code>文件中，再用<code>include</code>引入到<code>Makefile</code>，就相当于自动化完成了每个<code>.c</code>文件的精准依赖。</p><p>我们改写上一节的<code>Makefile</code>如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有 .c 文件:</span></span><br><span class="line">SRCS = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据SRCS生成 .o 文件列表:</span></span><br><span class="line">OBJS = $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据SRCS生成 .d 文件列表:</span></span><br><span class="line">DEPS = $(SRCS:.c=.d)</span><br><span class="line"></span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标:</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line"><span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># xyz.d 的规则由 xyz.c 生成:</span></span><br><span class="line"><span class="section">%.d: %.c</span></span><br><span class="line">rm -f <span class="variable">$@</span>; \</span><br><span class="line"><span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> &gt;<span class="variable">$@</span>.tmp; \</span><br><span class="line">sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.tmp &gt; <span class="variable">$@</span>; \</span><br><span class="line">rm -f <span class="variable">$@</span>.tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式规则:</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line"><span class="variable">$(CC)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.o *.d <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入所有 .d 文件:</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(DEPS)</span></span><br></pre></td></tr></table></figure><p>变量<code>$(SRCS)</code>通过扫描目录可以确定为<code>hello.c main.c</code>，因此，变量<code>$(OBJS)</code>赋值为<code>hello.o main.o</code>，变量<code>$(DEPS)</code>赋值为<code>hello.d main.d</code>。</p><p>通过<code>include $(DEPS)</code>我们引入<code>hello.d</code>和<code>main.d</code>文件，但是这两个文件一开始并不存在，不过，<code>make</code>通过模式规则匹配到<code>%.d: %.c</code>，这就给了我们一个机会，在这个模式规则内部，用<code>cc -MM</code>命令外加<code>sed</code>把<code>.d</code>文件创建出来。</p><p>运行<code>make</code>，首次输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">Makefile:31: hello.d: No such file or directory</span><br><span class="line">Makefile:31: main.d: No such file or directory</span><br><span class="line">rm -f main.d; \</span><br><span class="line">        cc -MM main.c &gt;main.d.tmp; \</span><br><span class="line">        sed &#x27;s,\(main\)\.o[ :]*,\1.o main.d : ,g&#x27; &lt; main.d.tmp &gt; main.d; \</span><br><span class="line">        rm -f main.d.tmp</span><br><span class="line">rm -f hello.d; \</span><br><span class="line">        cc -MM hello.c &gt;hello.d.tmp; \</span><br><span class="line">        sed &#x27;s,\(hello\)\.o[ :]*,\1.o hello.d : ,g&#x27; &lt; hello.d.tmp &gt; hello.d; \</span><br><span class="line">        rm -f hello.d.tmp</span><br><span class="line">cc -c -o hello.o hello.c</span><br><span class="line">cc -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><p><code>make</code>会提示找不到<code>hello.d</code>和<code>main.d</code>，不过随后自动创建出<code>hello.d</code>和<code>main.d</code>。<code>hello.d</code>内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello.o hello.d : hello.c</span><br></pre></td></tr></table></figure><p>上述规则有两个目标文件，实际上相当于如下两条规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello.o : hello.c</span><br><span class="line">hello.d : hello.c</span><br></pre></td></tr></table></figure><p><code>main.d</code>内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o main.d : main.c hello.h</span><br></pre></td></tr></table></figure><p>因此，<code>main.o</code>依赖于<code>main.c</code>和<code>hello.h</code>，这个依赖关系就和我们手动指定的一致。</p><p>改动<code>hello.h</code>，再次运行<code>make</code>，可以触发<code>main.c</code>的编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">rm -f main.d; \</span><br><span class="line">        cc -MM main.c &gt;main.d.tmp; \</span><br><span class="line">        sed &#x27;s,\(main\)\.o[ :]*,\1.o main.d : ,g&#x27; &lt; main.d.tmp &gt; main.d; \</span><br><span class="line">        rm -f main.d.tmp</span><br><span class="line">cc -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><p>在实际项目中，对每个<code>.c</code>文件都可以生成一个对应的<code>.d</code>文件表示依赖关系，再通过<code>include</code>引入到<code>Makefile</code>，同时又能让<code>make</code>自动更新<code>.d</code>文件，有点蛋生鸡和鸡生蛋的关系，不过，这种机制能正常工作，除了<code>.d</code>文件不存在时会打印错误，有强迫症的同学肯定感觉不满意，这个问题我们后面解决。</p><h3 id="参考源码-6">参考源码</h3><p>可以从<a href="https://github.com/michaelliao/makefile-tutorial/tree/main/v6">GitHub</a>下载源码。</p><h3 id="小结-6">小结</h3><p>利用GCC生成<code>.d</code>文件，再用<code>include</code>引入<code>Makefile</code>，可解决一个<code>.c</code>文件应该如何正确触发编译的问题。</p><p>查看官方手册：</p><ul><li><a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Prerequisites.html">自动生成依赖</a></li></ul><h2 id="完善Makefile">完善Makefile</h2><p>上一节我们解决了自动生成依赖的问题，这一节我们对项目目录进行整理，把所有源码放入<code>src</code>目录，所有编译生成的文件放入<code>build</code>目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">├── Makefile</span><br><span class="line">├── build</span><br><span class="line">└── src</span><br><span class="line">    ├── hello.c</span><br><span class="line">    ├── hello.h</span><br><span class="line">    └── main.c</span><br></pre></td></tr></table></figure><p>整理<code>Makefile</code>，内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">SRC_DIR = ./src</span><br><span class="line">BUILD_DIR = ./build</span><br><span class="line">TARGET = <span class="variable">$(BUILD_DIR)</span>/world.out</span><br><span class="line"></span><br><span class="line">CC = cc</span><br><span class="line">CFLAGS = -Wall</span><br><span class="line"></span><br><span class="line"><span class="comment"># ./src/*.c</span></span><br><span class="line">SRCS = <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(SRC_DIR)</span> -name &#x27;*.c&#x27;)</span></span><br><span class="line"><span class="comment"># ./src/*.c =&gt; ./build/*.o</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c,<span class="variable">$(BUILD_DIR)</span>/%.o,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line"><span class="comment"># ./src/*.c =&gt; ./build/*.d</span></span><br><span class="line">DEPS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c,<span class="variable">$(BUILD_DIR)</span>/%.d,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标:</span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build/xyz.d 的规则由 src/xyz.c 生成:</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.d: <span class="variable">$(SRC_DIR)</span>/%.c</span><br><span class="line">@mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>; \</span><br><span class="line">rm -f <span class="variable">$@</span>; \</span><br><span class="line"><span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> &gt;<span class="variable">$@</span>.tmp; \</span><br><span class="line">sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,<span class="variable">$(BUILD_DIR)</span>/\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.tmp &gt; <span class="variable">$@</span>; \</span><br><span class="line">rm -f <span class="variable">$@</span>.tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># build/xyz.o 的规则由 src/xyz.c 生成:</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.o: <span class="variable">$(SRC_DIR)</span>/%.c</span><br><span class="line">@mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接:</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">@echo <span class="string">&quot;buiding <span class="variable">$@</span>...&quot;</span></span><br><span class="line">@mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line"><span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理 build 目录:</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">@echo <span class="string">&quot;clean...&quot;</span></span><br><span class="line">rm -rf <span class="variable">$(BUILD_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入所有 .d 文件:</span></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br></pre></td></tr></table></figure><p>这个<code>Makefile</code>定义了源码目录<code>SRC_DIR</code>、生成目录<code>BUILD_DIR</code>，以及其他变量，同时用<code>-include</code>消除了<code>.d</code>文件不存在的错误。执行<code>make</code>，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -Wall -c -o build/hello.o src/hello.c</span><br><span class="line">cc -Wall -c -o build/main.o src/main.c</span><br><span class="line">buiding build/world.out...</span><br><span class="line">cc -o ./build/world.out ./build/hello.o ./build/main.o</span><br></pre></td></tr></table></figure><p>可以说基本满足编译需求，收工！</p><h3 id="参考源码-7">参考源码</h3><p>可以从<a href="https://github.com/michaelliao/makefile-tutorial/tree/main/v7">GitHub</a>下载源码。</p><h3 id="小结-7">小结</h3><p>除了基础的用法外，<code>Makefile</code>还支持条件判断，环境变量，嵌套执行，变量展开等各种功能，需要用到时可以查询<a href="https://www.gnu.org/software/make/manual/html_node/index.html">官方手册</a>。</p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> make </category>
          
      </categories>
      
      
        <tags>
            
            <tag> make </tag>
            
            <tag> devops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ansible教程-hands-on</title>
      <link href="/2025/05/22/ansible/ansible%E6%95%99%E7%A8%8B-hands-on/"/>
      <url>/2025/05/22/ansible/ansible%E6%95%99%E7%A8%8B-hands-on/</url>
      
        <content type="html"><![CDATA[<h1>Ansible 学习笔记</h1><h2 id="简介">简介</h2><ul><li>基于Python开发的自动化运维工具</li><li>集合了众多运维工具(puppet、cfengine、chef、func、fabric)的优点</li><li>基于模块工作，本身没有批量部署能力，批量部署由运行的模块实现</li><li>提供自动化运维框架</li></ul><h2 id="作用">作用</h2><ul><li>批量系统配置</li><li>批量程序部署</li><li>批量运行命令</li></ul><h2 id="框架组成">框架组成</h2><ul><li><strong>Connection Plugins</strong>：负责和被监控端实现通信</li><li><strong>Host Inventory</strong>：定义监控主机的配置文件</li><li><strong>模块</strong>：<ul><li>核心模块</li><li>command模块</li><li>自定义模块</li></ul></li><li><strong>插件</strong>：完成记录日志邮件等功能</li><li><strong>Playbook</strong>：剧本，非必需，可让节点一次性运行多个任务</li></ul><h2 id="架构图">架构图</h2><p><img src="/assets/images/ansible1.png" alt="Ansible架构图"></p><h2 id="架构字段解释">架构字段解释</h2><ul><li><strong>Ansible</strong>：核心程序</li><li><strong>Host Inventory</strong>：主机清单(可定义主机组和主机)</li><li><strong>模块</strong>：实际执行任务的组件</li><li><strong>Playbook</strong>：Yaml定义的剧本文件(类似shell脚本)</li><li><strong>Connect Plugin</strong>：连接插件</li></ul><h2 id="工作原理">工作原理</h2><ol><li>控制端通过inventory定义主机组</li><li>通过编写playbook或AD-HOC命令</li><li>使用SSH将模块推送到被控端</li><li>被控端执行任务(要求被控端有Python2环境)</li><li>任务完成后返回结果</li></ol><h2 id="命令执行过程">命令执行过程</h2><ol><li>加载配置文件(/etc/ansible/ansible.cfg)</li><li>查找主机配置文件</li><li>加载对应模块文件</li><li>生成临时Python脚本并传输到远程主机</li><li>存储在远程主机的<code>~/.ansible/tmp/</code>目录</li><li>添加执行权限</li><li>执行并返回结果</li><li>删除临时文件</li></ol><h2 id="执行流程理解图">执行流程理解图</h2><p><img src="/assets/images/ansible2.png" alt="执行流程"></p><h2 id="特性">特性</h2><ul><li><strong>No Agents</strong>：无需在被控端安装客户端</li><li><strong>No Server</strong>：无服务端架构</li><li><strong>Modules in Any Languages</strong>：支持任意语言开发模块</li><li><strong>YAML</strong>：使用YAML语言编写playbook</li><li><strong>SSH by Default</strong>：默认基于SSH工作</li><li><strong>Multi-tier Solution</strong>：支持多级指挥</li></ul><h2 id="配置文件">配置文件</h2><p>配置文件优先级(从高到低)：</p><ol><li>项目目录下的<code>ansible.cfg</code></li><li>用户家目录下的<code>.ansible.cfg</code></li><li>默认的<code>/etc/ansible/ansible.cfg</code></li></ol><h3 id="主要配置项">主要配置项</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#inventory = /etc/ansible/hosts      # 主机列表</span></span><br><span class="line"><span class="comment">#library = /usr/share/my_modules/     # 模块库目录</span></span><br><span class="line"><span class="comment">#remote_tmp = ~/.ansible/tmp          # 远程临时目录</span></span><br><span class="line"><span class="comment">#local_tmp = ~/.ansible/tmp           # 本地临时目录</span></span><br><span class="line"><span class="comment">#forks = 5                            # 并发数</span></span><br><span class="line"><span class="comment">#sudo_user = root                     # 默认sudo用户</span></span><br><span class="line"><span class="comment">#ask_sudo_pass = True                 # 是否询问sudo密码</span></span><br><span class="line"><span class="comment">#ask_pass = True                      # 是否询问SSH密码</span></span><br><span class="line"><span class="comment">#remote_port = 22                     # 远程端口</span></span><br><span class="line"><span class="attr">host_key_checking</span> = <span class="literal">False</span>             <span class="comment"># 跳过主机指纹检查</span></span><br><span class="line"><span class="attr">log_path</span> = /var/log/ansible.log       <span class="comment"># 日志路径</span></span><br></pre></td></tr></table></figure><h2 id="优点">优点</h2><ul><li>轻量级，客户端无需安装agent</li><li>批量任务可写成脚本且无需分发</li><li>基于Python，维护简单</li><li>支持sudo</li></ul><h2 id="环境搭建">环境搭建</h2><h3 id="主机规划">主机规划</h3><table><thead><tr><th>主机</th><th>IP</th><th>角色</th></tr></thead><tbody><tr><td>h1</td><td>192.168.50.60</td><td>master</td></tr><tr><td>h2</td><td>192.168.50.61</td><td>host1</td></tr><tr><td>h3</td><td>192.168.50.62</td><td>host2</td></tr><tr><td>h4</td><td>192.168.50.63</td><td>host3</td></tr></tbody></table><h3 id="SSH免密登录配置">SSH免密登录配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t dsa -f ~/.ssh/id_dsa -P <span class="string">&quot;&quot;</span></span><br><span class="line">ssh-copy-id -i ~/.ssh/id_dsa.pub root@192.168.50.61</span><br></pre></td></tr></table></figure><h3 id="安装">安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y ansible</span><br></pre></td></tr></table></figure><h3 id="主机清单配置">主机清单配置</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[hosts]</span></span><br><span class="line">192.168.50.61</span><br><span class="line">192.168.50.62</span><br><span class="line">192.168.50.63</span><br><span class="line"></span><br><span class="line"><span class="section">[local]</span></span><br><span class="line">127.0.0.1</span><br></pre></td></tr></table></figure><h3 id="测试">测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ansible webservers -m <span class="built_in">command</span> -a <span class="string">&#x27;uptime&#x27;</span></span><br><span class="line">ansible all -m ping</span><br></pre></td></tr></table></figure><h2 id="常用模块">常用模块</h2><h3 id="setup模块">setup模块</h3><p>查看远程主机基本信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible webservers -m setup</span><br></pre></td></tr></table></figure><h3 id="fetch模块">fetch模块</h3><p>从主机获取文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible 192.168.50.61 -m fetch -a <span class="string">&#x27;src=/root/t2 dest=/root&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="file模块">file模块</h3><p>设置文件属性</p><p><strong>选项</strong>:</p><ul><li><code>force</code>: 强制创建软链接(yes|no)</li><li><code>group</code>: 文件属组</li><li><code>mode</code>: 文件权限</li><li><code>owner</code>: 文件属主</li><li><code>path</code>: 文件路径(必选)</li><li><code>recurse</code>: 递归设置属性(仅目录)</li><li><code>src</code>: 源文件路径(仅state=link时)</li><li><code>dest</code>: 链接目标路径(仅state=link时)</li><li><code>state</code>:<ul><li><code>directory</code>: 创建目录</li><li><code>file</code>: 不创建文件</li><li><code>link</code>: 创建软链接</li><li><code>hard</code>: 创建硬链接</li><li><code>touch</code>: 创建空文件或更新修改时间</li><li><code>absent</code>: 删除文件/目录</li></ul></li></ul><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建符号链接</span></span><br><span class="line">ansible hosts -m file -a <span class="string">&quot;src=/etc/resolv.conf dest=/root/resolv.conf state=link&quot;</span></span><br></pre></td></tr></table></figure><h3 id="copy模块">copy模块</h3><p>复制文件到远程主机</p><p><strong>选项</strong>:</p><ul><li><code>backup</code>: 覆盖前备份(yes|no)</li><li><code>content</code>: 直接设置文件内容(替代src)</li><li><code>dest</code>: 目标绝对路径(必选)</li><li><code>directory_mode</code>: 递归设置目录权限</li><li><code>force</code>: 强制覆盖(yes|no)</li><li><code>src</code>: 本地源文件路径</li></ul><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible hosts -m copy -a <span class="string">&quot;src=/etc/ansible/ansible.cfg dest=/tmp/ansible.cfg owner=root group=root mode=0755&quot;</span></span><br></pre></td></tr></table></figure><h3 id="command模块">command模块</h3><p>在远程主机执行命令</p><p><strong>选项</strong>:</p><ul><li><code>creates</code>: 文件存在时不执行</li><li><code>free_form</code>: Linux命令</li><li><code>chdir</code>: 执行前切换目录</li><li><code>removes</code>: 文件不存在时不执行</li><li><code>executable</code>: 指定shell路径</li></ul><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ansible webservers -m <span class="built_in">command</span> -a <span class="string">&quot;ls -al /tmp&quot;</span></span><br><span class="line">ansible webservers -m <span class="built_in">command</span> -a <span class="string">&#x27;useradd abc&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="shell模块">shell模块</h3><p>支持管道操作的命令执行</p><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行远程脚本</span></span><br><span class="line">ansible hosts -m shell -a <span class="string">&quot;/root/test.sh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量添加用户密码</span></span><br><span class="line">ansible hosts -m shell -a <span class="string">&#x27;useradd abc &amp;&amp; echo 123 |passwd --stdin abc&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="cron模块">cron模块</h3><p>管理计划任务</p><p><strong>选项</strong>:</p><ul><li><code>minute/hour/day/month/weekday</code>: 时间设置</li><li><code>job</code>: 任务命令</li><li><code>name</code>: 任务名称</li><li><code>user</code>: 执行用户</li><li><code>state</code>: present(添加)|absent(删除)</li></ul><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建任务</span></span><br><span class="line">ansible all -m cron -a <span class="string">&quot;minute=&#x27;*/5&#x27; job=&#x27;/usr/sbin/ntpdate 192.168.50.60 &amp;&gt;/dev/null&#x27; name=&#x27;sync time&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除任务</span></span><br><span class="line">ansible all -m cron -a <span class="string">&quot;name=&#x27;sync time&#x27; state=absent&quot;</span></span><br></pre></td></tr></table></figure><h3 id="hostname模块">hostname模块</h3><p>管理主机名</p><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改主机名</span></span><br><span class="line">ansible 192.168.50.63 -m hostname -a <span class="string">&quot;name=t4&quot;</span></span><br></pre></td></tr></table></figure><h3 id="yum模块">yum模块</h3><p>软件包管理</p><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装tree</span></span><br><span class="line">ansible all -m yum -a <span class="string">&quot;name=tree&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">ansible all -m yum -a <span class="string">&#x27;name=tree state=absent&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="service模块">service模块</h3><p>服务管理</p><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动ntpdate服务</span></span><br><span class="line">ansible all -m service -a <span class="string">&quot;name=ntpdate state=started enabled=true&quot;</span></span><br></pre></td></tr></table></figure><h3 id="group模块">group模块</h3><p>用户组管理</p><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加系统组</span></span><br><span class="line">ansible all -m group -a <span class="string">&quot;name=gansible system=true&quot;</span></span><br></pre></td></tr></table></figure><h3 id="user模块">user模块</h3><p>用户管理</p><p><strong>选项</strong>:</p><ul><li><code>name</code>: 用户名</li><li><code>state</code>: present(新增)|absent(删除)</li><li><code>force</code>: 删除时是否删除家目录</li><li><code>system</code>: 是否系统用户</li><li><code>uid</code>: 指定UID</li><li><code>shell</code>: 指定shell</li><li><code>home</code>: 指定家目录</li></ul><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加系统用户</span></span><br><span class="line">ansible all -m user -a <span class="string">&quot;name=ccc system=true&quot;</span></span><br></pre></td></tr></table></figure><h2 id="YAML语法">YAML语法</h2><ul><li>数据序列化格式</li><li>基本结构:<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">key:</span> <span class="string">value</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">item1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">item2</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">item3</span></span><br></pre></td></tr></table></figure>例如: <code>&#123;name: jerry, age: 21&#125;</code></li></ul><h2 id="Playbook">Playbook</h2><h3 id="核心元素">核心元素</h3><ul><li>Tasks: 任务列表</li><li>Variables: 变量</li><li>Templates: 模板文件</li><li>Handlers: 条件触发任务</li><li>Roles: 角色</li></ul><h3 id="基础组件">基础组件</h3><ul><li><code>Hosts</code>: 目标主机</li><li><code>remote_user</code>: 执行用户</li><li><code>sudo_user</code>: sudo用户</li><li><code>tasks</code>: 任务列表</li></ul><h3 id="运行Playbook">运行Playbook</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法检查</span></span><br><span class="line">ansible-playbook --syntax-check playbook.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试运行</span></span><br><span class="line">ansible-playbook -C playbook.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际运行</span></span><br><span class="line">ansible-playbook playbook.yaml</span><br></pre></td></tr></table></figure><h3 id="示例">示例</h3><h4 id="1-添加用户和组">1. 添加用户和组</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">a</span> <span class="string">group</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">name=test</span> <span class="string">system=test</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">a</span> <span class="string">user</span></span><br><span class="line">      <span class="attr">user:</span> <span class="string">name=test</span> <span class="string">group=test</span> <span class="string">system=true</span></span><br></pre></td></tr></table></figure><h4 id="2-配置HTTP服务">2. 配置HTTP服务</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">hosts</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">yum:</span> <span class="string">name=httpd</span> <span class="string">state=latest</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">conf</span></span><br><span class="line">      <span class="attr">copy:</span> <span class="string">src=/root/httpd.conf</span> <span class="string">dest=/etc/httpd/conf/httpd.conf.bak</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">start</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=reloaded</span> <span class="string">enabled=true</span></span><br></pre></td></tr></table></figure><h2 id="更多模块">更多模块</h2><ul><li><code>synchronize</code>: 使用rsync同步文件</li><li><code>raw</code>: 直接执行命令(类似shell)</li></ul><h2 id="模块帮助">模块帮助</h2><pre><code class="language-bash"># 列出所有模块ansible-doc -l# 查看模块帮助ansible-doc -s MOD_NAME</code></pre>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ansible </tag>
            
            <tag> 简明教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ansible教程-概念</title>
      <link href="/2025/05/22/ansible/ansible%E6%95%99%E7%A8%8B-%E6%A6%82%E5%BF%B5/"/>
      <url>/2025/05/22/ansible/ansible%E6%95%99%E7%A8%8B-%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="Ansible-概念">Ansible 概念</h2><p>这些概念适用于 Ansible 的所有用途。在使用 Ansible 或阅读文档之前，您应该了解它们。</p><ul><li><p>[控制节点]</p></li><li><p>[被管理节点]</p></li><li><p>[清单]</p></li><li><p>[剧本]</p><ul><li><p>[剧集]</p><ul><li><p>[角色]</p></li><li><p>[任务]</p></li><li><p>[处理器]</p></li></ul></li></ul></li><li><p>[模块]</p></li><li><p>[插件]</p></li><li><p>[集合]</p></li></ul><h2 id="控制节点">[控制节点]</h2><p>运行 Ansible CLI 工具（<code>ansible-playbook</code>、<code>ansible</code>、<code>ansible-vault</code> 等）的机器。您可以使用任何满足软件要求的计算机作为控制节点——笔记本电脑、共享桌面和服务器都可以运行 Ansible。您也可以在称为<a href="https://docs.ansible.org.cn/ansible/latest/getting_started_ee/index.html#getting-started-ee-index">执行环境</a>的容器中运行 Ansible。</p><p>可以使用多个控制节点，但 Ansible 本身并不协调它们之间的工作，有关此类功能，请参见<code>AAP</code>。</p><h2 id="被管理节点">[被管理节点]</h2><p>也称为“主机”，这些是您旨在用 Ansible 管理的目标设备（服务器、网络设备或任何计算机）。</p><p>除非您使用<code>ansible-pull</code>，否则通常不会在被管理节点上安装 Ansible，但这很少见，也不是推荐的设置。</p><h2 id="清单">[清单]</h2><p>由一个或多个“清单源”提供的被管理节点列表。您的清单可以指定每个节点的特定信息，例如 IP 地址。它还用于分配组，这既允许在剧集中选择节点，也允许批量分配变量。</p><p>要了解有关清单的更多信息，请参阅<a href="https://docs.ansible.org.cn/ansible/latest/inventory_guide/intro_inventory.html#intro-inventory">使用清单</a>部分。有时，清单源文件也称为“主机文件”。</p><h2 id="剧本">[剧本]</h2><p>它们包含剧集（这是 Ansible 执行的基本单元）。这既是“执行概念”，也是我们用来描述<code>ansible-playbook</code>操作的文件的方式。</p><p>剧本是用 YAML 编写的，易于阅读、编写、共享和理解。要了解有关剧本的更多信息，请参阅<a href="https://docs.ansible.org.cn/ansible/latest/playbook_guide/playbooks_intro.html#about-playbooks">Ansible 剧本</a>。</p><h3 id="剧集">[剧集]</h3><p>Ansible 执行的主要上下文，此剧本对象将被管理节点（主机）映射到任务。剧集包含变量、角色和已排序的任务列表，并且可以重复运行。它基本上由对映射的主机和任务的隐式循环组成，并定义如何迭代它们。</p><h4 id="角色">[角色]</h4><p>可在剧集内部使用的可重用 Ansible 内容（任务、处理器、变量、插件、模板和文件）的有限分发。</p><p>要使用任何角色资源，必须将角色本身导入剧集。</p><h4 id="任务">[任务]</h4><p>应用于被管理主机的“操作”的定义。您可以使用<code>ansible</code>或<code>ansible-console</code>（两者都会创建一个虚拟剧集）一次执行单个任务。</p><h4 id="处理器">[处理器]</h4><p>任务的一种特殊形式，仅在之前的任务发出通知并且导致“已更改”状态时才执行。</p><h2 id="模块">[模块]</h2><p>Ansible 复制到并在每个被管理节点上执行（如有需要）的代码或二进制文件，以完成每个任务中定义的操作。</p><p>每个模块都有其特定的用途，从管理特定类型数据库上的用户到管理特定类型网络设备上的 VLAN 接口。</p><p>您可以使用任务调用单个模块，也可以在剧本中调用多个不同的模块。Ansible 模块分组在集合中。要了解 Ansible 包含多少集合，请参阅<a href="https://docs.ansible.org.cn/ansible/latest/collections/index.html#list-of-collections">集合索引</a>。</p><h2 id="插件">[插件]</h2><p>扩展 Ansible 核心功能的代码片段。插件可以控制您如何连接到被管理节点（连接插件）、操作数据（过滤器插件），甚至控制在控制台中显示的内容（回调插件）。</p><p>有关详细信息，请参阅<a href="https://docs.ansible.org.cn/ansible/latest/plugins/plugins.html#working-with-plugins">使用插件</a>。</p><h2 id="集合">[集合]</h2><p>Ansible 内容的分发格式，可以包含剧本、角色、模块和插件。您可以通过<a href="https://galaxy.ansible.com/">Ansible Galaxy</a>安装和使用集合。</p><p>要了解有关集合的更多信息，请参阅<a href="https://docs.ansible.org.cn/ansible/latest/collections_guide/index.html#collections">使用 Ansible 集合</a>。</p><p>集合资源可以彼此独立且离散地使用。</p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ansible </tag>
            
            <tag> 简明教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ansible教程-入门篇</title>
      <link href="/2025/05/22/ansible/ansible%E6%95%99%E7%A8%8B-%E5%85%A5%E9%97%A8%E7%AF%87/"/>
      <url>/2025/05/22/ansible/ansible%E6%95%99%E7%A8%8B-%E5%85%A5%E9%97%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="Ansible-简介">Ansible 简介</h2><p>Ansible 提供开源自动化，可降低复杂性并在任何地方运行。使用 Ansible 可以自动执行几乎任何任务。以下是 Ansible 的一些常见用例</p><ul><li><p>消除重复并简化工作流程</p></li><li><p>管理和维护系统配置</p></li><li><p>持续部署复杂的软件</p></li><li><p>执行零停机滚动更新</p></li></ul><p>Ansible 使用简单的、人类可读的脚本（称为剧本）来自动化您的任务。您在剧本中声明本地或远程系统的期望状态。Ansible 确保系统保持在该状态。</p><p>作为自动化技术，Ansible 围绕以下原则设计</p><p>无代理架构</p><p>通过避免在 IT 基础设施上安装额外软件来降低维护开销。</p><p>简单性</p><p>自动化剧本使用简单的 YAML 语法，代码就像文档一样易于阅读。Ansible 也是分散式的，使用 SSH 和现有的操作系统凭据来访问远程机器。</p><p>可扩展性和灵活性</p><p>通过模块化设计轻松快速地扩展您自动化的系统，该设计支持各种操作系统、云平台和网络设备。</p><p>幂等性和可预测性</p><p>当系统处于您的剧本描述的状态时，即使多次运行剧本，Ansible 也不会更改任何内容。</p><h2 id="使用-Ansible-开始自动化">使用 Ansible 开始自动化</h2><p>通过创建自动化项目、构建清单和创建“Hello World”剧本开始使用 Ansible。</p><ol><li><p>安装 Ansible。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install ansible</span><br></pre></td></tr></table></figure></li><li><p>在您的文件系统上创建一个项目文件夹。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ansible_quickstart &amp;&amp; cd ansible_quickstart</span><br></pre></td></tr></table></figure><p>使用单一目录结构可以更轻松地添加到源代码管理，以及重用和共享自动化内容。</p></li></ol><h2 id="构建清单">构建清单</h2><p>清单将受管节点组织在集中式文件中，这些文件为 Ansible 提供系统信息和网络位置。使用清单文件，Ansible 可以使用单个命令管理大量主机。</p><p>要完成以下步骤，您需要至少一个主机系统的 IP 地址或完全限定域名 (FQDN)。出于演示目的，主机可以在容器或虚拟机中本地运行。您还必须确保您的公共 SSH 密钥已添加到每个主机上的 <code>authorized_keys</code> 文件中。</p><p>继续 Ansible 入门并按如下步骤构建清单</p><ol><li><p>在您在 上一步中创建的 <code>ansible_quickstart</code> 目录中创建一个名为 <code>inventory.ini</code> 的文件。</p></li><li><p>向 <code>inventory.ini</code> 文件添加一个新的 <code>[myhosts]</code> 组，并指定每个主机系统的 IP 地址或完全限定域名 (FQDN)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[myhosts]</span><br><span class="line">192.0.2.50</span><br><span class="line">192.0.2.51</span><br><span class="line">192.0.2.52</span><br></pre></td></tr></table></figure></li><li><p>验证您的清单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-inventory -i inventory.ini --list</span><br></pre></td></tr></table></figure></li><li><p>Ping 清单中的 <code>myhosts</code> 组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible myhosts -m ping -i inventory.ini</span><br></pre></td></tr></table></figure><p>注意</p><p>如果控制节点和受管节点上的用户名不同，请使用 <code>ansible</code> 命令传递 <code>-u</code> 选项。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">192.0.2.50 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python3&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line">192.0.2.51 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python3&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line">192.0.2.52 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python3&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="INI-或-YAML-格式的清单">INI 或 YAML 格式的清单</h2><p>您可以使用 <code>INI</code> 文件或 <code>YAML</code> 创建清单。在大多数情况下，例如上一步中的示例，对于少量受管节点，<code>INI</code> 文件简单易读。</p><p>随着受管节点数量的增加，使用 <code>YAML</code> 格式创建清单变得更合理。例如，以下是 <code>inventory.ini</code> 的等效项，它声明受管节点的唯一名称并使用 <code>ansible_host</code> 字段</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">myhosts:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="attr">my_host_01:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.50</span></span><br><span class="line">    <span class="attr">my_host_02:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.51</span></span><br><span class="line">    <span class="attr">my_host_03:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.52</span></span><br></pre></td></tr></table></figure><h2 id="构建清单的技巧">构建清单的技巧</h2><ul><li><p>确保组名有意义且唯一。组名也区分大小写。</p></li><li><p>避免在组名中使用空格、连字符和前导数字（使用 <code>floor_19</code>，而不是 <code>19th_floor</code>）。</p></li><li><p>根据主机的**什么**、**哪里**和**何时**逻辑地将主机分组到您的清单中。</p><p>什么</p><p>根据拓扑结构对主机分组，例如：db、web、leaf、spine。</p><p>哪里</p><p>按地理位置对主机分组，例如：数据中心、区域、楼层、建筑物。</p><p>何时</p><p>按阶段对主机分组，例如：开发、测试、过渡、生产。</p></li></ul><h3 id="使用元组">使用元组</h3><p>使用以下语法创建一个元组来组织清单中的多个组</p><p>以下清单说明了数据中心的结构基础。此示例清单包含一个 <code>network</code> 元组，其中包括所有网络设备，以及一个 <code>datacenter</code> 元组，其中包括 <code>network</code> 组和所有 Web 服务器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">leafs:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="attr">leaf01:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.100</span></span><br><span class="line">    <span class="attr">leaf02:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.110</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spines:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="attr">spine01:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.120</span></span><br><span class="line">    <span class="attr">spine02:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.130</span></span><br><span class="line"></span><br><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">children:</span></span><br><span class="line">    <span class="attr">leafs:</span></span><br><span class="line">    <span class="attr">spines:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">webservers:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="attr">webserver01:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.140</span></span><br><span class="line">    <span class="attr">webserver02:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.150</span></span><br><span class="line"></span><br><span class="line"><span class="attr">datacenter:</span></span><br><span class="line">  <span class="attr">children:</span></span><br><span class="line">    <span class="attr">network:</span></span><br><span class="line">    <span class="attr">webservers:</span></span><br></pre></td></tr></table></figure><h3 id="创建变量">创建变量</h3><p>变量设置受管节点的值，例如 IP 地址、FQDN、操作系统和 SSH 用户，因此您无需在运行 Ansible 命令时传递它们。</p><p>变量可以应用于特定主机。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">webservers:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="attr">webserver01:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.140</span></span><br><span class="line">      <span class="attr">http_port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">webserver02:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.150</span></span><br><span class="line">      <span class="attr">http_port:</span> <span class="number">443</span></span><br></pre></td></tr></table></figure><p>变量也可以应用于组中的所有主机。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">webservers:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="attr">webserver01:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.140</span></span><br><span class="line">      <span class="attr">http_port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">webserver02:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.150</span></span><br><span class="line">      <span class="attr">http_port:</span> <span class="number">443</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">ansible_user:</span> <span class="string">my_server_user</span></span><br></pre></td></tr></table></figure><hr><h2 id="创建剧本">创建剧本</h2><p>剧本是 Ansible 用于部署和配置受管节点的自动化蓝图，采用 <code>YAML</code> 格式。</p><p>剧本</p><p>一系列定义 Ansible 执行操作顺序的剧目，自上而下，以实现总体目标。</p><p>剧目</p><p>一个有序的任务列表，映射到清单中的受管节点。</p><p>任务</p><p>对单个模块的引用，定义 Ansible 执行的操作。</p><p>模块</p><p>Ansible 在受管节点上运行的代码或二进制单元。Ansible 模块按集合分组，每个模块都有一个<a href="https://docs.ansible.org.cn/ansible/latest/reference_appendices/glossary.html#term-Fully-Qualified-Collection-Name-FQCN">完全限定的集合名称 (FQCN)</a>。</p><p>完成以下步骤以创建用于 ping 主机并打印“Hello world”消息的剧本</p><ol><li><p>在您之前创建的 <code>ansible_quickstart</code> 目录中创建一个名为 <code>playbook.yaml</code> 的文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">My</span> <span class="string">first</span> <span class="string">play</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">myhosts</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Ping</span> <span class="string">my</span> <span class="string">hosts</span></span><br><span class="line">     <span class="attr">ansible.builtin.ping:</span></span><br><span class="line"></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Print</span> <span class="string">message</span></span><br><span class="line">     <span class="attr">ansible.builtin.debug:</span></span><br><span class="line">       <span class="attr">msg:</span> <span class="string">Hello</span> <span class="string">world</span></span><br></pre></td></tr></table></figure></li><li><p>运行您的剧本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook -i inventory.ini playbook.yaml</span><br></pre></td></tr></table></figure></li></ol><p>Ansible 返回以下输出</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">PLAY [My first play] ****************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [Gathering Facts] **************************************************************************</span><br><span class="line">ok: [192.0.2.50]</span><br><span class="line">ok: [192.0.2.51]</span><br><span class="line">ok: [192.0.2.52]</span><br><span class="line"></span><br><span class="line">TASK [Ping my hosts] ****************************************************************************</span><br><span class="line">ok: [192.0.2.50]</span><br><span class="line">ok: [192.0.2.51]</span><br><span class="line">ok: [192.0.2.52]</span><br><span class="line"></span><br><span class="line">TASK [Print message] ****************************************************************************</span><br><span class="line">ok: [192.0.2.50] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;Hello world&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [192.0.2.51] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;Hello world&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [192.0.2.52] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;Hello world&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP **************************************************************************************</span><br><span class="line">192.0.2.50: ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br><span class="line">192.0.2.51: ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br><span class="line">192.0.2.52: ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure><p>在此输出中，您可以看到</p><ul><li><p>您为剧目和每个任务指定的名称。您应始终使用易于验证和排查剧本问题的描述性名称。</p></li><li><p>“收集事实”任务隐式运行。默认情况下，Ansible 会收集有关您的清单的信息，以便在剧本中使用。</p></li><li><p>每个任务的状态。每个任务的状态为 <code>ok</code>，表示它已成功运行。</p></li><li><p>剧目摘要，总结了每个主机上所有任务的结果。在此示例中，共有三个任务，因此 <code>ok=3</code> 表示每个任务都已成功运行。</p></li></ul><p>恭喜，您已开始使用 Ansible！</p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ansible </tag>
            
            <tag> 简明教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas cheat sheet</title>
      <link href="/2025/05/21/cheat-sheet/pandas-cheat-sheet/"/>
      <url>/2025/05/21/cheat-sheet/pandas-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="pandas">pandas:</h3><div class="row">    <embed src="/assets/pdf/pandas-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> data </category>
          
          <category> python </category>
          
          <category> pandas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> cheat sheet </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-framework cheat sheet</title>
      <link href="/2025/05/21/cheat-sheet/spring-framework-cheat-sheet/"/>
      <url>/2025/05/21/cheat-sheet/spring-framework-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="java">java:</h3><div class="row">    <embed src="/assets/pdf/spring-framework-4-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> 服务端 </category>
          
          <category> Java </category>
          
          <category> spring-framework-4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> cheat sheet </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java fundamentals cheat sheet</title>
      <link href="/2025/05/21/cheat-sheet/java-fundamentals-cheat-sheet/"/>
      <url>/2025/05/21/cheat-sheet/java-fundamentals-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="java">java:</h3><div class="row">    <embed src="/assets/pdf/java-fundamentals-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> cheat sheet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>postgresql cheat sheet</title>
      <link href="/2025/05/20/cheat-sheet/postgresql-cheat-sheet/"/>
      <url>/2025/05/20/cheat-sheet/postgresql-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="postgresql">postgresql:</h3><div class="row">    <embed src="/assets/pdf/postgresql-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div><div class="row">    <embed src="/assets/pdf/postgresql-cheat-sheet2.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cheat sheet </tag>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django cheat sheet</title>
      <link href="/2025/05/20/cheat-sheet/django-cheat-sheet/"/>
      <url>/2025/05/20/cheat-sheet/django-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="django">django:</h3><div class="row">    <embed src="/assets/pdf/django-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> 服务端 </category>
          
          <category> python </category>
          
          <category> django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cheat sheet </tag>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python cheat sheet</title>
      <link href="/2025/05/20/cheat-sheet/python-cheat-sheet/"/>
      <url>/2025/05/20/cheat-sheet/python-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="python">python:</h3><div class="row">    <embed src="/assets/pdf/python-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> cheat sheet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql cheat sheet</title>
      <link href="/2025/05/20/cheat-sheet/mysql-cheat-sheet/"/>
      <url>/2025/05/20/cheat-sheet/mysql-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="mysql">mysql:</h3><div class="row">    <embed src="/assets/pdf/mysql-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> cheat sheet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim cheat sheet</title>
      <link href="/2025/05/20/cheat-sheet/vim-cheat-sheet/"/>
      <url>/2025/05/20/cheat-sheet/vim-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="python">python:</h3><div class="row">    <embed src="/assets/pdf/vim-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> cheat sheet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ansible cheat sheet</title>
      <link href="/2025/05/20/cheat-sheet/ansible-cheat-sheet/"/>
      <url>/2025/05/20/cheat-sheet/ansible-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="ansible-command">ansible command:</h3><div class="row">    <embed src="/assets/pdf/ansible-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="playbook">playbook:</h3><div class="row">    <embed src="/assets/pdf/ansible-playbook.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cheat sheet </tag>
            
            <tag> ansible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>curl cheat sheet</title>
      <link href="/2025/05/20/cheat-sheet/curl-cheat-sheet/"/>
      <url>/2025/05/20/cheat-sheet/curl-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="curl-command">curl command:</h3><div class="row">    <embed src="/assets/pdf/curl-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> curl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cheat sheet </tag>
            
            <tag> curl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker cheat sheet</title>
      <link href="/2025/05/20/cheat-sheet/docker-cheat-sheet/"/>
      <url>/2025/05/20/cheat-sheet/docker-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="docker">docker:</h3><p><img src="/assets/images/docker-cheat-sheet.webp" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cheat sheet </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux cheat sheet</title>
      <link href="/2025/05/15/cheat-sheet/Linux-cheat-sheet/"/>
      <url>/2025/05/15/cheat-sheet/Linux-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<h3 id="linux">linux:</h3><p><img src="/assets/images/Linux-Commands_Cheat-Sheet.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> cheat sheet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git cheat sheet</title>
      <link href="/2025/05/14/git/git-cheat-sheet/"/>
      <url>/2025/05/14/git/git-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/images/gitcheatsheet.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim教程</title>
      <link href="/2025/05/12/vim%E6%95%99%E7%A8%8B/"/>
      <url>/2025/05/12/vim%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1>Vim 编辑器使用笔记整理</h1><h2 id="1-退出-Vim">1. 退出 Vim</h2><h3 id="命令行模式退出方式">命令行模式退出方式</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:wq</code></td><td>保存并退出</td></tr><tr><td><code>:q!</code></td><td>强制退出，不保存</td></tr><tr><td><code>:q</code></td><td>退出(未修改时)</td></tr><tr><td><code>:wq!</code></td><td>强制保存并退出</td></tr><tr><td><code>:w &lt;文件路径&gt;</code></td><td>另存为指定文件</td></tr><tr><td><code>:saveas 文件路径</code></td><td>另存为指定文件</td></tr><tr><td><code>:x</code></td><td>保存并退出(类似:wq)</td></tr></tbody></table><h3 id="普通模式退出方式">普通模式退出方式</h3><ul><li>输入 <code>Shift+zz</code> 即可保存退出</li></ul><h2 id="2-删除文本">2. 删除文本</h2><h3 id="普通模式删除命令">普通模式删除命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>x</code></td><td>删除游标所在字符</td></tr><tr><td><code>X</code></td><td>删除游标前一个字符</td></tr><tr><td><code>Delete</code></td><td>同 <code>x</code></td></tr><tr><td><code>dd</code></td><td>删除整行</td></tr><tr><td><code>dw</code></td><td>删除一个单词(不适用中文)</td></tr><tr><td><code>d$</code> 或 <code>D</code></td><td>删除至行尾</td></tr><tr><td><code>d^</code></td><td>删除至行首</td></tr><tr><td><code>dG</code></td><td>删除到文档结尾</td></tr><tr><td><code>d1G</code></td><td>删除至文档开头</td></tr><tr><td><code>:%d</code></td><td>清空整个文档内容（删除所有行）</td></tr><tr><td><code>:1,$d</code></td><td>同 <code>:%d</code>，删除从第一行到最后一行</td></tr><tr><td><code>ggdG</code></td><td>普通模式下清空文档的快捷方式（先跳转到首行，然后删除到末尾）</td></tr></tbody></table><p>注意：这些命令会立即生效且不可撤销，使用前请确保已保存重要内容</p><h3 id="数字前缀用法">数字前缀用法</h3><ul><li><code>2dd</code> 表示一次删除2行</li><li><code>3dw</code> 表示删除3个单词</li></ul><h2 id="3-重复执行命令">3. 重复执行命令</h2><ul><li>普通模式下 <code>.</code> (小数点)表示重复上一次命令</li><li>数字前缀：<code>10x</code> 删除10个连续字符</li></ul><h2 id="4-游标跳转">4. 游标跳转</h2><h3 id="行间跳转">行间跳转</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>nG</code></td><td>跳转到第n行(需先<code>:set nu</code>显示行号)</td></tr><tr><td><code>gg</code></td><td>跳转到第一行</td></tr><tr><td><code>G</code></td><td>跳转到最后一行</td></tr></tbody></table><h3 id="行内跳转">行内跳转</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>w</code></td><td>到下一个单词开头</td></tr><tr><td><code>e</code></td><td>到当前单词结尾</td></tr><tr><td><code>b</code></td><td>到前一个单词开头</td></tr><tr><td><code>ge</code></td><td>到前一个单词结尾</td></tr><tr><td><code>0</code> 或 <code>^</code></td><td>到行头</td></tr><tr><td><code>$</code></td><td>到行尾</td></tr><tr><td><code>f&lt;字母&gt;</code></td><td>向后搜索字母并跳转</td></tr><tr><td><code>F&lt;字母&gt;</code></td><td>向前搜索字母并跳转</td></tr><tr><td><code>t&lt;字母&gt;</code></td><td>向后搜索字母并跳转到匹配前</td></tr><tr><td><code>T&lt;字母&gt;</code></td><td>向前搜索字母并跳转到匹配后</td></tr></tbody></table><h2 id="5-复制粘贴和剪切">5. 复制粘贴和剪切</h2><h3 id="复制命令-yank">复制命令(yank)</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>yy</code></td><td>复制整行(3yy复制3行)</td></tr><tr><td><code>y^</code></td><td>复制至行首</td></tr><tr><td><code>y$</code></td><td>复制至行尾</td></tr><tr><td><code>yw</code></td><td>复制一个单词</td></tr><tr><td><code>yG</code></td><td>复制至文本末</td></tr><tr><td><code>y1G</code></td><td>复制至文本开头</td></tr></tbody></table><h3 id="粘贴命令">粘贴命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>p</code></td><td>粘贴至光标后</td></tr><tr><td><code>P</code></td><td>粘贴至光标前</td></tr></tbody></table><h2 id="6-替换和撤销">6. 替换和撤销</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>r+&lt;字母&gt;</code></td><td>替换游标所在字母</td></tr><tr><td><code>R</code></td><td>连续替换(按Esc结束)</td></tr><tr><td><code>cc</code></td><td>替换整行</td></tr><tr><td><code>cw</code></td><td>替换一个单词</td></tr><tr><td><code>C</code></td><td>替换至行末</td></tr><tr><td><code>~</code></td><td>反转字母大小写</td></tr><tr><td><code>u</code></td><td>撤销操作</td></tr><tr><td><code>U</code></td><td>撤销当前行所有修改</td></tr><tr><td><code>Ctrl+r</code></td><td>重做(redo)</td></tr></tbody></table><h2 id="7-缩进调整">7. 缩进调整</h2><h3 id="缩进命令">缩进命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>&gt;&gt;</code></td><td>整行向右缩进</td></tr><tr><td><code>&lt;&lt;</code></td><td>整行向左回退</td></tr><tr><td><code>:set shiftwidth=n</code></td><td>设置缩进字符数</td></tr></tbody></table><h3 id="文本位置调整">文本位置调整</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:ce</code></td><td>本行内容居中</td></tr><tr><td><code>:ri</code></td><td>本行文本靠右</td></tr><tr><td><code>:le</code></td><td>本行内容靠左</td></tr></tbody></table><h2 id="8-查找功能">8. 查找功能</h2><h3 id="基本查找">基本查找</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>/字符串</code></td><td>向下查找</td></tr><tr><td><code>?字符串</code></td><td>向上查找</td></tr><tr><td><code>n</code></td><td>继续查找</td></tr><tr><td><code>N</code></td><td>反向查找</td></tr></tbody></table><h3 id="高级查找">高级查找</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>*</code></td><td>向后查找当前单词</td></tr><tr><td><code>#</code></td><td>向前查找当前单词</td></tr><tr><td><code>g*</code></td><td>向后查找部分匹配单词</td></tr><tr><td><code>g#</code></td><td>向前查找部分匹配单词</td></tr></tbody></table><h2 id="9-多文件编辑">9. 多文件编辑</h2><h3 id="多文件操作">多文件操作</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:n</code></td><td>编辑下一个文件</td></tr><tr><td><code>:N</code></td><td>编辑上一个文件</td></tr><tr><td><code>:e 文件名</code></td><td>打开新文件</td></tr><tr><td><code>:e#</code></td><td>回到前一个文件</td></tr><tr><td><code>:ls</code></td><td>列出编辑过的文档</td></tr><tr><td><code>:b 文件名/编号</code></td><td>切换到指定文件</td></tr><tr><td><code>:bd 文件名/编号</code></td><td>从列表删除文件</td></tr><tr><td><code>:f</code></td><td>显示当前文件名</td></tr></tbody></table><h3 id="文件恢复">文件恢复</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim -r 文件名</span><br><span class="line">:ewcover 文件名</span><br></pre></td></tr></table></figure><h2 id="10-可视模式">10. 可视模式</h2><h3 id="进入可视模式">进入可视模式</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>v</code></td><td>字符选择模式</td></tr><tr><td><code>V</code></td><td>行选择模式</td></tr><tr><td><code>Ctrl+v</code></td><td>区域选择模式</td></tr></tbody></table><h3 id="可视模式操作">可视模式操作</h3><ul><li><code>d</code> 删除选中区域</li><li><code>y</code> 复制选中区域</li></ul><h2 id="11-视窗操作">11. 视窗操作</h2><h3 id="窗口分割">窗口分割</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:new</code></td><td>新建窗口</td></tr><tr><td><code>:sp 文件名</code></td><td>水平分割窗口</td></tr><tr><td><code>:vsp 文件名</code></td><td>垂直分割窗口</td></tr><tr><td><code>Ctrl+w s</code></td><td>水平分割当前窗口</td></tr><tr><td><code>Ctrl+w v</code></td><td>垂直分割当前窗口</td></tr></tbody></table><h3 id="窗口切换">窗口切换</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>Ctrl+w j/k/h/l</code></td><td>向下/上/左/右切换窗口</td></tr><tr><td><code>Ctrl+w q</code></td><td>关闭当前窗口</td></tr><tr><td><code>Ctrl+w o</code></td><td>只保留当前窗口</td></tr></tbody></table><h2 id="12-其他功能">12. 其他功能</h2><h3 id="文档加密">文档加密</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -x 文件名</span><br></pre></td></tr></table></figure><h3 id="执行外部命令">执行外部命令</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:!命令</span><br><span class="line">:<span class="keyword">w</span> 文件名  # 另存为</span><br></pre></td></tr></table></figure><h3 id="帮助系统">帮助系统</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:F1        # 打开帮助</span><br><span class="line">:h 主题    # 查看特定帮助</span><br><span class="line">:ver       # 显示版本</span><br></pre></td></tr></table></figure><h3 id="功能设定">功能设定</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">set</span> <span class="keyword">nu</span>    # 显示行号</span><br><span class="line">:<span class="keyword">set</span> ai    # 自动缩进</span><br><span class="line">:<span class="keyword">set</span> aw    # 自动保存</span><br><span class="line">:<span class="keyword">set</span> cin   # C语言风格缩进</span><br></pre></td></tr></table></figure><blockquote><p>提示：所有设置可通过修改 <code>~/.vimrc</code> 文件永久保存</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> devops </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文搞懂贝叶斯定理（应用篇）</title>
      <link href="/2023/08/29/%E6%95%B0%E5%AD%A6/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%88%E5%BA%94%E7%94%A8%E7%AF%87%EF%BC%89/"/>
      <url>/2023/08/29/%E6%95%B0%E5%AD%A6/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%88%E5%BA%94%E7%94%A8%E7%AF%87%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在统计学里，长期以来，有频率学派和贝叶斯学派两大学派，他们互相鄙视对方，就像华山派的气宗与剑宗之争。</p><p>这两大学派最根本的观点在于看待世界的方式不同：</p><ul><li>频率学派认为世界是客观的，必须通过大量独立采样来获得统计均值，不能先给出一个主观的先验概率（假设）；</li><li>贝叶斯学派则认为概率是一种信念度，可以有非常主观的先验概率，然后，通过一次次采样结果修正先验概率，使之逼近客观事实。</li></ul><p>这两大学派哪个才是正确的？其实都对，只是看待世界的角度不同。但是在现实世界中，除了抛硬币、掷骰子、玩老虎机等少数符合理想数学模型的场景，频率学派才能发挥作用。大多数需要我们估算概率的现实场景，只能用贝叶斯理论来指导实践。</p><p>举个例子，假设我住在市区，希望赶上飞机的概率不低于90%，那么我应该提前多久出发呢？我必须试验至少100次，看看样本空间，才能获得一个比较准确的统计均值。然而这是不现实的，因为我一年可能就坐几次飞机。我只能拍脑袋先估一个提前30分钟就够了，结果第三次就没赶上，这说明我必须修正我的先验概率，后续改为提前45分钟，才能提升赶上飞机的概率。</p><p>我们再以《狼来了》的故事为例，当小孩第一次喊狼来了，村民听到后可以根据先验概率，比如P(小孩是诚实的)=90%判断赶紧去帮忙，结果发现被骗了，于是大家根据“被骗了”这一证据把后验概率P(小孩是诚实的)调整为60%，第二次又被骗了，于是再次把后验概率调整为20%，等到第三次听见小孩求救时，大家根据P(小孩是诚实的)=20%判断，他大概率还是在说谎，于是没有人去帮忙了。</p><p>有的同学会问，你说的这些，都是定性分析，没有定量计算啊！</p><p>要把贝叶斯定理用到定量计算，必须得借助计算机。</p><p>以吴军老师在中文分词领域举的一个例子来说，对于一个句子：南京市长江大桥，可以有两种划分：</p><ul><li>南京市 / 长江大桥</li><li>南京市长 / 江大桥</li></ul><p>到底哪一种更合理？我们可以计算条件概率：</p><ul><li>P(长江大桥|南京市) = 出现“南京市”时，出现“长江大桥”的概率；</li><li>P(江大桥|南京市长) = 出现“南京市长”时，出现“江大桥”的概率。</li></ul><p>提前准备好大量的中文语料，计算出任意两个词的条件概率，我们就可以得出哪种分词更合理。</p><p>在互联网领域，凡是遇到“当出现xyz时应该推荐什么”这样的条件概率时，也总是能应用贝叶斯理论。</p><p>例如，我们在搜索引擎中输入<code>elon</code>这个单词后，搜索框自动给出了联想补全：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-29-bayes-use/elon.png" alt="elon"></p><p>怎么实现这个功能？把用户最近搜索的所有可能的单词列出来，然后计算条件概率：</p><ul><li>P(mask|elon)=0.5</li><li>P(jerk|elon)=0.1</li><li>P(university|elon)=0.2</li><li>…</li></ul><p>把它们排个序，选出条件概率最大的几个，就是搜索建议。</p><p>诸如反垃圾邮件、电商推荐系统等，都是贝叶斯理论在机器学习中的应用。由于需要大量的计算，贝叶斯理论也只有在计算机时代才能广泛应用。</p><h3 id="关于信念">关于信念</h3><p>我们再回顾一下贝叶斯定理：</p><p>稍微改一下，变为：</p><p>P(H)是先验概率，P(H|E)是后验概率，P(E|H)/P(E)被称为调整因子，先验概率乘以调整因子就得到后验概率。</p><p>我们发现，如果P(H)=0，则P(H|E)=0；如果P(H)=1，则P(E|H)=P(E)，P(H|E)=1。</p><p>也就是说，如果先验概率为0%或100%，那么，无论出现任何证据E，都无法改变后验概率P(H|E)。这对我们看待世界的认知有重大指导意义，因为贝叶斯概率的本质是信念，通过一次次事件，我们可能加强某种信念，也可能减弱某种信念，但如果信念保持100%或0%，则可以做到对外界输入完全“免疫”。</p><p>举个例子，十年前许多人都认为比特币是庞氏骗局，如果100%坚定地持有这种信念，那么他将无视用户越来越多、价格上涨、交易量扩大、机构入市等诸多证据，至今仍然会坚信比特币是骗局而错过无数次机会。（注：此处示例不构成任何投资建议）</p><p>对于新生事物，每个人都可以有非常主观的先验概率，但只要我们不把先验概率定死为0或100%，就有机会改变自己的信念，从而更有可能接近客观事实，这也是贝叶斯定理的精髓：</p><blockquote><p>你相信什么并不重要，重要的是你别完全相信它。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文搞懂贝叶斯定理（原理篇）</title>
      <link href="/2023/08/27/%E6%95%B0%E5%AD%A6/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/"/>
      <url>/2023/08/27/%E6%95%B0%E5%AD%A6/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>托马斯·贝叶斯（Thomas Bayes）是18世纪的英国数学家，也是一位虔诚的牧师。据说他为了反驳对上帝的质疑而推导出贝叶斯定理。贝叶斯定理是一个由结果倒推原因的概率算法，在贝叶斯提出这个条件概率公式后，很长一段时间，大家并没有觉得它有什么作用，并一直受到主流统计学派的排斥。直到计算机诞生后，人们发现，贝叶斯定理可以广泛应用在数据分析、模式识别、统计决策，以及最火的人工智能中，结果，贝叶斯定理是如此有用，以至于不仅应用在计算机上，还广泛应用在经济学、心理学、博弈论等各种领域，可以说，掌握并应用贝叶斯定理，是每个人必备的技能。</p><p>这里推荐两个视频，深入浅出地解释了贝叶斯定理：</p><p><a href="https://www.youtube.com/watch?v=Pu675cHJ7bg">Bayes’ Theorem 贝叶斯定理</a></p><p><a href="https://www.youtube.com/watch?v=HZGCoVF3YvM">Bayes theorem, the geometry of changing beliefs</a></p><p>如果你不想花太多时间看视频，可以继续阅读，我把视频内容编译成文字，以便快速学习贝叶斯定理。</p><p>为了搞明白贝叶斯定理究竟要解决什么问题，我们先看一个现实生活的例子：</p><p>已知有一种疾病，发病率是0.1%。针对这种疾病的测试非常准确：</p><ul><li>如果有病，则准确率是99%（即有1%未检出阳性）；</li><li>如果没有病，则误报率是2%（即有2%误报为阳性）。</li></ul><p>现在，如果一个人测试显示阳性，请问他患病的概率是多少？</p><p>如果我们从大街上随便找一个人，那么他患病的概率就是0.1%，因为这个概率是基于历史统计数据的先验概率。</p><p>现在，他做了一次测试，结果为阳性，我们要计算他患病的概率，就是计算条件概率，即：在测试为阳性这一条件下，患病的概率是多少。</p><p>从直觉上这个人患病的概率大于0.1%，但也肯定小于99%。究竟是多少，怎么计算，我们先放一放。</p><p>为了理解条件概率，我们换一个更简单的例子：掷两次骰子，一共可能出现的结果有6x6=36种：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/sample-all.png" alt="sample space"></p><p>这就是所谓的样本空间，每个样本的概率均为1/36，这个很好理解。</p><p>如果我们定义事件A为：至少有一个骰子是2，那么事件A的样本空间如下图红色部分所示：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/sample-a.png" alt="Event A"></p><p>事件A一共有11种情况，我们计算事件A的概率P(A)：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/pa.png" alt="P(A)"></p><p>我们再定义事件B：两个骰子之和为7，那么事件B的样本空间如下图绿色部分所示：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/sample-b.png" alt="Event B"></p><p>事件B一共有6种情况，我们计算事件B的概率P(B)：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/pb.png" alt="P(B)"></p><p>接下来我们用P(A∩B)表示A和B同时发生的概率，A∩B就是A和B的交集，如下图蓝色部分所示：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/sample-p-a-and-b.png" alt="P(A∩B)"></p><p>显然A∩B只有两种情况，因此，计算P(A∩B)：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/p-a-and-b.png" alt="P(A∩B)"></p><p>接下来我们就可以讨论条件概率了。我们用P(A|B)表示在B发生的条件下，A发生的概率。由于B已经发生，所以，样本空间就是B的样本数量6，而要发生A则只能是A、B同时发生，即A∩B，有两种情况。</p><p>因此，计算P(A|B)如下：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/p-a-b.png" alt="P(A|B)"></p><p>同理，我们用P(B|A)表示在A发生的条件下，B发生的概率。此时，分子仍然是A∩B的样本数量，但分母变成A的样本数量：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/p-b-a.png" alt="P(B|A)"></p><p>可见，条件概率P(A|B)和P(B|A)是不同的。</p><p>我们再回到A、B同时发生的概率，观察P(A∩B)可以改写为：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/p-a-and-b-2.png" alt="P(B|A)xP(A)"></p><p>同理，P(A∩B)还可以改写为：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/p-a-and-b-3.png" alt="P(A|B)xP(B)"></p><p>因此，根据上述两个等式，我们推导出下面的等式：</p><p>把左边的<code>P(A∩B)</code>去掉，我们得到等式：</p><p>最后，整理一下等式，我们推导出贝叶斯定理如下：</p><p>这就是著名的贝叶斯定理，它表示，当出现B时，如何计算A的概率。</p><p>很多时候，我们把<code>A</code>改写为<code>H</code>，把<code>B</code>改写为<code>E</code>：</p><p>H表示Hypothesis（假设），E表示Evidence（证据），贝叶斯定理的意义就在于，给定一个先验概率P(H)，在出现了证据E的情况下，计算后验概率P(H|E)。</p><h3 id="计算">计算</h3><p>有了贝叶斯定理，我们就可以回到开头的问题：</p><p>已知有一种疾病，发病率是0.1%。针对这种疾病的测试非常准确：</p><ul><li>如果有病，则准确率是99%（即有1%未检出阳性）；</li><li>如果没有病，则误报率是2%（即有2%误报为阳性）。</li></ul><p>现在，如果一个人测试显示阳性，请问他患病的概率是多少？</p><p>用H表示患病，E表示测试为阳性，那么，我们要计算在测试为阳性的条件下，一个人患病的概率，就是计算P(H|E)。根据贝叶斯定理，计算如下：</p><p>P(H)表示患病的概率，根据发病率可知，P(H)=0.1%；</p><p>P(E|H)表示在患病的情况下，测试为阳性的概率，根据“如果有病，则准确率是99%”可知，P(E|H)=99%；</p><p>P(E)表示测试为阳性的概率。这个概率就稍微复杂点，因为它是指对所有人（包含病人和健康人）进行测试，结果阳性的概率。</p><p>我们可以把检测人数放大，例如放大到10万人，对10万人进行检测，根据发病率可知：</p><ul><li>有100人是病人，另外99900是健康人；</li><li>对100个病人进行测试，有99人显示阳性，另有1人未检出（阴性）；</li><li>对99900个健康人进行测试，有2%=1998人显示阳性（误报），另有98%=97902人为阴性。</li></ul><p>下图显示了检测为阳性的结果的分布：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">           ┌───────┐</span><br><span class="line">           │100000 │</span><br><span class="line">           └───────┘</span><br><span class="line">               │</span><br><span class="line">       ┌───────┴───────┐</span><br><span class="line">       ▼               ▼</span><br><span class="line">   ┌───────┐       ┌───────┐</span><br><span class="line">   │  100  │       │ 99900 │</span><br><span class="line">   └───────┘       └───────┘</span><br><span class="line">       │               │</span><br><span class="line">   ┌───┴───┐       ┌───┴───┐</span><br><span class="line">   ▼       ▼       ▼       ▼</span><br><span class="line">┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐</span><br><span class="line">│ 99  │ │  1  │ │1998 │ │97902│</span><br><span class="line">└─────┘ └─────┘ └─────┘ └─────┘</span><br><span class="line">   │               │</span><br><span class="line">   ▼               ▼</span><br><span class="line">   +               +</span><br></pre></td></tr></table></figure><p>所以，对于10万人的样本空间来说，事件E=显示阳性的概率为(99+1998)/100000=2.097%。</p><p>带入贝叶斯定理，计算P(H|E)：</p><p>计算结果为患病的概率为4.721%，这个概率远小于99%，且与大多数人的直觉不同，原因在于庞大的健康人群导致的误报数量远多于病人，当出现“检测阳性”的证据时，患病的概率从先验概率0.1%提升到4.721%，还远不足以确诊。</p><h3 id="贝叶斯定理的另一种表示">贝叶斯定理的另一种表示</h3><p>在上述计算中，我们发现计算P(E)是比较困难的，很多时候，甚至无法知道P(E)。此时，我们需要贝叶斯定理的另一种表示形式。</p><p>我们用P(H)表示H发生的概率，用H表示H不发生，P(H)表示H不发生的概率。显然P(H)=1-P(H)。</p><p>下图红色部分表示H，红色部分以外则表示H：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/ph.png" alt="P(H)"></p><p>事件E用绿色表示：</p><p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/pe.png" alt="P(E)"></p><p>可见，P(E)可以分为两部分，一部分是E和H的交集，另一部分是E和H的交集：</p><p>根据上文的公式P(A∩B)=P(A|B)xP(B)，代入可得：</p><p>把P(E)替换掉，我们得到贝叶斯定理的另一种写法：</p><p>用这个公式来计算，我们就不必计算P(E)了。再次回到开头的问题：</p><p>已知有一种疾病，发病率是0.1%。针对这种疾病的测试非常准确：</p><ul><li>如果有病，则准确率是99%（即有1%未检出阳性）；</li><li>如果没有病，则误报率是2%（即有2%误报为阳性）。</li></ul><p>现在，如果一个人测试显示阳性，请问他患病的概率是多少？</p><ul><li>P(E|H)表示患病时检测阳性的概率=99%；</li><li>P(H)表示患病的概率=0.1%；</li><li>P(E|H)表示没有患病但检测阳性的概率=2%；</li><li>P(H)表示没有患病的概率=1-P(H)=99.9%。</li></ul><p>代入公式，计算：</p><p>检测为阳性这一证据使得患病的概率从0.1%提升到4.721%。假设这个人又做了一次检测，结果仍然是阳性，那么他患病的概率是多少？</p><p>我们仍然使用贝叶斯定理计算，只不过现在先验概率P(H)不再是0.1%，而是4.721%，P(E|H)和P(E|H)仍保持不变，计算新的P(H|E)：</p><p>结果为71%，两次检测为阳性的结果使得先验概率从0.1%提升到4.721%再提升到71%，继续第三次检测如果为阳性则概率将提升至99.18%。</p><p>可见，贝叶斯定理的核心思想就是不断根据新的证据，将先验概率调整为后验概率，使之更接近客观事实。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracelBD基础</title>
      <link href="/2021/05/09/oracelBD%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/05/09/oracelBD%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1>OracleDB 笔记整理</h1><h2 id="1-SQL-分类">1. SQL 分类</h2><table><thead><tr><th>分类</th><th>说明</th><th>关键字</th></tr></thead><tbody><tr><td><strong>DML</strong> (Data Manipulation Language)</td><td>数据操作语言</td><td><code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>MERGE</code></td></tr><tr><td><strong>DDL</strong> (Data Definition Language)</td><td>数据定义语言</td><td><code>CREATE</code>, <code>ALTER</code>, <code>DROP</code>, <code>RENAME</code>, <code>TRUNCATE</code>, <code>COMMENT</code></td></tr><tr><td><strong>DCL</strong> (Data Control Language)</td><td>数据控制语言</td><td><code>GRANT</code>, <code>REVOKE</code></td></tr><tr><td><strong>事务</strong> (Transaction)</td><td>事务控制</td><td><code>COMMIT</code>, <code>ROLLBACK</code>, <code>SAVEPOINT</code></td></tr></tbody></table><h2 id="2-OracleDB-构成">2. OracleDB 构成</h2><h3 id="2-1-基本构成">2.1 基本构成</h3><p>OracleDB 由 <strong>Oracle实例(instance)</strong> 和 <strong>Database</strong> 构成：</p><ul><li><strong>实例(Instance)</strong> 由：<ul><li><strong>SGA(System Global Area)</strong>：内存区域</li><li><strong>Background Process</strong>：后台进程</li></ul></li><li><strong>Database</strong> 由：<ul><li>控制文件（制御ファイル）</li><li>REDO 文件（REDO ログ）</li><li>数据文件（データファイル）</li></ul></li></ul><h3 id="2-2-进程视角">2.2 进程视角</h3><p>除了实例中的 <strong>Background Process</strong>，还包括：</p><ul><li>用户进程</li><li>服务器进程</li><li>监听进程</li></ul><h3 id="2-3-工具列表">2.3 工具列表</h3><h4 id="安装和升级相关工具">安装和升级相关工具</h4><table><thead><tr><th>工具名</th><th>用途</th></tr></thead><tbody><tr><td>Oracle Universal Installer (OUI)</td><td>安装 Oracle 软件</td></tr><tr><td>Oracle Database Configuration Assistant (DBCA)</td><td>创建数据库</td></tr><tr><td>Oracle Database Upgrade Assistant (DBUA)</td><td>升级现有数据库到新版本</td></tr></tbody></table><h4 id="网络相关工具">网络相关工具</h4><table><thead><tr><th>工具名</th><th>用途</th></tr></thead><tbody><tr><td>Oracle Net Manager (netmgr)</td><td>配置 Oracle 网络</td></tr><tr><td>Oracle Net Configuration Assistant (netca)</td><td>配置 Oracle 网络</td></tr></tbody></table><h4 id="实例和数据库管理工具">实例和数据库管理工具</h4><table><thead><tr><th>工具名</th><th>用途</th></tr></thead><tbody><tr><td>Oracle Enterprise Manager (EM)</td><td>管理 Oracle DB</td></tr><tr><td>SQL*Plus</td><td>SQL 命令行工具</td></tr><tr><td>SQL Developer</td><td>图形化数据库管理工具</td></tr><tr><td>Recovery Manager (RMAN)</td><td>数据库备份、恢复、复原</td></tr><tr><td>Oracle Secure Backup</td><td>备份管理</td></tr><tr><td>Data Pump</td><td>数据库间高速数据传输</td></tr><tr><td>SQL*Loader</td><td>外部文件数据批量导入</td></tr></tbody></table><h2 id="3-安装">3. 安装</h2><h3 id="3-1-OUI-功能">3.1 OUI 功能</h3><ul><li>显示已安装的 Oracle 软件</li><li>安装新软件</li><li>删除软件</li><li>查看在线帮助</li><li>检查安装需求</li></ul><h3 id="3-2-系统要求">3.2 系统要求</h3><ul><li><strong>内存</strong>：1GB</li><li><strong>SWAP</strong>：1.5GB</li><li><strong>硬盘空间</strong>：<ul><li>最小 1GB</li><li>一般需要 6.1GB</li></ul></li></ul><h3 id="3-3-创建用户和组">3.3 创建用户和组</h3><ul><li><strong>软件所有者</strong>：Oracle 用户</li><li><strong>Oracle Inventory Group</strong>：用于管理 Oracle 软件</li><li><strong>DB 管理组</strong>：<ul><li><code>OSDBA</code>：数据库管理员组</li><li><code>OSOPER</code>：受限制的数据库管理员组</li></ul></li></ul><h3 id="3-4-环境变量">3.4 环境变量</h3><table><thead><tr><th>变量名</th><th>说明</th></tr></thead><tbody><tr><td><code>ORACLE_BASE</code></td><td>Oracle 主目录</td></tr><tr><td><code>ORACLE_HOME</code></td><td>Oracle 软件安装位置</td></tr><tr><td><code>ORACLE_SID</code></td><td>系统标识（实例名）</td></tr><tr><td><code>LD_LIBRARY_PATH</code></td><td>共享库路径（如 <code>$ORACLE_HOME/lib</code>）</td></tr></tbody></table><h3 id="3-5-安装脚本">3.5 安装脚本</h3><table><thead><tr><th>脚本名</th><th>用途</th></tr></thead><tbody><tr><td><code>orainstRoot.sh</code></td><td>生成 inventory pointer 文件</td></tr><tr><td><code>root.sh</code></td><td>生成 <code>oratab</code> 并设置环境变量 (<code>oraenv</code> 和 <code>coraenv</code>)，指定 <code>dbstart</code> 和 <code>dbshut</code> 脚本</td></tr></tbody></table><h3 id="3-6-创建数据库（DBCA）">3.6 创建数据库（DBCA）</h3><h4 id="3-6-1-指定-Global-DB-名">3.6.1 指定 Global DB 名</h4><p>格式：<code>database_name.domain_name</code></p><h4 id="3-6-2-Enterprise-Manager-选项">3.6.2 Enterprise Manager 选项</h4><ul><li><strong>Database Express</strong>：单数据库管理</li><li><strong>Cloud Control</strong>：集中管理多个数据库（需预先安装 Cloud Control）</li></ul><h4 id="3-6-3-存储类型">3.6.3 存储类型</h4><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>文件系统</td><td>使用操作系统文件</td></tr><tr><td>ASM (Automatic Storage Management)</td><td>文件存储在 ASM 磁盘组，需额外实例</td></tr></tbody></table><h4 id="3-6-4-数据库文件位置">3.6.4 数据库文件位置</h4><ul><li><strong>使用模板的文件位置</strong></li><li><strong>所有数据库文件共享文件夹</strong></li><li><strong>Oracle Managed Files</strong>：由 Oracle 直接管理文件</li></ul><h4 id="3-6-5-模板">3.6.5 模板</h4><p>模板包含以下信息：</p><ul><li>数据库选项</li><li>初始化参数</li><li>存储属性（数据文件、表空间、控制文件、REDO 日志属性）</li></ul><h5 id="模板分类">模板分类</h5><table><thead><tr><th>模板类型</th><th>说明</th></tr></thead><tbody><tr><td>通用事务处理（默认）</td><td>适用于 OLTP 场景</td></tr><tr><td>数据仓库 (Data Warehouse)</td><td>适用于复杂查询和大数据处理</td></tr><tr><td>自定义模板</td><td>用户自定义配置</td></tr></tbody></table><h5 id="模板形式">模板形式</h5><table><thead><tr><th>形式</th><th>说明</th></tr></thead><tbody><tr><td>Sheet Template</td><td>包含现有数据库结构和物理文件</td></tr><tr><td>Non-Sheet Template</td><td>仅包含数据库特性</td></tr></tbody></table><h2 id="4-EM-Express">4. EM Express</h2><h3 id="4-1-功能">4.1 功能</h3><ul><li>提供数据库管理功能（<strong>不包括启动/停止数据库</strong>）</li><li>如需启动/停止数据库，需使用 <strong>Oracle Enterprise Manager Cloud Control</strong></li></ul><h3 id="4-2-手动配置-EM-Express">4.2 手动配置 EM Express</h3><ol><li><strong>启动监听进程</strong></li><li><strong>初始化 <code>DISPATCHERS</code> 参数</strong>（设置 <code>PROTOCOL=TCP</code>）：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatchers<span class="operator">=</span>&quot;(PROTOCOL=TCP)(SERVICE=&lt;sid&gt;XDB)&quot;</span><br></pre></td></tr></table></figure></li><li><strong>设置端口</strong>（需 <code>SYSDBA</code> 权限）：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> DBMS_XDB_CONFIG.setHTTPSPORT(<span class="number">5500</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-3-使用-EM-Express">4.3 使用 EM Express</h3><h4 id="4-3-1-查询-EM-Express-端口">4.3.1 查询 EM Express 端口</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DBMS_XDB_CONFIG.getHTTPSPort <span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure><h4 id="4-3-2-权限分配">4.3.2 权限分配</h4><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td><code>EM_EXPRESS_BASIC</code></td><td>只读模式</td></tr><tr><td><code>EM_EXPRESS_ALL</code></td><td>完全权限</td></tr></tbody></table><h3 id="4-4-连接数据库">4.4 连接数据库</h3><h4 id="4-4-1-SQL-Plus-连接方式">4.4.1 SQL*Plus 连接方式</h4><ol><li>运行 <code>oraenv</code> 设置环境变量：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. oraenv</span><br></pre></td></tr></table></figure></li><li>启动 SQL*Plus（<code>/nolog</code> 表示不登录数据库）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlplus /nolog</span><br></pre></td></tr></table></figure></li><li>连接数据库：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span><span class="operator">/</span><span class="operator">&lt;</span>密码<span class="operator">&gt;</span> [<span class="keyword">AS</span> SYSDBA <span class="operator">|</span> <span class="keyword">AS</span> SYSOPER]</span><br></pre></td></tr></table></figure></li><li>其他功能：<ul><li>执行 SQL 脚本：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="operator">&lt;</span><span class="keyword">sql</span>文件名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li><li>执行操作系统命令：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOST <span class="operator">&lt;</span>命令<span class="operator">&gt;</span>  # 例如：HOST ls</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="4-4-2-SQL-Developer-连接方式">4.4.2 SQL Developer 连接方式</h4><ol><li>运行 <code>oraenv</code> 设置环境变量：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. oraenv</span><br></pre></td></tr></table></figure></li><li>启动 SQL Developer：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$ORACLE_HOME</span>/sqldeveloper</span><br><span class="line">sh sqldeveloper.sh</span><br></pre></td></tr></table></figure></li><li>功能：<ul><li><strong>普通模式</strong>：查看、创建、编辑、删除表、视图等对象</li><li><strong>DBA Navigator</strong>：连接 DBA 用户后可启动/停止数据库</li></ul></li></ol><h2 id="5-Oracle-网络构成">5. Oracle 网络构成</h2><h3 id="5-1-Oracle-Net-概述">5.1 Oracle Net 概述</h3><ul><li><strong>功能</strong>：提供网络服务</li><li><strong>安装方式</strong>：随 Oracle 数据库软件或客户端一同安装</li><li><strong>通信模式</strong>：<ul><li><strong>客户端-服务端模式</strong>：两端均需安装 Oracle Net</li><li><strong>客户端-Web 服务器-DB 服务器模式</strong>：客户端和 Web 服务器需安装 Oracle Net</li></ul></li></ul><h3 id="5-2-通信条件">5.2 通信条件</h3><table><thead><tr><th><strong>角色</strong></th><th><strong>要求</strong></th></tr></thead><tbody><tr><td><strong>DB 服务端</strong></td><td>1. 网络服务器在线<br>2. 已安装 Oracle DB<br>3. 支持 TCP/IP 协议<br>4. 监听进程已启动</td></tr><tr><td><strong>客户端</strong></td><td>1. 网络服务器在线<br>2. 已安装 Oracle 客户端<br>3. 支持 TCP/IP 协议</td></tr></tbody></table><h3 id="5-3-监听进程">5.3 监听进程</h3><ul><li><p><strong>自动安装</strong>：通过 OUI 初始化 DB 时，NetCA 会默认安装监听进程</p></li><li><p><strong>作用</strong>：处理客户端连接请求（连接建立后不再参与通信）</p></li><li><p><strong>关键命令</strong>：</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>lsnrctl start &lt;监听进程名&gt;</code></td><td>启动监听进程</td></tr><tr><td><code>lsnrctl stop &lt;监听进程名&gt;</code></td><td>停止监听进程</td></tr><tr><td><code>lsnrctl status &lt;监听进程名&gt;</code></td><td>查看状态</td></tr><tr><td><code>lsnrctl services &lt;监听进程名&gt;</code></td><td>查看支持的服务</td></tr><tr><td><code>LSNRCTL&gt; set current_listener &lt;名称&gt;</code></td><td>切换监听进程（需交互模式）</td></tr></tbody></table></li></ul><h3 id="5-4-客户端构成">5.4 客户端构成</h3><ul><li><strong>数据库连接示例</strong>：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> hr@(DESCRIPTION <span class="operator">=</span> </span><br><span class="line">  (ADDRESS <span class="operator">=</span> (PROTOCOL <span class="operator">=</span> TCP)(HOST <span class="operator">=</span> proj1<span class="operator">-</span>sv)(PORT <span class="operator">=</span> <span class="number">1521</span>))</span><br><span class="line">  (CONNECT_DATA <span class="operator">=</span> (SERVICE_NAME <span class="operator">=</span> sales.edifist.com)))</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-5-命名方法">5.5 命名方法</h3><table><thead><tr><th><strong>类型</strong></th><th><strong>存储位置</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>本地命名</strong></td><td>客户端 <code>tnsnames.ora</code></td><td>网络服务名映射存储在本地文件</td></tr><tr><td><strong>LDAP 基准</strong></td><td>LDAP 服务器</td><td>集中管理服务名映射</td></tr><tr><td><strong>简易连接命名</strong></td><td>无</td><td>直接使用 TCP/IP 连接字符串（如 <code>connect scott@host名/服务名</code>）</td></tr><tr><td><strong>外部命名</strong></td><td>第三方命名服务（如 NIS）</td><td>依赖非 Oracle 服务</td></tr></tbody></table><h4 id="本地命名配置方法">本地命名配置方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netca  <span class="comment"># 启动图形化配置工具</span></span><br></pre></td></tr></table></figure><h4 id="简易连接示例">简易连接示例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlplus <span class="operator">/</span>nolog</span><br><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">CONNECT</span> hr<span class="operator">/</span>hr<span class="variable">@oracle_sv</span><span class="operator">/</span>orcl.edifist.com</span><br></pre></td></tr></table></figure><hr><h2 id="6-数据库服务器架构概要">6. 数据库服务器架构概要</h2><h3 id="6-1-核心组件">6.1 核心组件</h3><ul><li><strong>Oracle 实例</strong>：内存结构（SGA） + 后台进程</li><li><strong>Oracle 数据库</strong>：物理文件集合</li></ul><h3 id="6-2-SGA-System-Global-Area-构成">6.2 SGA (System Global Area) 构成</h3><table><thead><tr><th><strong>组件</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td><strong>数据库缓存</strong></td><td>存储数据块（Buffer Cache）</td></tr><tr><td><strong>REDO 日志 Buffer</strong></td><td>记录数据变更历史</td></tr><tr><td><strong>共享池</strong></td><td>缓存 SQL/PLSQL 解析结果、执行计划、数据字典</td></tr><tr><td><strong>Large Pool</strong></td><td>可选，用于共享服务器模式、并行查询、RMAN 备份等</td></tr><tr><td><strong>Java Pool</strong></td><td>支持 Java 虚拟机（JVM）</td></tr><tr><td><strong>Stream Pool</strong></td><td>支持 Oracle Stream 数据复制</td></tr></tbody></table><h3 id="6-3-关键后台进程">6.3 关键后台进程</h3><table><thead><tr><th><strong>进程</strong></th><th><strong>名称</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td><strong>SMON</strong></td><td>System Monitor</td><td>实例恢复（如崩溃后自动修复）</td></tr><tr><td><strong>PMON</strong></td><td>Process Monitor</td><td>清理异常终止的用户进程资源</td></tr><tr><td><strong>DBWn</strong></td><td>Database Writer</td><td>将脏缓冲区写入数据文件</td></tr><tr><td><strong>CKPT</strong></td><td>Checkpoint</td><td>触发 DBWn 写入，更新控制文件（用于灾难恢复）</td></tr><tr><td><strong>LGWR</strong></td><td>Log Writer</td><td>将 REDO 日志缓冲区写入磁盘</td></tr><tr><td><strong>ARCn</strong></td><td>Archiver</td><td>归档 REDO 日志</td></tr><tr><td><strong>MMON</strong></td><td>Manageability Monitor</td><td>执行 AWR（自动工作负载仓库）相关任务</td></tr></tbody></table><h3 id="6-4-用户与服务器进程">6.4 用户与服务器进程</h3><ul><li><strong>用户进程</strong>：运行应用程序（如 SQL*Plus）</li><li><strong>服务器进程</strong>：处理用户提交的 SQL 查询</li></ul><h3 id="6-5-PGA-Program-Global-Area">6.5 PGA (Program Global Area)</h3><ul><li><strong>特点</strong>：非共享内存，仅限单个进程访问</li><li><strong>用途</strong>：存储 SQL 执行时的排序区、会话信息等</li></ul><hr><h2 id="7-实例启停">7. 实例启停</h2><h3 id="7-1-启动方法">7.1 启动方法</h3><ul><li>SQL*Plus（<code>STARTUP</code> 命令）</li><li>Windows 服务管理器</li><li>SQL Developer</li><li>Enterprise Manager Cloud Control</li></ul><h3 id="7-2-启动状态迁移">7.2 启动状态迁移</h3><table><thead><tr><th><strong>状态</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>NOMOUNT</strong></td><td>读取参数文件，分配 SGA，启动后台进程（控制文件未打开）</td></tr><tr><td><strong>MOUNT</strong></td><td>打开控制文件（获知数据文件/日志文件路径，但未打开文件）</td></tr><tr><td><strong>OPEN</strong></td><td>打开所有数据文件和 REDO 日志，数据库可用</td></tr></tbody></table><h3 id="7-3-权限要求">7.3 权限要求</h3><table><thead><tr><th><strong>权限</strong></th><th><strong>能力</strong></th></tr></thead><tbody><tr><td><strong>SYSDBA</strong></td><td>完全控制（包括启停实例、用户授权）</td></tr><tr><td><strong>SYSOPER</strong></td><td>仅限启停实例（无权管理用户对象）</td></tr></tbody></table><h4 id="连接示例">连接示例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> 用户名<span class="operator">/</span>密码 <span class="keyword">AS</span> &#123;SYSOPER <span class="operator">|</span> SYSDBA&#125;</span><br><span class="line">sqlplus <span class="operator">/</span>nolog</span><br><span class="line"><span class="keyword">CONNECT</span> sys <span class="keyword">AS</span> sysdba</span><br><span class="line">STARTUP</span><br></pre></td></tr></table></figure><h3 id="7-4-停止流程">7.4 停止流程</h3><ol><li><strong>关闭数据库</strong>（OPEN → CLOSED）<ul><li>执行 Checkpoint，写入数据文件和 REDO 日志</li><li>关闭数据文件和 REDO 日志（控制文件仍打开）</li></ul></li><li><strong>卸载数据库</strong>（CLOSED → DISMOUNT）<ul><li>实例与数据库分离</li></ul></li><li><strong>停止实例</strong>（DISMOUNT → SHUTDOWN）<ul><li>终止后台进程，释放 SGA 内存</li></ul></li></ol><h3 id="7-5-停止模式对比">7.5 停止模式对比</h3><table><thead><tr><th><strong>行为</strong></th><th>NORMAL</th><th>TRANSACTIONAL</th><th>IMMEDIATE</th><th>ABORT</th></tr></thead><tbody><tr><td>接受新连接</td><td>×</td><td>×</td><td>×</td><td>×</td></tr><tr><td>等待当前会话结束</td><td>✓</td><td>✓</td><td>×</td><td>×</td></tr><tr><td>等待当前事务结束</td><td>✓</td><td>✓</td><td>✓</td><td>×</td></tr><tr><td>执行 Checkpoint 后关闭</td><td>✓</td><td>✓</td><td>✓</td><td>×</td></tr></tbody></table><h3 id="7-6-初始化参数文件">7.6 初始化参数文件</h3><table><thead><tr><th><strong>类型</strong></th><th><strong>名称</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>静态</strong></td><td>PFILE（文本文件）</td><td>手动编辑，需重启生效</td></tr><tr><td><strong>动态</strong></td><td>SPFILE（二进制文件）</td><td>支持在线修改（<code>ALTER SYSTEM</code>），优先使用</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
          <category> oracleDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracleDB </tag>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPC</title>
      <link href="/2021/01/12/VPC/"/>
      <url>/2021/01/12/VPC/</url>
      
        <content type="html"><![CDATA[<ol><li><p>Security Group(SG):</p><ol><li>所有设定默认是拒绝，只可以设定许可规则，拒否ルールは指定できません。</li><li>特征是不单可以指定CIDR等IP,还可以指定SG</li><li>安全组是有状态的 — 如果您从实例发送一个请求，则无论入站安全组规则如何，都将允许该请求的响应流量流入。如果是为响应已允许的入站流量，则该响应可以出站，此时可忽略出站规则。セキュリティグループはステートフルです。</li></ol></li><li><p>Access Control List(ACL):</p><ol><li>VPC 自动带有可修改的默认网络 ACL。默认情况下，它允许所有入站和出站 IPv4 流量以及 IPv6 流量 (如果适用)。</li><li>可以创建自定义网络 ACL 并将其与子网相关联。默认情况下，每个自定义网络 ACL 都拒绝所有入站和出站流量，直至您添加规则。</li><li>VPC 中的每个子网都必须与一个网络 ACL 相关联。如果您没有明确地将子网与网络 ACL 相关联，则子网将自动与默认网络 ACL 关联。</li><li>可以将网络 ACL 与多个子网关联。但是，一个子网一次只能与一个网络 ACL 关联。当您将一个网络 ACL 与一个子网关联时，将删除之前的关联。</li><li>网络 ACL 包含规则的编号列表。我们按顺序评估（从编号最小的规则开始）规则，以判断是否允许流量进入或离开任何与网络 ACL 关联的子网。您可以使用的最高规则编号为 32766。我们建议您开始先以增量方式创建规则（例如，以 10 或 100 的增量增加），这样您可以在稍后需要时插入新的规则。</li><li>网络 ACL 有单独的入站和出站规则，每项规则都或是允许或是拒绝数据流。</li><li>网络 ACL 没有任何状态，这意味着对允许入站数据流的响应会随着出站数据流规则的变化而改变（反之亦然）。(ネットワーク ACL はステートレスです。許可されているインバウンドトラフィックに対する応答は、アウトバウンドトラフィックのルールに従います（その逆の場合も同様です）。)</li><li>ルール番号。ルールは、最も低い番号のルールから評価されます。ルールがトラフィックに一致すると、それと相反するより高い数値のルールの有無にかかわらず、すぐに適用されます。</li><li>タイプ。トラフィックのタイプ（SSH など）。また、すべてのトラフィックまたはカスタム範囲を指定することもできます。</li></ol></li></ol><p>セキュリティグループはステートフルです。（レスポンスでも明示する必要なしで許可。）<br>ACLはステートレスです。（レスポンスでも明示する必要ある。）</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> AWS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17.系统维护</title>
      <link href="/2020/11/17/linux/17-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4/"/>
      <url>/2020/11/17/linux/17-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<h1>从源代码安装软件笔记整理</h1><h2 id="1-安装C语言开源软件的三个主要步骤">1. 安装C语言开源软件的三个主要步骤</h2><ol><li>解压源代码</li><li>编译成二进制文件</li><li>将二进制文件安装到适当的文件夹</li></ol><h2 id="2-解压源代码">2. 解压源代码</h2><h3 id="常用解压命令">常用解压命令</h3><table><thead><tr><th>命令格式</th><th>说明</th></tr></thead><tbody><tr><td><code>gunzip [文件名]</code></td><td>解压.gz文件</td></tr><tr><td><code>gzip [option] [文件名]</code></td><td>压缩/解压文件</td></tr><tr><td><code>bunzip [文件名]</code></td><td>解压.bz2文件</td></tr><tr><td><code>bzip [option] [文件名]</code></td><td>压缩/解压文件</td></tr></tbody></table><h3 id="gzip-bzip-选项说明">gzip/bzip 选项说明</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-d</code></td><td>解压压缩文件</td></tr><tr><td><code>-c</code></td><td>解压压缩文件到标准输出</td></tr></tbody></table><h2 id="3-patch命令">3. patch命令</h2><p>用于应用补丁文件</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-d 文件夹</code></td><td>移动到指定文件夹后处理</td></tr><tr><td><code>-p</code></td><td>修正patch文件内的path: <br><code>-p0</code>: 不修正path <br><code>-p1</code>: 删除最初的’/’ <br><code>-p2</code>: 删除下一级文件夹</td></tr><tr><td><code>patch</code></td><td>应用补丁</td></tr><tr><td><code>-C</code></td><td>测试(不实际应用补丁)</td></tr><tr><td><code>-R</code></td><td>取消补丁，恢复到补丁前状态</td></tr></tbody></table><h2 id="4-生成Makefile">4. 生成Makefile</h2><p>运行config脚本根据环境配置config文件:</p><h3 id="config脚本主要选项">config脚本主要选项</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>--help</code></td><td>显示帮助说明</td></tr><tr><td><code>--prefix=文件夹</code></td><td>指定安装目标的top路径</td></tr></tbody></table><h2 id="5-编译和安装">5. 编译和安装</h2><h3 id="make命令">make命令</h3><p>根据当前文件夹内的Makefile编译源代码</p><p>基本格式：</p><pre><code class="language-bash">make [option] [目标]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16.网络</title>
      <link href="/2020/11/16/linux/16-%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/11/16/linux/16-%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="1-网络设备管理">1. 网络设备管理</h2><h3 id="1-1-网络接口命名规则">1.1 网络接口命名规则</h3><table><thead><tr><th>接口名称</th><th>说明</th></tr></thead><tbody><tr><td><code>eth0</code></td><td>第一个 Ethernet 接口</td></tr><tr><td><code>eth1</code></td><td>第二个 Ethernet 接口</td></tr><tr><td><code>ppp0</code></td><td>第一个 PPP 接口</td></tr><tr><td><code>lo</code></td><td>Loopback 接口</td></tr></tbody></table><h3 id="1-2-网络设备识别命令">1.2 网络设备识别命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep eth  <span class="comment"># 查看内核识别的网络设备</span></span><br></pre></td></tr></table></figure><h3 id="1-3-网络接口配置命令">1.3 网络接口配置命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig [-a] [IF名] [参数]</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-a</code></td><td>显示所有接口</td></tr><tr><td><code>IF名</code></td><td>指定接口名称</td></tr><tr><td><code>IP地址</code></td><td>设置 IP 地址</td></tr><tr><td><code>netmask</code></td><td>设置子网掩码</td></tr><tr><td><code>up</code></td><td>激活接口（等价于 <code>ifup</code>）</td></tr><tr><td><code>down</code></td><td>停止接口（等价于 <code>ifdown</code>）</td></tr></tbody></table><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.120.27 netmask 255.255.255.0 up</span><br></pre></td></tr></table></figure><h3 id="1-4-NIC-组合与虚拟网络接口">1.4 NIC 组合与虚拟网络接口</h3><ul><li><strong>NIC 组合</strong>：允许将多个物理以太网适配器分组为虚拟网络适配器，提高性能和容错能力。</li><li><strong>MAC 地址设置</strong>：在 “交换机独立” 模式下，团队会将 MAC 地址设置为出站流量。</li><li><strong>IP 别名</strong>：在同一个网卡上分配不同 IP 地址。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0:0 192.168.0.1 netmask 255.255.255.0 up</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-ARP-协议管理">2. ARP 协议管理</h2><h3 id="2-1-ARP-协议简介">2.1 ARP 协议简介</h3><p>ARP (Address Resolution Protocol) 用于将 IP 地址解析为 MAC 地址。</p><h3 id="2-2-ARP-命令">2.2 ARP 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp [option]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-a [host]</code></td><td>显示指定主机或全部 ARP 表</td></tr><tr><td><code>-f 文件名</code></td><td>从文件读取主机:MAC 对应表</td></tr><tr><td><code>-n</code></td><td>显示 IP 地址而非主机名</td></tr><tr><td><code>-d [host]</code></td><td>删除指定主机的 ARP 记录</td></tr><tr><td><code>-i [IF名]</code></td><td>指定接口</td></tr><tr><td><code>-s [host] [MAC地址]</code></td><td>添加主机和 MAC 地址的对应关系</td></tr></tbody></table><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp -s h001.example.com 00:01:02:03:04:05</span><br></pre></td></tr></table></figure><h3 id="2-3-ARP-监视工具">2.3 ARP 监视工具</h3><ul><li><code>arpwatch</code>：监视网络中的 ARP 活动。</li></ul><h2 id="3-网络管理命令">3. 网络管理命令</h2><h3 id="3-1-Ping-命令">3.1 Ping 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping [host名或IP] [option]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-n</code></td><td>不解析主机名，显示 IP 地址</td></tr><tr><td><code>-c 次数</code></td><td>发送指定次数的 ICMP 包</td></tr><tr><td><code>-i 间隔</code></td><td>按指定间隔发送 ICMP 包</td></tr></tbody></table><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 4 192.168.1.1</span><br></pre></td></tr></table></figure><h3 id="3-2-Traceroute-命令">3.2 Traceroute 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute [option] [host名或IP]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-i [IF]</code></td><td>指定接口</td></tr><tr><td><code>-n</code></td><td>显示 IP 地址而非主机名</td></tr></tbody></table><h3 id="3-3-Tcpdump-命令">3.3 Tcpdump 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump [option] [条件式]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-i IF名</code></td><td>指定监视的接口</td></tr><tr><td><code>-s 比特数</code></td><td>指定从包中提取的比特数</td></tr><tr><td><code>-X</code></td><td>显示十六进制和 ASCII 文本</td></tr><tr><td><code>-n</code></td><td>不解析 ARP 地址</td></tr><tr><td><code>-l</code></td><td>缓存标准输出</td></tr><tr><td><code>-t</code></td><td>不显示时间</td></tr><tr><td><code>-v</code></td><td>显示详细信息</td></tr></tbody></table><p><strong>条件式</strong>:</p><ul><li><code>port</code>：指定端口</li></ul><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nli eth0 port 53</span><br></pre></td></tr></table></figure><h3 id="3-4-Wireshark">3.4 Wireshark</h3><ul><li>图形化网络监视工具。</li></ul><h3 id="3-5-Netstat-命令">3.5 Netstat 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [option]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-a</code></td><td>显示所有 socket</td></tr><tr><td><code>-c</code></td><td>每秒刷新</td></tr><tr><td><code>-i</code></td><td>显示接口状态</td></tr><tr><td><code>-l</code></td><td>只显示监听状态的端口</td></tr><tr><td><code>-n</code></td><td>显示地址和端口</td></tr><tr><td><code>-p</code></td><td>显示 PID 和进程</td></tr><tr><td><code>-r</code></td><td>显示路由表</td></tr><tr><td><code>-t</code></td><td>显示 TCP 连接</td></tr><tr><td><code>-u</code></td><td>显示 UDP 连接</td></tr></tbody></table><h3 id="3-6-IP-命令">3.6 IP 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip [option] 操作对象 [命令] [设备]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-s</code></td><td>显示状态</td></tr><tr><td><code>-r</code></td><td>解析名称</td></tr></tbody></table><p><strong>操作对象</strong>:</p><ul><li><code>link</code>：接口详细信息</li><li><code>addr</code>：IP 地址</li><li><code>route</code>：路由表</li><li><code>neigh</code>：ARP 缓存</li></ul><p><strong>命令</strong>:</p><ul><li><code>show</code>：显示指定对象</li><li><code>add</code>：设置指定对象的参数</li></ul><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip <span class="built_in">link</span> show eth0</span><br></pre></td></tr></table></figure><h2 id="4-路由设置">4. 路由设置</h2><h3 id="4-1-Route-命令">4.1 Route 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route [option]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-n</code></td><td>不解析主机名</td></tr><tr><td><code>-F</code></td><td>显示内核路由表</td></tr><tr><td><code>-C</code></td><td>显示内核路由缓存</td></tr></tbody></table><p><strong>路由表项目</strong>:</p><ul><li><code>Destination</code>：目标网络或主机</li><li><code>Gateway</code>：网关</li><li><code>Genmask</code>：目标子网掩码</li><li><code>Flags</code>：路由状态（U:有效, H:目标主机, G:使用网关, !:无效）</li><li><code>Metric</code>：到达目标的距离</li><li><code>Ref</code>：路由引用数</li><li><code>Use</code>：路径引用次数</li><li><code>Iface</code>：使用的接口</li></ul><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">route add -net 192.168.100.0 netmask 255.255.255.0 gw 172.16.0.1</span><br><span class="line">route add default gw 192.168.0.50</span><br><span class="line">route del -net 192.168.100.0 netmask 255.255.255.0 gw 172.16.0.1</span><br></pre></td></tr></table></figure><h2 id="5-无线网络设置">5. 无线网络设置</h2><h3 id="5-1-无线规格与安全标准">5.1 无线规格与安全标准</h3><table><thead><tr><th>规格</th><th>频率</th><th>传送速度</th></tr></thead><tbody><tr><td>IEEE 802.11a</td><td>5.2GHz</td><td>54Mbps</td></tr><tr><td>IEEE 802.11b</td><td>2.4GHz</td><td>11Mbps</td></tr><tr><td>IEEE 802.11g</td><td>2.4GHz</td><td>54Mbps</td></tr><tr><td>IEEE 802.11n</td><td>2.4GHz/5GHz</td><td>600Mbps</td></tr><tr><td>IEEE 802.11ac</td><td>5GHz</td><td>433Mbps~7Gbps</td></tr></tbody></table><p><strong>安全标准</strong>:</p><ul><li><strong>WEP</strong>：使用 RC4 算法，存在漏洞。</li><li><strong>WPA</strong>：多种加密技术（TKIP, AES），用户认证由 IEEE 802.1x 等实现。WPA-AES 比 WPA-TKIP 更安全。</li></ul><h3 id="5-2-无线接口状态确认">5.2 无线接口状态确认</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iwconfig [wlanN] [essid ESSID] [key [s:]WEP key]</span><br></pre></td></tr></table></figure><p><strong>示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iwconfig wlan0 essid <span class="string">&quot;windsor&quot;</span></span><br><span class="line">iwconfig wlan0 key s:abc12345</span><br></pre></td></tr></table></figure><h3 id="5-3-获取无线接口信息">5.3 获取无线接口信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iwlist [无线IF] [参数]</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>scanning [essid ID]</code></td><td>显示可接入的热点列表</td></tr><tr><td><code>channel</code></td><td>显示可设置的频道</td></tr><tr><td><code>rate</code></td><td>显示传送速度</td></tr></tbody></table><h2 id="6-高级网络设置">6. 高级网络设置</h2><h3 id="6-1-网络相关文件">6.1 网络相关文件</h3><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td><code>/etc/hostname</code></td><td>记录主机名</td></tr><tr><td><code>/etc/hosts</code></td><td>记录主机名、别名和 IP 的对应关系</td></tr><tr><td><code>/etc/networks</code></td><td>记录网络和 IP 的对应关系</td></tr><tr><td><code>/etc/nsswitch.conf</code></td><td>规定信息查找顺序</td></tr><tr><td><code>/etc/resolv.conf</code></td><td>记录 DNS 服务器和域名</td></tr><tr><td><code>/etc/sysconfig/network</code></td><td>网络功能、主机名、默认网关等设置</td></tr><tr><td><code>/etc/sysconfig/network-scripts/</code></td><td>存放网络接口设置文件</td></tr><tr><td><code>/etc/network/interfaces</code></td><td>Debian 系统的网络接口设置文件</td></tr></tbody></table><h3 id="6-2-配置文件示例">6.2 配置文件示例</h3><p><strong>/etc/sysconfig/network-scripts/ifcfg-eth0</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth0</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=192.168.0.6</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">NETWORK=192.168.0.0</span><br><span class="line">BROADCAST=192.168.0.255</span><br><span class="line">ONBOOT=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p><strong>/etc/network/interfaces (Debian)</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line">allow-hotplug eth0</span><br><span class="line">iface eth0 inet static </span><br><span class="line">    address 192.168.0.6</span><br><span class="line">    netmask 255.255.255.0</span><br><span class="line">    gateway 192.168.0.1</span><br><span class="line">    dns-domain example.com</span><br><span class="line">    dns-nameservers 192.168.1.1</span><br></pre></td></tr></table></figure><h2 id="7-网络问题排查">7. 网络问题排查</h2><h3 id="7-1-排查步骤">7.1 排查步骤</h3><ol><li><p><strong>Ping 测试</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping 172.16.0.1</span><br><span class="line">ping h001.s16.la.net</span><br></pre></td></tr></table></figure><ul><li>如果 IP 能 Ping 通，但主机名失败，可能是 DNS 问题，检查 <code>/etc/resolv.conf</code>。</li></ul></li><li><p><strong>局域网连通但无法访问互联网</strong>：</p><ul><li>检查默认网关或路由表：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route</span><br></pre></td></tr></table></figure></li><li>如果没有默认路由，添加默认网关：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add default gw 172.16.0.1</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>网络连接不通</strong>：</p><ul><li>使用 <code>traceroute</code> 或 <code>tracepath</code> 查看路径：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute www.lpi.jp</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>网络接口问题</strong>：</p><ul><li>检查网卡状态：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure></li><li>如果只显示 <code>lo</code>，启动接口：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifup eth0</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">ifconfig eth0 up</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="7-2-需要确认的配置文件">7.2 需要确认的配置文件</h3><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td><code>/etc/resolv.conf</code></td><td>DNS 服务器设置</td></tr><tr><td><code>/etc/sysconfig/network-scripts/*</code></td><td>网络接口设置（RHEL/CentOS）</td></tr><tr><td><code>/etc/network/interfaces</code></td><td>网络接口设置（Debian）</td></tr><tr><td><code>/etc/hosts.allow</code>, <code>/etc/hosts.deny</code></td><td>连接控制</td></tr></tbody></table><hr><p><strong>补充说明</strong>：</p><ul><li><strong>IP 别名</strong>：允许在同一个网卡上分配多个 IP 地址，常用于服务器提供多种服务。</li><li><strong>ARP 缓存</strong>：存储 IP 地址与 MAC 地址的映射关系，可通过 <code>arp -d</code> 手动清除缓存。</li><li><strong>无线安全</strong>：建议使用 WPA2 或 WPA3 加密方式，避免使用不安全的 WEP。</li><li><strong>路由表</strong>：理解目标网络、网关、子网掩码和接口的关系，确保数据包正确转发。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15.高度的存储管理</title>
      <link href="/2020/11/15/linux/15-%E9%AB%98%E5%BA%A6%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
      <url>/2020/11/15/linux/15-%E9%AB%98%E5%BA%A6%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1>1. RAID (冗余磁盘阵列)</h1><p>RAID（Redundant Arrays of Inexpensive Disks）是一种将多个硬盘组合以提高性能或数据冗余的技术。</p><h2 id="Linux-上的-RAID">Linux 上的 RAID</h2><p>在 Linux 上应用 RAID，有软件 RAID 和硬件 RAID 之分。通常，硬件 RAID 会被视作 SCSI 设备。</p><h2 id="RAID-各个等级：">RAID 各个等级：</h2><ul><li><p><strong>RAID 0 (条带化)</strong></p><ul><li>多个硬盘组合成一个大磁盘，没有备份，提供较好的性能但没有容灾能力。</li><li>示例：三台 100GB 硬盘组成一个 300GB 的 RAID 0。</li></ul></li><li><p><strong>RAID 1 (镜像)</strong></p><ul><li>多台硬盘写入相同数据，提供冗余备份。</li><li>示例：三个 100GB 硬盘组成一个 100GB 的 RAID 1。</li></ul></li><li><p><strong>RAID 4</strong></p><ul><li>至少需要 3 台硬盘，其中一台用作备份分区。性能瓶颈在于备份分区。</li><li>示例：三个 100GB 硬盘组成一个 200GB 的 RAID 4。</li></ul></li><li><p><strong>RAID 5</strong></p><ul><li>使用分布式备份技术，性能较 RAID 4 好，且不需要专门的备份硬盘。</li><li>示例：三个 100GB 硬盘组成一个 200GB 的 RAID 5。</li></ul></li><li><p><strong>其他 RAID 等级：</strong></p><ul><li><strong>RAID LINEAR</strong>：类似 RAID 0。</li><li><strong>RAID 0+1 (RAID01)</strong>：RAID 0 组成的 RAID 1。</li><li><strong>RAID 10 (RAID+0)</strong>：RAID 1 组成的 RAID 0。</li><li><strong>RAID 6</strong>：比 RAID 5 多一台备份区。</li></ul></li></ul><h2 id="mdadm-命令控制-RAID-阵列"><code>mdadm</code> 命令控制 RAID 阵列</h2><p><code>mdadm [option] [设备名]</code></p><h3 id="常用选项：">常用选项：</h3><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-C</code>, <code>--create</code></td><td>创建 RAID 阵列并生成相关设备</td></tr><tr><td><code>-a</code></td><td>自动生成必要的设备文件</td></tr><tr><td><code>-c</code></td><td>指定 Chunk 大小</td></tr><tr><td><code>-l</code>, <code>--level</code></td><td>指定 RAID 级别</td></tr><tr><td><code>-n</code>, <code>--raid-devices</code></td><td>指定 RAID 阵列中的设备数量</td></tr><tr><td><code>-x</code>, <code>--spare-devices</code></td><td>指定备用设备数量</td></tr><tr><td><code>--manage</code></td><td>管理 RAID 阵列</td></tr><tr><td><code>-a</code>, <code>--add</code></td><td>添加设备</td></tr><tr><td><code>-r</code>, <code>--remove</code></td><td>删除设备</td></tr><tr><td><code>-f</code>, <code>--fail</code></td><td>标记设备为失效</td></tr><tr><td><code>--query</code></td><td>查询 RAID 状态</td></tr><tr><td><code>--detail</code></td><td>查看 RAID 详细状态</td></tr><tr><td><code>--stop</code></td><td>停止指定的 RAID 阵列</td></tr><tr><td><code>--stop --scan</code></td><td>停止所有 RAID 阵列</td></tr></tbody></table><hr><h1>2. LVM (逻辑卷管理)</h1><p>LVM 是 Linux 下的一种磁盘管理工具，可以灵活地管理硬盘、分区和逻辑卷。</p><h3 id="LVM-结构：">LVM 结构：</h3><ol><li><strong>PV (Physical Volume)</strong>：一个硬盘或一个分区作为物理空间。</li><li><strong>PE (Physical Extent)</strong>：PV 组成 PE。</li><li><strong>VG (Volume Group)</strong>：PE 组成 VG。</li><li><strong>LV (Logical Volume)</strong>：VG 内的 PE 分配为 LV。</li></ol><h3 id="创建-LVM：">创建 LVM：</h3><ol><li><p>准备 LVM 用的分区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sda</span><br><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure></li><li><p>初始化 PV：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pvcreate /dev/sda1 /dev/sdb1</span><br></pre></td></tr></table></figure></li><li><p>创建 VG：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vgcreate testvg /dev/sda1 /dev/sdb1</span><br></pre></td></tr></table></figure></li><li><p>创建 LV：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvcreate -L 1G -n lv01 testvg</span><br></pre></td></tr></table></figure></li><li><p>创建文件系统并挂载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mke2fs -j /dev/testvg/lv01</span><br><span class="line">mount /dev/testvg/lv01 /mnt</span><br></pre></td></tr></table></figure></li></ol><h3 id="管理-LVM：">管理 LVM：</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>pvdisplay</code></td><td>显示物理 PV 信息</td></tr><tr><td><code>pvscan</code></td><td>显示 PV 状态</td></tr><tr><td><code>pvmove</code></td><td>移动 PV 中的 PE</td></tr><tr><td><code>pvremove</code></td><td>删除 PV</td></tr><tr><td><code>vgextend</code></td><td>扩展 VG</td></tr><tr><td><code>vgreduce</code></td><td>缩小 VG</td></tr><tr><td><code>vgdisplay</code></td><td>显示 VG 详情</td></tr><tr><td><code>lvdisplay</code></td><td>显示 LV 详情</td></tr><tr><td><code>lvextend</code></td><td>扩展 LV</td></tr><tr><td><code>lvreduce</code></td><td>缩小 LV</td></tr><tr><td><code>lvremove</code></td><td>删除 LV</td></tr><tr><td><code>lvcreate -s</code></td><td>创建快照</td></tr></tbody></table><hr><h1>3. 访问记忆装置</h1><h3 id="设备文件说明：">设备文件说明：</h3><table><thead><tr><th>设备文件</th><th>说明</th></tr></thead><tbody><tr><td><code>/dev/hda</code></td><td>IDE 主硬盘</td></tr><tr><td><code>/dev/hdb</code></td><td>IDE 从硬盘</td></tr><tr><td><code>/dev/sda</code></td><td>第一个 SCSI/STAT/USB 硬盘</td></tr><tr><td><code>/dev/sdb</code></td><td>第二个 SCSI/STAT/USB 硬盘</td></tr><tr><td><code>/dev/sr0</code></td><td>第一个 SCSI/STAT/USB CD/DVD</td></tr><tr><td><code>/dev/st0</code></td><td>第一个 SCSI 磁带设备</td></tr></tbody></table><h3 id="硬盘管理：">硬盘管理：</h3><p>Linux 将 IDE 以外的硬盘识别为 SCSI 设备。硬盘的数据传送模式有 PIO（Programmed I/O）和 DMA（Direct Memory Access）模式。通常使用 DMA 模式。</p><h3 id="检查-DMA-模式：">检查 DMA 模式：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdparm -i /dev/sda</span><br></pre></td></tr></table></figure><h3 id="硬盘控制：">硬盘控制：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdparm -d1 /dev/sda  <span class="comment"># 启用 DMA 模式</span></span><br></pre></td></tr></table></figure><h3 id="使用-SCSI-STAT-USB：">使用 SCSI/STAT/USB：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdparm [option] [设备文件]</span><br></pre></td></tr></table></figure><hr><h1>4. iSCSI (Internet Small Computer System Interface)</h1><p>iSCSI 是基于 TCP/IP 的 SCSI 协议，可以使远程存储设备像本地设备一样使用。</p><h2 id="iSCSI-配置步骤：">iSCSI 配置步骤：</h2><ol><li><p>配置 <code>targets.conf</code> 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">iqn.2014.01.com.example.lpic:target0</span>&gt;</span></span><br><span class="line">   backing-store /dev/sdb2</span><br><span class="line">   initiator-address 192.168.11.2</span><br><span class="line">   initiator-address 192.168.11.4</span><br><span class="line">   incominguser centuser password</span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>启动 iSCSI target 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service tgtd start</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>tgtadm</code> 命令查看 target 状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tgtadm --mode target --op show</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>iscsiadm</code> 从 initiator 查询 target：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iscsiadm -m discovery -t sendtargets -p 192.168.11.3</span><br></pre></td></tr></table></figure></li><li><p>配置认证方式：<br>修改 <code>/etc/iscsi/iscid.conf</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node.session.auth.authmethod = CHAP</span><br><span class="line">node.session.auth.username = centuser</span><br><span class="line">node.session.auth.password = password</span><br></pre></td></tr></table></figure></li><li><p>登录 iSCSI：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iscsiadm -m node --login</span><br></pre></td></tr></table></figure><p>登录后，使用 <code>cat /proc/partitions</code> 查看 iSCSI 目标是否添加成功。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.设备和文件系统</title>
      <link href="/2020/11/14/linux/14-%E8%AE%BE%E5%A4%87%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/11/14/linux/14-%E8%AE%BE%E5%A4%87%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-文件系统基础">1. 文件系统基础</h2><h3 id="etc-fstab-文件格式解析">/etc/fstab 文件格式解析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设备/标签/UUID  挂载点  文件系统类型  挂载选项  dump标志  fsck顺序</span><br></pre></td></tr></table></figure><p><strong>字段说明：</strong></p><table><thead><tr><th>字段</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>1</td><td>设备标识</td><td>/dev/sda1, UUID=xxxx, LABEL=root</td></tr><tr><td>2</td><td>挂载路径</td><td>/, /home, /boot</td></tr><tr><td>3</td><td>文件系统类型</td><td>ext4, xfs, nfs</td></tr><tr><td>4</td><td>挂载选项</td><td>defaults, noatime</td></tr><tr><td>5</td><td>dump备份标志</td><td>0(不备份), 1(备份)</td></tr><tr><td>6</td><td>fsck检查顺序</td><td>0(不检查), 1(优先), 2(次级)</td></tr></tbody></table><h3 id="文件系统类型对比">文件系统类型对比</h3><table><thead><tr><th>类型</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>ext4</td><td>日志式, 最大16TB文件</td><td>通用Linux系统</td></tr><tr><td>XFS</td><td>高性能, 最大8EB文件</td><td>大文件处理</td></tr><tr><td>Btrfs</td><td>写时复制, 快照功能</td><td>高级存储需求</td></tr><tr><td>FAT32</td><td>兼容性好</td><td>U盘/移动设备</td></tr><tr><td>NTFS</td><td>Windows兼容</td><td>双系统共享分区</td></tr></tbody></table><h3 id="常用挂载选项">常用挂载选项</h3><table><thead><tr><th>选项</th><th>作用</th><th>性能影响</th></tr></thead><tbody><tr><td>async</td><td>异步写入</td><td>提升性能</td></tr><tr><td>noatime</td><td>不更新访问时间</td><td>显著提升</td></tr><tr><td>nodiratime</td><td>不更新目录访问时间</td><td>小幅提升</td></tr><tr><td>discard</td><td>TRIM支持(SSD)</td><td>延长SSD寿命</td></tr><tr><td>data=writeback</td><td>ext4日志模式</td><td>性能最佳</td></tr></tbody></table><p><strong>查看支持的文件系统：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/filesystems</span><br></pre></td></tr></table></figure><p><strong>查看已挂载文件系统：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/mtab   <span class="comment"># 或</span></span><br><span class="line"><span class="built_in">cat</span> /proc/mounts</span><br></pre></td></tr></table></figure><h2 id="2-挂载管理命令">2. 挂载管理命令</h2><h3 id="mount-命令详解">mount 命令详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [选项] [设备] [挂载点]</span><br></pre></td></tr></table></figure><p><strong>常用选项：</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-t</td><td>指定文件系统类型</td></tr><tr><td>-o</td><td>指定挂载选项(多选项用逗号分隔)</td></tr><tr><td>-a</td><td>挂载/etc/fstab中所有文件系统</td></tr><tr><td>–bind</td><td>目录绑定挂载</td></tr><tr><td>-l</td><td>显示标签</td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t ext4 -o noatime /dev/sdb1 /mnt/data</span><br></pre></td></tr></table></figure><h3 id="umount-命令">umount 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount [选项] [设备|挂载点]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>卸载所有文件系统</td></tr><tr><td>-t</td><td>按类型卸载</td></tr><tr><td>-l</td><td>延迟卸载(强制)</td></tr><tr><td>-f</td><td>强制卸载</td></tr></tbody></table><p><strong>强制卸载流程：</strong></p><ol><li><code>fuser -vm /mountpoint</code> 查看占用进程</li><li><code>kill -9 PID</code> 结束进程</li><li><code>umount -f /mountpoint</code></li></ol><h2 id="3-SWAP-管理">3. SWAP 管理</h2><h3 id="创建SWAP文件">创建SWAP文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建1GB交换文件</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/swapfile bs=1M count=1024</span><br><span class="line"><span class="built_in">chmod</span> 600 /swapfile</span><br><span class="line">mkswap /swapfile</span><br><span class="line">swapon /swapfile</span><br></pre></td></tr></table></figure><h3 id="SWAP管理命令">SWAP管理命令</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>swapon -a</code></td><td>启用所有swap</td></tr><tr><td><code>swapon -s</code></td><td>查看swap使用</td></tr><tr><td><code>swapoff -a</code></td><td>禁用所有swap</td></tr></tbody></table><p><strong>优化建议：</strong></p><ul><li>物理内存&lt;8GB时，SWAP=1.5倍内存</li><li>物理内存≥8GB时，SWAP=8GB</li></ul><h2 id="4-文件系统创建与维护">4. 文件系统创建与维护</h2><h3 id="创建工具对比">创建工具对比</h3><table><thead><tr><th>命令</th><th>对应文件系统</th><th>特点</th></tr></thead><tbody><tr><td>mkfs.ext4</td><td>ext4</td><td>默认日志模式</td></tr><tr><td>mkfs.xfs</td><td>XFS</td><td>高性能大文件</td></tr><tr><td>mkfs.btrfs</td><td>Btrfs</td><td>高级功能支持</td></tr></tbody></table><p><strong>ext4创建示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 -b 4096 -m 1 -L DATA /dev/sdb1</span><br></pre></td></tr></table></figure><p><strong>XFS创建示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.xfs -f -L BIGDATA /dev/sdc1</span><br></pre></td></tr></table></figure><h3 id="文件系统检查">文件系统检查</h3><p><strong>ext系列检查：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fsck -y /dev/sda1   <span class="comment"># 自动修复</span></span><br><span class="line">e2fsck -f /dev/sda1 <span class="comment"># 强制检查</span></span><br></pre></td></tr></table></figure><p><strong>XFS检查：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_repair /dev/sdb1</span><br></pre></td></tr></table></figure><p><strong>检查时机：</strong></p><ul><li>异常关机后</li><li>定期维护时(建议每6个月)</li><li>出现I/O错误时</li></ul><h2 id="5-高级文件系统特性">5. 高级文件系统特性</h2><h3 id="ext4-特性管理">ext4 特性管理</h3><p><strong>转换ext3→ext4：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tune2fs -O extent,uninit_bg,dir_index /dev/sda1</span><br><span class="line">fsck -pf /dev/sda1</span><br></pre></td></tr></table></figure><p><strong>调整参数：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tune2fs -c 30 -i 7d /dev/sda1  <span class="comment"># 每30次挂载或7天检查</span></span><br><span class="line">tune2fs -m 5 /dev/sda1         <span class="comment"># 保留5%空间</span></span><br></pre></td></tr></table></figure><h3 id="XFS-高级功能">XFS 高级功能</h3><p><strong>查看信息：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xfs_info /dev/sdb1</span><br><span class="line">xfs_admin -l /dev/sdb1</span><br></pre></td></tr></table></figure><p><strong>备份恢复：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xfsdump -l 0 -f /backup/root.xfsdump /dev/sda1</span><br><span class="line">xfsrestore -f /backup/root.xfsdump /mnt/restore</span><br></pre></td></tr></table></figure><h2 id="6-光盘与加密文件系统">6. 光盘与加密文件系统</h2><h3 id="光盘制作">光盘制作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建ISO</span></span><br><span class="line">mkisofs -JR -V <span class="string">&quot;BACKUP_2023&quot;</span> -o backup.iso /backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刻录光盘</span></span><br><span class="line">cdrecord -v dev=1,0,0 speed=24 backup.iso</span><br></pre></td></tr></table></figure><h3 id="加密文件系统">加密文件系统</h3><p><strong>LUKS加密：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cryptsetup luksFormat /dev/sdb1</span><br><span class="line">cryptsetup luksOpen /dev/sdb1 secret</span><br><span class="line">mkfs.ext4 /dev/mapper/secret</span><br><span class="line">mount /dev/mapper/secret /mnt/secure</span><br></pre></td></tr></table></figure><p><strong>关闭加密卷：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umount /mnt/secure</span><br><span class="line">cryptsetup luksClose secret</span><br></pre></td></tr></table></figure><h2 id="7-磁盘健康监控">7. 磁盘健康监控</h2><h3 id="S-M-A-R-T-监控">S.M.A.R.T. 监控</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">smartctl -a /dev/sda          <span class="comment"># 查看详细信息</span></span><br><span class="line">smartctl -H /dev/sda          <span class="comment"># 健康状态</span></span><br><span class="line">smartctl -t long /dev/sda     <span class="comment"># 启动长测试</span></span><br></pre></td></tr></table></figure><p><strong>关键监控指标：</strong></p><ul><li>Reallocated_Sector_Ct</li><li>Current_Pending_Sector</li><li>Temperature_Celsius</li></ul><h2 id="8-故障处理流程">8. 故障处理流程</h2><h3 id="文件系统修复步骤">文件系统修复步骤</h3><ol><li><p><strong>卸载文件系统</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount /dev/sda1</span><br></pre></td></tr></table></figure></li><li><p><strong>进入单用户模式</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init 1</span><br></pre></td></tr></table></figure></li><li><p><strong>执行检查修复</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsck -y /dev/sda1</span><br></pre></td></tr></table></figure></li><li><p><strong>严重损坏时</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">debugfs /dev/sda1</span><br><span class="line">&gt; lsdel      <span class="comment"># 查看已删除inode</span></span><br><span class="line">&gt; dump &lt;inode&gt; /tmp/recover_file</span><br></pre></td></tr></table></figure></li></ol><h3 id="应急恢复方案">应急恢复方案</h3><table><thead><tr><th>问题现象</th><th>解决方案</th></tr></thead><tbody><tr><td>无法挂载</td><td><code>fsck -y /dev/sdX</code></td></tr><tr><td>Superblock损坏</td><td><code>e2fsck -b 32768 /dev/sdX</code></td></tr><tr><td>只读文件系统</td><td><code>mount -o remount,rw /</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.系统启动</title>
      <link href="/2020/11/10/linux/13-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"/>
      <url>/2020/11/10/linux/13-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-系统启动流程">1. 系统启动流程</h2><h3 id="1-1-启动阶段详解">1.1 启动阶段详解</h3><table><thead><tr><th>阶段</th><th>组件</th><th>功能说明</th></tr></thead><tbody><tr><td>1</td><td>BIOS</td><td>- 硬件自检(POST)<br>- 读取CMOS设置<br>- 检测启动设备顺序<br>- 加载MBR中的BootLoader</td></tr><tr><td>2</td><td>MBR</td><td>- 512字节(启动代码+分区表)<br>- 包含第一阶段BootLoader<br>- 标识活动分区</td></tr><tr><td>3</td><td>BootLoader</td><td>- 阶段1: MBR中的初始代码<br>- 阶段1.5: 文件系统识别<br>- 阶段2: 加载内核(/boot/grub/)</td></tr><tr><td>4</td><td>内核</td><td>- 硬件检测与初始化<br>- 加载驱动模块<br>- 挂载根文件系统<br>- 启动init进程(PID=1)</td></tr><tr><td>5</td><td>init进程</td><td>- 根据/etc/inittab初始化系统<br>- 启动运行级别对应服务<br>- 生成所有后续进程</td></tr></tbody></table><h3 id="1-2-inittab-文件格式">1.2 inittab 文件格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id:runlevels:action:process</span><br></pre></td></tr></table></figure><h4 id="主要action类型">主要action类型</h4><table><thead><tr><th>action</th><th>说明</th></tr></thead><tbody><tr><td>boot</td><td>系统启动时执行，不等待完成</td></tr><tr><td>bootwait</td><td>系统启动时执行，等待完成</td></tr><tr><td>ctrlaltdel</td><td>捕获Ctrl+Alt+Del组合键</td></tr><tr><td>initdefault</td><td>设置默认运行级别</td></tr><tr><td>once</td><td>进入运行级别时执行一次</td></tr><tr><td>respawn</td><td>进程终止后自动重启</td></tr><tr><td>sysinit</td><td>系统初始化脚本</td></tr><tr><td>wait</td><td>进入运行级别时执行并等待</td></tr></tbody></table><h3 id="1-3-运行级别管理">1.3 运行级别管理</h3><h4 id="标准运行级别">标准运行级别</h4><table><thead><tr><th>级别</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>关机</td></tr><tr><td>1/S</td><td>单用户模式</td></tr><tr><td>2</td><td>多用户无NFS</td></tr><tr><td>3</td><td>完整多用户模式</td></tr><tr><td>4</td><td>自定义</td></tr><tr><td>5</td><td>图形界面</td></tr><tr><td>6</td><td>重启</td></tr></tbody></table><h4 id="服务管理脚本">服务管理脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/service [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>start</td><td>启动服务</td></tr><tr><td>stop</td><td>停止服务</td></tr><tr><td>restart</td><td>重启服务</td></tr><tr><td>reload</td><td>重载配置</td></tr><tr><td>status</td><td>查看状态</td></tr></tbody></table><h4 id="服务自启动管理">服务自启动管理</h4><p><strong>RedHat系(chkconfig):</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig [选项] 服务名 [on|off]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>–list</td><td>显示服务状态</td></tr><tr><td>–level</td><td>指定运行级别</td></tr><tr><td>–add</td><td>添加服务</td></tr><tr><td>–del</td><td>删除服务</td></tr></tbody></table><p><strong>Debian系(update-rc.d):</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-rc.d [选项] 服务名 [commands]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>模拟执行</td></tr><tr><td>-f</td><td>强制操作</td></tr><tr><td>remove</td><td>删除链接</td></tr></tbody></table><h3 id="1-4-Upstart-事件驱动">1.4 Upstart 事件驱动</h3><p><strong>主要命令:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initctl [<span class="built_in">command</span>] job</span><br></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>start</td><td>启动作业</td></tr><tr><td>stop</td><td>停止作业</td></tr><tr><td>restart</td><td>重启作业</td></tr><tr><td>status</td><td>查看状态</td></tr><tr><td>list</td><td>列出所有作业</td></tr></tbody></table><p><strong>配置文件位置:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init/*.conf</span><br></pre></td></tr></table></figure><h2 id="2-GRUB-引导加载器">2. GRUB 引导加载器</h2><h3 id="2-1-GRUB-Legacy-vs-GRUB2">2.1 GRUB Legacy vs GRUB2</h3><table><thead><tr><th>特性</th><th>GRUB Legacy</th><th>GRUB2</th></tr></thead><tbody><tr><td>版本</td><td>0.9x</td><td>1.9x</td></tr><tr><td>配置文件</td><td>menu.lst</td><td>grub.cfg</td></tr><tr><td>生成方式</td><td>直接编辑</td><td>update-grub</td></tr><tr><td>分区表示</td><td>(hd0,0)</td><td>hd0,msdos1</td></tr></tbody></table><h3 id="2-2-GRUB-Legacy-配置">2.2 GRUB Legacy 配置</h3><p><strong>/boot/grub/menu.lst 示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">timeout 5</span><br><span class="line">default 0</span><br><span class="line">title CentOS</span><br><span class="line">root (hd0,0)</span><br><span class="line">kernel /vmlinuz ro root=/dev/sda1</span><br><span class="line">initrd /initrd.img</span><br></pre></td></tr></table></figure><p><strong>常用命令:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grub&gt; root (hd0,0)     <span class="comment"># 设置根分区</span></span><br><span class="line">grub&gt; setup (hd0)      <span class="comment"># 安装到MBR</span></span><br><span class="line">grub&gt; <span class="built_in">cat</span> /grub/menu.lst <span class="comment"># 查看配置</span></span><br></pre></td></tr></table></figure><h3 id="2-3-GRUB2-配置">2.3 GRUB2 配置</h3><p><strong>/etc/default/grub 关键参数:</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>GRUB_DEFAULT</td><td>默认启动项</td></tr><tr><td>GRUB_TIMEOUT</td><td>菜单超时</td></tr><tr><td>GRUB_CMDLINE_LINUX</td><td>内核参数</td></tr></tbody></table><p><strong>生成配置:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-grub</span><br></pre></td></tr></table></figure><h3 id="2-4-内核启动参数">2.4 内核启动参数</h3><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>root=/dev/sda1</td><td>指定根分区</td></tr><tr><td>ro/rw</td><td>只读/读写挂载</td></tr><tr><td>init=/bin/bash</td><td>指定初始化程序</td></tr><tr><td>single</td><td>单用户模式</td></tr><tr><td>mem=1024M</td><td>限制内存大小</td></tr></tbody></table><p><strong>查看当前参数:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cmdline</span><br></pre></td></tr></table></figure><h2 id="3-其他引导加载器">3. 其他引导加载器</h2><h3 id="3-1-LILO-配置">3.1 LILO 配置</h3><p><strong>/etc/lilo.conf 示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boot=/dev/sda</span><br><span class="line">map=/boot/map</span><br><span class="line">default=linux</span><br><span class="line">image=/boot/vmlinuz</span><br><span class="line">label=linux</span><br><span class="line">root=/dev/sda1</span><br></pre></td></tr></table></figure><p><strong>应用配置:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lilo -v</span><br></pre></td></tr></table></figure><h3 id="3-2-SYSLINUX-系列">3.2 SYSLINUX 系列</h3><table><thead><tr><th>类型</th><th>文件系统</th><th>用途</th></tr></thead><tbody><tr><td>SYSLINUX</td><td>FAT</td><td>USB启动</td></tr><tr><td>ISOLINUX</td><td>ISO9660</td><td>光盘启动</td></tr><tr><td>EXTLINUX</td><td>ext2/3/4</td><td>硬盘启动</td></tr><tr><td>PXELINUX</td><td>网络</td><td>网络启动</td></tr></tbody></table><p><strong>PXE启动环境搭建:</strong></p><ol><li>安装必要服务:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install dhcp tftp-server syslinux</span><br></pre></td></tr></table></figure><ol start="2"><li>配置DHCP:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filename &quot;pxelinux.0&quot;;</span><br><span class="line">next-server 192.168.1.100;</span><br></pre></td></tr></table></figure><ol start="3"><li>准备TFTP目录:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/</span><br><span class="line"><span class="built_in">mkdir</span> /var/lib/tftpboot/pxelinux.cfg</span><br></pre></td></tr></table></figure><h2 id="4-系统恢复方法">4. 系统恢复方法</h2><h3 id="4-1-救援模式操作">4.1 救援模式操作</h3><ol><li>使用安装介质启动</li><li>进入救援模式</li><li>挂载原系统:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chroot</span> /mnt/sysimage</span><br></pre></td></tr></table></figure><ol start="4"><li>修复引导:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-install /dev/sda</span><br></pre></td></tr></table></figure><h3 id="4-2-常见修复场景">4.2 常见修复场景</h3><table><thead><tr><th>问题</th><th>解决方案</th></tr></thead><tbody><tr><td>MBR损坏</td><td><code>dd if=/usr/share/syslinux/mbr.bin of=/dev/sda</code></td></tr><tr><td>GRUB损坏</td><td><code>grub-install /dev/sda</code></td></tr><tr><td>文件系统错误</td><td><code>fsck -y /dev/sda1</code></td></tr><tr><td>密码重置</td><td><code>init=/bin/bash</code> 启动后修改密码</td></tr></tbody></table><h2 id="5-启动优化技巧">5. 启动优化技巧</h2><ol><li><strong>并行启动</strong>:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/init/rc-sysinit.conf</span><br><span class="line"><span class="comment"># 修改为:</span></span><br><span class="line"><span class="built_in">env</span> DEFAULT_RUNLEVEL=2</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>禁用不需要的服务</strong>:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list | grep 3:on</span><br><span class="line">chkconfig servicename off</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>使用readahead</strong>:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service readahead-early restart</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>SSD优化</strong>:<br>在/etc/fstab添加:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">noatime,discard</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.内核</title>
      <link href="/2020/11/08/linux/12-%E5%86%85%E6%A0%B8/"/>
      <url>/2020/11/08/linux/12-%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-内核版本管理">1. 内核版本管理</h2><h3 id="版本号说明">版本号说明</h3><ul><li><p><strong>2.X.Y 旧版本格式</strong>：</p><ul><li>X：偶数表示稳定版，奇数表示开发版</li><li>Y：修订版本号</li><li>后缀说明：<ul><li><code>-rcN</code>：Release Candidate（候选版本）</li><li><code>-gitN</code>：开发中的Git版本</li></ul></li></ul></li><li><p><strong>3.0+ 新版本分类</strong>：</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>Prepatch</td><td>稳定版前的测试版本</td></tr><tr><td>Mainline</td><td>包含新特性的主线开发版本</td></tr><tr><td>Stable</td><td>稳定版本</td></tr><tr><td>Longterm</td><td>长期支持版本(LTS)</td></tr></tbody></table></li></ul><h3 id="版本查询命令">版本查询命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> [选项]</span><br></pre></td></tr></table></figure><h4 id="常用选项">常用选项</h4><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>显示全部系统信息</td></tr><tr><td>-r</td><td>显示内核版本</td></tr><tr><td>-m</td><td>显示硬件架构</td></tr></tbody></table><h4 id="其他查询方式">其他查询方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看/proc版本信息</span></span><br><span class="line"><span class="built_in">cat</span> /proc/version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过Makefile查看</span></span><br><span class="line"><span class="built_in">head</span> -4 /usr/src/linux/Makefile</span><br></pre></td></tr></table></figure><h2 id="2-内核模块管理">2. 内核模块管理</h2><h3 id="核心命令对比">核心命令对比</h3><table><thead><tr><th>命令</th><th>功能说明</th><th>特点</th></tr></thead><tbody><tr><td>lsmod</td><td>显示已加载模块</td><td>读取/proc/modules</td></tr><tr><td>insmod</td><td>加载单个模块</td><td>不处理依赖关系</td></tr><tr><td>rmmod</td><td>卸载模块</td><td>需确保无依赖</td></tr><tr><td>modprobe</td><td>智能加载/卸载模块</td><td>自动处理依赖关系</td></tr><tr><td>depmod</td><td>生成模块依赖关系文件</td><td>创建modules.dep</td></tr></tbody></table><h3 id="命令详解">命令详解</h3><h4 id="lsmod-输出说明">lsmod 输出说明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Module                  Size  Used by    Dependent modules</span><br></pre></td></tr></table></figure><ul><li>显示模块名、大小、引用计数和被哪些模块使用</li></ul><h4 id="modinfo-模块信息">modinfo 模块信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modinfo [选项] 模块名</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>显示作者信息</td></tr><tr><td>-d</td><td>显示描述信息</td></tr><tr><td>-l</td><td>显示许可证信息</td></tr><tr><td>-n</td><td>显示模块文件路径</td></tr></tbody></table><h4 id="modprobe-高级用法">modprobe 高级用法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe [选项] 模块名</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>加载所有匹配模块</td></tr><tr><td>-c</td><td>显示当前配置</td></tr><tr><td>-l</td><td>列出所有可用模块</td></tr><tr><td>-r</td><td>递归卸载模块及依赖</td></tr><tr><td>-t 类型</td><td>仅操作指定类型模块</td></tr><tr><td>–show-depends</td><td>显示模块依赖关系</td></tr></tbody></table><h3 id="配置文件">配置文件</h3><ul><li><code>/etc/modprobe.conf</code>：模块别名和参数配置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias eth0 e1000</span><br><span class="line">options e1000 speed=1000 duplex=full</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-内核编译流程">3. 内核编译流程</h2><h3 id="编译步骤">编译步骤</h3><ol><li><strong>准备源代码</strong></li><li><strong>配置内核</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make oldconfig    <span class="comment"># 基于旧配置更新</span></span><br><span class="line">make menuconfig  <span class="comment"># 文本界面配置</span></span><br><span class="line">make xconfig     <span class="comment"># Qt图形界面配置</span></span><br><span class="line">make gconfig     <span class="comment"># GTK图形界面配置</span></span><br></pre></td></tr></table></figure></li><li><strong>编译内核</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make           <span class="comment"># 编译内核和模块</span></span><br><span class="line">make bzImage   <span class="comment"># 仅编译内核</span></span><br><span class="line">make modules   <span class="comment"># 仅编译模块</span></span><br></pre></td></tr></table></figure></li><li><strong>安装组件</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make modules_install  <span class="comment"># 安装模块到/lib/modules/</span></span><br><span class="line">make install          <span class="comment"># 自动安装内核</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="手动安装示例">手动安装示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制内核文件</span></span><br><span class="line"><span class="built_in">cp</span> <span class="built_in">arch</span>/x86/boot/bzImage /boot/vmlinuz-2.6.32</span><br><span class="line"><span class="built_in">cp</span> System.map /boot/System.map-2.6.32</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建链接</span></span><br><span class="line"><span class="built_in">ln</span> -s /boot/vmlinuz-2.6.32 /boot/vmlinuz</span><br><span class="line"><span class="built_in">ln</span> -s /boot/System.map-2.6.32 /boot/System.map</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成initramfs</span></span><br><span class="line">mkinitramfs -o /boot/initrd-2.6.32.img 2.6.32</span><br></pre></td></tr></table></figure><h3 id="其他make目标">其他make目标</h3><table><thead><tr><th>目标</th><th>说明</th></tr></thead><tbody><tr><td>clean</td><td>清除编译文件</td></tr><tr><td>mrproper</td><td>彻底清除(含配置)</td></tr><tr><td>rpm-pkg</td><td>生成RPM包</td></tr><tr><td>deb-pkg</td><td>生成Debian包</td></tr></tbody></table><h2 id="4-内核参数调优">4. 内核参数调优</h2><h3 id="proc-sys-关键参数">/proc/sys 关键参数</h3><table><thead><tr><th>路径</th><th>说明</th></tr></thead><tbody><tr><td>kernel/ctrl-alt-del</td><td>Ctrl+Alt+Del行为</td></tr><tr><td>kernel/shmall</td><td>共享内存页数上限</td></tr><tr><td>kernel/shmmax</td><td>共享内存段最大大小</td></tr><tr><td>net/ipv4/ip_forward</td><td>IP转发开关(1/0)</td></tr><tr><td>fs/file-max</td><td>系统最大文件句柄数</td></tr></tbody></table><h3 id="sysctl-工具">sysctl 工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl [选项] [参数=值]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>显示所有可用参数</td></tr><tr><td>-p</td><td>从/etc/sysctl.conf加载配置</td></tr><tr><td>-w</td><td>临时修改参数</td></tr></tbody></table><h3 id="initramfs-管理">initramfs 管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建initramfs</span></span><br><span class="line">mkinitramfs -o initrd.img 3.16.0-4-amd64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压分析</span></span><br><span class="line"><span class="built_in">mkdir</span> initrd &amp;&amp; <span class="built_in">cd</span> initrd</span><br><span class="line">zcat ../initrd.img | cpio -<span class="built_in">id</span></span><br></pre></td></tr></table></figure><h2 id="5-内核调试与设备管理">5. 内核调试与设备管理</h2><h3 id="proc-关键文件">/proc 关键文件</h3><table><thead><tr><th>文件</th><th>内容说明</th></tr></thead><tbody><tr><td>/proc/cpuinfo</td><td>CPU详细信息</td></tr><tr><td>/proc/meminfo</td><td>内存使用情况</td></tr><tr><td>/proc/modules</td><td>已加载模块列表</td></tr><tr><td>/proc/partitions</td><td>分区信息</td></tr></tbody></table><h3 id="硬件信息工具">硬件信息工具</h3><h4 id="lspci">lspci</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci [选项]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-vv</td><td>超详细输出</td></tr><tr><td>-t</td><td>树状显示设备层级</td></tr></tbody></table><h4 id="lsusb">lsusb</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsusb [选项]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-v</td><td>详细输出设备描述符</td></tr><tr><td>-t</td><td>树状显示USB设备拓扑</td></tr></tbody></table><h3 id="udev-设备管理">udev 设备管理</h3><h4 id="规则文件示例">规则文件示例</h4><p><code>/etc/udev/rules.d/70-persistent-net.rules</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, </span><br><span class="line">ATTR&#123;address&#125;==&quot;08:00:27:aa:11:3c&quot;, NAME=&quot;eth0&quot;</span><br></pre></td></tr></table></figure><h4 id="udevadm-工具">udevadm 工具</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udevadm info [选项]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>显示父设备属性</td></tr><tr><td>-n</td><td>指定设备节点路径</td></tr></tbody></table><h4 id="实时监控">实时监控</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udevadm monitor</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.性能测定</title>
      <link href="/2020/11/07/linux/11-%E6%80%A7%E8%83%BD%E6%B5%8B%E5%AE%9A/"/>
      <url>/2020/11/07/linux/11-%E6%80%A7%E8%83%BD%E6%B5%8B%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="1-top-命令-实时进程监控">1. top 命令 - 实时进程监控</h2><h3 id="基本用法">基本用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [选项]</span><br></pre></td></tr></table></figure><h3 id="常用选项">常用选项</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>批处理模式（非交互式）</td></tr><tr><td>-d 秒</td><td>设置刷新间隔时间</td></tr><tr><td>-n 次数</td><td>指定刷新次数后退出</td></tr><tr><td>-u 用户</td><td>只显示指定用户的进程</td></tr><tr><td>-p PID</td><td>只监控指定PID的进程</td></tr></tbody></table><h3 id="显示字段说明">显示字段说明</h3><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>PID</td><td>进程ID</td></tr><tr><td>PPID</td><td>父进程ID</td></tr><tr><td>USER</td><td>进程所有者</td></tr><tr><td>RUSER</td><td>实际用户名</td></tr><tr><td>UID</td><td>用户ID</td></tr><tr><td>GROUP</td><td>所属组</td></tr><tr><td>PR</td><td>优先级</td></tr><tr><td>NI</td><td>nice值</td></tr><tr><td>VIRT</td><td>虚拟内存使用量(KB)</td></tr><tr><td>RES</td><td>物理内存使用量(KB)</td></tr><tr><td>SHR</td><td>共享内存大小(KB)</td></tr><tr><td>S</td><td>进程状态</td></tr><tr><td>TTY</td><td>关联终端</td></tr><tr><td>%CPU</td><td>CPU使用率</td></tr><tr><td>%MEM</td><td>内存使用率</td></tr><tr><td>TIME+</td><td>CPU占用时间累计</td></tr><tr><td>COMMAND</td><td>执行的命令</td></tr></tbody></table><h3 id="交互式操作">交互式操作</h3><table><thead><tr><th>按键</th><th>功能说明</th></tr></thead><tbody><tr><td>空格/Enter</td><td>立即刷新</td></tr><tr><td>f</td><td>选择显示字段</td></tr><tr><td>o</td><td>修改排序字段</td></tr><tr><td>l</td><td>切换负载显示</td></tr><tr><td>m</td><td>切换内存显示</td></tr><tr><td>u</td><td>筛选用户进程</td></tr><tr><td>t</td><td>切换CPU状态显示</td></tr><tr><td>P</td><td>按CPU%排序</td></tr><tr><td>M</td><td>按内存%排序</td></tr><tr><td>N</td><td>按PID排序</td></tr><tr><td>T</td><td>按运行时间排序</td></tr><tr><td>W</td><td>保存当前配置</td></tr><tr><td>k</td><td>结束进程</td></tr><tr><td>h/?</td><td>帮助信息</td></tr><tr><td>q</td><td>退出程序</td></tr><tr><td>A</td><td>切换显示模式</td></tr><tr><td>d/s</td><td>修改刷新间隔</td></tr><tr><td>&lt;/&gt;</td><td>切换排序顺序</td></tr></tbody></table><h2 id="2-vmstat-系统资源监控">2. vmstat - 系统资源监控</h2><h3 id="基本用法-2">基本用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmstat [刷新间隔(秒)] [刷新次数]</span><br></pre></td></tr></table></figure><h3 id="输出字段说明">输出字段说明</h3><table><thead><tr><th>类别</th><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>procs</td><td>r</td><td>运行队列中的进程数（若持续超过CPU核心数表示CPU瓶颈）</td></tr><tr><td></td><td>b</td><td>等待I/O的进程数</td></tr><tr><td>memory</td><td>swpd</td><td>使用的swap空间大小</td></tr><tr><td></td><td>free</td><td>空闲内存</td></tr><tr><td></td><td>buff</td><td>用作buffer的内存</td></tr><tr><td></td><td>cache</td><td>用作cache的内存</td></tr><tr><td>swap</td><td>si</td><td>每秒从swap读入内存量</td></tr><tr><td></td><td>so</td><td>每秒从内存写入swap量</td></tr><tr><td>io</td><td>bi</td><td>块设备每秒接收的块数</td></tr><tr><td></td><td>bo</td><td>块设备每秒发送的块数</td></tr><tr><td>system</td><td>in</td><td>每秒中断数</td></tr><tr><td></td><td>cs</td><td>每秒上下文切换数</td></tr><tr><td>cpu</td><td>us</td><td>用户空间CPU时间占比</td></tr><tr><td></td><td>sy</td><td>内核空间CPU时间占比</td></tr><tr><td></td><td>id</td><td>CPU空闲时间占比</td></tr><tr><td></td><td>wa</td><td>I/O等待时间占比</td></tr><tr><td></td><td>st</td><td>虚拟机偷取时间占比</td></tr></tbody></table><h2 id="3-iostat-I-O监控">3. iostat - I/O监控</h2><h3 id="基本用法-3">基本用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat [选项] [间隔秒数] [次数]</span><br></pre></td></tr></table></figure><h3 id="常用选项-2">常用选项</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>只显示CPU统计</td></tr><tr><td>-d</td><td>只显示磁盘统计</td></tr><tr><td>-k</td><td>以KB为单位显示</td></tr><tr><td>-t</td><td>显示时间戳</td></tr></tbody></table><h3 id="CPU统计字段">CPU统计字段</h3><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>%user</td><td>用户进程CPU占比</td></tr><tr><td>%nice</td><td>调整优先级进程的CPU占比</td></tr><tr><td>%system</td><td>内核CPU占比</td></tr><tr><td>%iowait</td><td>I/O等待占比</td></tr><tr><td>%steal</td><td>虚拟机占用占比</td></tr><tr><td>%idle</td><td>空闲占比</td></tr></tbody></table><h3 id="磁盘统计字段">磁盘统计字段</h3><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>tps</td><td>每秒I/O请求数</td></tr><tr><td>Blk_read/s</td><td>每秒读取块数</td></tr><tr><td>Blk_wrtn/s</td><td>每秒写入块数</td></tr><tr><td>Blk_read</td><td>总读取块数</td></tr><tr><td>Blk_wrtn</td><td>总写入块数</td></tr></tbody></table><h2 id="4-sar-系统活动报告">4. sar - 系统活动报告</h2><h3 id="基本用法-4">基本用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar [选项] [-s 开始时间] [-e 结束时间] [-f 日志文件] [间隔] [次数]</span><br></pre></td></tr></table></figure><h3 id="常用选项-3">常用选项</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-A</td><td>显示所有报告</td></tr><tr><td>-b</td><td>I/O和传输速率统计</td></tr><tr><td>-c</td><td>进程创建统计</td></tr><tr><td>-f 文件</td><td>指定日志文件</td></tr><tr><td>-n DEV</td><td>网络设备统计</td></tr><tr><td>-n EDEV</td><td>网络错误统计</td></tr><tr><td>-r</td><td>内存和swap统计</td></tr><tr><td>-u</td><td>CPU利用率</td></tr><tr><td>-P ALL</td><td>每个CPU核心统计</td></tr><tr><td>-R</td><td>内存统计</td></tr><tr><td>-W</td><td>swap统计</td></tr></tbody></table><h3 id="详细字段说明">详细字段说明</h3><h4 id="sar-b-I-O统计">sar -b (I/O统计)</h4><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>tps</td><td>每秒I/O请求数</td></tr><tr><td>rtps</td><td>每秒读请求数</td></tr><tr><td>wtps</td><td>每秒写请求数</td></tr><tr><td>bread/s</td><td>每秒读取块数</td></tr><tr><td>bwrtn/s</td><td>每秒写入块数</td></tr></tbody></table><h4 id="sar-n-DEV-网络统计">sar -n DEV (网络统计)</h4><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>IFACE</td><td>网络接口名</td></tr><tr><td>rxpck/s</td><td>每秒接收包数</td></tr><tr><td>txpck/s</td><td>每秒发送包数</td></tr><tr><td>rxkB/s</td><td>每秒接收KB数</td></tr><tr><td>txkB/s</td><td>每秒发送KB数</td></tr></tbody></table><h4 id="sar-r-内存统计">sar -r (内存统计)</h4><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>kbmemfree</td><td>空闲内存(KB)</td></tr><tr><td>kbmemused</td><td>已用内存(KB)</td></tr><tr><td>%memused</td><td>内存使用率</td></tr><tr><td>kbbuffers</td><td>buffer使用量(KB)</td></tr><tr><td>kbcached</td><td>cache使用量(KB)</td></tr></tbody></table><h2 id="5-系统负载命令">5. 系统负载命令</h2><h3 id="uptime">uptime</h3><p>显示：</p><ol><li>系统运行时间</li><li>登录用户数</li><li>1/5/15分钟平均负载</li></ol><h3 id="w-命令">w 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w [选项] [用户名]</span><br></pre></td></tr></table></figure><h4 id="选项">选项</h4><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-h</td><td>不显示标题</td></tr><tr><td>-s</td><td>精简格式(不显示登录时间/JCPU/PCPU)</td></tr></tbody></table><h4 id="输出字段">输出字段</h4><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>USER</td><td>用户名</td></tr><tr><td>TTY</td><td>终端名</td></tr><tr><td>FROM</td><td>远程主机</td></tr><tr><td>LOGIN@</td><td>登录时间</td></tr><tr><td>IDLE</td><td>空闲时间</td></tr><tr><td>JCPU</td><td>该终端所有进程CPU时间</td></tr><tr><td>PCPU</td><td>当前进程CPU时间</td></tr><tr><td>WHAT</td><td>正在执行的命令</td></tr></tbody></table><h2 id="6-进程监控">6. 进程监控</h2><h3 id="ps-命令">ps 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [选项]</span><br></pre></td></tr></table></figure><h4 id="常用选项-4">常用选项</h4><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>a</td><td>显示所有进程</td></tr><tr><td>e</td><td>显示环境变量</td></tr><tr><td>x</td><td>包括无终端进程</td></tr><tr><td>u</td><td>显示用户信息</td></tr><tr><td>r</td><td>只显示运行中进程</td></tr><tr><td>l</td><td>长格式显示</td></tr><tr><td>U 用户</td><td>筛选指定用户</td></tr><tr><td>-C 命令</td><td>筛选指定命令</td></tr><tr><td>-e</td><td>显示所有进程</td></tr><tr><td>-f</td><td>完整格式显示</td></tr><tr><td>-l</td><td>长格式显示</td></tr><tr><td>-p PID</td><td>筛选指定PID</td></tr><tr><td>-t tty</td><td>筛选指定终端</td></tr></tbody></table><h4 id="显示字段">显示字段</h4><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>USER</td><td>用户名</td></tr><tr><td>PID</td><td>进程ID</td></tr><tr><td>PPID</td><td>父进程ID</td></tr><tr><td>%CPU</td><td>CPU使用率</td></tr><tr><td>%MEM</td><td>内存使用率</td></tr><tr><td>VSZ</td><td>虚拟内存大小</td></tr><tr><td>RSS</td><td>物理内存大小</td></tr><tr><td>TTY</td><td>关联终端</td></tr><tr><td>STAT</td><td>进程状态</td></tr><tr><td>START</td><td>启动时间</td></tr><tr><td>TIME</td><td>CPU占用时间</td></tr><tr><td>COMMAND</td><td>执行的命令</td></tr></tbody></table><h3 id="其他进程工具">其他进程工具</h3><ul><li><code>pstree</code>：以树状显示进程关系</li><li><code>lsof</code>：列出打开的文件</li></ul><h2 id="7-内存监控">7. 内存监控</h2><h3 id="free-命令">free 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free [选项]</span><br></pre></td></tr></table></figure><h4 id="选项-2">选项</h4><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>以字节显示</td></tr><tr><td>-k</td><td>以KB显示(默认)</td></tr><tr><td>-m</td><td>以MB显示</td></tr><tr><td>-t</td><td>显示总计行</td></tr><tr><td>-o</td><td>不显示buffer行</td></tr><tr><td>-s 秒</td><td>持续监控间隔</td></tr></tbody></table><h4 id="输出字段-2">输出字段</h4><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>total</td><td>总内存量</td></tr><tr><td>used</td><td>已用量(含buffer/cache)</td></tr><tr><td>free</td><td>空闲量(含buffer/cache)</td></tr><tr><td>shared</td><td>共享内存</td></tr><tr><td>buffers</td><td>buffer缓存</td></tr><tr><td>cached</td><td>page cache</td></tr><tr><td>-/+ buffers/cache</td><td>实际内存使用</td></tr><tr><td>used</td><td>不含buffer/cache的用量</td></tr><tr><td>free</td><td>含buffer/cache的空闲量</td></tr></tbody></table><h2 id="8-磁盘与网络监控">8. 磁盘与网络监控</h2><h3 id="df-命令">df 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> [选项] [目录]</span><br></pre></td></tr></table></figure><h4 id="选项-3">选项</h4><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>显示所有文件系统</td></tr><tr><td>-h</td><td>人性化显示(1024进制)</td></tr><tr><td>-H</td><td>人性化显示(1000进制)</td></tr><tr><td>-i</td><td>显示inode信息</td></tr><tr><td>-l</td><td>只显示本地文件系统</td></tr><tr><td>-m</td><td>以MB为单位显示</td></tr></tbody></table><h3 id="网络测试工具">网络测试工具</h3><ul><li><code>netserver</code>：启动测试服务(监听12865端口)</li><li><code>netperf</code>：网络性能测试客户端</li></ul><h2 id="9-高级监控系统">9. 高级监控系统</h2><h3 id="collectd">collectd</h3><p>监控项目包括：</p><ul><li>CPU使用率</li><li>系统温度和风扇状态</li><li>进程状态</li><li>网络流量和延迟</li><li>Web服务器状态(APACHE/Nginx)</li><li>DNS服务器状态</li><li>数据库状态</li><li>SWAP使用情况</li><li>用户登录情况</li></ul><h3 id="Nagios">Nagios</h3><p>功能特点：</p><ul><li>网络服务监控</li><li>系统资源监控</li><li>基于Web的监控界面</li><li>邮件/SMS告警通知</li><li>自定义事件处理</li><li>日志自动轮转</li><li>支持分层主机结构</li></ul><h3 id="可视化工具">可视化工具</h3><ul><li><strong>MRTG</strong>：网络流量可视化</li><li><strong>Cacti</strong>：MRTG的增强替代品，提供更丰富的监控功能</li></ul><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.安全</title>
      <link href="/2020/06/24/linux/10-%E5%AE%89%E5%85%A8/"/>
      <url>/2020/06/24/linux/10-%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1>守护进程管理与系统安全笔记整理</h1><h2 id="守护进程管理">守护进程管理</h2><h3 id="Super-Server-超级服务器">Super Server (超级服务器)</h3><ul><li><strong>作用</strong>：代替其他服务监视服务请求，建立连接后转交给实际服务处理</li><li><strong>优势</strong>：降低系统负载，不需要为每个服务都启动独立进程</li></ul><h3 id="inetd-Internet-Daemon">inetd (Internet Daemon)</h3><ul><li>传统的超级服务器守护进程</li><li>配置文件：<code>/etc/inetd.conf</code></li></ul><h4 id="inetd-conf-字段说明">inetd.conf 字段说明</h4><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>service_name</td><td><code>/etc/services</code>中定义的服务名</td></tr><tr><td>socket_type</td><td>socket类型(TCP=stream, UDP=dgram)</td></tr><tr><td>protocol</td><td>协议类型(通常TCP/UDP)</td></tr><tr><td>flags</td><td>请求处理方式(wait=等待处理完成, nowait=立即处理下一个)</td></tr><tr><td>user</td><td>执行用户</td></tr><tr><td>program</td><td>程序绝对路径</td></tr><tr><td>args</td><td>转发参数</td></tr></tbody></table><h4 id="重启inetd">重启inetd</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP inetd的PID</span><br><span class="line">killall -HUP inetd</span><br><span class="line">/etc/init.d/inetd restart</span><br></pre></td></tr></table></figure><h3 id="TCP-Wrapper">TCP Wrapper</h3><ul><li>访问控制机制，检查顺序：<ol><li>先查<code>/etc/hosts.allow</code> → 匹配则允许</li><li>再查<code>/etc/hosts.deny</code> → 匹配则拒绝</li><li>都不匹配则允许</li></ol></li></ul><h4 id="通配符说明">通配符说明</h4><table><thead><tr><th>通配符</th><th>说明</th></tr></thead><tbody><tr><td>ALL</td><td>所有服务和主机</td></tr><tr><td>A EXCEPT B</td><td>除B以外的A</td></tr><tr><td>LOCAL</td><td>本地主机(不含.)</td></tr><tr><td>PARANOID</td><td>主机名与DNS解析IP不一致的情况</td></tr></tbody></table><h4 id="示例配置">示例配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in.telnetd: .lpic.jp  # 允许lpic.jp域访问telnet</span><br><span class="line">ALL: 192.168.2.      # 允许192.168.2.x网段所有服务</span><br></pre></td></tr></table></figure><h3 id="xinetd-扩展的inetd">xinetd (扩展的inetd)</h3><ul><li>更安全的超级服务器，支持分服务配置</li><li>主配置文件：<code>/etc/xinetd.conf</code></li><li>服务配置文件：<code>/etc/xinetd.d/</code></li></ul><h4 id="xinetd-conf-主要参数">xinetd.conf 主要参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">default</span><br><span class="line">&#123;</span><br><span class="line">    instance = 60               <span class="comment"># 最大守护进程数</span></span><br><span class="line">    log_type = SYSLOG authpriv  <span class="comment"># 日志类型</span></span><br><span class="line">    log_on_success = HOST PID   <span class="comment"># 成功日志内容</span></span><br><span class="line">    log_on_failure = HOST       <span class="comment"># 失败日志内容</span></span><br><span class="line">    cps = 25 30                 <span class="comment"># 每秒最大连接数(超限后暂停30秒)</span></span><br><span class="line">&#125;</span><br><span class="line">includedir /etc/xinetd.d        <span class="comment"># 包含服务配置目录</span></span><br></pre></td></tr></table></figure><h4 id="服务配置示例-telnet">服务配置示例(telnet)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">service telnet</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">disable</span> = no</span><br><span class="line">    socket_type = stream</span><br><span class="line">    <span class="built_in">wait</span> = no</span><br><span class="line">    user = root</span><br><span class="line">    server = /usr/sbin/in.telnetd</span><br><span class="line">    log_on_failure += USERID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重启xinetd">重启xinetd</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/xinetd restart</span><br></pre></td></tr></table></figure><h2 id="端口安全">端口安全</h2><h3 id="检查开放端口">检查开放端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netstat -atun       <span class="comment"># 显示所有TCP/UDP端口</span></span><br><span class="line">lsof -i -n          <span class="comment"># 查看网络连接</span></span><br><span class="line">lsof -i :22         <span class="comment"># 查看指定端口</span></span><br><span class="line">lsof -c ssh         <span class="comment"># 查看指定进程</span></span><br></pre></td></tr></table></figure><h3 id="nmap-扫描">nmap 扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap 目标主机       <span class="comment"># 扫描主机开放端口</span></span><br></pre></td></tr></table></figure><h3 id="查找特殊权限文件">查找特殊权限文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u+s -<span class="built_in">ls</span>   <span class="comment"># 查找SUID文件</span></span><br><span class="line">find / -perm -g+s -<span class="built_in">ls</span>   <span class="comment"># 查找SGID文件</span></span><br><span class="line">find / -perm -o+t -<span class="built_in">ls</span>   <span class="comment"># 查找sticky bit文件</span></span><br></pre></td></tr></table></figure><h2 id="用户安全">用户安全</h2><h3 id="密码有效期设置-chage">密码有效期设置(chage)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chage [选项] 用户名</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-l</td><td>显示有效期</td></tr><tr><td>-m 天数</td><td>密码最小使用天数</td></tr><tr><td>-M 天数</td><td>密码最大有效期</td></tr><tr><td>-d 日期</td><td>最后修改日期</td></tr><tr><td>-W 天数</td><td>密码过期前警告天数</td></tr><tr><td>-I 天数</td><td>密码过期后锁定前天数</td></tr><tr><td>-E 日期</td><td>账号失效日期</td></tr></tbody></table><h3 id="禁止登录方法">禁止登录方法</h3><ol><li>创建<code>/etc/nologin</code>文件：禁止所有非root用户登录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> /etc/nologin</span><br></pre></td></tr></table></figure></li><li>修改用户shell：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -s /sbin/nologin 用户名  <span class="comment"># 禁止指定用户登录</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="su-sudo">su/sudo</h3><h4 id="su-切换用户">su (切换用户)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su - 用户名   <span class="comment"># 完全切换(加载环境变量)</span></span><br><span class="line">su 用户名     <span class="comment"># 部分切换(保留当前环境)</span></span><br></pre></td></tr></table></figure><h4 id="sudo-超级用户权限">sudo (超级用户权限)</h4><ul><li>配置文件：<code>/etc/sudoers</code> (使用<code>visudo</code>编辑)</li><li>示例配置：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许student用户执行shutdown</span></span><br><span class="line">student ALL=(ALL) /sbin/shutdown</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许wheel组成员执行所有命令且不输密码</span></span><br><span class="line">%wheel ALL=(ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure></li></ul><h3 id="资源限制-ulimit">资源限制(ulimit)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> [选项] [限制值]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>显示所有限制</td></tr><tr><td>-c size</td><td>核心文件大小</td></tr><tr><td>-f size</td><td>最大文件大小</td></tr><tr><td>-n num</td><td>打开文件数限制</td></tr><tr><td>-u num</td><td>用户最大进程数</td></tr><tr><td>-v size</td><td>最大虚拟内存</td></tr></tbody></table><h2 id="OpenSSH-安全">OpenSSH 安全</h2><h3 id="SSH密钥文件">SSH密钥文件</h3><table><thead><tr><th>文件名</th><th>说明</th></tr></thead><tbody><tr><td>ssh_host_key</td><td>SSH1私钥</td></tr><tr><td>ssh_host_dsa_key</td><td>SSH2 DSA私钥</td></tr><tr><td>ssh_host_rsa_key</td><td>SSH2 RSA私钥</td></tr><tr><td>*.pub</td><td>对应公钥</td></tr></tbody></table><h3 id="sshd配置-etc-ssh-sshd-config">sshd配置(/etc/ssh/sshd_config)</h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>Port</td><td>SSH端口(默认22)</td></tr><tr><td>Protocol</td><td>SSH版本(1,2)</td></tr><tr><td>HostKey</td><td>私钥文件路径</td></tr><tr><td>PermitRootLogin</td><td>是否允许root登录</td></tr><tr><td>RSAAuthentication</td><td>是否启用SSH1公钥认证</td></tr><tr><td>PubkeyAuthentication</td><td>是否启用SSH2公钥认证</td></tr><tr><td>AuthorizedKeysFile</td><td>授权公钥文件路径</td></tr><tr><td>PermitEmptyPasswords</td><td>是否允许空密码</td></tr><tr><td>PasswordAuthentication</td><td>是否启用密码认证</td></tr><tr><td>X11Forwarding</td><td>是否允许X11转发</td></tr></tbody></table><h3 id="SSH密钥认证流程">SSH密钥认证流程</h3><ol><li>客户端生成密钥对：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa   <span class="comment"># 生成RSA密钥对</span></span><br></pre></td></tr></table></figure></li><li>上传公钥到服务器：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id 用户名@服务器</span><br></pre></td></tr></table></figure></li><li>服务器端公钥存储在：<code>~/.ssh/authorized_keys</code></li></ol><h3 id="SSH实用命令">SSH实用命令</h3><h4 id="scp-安全复制">scp (安全复制)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp 文件 用户@主机:路径   <span class="comment"># 上传</span></span><br><span class="line">scp -r 目录 用户@主机:路径 <span class="comment"># 递归复制目录</span></span><br></pre></td></tr></table></figure><h4 id="ssh-agent-密钥代理">ssh-agent (密钥代理)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> `ssh-agent`   <span class="comment"># 启动代理</span></span><br><span class="line">ssh-add            <span class="comment"># 添加密钥</span></span><br><span class="line">ssh-add -l         <span class="comment"># 列出已加载密钥</span></span><br></pre></td></tr></table></figure><h4 id="端口转发">端口转发</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地端口转发</span></span><br><span class="line">ssh -L 本地端口:远程主机:远程端口 用户@网关</span><br><span class="line"></span><br><span class="line"><span class="comment"># X11转发</span></span><br><span class="line">ssh -X 用户@主机</span><br></pre></td></tr></table></figure><h2 id="GnuPG-文件加密">GnuPG 文件加密</h2><h3 id="密钥管理">密钥管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gpg --gen-key              <span class="comment"># 生成密钥对</span></span><br><span class="line">gpg --list-keys            <span class="comment"># 列出密钥</span></span><br><span class="line">gpg --<span class="built_in">export</span> -a <span class="string">&quot;用户&quot;</span> &gt; pubkey.asc  <span class="comment"># 导出公钥</span></span><br><span class="line">gpg --import pubkey.asc    <span class="comment"># 导入公钥</span></span><br></pre></td></tr></table></figure><h3 id="文件加密-解密">文件加密/解密</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加密文件(给指定用户)</span></span><br><span class="line">gpg -e -a -r 接收者邮件 文件</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密文件</span></span><br><span class="line">gpg 加密文件.asc</span><br></pre></td></tr></table></figure><h3 id="密钥吊销">密钥吊销</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpg --gen-revoke 用户邮件 &gt; revoke.asc  <span class="comment"># 生成吊销证书</span></span><br><span class="line">gpg --import revoke.asc                 <span class="comment"># 导入吊销证书</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.TCP-IP</title>
      <link href="/2020/06/18/linux/9-TCP-IP/"/>
      <url>/2020/06/18/linux/9-TCP-IP/</url>
      
        <content type="html"><![CDATA[<h1>TCP/IP 基础笔记整理</h1><h2 id="IPv4-地址分类">IPv4 地址分类</h2><h3 id="标准分类">标准分类</h3><table><thead><tr><th>类别</th><th>IP 地址范围</th><th>子网掩码</th></tr></thead><tbody><tr><td>A</td><td>0.0.0.0 ~ 127.255.255.255</td><td>255.0.0.0</td></tr><tr><td>B</td><td>128.0.0.0 ~ 191.255.255.255</td><td>255.255.0.0</td></tr><tr><td>C</td><td>192.0.0.0 ~ 223.255.255.255</td><td>255.255.255.0</td></tr></tbody></table><h3 id="私有地址范围">私有地址范围</h3><table><thead><tr><th>类别</th><th>IP 地址范围</th></tr></thead><tbody><tr><td>A</td><td>10.0.0.0 ~ 10.255.255.255</td></tr><tr><td>B</td><td>172.16.0.0 ~ 172.31.255.255</td></tr><tr><td>C</td><td>192.168.0.0 ~ 192.168.255.255</td></tr></tbody></table><h2 id="CIDR-Classless-Inter-Domain-Routing">CIDR (Classless Inter-Domain Routing)</h2><ul><li>无类别域间路由</li><li>允许更灵活的子网划分方式，不再受传统 A/B/C 类限制</li></ul><h2 id="IPv6">IPv6</h2><ul><li>128 比特地址，用 16 进制表示，分为 8 个 block</li><li>表示规则：<ol><li>每个 block 开头的 0 可以省略</li><li>连续的 0 可以用 <code>::</code> 表示，但整个地址中 <code>::</code> 只能出现一次</li></ol></li></ul><h3 id="IPv6-地址类型">IPv6 地址类型</h3><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>单播地址 (Unicast)</td><td>标识单个接口，类似 IPv4 单播地址</td></tr><tr><td>组播地址 (Multicast)</td><td>标识一组接口，类似 IPv4 组播地址</td></tr><tr><td>任播地址 (Anycast)</td><td>新增类型，数据包发送给最近的一个接口</td></tr></tbody></table><h2 id="端口-Port">端口 (Port)</h2><ul><li><code>/etc/services</code>：端口与服务对应关系文件</li><li>常用端口：</li></ul><table><thead><tr><th>端口</th><th>协议</th><th>服务</th><th>说明</th></tr></thead><tbody><tr><td>20</td><td>TCP</td><td>FTP</td><td>文件传输(数据)</td></tr><tr><td>21</td><td>TCP</td><td>FTP</td><td>文件传输(控制)</td></tr><tr><td>22</td><td>TCP</td><td>SSH</td><td>安全Shell</td></tr><tr><td>23</td><td>TCP</td><td>Telnet</td><td>远程登录</td></tr><tr><td>25</td><td>TCP/UDP</td><td>SMTP</td><td>邮件发送</td></tr><tr><td>53</td><td>TCP/UDP</td><td>DNS</td><td>域名解析</td></tr><tr><td>80</td><td>TCP</td><td>HTTP</td><td>Web服务</td></tr><tr><td>110</td><td>TCP</td><td>POP3</td><td>邮件接收</td></tr><tr><td>119</td><td>TCP</td><td>NNTP</td><td>网络新闻</td></tr><tr><td>139</td><td>TCP/UDP</td><td>NetBIOS</td><td>Windows网络</td></tr><tr><td>143</td><td>TCP</td><td>IMAP</td><td>邮件访问</td></tr><tr><td>161</td><td>UDP</td><td>SNMP</td><td>网络管理</td></tr><tr><td>443</td><td>TCP</td><td>HTTPS</td><td>安全Web</td></tr><tr><td>465</td><td>TCP</td><td>SMTPS</td><td>安全SMTP</td></tr><tr><td>993</td><td>TCP</td><td>IMAPS</td><td>安全IMAP</td></tr><tr><td>995</td><td>TCP</td><td>POP3S</td><td>安全POP3</td></tr></tbody></table><h2 id="nsswitch-conf-文件">nsswitch.conf 文件</h2><p>控制各种系统数据库的搜索顺序和方法</p><h3 id="1-信息类型-Info">1. 信息类型(Info)</h3><ul><li><code>automount</code>：自动挂载信息</li><li><code>bootparams</code>：引导选项</li><li><code>ethers</code>：MAC地址</li><li><code>group</code>：用户组信息</li><li><code>hosts</code>：主机名和IP</li><li><code>networks</code>：网络信息</li><li><code>passwd</code>：用户信息</li><li><code>protocols</code>：网络协议</li><li><code>publickey</code>：NIS+/NFS公钥</li><li><code>rpc</code>：远程过程调用</li><li><code>services</code>：网络服务</li><li><code>shadow</code>：用户密码信息</li><li><code>aliases</code>：邮件别名</li></ul><h3 id="2-搜索方法-method">2. 搜索方法(method)</h3><ul><li><code>files</code>：搜索本地文件</li><li><code>nis</code>：搜索NIS数据库</li><li><code>dns</code>：查询DNS</li><li><code>compat</code>：兼容模式(±语法)</li></ul><h3 id="3-搜索顺序">3. 搜索顺序</h3><p>从左到右依次尝试，先找到的结果优先</p><h3 id="4-动作项-action">4. 动作项([action])</h3><p>格式：<code>[[!]STATUS=action]</code></p><ul><li>STATUS：<ul><li><code>NOTFOUND</code>：未找到</li><li><code>SUCCESS</code>：成功找到</li><li><code>UNAVAIL</code>：永久不可用</li><li><code>TRYAGAIN</code>：临时不可用</li></ul></li><li>action：<ul><li><code>return</code>：返回结果</li><li><code>continue</code>：继续尝试下个方法</li></ul></li></ul><h3 id="5-compat方法">5. compat方法</h3><p>在passwd/group/shadow文件中使用<code>+</code>和<code>-</code>来合并NIS信息</p><h2 id="网络故障排除命令">网络故障排除命令</h2><h3 id="ping">ping</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ping 主机名或IP地址</span><br><span class="line">ping -c 次数 目标  <span class="comment"># 指定发送次数</span></span><br><span class="line">ping -i 间隔 目标  <span class="comment"># 指定发送间隔</span></span><br></pre></td></tr></table></figure><ul><li>TTL：ICMP包最大生存时间</li><li>time：响应时间</li></ul><h3 id="traceroute-tracepath">traceroute/tracepath</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">traceroute 主机名或IP地址</span><br><span class="line">tracepath 主机名或IP地址 [端口]</span><br></pre></td></tr></table></figure><ul><li>显示到达目标的路径</li></ul><h3 id="host">host</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">host [选项] 主机名或IP [DNS服务器]</span><br><span class="line">host -v 目标  <span class="comment"># 显示详细信息</span></span><br></pre></td></tr></table></figure><ul><li>查询DNS信息</li></ul><h3 id="hostname">hostname</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hostname  <span class="comment"># 显示当前主机名</span></span><br><span class="line">hostname 新主机名  <span class="comment"># 设置主机名</span></span><br></pre></td></tr></table></figure><h3 id="netstat">netstat</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">netstat -a  <span class="comment"># 显示所有socket</span></span><br><span class="line">netstat -c  <span class="comment"># 实时更新</span></span><br><span class="line">netstat -i  <span class="comment"># 显示接口状态</span></span><br><span class="line">netstat -n  <span class="comment"># 显示数字地址</span></span><br><span class="line">netstat -p  <span class="comment"># 显示PID/进程名</span></span><br><span class="line">netstat -r  <span class="comment"># 显示路由表</span></span><br><span class="line">netstat -t  <span class="comment"># 只显示TCP</span></span><br><span class="line">netstat -u  <span class="comment"># 只显示UDP</span></span><br></pre></td></tr></table></figure><h3 id="route">route</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">route  <span class="comment"># 显示路由表</span></span><br><span class="line">route add -net 目标网络 netmask 子网掩码 gw 网关</span><br><span class="line">route add default gw 默认网关</span><br><span class="line">route del -net 目标网络</span><br></pre></td></tr></table></figure><p>路由表字段说明：</p><ul><li>Destination：目标网络/主机</li><li>Gateway：网关</li><li>Genmask：子网掩码</li><li>Flags：标志(U=有效,H=主机,G=网关)</li><li>Metric：距离</li><li>Ref：引用数</li><li>Use：使用计数</li><li>Iface：接口</li></ul><h3 id="ifconfig">ifconfig</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig 接口名 IP地址 netmask 子网掩码</span><br><span class="line">ifconfig 接口名 up/down  <span class="comment"># 启用/禁用接口</span></span><br></pre></td></tr></table></figure><h3 id="ifup-ifdown">ifup/ifdown</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifup 接口名  <span class="comment"># 启用接口</span></span><br><span class="line">ifdown 接口名  <span class="comment"># 禁用接口</span></span><br></pre></td></tr></table></figure><h2 id="网络服务命令">网络服务命令</h2><h3 id="telnet">telnet</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 主机 [端口]  <span class="comment"># 默认端口23</span></span><br></pre></td></tr></table></figure><h3 id="ftp">ftp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ftp 主机</span><br><span class="line"><span class="comment"># 常用命令：</span></span><br><span class="line"><span class="built_in">ls</span>      <span class="comment"># 列出远程文件</span></span><br><span class="line"><span class="built_in">pwd</span>     <span class="comment"># 显示远程当前目录</span></span><br><span class="line">get     <span class="comment"># 下载文件</span></span><br><span class="line">mget    <span class="comment"># 下载多个文件</span></span><br><span class="line">put     <span class="comment"># 上传文件</span></span><br><span class="line">ascii   <span class="comment"># ASCII传输模式</span></span><br><span class="line">binary  <span class="comment"># 二进制传输模式</span></span><br><span class="line">quit    <span class="comment"># 退出</span></span><br></pre></td></tr></table></figure><h3 id="dig">dig</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dig [选项] @DNS服务器 主机名 域名 [查询类型]</span><br><span class="line">dig -x IP地址  <span class="comment"># 反向查询</span></span><br><span class="line"><span class="comment"># 查询类型：</span></span><br><span class="line">a    <span class="comment"># IP地址</span></span><br><span class="line">any  <span class="comment"># 所有信息</span></span><br><span class="line">mx   <span class="comment"># 邮件服务器</span></span><br><span class="line">ns   <span class="comment"># 名称服务器</span></span><br></pre></td></tr></table></figure><h3 id="whois">whois</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whois 目标 [@whois服务器]</span><br></pre></td></tr></table></figure><ul><li>查询域名注册信息</li></ul><h2 id="网络配置文件">网络配置文件</h2><h3 id="etc-hostname">/etc/hostname</h3><ul><li>存储主机名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windsor.lpic.jp</span><br></pre></td></tr></table></figure><h3 id="etc-hosts">/etc/hosts</h3><ul><li>主机名与IP映射</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 localhost.localdomain localhost</span><br><span class="line">192.168.0.1 windsor.example.com windsor</span><br></pre></td></tr></table></figure><h3 id="etc-nsswitch-conf">/etc/nsswitch.conf</h3><ul><li>名称服务切换配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hosts: files ldap dns  # 先查本地文件，再LDAP，最后DNS</span><br></pre></td></tr></table></figure><h3 id="etc-resolv-conf">/etc/resolv.conf</h3><ul><li>DNS配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">domain lpic.jp</span><br><span class="line">search lpic.jp</span><br><span class="line">nameserver 192.168.1.253</span><br><span class="line">nameserver 192.168.1.2</span><br></pre></td></tr></table></figure><h3 id="etc-sysconfig-network">/etc/sysconfig/network</h3><ul><li>基本网络设置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NETWORKING=YES</span><br><span class="line">HOSTNAME=lpic.example.net</span><br><span class="line">GATEWAY=192.168.0.254</span><br></pre></td></tr></table></figure><h3 id="etc-sysconfig-network-scripts">/etc/sysconfig/network-scripts/</h3><ul><li>网络接口配置文件(如ifcfg-eth0)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth0</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=192.168.0.6</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">NETWORK=192.168.0.0</span><br><span class="line">BROADCAST=192.168.0.255</span><br><span class="line">ONBOOT=yes</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytest基础</title>
      <link href="/2020/06/12/pytest%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/06/12/pytest%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述">1. 概述</h2><p>pytest 是一个功能强大的 Python 测试框架，具有以下特点：</p><ul><li>简单灵活，文档丰富</li><li>支持参数化测试</li><li>可用于单元测试、功能测试、自动化测试（如 Selenium/Appium）和接口测试</li><li>丰富的插件生态系统</li><li>支持测试跳过（skip）和预期失败（xfail）</li><li>良好的 CI 工具集成（如 Jenkins）</li></ul><h3 id="主要插件">主要插件</h3><table><thead><tr><th>插件名称</th><th>功能描述</th></tr></thead><tbody><tr><td>pytest-selenium</td><td>Selenium 集成</td></tr><tr><td>pytest-html</td><td>生成 HTML 测试报告</td></tr><tr><td>pytest-rerunfailures</td><td>失败用例重试</td></tr><tr><td>pytest-xdist</td><td>多 CPU 并行测试</td></tr></tbody></table><h2 id="2-使用介绍">2. 使用介绍</h2><h3 id="2-1-安装">2.1 安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest</span><br></pre></td></tr></table></figure><h3 id="2-2-编写规则">2.2 编写规则</h3><ul><li>测试文件：<code>test_*.py</code> 或 <code>*_test.py</code></li><li>测试类：以 <code>Test</code> 开头，不能有 <code>__init__</code> 方法</li><li>测试函数：以 <code>test_</code> 开头</li><li>断言：使用 Python 原生 <code>assert</code></li></ul><h3 id="2-3-示例代码">2.3 示例代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pytest1.py</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">&#x27;function&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setup_function</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">teardown_function</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;teardown_function called.&quot;</span>)</span><br><span class="line">    request.addfinalizer(teardown_function)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;setup_function called.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">&#x27;module&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setup_module</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">teardown_module</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;teardown_module called.&quot;</span>)</span><br><span class="line">    request.addfinalizer(teardown_module)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;setup_module called.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.website</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_1</span>(<span class="params">setup_function</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Test_1 called.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_2</span>(<span class="params">setup_module</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Test_2 called.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_3</span>(<span class="params">setup_module</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Test_3 called.&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-4-fixture-的-scope-参数">2.4 fixture 的 scope 参数</h3><table><thead><tr><th>参数值</th><th>作用范围</th></tr></thead><tbody><tr><td>function</td><td>每个测试函数运行一次（默认）</td></tr><tr><td>class</td><td>每个测试类运行一次</td></tr><tr><td>module</td><td>每个模块运行一次</td></tr><tr><td>session</td><td>每次会话运行一次</td></tr></tbody></table><h3 id="2-5-setup-和-teardown">2.5 setup 和 teardown</h3><ul><li><strong>setup</strong>：测试前的准备工作</li><li><strong>teardown</strong>：测试后的清理工作</li><li>替代方案：使用 <code>yield</code> 实现 setup/teardown</li></ul><h2 id="3-测试执行">3. 测试执行</h2><h3 id="3-1-基本执行命令">3.1 基本执行命令</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>pytest</code></td><td>运行当前目录下所有测试</td></tr><tr><td><code>pytest test_mod.py</code></td><td>运行指定模块的测试</td></tr><tr><td><code>pytest somepath/</code></td><td>运行指定路径下的测试</td></tr><tr><td><code>pytest -k &quot;stringexpr&quot;</code></td><td>运行名称匹配表达式的测试</td></tr><tr><td><code>pytest test_mod.py::test_func</code></td><td>运行指定模块的特定测试函数</td></tr></tbody></table><h3 id="3-2-标记执行">3.2 标记执行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行标记为 website 的测试</span></span><br><span class="line">pytest -v -m <span class="string">&quot;website&quot;</span> pytest1.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行未标记为 website 的测试</span></span><br><span class="line">pytest -v -m <span class="string">&quot;not website&quot;</span> pytest1.py</span><br></pre></td></tr></table></figure><h3 id="3-3-常用命令行参数">3.3 常用命令行参数</h3><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td><code>-v</code></td><td>显示详细测试结果</td></tr><tr><td><code>-q</code></td><td>只显示简要结果</td></tr><tr><td><code>-s</code></td><td>显示 print 输出</td></tr><tr><td><code>-x</code></td><td>遇到第一个失败立即停止</td></tr><tr><td><code>--exitfirst</code></td><td>同 <code>-x</code></td></tr><tr><td><code>-h</code></td><td>显示帮助信息</td></tr></tbody></table><h2 id="4-扩展插件">4. 扩展插件</h2><h3 id="4-1-测试覆盖率-pytest-cov">4.1 测试覆盖率 (pytest-cov)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest-cov</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 HTML 覆盖率报告</span></span><br><span class="line">pytest --cov-report=html --cov=./ test_code_target_dir</span><br></pre></td></tr></table></figure><p><strong>覆盖率参数</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>--cov=[path]</code></td><td>指定计算覆盖率的路径</td></tr><tr><td><code>--cov-report=type</code></td><td>报告类型：term, html, xml 等</td></tr><tr><td><code>--cov-fail-under=MIN</code></td><td>设置覆盖率最低阈值</td></tr></tbody></table><h3 id="4-2-其他实用插件">4.2 其他实用插件</h3><table><thead><tr><th>插件</th><th>功能</th><th>安装命令</th></tr></thead><tbody><tr><td>pytest-randomly</td><td>随机执行测试</td><td><code>pip install pytest-randomly</code></td></tr><tr><td>pytest-xdist</td><td>分布式测试</td><td><code>pip install pytest-xdist</code></td></tr><tr><td>pytest-instafail</td><td>立即显示失败</td><td><code>pip install pytest-instafail</code></td></tr></tbody></table><h2 id="5-示例输出">5. 示例输出</h2><h3 id="5-1-详细模式-v">5.1 详细模式 (-v)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ pytest -v pytest1.py</span><br><span class="line">==============================================================================</span><br><span class="line">platform linux2 -- Python 2.7.14, pytest-3.0.0</span><br><span class="line">collected 3 items</span><br><span class="line"></span><br><span class="line">pytest1.py::test_1 PASSED</span><br><span class="line">pytest1.py::test_3 PASSED</span><br><span class="line">pytest1.py::test_2 PASSED</span><br></pre></td></tr></table></figure><h3 id="5-2-显示输出-s">5.2 显示输出 (-s)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ pytest -s pytest1.py</span><br><span class="line">==============================================================================</span><br><span class="line">setup_function called.</span><br><span class="line">Test_1 called.</span><br><span class="line">.teardown_function called.</span><br><span class="line">setup_module called.</span><br><span class="line">Test_2 called.</span><br><span class="line">.Test_3 called.</span><br><span class="line">.teardown_module called.</span><br></pre></td></tr></table></figure><h3 id="5-3-覆盖率报告">5.3 覆盖率报告</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------------------------------- coverage: platform linux2, python 2.7.14-final-0 ----------------------------------------------------------------</span><br><span class="line">Name         Stmts   Miss  Cover</span><br><span class="line">--------------------------------</span><br><span class="line">pytest1.py      18      0   100%</span><br></pre></td></tr></table></figure><h2 id="6-参考资源">6. 参考资源</h2><ol><li><a href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy">Python 测试工具大全</a></li><li><a href="http://docs.python-guide.org/en/latest/writing/tests/">主流测试工具比较</a></li><li><a href="http://pythontesting.net/test-podcast/">pytest 官方播客</a></li><li><a href="https://blog.csdn.net/liuchunming033/article/details/46501653">pytest 简介</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> pytest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> devops </tag>
            
            <tag> python </tag>
            
            <tag> pytest </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.系统管理</title>
      <link href="/2020/05/24/linux/8-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
      <url>/2020/05/24/linux/8-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1>Linux 用户、群组与系统管理</h1><h2 id="1-用户和群组管理">1. 用户和群组管理</h2><h3 id="1-1-用户配置文件">1.1 用户配置文件</h3><h4 id="etc-passwd-文件格式">/etc/passwd 文件格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lpic:x:500:500:LPI linux:/home/lpic:/bin/bash</span><br><span class="line">↑    ↑ ↑   ↑   ↑         ↑          ↑</span><br><span class="line">│    │ │   │   │         │          └─ 默认shell</span><br><span class="line">│    │ │   │   │         └─────────── 家目录</span><br><span class="line">│    │ │   │   └───────────────────── 用户备注信息(GECOS)</span><br><span class="line">│    │ │   └───────────────────────── 主组GID</span><br><span class="line">│    │ └───────────────────────────── 用户UID</span><br><span class="line">│    └─────────────────────────────── 密码占位符(实际在/etc/shadow)</span><br><span class="line">└──────────────────────────────────── 用户名</span><br></pre></td></tr></table></figure><h4 id="etc-shadow-文件">/etc/shadow 文件</h4><ul><li>存储用户密码哈希值</li><li>只有root用户可访问</li><li>包含密码过期时间等安全信息</li></ul><h4 id="etc-group-文件格式">/etc/group 文件格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">staff:x:500:linux,lpic</span><br><span class="line">↑     ↑ ↑   ↑</span><br><span class="line">│     │ │   └───────────── 附加组成员</span><br><span class="line">│     │ └───────────────── 组GID</span><br><span class="line">│     └─────────────────── 组密码占位符</span><br><span class="line">└───────────────────────── 组名</span><br></pre></td></tr></table></figure><h3 id="1-2-用户管理命令">1.2 用户管理命令</h3><h4 id="useradd-添加用户">useradd - 添加用户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -c <span class="string">&quot;开发人员&quot;</span> -d /home/dev -g staff -G developers -s /bin/bash -m devuser</span><br></pre></td></tr></table></figure><p>常用选项：</p><ul><li><code>-c</code>：用户备注信息</li><li><code>-d</code>：指定家目录路径</li><li><code>-g</code>：指定主组</li><li><code>-G</code>：指定附加组</li><li><code>-s</code>：指定登录shell</li><li><code>-m</code>：自动创建家目录(从/etc/skel复制模板)</li></ul><h4 id="usermod-修改用户">usermod - 修改用户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -c <span class="string">&quot;高级开发&quot;</span> -G managers -s /bin/zsh devuser</span><br></pre></td></tr></table></figure><p>常用选项：</p><ul><li><code>-c</code>：备注:指定备注</li><li><code>-d</code>：path:home目录</li><li><code>-g</code>：组名/GID:所属主组</li><li><code>-G</code>：组名/GID:其他所属组</li><li><code>-s</code>：path: login shell</li><li><code>-L</code>：锁定用户密码</li><li><code>-U</code>：解锁用户密码</li></ul><h4 id="userdel-删除用户">userdel - 删除用户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel -r devuser  <span class="comment"># 删除用户并移除家目录</span></span><br></pre></td></tr></table></figure><h4 id="passwd-密码管理">passwd - 密码管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">passwd devuser      <span class="comment"># 设置密码</span></span><br><span class="line">passwd -l devuser   <span class="comment"># 锁定账户</span></span><br><span class="line">passwd -u devuser   <span class="comment"># 解锁账户</span></span><br></pre></td></tr></table></figure><h3 id="1-3-群组管理命令">1.3 群组管理命令</h3><h4 id="groupadd-添加组">groupadd - 添加组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd developers</span><br></pre></td></tr></table></figure><h4 id="groupmod-修改组">groupmod - 修改组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod -g 1001 -n devgroup developers</span><br></pre></td></tr></table></figure><ul><li><code>-g</code>：修改GID</li><li><code>-n</code>：修改组名</li></ul><h4 id="groupdel-删除组">groupdel - 删除组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel devgroup</span><br></pre></td></tr></table></figure><h4 id="id-查看用户信息">id - 查看用户信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> devuser  <span class="comment"># 显示用户UID、GID和所属组</span></span><br></pre></td></tr></table></figure><h2 id="2-系统时间管理">2. 系统时间管理</h2><h3 id="2-1-date-系统时间">2.1 date - 系统时间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> 093017002012.30    <span class="comment"># 设置为2012年9月30日17:00:30</span></span><br><span class="line"><span class="built_in">date</span> <span class="string">&quot;+%Y/%m/%d (%a)&quot;</span>   <span class="comment"># 格式化为&quot;2023/05/15 (Mon)&quot;</span></span><br></pre></td></tr></table></figure><p>常用格式符号：</p><ul><li><code>%Y</code>：4位年份</li><li><code>%m</code>：2位月份</li><li><code>%d</code>：2位日期</li><li><code>%H</code>：24小时制小时</li><li><code>%M</code>：分钟</li><li><code>%a</code>：星期缩写</li></ul><h3 id="2-2-hwclock-硬件时钟">2.2 hwclock - 硬件时钟</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hwclock --show          <span class="comment"># 显示硬件时钟</span></span><br><span class="line">hwclock --systohc       <span class="comment"># 系统时间同步到硬件时钟</span></span><br><span class="line">hwclock --hctosys       <span class="comment"># 硬件时钟同步到系统时间</span></span><br></pre></td></tr></table></figure><h3 id="2-3-NTP时间同步">2.3 NTP时间同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ntpdate time.server.lpic.jp  <span class="comment"># 手动同步时间</span></span><br><span class="line">service ntpd start           <span class="comment"># 启动NTP服务</span></span><br></pre></td></tr></table></figure><p>NTP配置文件(<code>/etc/ntp.conf</code>)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driftfile /etc/ntp.drift</span><br><span class="line">logfile /var/log/ntp.log</span><br><span class="line">server ntp.server.lpic.jp</span><br></pre></td></tr></table></figure><h2 id="3-系统日志管理">3. 系统日志管理</h2><h3 id="3-1-syslog-配置">3.1 syslog 配置</h3><p>配置文件：<code>/etc/syslog.conf</code></p><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">facility.priority    log_location</span><br></pre></td></tr></table></figure><h4 id="facility-设施-类型：">facility(设施)类型：</h4><ul><li><code>auth</code>/<code>authpriv</code>：认证相关</li><li><code>cron</code>：定时任务</li><li><code>daemon</code>：守护进程</li><li><code>kern</code>：内核消息</li><li><code>mail</code>：邮件系统</li><li><code>syslog</code>：syslog自身</li><li><code>local0</code>-<code>local7</code>：自定义设施</li></ul><h4 id="priority-优先级-：">priority(优先级)：</h4><ul><li><code>emerg</code>：紧急情况</li><li><code>alert</code>：需要立即处理</li><li><code>crit</code>：严重错误</li><li><code>err</code>：一般错误</li><li><code>warning</code>：警告</li><li><code>notice</code>：重要通知</li><li><code>info</code>：一般信息</li><li><code>debug</code>：调试信息</li></ul><h4 id="输出目标：">输出目标：</h4><ul><li>文件名：如<code>/var/log/messages</code></li><li><code>@host</code>：远程syslog服务器</li><li>用户名：发送到用户终端</li><li><code>*</code>：所有用户终端</li></ul><h3 id="3-2-logger-命令">3.2 logger 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger -p syslog.info -t TEST <span class="string">&quot;测试日志消息&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-3-常用日志文件">3.3 常用日志文件</h3><ul><li><code>/var/log/secure</code>：认证日志</li><li><code>/var/log/messages</code>：系统消息</li><li><code>/var/log/boot.log</code>：启动日志</li></ul><h3 id="3-4-用户登录信息">3.4 用户登录信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span>          <span class="comment"># 显示当前登录用户</span></span><br><span class="line">w            <span class="comment"># 显示详细登录信息</span></span><br><span class="line">last         <span class="comment"># 显示登录历史</span></span><br><span class="line">lastlog      <span class="comment"># 显示用户最近登录时间</span></span><br></pre></td></tr></table></figure><h3 id="3-5-日志轮转">3.5 日志轮转</h3><p>配置文件：<code>/etc/logrotate.conf</code></p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">weekly</span><br><span class="line">rotate 4</span><br><span class="line">create</span><br><span class="line">compress</span><br><span class="line"></span><br><span class="line">/var/log/wtmp &#123;</span><br><span class="line">    monthly</span><br><span class="line">    create 0664 root utmp</span><br><span class="line">    rotate 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-邮件系统">4. 邮件系统</h2><h3 id="4-1-邮件组件">4.1 邮件组件</h3><ul><li><strong>MTA</strong>(邮件传输代理)：sendmail/postfix/exim</li><li><strong>MDA</strong>(邮件投递代理)：procmail</li><li><strong>MUA</strong>(邮件用户代理)：mail/mutt/thunderbird</li></ul><h3 id="4-2-启动MTA">4.2 启动MTA</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service sendmail start</span><br><span class="line">service postfix start</span><br><span class="line">service exim4 start</span><br></pre></td></tr></table></figure><h3 id="4-3-mail-命令">4.3 mail 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mail -s <span class="string">&quot;测试邮件&quot;</span> user@example.com</span><br><span class="line">邮件正文...</span><br><span class="line">.   <span class="comment"># 单独一行输入点结束</span></span><br><span class="line">Cc: <span class="comment"># 抄送地址(可选)</span></span><br></pre></td></tr></table></figure><h3 id="4-4-邮件转发">4.4 邮件转发</h3><h4 id="etc-aliases">/etc/aliases</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root: admin,lpic</span><br></pre></td></tr></table></figure><p>更新别名数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newaliases</span><br></pre></td></tr></table></figure><h4 id="用户-forward文件">用户.forward文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/user/.forward:</span><br><span class="line">user2@example.com</span><br></pre></td></tr></table></figure><h2 id="5-打印系统">5. 打印系统</h2><h3 id="5-1-CUPS打印系统">5.1 CUPS打印系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service cups start  <span class="comment"># 启动CUPS服务</span></span><br></pre></td></tr></table></figure><p>主要配置文件：</p><ul><li><code>/etc/cups/cupsd.conf</code>：服务配置</li><li><code>/etc/cups/printers.conf</code>：打印机配置</li><li><code>/etc/cups/ppd/</code>：PPD驱动文件</li></ul><h3 id="5-2-打印命令">5.2 打印命令</h3><h4 id="lpr-打印文件">lpr - 打印文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpr -P LaserJet -#2 document.pdf</span><br></pre></td></tr></table></figure><h4 id="lpq-查看打印队列">lpq - 查看打印队列</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpq -P LaserJet</span><br></pre></td></tr></table></figure><h4 id="lprm-删除打印任务">lprm - 删除打印任务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lprm -P LaserJet 123  <span class="comment"># 删除指定任务</span></span><br><span class="line">lprm -P LaserJet -    <span class="comment"># 删除用户所有任务</span></span><br></pre></td></tr></table></figure><h3 id="5-3-Web管理界面">5.3 Web管理界面</h3><p>访问：<a href="http://localhost:631">http://localhost:631</a></p><h2 id="6-定时任务管理">6. 定时任务管理</h2><h3 id="6-1-cron-定时任务系统">6.1 cron 定时任务系统</h3><h4 id="crontab-命令">crontab 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">crontab -e            <span class="comment"># 编辑当前用户的crontab</span></span><br><span class="line">crontab -l            <span class="comment"># 列出当前用户的crontab</span></span><br><span class="line">crontab -r            <span class="comment"># 删除当前用户的crontab</span></span><br><span class="line">crontab -u user -e    <span class="comment"># 编辑指定用户的crontab(root权限)</span></span><br></pre></td></tr></table></figure><h4 id="crontab-文件格式">crontab 文件格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* * * * * command_to_execute</span><br><span class="line">│ │ │ │ │</span><br><span class="line">│ │ │ │ └── 星期几 (0-6, 0=星期日)</span><br><span class="line">│ │ │ └──── 月份 (1-12)</span><br><span class="line">│ │ └────── 日 (1-31)</span><br><span class="line">│ └──────── 小时 (0-23)</span><br><span class="line">└────────── 分钟 (0-59)</span><br></pre></td></tr></table></figure><p>特殊字符：</p><ul><li><code>*</code>：所有有效值</li><li><code>,</code>：值列表分隔符(如1,3,5)</li><li><code>-</code>：范围(如1-5)</li><li><code>/</code>：步长(如*/2表示每2个单位)</li></ul><h4 id="系统cron目录">系统cron目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/crontab           <span class="comment"># 系统级crontab文件</span></span><br><span class="line">/etc/cron.d/           <span class="comment"># 系统cron片段</span></span><br><span class="line">/etc/cron.hourly/      <span class="comment"># 每小时执行</span></span><br><span class="line">/etc/cron.daily/       <span class="comment"># 每天执行</span></span><br><span class="line">/etc/cron.weekly/      <span class="comment"># 每周执行</span></span><br><span class="line">/etc/cron.monthly/     <span class="comment"># 每月执行</span></span><br></pre></td></tr></table></figure><h4 id="anacron">anacron</h4><ul><li>用于在系统停机后执行错过的定时任务</li><li>配置文件：<code>/etc/anacrontab</code></li></ul><h3 id="6-2-at-一次性任务">6.2 at 一次性任务</h3><h4 id="at-命令">at 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at 17:00 tomorrow      <span class="comment"># 创建定时任务</span></span><br><span class="line">at -f job.sh 23:00     <span class="comment"># 从文件读取任务</span></span><br><span class="line">atq                    <span class="comment"># 查看待执行任务(at -l)</span></span><br><span class="line">atrm 3                 <span class="comment"># 删除任务3(at -d 3)</span></span><br></pre></td></tr></table></figure><h4 id="时间格式">时间格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HH:MM                  # 24小时制(如23:00)</span><br><span class="line">noon/midnight          # 中午12点/午夜12点</span><br><span class="line">today/tomorrow         # 今天/明天</span><br><span class="line">now + count time-units # 如now + 3 days</span><br></pre></td></tr></table></figure><h3 id="6-3-batch-低负荷执行">6.3 batch 低负荷执行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch                  <span class="comment"># 进入交互式输入模式</span></span><br><span class="line">batch -f job.sh        <span class="comment"># 从文件读取任务</span></span><br></pre></td></tr></table></figure><h3 id="6-4-访问控制">6.4 访问控制</h3><h4 id="cron-访问控制">cron 访问控制</h4><ol><li>如存在<code>/etc/cron.allow</code>，仅允许文件内用户</li><li>如无allow文件，检查<code>/etc/cron.deny</code>，拒绝文件内用户</li><li>如两者都不存在，默认行为取决于系统配置</li></ol><h4 id="at-访问控制">at 访问控制</h4><ol><li>如存在<code>/etc/at.allow</code>，仅允许文件内用户</li><li>如无allow文件，检查<code>/etc/at.deny</code>，拒绝文件内用户</li><li>如两者都不存在，默认只有root可用</li></ol><h2 id="7-本地化与国际化">7. 本地化与国际化</h2><h3 id="7-1-本地化变量">7.1 本地化变量</h3><table><thead><tr><th>变量</th><th>作用域</th></tr></thead><tbody><tr><td><code>LC_CTYPE</code></td><td>字符分类和大小写转换</td></tr><tr><td><code>LC_COLLATE</code></td><td>排序和比较规则</td></tr><tr><td><code>LC_MESSAGES</code></td><td>系统消息语言</td></tr><tr><td><code>LC_MONETARY</code></td><td>货币格式</td></tr><tr><td><code>LC_NUMERIC</code></td><td>数字格式</td></tr><tr><td><code>LC_TIME</code></td><td>日期时间格式</td></tr><tr><td><code>LC_ALL</code></td><td>覆盖所有LC_*设置</td></tr><tr><td><code>LANG</code></td><td>默认设置(未被LC_*覆盖时使用)</td></tr></tbody></table><h3 id="7-2-常用locale设置">7.2 常用locale设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C/POSIX               <span class="comment"># 最小locale</span></span><br><span class="line">en_US.utf8            <span class="comment"># 英文(美国)</span></span><br><span class="line">ja_JP.utf8            <span class="comment"># 日文(UTF-8)</span></span><br><span class="line">ja_JP.eucJP           <span class="comment"># 日文(EUC-JP)</span></span><br><span class="line">zh_CN.utf8            <span class="comment"># 中文(简体)</span></span><br></pre></td></tr></table></figure><h3 id="7-3-locale-命令">7.3 locale 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">locale -a             <span class="comment"># 列出可用locale</span></span><br><span class="line">locale -m             <span class="comment"># 列出可用字符编码</span></span><br><span class="line">locale                <span class="comment"># 显示当前locale设置</span></span><br></pre></td></tr></table></figure><h3 id="7-4-字符编码">7.4 字符编码</h3><table><thead><tr><th>编码</th><th>描述</th></tr></thead><tbody><tr><td>ASCII</td><td>7位英文字符</td></tr><tr><td>ISO-8859</td><td>8位扩展ASCII</td></tr><tr><td>UTF-8</td><td>Unicode编码</td></tr><tr><td>EUC-JP</td><td>Linux日文编码</td></tr><tr><td>Shift_JIS</td><td>Windows/Mac日文编码</td></tr><tr><td>ISO-2022-JP</td><td>邮件用日文编码</td></tr></tbody></table><h3 id="7-5-iconv-编码转换">7.5 iconv 编码转换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iconv -f eucjp -t utf8 input.txt &gt; output.txt  <span class="comment"># EUC-JP转UTF-8</span></span><br><span class="line">iconv -l                                      <span class="comment"># 列出支持编码</span></span><br></pre></td></tr></table></figure><h2 id="8-时区设置">8. 时区设置</h2><h3 id="8-1-时区文件">8.1 时区文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/zoneinfo/   <span class="comment"># 所有时区定义文件</span></span><br><span class="line">/etc/localtime         <span class="comment"># 系统当前时区链接</span></span><br></pre></td></tr></table></figure><h3 id="8-2-设置时区方法">8.2 设置时区方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1: 复制时区文件</span></span><br><span class="line"><span class="built_in">cp</span> /usr/share/zoneinfo/Asia/Tokyo /etc/localtime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2: 创建符号链接</span></span><br><span class="line"><span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Tokyo /etc/localtime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法3: 临时设置(当前会话有效)</span></span><br><span class="line"><span class="built_in">export</span> TZ=<span class="string">&quot;Asia/Tokyo&quot;</span></span><br></pre></td></tr></table></figure><h3 id="8-3-时区配置工具">8.3 时区配置工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tzselect   <span class="comment"># 交互式时区选择</span></span><br><span class="line">tzconfig   <span class="comment"># 时区配置工具(部分发行版)</span></span><br><span class="line">dpkg-reconfigure tzdata  <span class="comment"># Debian系重新配置时区</span></span><br><span class="line">timedatectl set-timezone Asia/Tokyo  <span class="comment"># systemd系统设置时区</span></span><br></pre></td></tr></table></figure><h2 id="9-打印系统补充">9. 打印系统补充</h2><h3 id="9-1-CUPS-Web管理界面">9.1 CUPS Web管理界面</h3><p>访问：<code>http://localhost:631</code></p><h3 id="9-2-打印命令补充">9.2 打印命令补充</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpstat -p -d          <span class="comment"># 显示打印机状态和默认打印机</span></span><br><span class="line">lpoptions -d LaserJet <span class="comment"># 设置默认打印机</span></span><br></pre></td></tr></table></figure><h3 id="9-3-打印系统日志">9.3 打印系统日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/log/cups/        <span class="comment"># CUPS日志目录</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.XWindow</title>
      <link href="/2020/05/08/linux/7-XWindow/"/>
      <url>/2020/05/08/linux/7-XWindow/</url>
      
        <content type="html"><![CDATA[<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># X Window 系统架构详解</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 基础架构</span></span><br></pre></td></tr></table></figure><p>localhost(X server) --X protocol-- remotehost(X client)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 核心组件说明</span><br><span class="line">1. **X Server**：</span><br><span class="line">   - 负责硬件管理（显卡、显示器、输入设备等）</span><br><span class="line">   - 屏幕绘制与渲染</span><br><span class="line">   - 提供字体服务功能</span><br><span class="line">   - 典型实现：Xorg</span><br><span class="line"></span><br><span class="line">2. **X Client**：</span><br><span class="line">   - 应用程序逻辑处理</span><br><span class="line">   - 响应X Server的事件请求</span><br><span class="line">   - 例如：xterm、Firefox等GUI程序</span><br><span class="line"></span><br><span class="line">3. **X Window Manager**：</span><br><span class="line">   - 特殊的X Client</span><br><span class="line">   - 负责管理窗口布局、装饰和交互</span><br><span class="line">   - 常见WM：twm、KWin、Metacity等</span><br><span class="line"></span><br><span class="line">4. **Display Manager**：</span><br><span class="line">   - 提供图形化登录界面</span><br><span class="line">   - 负责加载用户选择的WM和语言环境</span><br><span class="line">   - 常见实现：GDM、KDM、XDM</span><br><span class="line"></span><br><span class="line">## startx 启动流程</span><br><span class="line"></span><br><span class="line">### 命令语法</span><br><span class="line">```bash</span><br><span class="line">startx [X client 参数] -- [X server 参数]</span><br></pre></td></tr></table></figure><h3 id="X-server-参数查找顺序">X server 参数查找顺序</h3><ol><li>startx 命令行参数</li><li>用户主目录 <code>~/.xserverrc</code></li><li>系统默认 <code>/etc/X11/xinit/xserverrc</code></li><li>最终回退 <code>/usr/bin/X</code> (X server可执行文件)</li></ol><h3 id="X-client-参数查找顺序">X client 参数查找顺序</h3><ol><li>startx 命令行参数</li><li>用户主目录 <code>~/.xinitrc</code></li><li>系统默认 <code>/etc/X11/xinit/xinitrc</code></li><li>最终回退 <code>xterm</code> (基础终端模拟器)</li></ol><h3 id="底层调用">底层调用</h3><p>startx 最终调用 <code>xinit</code> 启动X系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xinit [client option] -- [server or display option]</span><br></pre></td></tr></table></figure><p>默认等效命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xinit /etc/X11/xinit/xinitrc -- /usr/bin/X</span><br></pre></td></tr></table></figure><p>最小化启动示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xinit xterm -geometry +1+1 -n login -display :0 -- X :0</span><br></pre></td></tr></table></figure><h2 id="配置文件体系">配置文件体系</h2><h3 id="核心配置文件">核心配置文件</h3><ul><li>主配置文件：<code>/etc/X11/xorg.conf</code></li><li>模块目录：<code>/usr/lib64/xorg/modules/</code></li><li>字体目录：<code>/usr/share/X11/fonts/</code></li><li>显卡驱动：<code>/usr/lib64/xorg/modules/drivers/</code></li></ul><h3 id="配置段落-Section">配置段落(Section)</h3><table><thead><tr><th>Section名称</th><th>功能描述</th></tr></thead><tbody><tr><td>Module</td><td>X Server加载的功能模块</td></tr><tr><td>InputDevice</td><td>输入设备配置（键盘/鼠标）</td></tr><tr><td>Files</td><td>字体和颜色资源路径</td></tr><tr><td>Monitor</td><td>显示器参数（刷新率等）</td></tr><tr><td>Device</td><td>显卡芯片组配置</td></tr><tr><td>Screen</td><td>显示分辨率和色深设置</td></tr><tr><td>ServerLayout</td><td>各模块的组合配置</td></tr></tbody></table><h3 id="配置生成工具">配置生成工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Xorg -configure</span><br><span class="line"><span class="comment"># 生成测试配置文件：/root/xorg.conf.new</span></span><br><span class="line"><span class="comment"># 测试命令：X -config /root/xorg.conf.new</span></span><br></pre></td></tr></table></figure><h2 id="实用命令工具">实用命令工具</h2><h3 id="显示调节">显示调节</h3><ul><li><code>xvidtune</code>：GUI显示器频率调节工具</li><li><code>xhost</code>：X server访问控制<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xhost +hostname  <span class="comment"># 添加访问权限</span></span><br><span class="line">xhost -hostname  <span class="comment"># 移除访问权限</span></span><br><span class="line">xhost +          <span class="comment"># 允许所有主机</span></span><br><span class="line">xhost -          <span class="comment"># 禁用所有远程访问</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="环境变量">环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DISPLAY=localhost:0  <span class="comment"># 指定显示目标</span></span><br><span class="line"><span class="built_in">export</span> DISPLAY</span><br></pre></td></tr></table></figure><h3 id="信息查询">信息查询</h3><table><thead><tr><th>命令</th><th>功能描述</th></tr></thead><tbody><tr><td>showrgb</td><td>显示可用RGB颜色值</td></tr><tr><td>xlsclients</td><td>列出运行中的X客户端</td></tr><tr><td>xwininfo</td><td>查询窗口几何属性</td></tr><tr><td>xdpyinfo</td><td>显示X Server详细信息</td></tr></tbody></table><h2 id="显示管理器-XDM">显示管理器(XDM)</h2><h3 id="类型对比">类型对比</h3><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>XDM</td><td>基础X Display Manager</td></tr><tr><td>GDM</td><td>GNOME显示管理器</td></tr><tr><td>KDM</td><td>KDE显示管理器</td></tr></tbody></table><h3 id="XDM启动流程">XDM启动流程</h3><ol><li>启动XDM服务</li><li>加载 <code>/etc/X11/Xsession</code></li><li>执行 <code>/etc/X11/xinit/xinitrc.d/</code> 下脚本</li><li>读取用户配置 <code>~/.xsession</code></li><li>加载 <code>~/.Xclients</code> 或 <code>/etc/X11/xinit/Xclients</code></li></ol><h3 id="关键配置文件">关键配置文件</h3><table><thead><tr><th>文件名</th><th>用途描述</th></tr></thead><tbody><tr><td>xdm-config</td><td>基础配置和访问控制</td></tr><tr><td>Xaccess</td><td>主机访问权限设置</td></tr><tr><td>Xresources</td><td>登录界面样式和X资源定义</td></tr><tr><td>Xservers</td><td>X Server与Display映射</td></tr><tr><td>Xsetup_0</td><td>登录前环境设置（如壁纸）</td></tr><tr><td>Xsession</td><td>会话启动流程控制</td></tr></tbody></table><h2 id="窗口管理器列表">窗口管理器列表</h2><table><thead><tr><th>名称</th><th>特点描述</th></tr></thead><tbody><tr><td>twm</td><td>最基本的窗口管理器</td></tr><tr><td>fvwm</td><td>轻量级窗口管理器</td></tr><tr><td>sawfish</td><td>GNOME集成WM</td></tr><tr><td>enlightenment</td><td>高定制化WM</td></tr><tr><td>metacity</td><td>GNOME默认WM</td></tr><tr><td>fluxbox</td><td>轻量级高自由度WM</td></tr><tr><td>WindowMaker</td><td>NeXTSTEP风格WM</td></tr><tr><td>KWin</td><td>KDE标准窗口管理器</td></tr></tbody></table><h2 id="辅助功能技术">辅助功能技术</h2><h3 id="AccessX-功能">AccessX 功能</h3><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>粘滞键</td><td>分离组合键输入</td></tr><tr><td>慢速键</td><td>调整按键响应时间</td></tr><tr><td>防反弹键</td><td>防止重复输入</td></tr><tr><td>切换键</td><td>切换状态声音反馈</td></tr><tr><td>鼠标键</td><td>键盘模拟鼠标操作</td></tr></tbody></table><h3 id="其他辅助工具">其他辅助工具</h3><ul><li><strong>高对比度显示</strong>：增强视觉可读性</li><li><strong>屏幕阅读器</strong>：Orca等文本转语音工具</li><li><strong>盲文显示器</strong>：触觉输出设备</li><li><strong>屏幕放大镜</strong>：视觉辅助工具</li><li><strong>屏幕键盘</strong>：GOK等虚拟输入工具</li></ul><h3 id="专用软件">专用软件</h3><ul><li><strong>Orca</strong>：GNOME屏幕阅读器和放大镜</li><li><strong>GOK</strong>：GNOME屏幕键盘</li><li><strong>emacspeak</strong>：为Emacs添加语音功能</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.Shell变量与Shell脚本</title>
      <link href="/2020/05/08/linux/6-Shell%E5%8F%98%E9%87%8F%E4%B8%8EShell%E8%84%9A%E6%9C%AC/"/>
      <url>/2020/05/08/linux/6-Shell%E5%8F%98%E9%87%8F%E4%B8%8EShell%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1>Shell变量与Shell脚本</h1><h2 id="Bash设定文档">Bash设定文档</h2><ul><li><strong>/etc/profile</strong>: 登录时执行，适用于所有用户</li><li><strong>~/.bash_profile</strong>: 登录时执行</li><li><strong>~/.bash_login</strong>: 当 <code>~/.bash_profile</code> 不存在时，登录时执行</li><li><strong>~/.profile</strong>: 当 <code>~/.bash_profile</code> 和 <code>~/.bash_login</code> 都不存在时，登录时执行</li><li><strong>~/.bashrc</strong>: 每次启动 Bash 时执行</li><li><strong>~/.bash_logout</strong>: 登出时执行</li></ul><h2 id="Shell环境定制化">Shell环境定制化</h2><h3 id="export命令"><code>export</code>命令</h3><p>用于将shell变量转化为环境变量，使得该变量能够被其他程序或子进程访问。</p><h3 id="set命令"><code>set</code>命令</h3><ul><li><p><code>set</code>: 显示打印当前的环境变量和Shell变量</p></li><li><p><code>set [-o] [+o] option</code>：</p><ul><li><code>-o</code>：启用该选项</li><li><code>+o</code>：禁用该选项</li><li>常用选项：<ul><li><code>allexport</code>: 自动将变量导出为环境变量</li><li><code>emacs</code>: 设置Emacs风格的键绑定</li><li><code>ignoreeof</code>: 禁止通过 Ctrl+D 退出Shell</li><li><code>noclobber</code>: 禁止文件重定向覆盖文件</li><li><code>noglob</code>: 禁用元字符解析</li><li><code>vi</code>: 设置vi风格的键绑定</li></ul></li></ul></li><li><p><code>set -o</code>: 显示或更改选项的状态</p></li></ul><h3 id="printenv命令"><code>printenv</code>命令</h3><p>用于打印当前的环境变量。</p><h3 id="alias-unalias"><code>alias</code>/<code>unalias</code></h3><ul><li><code>alias</code>: 设置命令别名</li><li><code>unalias</code>: 取消命令别名</li><li>临时解除别名：可以使用反斜杠 <code>\</code>，例如：<code>alias ls='ls -l'</code> 后，<code>'\ls'</code> 会执行原始的 <code>ls</code> 命令。</li></ul><h2 id="定义Shell函数">定义Shell函数</h2><ul><li><p>定义函数语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> [函数名] () &#123;</span><br><span class="line">    运行内容;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>&#123;</code> 和 <code>&#125;</code> 前后需要有空格。</p></li><li><p>定义变量：<code>$变量名</code></p></li><li><p>函数名不能与变量名重名。</p></li><li><p>查看已定义的函数：<code>declare -f</code></p></li><li><p>删除函数：<code>unset</code></p></li></ul><h2 id="Shell脚本">Shell脚本</h2><h3 id="执行Shell脚本">执行Shell脚本</h3><ul><li>脚本命令可以分行书写，并逐行执行。</li><li>运行脚本时，如果没有执行权限，只需要文件的读取权限和文件夹的运行权限即可。<ul><li>使用 <code>source [脚本名]</code> 或简化版 <code>.[脚本名]</code> 执行脚本。</li><li>如果脚本有执行权限，可以省略 <code>source</code>，例如：<code>./[脚本名]</code>。</li><li>如果脚本不在 <code>PATH</code> 环境变量指定的文件夹中，需要显式指定脚本路径，或者在当前目录使用 <code>./</code>。</li></ul></li></ul><h3 id="传入Shell脚本的变量">传入Shell脚本的变量</h3><ul><li><code>$0</code>：脚本文件名（全路径）</li><li><code>$1</code>：第一个传入的变量值</li><li><code>$2</code>：第二个传入的变量值</li><li><code>#$</code>：传入的变量数量</li><li><code>$@</code>：所有传入的变量值（空格分隔）</li><li><code>$*</code>：所有变量值（以系统默认的分隔符分隔）</li><li>脚本执行结束后的返回状态：<code>echo $?</code>。正常执行返回0，错误返回1。</li></ul><h3 id="文件检查">文件检查</h3><p>使用 <code>test</code> 命令或者 <code>[</code> <code>]</code> 语法进行文件检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> 条件文</span><br><span class="line">[ 条件文 ]</span><br></pre></td></tr></table></figure><h4 id="常见条件文：">常见条件文：</h4><ul><li><code>-f 文件名</code>：检查文件是否存在且为普通文件</li><li><code>-d 文件夹名</code>：检查文件夹是否存在</li><li><code>-r 文件名</code>：检查文件是否有读取权限</li><li><code>-w 文件名</code>：检查文件是否有写入权限</li><li><code>-x 文件名</code>：检查文件是否有执行权限</li><li><code>-s 文件名</code>：检查文件是否为空</li><li><code>-L 文件名</code>：检查是否为软链接</li><li><code>-e 文件名</code>：检查文件是否存在</li><li><code>文件名1 -nt 文件名2</code>：文件1是否比文件2新</li><li><code>文件名1 -ot 文件名2</code>：文件1是否比文件2旧</li><li>数值比较：<code>-eq</code>, <code>-ge</code>, <code>-gt</code>, <code>-le</code>, <code>-lt</code>, <code>-ne</code>（等于、大于等于、大于、小于等于、小于、不等于）</li><li>字符串比较：<code>-n</code>（字符串长度大于0），<code>-z</code>（字符串长度为0）</li><li>字符串相等：<code>字符串1 = 字符串2</code></li><li>字符串不等：<code>字符串1 != 字符串2</code></li><li>逻辑操作：<ul><li><code>!</code>：条件非</li><li><code>-a</code>：与（and）</li><li><code>-o</code>：或（or）</li></ul></li></ul><h2 id="条件分歧">条件分歧</h2><h3 id="if语句"><code>if</code>语句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件式</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    执行文1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    执行文2</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件式; <span class="keyword">then</span></span><br><span class="line">    执行文1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    执行文2</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="case语句"><code>case</code>语句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> 式 <span class="keyword">in</span></span><br><span class="line">    值1)</span><br><span class="line">        执行文1 ;;</span><br><span class="line">    值2)</span><br><span class="line">        执行文2 ;;</span><br><span class="line">    *)</span><br><span class="line">        执行其他文 ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>注意：每个 <code>执行文</code> 后面要有 <code>;;</code>，并且最后使用 <code>esac</code> 结束。</p><h3 id="for循环"><code>for</code>循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量名 <span class="keyword">in</span> 变量值列表</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    执行文</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> Vine SUSE Gentoo</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$var</span> Linux</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>变量值列表可以通过空格分隔，也可以使用 <code>seq</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `<span class="built_in">seq</span> 10 15`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="while循环"><code>while</code>循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件文</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    执行文</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="read命令"><code>read</code>命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&#x27;Who are you?:&#x27;</span></span><br><span class="line"><span class="built_in">read</span> username</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$username</span>!&quot;</span></span><br></pre></td></tr></table></figure><ul><li>如果 <code>echo</code> 后面跟 <code>-n</code>，则输入的提示信息和用户输入将在同一行显示。</li></ul><h2 id="指定执行Shell类型">指定执行Shell类型</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure><p>此行用于指定脚本执行时使用的Shell解释器。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.文件系统与存储管理</title>
      <link href="/2020/05/08/linux/5-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/05/08/linux/5-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-磁盘配额管理">1. 磁盘配额管理</h2><h3 id="1-1-配额概念与类型">1.1 配额概念与类型</h3><h4 id="配额类型说明">配额类型说明</h4><ul><li><strong>硬限制(Hard Limit)</strong>：用户绝对不能超过的磁盘空间限制</li><li><strong>软限制(Soft Limit)</strong>：允许用户暂时超过的限制，系统会发出警告</li><li><strong>宽限期(Grace Period)</strong>：超过软限制后允许保留的时间（默认7天）</li></ul><h3 id="1-2-配额实施完整步骤">1.2 配额实施完整步骤</h3><ol><li><p><strong>修改fstab文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在/etc/fstab中添加usrquota和/或grpquota选项</span></span><br><span class="line">/dev/sda1 /home ext4 defaults,usrquota,grpquota 0 2</span><br></pre></td></tr></table></figure></li><li><p><strong>重新挂载文件系统</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umount /home</span><br><span class="line">mount -o remount /home</span><br></pre></td></tr></table></figure></li><li><p><strong>创建配额文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> /home/aquota.user /home/aquota.group</span><br><span class="line"><span class="built_in">chmod</span> 600 /home/aquota.*</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化配额数据库</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quotacheck -cugm /home</span><br></pre></td></tr></table></figure></li><li><p><strong>启用配额系统</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quotaon -avug</span><br></pre></td></tr></table></figure></li><li><p><strong>为用户设置配额</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edquota username</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-3-配额管理命令详解">1.3 配额管理命令详解</h3><h4 id="quota-显示配额信息">quota - 显示配额信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quota -u username  <span class="comment"># 显示用户配额</span></span><br><span class="line">quota -g groupname <span class="comment"># 显示组配额</span></span><br><span class="line">quota -v           <span class="comment"># 显示详细信息</span></span><br></pre></td></tr></table></figure><h4 id="quotacheck-检查配额">quotacheck - 检查配额</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quotacheck -avug  <span class="comment"># 检查所有文件系统配额</span></span><br><span class="line">quotacheck -cug /home  <span class="comment"># 检查指定文件系统</span></span><br></pre></td></tr></table></figure><h4 id="quotaon-quotaoff-启用-禁用配额">quotaon/quotaoff - 启用/禁用配额</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quotaon -avug     <span class="comment"># 启用所有配额</span></span><br><span class="line">quotaoff /home    <span class="comment"># 禁用指定文件系统配额</span></span><br></pre></td></tr></table></figure><h4 id="edquota-编辑配额">edquota - 编辑配额</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">edquota -u username  <span class="comment"># 编辑用户配额</span></span><br><span class="line">edquota -p template_user new_user  <span class="comment"># 复制配额设置</span></span><br><span class="line">edquota -t           <span class="comment"># 修改宽限期</span></span><br></pre></td></tr></table></figure><h4 id="repquota-报告配额状态">repquota - 报告配额状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repquota -a       <span class="comment"># 报告所有文件系统配额状态</span></span><br><span class="line">repquota -u /home <span class="comment"># 报告/home的用户配额</span></span><br></pre></td></tr></table></figure><h2 id="2-文件系统层次标准-FHS">2. 文件系统层次标准(FHS)</h2><h3 id="2-1-核心目录结构">2.1 核心目录结构</h3><table><thead><tr><th>目录</th><th>完整描述</th><th>典型内容</th></tr></thead><tbody><tr><td><code>/bin</code></td><td>基础命令二进制文件</td><td>ls, cp, mv等基本命令</td></tr><tr><td><code>/sbin</code></td><td>系统管理二进制文件</td><td>fdisk, fsck, ifconfig等</td></tr><tr><td><code>/etc</code></td><td>系统配置文件</td><td>passwd, fstab, network等配置文件</td></tr><tr><td><code>/dev</code></td><td>设备文件</td><td>sda, tty, null等设备节点</td></tr><tr><td><code>/lib</code></td><td>系统库文件</td><td>系统运行所需共享库</td></tr><tr><td><code>/mnt</code></td><td>临时挂载点</td><td>临时挂载文件系统的目录</td></tr><tr><td><code>/opt</code></td><td>可选应用软件包</td><td>第三方应用程序</td></tr><tr><td><code>/proc</code></td><td>进程和内核信息</td><td>虚拟文件系统，提供系统信息</td></tr><tr><td><code>/root</code></td><td>root用户主目录</td><td>root用户的个人文件和配置</td></tr><tr><td><code>/boot</code></td><td>启动加载文件</td><td>vmlinuz, initramfs, grub等</td></tr><tr><td><code>/home</code></td><td>用户主目录</td><td>普通用户的个人目录</td></tr><tr><td><code>/tmp</code></td><td>临时文件</td><td>系统重启后通常清空</td></tr><tr><td><code>/var</code></td><td>可变数据文件</td><td>日志、邮件、数据库等</td></tr><tr><td><code>/usr</code></td><td>用户程序资源</td><td>应用程序、文档、库文件等</td></tr></tbody></table><h2 id="3-分区与文件系统管理">3. 分区与文件系统管理</h2><h3 id="3-1-分区管理">3.1 分区管理</h3><h4 id="fdisk-完整操作流程">fdisk 完整操作流程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure><p>交互命令列表：</p><ul><li><code>n</code>：创建新分区</li><li><code>d</code>：删除分区</li><li><code>p</code>：显示分区表</li><li><code>t</code>：更改分区类型</li><li><code>a</code>：切换启动标志</li><li><code>w</code>：写入并退出</li><li><code>q</code>：不保存退出</li><li><code>m</code>：显示帮助菜单</li></ul><h3 id="3-2-文件系统创建与管理">3.2 文件系统创建与管理</h3><h4 id="mkfs-命令集">mkfs 命令集</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t ext4 /dev/sdb1      <span class="comment"># 创建ext4文件系统</span></span><br><span class="line">mkfs.ext4 /dev/sdb1         <span class="comment"># 同上</span></span><br><span class="line">mkfs.xfs /dev/sdb2          <span class="comment"># 创建XFS文件系统</span></span><br><span class="line">mkfs.btrfs /dev/sdb3        <span class="comment"># 创建Btrfs文件系统</span></span><br></pre></td></tr></table></figure><h4 id="交换空间管理">交换空间管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkswap /dev/sdb4            <span class="comment"># 创建交换分区</span></span><br><span class="line">swapon /dev/sdb4            <span class="comment"># 启用交换分区</span></span><br><span class="line">swapon -s                   <span class="comment"># 显示交换空间状态</span></span><br><span class="line">swapoff /dev/sdb4           <span class="comment"># 禁用交换分区</span></span><br></pre></td></tr></table></figure><h3 id="3-3-文件系统检查与维护">3.3 文件系统检查与维护</h3><h4 id="fsck-系列命令">fsck 系列命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fsck /dev/sdb1              <span class="comment"># 基本文件系统检查</span></span><br><span class="line">fsck -y /dev/sdb1           <span class="comment"># 自动修复错误</span></span><br><span class="line">e2fsck -p /dev/sdb1         <span class="comment"># ext文件系统自动修复</span></span><br><span class="line">xfs_repair /dev/sdb2        <span class="comment"># XFS文件系统修复</span></span><br></pre></td></tr></table></figure><h4 id="tune2fs-调整参数">tune2fs 调整参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tune2fs -c 30 /dev/sdb1     <span class="comment"># 设置每30次挂载后检查</span></span><br><span class="line">tune2fs -i 15d /dev/sdb1    <span class="comment"># 设置15天间隔检查</span></span><br><span class="line">tune2fs -L DATA /dev/sdb1   <span class="comment"># 设置卷标为DATA</span></span><br></pre></td></tr></table></figure><h3 id="3-4-空间监控命令">3.4 空间监控命令</h3><h4 id="df-详细用法">df 详细用法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h                       <span class="comment"># 人类可读格式</span></span><br><span class="line"><span class="built_in">df</span> -i                       <span class="comment"># 显示inode使用情况</span></span><br><span class="line"><span class="built_in">df</span> -T                       <span class="comment"># 显示文件系统类型</span></span><br><span class="line"><span class="built_in">df</span> --total                  <span class="comment"># 显示总计信息</span></span><br></pre></td></tr></table></figure><h4 id="du-详细用法">du 详细用法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh /var/log             <span class="comment"># 显示目录总大小</span></span><br><span class="line"><span class="built_in">du</span> -ah /home                <span class="comment"># 显示所有文件和目录大小</span></span><br><span class="line"><span class="built_in">du</span> -csh *                   <span class="comment"># 显示当前目录各项目大小和总计</span></span><br><span class="line"><span class="built_in">du</span> --max-depth=1 /usr       <span class="comment"># 只显示一级子目录大小</span></span><br></pre></td></tr></table></figure><h2 id="4-文件搜索命令">4. 文件搜索命令</h2><h3 id="4-1-find-命令完整用法">4.1 find 命令完整用法</h3><h4 id="基本语法">基本语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [路径] [选项] [操作]</span><br></pre></td></tr></table></figure><h4 id="常用示例">常用示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find / -name <span class="string">&quot;*.conf&quot;</span>               <span class="comment"># 按名称查找</span></span><br><span class="line">find /home -user alice              <span class="comment"># 按属主查找</span></span><br><span class="line">find /var/log -mtime -7             <span class="comment"># 查找7天内修改的文件</span></span><br><span class="line">find /tmp -size +10M                <span class="comment"># 查找大于10MB的文件</span></span><br><span class="line">find . -perm 644                    <span class="comment"># 查找权限为644的文件</span></span><br><span class="line">find /etc -<span class="built_in">type</span> f -<span class="built_in">exec</span> grep -l <span class="string">&quot;error&quot;</span> &#123;&#125; \;  <span class="comment"># 结合grep</span></span><br></pre></td></tr></table></figure><h3 id="4-2-locate-updatedb-系统">4.2 locate/updatedb 系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">locate passwd              <span class="comment"># 快速查找文件</span></span><br><span class="line">updatedb                   <span class="comment"># 更新数据库</span></span><br><span class="line">updatedb -e /mnt           <span class="comment"># 排除/mnt目录</span></span><br></pre></td></tr></table></figure><h3 id="4-3-which-whereis-type">4.3 which/whereis/type</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> <span class="built_in">ls</span>                   <span class="comment"># 查找命令路径</span></span><br><span class="line">whereis python             <span class="comment"># 查找命令相关文件</span></span><br><span class="line"><span class="built_in">type</span> -a <span class="built_in">cd</span>                 <span class="comment"># 显示命令类型</span></span><br></pre></td></tr></table></figure><h2 id="5-挂载管理">5. 挂载管理</h2><h3 id="5-1-挂载选项详解">5.1 挂载选项详解</h3><table><thead><tr><th>选项</th><th>完整描述</th></tr></thead><tbody><tr><td><code>async/sync</code></td><td>异步/同步写入</td></tr><tr><td><code>auto/noauto</code></td><td>是否允许mount -a自动挂载</td></tr><tr><td><code>exec/noexec</code></td><td>是否允许执行二进制文件</td></tr><tr><td><code>ro/rw</code></td><td>只读/读写模式</td></tr><tr><td><code>suid/nosuid</code></td><td>是否允许SUID/SGID</td></tr><tr><td><code>user/nouser</code></td><td>是否允许普通用户挂载</td></tr><tr><td><code>defaults</code></td><td>默认选项(rw,suid,dev,exec,auto,nouser,async)</td></tr></tbody></table><h3 id="5-2-mount-umount-完整用法">5.2 mount/umount 完整用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdb1 /mnt/data           <span class="comment"># 基本挂载</span></span><br><span class="line">mount -o remount,ro /mnt/data       <span class="comment"># 重新挂载为只读</span></span><br><span class="line">mount -t nfs server:/share /mnt/nfs <span class="comment"># 挂载NFS</span></span><br><span class="line">umount /mnt/data                    <span class="comment"># 卸载</span></span><br><span class="line">umount -l /mnt/data                 <span class="comment"># 延迟卸载</span></span><br></pre></td></tr></table></figure><h3 id="5-3-etc-fstab-文件格式">5.3 /etc/fstab 文件格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 设备文件/挂载点/文件系统类型/选项/备份标记/检查顺序</span><br><span class="line">/dev/sdb1  /data  ext4  defaults  0  2</span><br><span class="line">UUID=xxxx  /home  xfs   defaults  0  1</span><br></pre></td></tr></table></figure><h2 id="6-逻辑卷管理-LVM">6. 逻辑卷管理(LVM)</h2><h3 id="6-1-LVM-基本概念">6.1 LVM 基本概念</h3><ol><li><strong>PV(Physical Volume)</strong>：物理卷，实际存储设备</li><li><strong>VG(Volume Group)</strong>：卷组，由PV组成的存储池</li><li><strong>LV(Logical Volume)</strong>：逻辑卷，从VG划分的可挂载空间</li><li><strong>PE(Physical Extent)</strong>：物理块，LVM最小分配单元(默认4MB)</li><li><strong>LE(Logical Extent)</strong>：逻辑块，与PE一一对应</li></ol><h3 id="6-2-LVM-完整操作流程">6.2 LVM 完整操作流程</h3><h4 id="物理卷-PV-管理">物理卷(PV)管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pvcreate /dev/sdb /dev/sdc          <span class="comment"># 创建PV</span></span><br><span class="line">pvdisplay                           <span class="comment"># 显示PV信息</span></span><br><span class="line">pvmove /dev/sdb                     <span class="comment"># 迁移PV数据</span></span><br><span class="line">pvremove /dev/sdb                   <span class="comment"># 删除PV</span></span><br></pre></td></tr></table></figure><h4 id="卷组-VG-管理">卷组(VG)管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vgcreate vg_data /dev/sdb /dev/sdc  <span class="comment"># 创建VG</span></span><br><span class="line">vgextend vg_data /dev/sdd           <span class="comment"># 扩展VG</span></span><br><span class="line">vgreduce vg_data /dev/sdb           <span class="comment"># 缩减VG</span></span><br><span class="line">vgdisplay                           <span class="comment"># 显示VG信息</span></span><br><span class="line">vgremove vg_data                    <span class="comment"># 删除VG</span></span><br></pre></td></tr></table></figure><h4 id="逻辑卷-LV-管理">逻辑卷(LV)管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lvcreate -L 50G -n lv_home vg_data  <span class="comment"># 创建50G逻辑卷</span></span><br><span class="line">lvextend -L +10G /dev/vg_data/lv_home <span class="comment"># 扩展10G</span></span><br><span class="line">lvreduce -L -5G /dev/vg_data/lv_home <span class="comment"># 缩减5G</span></span><br><span class="line">lvresize -L 60G /dev/vg_data/lv_home <span class="comment"># 调整到60G</span></span><br><span class="line">lvdisplay                           <span class="comment"># 显示LV信息</span></span><br><span class="line">lvremove /dev/vg_data/lv_home       <span class="comment"># 删除LV</span></span><br></pre></td></tr></table></figure><h4 id="文件系统扩展">文件系统扩展</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于ext2/3/4文件系统</span></span><br><span class="line">resize2fs /dev/vg_data/lv_home</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于XFS文件系统</span></span><br><span class="line">xfs_growfs /dev/vg_data/lv_home</span><br></pre></td></tr></table></figure><h3 id="6-3-LVM-快照功能">6.3 LVM 快照功能</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lvcreate -L 10G -s -n snap_home /dev/vg_data/lv_home  <span class="comment"># 创建快照</span></span><br><span class="line">mount /dev/vg_data/snap_home /mnt/snapshot           <span class="comment"># 挂载快照</span></span><br><span class="line">umount /mnt/snapshot                                 <span class="comment"># 卸载快照</span></span><br><span class="line">lvremove /dev/vg_data/snap_home                      <span class="comment"># 删除快照</span></span><br></pre></td></tr></table></figure><h3 id="6-4-LVM-信息查看命令">6.4 LVM 信息查看命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pvs        <span class="comment"># 简要PV信息</span></span><br><span class="line">vgs        <span class="comment"># 简要VG信息</span></span><br><span class="line">lvs        <span class="comment"># 简要LV信息</span></span><br><span class="line">pvdisplay  <span class="comment"># 详细PV信息</span></span><br><span class="line">vgdisplay  <span class="comment"># 详细VG信息</span></span><br><span class="line">lvdisplay  <span class="comment"># 详细LV信息</span></span><br><span class="line">lsblk      <span class="comment"># 块设备层次结构</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.文件和程序管理</title>
      <link href="/2020/05/08/linux/4-%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"/>
      <url>/2020/05/08/linux/4-%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-用户权限管理">1. 用户权限管理</h2><h3 id="1-1-文件权限基础">1.1 文件权限基础</h3><h4 id="权限表示法">权限表示法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d rwx r-x r--</span><br><span class="line">↑ ↑   ↑   ↑</span><br><span class="line">│ │   │   └─ 其他用户权限(r--)</span><br><span class="line">│ │   └─── 所属组权限(r-x)</span><br><span class="line">│ └────── 所有者权限(rwx)</span><br><span class="line">└──────── 文件类型(d=目录)</span><br></pre></td></tr></table></figure><h4 id="权限数值">权限数值</h4><ul><li>r(读): 4</li><li>w(写): 2</li><li>x(执行): 1</li></ul><h3 id="1-2-chmod-命令">1.2 chmod 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [选项] 权限 文件</span><br></pre></td></tr></table></figure><h4 id="常用选项">常用选项</h4><ul><li><code>-R</code>: 递归修改目录下所有文件</li></ul><h4 id="权限设置方法">权限设置方法</h4><ol><li><p><strong>符号法</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+x file      <span class="comment"># 给所有者添加执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> g-w file      <span class="comment"># 移除组的写权限</span></span><br><span class="line"><span class="built_in">chmod</span> o=rx file     <span class="comment"># 设置其他用户为读执行</span></span><br><span class="line"><span class="built_in">chmod</span> a+r file      <span class="comment"># 给所有用户添加读权限</span></span><br></pre></td></tr></table></figure></li><li><p><strong>数字法</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 755 file      <span class="comment"># rwxr-xr-x</span></span><br><span class="line"><span class="built_in">chmod</span> 644 file      <span class="comment"># rw-r--r--</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="1-3-特殊权限">1.3 特殊权限</h3><table><thead><tr><th>权限</th><th>数值</th><th>设置方法</th><th>说明</th></tr></thead><tbody><tr><td>SUID</td><td>4000</td><td><code>u+s</code></td><td>执行时以文件所有者权限运行</td></tr><tr><td>SGID</td><td>2000</td><td><code>g+s</code></td><td>执行时以文件所属组权限运行</td></tr><tr><td>Sticky</td><td>1000</td><td><code>o+t</code></td><td>目录中文件只有所有者能删除</td></tr></tbody></table><h3 id="1-4-umask-命令">1.4 umask 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">umask</span>           <span class="comment"># 查看当前umask值</span></span><br><span class="line"><span class="built_in">umask</span> 022       <span class="comment"># 设置新的umask值</span></span><br></pre></td></tr></table></figure><ul><li>文件默认权限: <code>666 - umask</code></li><li>目录默认权限: <code>777 - umask</code></li></ul><h3 id="1-5-ACL-高级权限控制">1.5 ACL 高级权限控制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setfacl -m u:user:rwx file   <span class="comment"># 添加用户ACL</span></span><br><span class="line">setfacl -x u:user file       <span class="comment"># 删除用户ACL</span></span><br><span class="line">getfacl file                 <span class="comment"># 查看ACL权限</span></span><br></pre></td></tr></table></figure><h3 id="1-6-所有权管理">1.6 所有权管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> user:group file        <span class="comment"># 修改所有者和组</span></span><br><span class="line"><span class="built_in">chown</span> -R user:group <span class="built_in">dir</span>      <span class="comment"># 递归修改</span></span><br><span class="line"><span class="built_in">chgrp</span> group file             <span class="comment"># 修改文件所属组</span></span><br></pre></td></tr></table></figure><h2 id="2-链接管理">2. 链接管理</h2><h3 id="2-1-链接类型对比">2.1 链接类型对比</h3><table><thead><tr><th>特性</th><th>硬链接</th><th>软链接</th></tr></thead><tbody><tr><td>inode</td><td>相同</td><td>不同</td></tr><tr><td>跨文件系统</td><td>不支持</td><td>支持</td></tr><tr><td>链接目录</td><td>不允许</td><td>允许</td></tr><tr><td>原文件删除</td><td>仍可访问</td><td>失效</td></tr></tbody></table><h3 id="2-2-ln-命令">2.2 ln 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> <span class="built_in">source</span> <span class="built_in">link</span>        <span class="comment"># 创建硬链接</span></span><br><span class="line"><span class="built_in">ln</span> -s <span class="built_in">source</span> <span class="built_in">link</span>     <span class="comment"># 创建软链接</span></span><br></pre></td></tr></table></figure><h2 id="3-进程管理">3. 进程管理</h2><h3 id="3-1-ps-命令">3.1 ps 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps aux       <span class="comment"># 查看所有进程</span></span><br><span class="line">ps -ef       <span class="comment"># 完整格式显示</span></span><br><span class="line">ps -u user   <span class="comment"># 查看指定用户进程</span></span><br></pre></td></tr></table></figure><h3 id="3-2-top-命令">3.2 top 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top          <span class="comment"># 动态查看进程</span></span><br></pre></td></tr></table></figure><ul><li><code>r</code>: 调整进程优先级</li><li><code>k</code>: 终止进程</li><li><code>q</code>: 退出</li></ul><h3 id="3-3-进程控制">3.3 进程控制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 PID          <span class="comment"># 强制终止进程</span></span><br><span class="line">killall process      <span class="comment"># 终止同名所有进程</span></span><br><span class="line">pkill pattern        <span class="comment"># 按模式终止进程</span></span><br></pre></td></tr></table></figure><h4 id="常用信号">常用信号</h4><table><thead><tr><th>信号</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>HUP</td><td>1</td><td>重新加载配置</td></tr><tr><td>INT</td><td>2</td><td>中断(Ctrl+C)</td></tr><tr><td>KILL</td><td>9</td><td>强制终止</td></tr><tr><td>TERM</td><td>15</td><td>正常终止</td></tr></tbody></table><h3 id="3-4-作业控制">3.4 作业控制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &amp;       <span class="comment"># 后台运行</span></span><br><span class="line"><span class="built_in">fg</span> %1          <span class="comment"># 前台恢复作业1</span></span><br><span class="line"><span class="built_in">bg</span> %2          <span class="comment"># 后台继续作业2</span></span><br><span class="line"><span class="built_in">jobs</span>           <span class="comment"># 查看后台作业</span></span><br></pre></td></tr></table></figure><h3 id="3-5-优先级管理">3.5 优先级管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nice</span> -n 10 <span class="built_in">command</span>   <span class="comment"># 启动低优先级进程</span></span><br><span class="line">renice 15 -p PID     <span class="comment"># 调整运行中进程优先级</span></span><br></pre></td></tr></table></figure><h3 id="3-6-终端复用器">3.6 终端复用器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux                <span class="comment"># 启动新会话</span></span><br></pre></td></tr></table></figure><p>常用快捷键:</p><ul><li><code>Ctrl+b c</code>: 新建窗口</li><li><code>Ctrl+b %</code>: 垂直分割</li><li><code>Ctrl+b &quot;</code>: 水平分割</li><li><code>Ctrl+b d</code>: 分离会话</li></ul><h2 id="4-压缩与归档">4. 压缩与归档</h2><h3 id="4-1-单文件压缩">4.1 单文件压缩</h3><h4 id="gzip">gzip</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gzip file            <span class="comment"># 压缩为file.gz</span></span><br><span class="line">gunzip file.gz       <span class="comment"># 解压</span></span><br><span class="line">gzip -d file.gz      <span class="comment"># 解压(同上)</span></span><br></pre></td></tr></table></figure><h4 id="bzip2">bzip2</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bzip2 file           <span class="comment"># 压缩为file.bz2</span></span><br><span class="line">bunzip2 file.bz2     <span class="comment"># 解压</span></span><br></pre></td></tr></table></figure><h4 id="xz">xz</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xz file              <span class="comment"># 压缩为file.xz</span></span><br><span class="line">unxz file.xz         <span class="comment"># 解压</span></span><br></pre></td></tr></table></figure><h3 id="4-2-归档工具">4.2 归档工具</h3><h4 id="tar-命令">tar 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打包压缩</span></span><br><span class="line">tar czvf archive.tar.gz <span class="built_in">dir</span>/     <span class="comment"># gzip压缩</span></span><br><span class="line">tar cjvf archive.tar.bz2 <span class="built_in">dir</span>/    <span class="comment"># bzip2压缩</span></span><br><span class="line">tar cJvf archive.tar.xz <span class="built_in">dir</span>/     <span class="comment"># xz压缩</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar xzvf archive.tar.gz          <span class="comment"># 解压gzip</span></span><br><span class="line">tar xjvf archive.tar.bz2         <span class="comment"># 解压bzip2</span></span><br><span class="line">tar xJvf archive.tar.xz          <span class="comment"># 解压xz</span></span><br></pre></td></tr></table></figure><h4 id="cpio-命令">cpio 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . | cpio -ov &gt; backup.cpio      <span class="comment"># 创建归档</span></span><br><span class="line">cpio -idv &lt; backup.cpio              <span class="comment"># 解压归档</span></span><br></pre></td></tr></table></figure><h4 id="dd-命令">dd 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sda of=disk.img bs=1M     <span class="comment"># 创建磁盘映像</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=disk.img of=/dev/sdb           <span class="comment"># 恢复磁盘映像</span></span><br></pre></td></tr></table></figure><h2 id="5-实用技巧">5. 实用技巧</h2><h3 id="5-1-nohup-命令">5.1 nohup 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> <span class="built_in">command</span> &amp;      <span class="comment"># 退出终端后继续运行</span></span><br></pre></td></tr></table></figure><h3 id="5-2-watch-命令">5.2 watch 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 5 <span class="string">&#x27;ls -l&#x27;</span>   <span class="comment"># 每5秒执行一次命令</span></span><br></pre></td></tr></table></figure><h3 id="5-3-文件传输">5.3 文件传输</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=file.iso | ssh user@host <span class="string">&quot;dd of=file.iso&quot;</span>  <span class="comment"># 通过SSH传输文件</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.bash</title>
      <link href="/2020/05/07/linux/3-bash/"/>
      <url>/2020/05/07/linux/3-bash/</url>
      
        <content type="html"><![CDATA[<h1>Bash 命令与 Shell 使用指南</h1><h2 id="1-命令组合与控制">1. 命令组合与控制</h2><h3 id="1-1-命令组合方式">1.1 命令组合方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命令1 ; 命令2    <span class="comment"># 无论命令1成功与否，都会执行命令2</span></span><br><span class="line">命令1 &amp;&amp; 命令2   <span class="comment"># 只有命令1成功执行(返回0)才会执行命令2</span></span><br><span class="line">命令1 || 命令2   <span class="comment"># 只有命令1执行失败(非0)才会执行命令2</span></span><br></pre></td></tr></table></figure><h3 id="1-2-引用符号">1.2 引用符号</h3><table><thead><tr><th>符号</th><th>名称</th><th>功能说明</th></tr></thead><tbody><tr><td><code>'</code></td><td>单引号</td><td>内部所有内容视为纯文本，不解释变量和特殊字符</td></tr><tr><td><code>&quot;</code></td><td>双引号</td><td>会解释$、`和\等特殊字符，变量会被展开</td></tr><tr><td><code>`</code></td><td>反引号</td><td>执行内部命令并将结果替换到当前位置(等同于<code>$(命令)</code>语法)</td></tr></tbody></table><h2 id="2-命令历史">2. 命令历史</h2><h3 id="2-1-history-命令">2.1 history 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span>        <span class="comment"># 显示命令历史记录</span></span><br><span class="line">!5            <span class="comment"># 执行历史记录中第5条命令</span></span><br><span class="line">!<span class="built_in">ls</span>           <span class="comment"># 执行最近以ls开头的命令</span></span><br><span class="line">!?config      <span class="comment"># 执行最近包含config的命令</span></span><br></pre></td></tr></table></figure><h3 id="2-2-历史记录管理">2.2 历史记录管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> -c    <span class="comment"># 清除当前shell的历史记录</span></span><br><span class="line"><span class="built_in">history</span> -d 10 <span class="comment"># 删除第10条历史记录</span></span><br></pre></td></tr></table></figure><h3 id="2-3-相关环境变量">2.3 相关环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HISTSIZE=1000       <span class="comment"># 内存中保存的历史记录数量</span></span><br><span class="line">HISTFILESIZE=2000   <span class="comment"># 历史记录文件保存的最大数量</span></span><br><span class="line">HISTFILE=~/.bash_history  <span class="comment"># 历史记录文件路径</span></span><br></pre></td></tr></table></figure><h2 id="3-Shell-类型与快捷键">3. Shell 类型与快捷键</h2><h3 id="3-1-常见Shell类型">3.1 常见Shell类型</h3><ul><li><strong>Bourne Shell(sh)</strong>: 经典Unix shell → 衍生出bash</li><li><strong>Bash(Bourne-Again Shell)</strong>: Linux默认shell</li><li><strong>C Shell(csh)</strong>: 类C语法 → 衍生出tcsh</li><li><strong>Korn Shell(ksh)</strong>: 结合sh和csh优点</li><li><strong>Z Shell(zsh)</strong>: 功能强大的现代shell</li></ul><h3 id="3-2-常用快捷键">3.2 常用快捷键</h3><table><thead><tr><th>快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>Tab</td><td>命令/文件名自动补全</td></tr><tr><td>Ctrl+A</td><td>移动到行首</td></tr><tr><td>Ctrl+E</td><td>移动到行尾</td></tr><tr><td>Ctrl+D</td><td>删除当前字符(相当于Delete)</td></tr><tr><td>Ctrl+H</td><td>删除前一个字符(相当于Backspace)</td></tr><tr><td>Ctrl+L</td><td>清屏(等同于clear命令)</td></tr><tr><td>Ctrl+C</td><td>终止当前命令</td></tr><tr><td>Ctrl+Z</td><td>暂停当前命令(可用fg恢复)</td></tr><tr><td>Ctrl+S</td><td>暂停屏幕输出</td></tr><tr><td>Ctrl+Q</td><td>恢复屏幕输出</td></tr></tbody></table><h2 id="4-变量与环境设置">4. 变量与环境设置</h2><h3 id="4-1-变量操作">4.1 变量操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> VAR=value    <span class="comment"># 设置环境变量(对新shell有效)</span></span><br><span class="line"><span class="built_in">unset</span> VAR           <span class="comment"># 删除变量</span></span><br><span class="line">PATH=<span class="variable">$PATH</span>:/new/path <span class="comment"># 追加PATH路径</span></span><br></pre></td></tr></table></figure><h3 id="4-2-set-命令选项">4.2 set 命令选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -o option      <span class="comment"># 启用选项</span></span><br><span class="line"><span class="built_in">set</span> +o option      <span class="comment"># 禁用选项</span></span><br></pre></td></tr></table></figure><p>常用选项：</p><ul><li><code>noclobber</code>/<code>-C</code>: 防止重定向覆盖已有文件</li><li><code>histexpand</code>/<code>-H</code>: 启用<code>!</code>历史命令扩展</li></ul><h3 id="4-3-提示符定制-PS1">4.3 提示符定制(PS1)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS1=<span class="string">&#x27;[\u@\h \W]\$ &#x27;</span>  <span class="comment"># 常见默认提示符格式</span></span><br></pre></td></tr></table></figure><p>可用转义符：</p><ul><li><code>\s</code>: shell名称</li><li><code>\v</code>: bash版本</li><li><code>\u</code>: 用户名</li><li><code>\h</code>: 主机名</li><li><code>\w</code>: 当前工作目录</li></ul><h3 id="4-4-用户切换">4.4 用户切换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su user       <span class="comment"># 切换用户(不改变环境变量)</span></span><br><span class="line">su - user     <span class="comment"># 完全切换用户(包括环境)</span></span><br></pre></td></tr></table></figure><h2 id="5-帮助命令-man-详解">5.帮助命令 <code>man</code> 详解</h2><h3 id="基本用法">基本用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man <span class="built_in">command</span>      <span class="comment"># 查看命令的手册页(返回第一个匹配的帮助文件)</span></span><br></pre></td></tr></table></figure><h3 id="常用选项">常用选项</h3><table><thead><tr><th>选项</th><th>功能说明</th><th>等价命令</th></tr></thead><tbody><tr><td><code>-a</code></td><td>显示所有匹配的手册页(按顺序显示)</td><td>-</td></tr><tr><td><code>-f</code></td><td>查找完全匹配的命令文档</td><td><code>whatis</code></td></tr><tr><td><code>-k</code></td><td>查找包含关键词的文档</td><td><code>apropos</code></td></tr><tr><td><code>-w</code></td><td>显示手册页的存储路径</td><td>-</td></tr></tbody></table><h3 id="指定手册章节">指定手册章节</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">man 5 passwd     <span class="comment"># 查看/etc/passwd文件的格式说明(第5节)</span></span><br><span class="line">man 3 <span class="built_in">printf</span>     <span class="comment"># 查看C库函数printf的文档(第3节)</span></span><br></pre></td></tr></table></figure><h3 id="手册章节分类">手册章节分类</h3><table><thead><tr><th>Section</th><th>内容类型</th></tr></thead><tbody><tr><td>1</td><td>用户命令</td></tr><tr><td>2</td><td>系统调用</td></tr><tr><td>3</td><td>C库函数</td></tr><tr><td>4</td><td>设备文件</td></tr><tr><td>5</td><td>配置文件格式</td></tr><tr><td>6</td><td>游戏</td></tr><tr><td>7</td><td>杂项</td></tr><tr><td>8</td><td>系统管理命令</td></tr><tr><td>9</td><td>Linux内核相关</td></tr></tbody></table><h3 id="手册页存储位置">手册页存储位置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/man         <span class="comment"># 系统手册页主目录</span></span><br><span class="line">/usr/local/share/man   <span class="comment"># 本地安装软件的手册页</span></span><br></pre></td></tr></table></figure><h3 id="维护whatis数据库">维护whatis数据库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">makewhatis            <span class="comment"># 生成/更新whatis数据库(供-f/-k使用)</span></span><br><span class="line">mandb                 <span class="comment"># 现代系统中更新手册数据库(替代makewhatis)</span></span><br></pre></td></tr></table></figure><h3 id="使用示例">使用示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">man -a <span class="built_in">printf</span>        <span class="comment"># 查看所有章节的printf文档</span></span><br><span class="line">man -k <span class="string">&quot;copy&quot;</span>        <span class="comment"># 查找所有包含&quot;copy&quot;关键词的命令</span></span><br><span class="line">man -f <span class="built_in">ls</span>            <span class="comment"># 精确查找ls命令的文档</span></span><br><span class="line">man -w 5 passwd      <span class="comment"># 显示passwd配置文件的文档路径</span></span><br></pre></td></tr></table></figure><h2 id="6-管道与重定向">6. 管道与重定向</h2><h3 id="6-1-标准文件描述符">6.1 标准文件描述符</h3><table><thead><tr><th>文件描述符</th><th>名称</th><th>默认设备</th></tr></thead><tbody><tr><td>0</td><td>标准输入(stdin)</td><td>键盘</td></tr><tr><td>1</td><td>标准输出(stdout)</td><td>屏幕</td></tr><tr><td>2</td><td>标准错误(stderr)</td><td>屏幕</td></tr></tbody></table><h3 id="6-2-管道">6.2 管道(|)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令1 | 命令2    <span class="comment"># 将命令1的输出作为命令2的输入</span></span><br></pre></td></tr></table></figure><h3 id="6-3-tee命令">6.3 tee命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令 | <span class="built_in">tee</span> 文件    <span class="comment"># 同时输出到屏幕和文件</span></span><br><span class="line">命令 | <span class="built_in">tee</span> -a 文件 <span class="comment"># 追加模式(不覆盖原文件)</span></span><br></pre></td></tr></table></figure><h3 id="6-4-重定向操作">6.4 重定向操作</h3><table><thead><tr><th>语法</th><th>功能描述</th></tr></thead><tbody><tr><td><code>命令 &gt; 文件</code></td><td>标准输出覆盖写入文件</td></tr><tr><td><code>命令 &gt;&gt; 文件</code></td><td>标准输出追加写入文件</td></tr><tr><td><code>命令 &lt; 文件</code></td><td>从文件读取标准输入</td></tr><tr><td><code>命令 2&gt; 文件</code></td><td>标准错误覆盖写入文件</td></tr><tr><td><code>命令 2&gt;&gt; 文件</code></td><td>标准错误追加写入文件</td></tr><tr><td><code>命令 &gt; 文件 2&gt;&amp;1</code></td><td>标准输出和错误都覆盖写入同一文件</td></tr><tr><td><code>命令 &gt;&gt; 文件 2&gt;&amp;1</code></td><td>标准输出和错误都追加写入同一文件</td></tr><tr><td><code>命令 &lt;&lt; 结束标记</code></td><td>从标准输入读取直到遇到&quot;结束标记&quot;(here文档)</td></tr><tr><td><code>命令 &amp;&gt; 文件</code></td><td>标准输出和错误都覆盖写入文件(bash简写)</td></tr></tbody></table><h2 id="7-文件操作命令">7. 文件操作命令</h2><h3 id="7-1-ls命令">7.1 ls命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -a    <span class="comment"># 显示所有文件(包括.开头的隐藏文件)</span></span><br><span class="line"><span class="built_in">ls</span> -A    <span class="comment"># 类似-a但不显示.和..</span></span><br><span class="line"><span class="built_in">ls</span> -d    <span class="comment"># 显示目录本身而非内容</span></span><br><span class="line"><span class="built_in">ls</span> -F    <span class="comment"># 显示文件类型标识(/:目录, *:可执行, @:链接)</span></span><br><span class="line"><span class="built_in">ls</span> -i    <span class="comment"># 显示inode编号</span></span><br><span class="line"><span class="built_in">ls</span> -l    <span class="comment"># 长格式显示详细信息</span></span><br><span class="line"><span class="built_in">ls</span> -t    <span class="comment"># 按修改时间排序</span></span><br><span class="line"><span class="built_in">ls</span> -h    <span class="comment"># 人类可读的文件大小(如1K, 2M)</span></span><br></pre></td></tr></table></figure><h3 id="7-2-cp命令">7.2 cp命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -f    <span class="comment"># 强制覆盖不提示</span></span><br><span class="line"><span class="built_in">cp</span> -i    <span class="comment"># 覆盖前提示确认</span></span><br><span class="line"><span class="built_in">cp</span> -p    <span class="comment"># 保留原文件属性</span></span><br><span class="line"><span class="built_in">cp</span> -r/R  <span class="comment"># 递归复制目录</span></span><br><span class="line"><span class="built_in">cp</span> -d    <span class="comment"># 保留链接文件</span></span><br><span class="line"><span class="built_in">cp</span> -a    <span class="comment"># 归档模式(相当于-dpR)</span></span><br></pre></td></tr></table></figure><h3 id="7-3-mv命令">7.3 mv命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> -f    <span class="comment"># 强制覆盖不提示</span></span><br><span class="line"><span class="built_in">mv</span> -i    <span class="comment"># 覆盖前提示确认</span></span><br></pre></td></tr></table></figure><h3 id="7-4-mkdir命令">7.4 mkdir命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -m 755 <span class="built_in">dir</span>   <span class="comment"># 创建指定权限的目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p dir1/dir2 <span class="comment"># 创建多级目录</span></span><br></pre></td></tr></table></figure><h3 id="7-5-rm命令">7.5 rm命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f    <span class="comment"># 强制删除不提示</span></span><br><span class="line"><span class="built_in">rm</span> -i    <span class="comment"># 删除前提示确认</span></span><br><span class="line"><span class="built_in">rm</span> -r/R  <span class="comment"># 递归删除目录</span></span><br></pre></td></tr></table></figure><h3 id="7-6-rmdir命令">7.6 rmdir命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> -p dir1/dir2 <span class="comment"># 删除多级空目录</span></span><br></pre></td></tr></table></figure><h3 id="7-7-touch命令">7.7 touch命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> -t 202405071530.00 file  <span class="comment"># 设置特定时间戳(YYMMDDhhmm.ss)</span></span><br><span class="line"><span class="built_in">touch</span> -a file       <span class="comment"># 仅更新访问时间</span></span><br><span class="line"><span class="built_in">touch</span> -m file       <span class="comment"># 仅更新修改时间</span></span><br></pre></td></tr></table></figure><h3 id="7-8-file命令">7.8 file命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file document.txt   <span class="comment"># 检测文件类型和编码</span></span><br></pre></td></tr></table></figure><h2 id="8-元字符-通配符">8. 元字符(通配符)</h2><table><thead><tr><th>元字符</th><th>功能描述</th><th>示例</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配任意长度字符(包括空字符)</td><td><code>ls *.txt</code></td></tr><tr><td><code>?</code></td><td>匹配任意单个字符</td><td><code>ls file?.txt</code></td></tr><tr><td><code>[]</code></td><td>匹配括号内任意一个字符</td><td><code>ls file[123].txt</code></td></tr><tr><td><code>[!]</code></td><td>匹配不在括号内的任意一个字符</td><td><code>ls file[!a-z].txt</code></td></tr><tr><td><code>&#123;&#125;</code></td><td>展开括号内逗号分隔的多个模式</td><td><code>touch file&#123;1,2,3&#125;</code></td></tr></tbody></table><p>示例扩展：</p><ul><li><code>[a-z]</code>: 任意小写字母</li><li><code>[0-9]</code>: 任意数字</li><li><code>[a-zA-Z]</code>: 任意字母</li><li><code>file&#123;1..3&#125;</code>: 展开为file1, file2, file3</li></ul><h2 id="9-文档处理命令">9. 文档处理命令</h2><h3 id="9-1-文件内容查看">9.1 文件内容查看</h3><h4 id="cat-命令">cat 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> -n file.txt  <span class="comment"># 显示文件内容并添加行号</span></span><br></pre></td></tr></table></figure><h4 id="nl-命令（行号显示）">nl 命令（行号显示）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nl</span> -b a file.txt    <span class="comment"># 所有行添加行号</span></span><br><span class="line"><span class="built_in">nl</span> -b t file.txt    <span class="comment"># 非空行添加行号</span></span><br><span class="line"><span class="built_in">nl</span> -h a -f a file.txt  <span class="comment"># 为页眉和页脚也添加行号</span></span><br></pre></td></tr></table></figure><h4 id="od-命令（二进制查看）">od 命令（二进制查看）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">od</span> -t c file.bin    <span class="comment"># 以ASCII字符显示</span></span><br><span class="line"><span class="built_in">od</span> -t o file.bin    <span class="comment"># 以八进制显示</span></span><br><span class="line"><span class="built_in">od</span> -t x file.bin    <span class="comment"># 以十六进制显示</span></span><br></pre></td></tr></table></figure><h3 id="9-2-文件头部-尾部查看">9.2 文件头部/尾部查看</h3><h4 id="head-命令">head 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 10 file.txt    <span class="comment"># 显示前10行</span></span><br><span class="line"><span class="built_in">head</span> -10 file.txt      <span class="comment"># 同上</span></span><br><span class="line"><span class="built_in">head</span> -c 100 file.txt   <span class="comment"># 显示前100字节</span></span><br></pre></td></tr></table></figure><h4 id="tail-命令">tail 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -n 10 file.txt    <span class="comment"># 显示最后10行</span></span><br><span class="line"><span class="built_in">tail</span> -10 file.txt      <span class="comment"># 同上</span></span><br><span class="line"><span class="built_in">tail</span> -c 100 file.txt   <span class="comment"># 显示最后100字节</span></span><br><span class="line"><span class="built_in">tail</span> -f log.txt        <span class="comment"># 实时监控日志文件</span></span><br></pre></td></tr></table></figure><h3 id="9-3-文本提取与转换">9.3 文本提取与转换</h3><h4 id="cut-命令">cut 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cut</span> -c 1-5 file.txt      <span class="comment"># 提取每行第1-5个字符</span></span><br><span class="line"><span class="built_in">cut</span> -d: -f1 /etc/passwd  <span class="comment"># 以冒号分隔，提取第一个字段</span></span><br></pre></td></tr></table></figure><h4 id="join-命令（合并文件）">join 命令（合并文件）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">join</span> -j 1 file1.txt file2.txt  <span class="comment"># 按第一个字段合并两个文件</span></span><br></pre></td></tr></table></figure><h4 id="paste-命令">paste 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">paste</span> -d<span class="string">&quot;;&quot;</span> file1.txt file2.txt  <span class="comment"># 用分号分隔合并文件</span></span><br></pre></td></tr></table></figure><h4 id="tr-命令（字符转换）">tr 命令（字符转换）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tr</span> <span class="string">&#x27;a-z&#x27;</span> <span class="string">&#x27;A-Z&#x27;</span> &lt; file.txt    <span class="comment"># 小写转大写</span></span><br><span class="line"><span class="built_in">tr</span> -d <span class="string">&#x27;\r&#x27;</span> &lt; file.txt        <span class="comment"># 删除回车符</span></span><br><span class="line"><span class="built_in">tr</span> -s <span class="string">&#x27; &#x27;</span> &lt; file.txt         <span class="comment"># 压缩连续空格</span></span><br><span class="line"><span class="built_in">tr</span> -d <span class="string">&#x27;[:digit:]&#x27;</span> &lt; file.txt <span class="comment"># 删除所有数字</span></span><br></pre></td></tr></table></figure><h3 id="9-4-文本排序与统计">9.4 文本排序与统计</h3><h4 id="sort-命令">sort 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span> file.txt          <span class="comment"># 按字母顺序排序</span></span><br><span class="line"><span class="built_in">sort</span> -n file.txt       <span class="comment"># 按数值排序</span></span><br><span class="line"><span class="built_in">sort</span> -r file.txt       <span class="comment"># 反向排序</span></span><br><span class="line"><span class="built_in">sort</span> -t: -k3n /etc/passwd  <span class="comment"># 按冒号分隔的第3列数值排序</span></span><br></pre></td></tr></table></figure><h4 id="uniq-命令（去重）">uniq 命令（去重）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span> file.txt | <span class="built_in">uniq</span>    <span class="comment"># 去重（需先排序）</span></span><br><span class="line"><span class="built_in">uniq</span> -d file.txt        <span class="comment"># 只显示重复行</span></span><br><span class="line"><span class="built_in">uniq</span> -u file.txt        <span class="comment"># 只显示唯一行</span></span><br></pre></td></tr></table></figure><h4 id="wc-命令（统计）">wc 命令（统计）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wc</span> -l file.txt    <span class="comment"># 统计行数</span></span><br><span class="line"><span class="built_in">wc</span> -w file.txt    <span class="comment"># 统计单词数</span></span><br><span class="line"><span class="built_in">wc</span> -c file.txt    <span class="comment"># 统计字节数</span></span><br></pre></td></tr></table></figure><h3 id="9-5-文本分割与格式化">9.5 文本分割与格式化</h3><h4 id="split-命令">split 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> -l 1000 bigfile.txt part_  <span class="comment"># 每1000行分割文件</span></span><br></pre></td></tr></table></figure><h4 id="pr-命令（分页）">pr 命令（分页）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pr</span> -l 40 file.txt    <span class="comment"># 按每页40行分页显示</span></span><br></pre></td></tr></table></figure><h4 id="fmt-命令（格式化）">fmt 命令（格式化）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fmt</span> -w 80 file.txt   <span class="comment"># 设置每行80个字符</span></span><br></pre></td></tr></table></figure><h4 id="expand-unexpand-命令">expand/unexpand 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">expand</span> -t 4 file.txt    <span class="comment"># 将tab转为4个空格</span></span><br><span class="line"><span class="built_in">unexpand</span> -t 4 file.txt  <span class="comment"># 将4个空格转为tab</span></span><br></pre></td></tr></table></figure><h3 id="8-6-高级文本处理">8.6 高级文本处理</h3><h4 id="xargs-命令">xargs 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">&quot;*.log&quot;</span> | xargs <span class="built_in">rm</span>    <span class="comment"># 删除所有log文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f | xargs grep <span class="string">&quot;text&quot;</span> <span class="comment"># 在所有文件中搜索文本</span></span><br></pre></td></tr></table></figure><h2 id="10-vi-vim-编辑器">10. vi/vim 编辑器</h2><h3 id="10-1-基本操作">10.1 基本操作</h3><h4 id="启动与退出">启动与退出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi file.txt        <span class="comment"># 编辑文件</span></span><br><span class="line">vi -R file.txt     <span class="comment"># 只读模式</span></span><br><span class="line">:q                 <span class="comment"># 退出</span></span><br><span class="line">:q!                <span class="comment"># 强制退出</span></span><br><span class="line">:wq 或 ZZ          <span class="comment"># 保存退出</span></span><br></pre></td></tr></table></figure><h4 id="模式切换">模式切换</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>i</td><td>在光标前插入</td></tr><tr><td>a</td><td>在光标后插入</td></tr><tr><td>I</td><td>在行首插入</td></tr><tr><td>A</td><td>在行尾插入</td></tr><tr><td>o</td><td>在下一行插入</td></tr><tr><td>O</td><td>在上一行插入</td></tr><tr><td>ESC</td><td>返回命令模式</td></tr></tbody></table><h3 id="10-2-光标移动">10.2 光标移动</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>h/j/k/l</td><td>左/下/上/右</td></tr><tr><td>0</td><td>行首</td></tr><tr><td>$</td><td>行尾</td></tr><tr><td>gg</td><td>文件开头</td></tr><tr><td>G</td><td>文件末尾</td></tr><tr><td>50G</td><td>跳转到第50行</td></tr><tr><td>Ctrl+b</td><td>上一页</td></tr><tr><td>Ctrl+f</td><td>下一页</td></tr></tbody></table><h3 id="10-3-编辑命令">10.3 编辑命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>x</td><td>删除当前字符</td></tr><tr><td>X</td><td>删除前一个字符</td></tr><tr><td>dd</td><td>删除当前行</td></tr><tr><td>dw</td><td>删除下一个单词</td></tr><tr><td>yy</td><td>复制当前行</td></tr><tr><td>p</td><td>粘贴到光标后</td></tr><tr><td>P</td><td>粘贴到光标前</td></tr><tr><td>u</td><td>撤销</td></tr><tr><td>Ctrl+r</td><td>重做</td></tr></tbody></table><h3 id="10-4-搜索与替换">10.4 搜索与替换</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>/pattern</td><td>向前搜索</td></tr><tr><td>?pattern</td><td>向后搜索</td></tr><tr><td>n</td><td>下一个匹配项</td></tr><tr><td>N</td><td>上一个匹配项</td></tr><tr><td>:%s/old/new/g</td><td>全局替换</td></tr><tr><td>:1,10s/old/new/g</td><td>替换1-10行的内容</td></tr></tbody></table><h3 id="10-5-设置选项">10.5 设置选项</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">set</span> <span class="keyword">nu</span>        # 显示行号</span><br><span class="line">:<span class="keyword">set</span> nonu      # 隐藏行号</span><br><span class="line">:<span class="keyword">set</span> <span class="keyword">ts</span>=<span class="number">4</span>      # 设置<span class="keyword">tab</span>为<span class="number">4</span>个空格</span><br><span class="line">:<span class="keyword">set</span> <span class="keyword">list</span>      # 显示不可见字符</span><br></pre></td></tr></table></figure><h2 id="11-正则表达式与文本搜索">11. 正则表达式与文本搜索</h2><h3 id="11-1-基本元字符">11.1 基本元字符</h3><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配任意单个字符</td></tr><tr><td>*</td><td>前一个字符0次或多次</td></tr><tr><td>[]</td><td>匹配括号内任意一个字符</td></tr><tr><td>[^]</td><td>不匹配括号内的字符</td></tr><tr><td>^</td><td>行首</td></tr><tr><td>$</td><td>行尾</td></tr><tr><td>\</td><td>转义特殊字符</td></tr></tbody></table><h3 id="11-2-grep-命令">11.2 grep 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;pattern&quot;</span> file.txt      <span class="comment"># 基本搜索</span></span><br><span class="line">grep -i <span class="string">&quot;pattern&quot;</span> file.txt   <span class="comment"># 忽略大小写</span></span><br><span class="line">grep -v <span class="string">&quot;pattern&quot;</span> file.txt   <span class="comment"># 反向匹配</span></span><br><span class="line">grep -n <span class="string">&quot;pattern&quot;</span> file.txt   <span class="comment"># 显示行号</span></span><br><span class="line">grep -E <span class="string">&quot;regex&quot;</span> file.txt     <span class="comment"># 使用扩展正则</span></span><br><span class="line">grep -r <span class="string">&quot;pattern&quot;</span> /dir       <span class="comment"># 递归搜索目录</span></span><br></pre></td></tr></table></figure><h4 id="特殊变体">特殊变体</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">egrep = grep -E       <span class="comment"># 扩展正则表达式</span></span><br><span class="line">fgrep = grep -F       <span class="comment"># 不解析正则，快速搜索</span></span><br><span class="line">pgrep -u root         <span class="comment"># 搜索root用户的进程</span></span><br></pre></td></tr></table></figure><h3 id="11-3-sed-流编辑器">11.3 sed 流编辑器</h3><h4 id="基本用法-2">基本用法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/old/new/&#x27;</span> file.txt       <span class="comment"># 替换第一个匹配</span></span><br><span class="line">sed <span class="string">&#x27;s/old/new/g&#x27;</span> file.txt      <span class="comment"># 替换所有匹配</span></span><br><span class="line">sed <span class="string">&#x27;1,5d&#x27;</span> file.txt             <span class="comment"># 删除1-5行</span></span><br><span class="line">sed <span class="string">&#x27;/pattern/d&#x27;</span> file.txt       <span class="comment"># 删除匹配行</span></span><br></pre></td></tr></table></figure><h4 id="高级用法">高级用法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;10,20p&#x27;</span> file.txt       <span class="comment"># 只打印10-20行</span></span><br><span class="line">sed <span class="string">&#x27;y/abc/ABC/&#x27;</span> file.txt      <span class="comment"># 字符转换</span></span><br><span class="line">sed -i.bak <span class="string">&#x27;s/old/new/&#x27;</span> file   <span class="comment"># 直接修改文件并备份</span></span><br><span class="line">sed -e <span class="string">&#x27;cmd1&#x27;</span> -e <span class="string">&#x27;cmd2&#x27;</span> file   <span class="comment"># 执行多个命令</span></span><br></pre></td></tr></table></figure><h4 id="脚本示例">脚本示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将1-5行行首添加&gt;字符</span></span><br><span class="line">sed <span class="string">&#x27;1,5s/^/&gt;/&#x27;</span> file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将每行的第一个数字替换为#</span></span><br><span class="line">sed <span class="string">&#x27;s/[0-9]/#/&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><h3 id="11-4-正则表达式示例">11.4 正则表达式示例</h3><ol><li>匹配IP地址：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&#x27;([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><ol start="2"><li>匹配邮箱地址：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&#x27;[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]&#123;2,&#125;&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><ol start="3"><li>提取HTML标签内容：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;s/&lt;title&gt;\(.*\)&lt;\/title&gt;/\1/p&#x27;</span> file.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.linux安装与包管理</title>
      <link href="/2020/05/07/linux/2-linux%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8C%85%E7%AE%A1%E7%90%86/"/>
      <url>/2020/05/07/linux/2-linux%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8C%85%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1>Linux 安装与软件包管理</h1><h2 id="1-硬盘分区布局">1. 硬盘分区布局</h2><h3 id="1-1-标准目录结构">1.1 标准目录结构</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/home     # 普通用户文件存储目录</span><br><span class="line">/var      # 存放日志文件、邮件队列等可变数据</span><br><span class="line">/usr      # 存放程序、库文件、文档等(通常占用空间最大)</span><br><span class="line">/boot     # 引导分区，通常100MB左右足够</span><br><span class="line">/swap     # 交换分区(建议大小为物理内存的1-2倍)</span><br></pre></td></tr></table></figure><h2 id="2-引导加载程序-GRUB">2. 引导加载程序(GRUB)</h2><h3 id="2-1-传统GRUB-GRUB-Legacy">2.1 传统GRUB (GRUB Legacy)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grub-install /dev/sda   <span class="comment"># 安装GRUB到指定设备</span></span><br><span class="line">grub-install -v         <span class="comment"># 显示详细安装信息</span></span><br></pre></td></tr></table></figure><h4 id="配置文件关键参数-boot-grub-menu-lst">配置文件关键参数(/boot/grub/menu.lst):</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">timeout      # 等待用户选择的时间(秒)</span><br><span class="line">default      # 默认启动项序号</span><br><span class="line">title        # 启动项标题</span><br><span class="line">root         # 指定根分区</span><br><span class="line">kernel       # 指定内核文件</span><br><span class="line">makeactive   # 激活分区</span><br><span class="line">chainloader  # 链式加载其他引导程序</span><br><span class="line">hiddenmenu   # 是否隐藏菜单</span><br></pre></td></tr></table></figure><h3 id="2-2-GRUB2-现代Linux默认使用">2.2 GRUB2 (现代Linux默认使用)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-grub2   <span class="comment"># 更新GRUB2配置</span></span><br></pre></td></tr></table></figure><h4 id="配置文件-etc-default-grub">配置文件(/etc/default/grub):</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GRUB_DEFAULT                  # 默认启动项</span><br><span class="line">GRUB_HIDDEN_TIMEOUT           # 隐藏菜单超时</span><br><span class="line">GRUB_HIDDEN_TIMEOUT_QUIET     # 是否静默隐藏</span><br><span class="line">GRUB_TIMEOUT                  # 菜单显示时间</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT    # 默认内核参数</span><br><span class="line">GRUB_CMDLINE_LINUX            # 附加内核参数</span><br></pre></td></tr></table></figure><h2 id="3-共享库管理">3. 共享库管理</h2><h3 id="3-1-基本概念">3.1 基本概念</h3><ul><li><strong>共享库(Shared Library)</strong>: 通过动态链接方式被多个程序共同使用的库文件</li><li>命名规则: <code>lib*.so*</code> (如 <code>libc.so.6</code>)</li></ul><h3 id="3-2-常用命令">3.2 常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldd /bin/ls      <span class="comment"># 查看二进制文件依赖的共享库</span></span><br><span class="line">ldconfig         <span class="comment"># 重建共享库缓存</span></span><br><span class="line">ldconfig -p      <span class="comment"># 打印当前缓存内容</span></span><br></pre></td></tr></table></figure><h3 id="3-3-共享库搜索顺序">3.3 共享库搜索顺序</h3><ol><li>可执行文件中的DT_RPATH或DT_RUNPATH段</li><li>环境变量<code>LD_LIBRARY_PATH</code>指定的路径</li><li><code>/etc/ld.so.cache</code>缓存中的路径(除非使用<code>-z nodeflib</code>选项)</li><li>默认路径<code>/lib</code>和<code>/usr/lib</code>(除非使用<code>-z nodeflib</code>选项)</li></ol><h3 id="3-4-添加自定义库路径">3.4 添加自定义库路径</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 临时添加(当前会话有效)</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/path/to/library</span><br><span class="line"></span><br><span class="line"><span class="comment"># 永久添加(需修改配置文件)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/path/to/library&quot;</span> &gt;&gt; /etc/ld.so.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure><h2 id="4-Debian系包管理-Debian-Ubuntu等">4. Debian系包管理(Debian/Ubuntu等)</h2><h3 id="4-1-包命名格式">4.1 包命名格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tree_1.5.3-1_i386.deb</span><br><span class="line">├── 包名(tree)</span><br><span class="line">├── 版本号(1.5.3)</span><br><span class="line">├── 发布号(1)</span><br><span class="line">├── 架构(i386)</span><br><span class="line">└── 扩展名(.deb)</span><br></pre></td></tr></table></figure><h3 id="4-2-dpkg命令-底层工具">4.2 dpkg命令(底层工具)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i package.deb       <span class="comment"># 安装包</span></span><br><span class="line">dpkg -r package           <span class="comment"># 移除包(保留配置)</span></span><br><span class="line">dpkg -P package           <span class="comment"># 完全清除包(包括配置)</span></span><br><span class="line">dpkg -l                   <span class="comment"># 列出已安装包</span></span><br><span class="line">dpkg -L package           <span class="comment"># 列出包安装的文件</span></span><br><span class="line">dpkg -s package           <span class="comment"># 显示包状态信息</span></span><br><span class="line">dpkg -S /path/to/file     <span class="comment"># 查找文件属于哪个包</span></span><br><span class="line">dpkg --configure package  <span class="comment"># 配置已解压的包</span></span><br><span class="line">dpkg --unpack package.deb <span class="comment"># 仅解压不配置</span></span><br></pre></td></tr></table></figure><h3 id="4-3-apt-get命令-高级工具">4.3 apt-get命令(高级工具)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apt-get update            <span class="comment"># 更新包数据库</span></span><br><span class="line">apt-get upgrade           <span class="comment"># 升级所有可升级包</span></span><br><span class="line">apt-get dist-upgrade      <span class="comment"># 智能升级(处理依赖变化)</span></span><br><span class="line">apt-get install package   <span class="comment"># 安装包</span></span><br><span class="line">apt-get remove package    <span class="comment"># 移除包</span></span><br><span class="line">apt-get clean             <span class="comment"># 清理下载的包文件</span></span><br><span class="line">apt-get -d install package <span class="comment"># 仅下载不安装</span></span><br><span class="line">apt-get -s install package <span class="comment"># 模拟安装(不实际执行)</span></span><br></pre></td></tr></table></figure><h3 id="4-4-软件源配置-etc-apt-sources-list">4.4 软件源配置(/etc/apt/sources.list)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">↑         ↑                          ↑       ↑</span><br><span class="line">类型     镜像地址                    发行版   组件</span><br></pre></td></tr></table></figure><ul><li><strong>类型</strong>: <code>deb</code>(二进制包)或<code>deb-src</code>(源代码包)</li><li><strong>组件</strong>:<ul><li><code>main</code>: 官方支持的免费软件</li><li><code>contrib</code>: 非自由软件但有自由依赖</li><li><code>non-free</code>: 有分发限制的软件</li></ul></li></ul><h3 id="4-5-apt-cache命令-查询工具">4.5 apt-cache命令(查询工具)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-cache search keyword    <span class="comment"># 搜索包</span></span><br><span class="line">apt-cache show package      <span class="comment"># 显示包详细信息</span></span><br><span class="line">apt-cache depends package   <span class="comment"># 显示包依赖</span></span><br></pre></td></tr></table></figure><h3 id="4-6-aptitude命令-交互式工具">4.6 aptitude命令(交互式工具)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aptitude update          <span class="comment"># 更新包列表</span></span><br><span class="line">aptitude install package <span class="comment"># 安装包</span></span><br><span class="line">aptitude remove package  <span class="comment"># 移除包</span></span><br><span class="line">aptitude purge package   <span class="comment"># 完全清除包</span></span><br><span class="line">aptitude upgrade         <span class="comment"># 升级包</span></span><br><span class="line">aptitude dist-upgrade    <span class="comment"># 智能升级</span></span><br></pre></td></tr></table></figure><h2 id="5-RedHat系包管理-RHEL-CentOS-Fedora">5. RedHat系包管理(RHEL/CentOS/Fedora)</h2><h3 id="5-1-rpm命令-底层工具">5.1 rpm命令(底层工具)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh package.rpm     <span class="comment"># 安装包(-v:详细,-h:进度条)</span></span><br><span class="line">rpm -Uvh package.rpm     <span class="comment"># 升级包</span></span><br><span class="line">rpm -Fvh *.rpm           <span class="comment"># 仅升级已安装的包</span></span><br><span class="line">rpm -e package           <span class="comment"># 卸载包</span></span><br><span class="line">rpm -qa                  <span class="comment"># 查询所有已安装包</span></span><br><span class="line">rpm -qf /path/to/file    <span class="comment"># 查询文件属于哪个包</span></span><br><span class="line">rpm -qi package          <span class="comment"># 查询包信息</span></span><br><span class="line">rpm -ql package          <span class="comment"># 列出包安装的文件</span></span><br><span class="line">rpm -qc package          <span class="comment"># 列出包配置文件</span></span><br><span class="line">rpm -qd package          <span class="comment"># 列出包文档文件</span></span><br><span class="line">rpm --nodeps             <span class="comment"># 忽略依赖关系(不推荐)</span></span><br><span class="line">rpm --<span class="built_in">test</span>               <span class="comment"># 测试模式(不实际执行)</span></span><br></pre></td></tr></table></figure><h3 id="5-2-rpm文件提取">5.2 rpm文件提取</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm2cpio package.rpm | cpio -idv  <span class="comment"># 提取rpm包内容</span></span><br><span class="line">rpm2cpio package.rpm | cpio -t    <span class="comment"># 列出rpm包内容</span></span><br></pre></td></tr></table></figure><h3 id="5-3-yum命令-高级工具">5.3 yum命令(高级工具)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yum install package      <span class="comment"># 安装包</span></span><br><span class="line">yum remove package       <span class="comment"># 移除包</span></span><br><span class="line">yum update               <span class="comment"># 更新所有包</span></span><br><span class="line">yum update package       <span class="comment"># 更新指定包</span></span><br><span class="line">yum check-update         <span class="comment"># 检查可用更新</span></span><br><span class="line">yum info package         <span class="comment"># 显示包信息</span></span><br><span class="line">yum list                 <span class="comment"># 列出包</span></span><br><span class="line">yum search keyword       <span class="comment"># 搜索包</span></span><br><span class="line">yum groupinstall <span class="string">&quot;Development Tools&quot;</span> <span class="comment"># 安装软件组</span></span><br><span class="line">yum repolist             <span class="comment"># 列出已配置的仓库</span></span><br></pre></td></tr></table></figure><h3 id="5-4-下载rpm包">5.4 下载rpm包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yumdownloader package    <span class="comment"># 下载rpm包不安装</span></span><br></pre></td></tr></table></figure><h3 id="5-5-zypper命令-SUSE系统">5.5 zypper命令(SUSE系统)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zypper install package   <span class="comment"># 安装包</span></span><br><span class="line">zypper remove package    <span class="comment"># 移除包</span></span><br><span class="line">zypper update            <span class="comment"># 更新系统</span></span><br></pre></td></tr></table></figure><h2 id="6-软件包管理对比">6. 软件包管理对比</h2><table><thead><tr><th>功能</th><th>Debian系(apt)</th><th>RedHat系(yum)</th><th>SUSE系(zypper)</th></tr></thead><tbody><tr><td>安装包</td><td>apt-get install</td><td>yum install</td><td>zypper install</td></tr><tr><td>移除包</td><td>apt-get remove</td><td>yum remove</td><td>zypper remove</td></tr><tr><td>更新系统</td><td>apt-get upgrade</td><td>yum update</td><td>zypper update</td></tr><tr><td>搜索包</td><td>apt-cache search</td><td>yum search</td><td>zypper search</td></tr><tr><td>显示包信息</td><td>apt-cache show</td><td>yum info</td><td>zypper info</td></tr><tr><td>清理缓存</td><td>apt-get clean</td><td>yum clean</td><td>zypper clean</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.系统架构</title>
      <link href="/2020/05/06/linux/1-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
      <url>/2020/05/06/linux/1-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="1-系统架构">1. 系统架构</h2><h3 id="1-1-PCI架构">1.1 PCI架构</h3><ul><li><strong>PCI(外围组件互连)</strong>: Intel Core系统的主要总线架构</li><li><strong>组件</strong>:<ul><li><strong>CPU</strong>:<ul><li>显示: eDP(支持i7 CPU和DDR4内存)</li><li>显示: HDMI(支持i7 CPU和DDR4内存)</li></ul></li><li><strong>PCH(平台控制器中枢)</strong>:<ul><li>USB 3.0接口</li><li>PCI总线</li><li>音频输出</li></ul></li></ul></li></ul><h3 id="1-2-lspci命令">1.2 lspci命令</h3><ul><li>显示PCI总线和连接设备的信息</li><li>可以查看:<ul><li>中断请求(IRQ)信息</li><li>设备路径和速度</li><li>制造商ID</li></ul></li></ul><h3 id="1-3-ACPI-高级配置与电源接口">1.3 ACPI(高级配置与电源接口)</h3><ul><li>电源管理规范标准</li><li>管理功能包括:<ul><li>电源按钮操作</li><li>笔记本开合盖检测</li><li>电池充电状态</li><li>CPU速度调节</li></ul></li><li><strong>重要说明</strong>:<ul><li>不直接管理硬件，而是处理电源事件</li><li>配置文件位置:<ul><li><code>/etc/acpi/</code>目录</li><li><code>/proc/acpi/</code>目录</li></ul></li></ul></li><li><strong>守护进程</strong>:<ul><li><code>acpid</code>:<ul><li>配置目录: <code>/etc/acpi/</code></li><li>示例: 查看电源配置<code>cat /etc/acpi/events/power.conf</code></li></ul></li><li><code>systemd-logind</code>:<ul><li>配置文件: <code>/etc/systemd/logind.conf</code></li></ul></li></ul></li></ul><h2 id="2-启动流程">2. 启动流程</h2><h3 id="2-1-传统SysV-Init启动">2.1 传统SysV Init启动</h3><ol><li>电源启动</li><li>BIOS初始化</li><li>引导加载程序(GRUB)</li><li>加载内核(<code>vmlinuz</code>, <code>initramfs</code>)</li><li>执行内核</li><li>执行initramfs</li><li>init进程启动并挂载根文件系统</li><li>init启动各种服务</li></ol><h3 id="2-2-现代systemd启动">2.2 现代systemd启动</h3><ol><li>电源启动</li><li>UEFI初始化</li><li>引导加载程序(GRUB2)</li><li>加载内核(<code>vmlinuz</code>, <code>initramfs</code>)</li><li>执行内核</li><li>执行initramfs</li><li>systemd启动并挂载根文件系统</li><li>systemd启动各种服务</li></ol><h3 id="2-3-Init进程详情">2.3 Init进程详情</h3><ul><li>第一个用户空间进程路径: <code>/sbin/init</code></li><li>传统init流程:<ol><li>init读取<code>/etc/inittab</code></li><li>init执行<code>/etc/rc.sysinit</code>脚本</li><li>init执行<code>/etc/rc</code>脚本</li><li><code>/etc/rc</code>执行<code>/etc/rc&lt;运行级别&gt;.d/</code>目录下的脚本</li></ol></li></ul><h2 id="3-分区表">3. 分区表</h2><h3 id="3-1-GPT-GUID分区表">3.1 GPT(GUID分区表)</h3><ul><li>EFI规范的一部分</li><li>支持最大9.4TB分区</li><li>使用GUID标识:<ul><li>设备标识</li><li>分区标识</li></ul></li></ul><h3 id="3-2-MBR-主引导记录">3.2 MBR(主引导记录)</h3><ul><li>使用CHS(柱面/磁头/扇区)寻址</li><li>最大只支持2TB分区</li></ul><h2 id="4-系统信息命令">4. 系统信息命令</h2><h3 id="4-1-uname命令">4.1 uname命令</h3><p>显示系统信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -m  <span class="comment"># 显示硬件架构类型</span></span><br><span class="line"><span class="built_in">uname</span> -n  <span class="comment"># 显示网络节点主机名</span></span><br><span class="line"><span class="built_in">uname</span> -r  <span class="comment"># 显示内核发行版本</span></span><br><span class="line"><span class="built_in">uname</span> -s  <span class="comment"># 显示操作系统名称</span></span><br><span class="line"><span class="built_in">uname</span> -v  <span class="comment"># 显示内核版本</span></span><br><span class="line"><span class="built_in">uname</span> -a  <span class="comment"># 显示所有信息</span></span><br></pre></td></tr></table></figure><h3 id="4-2-wall命令">4.2 wall命令</h3><p>向所有用户广播消息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wall <span class="string">&quot;消息内容&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-3-dmesg命令">4.3 dmesg命令</h3><p>显示内核环形缓冲区消息(启动日志):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg</span><br></pre></td></tr></table></figure><h3 id="4-4-lsmod命令">4.4 lsmod命令</h3><p>列出已加载的内核模块:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod</span><br></pre></td></tr></table></figure><h3 id="4-5-modprobe命令">4.5 modprobe命令</h3><p>手动加载设备驱动:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe &lt;设备名称&gt;</span><br></pre></td></tr></table></figure><h2 id="5-proc文件系统">5. /proc文件系统</h2><p>/proc目录下的重要文件:</p><ul><li><code>/proc/bus/usb/*</code> - USB设备信息</li><li><code>/proc/cpuinfo</code> - CPU信息</li><li><code>/proc/interrupts</code> - 中断请求信息</li><li><code>/proc/pci</code> - PCI设备信息</li><li><code>/proc/scsi/scsi</code> - SCSI设备信息</li><li><code>/proc/version</code> - 内核版本信息</li><li><code>/proc/meminfo</code> - 内存信息</li></ul><h2 id="6-运行级别">6. 运行级别</h2><p>运行级别配置文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/inittab</span><br></pre></td></tr></table></figure><h2 id="7-模拟器">7. 模拟器</h2><p>通过软件模拟硬件环境来运行不同操作系统的工具</p><h2 id="8-启动顺序图示">8. 启动顺序图示</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[BIOS/UEFI固件] --&gt; B[引导加载程序]</span><br><span class="line">    B --&gt; C[Linux内核]</span><br><span class="line">    C --&gt; D[Init/Systemd]</span><br><span class="line">    D --&gt; E[系统服务]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> LPIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率2-连续型随机分布律</title>
      <link href="/2019/10/28/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%872-%E8%BF%9E%E7%BB%AD%E5%9E%8B%E9%9A%8F%E6%9C%BA%E5%88%86%E5%B8%83%E5%BE%8B/"/>
      <url>/2019/10/28/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%872-%E8%BF%9E%E7%BB%AD%E5%9E%8B%E9%9A%8F%E6%9C%BA%E5%88%86%E5%B8%83%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="1-均匀分布">1,均匀分布</h5><p>若连续型随机变量X具有概率密度</p>\begin{align*}f(x)= \begin{cases}{1 \over {b-a}} ,a < x < b,\\0\end{cases}\end{align*}<p>则称X在区间(a,b)上服从均匀分布，记为X〜U(a,b)</p><p>分布函数：</p>\begin{align*}F(x)= \begin{cases} 0, & x < a \\\frac{x-a}{b-a}, & a \leq x < b \\1, & x \geq b \end{cases}\end{align*}<hr><h3 id="2-指数分布">2. 指数分布</h3><p>若连续型随机变量X具有概率密度：</p>\begin{align*}f(x)= \begin{cases}\frac{1}{\theta} e^{-x/\theta}, & x > 0 \\0, & \text{其他}\end{cases}\end{align*}<p>其中θ&gt;0为常数，则称X服从参数为θ的指数分布。</p><p>易知f(x)≥0，且：</p>\begin{align*}\int^\infty_{-\infty}f(x)dx = \left[-e^{-x/\theta}\right]^\infty_0 = 1\end{align*}<p>分布函数：</p>\begin{align*}F(x)= \begin{cases}1-e^{-x/\theta}, & x > 0 \\0, & \text{其他}\end{cases}\end{align*}<p>服从指数分布的随机变量X具有无记忆性：<br>对于任意s,t&gt;0，有</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>{</mo><mi>X</mi><mo>&gt;</mo><mi>s</mi><mo>+</mo><mi>t</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo>&gt;</mo><mi>s</mi><mo>}</mo><mo>=</mo><mi>P</mi><mo>(</mo><mi>X</mi><mo>&gt;</mo><mi>t</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">P\{X&gt;s+t|X&gt;s\} = P(X&gt;t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">{</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mrel">&gt;</span><span class="mord mathit">s</span><span class="mbin">+</span><span class="mord mathit">t</span><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mrel">&gt;</span><span class="mord mathit">s</span><span class="mclose">}</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mrel">&gt;</span><span class="mord mathit">t</span><span class="mclose">)</span></span></span></span></span></p><p>证明：</p>\begin{align*}P\{X>s+t|X>s\} &= \frac{P\{X>s+t\} \cap P\{X>s\}}{P\{X>s\}} \\&= \frac{P\{X>s+t\}}{P\{X>s\}} \\&= \frac{1-F(s+t)}{1-F(s)} \\&= \frac{e^{-(s+t)/\theta}}{e^{-s/\theta}} \\&= e^{-t/\theta} \\&= P\{X>t\}\end{align*}<hr><h3 id="3-正态分布">3. 正态分布</h3><p>若连续型随机变量X具有概率密度：</p>\begin{align*}f(x) = \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}\end{align*}<p>其中μ,σ(σ&gt;0)为常数，则称X服从参数为μ,σ的正态分布，记为X～N(μ,σ²)。</p><p>显然f(x)≥0，下面证明：</p>\begin{align*}\int^\infty_{-\infty}f(x)dx = 1\end{align*}<p>令<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mfrac><mrow><mi>x</mi><mo>−</mo><mi>μ</mi></mrow><mrow><mi>σ</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">t = \frac{x-\mu}{\sigma}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.854439em;"></span><span class="strut bottom" style="height:1.199439em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mrel">=</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03588em;">σ</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.44610799999999995em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">x</span><span class="mbin">−</span><span class="mord mathit">μ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>，则：</p>\begin{align*}σ=(x-μ)/t,t'(x)=1/σ\end{align*}<p>得到:</p>\begin{align*}\int^\infty_{-\infty}\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}dx &=\int^\infty_{-\infty}{1 \over {\sqrt{2 \pi}}(x-μ)/t}e^{-t^2 \over 2}dt \\&= \frac{1}{\sqrt{2\pi}}\int^\infty_{-\infty}e^{-\frac{t^2}{2}}dt\end{align*}<p>记：</p>\begin{align*}I = \int^\infty_{-\infty}e^{-\frac{t^2}{2}}dt\end{align*}<p>则有：</p>\begin{align*}I^2 = \int^\infty_{-\infty}\int^\infty_{-\infty}e^{-\frac{t^2+u^2}{2}}dtdu\end{align*}<p>利用极坐标变换：</p>\begin{align*}I^2 = \int^{2\pi}_0\int^\infty_0 re^{-\frac{r^2}{2}}drd\theta = 2\pi\end{align*}<p>（p55）</p><hr><h3 id="附：">附：</h3><p>计算：</p>\begin{align*}\iint_D^\infty e^{-\frac{x^2+y^2}{2}}dxdy\end{align*}]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率1-离散型随机分布律</title>
      <link href="/2019/10/28/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%871-%E7%A6%BB%E6%95%A3%E5%9E%8B%E9%9A%8F%E6%9C%BA%E5%88%86%E5%B8%83%E5%BE%8B/"/>
      <url>/2019/10/28/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%871-%E7%A6%BB%E6%95%A3%E5%9E%8B%E9%9A%8F%E6%9C%BA%E5%88%86%E5%B8%83%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="１-不放回抽样表达式">１.不放回抽样表达式:</h5><p>a件产品中抽取n件（不放回），则可能的取法有</p>\begin{align*}\left( \begin{matrix} a\\ n \\ \end{matrix} \right) =C^n_a=A^n_a/n!= { {a(a-1)...(a-n+1)} \over n!} ={a! \over n!(a-n)!}\end{align*}<hr><h5 id="伯努利试验-二项分布">伯努利试验,二项分布</h5><p>设试验E只有两种可能结果:A及非A,则称E为伯努利试验，设P(A)=p (0&lt;p&lt;1),此时P(非A)=1-p.将E独立重复地进行N次，则称这一串重复的独立试验为n重伯努利试验。</p><p>标记为<br>X〜b(n,p).</p>\begin{align*}P\{X = k\}=\left( \begin{matrix} n\\ k \\ \end{matrix} \right) p^k q^{n-k}\end{align*}<p>当n=1时，化为二项分布：</p>\begin{align*}P\{X = k\}= p^k q^{1-k}\end{align*}\begin{align*}\sum_{k=0}^n P\{X = k\}=\sum_{k=0}^n {\left( \begin{matrix} n\\ k \\ \end{matrix} \right) } p^k q^{n-k} =(p+q)^n=1\end{align*}<hr><h5 id="泊松分布">泊松分布</h5><p>设随机变量X所有可能取的值为0,1,2,…,2而取各个值的概率为</p>\begin{align*}P\{X=k\}={λ^ke^{-λ} \over {k!}} ,k=0,1,2,...,\end{align*}<p>其中λ&gt;0是常数.则称X服从参数为λ的泊松分布，记为X〜π(λ).</p><p>易知,P{X=k}≥0,k=0,1,2,…,且有</p>\begin{align*}\sum_{k=0}^\infty P\{X = k\}=\sum_{k=0}^\infty {λ^ke^{-λ} \over {k!}}=e^{-λ}\sum_{k=0}^\infty {λ^k\over {k!}}=e^{-λ}e^λ=1\end{align*}<p>倒数第二步是<strong>泰勒级数</strong>(见附表)</p><p><strong>泊松定理</strong>  设λ&gt;0是一个常数,n是任意正整数,设np=λ,则对于任一固定的非负整数k，有</p>\begin{align*}\lim_{n \to \infty} \binom{n}{k} p_n^k (1-p_n)^{n-k} = \frac{\color{red}\lambda^k \color{purple}e^{-\lambda}}{\color{red}k!}.\end{align*}<p><strong>证</strong> 由</p>\begin{align*}p_n= {λ \over n}\end{align*}<p>,有</p>\begin{align*}{\left( \begin{matrix} n\\ k \\ \end{matrix} \right)}p^k_n(1-p_n)^{n-k}&={\color{blue}{n(n-1)(n-2)...(n-k+1)} \over {\color{red}k!}}{({\color{red}{λ} \over \color{blue}n})^k}{(1-{λ \over n})^{n-k}} \\&={\color{red}{λ^k \over k!}}{[\color{blue}1 \cdot ({1-{1 \over n})}\cdot ({1-{2 \over n})...(1-{(k+1) \over n})}}]{\color{purple}(1-{λ \over n})^{n}}{(1-{λ \over n})^{-k}}\end{align*}<p>对于任意固定的k,当n→∞,</p>\begin{align*}\lim_{n \to \infty}[1 \cdot ({1-{1 \over n})}\cdot ({1-{2 \over n})...(1-{(k+1) \over n})}]=1, \\\lim_{n \to \infty}(1-{λ \over n})^{n}={\color{purple}e^{-λ}}, \\\lim_{n \to \infty}(1-{λ \over n})^{-k}=1\end{align*}<p>Q.E.D.</p><hr><p><strong>泰勒中值定理</strong> 如果函数f(x)在含有x₀的某个开区间(a,b)内具有直到(n+1)阶的导数，则对任一x∈(a,b),有</p>\begin{align*}f(x)=f(x_0)+f'(x_0)(x-x_0)+{f''(x_0) \over 2!}(x-x_0)^2+...+{f^{(n)}(x_0) \over n!}(x-x_0)^n+R_n(x),\end{align*}<p>其中</p>\begin{align*}R_n(x)={f^{(n+1)}(\xi) \over ({n+1})!} (x-x_0)^{n+1}\end{align*}<p>当</p>\begin{align*}&x_0=0,f(λ)=e^λ \\&f(λ)=e^λ \\&= e^0+{(e^0)(λ-0) \over {1!}}+{(e^0)(λ-0)^2 \over {2!}}+{(e^0)(λ-0)^3 \over {3!}}+...+{(e^0)(λ-0)^k \over {k!}} \\&= \sum_{k=0}^\infty {λ^k\over {k!}}\end{align*}]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.偏导数(拉普拉斯方程)</title>
      <link href="/2019/10/28/%E6%95%B0%E5%AD%A6/11-%E5%81%8F%E5%AF%BC%E6%95%B0-%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E6%96%B9%E7%A8%8B/"/>
      <url>/2019/10/28/%E6%95%B0%E5%AD%A6/11-%E5%81%8F%E5%AF%BC%E6%95%B0-%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E6%96%B9%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>拉普拉斯方程：<br>验证函数</p>\begin{align*}z=ln \sqrt{x^2+y^2}\end{align*}<p>满足方程</p>\begin{align*}{\partial^2{z} \over \partial{x^2}}+{\partial^2{z} \over \partial{y^2}}=0\end{align*}<p>证:因为</p>\begin{align*}z=ln \sqrt{x^2+y^2} =1/2 ln(x^2+y^2)\end{align*}<p>所以</p>\begin{align*}{\partial{z} \over \partial{x}}={x \over(x^2+y^2)}\end{align*}\begin{align*}{\partial^2{z} \over \partial{x^2}}={(x^2+y^2)-2x \cdot x \over(x^2+y^2)^2}={y^2-x^2 \over(x^2+y^2)^2}\end{align*}\begin{align*}{\partial{z} \over \partial{y}}={y \over(x^2+y^2)}\end{align*}\begin{align*}{\partial^2{z} \over \partial{y^2}}={(x^2+y^2)-2y \cdot y \over(x^2+y^2)^2}={x^2-y^2 \over(x^2+y^2)^2}\end{align*}<p>Q.E.D.</p><hr><p>验证函数</p>\begin{align*}u={1 \over r}\end{align*}<p>满足方程</p>\begin{align*}{\partial^2{u} \over \partial{x^2}}+{\partial^2{u} \over \partial{y^2}}+{\partial^2{u} \over \partial{z^2}}=0\end{align*}<p>其中</p>\begin{align*}r =\sqrt{x^2+y^2+z^2}\end{align*}<p>证：</p>\begin{align*}{\partial{u} \over \partial{x}}={-1 \over r^2} \cdot {1 \over {2r}}  \cdot 2x=-{x \over r^3}\end{align*}\begin{align*}{\partial^2{u} \over \partial{x^2}}=-{1 \over r^3}+ {3 \over r^4}x \cdot {1 \over {2r}}  \cdot 2x=-{1 \over r^3}+{3x^2 \over r^5}\end{align*}<p>同理</p>\begin{align*}{\partial^2{u} \over \partial{y^2}}=-{1 \over r^3}+ {3 \over r^4}y \cdot {1 \over {2r}}  \cdot 2y=-{1 \over r^3}+{3y^2 \over r^5}\end{align*}\begin{align*}{\partial^2{u} \over \partial{z^2}}=-{1 \over r^3}+ {3 \over r^4}z \cdot {1 \over {2r}}  \cdot 2z=-{1 \over r^3}+{3z^2 \over r^5}\end{align*}<p>于是</p>\begin{align*}{\partial^2{u} \over \partial{x^2}}+{\partial^2{u} \over \partial{y^2}}+{\partial^2{u} \over \partial{z^2}}={-3 \over r^3}+{(3x^2+3y^2+3z^2) \over r^5}=0\end{align*}]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.向量基本概念</title>
      <link href="/2019/10/28/%E6%95%B0%E5%AD%A6/10-%E5%90%91%E9%87%8F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/10/28/%E6%95%B0%E5%AD%A6/10-%E5%90%91%E9%87%8F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h4 id="一-向量的线性运算">一,向量的线性运算</h4><hr><p>1,向量的加减法</p><p>(1)交换律 a+b=B+a;</p><p>(2)结合律 (a+b)+c=a+(b+c);</p><hr><p>2,向量与数的乘法</p><p>(1)结合律</p>\begin{align*}\lambda (\mu \vec{a}) =\lambda (\mu \vec{a})= (\lambda \mu) \vec{a}\end{align*}<p>(2)分配律</p>\begin{align*}(\lambda + \mu)\vec{a} =\lambda \vec{a} + \mu \vec{a} \\\lambda (\vec{a}+\vec{b}) =\lambda \vec{a} + \lambda \vec{b}\end{align*}<p><strong>定理1 设向量a ≠ 0,那么，向量b平行于a的充分必要条件是:存在唯一的实数λ，使b=λa</strong></p><hr><h4 id="向量的模，方向角，投影">向量的模，方向角，投影</h4><p>向量模的坐标式</p>\begin{align*}|\vec{AB}|=\sqrt{x^2+y^2+z^2}\end{align*}<p>A，B两点间距离就是向量AB的模。</p>\begin{align*}|\vec{AB}|=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}\end{align*}<p>方向角和方向余弦</p><p>设有两个非零向量a,b,任取空间一点O，<br>（P298）</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.Γ函数(gamma函数)</title>
      <link href="/2019/10/27/%E6%95%B0%E5%AD%A6/9-%CE%93%E5%87%BD%E6%95%B0-gamma%E5%87%BD%E6%95%B0/"/>
      <url>/2019/10/27/%E6%95%B0%E5%AD%A6/9-%CE%93%E5%87%BD%E6%95%B0-gamma%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>Γ函数：</p>\begin{align*}\Gamma (s)= \int_0^{+ \infty} e^{-x} x^{(s-1)}dx \ .(s>0)\end{align*}<p>分别讨论以下两个积分:</p>\begin{align*}I_1= \int_0^1 e^{-x} x^{(s-1)}dx \ .(s>0)\end{align*}\begin{align*}I_2= \int_1^{+ \infty} e^{-x} x^{(s-1)}dx \ .(s>0)\end{align*}<p>当s≥1时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">I_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07847em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 是定积分（s看作定值），当0&lt;s&lt;1时，因为</p>\begin{align*}e^{-x} \cdot x^{s-1} ={1 \over x^{1-s}} \cdot {1 \over e^x} < {1 \over x^{1-s}}\end{align*}<p>根据比较审敛法2，反常积分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">I_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07847em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>收敛。</p><p>再讨论<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">I_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07847em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,因为</p>\begin{align*}\lim_{x \to + \infty} x^2 \cdot (e^{-x}x^{s-1})= \lim_{x \to + \infty} {x^{s+1} \over e^x}=0\end{align*}<p>根据比较审敛法1，反常积分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">I_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07847em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>收敛。<br>(最后一步洛必达法则)</p><hr><p>Γ函数四个性质:</p><p>1.递推公式</p>\begin{align*}\Gamma (s+1) = s \Gamma (s) (s>0)\end{align*}<p>证: 应用分部积分法,有</p>\begin{align*}\Gamma (s+1) &= \int_0^{+ \infty} e^{-x} x^s dx \\&= - \int_0^{+ \infty} x^s de^{-x} \\&= -([x^se^{-x}]_0^{+ \infty } -s \int_0^{+ \infty} e^{-x}x^{s-1}dx ) \\&= 0 + s \int_0^{+ \infty} e^{-x}x^{s-1}dx \\&= s \Gamma (s) \end{align*}<p>其中</p>\begin{align*}\lim_{x \to + \infty  } x^se^{-x} =0\end{align*}<p>可由洛必达法则求得。<br>显然:</p>\begin{align*}\Gamma (1) &=\int_0^{+ \infty} e^{-x}x^{s-1}dx \\&=\int_0^{+ \infty} e^{-x}dx \\ &=[-e^{-x}]^{+ \infty}_0 \\&=0-(-1) \\&=1\end{align*}<p>反复运用递推公式有:<br>对于任意的正整数</p>\begin{align*}\Gamma (n+1)=n!\end{align*}<p>所以Gamma函数可以看作阶乘的推广</p><p>2.当</p>\begin{align*}s \to 0^+\end{align*}<p>时,</p>\begin{align*}\Gamma (s) ={\Gamma (s+1) \over s},\Gamma (1)=1\end{align*}<p>,所以当</p>\begin{align*}s \to 0^+,\Gamma (s) \to + {\infty}\end{align*}<ol start="3"><li></li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow><mi mathvariant="normal">Γ</mi><mo>(</mo><mi>s</mi><mo>)</mo><mi mathvariant="normal">Γ</mi><mo>(</mo><mi>s</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>=</mo><mrow><mfrac><mrow><mi>π</mi></mrow><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mi>π</mi><mi>s</mi></mrow></mfrac></mrow><mtext> </mtext><mo>(</mo><mn>0</mn><mo>&lt;</mo><mi>s</mi><mo>&lt;</mo><mn>1</mn><mo>)</mo></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned}\Gamma (s) \Gamma (s-1) ={\pi \over sin \pi s} \ (0&lt;s&lt;1)\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.1467800000000001em;"></span><span class="strut bottom" style="height:1.7935600000000003em;vertical-align:-0.64678em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:-0.03922000000000003em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord mathrm">Γ</span><span class="mopen">(</span><span class="mord mathit">s</span><span class="mclose">)</span><span class="mord mathrm">Γ</span><span class="mopen">(</span><span class="mord mathit">s</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord displaystyle textstyle uncramped"><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">π</span><span class="mord mathit">s</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">π</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span><span class="mord mspace"> </span><span class="mopen">(</span><span class="mord mathrm">0</span><span class="mrel">&lt;</span><span class="mord mathit">s</span><span class="mrel">&lt;</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></span></p><p>4.在</p>\begin{align*}\Gamma (s)  = \int_0^{+ \infty} e^{-x} x^{(s-1)}dx\end{align*}<p>作代换</p>\begin{align*}x=u^2\end{align*}<p>,<br>有</p>\begin{align*}\Gamma (s) =  \int_0^{+ \infty} e^{-u^2} u^{2(s-1)}2udu = 2 \int_0^{+ \infty} e^{-u^2} u^{2s-1}du\end{align*}<p>再令2s-1=t有:</p>\begin{align*}\int_0^{+ \infty} e^{-u^2} u^{2s-1}du = \int_0^{+ \infty} e^{-u^2} u^tdu =\Gamma ({t+1 \over 2}) . (t>-1) \end{align*}<p>上式<br>令t=0,则s=1/2,得</p>\begin{align*}2 \int_0^{+ \infty} e^{-u^2}du =\Gamma({1 \over 2})=\sqrt{\pi}\end{align*}<p>以上即为高斯积分</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.反常积分</title>
      <link href="/2019/10/26/%E6%95%B0%E5%AD%A6/8-%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/"/>
      <url>/2019/10/26/%E6%95%B0%E5%AD%A6/8-%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h5 id="反常积分">反常积分</h5><p><strong>定义1 设函数f(x)在区间[a,+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>)上连续，取t&gt;a，如果极限</strong></p>\begin{align*}\lim_{t \to +\infty} \int_a^tf(x)dx\end{align*}<p><strong>存在，则称此极限为函数f(x)在无穷区间[a,+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>)上的反常积分,记作</strong></p>\begin{align*}\int_a^{+\infty}f(x)dx\end{align*}<p>此时称反常积分收敛。<br>-无穷大同理，两个无穷大都收敛，则称无穷限的反常积分。</p><p>例: 计算反常积分</p>\begin{align*}\int_0^{+\infty}te^{-pt}dt\end{align*}<p>(p是常数，p&gt;0)</p><p>解:</p>\begin{align*}\int_0^{+\infty}te^{-pt}dt &= [\int te^{-pt}dt]_0^{+\infty} \\&= [-1/p\int tde^{e^{-pt}}]_0^{+\infty} \\&= [-1/p(te^{-pt}-\int e^{-pt}dt)]^{+\infty}_0 \\&= [-1/p(te^{-pt}+1/pe^{-pt})]_0^{+\infty} \\&= [-1/pte^{-pt}]_0^{+\infty}-[1/p^2e^{-pt}]_0^{+\infty} \\&= -1/p \lim_{t \to +\infty}te^{-pt}-0-1/p^2(\lim_{t \to +\infty} e^{-pt}-1) \\&=1/p^2\end{align*}<hr>\begin{align*}&\because de^{-pt}/dt=-pe^{-pt} \\&\therefore dt= {de^{-pt} \over {-pe^{-pt}}}, e^{-pt}dt = {de^{-pt} \over {-p}}\end{align*}\begin{align*}(uv)'=u'v+v'u\end{align*}<hr><p><strong>定义2 设函数f(x)在区间(a,b]上连续，点a为f(x)的瑕点,取t&gt;a，如果极限</strong></p>\begin{align*}\lim_{t \to a^+} \int_t^bf(x)dx\end{align*}<p><strong>存在，则称此极限为函数f(x)在无穷区间(a,b]上的反常积分,记作</strong></p>\begin{align*}\int_a^bf(x)dx\end{align*}<p>此时称反常积分收敛。-a同理。</p><hr><h5 id="反常积分的审敛法">反常积分的审敛法</h5><p><strong>定理1 设函数f(x)在区间[a,+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>)上连续,且f(x)≥0,若函数</strong></p>\begin{align*}F(x)=\int_a^xf(t)dt\end{align*}<p>在[a,+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>]上有界，则反常积分</p>\begin{align*}\int_a^{+\infty} f(t)dt\end{align*}<p>收敛</p><hr><p><strong>定理2(比较审敛原理) 设函数f(x),g(x)在区间[a,+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>)上连续,如果0≤f(x)≤g(x)(a≤x≤+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>),并且</strong></p>\begin{align*}\int_a^{+\infty} g(x)dx\end{align*}<p><strong>收敛，则</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx\end{align*}<p><strong>也收敛;如果0≤g(x)≤f(x)(a≤x≤+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>)，并且</strong></p>\begin{align*}\int_a^{+\infty} g(x)dx\end{align*}<p><strong>发散，则</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx\end{align*}<p><strong>也发散.</strong></p><hr><p><strong>定理3(比较审敛法1) 设函数f(x)在区间[a,+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>)上连续,且f(x)≥0,如果存在常数M&gt;0及p&gt;1,使得</strong></p>\begin{align*}f(x) \le {M \over x^p} (a \le x< + \infty )\end{align*}<p><strong>则反常积分</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx\end{align*}<p><strong>收敛;如果存在常数N&gt;0,使得</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>≥</mo><mrow><mfrac><mrow><mi>N</mi></mrow><mrow><mi>x</mi></mrow></mfrac></mrow><mo>(</mo><mi>a</mi><mo>≤</mo><mi>x</mi><mo>&lt;</mo><mo>+</mo><mi mathvariant="normal">∞</mi><mo>)</mo></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned}f(x) \ge {N \over x} (a \le x&lt; + \infty )\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.273165em;"></span><span class="strut bottom" style="height:2.04633em;vertical-align:-0.773165em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:0.08716499999999994em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mrel">≥</span><span class="mord displaystyle textstyle uncramped"><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit">x</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mrel">≤</span><span class="mord mathit">x</span><span class="mrel">&lt;</span><span class="mord">+</span><span class="mord mathrm">∞</span><span class="mclose">)</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></span></p><p><strong>则反常积分</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx\end{align*}<p><strong>发散.</strong></p><hr><p><strong>定理4(极限审敛法1) 设函数f(x)在区间[a,+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>)上连续,且f(x)≥0,如果存在常数p&gt;1,使得</strong></p>\begin{align*}\lim_{x \to + \infty }x^pf(x)\end{align*}<p><strong>存在,则反常积分</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx\end{align*}<p><strong>收敛;如果</strong></p>\begin{align*}\lim_{x \to + \infty }xf(x)=d>0\end{align*}<p><strong>或</strong></p>\begin{align*}\lim_{x \to + \infty }xf(x)=+ \infty\end{align*}<p><strong>,则反常积分</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx\end{align*}<p><strong>发散</strong></p><hr><p><strong>定理5 设函数f(x)在区间[a,+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>)上连续,如果反常积分</strong></p>\begin{align*}\int_a^{+\infty} |f(x)|dx\end{align*}<p><strong>收敛，则反常积分</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx\end{align*}<p><strong>收敛.</strong></p><hr><p><strong>定理6(比较审敛法2) 设函数f(x)在区间(a,b]上连续,且f(x)≥0，x=a为f(x)的瑕玷.如果存在常数M&gt;0及q&lt;1,使得</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx \le {M \over (x-a)^q} (a < x \le b),\end{align*}<p><strong>则反常积分</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx\end{align*}<p><strong>收敛.</strong></p><p><strong>如果存在常数N&gt;0,使得</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx \ge {N \over (x-a)} (a < x \le b),\end{align*}<p><strong>则反常积分</strong></p>\begin{align*}\int_a^{+\infty} f(x)dx\end{align*}<p><strong>发散.</strong></p><hr><p><strong>定理7(极限审敛法2) 设函数f(x)在区间(a,b]上连续,且f(x)≥0,x=a为f(x)的瑕点如果存在常数0&lt;q&lt;1,使得</strong></p>\begin{align*}\lim_{x \to a^+ }(x - a )^qf(x)\end{align*}<p><strong>存在,则反常积分</strong></p>\begin{align*}\int_a^b f(x)dx\end{align*}<p><strong>收敛;如果</strong></p>\begin{align*}\lim_{x \to + a^+ }(x-a)f(x)=d>0\end{align*}<p><strong>或</strong></p>\begin{align*}\lim_{x \to + a^+ }(x-a)f(x)=+ \infty\end{align*}<p><strong>,则反常积分</strong></p>\begin{align*}\int_a^b f(x)dx\end{align*}<p><strong>发散</strong></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.定积分</title>
      <link href="/2019/10/24/%E6%95%B0%E5%AD%A6/7-%E5%AE%9A%E7%A7%AF%E5%88%86/"/>
      <url>/2019/10/24/%E6%95%B0%E5%AD%A6/7-%E5%AE%9A%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p><strong>定义</strong> 设函数f(x)在[a,b]上有界，在[a,b]中任意插入若干个分点</p>\begin{align*}a={x_0}<{x_1}<{x_2}<...<{x_{n-1}}<{x_n}=b\end{align*}<p>把区间[a,b]分成n个小区间</p>\begin{align*}[x_0,x_1],[x_1,x_2],...,[x_{n-1},x_n],\end{align*}<p>各个小区间的长度依次为</p>\begin{align*}\Delta x_1 = x_1-x_0,\Delta x_2 = x_2-x_1,...,\Delta x_n = x_n-x_{n-1},\end{align*}<p>在每个小区间</p>\begin{align*}[x_n,x_{n-1}],\end{align*}<p>上任取一点ξ(ξ∈[xi-1,xi],作函数f(ξ)与小区间长度Δxi的乘积f(ξ)Δxi(i),并作出和</p>\begin{align*}S= \sum_{i=1}f(\xi_i) \Delta x_i\end{align*}<hr><h5 id="定积分基本性质">定积分基本性质</h5><p>(1)当a=b时,</p>\begin{align*}\int^b_a f(x)dx=0\end{align*}<p>(2)当a&gt;b时,</p>\begin{align*}\int^b_a f(x)dx= - \int^a_b f(x)dx\end{align*}<p><strong>性质1</strong></p>\begin{align*}\int^b_a [f(x) \pm g(x)]dx = \int^b_a f(x) \pm \int^b_a  g(x)dx \end{align*}<p><strong>性质2</strong></p>\begin{align*}\int^b_a kf(x)dx = k \int^b_a f(x)dx \end{align*}<p><strong>性质3</strong></p><p>设a&lt;c&lt;b,则</p>\begin{align*}\int^b_a f(x)dx = \int^c_a f(x)dx + \int^b_c f(x)dx \end{align*}<p><strong>性质4</strong></p><p>如果在区间[a,b]上f(x)≡1，则</p>\begin{align*}\int^b_a 1dx = \int^b_a dx=b-a\end{align*}<p><strong>性质5</strong></p><p>如果在区间[a,b]上f(x)≥0，则</p>\begin{align*}\int^b_a f(x)dx \ge 0 (a < b)\end{align*}<hr><h5 id="积分上限函数及其导数">积分上限函数及其导数</h5><p>设函数f(t)在区间[a,b]上连续，并且设x为[a,b]上的一点。在[a,b]定义一个函数，记作</p>\begin{align*}\Phi (x)= \int^x_a f(t)dt (a \le x \le b )\end{align*}<p><strong>定理1 如果函数f(x)在区间[a,b]上连续，则积分上限的函数</strong></p>\begin{align*}\Phi (x)= \int^x_a f(t)dt\end{align*}<p>在[a,b]上可导,并且它的导数是</p>\begin{align*}\Phi' (x)={d \over dx} \int^x_a f(t)dt=f(x)(a \le x \le b )\end{align*}<p><strong>证</strong> 若x∈(a,b),设x获得增量Δx,其绝对值足够地小，使得x+Δx∈(a,b),<br>则Φ（x）在x+Δx∈处的函数值为</p>\begin{align*}\Phi (x+\Delta x)=\int^{x+\Delta x}_a f(t)dt\end{align*}<p>由此得函数的增量为</p>\begin{align*}\Phi (x+\Delta x)-\Phi (x) &= \int^{x+\Delta x}_a f(t)dt - \int^{x}_a f(t)dt \\ &= \int^x_a f(t)dt+\int^{x+\Delta x}_x f(t)dt - \int^{x}_a f(t)dt \\ &= \int^{x+\Delta x}_x f(t)dt\end{align*}<p>应用积分中值定理有等式<br>ΔΦ(x)=f(ξ)Δx<br>即：</p>\begin{align*}{ΔΦ(x) \over Δx}=f(ξ)\end{align*}<p>由于f(x)在[a,b]上连续，当Δx→0，ξ→x,因此</p>\begin{align*}\lim_{\Delta x\to 0}f(ξ)=f(x)\end{align*}<p>两端取极限即可。</p><p><strong>定理2 如果函数f(x)在区间[a,b]上连续，则函数</strong></p>\begin{align*}\Phi (x)= \int^x_a f(t)dt\end{align*}<p><strong>就是f(x)在[a,b]上的一个原函数</strong></p><hr><h5 id="牛顿-莱布尼茨公式">牛顿-莱布尼茨公式</h5><p><strong>定理3 如果函数F(x)是连续函数f(x)在区间[a,b]上的一个原函数，则</strong></p>\begin{align*}\int^b_a f(x)dx=F(b)-F(a). \  \  (1)\end{align*}<p>证 已知函数F(x)是连续函数f(x)的一个原函数，又根据定理2知道，积分上限函数</p>\begin{align*}\Phi (x)= \int^x_a f(t)dt  \  \  (2)\end{align*}<p>也是f(x)的一个原函数.于是这两个原函数之差F(x)-Φ(x)在[a,b]上必定是一个常数C，即<br>差</p><p>F(x)-Φ(x)=C (a≤x≤b)   (3)</p><p>令x=a.得F(a)-Φ(a)=C,由定理2，得Φ(a)=0，因此F(a)=C,代入式(1),F(a)代入式(3)得</p>\begin{align*}F(x)- \int^x_a f(t)dt =F(a) \\\therefore \int^x_a f(t)dt =F(x)-F(a)\end{align*}<p>将x=b代入，即式（1）</p><p>也记为</p>\begin{align*}\therefore \int^b_a f(x)dx =[F(x)]_a^b\end{align*}]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.不定积分</title>
      <link href="/2019/10/24/%E6%95%B0%E5%AD%A6/6-%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/"/>
      <url>/2019/10/24/%E6%95%B0%E5%AD%A6/6-%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h5 id="基本积分表">基本积分表</h5>\begin{align*}1. &\int kdx = kx +C \\2. &\int x^n dx = {x^{n+1} \over {\mu +1}} +C \ (\mu \neq -1) \\3. &\int {dx \over x} = ln|x| +C \\4. &\int {dx \over {1+x^2}} = arctan x +C \\5. &\int {dx \over \sqrt {1+x^2}} = arcsin x +C \\6. &\int cosx \ dx = sin \ x + C \\7. &\int sinx \ dx = -cos \ x +C \\8. &\int {dx \over cos^2 x} = \int sec^2 x dx=tan x + C \\9. &\int {dx \over sin^2 x} = \int sec^2 x dx=-cot x + C \\10. &\int sec x \ tanx \ dx = sec x + C \\11. &\int csc x \ cot x \ dx = -csc x +C \\12. &\int e^x dx =e^x + C \\13. &\int a^x dx = {a^x \over ln \ a} + C \\14. &\int sh \ x \ dx = ch \ x + C \\15. &\int ch \ x \ dx = sh \ x + C\end{align*}<hr><h5 id="不定积分的性质">不定积分的性质:</h5><p><strong>性质1</strong> 设函数 f(x)及g(x)的原函数存在，则</p>\begin{align*}\int [f(x)+g(x)]dx = \int f(x)dx + \int g(x)dx\end{align*}<p><strong>性质2</strong> 设函数 f(x)及g(x)的原函数存在，则</p>\begin{align*}\int kf(x)dx = k \int f(x)dx \end{align*}<hr><h5 id="换元积分法">换元积分法</h5><p><strong>1，第一类换元积分法</strong></p><p><strong>定理1</strong> 设f(u)具有原函数，u=ψ(x)可导,则有换元公式</p>\begin{align*}\int f[ \psi(x)]\psi '(x)dx =[\int f(u)du]_{u=\psi(x)}\end{align*}<p><strong>2，第二类换元积分法</strong></p><p><strong>定理2</strong> 设x=ψ(t) 是单调的，可导的函数,并且ψ’(t)≠0.又设f[ψ(t)]ψ’(t)具有原函数,则有换元公式</p>\begin{align*}\int f(x)dx = [ \int  f[ \psi (t)] \psi ' (t)dt]_{t=\psi ^{-1} (x)}\end{align*}<p>其中</p>\begin{align*}\psi ^{-1} (x)\end{align*}<p>是x=ψ(t)的反函数.</p><p><strong>证</strong> 设f[ψ(t)]ψ’(t)的原函数为Ψ(t),记</p>\begin{align*}Ψ[ψ^{-1}(x)] = F(x)\end{align*}<p>，利用复合函数及反函数的求导法则，得到</p>\begin{align*}F'(x) = {\color{red}{d \Psi \over dt}} \cdot {\color{blue}{dt \over dx}} = {\color{red}f[ \psi(t) ] \psi'(t)} \cdot {\color{blue}{1 \over \psi'(t)}} = f[\psi (t)]=f(x)\end{align*}<hr><h5 id="分部积分法">分部积分法</h5>\begin{align*}\int u dv = uv - \int v du\end{align*}]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.微分中值定理</title>
      <link href="/2019/10/13/%E6%95%B0%E5%AD%A6/5-%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/"/>
      <url>/2019/10/13/%E6%95%B0%E5%AD%A6/5-%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="费马定理">费马定理</h4>\begin{align*}{设函数}f(x) {在点} x_0 {的某邻域} U(x_0) {内有定义，且在} x_0 {处可导。若对任意} x \in U(x_0)\end{align*}<p>有：</p>\begin{align*}f(x) \leq f(x_0) \quad \text{（或} \ f(x) \geq f(x_0)\text{）}\end{align*}<p>则：</p>\begin{align*}f'(x_0) = 0\end{align*}<p><strong>证明</strong>：<br>对于</p>\begin{align*}x_0 + \Delta x \in U(x_0)，\end{align*}<p>有</p>\begin{align*}f(x_0 + \Delta x) \leq f(x_0) \\\end{align*}<p>当 $$\Delta x &gt; 0$$ 时：</p>\begin{align*}\frac{f(x_0 + \Delta x) - f(x_0)}{\Delta x} \leq 0 \quad \text{（右导数非正）}\end{align*}<p>当 $$\Delta x &lt; 0$$ 时：</p>\begin{align*}\frac{f(x_0 + \Delta x) - f(x_0)}{\Delta x} \geq 0 \quad \text{（左导数非负）}\end{align*}<p>由可导性知左右导数相等，故 $$f’(x_0) = 0$$。</p><hr><h4 id="罗尔定理">罗尔定理</h4><p>若函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span> 满足：</p><ol><li>在闭区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">]</span></span></span></span> 上连续；</li><li>在开区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span></span></span></span> 内可导；</li><li>在区间端点处的函数值相等，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(a) = f(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">b</span><span class="mclose">)</span></span></span></span>，</li></ol><p>则在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span></span></span></span> 内至少存在一点 \xi{(a < ξ < b)} 使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup><mo>(</mo><mi>ξ</mi><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f&#x27;(\xi) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.04601em;">ξ</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span></span>。</p><hr><h4 id="拉格朗日中值定理">拉格朗日中值定理</h4><p>如果函数f(x)满足</p><p>(1)在闭区间[a,b]上连续;</p><p>(2)在开区间(a,b)内可导;</p><p>那么在(a,b)内至少有一点ξ(a&lt;ξ&lt;b) 使等式</p>\begin{align*}f(b)-f(a)=f'(\xi)(b-a)\end{align*}<p>成立</p><hr><p><strong>证:</strong></p><ol><li>构造辅助函数ψ(x)，等于f(x)曲线跟直线AB之间的垂直距离:</li></ol><p>有</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ψ</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>=</mo><mi>ψ</mi><mo>(</mo><mi>b</mi><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\psi(a)=\psi(b)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span></span></span></p><p>设直线AB的方程为y=L(x),则</p>\begin{align*}L(x) = f(a)+\frac{f(b)-f(a)}{b-a}(x-a)\end{align*}<p>由于M,N的纵坐标为f(x)及L(x)，有:</p>\begin{align*}\psi(x)=f(x)-L(x)=f(x)-\left[f(a)+\frac{f(b)-f(a)}{b-a}(x-a)\right] \quad (1)\end{align*}<ol start="2"><li>验证罗尔定理条件:</li></ol><ul><li>ψ(x)在[a,b]上连续</li><li>ψ(x)在(a,b)内可导</li><li>ψ(a)=ψ(b)=0</li></ul><p>对(1)式求导:</p>\begin{align*}\psi'(x)=f'(x)-\frac{f(b)-f(a)}{b-a}\end{align*}<ol start="3"><li>应用罗尔定理:<br>在(a,b)内至少存在一点ξ(a&lt;ξ&lt;b)使得ψ’(ξ)=0,即:</li></ol>\begin{align*}f'(\xi)-\frac{f(b)-f(a)}{b-a}=0\end{align*}<p>从而得到:</p>\begin{align*}f(b)-f(a)=f'(\xi)(b-a) \quad (2)\end{align*}<ol start="4"><li>推论:<br>如果函数f(x)在区间I上的导数恒为0，那么f(x)在区间I上是一个常数。</li></ol><p>证明:<br>由(2)式，当$ f’(ξ)=0 $时，有f(b)-f(a)=0，即f(b)=f(a)。由于a,b是I上任意两点，故f(x)在I上为常数。</p><hr><p><strong>注:</strong></p><ol><li>式(2)表明存在点ξ处的切线斜率等于弦AB的斜率</li><li>辅助函数ψ(x)的构造是关键，它表示曲线与弦的垂直距离</li><li>当f(a)=f(b)时，即为罗尔定理的特殊情形</li></ol><hr><h4 id="柯西中值定理">柯西中值定理</h4><p>若函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">F(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span> 满足：</p><ol><li>在闭区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">]</span></span></span></span> 上连续；</li><li>在开区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span></span></span></span> 内可导；</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo>∈</mo><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo separator="true">,</mo><msup><mi>F</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup><mo>(</mo><mi>x</mi><mo>)</mo><mo>≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\forall x \in (a,b), F&#x27;(x) \neq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∀</span><span class="mord mathit">x</span><span class="mrel">∈</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mrel">≠</span><span class="mord mathrm">0</span></span></span></span>，</li></ol><p>则在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span></span></span></span> 内至少存在一点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ξ</mi></mrow><annotation encoding="application/x-tex">\xi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.04601em;">ξ</span></span></span></span> 使得：</p>\begin{align*}\frac{f(b)-f(a)}{F(b)-F(a)} = \frac{f'(\xi)}{F'(\xi)} \quad \text{（两函数变化率之比相等）}\end{align*}<p><strong>证:</strong><br>f(x),F(x)应用(2)式，上下一除即可</p><hr><h4 id="洛必达法则">洛必达法则</h4><p><strong>定理1</strong>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">x \to a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">→</span><span class="mord mathit">a</span></span></span></span> 型）：<br>若：</p>\begin{align*}&1. \lim\limits_{x \to a} f(x) = \lim\limits_{x \to a} F(x) = 0 ； \\&2. 在 a 的去心邻域内 f'(x), F'(x) 存在且 F'(x) \neq 0； \\&3. \lim\limits_{x \to a} \frac{f'(x)}{F'(x)} 存在（或为无穷大）， \\\end{align*}<p>则：</p>\begin{align*}\lim_{x \to a} \frac{f(x)}{F(x)} = \lim_{x \to a} \frac{f'(x)}{F'(x)}\end{align*}<p><strong>定理2</strong>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">x \to \infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">→</span><span class="mord mathrm">∞</span></span></span></span> 型）：<br>将定理1中的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">x \to a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">→</span><span class="mord mathit">a</span></span></span></span> 改为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">x \to \infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">→</span><span class="mord mathrm">∞</span></span></span></span>，条件类似。</p><hr><h4 id="重要极限例子">重要极限例子</h4><ol><li>对数函数与幂函数：</li></ol>\begin{align*}\lim_{x \to \infty} \frac{\ln x}{x^n} &= \lim_{x \to \infty} {f'(x) \over F'(x)} \\&= \lim_{x \to \infty} \frac{1/x}{n x^{n-1}} \\&= \lim_{x \to \infty} \frac{1}{n x^n} \\&= 0 \quad \text{（对数增长慢于幂函数）}\end{align*}<ol start="2"><li>幂函数与指数函数：</li></ol>\begin{align*}\lim_{x \to \infty} \frac{x^n}{e^{\lambda x}} &= \lim_{x \to \infty} {f'(x) \over F'(x)} \\&= \lim_{x \to \infty} \frac{n x^{n-1}}{\lambda e^{\lambda x}} \\&= \cdots \\&= \lim_{x \to \infty} \frac{n!}{\lambda^n e^{\lambda x}} \\&= 0 \quad \text{（指数增长快于幂函数）}\end{align*}<hr><h4 id="泰勒公式">泰勒公式</h4><p><strong>泰勒中值定理</strong>：</p>\begin{align*} 若 f(x) 在含 x_0 的开区间 (a,b) 内有直到 (n+1) 阶导数，则对任意 x \in (a,b) 有：\end{align*}\begin{align*}f(x) &= f(x_0) + f'(x_0)(x-x_0) + \frac{f''(x_0)}{2!}(x-x_0)^2 + \cdots \\&\quad + \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n + R_n(x)\end{align*}<p>其中余项：</p>\begin{align*}R_n(x) = \frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1} \quad \text{（$\xi$ 在 $x_0$ 与 $x$ 之间）}\end{align*}]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.微分</title>
      <link href="/2019/09/28/%E6%95%B0%E5%AD%A6/4-%E5%BE%AE%E5%88%86/"/>
      <url>/2019/09/28/%E6%95%B0%E5%AD%A6/4-%E5%BE%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h3 id="定义">定义</h3><p><strong>微分的基本概念：</strong></p>\begin{align*}\Delta y &= f(x_0 + \Delta x) - f(x_0) \quad \text{（函数增量）} \\\Delta y &= A \Delta x + o(\Delta x) \quad \text{（线性近似+高阶无穷小）}\end{align*}<p><strong>微分表达式：</strong></p>\begin{align*}dy = y'_x(x)dx = f'(u)g'(x)dx \quad \text{（链式法则微分形式）}\end{align*}<hr><h4 id="复合函数的微分法则">复合函数的微分法则</h4><p><strong>乘法法则的微分形式：</strong></p>\begin{align*}d(uv) &= (uv)'dx \\[5pt]\text{∵}\quad (uv)' &= u'v + v'u \quad \text{（乘积导数法则）} \\[5pt]u'dx &= du \\[5pt]v'dx &= dv \\[5pt]\text{∴}\quad d(uv) &=(u'v+v'u)dx \\&=u'vdx+v'udx \\&= vdu + udv \quad \text{（微分乘积法则）} \\\end{align*}<p><strong>复合函数示例：</strong></p>\begin{align*}y &= \sin(2x+1) \\dy &= d(\sin u) = \cos(2x+1)d(2x+1) \\&= \cos(2x+1) \cdot 2dx = 2\cos(2x+1)dx \text{（先外函数后内函数）}\end{align*}<hr><h4 id="近似计算原理">近似计算原理</h4><p><strong>线性近似公式：</strong></p>\begin{align*}\text{∵} \Delta y=f(x_0 + \Delta x) - f(x_0)&\approx dy = f'(x_0)\Delta x \quad \text{（用切线近似函数）} \\[5pt]\text{∴} f(x_0 + \Delta x) \approx f(x_0) + f'(x_0) \Delta x \\[5pt]for \ x=(x_0 + \Delta x): \\[5pt]f(x) &\approx f(x_0) + f'(x_0)(x-x_0) \quad \text{（泰勒展开一阶项）}\end{align*}<hr><h4 id="常用近似公式（当-x-很小时）：">常用近似公式（当|x|很小时）：</h4><ol><li><p><strong>n次方根：</strong></p>\begin{align*}\sqrt[n]{1+x} \approx f(0) + f'(0)x (x - 0) =1 +(\frac{1}{n})(x)  = 1 + \frac{1}{n}x\end{align*}<p>如 $$\sqrt{1.02} \approx 1.01$$</p></li><li><p><strong>正弦函数：</strong></p>\begin{align*}\sin x \approx f(0) + f'(0)(x - 0) = 0 + \cos(0)x = x\end{align*}<p>小角度时正弦值≈弧度值</p></li><li><p><strong>正切函数：</strong></p>\begin{align*}\tan x &= \frac{\sin x}{\cos x} \\[5pt]\text{∵}\quad \tan'x &= \frac{\cos^2x + \sin^2x}{\cos^2x} = \frac{1}{\cos^2x} = \sec^2x \\[5pt]\text{∴}\quad \tan x &\approx f(0) + f'(0)(x - 0) = 0 + 1 \cdot x = x\end{align*}<p>小角度时正切值≈弧度值</p></li><li><p><strong>指数函数：</strong></p>\begin{align*}e^x \approx f(0) + f'(0)(x - 0) = 1 + x\end{align*}<p>如 $$e^{0.01} \approx 1.01$$</p></li><li><p><strong>对数函数：</strong></p>\begin{align*}\ln(1+x) \approx f(0) + f'(0)(x - 0) = 0 + 1 \cdot x = x\end{align*}<p>如 $$\ln(1.02) \approx 0.02$$</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.莱布尼兹公式</title>
      <link href="/2019/09/28/%E6%95%B0%E5%AD%A6/3-%E8%8E%B1%E5%B8%83%E5%B0%BC%E5%85%B9%E5%85%AC%E5%BC%8F/"/>
      <url>/2019/09/28/%E6%95%B0%E5%AD%A6/3-%E8%8E%B1%E5%B8%83%E5%B0%BC%E5%85%B9%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>对于幂函数：</p>\begin{align*}&y=x^n \\&y' = n x^{n-1} \\&y''=n(n-1)x^{n-2}  \\&...\\&y^{(m)}=n(n-1)...(n-m+1) x^{(n-m)}=n!/m! x^{(n-m)} \\if  \ n=m: \\&y^{(n)}=n!\end{align*}<p>莱布尼兹公式:</p>\begin{align*}(uv)^{(n)} = \sum^n_{k=0}C^k_nu^{(n-k)}v^{(k)}\end{align*}]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.函数的求导法则</title>
      <link href="/2019/09/28/%E6%95%B0%E5%AD%A6/2-%E5%87%BD%E6%95%B0%E7%9A%84%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99/"/>
      <url>/2019/09/28/%E6%95%B0%E5%AD%A6/2-%E5%87%BD%E6%95%B0%E7%9A%84%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99/</url>
      
        <content type="html"><![CDATA[\begin{align*}(1)\ & [u(x) \pm v(x)]' = u'(x) \pm v'(x) \\[10pt](2)\ & [u(x)v(x)]' = u'(x)v(x) + u(x)v'(x) \\[10pt](3)\ & \left[\frac{u(x)}{v(x)}\right]' = \frac{u'(x)v(x) - u(x)v'(x)}{v^2(x)}\end{align*}<h3 id="证明">证明</h3><h4 id="1-加减法则">(1) 加减法则</h4>\begin{align*}[u(x) \pm v(x)]' &= \lim_{\Delta x \to 0} \frac{[u(x + \Delta x) \pm v(x + \Delta x)] - [u(x) \pm v(x)]}{\Delta x} \\&= \lim_{\Delta x \to 0} \frac{[u(x + \Delta x) - u(x)] \pm [v(x + \Delta x) - v(x)]}{\Delta x} \\&= \lim_{\Delta x \to 0} \frac{u(x + \Delta x) - u(x)}{\Delta x} \pm \lim_{\Delta x \to 0} \frac{v(x + \Delta x) - v(x)}{\Delta x} \\&= u'(x) \pm v'(x)\end{align*}<h4 id="2-乘法法则">(2) 乘法法则</h4>\begin{align*}[u(x)v(x)]' &= \lim_{\Delta x \to 0} \frac{u(x + \Delta x)v(x + \Delta x) - u(x)v(x)}{\Delta x} \\&= \lim_{\Delta x \to 0} \left[  \frac{u(x + \Delta x) - u(x)}{\Delta x} \cdot v(x + \Delta x)   + u(x) \cdot \frac{v(x + \Delta x) - v(x)}{\Delta x}\right] \\&= u'(x)v(x) + u(x)v'(x)\end{align*}<h4 id="3-除法法则">(3) 除法法则</h4>\begin{align*}\left[\frac{u(x)}{v(x)}\right]' &= \lim_{\Delta x \to 0} \frac{\frac{u(x + \Delta x)}{v(x + \Delta x)} - \frac{u(x)}{v(x)}}{\Delta x} \\&= \lim_{\Delta x \to 0} \frac{u(x + \Delta x)v(x) - u(x)v(x + \Delta x)}{\Delta x \cdot v(x)v(x + \Delta x)} \\&= \lim_{\Delta x \to 0} \frac{  \frac{[u(x + \Delta x) - u(x)]v(x)}{\Delta x}   - \frac{u(x)[v(x + \Delta x) - v(x)]}{\Delta x}}{v(x)v(x + \Delta x)} \\&= \frac{u'(x)v(x) - u(x)v'(x)}{v^2(x)}\end{align*}<hr><h3 id="反函数的导数">反函数的导数</h3>\begin{align*}[f^{-1}(x)]' = \lim_{\Delta x \to 0} \frac{\Delta y}{\Delta x} = \lim_{\Delta y \to 0} \frac{1}{\frac{\Delta x}{\Delta y}} = \frac{1}{f'(y)}\end{align*}<hr><h3 id="复合函数导数">复合函数导数</h3>\begin{align*}y &= f(u) \\u &= g(x) \\y &= f[g(x)] \\[10pt]\frac{dy}{dx} &= f'(u) \cdot g'(x) = \frac{dy}{du} \cdot \frac{du}{dx}\end{align*}<hr><h3 id="隐函数求导">隐函数求导</h3><h4 id="例1">例1</h4>\begin{align*}x + y^3 - 1 &= 0 \\1 + 3y^2 \cdot \frac{dy}{dx} &= 0\end{align*}<h4 id="例2">例2</h4>\begin{align*}e^y + xy - e &= 0 \\e^y \frac{dy}{dx} + y + x\frac{dy}{dx} &= 0\end{align*}<hr><h3 id="参数方程导数">参数方程导数</h3><h4 id="运动学示例">运动学示例</h4>\begin{align*}\begin{cases}x = v_1 t \\y = v_2 t - \frac{1}{2}gt^2\end{cases}\end{align*}<h4 id="一般形式">一般形式</h4>\begin{align*}\begin{cases}x = \varphi(t) \\y = \psi(t)\end{cases}\quad \Rightarrow \quad\frac{dy}{dx} = \frac{\frac{dy}{dt}}{\frac{dx}{dt}} = \frac{\psi'(t)}{\varphi'(t)}\end{align*}]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.初等函数的导数推导</title>
      <link href="/2019/09/28/%E6%95%B0%E5%AD%A6/1-%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E6%95%B0%E6%8E%A8%E5%AF%BC/"/>
      <url>/2019/09/28/%E6%95%B0%E5%AD%A6/1-%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E6%95%B0%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="初等函数的导数推导">初等函数的导数推导</h2><h3 id="1-幂函数求导">1. 幂函数求导</h3><p>求 $$\textcolor{red}{f(x)=x^n}$$ 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">x=a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">=</span><span class="mord mathit">a</span></span></span></span> 处的导数：</p>\begin{align*}f'(x) &= \lim_{x\to a} \frac{f(x)-f(a)}{x-a} \\&= \lim_{x\to a} \frac{x^n-a^n}{x-a} \\&= \lim_{x\to a} \frac{(x^n-ax^{n-1}) + (ax^{n-1}-a^2x^{n-2}) + \cdots + a^{n-1}x-a^n}{x-a} \\&= \lim_{x\to a} \left[(x^{n-1}) + (ax^{n-2}) + \cdots + a^{n-1}\right] \\&= \lim_{x\to a} (x^{n-1}) + \lim_{x \to a} (ax^{n-2})...+\lim_{x\to a} a^{n-1} \\&= na^{n-1}\end{align*}\begin{align*}\thereforef(x)=x^n \\f'(x) = n x^{n-1}\end{align*}<hr><h3 id="2-正弦函数求导">2. 正弦函数求导</h3><p>求 $$\textcolor{red}{f(x)= \sin x}$$ 的导数：</p>\begin{align*}f'(x) &= \lim_{h\to 0} \frac{f(x+h)-f(x)}{h} \\&= \lim_{h\to 0} \frac{\sin(x+h)-\sin x}{h} \\&= \lim_{h\to 0} \frac{2\sin\left(\frac{h}{2}\right)\cos\left(x+\frac{h}{2}\right)}{h} \\&= \lim_{h\to 0} \left(\frac{\sin\left(\frac{h}{2}\right)}{\frac{h}{2}} \cdot \cos\left(x+\frac{h}{2}\right)\right) \\&= \cos x\end{align*}<hr><h3 id="3-余弦函数求导">3. 余弦函数求导</h3><p>求 $$\textcolor{red}{f(x)= \cos x}$$ 的导数：</p>\begin{align*}f'(x) &= \lim_{h\to 0} {f(x+h)-f(x) \over h} \\&= \lim_{h\to 0} \frac{\cos(x+h)-\cos x}{h} \\&= \lim_{h\to 0} \frac{-2\sin\left(\frac{h}{2}\right)\sin\left(x+\frac{h}{2}\right)}{h} \\&= -\lim_{h\to 0} \left(\frac{\sin\left(\frac{h}{2}\right)}{\frac{h}{2}} \cdot \sin\left(x+\frac{h}{2}\right)\right) \\&= -\sin x\end{align*}<hr><h3 id="4-指数函数求导">4. 指数函数求导</h3><p>求 $$\textcolor{red}{f(x)= a^x}$$ 的导数：</p>\begin{align*}f'(x) &= \lim_{h\to 0} {f(x+h)-f(x) \over h} \\&= \lim_{h\to 0} \frac{a^{x+h}-a^x}{h} \\&= \textcolor{red}{a^x \lim_{h\to 0} \frac{a^h-1}{h}} \\&= \textcolor{red}{a^x \ln a}\end{align*}<p><strong>推导关键步骤</strong>：<br>令 $$t = a^h - 1$$，则：</p>\begin{align*}a=log_a (t+1)\end{align*}\begin{align*}此时有:\textcolor{red}{\lim_{h\to 0} \frac{a^h-1}{h} = \lim_{t\to 0} \frac{t}{\log_a(t+1)} = \ln a}\end{align*}<hr><h3 id="5-对数函数求导">5. 对数函数求导</h3><p>求 $$\textcolor{red}{f(x)= \log_a x}$$ 的导数：</p>\begin{align*}f'(x) &= \lim_{h\to 0} {f(x+h)-f(x) \over h} \\&= \lim_{h\to 0} \frac{\log_a(x+h) - \log_a x}{h} \\&= \lim_{h\to 0} {log_a \ {(x+h) \over x} \over h} \\&= \lim_{h\to 0} \frac{1}{x} \cdot \textcolor{red}{\frac{\log_a\left(1+\frac{h}{x}\right)}{\frac{h}{x}}} \\&\textcolor{red}{= \frac{1}{x \ln a}}\end{align*}<p><strong>特例</strong>：当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">a=e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mrel">=</span><span class="mord mathit">e</span></span></span></span> 时，</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>l</mi><mi>n</mi><mtext> </mtext><mi>x</mi></mrow><annotation encoding="application/x-tex">f(x)= ln \ x </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">n</span><span class="mord mspace"> </span><span class="mord mathit">x</span></span></span></span></span></p>\begin{align*}& f'(x) =(\ln x)' = \frac{1}{x}\end{align*}]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0.中学数学复习</title>
      <link href="/2019/09/13/%E6%95%B0%E5%AD%A6/0-%E4%B8%AD%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0/"/>
      <url>/2019/09/13/%E6%95%B0%E5%AD%A6/0-%E4%B8%AD%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="等比公式：">等比公式：</h4>\begin{align*}S_n=a_1(1-q^n)/(1-q)\end{align*}<h4 id="等差公式：">等差公式：</h4>\begin{align*}S_n=(a_1+a_n)n/2=na_1+n(n-1)d/2\end{align*}<hr><h3 id="排列组合：">排列组合：</h3><h4 id="排列">排列</h4>\begin{align*}A^m_n=n(n-1)(n-2)...(n-m+1)=\frac{n!}{(n-m)!}\end{align*}<h4 id="组合">组合</h4>\begin{align*}C^m_n={A^m_n \over m!}={n(n-1)(n-2)...(n-m+1)\over m!}={n! \over m!(n-m)!}\end{align*}<hr><h3 id="牛顿二项式">牛顿二项式</h3>\begin{align*}(a+b)^n=\sum^n_{k=0}C^k_nx^k\end{align*}<hr><h3 id="三角函数">三角函数</h3>\begin{align*}\sin(\alpha+\beta)=\sin(\alpha)\cos(\beta)+\cos(\alpha)\sin(\beta)\therefore \sin(2\alpha)=2\sin(\alpha)\cos(\alpha)\end{align*}\begin{align*}\cos(\alpha+\beta)=\cos(\alpha)\cos(\beta)-\sin(\alpha)s\in(\beta)\therefore \cos(2\alpha)=\cos^2(\alpha)-\sin^2(\alpha)\end{align*}<hr><h3 id="对数函数">对数函数</h3><hr><p>e的定义</p>\begin{align*}\lim_{x\to \infty} (1+{1 \over {n}})^n=e\end{align*}]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极简数学复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX的写法</title>
      <link href="/2019/09/12/%E6%95%B0%E5%AD%A6/markdown-latex%E7%9A%84%E6%95%B0%E5%AD%A6%E5%BC%8F%E5%86%99%E6%B3%95/"/>
      <url>/2019/09/12/%E6%95%B0%E5%AD%A6/markdown-latex%E7%9A%84%E6%95%B0%E5%AD%A6%E5%BC%8F%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>数学符号和对应的LaTeX代码：</p><table><thead><tr><th>符号显示</th><th>LaTeX代码</th><th>符号显示</th><th>LaTeX代码</th></tr></thead><tbody><tr><td>∑</td><td><code>$\sum$</code></td><td>∑_{i=0}^n</td><td><code>$\sum_&#123;i=0&#125;^n$</code></td></tr><tr><td>∏</td><td><code>$\prod$</code></td><td>∏_{i=0}^n</td><td><code>$\prod_&#123;i=0&#125;^n$</code></td></tr><tr><td>×</td><td><code>$\times$</code></td><td>∗</td><td><code>$\ast$</code></td></tr><tr><td>±</td><td><code>$\pm$</code></td><td>÷</td><td><code>$\div$</code></td></tr><tr><td>∣</td><td><code>$\mid$</code></td><td>⋅</td><td><code>$\cdot$</code></td></tr><tr><td>⨀</td><td><code>$\bigodot$</code></td><td>≈</td><td><code>$\approx$</code></td></tr><tr><td>≤</td><td><code>$\leq$</code></td><td>≥</td><td><code>$\geq$</code></td></tr><tr><td>≠</td><td><code>$\neq$</code></td><td>≡</td><td><code>$\equiv$</code></td></tr><tr><td>x̄</td><td><code>$\overline&#123;x&#125;$</code></td><td>x̲</td><td><code>$\underline&#123;x&#125;$</code></td></tr><tr><td>x̂</td><td><code>$\hat&#123;x&#125;$</code></td><td>x̌</td><td><code>$\check&#123;x&#125;$</code></td></tr><tr><td>x̆</td><td><code>$\breve&#123;x&#125;$</code></td><td>↑</td><td><code>$\uparrow$</code></td></tr><tr><td>↓</td><td><code>$\downarrow$</code></td><td>←</td><td><code>$\leftarrow$</code></td></tr><tr><td>→</td><td><code>$\rightarrow$</code></td><td>⇑</td><td><code>$\Uparrow$</code></td></tr><tr><td>⇓</td><td><code>$\Downarrow$</code></td><td>⇐</td><td><code>$\Leftarrow$</code></td></tr><tr><td>⇒</td><td><code>$\Rightarrow$</code></td><td>⟵</td><td><code>$\longleftarrow$</code></td></tr><tr><td>⟶</td><td><code>$\longrightarrow$</code></td><td>⟸</td><td><code>$\Longleftarrow$</code></td></tr><tr><td>⟹</td><td><code>$\Longrightarrow$</code></td><td>∵</td><td><code>$\because$</code></td></tr><tr><td>∴</td><td><code>$\therefore$</code></td><td>∀</td><td><code>$\forall$</code></td></tr><tr><td>∃</td><td><code>$\exists$</code></td><td>y′</td><td><code>$y'$</code></td></tr><tr><td>∫</td><td><code>$\int$</code></td><td>∬</td><td><code>$\iint$</code></td></tr><tr><td>∭</td><td><code>$\iiint$</code></td><td>∮</td><td><code>$\oint$</code></td></tr><tr><td>lim</td><td><code>$\lim$</code></td><td>∞</td><td><code>$\infty$</code></td></tr><tr><td>∇</td><td><code>$\nabla$</code></td><td>⊥</td><td><code>$\bot$</code></td></tr><tr><td>∠30°</td><td><code>$\angle 30^\circ$</code></td><td>sin</td><td><code>$\sin$</code></td></tr><tr><td>cos</td><td><code>$\cos$</code></td><td>tan</td><td><code>$\tan$</code></td></tr><tr><td>cot</td><td><code>$\cot$</code></td><td>sec</td><td><code>$\sec$</code></td></tr><tr><td>csc</td><td><code>$\csc$</code></td><td>log</td><td><code>$\log$</code></td></tr><tr><td>lg</td><td><code>$\lg$</code></td><td>ln</td><td><code>$\ln$</code></td></tr><tr><td>∅</td><td><code>$\emptyset$</code></td><td>∈</td><td><code>$\in$</code></td></tr><tr><td>∉</td><td><code>$\notin$</code></td><td>⊂</td><td><code>$\subset$</code></td></tr><tr><td>⊃</td><td><code>$\supset$</code></td><td>⊆</td><td><code>$\subseteq$</code></td></tr><tr><td>⊇</td><td><code>$\supseteq$</code></td><td>⋂</td><td><code>$\bigcap$</code></td></tr><tr><td>⋃</td><td><code>$\bigcup$</code></td><td>⋁</td><td><code>$\bigvee$</code></td></tr><tr><td>⋀</td><td><code>$\bigwedge$</code></td><td>⨄</td><td><code>$\biguplus$</code></td></tr><tr><td>⨆</td><td><code>$\bigsqcup$</code></td><td></td><td></td></tr></tbody></table><h3 id="分式与特殊符号">分式与特殊符号</h3><table><thead><tr><th>显示</th><th>LaTeX代码</th></tr></thead><tbody><tr><td>1/(2x+1)</td><td><code>$\frac&#123;1&#125;&#123;2x+1&#125;$</code></td></tr><tr><td>1/(2x+1)</td><td><code>$&#123;&#123;1&#125; \over &#123;2x+1&#125;&#125;$</code></td></tr><tr><td>du/dx|_{x=0}</td><td>`$\left.\frac{du}{dx}\right</td></tr><tr><td>∛9</td><td><code>$\sqrt[3]&#123;9&#125;$</code></td></tr><tr><td>√16</td><td><code>$\sqrt&#123;16&#125;$</code></td></tr><tr><td>…</td><td><code>$\ldots$</code></td></tr><tr><td>f(x₁,x₂,…,xₙ)=x₁²+⋯+xₙ²</td><td><code>$f(x_1,x_2,\ldots,x_n)=x_1^2+\cdots+x_n^2$</code></td></tr><tr><td>a⃗</td><td><code>$\vec&#123;a&#125;$</code></td></tr><tr><td>∫₀¹ x²dx</td><td><code>$\int_0^1 x^2 dx$</code></td></tr><tr><td>limₙ→∞ 1/[n(n+1)]</td><td><code>$\lim_&#123;n\to\infty&#125;\frac&#123;1&#125;&#123;n(n+1)&#125;$</code></td></tr><tr><td>∑₁ⁿ 1/x²</td><td><code>$\sum_1^n \frac&#123;1&#125;&#123;x^2&#125;$</code></td></tr><tr><td>x∈[0,100]</td><td><code>$x \in [0,100]$</code></td></tr><tr><td>xʸᶻ=(1+eˣ)⁻²ˣʸʷ</td><td><code>$x^&#123;y^z&#125;=(1+e^x)^&#123;-2xy^w&#125;$</code></td></tr></tbody></table><h3 id="分段函数">分段函数</h3>\begin{align*}y = \begin{cases} x \\ \alpha \end{cases}\end{align*}<p>LaTeX代码：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span>y =<span class="keyword">\begin</span>&#123;cases&#125; x<span class="keyword">\\</span> <span class="keyword">\alpha</span> <span class="keyword">\end</span>&#123;cases&#125;<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java变量类型</title>
      <link href="/2019/01/18/Java%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/01/18/Java%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="变量类型">变量类型</h3><hr><p>在Java语言中，所有的变量在使用前必须声明。声明变量的基本格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type identifier [ = value][, identifier [= value] ...] ;</span><br></pre></td></tr></table></figure><p>格式说明：type为Java数据类型。identifier是变量名。可以使用逗号隔开来声明多个同类型变量。<br>以下列出了一些变量的声明实例。注意有些包含了初始化过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a, b, c;         // 声明三个int型整数：a、 b、c</span><br><span class="line">int d = 3, e = 4, f = 5; // 声明三个整数并赋予初值</span><br><span class="line">byte z = 22;         // 声明并初始化 z</span><br><span class="line">String s = &quot;runoob&quot;;  // 声明并初始化字符串 s</span><br><span class="line">double pi = 3.14159; // 声明了双精度浮点型变量 pi</span><br><span class="line">char x = &#x27;x&#x27;;        // 声明变量 x 的值是字符 &#x27;x&#x27;。</span><br></pre></td></tr></table></figure><h1></h1><p>Java语言支持的变量类型有：</p><ul><li>类变量：独立于方法之外的变量，用 static 修饰。</li><li>实例变量：独立于方法之外的变量，不过没有 static 修饰。</li><li>局部变量：类的方法中的变量。</li></ul><h1></h1><h4 id="Java-局部变量">Java 局部变量</h4><ul><li>局部变量声明在方法、构造方法或者语句块中；</li><li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li><li>==访问修饰符不能用于局部变量；==</li><li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li><li>局部变量是在栈上分配的。</li><li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li></ul><h1></h1><h4 id="Java-实例变量">Java 实例变量</h4><ul><li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li><li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li><li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</li><li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li><li>实例变量可以声明在使用前或者使用后；</li><li>==访问修饰符可以修饰实例变量；==</li><li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li><li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li><li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</li></ul><h1></h1><h4 id="类变量（静态变量）">类变量（静态变量）</h4><ul><li>类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。</li><li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li><li>静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。</li><li>==静态变量储存在静态存储区。==经常被声明为常量，很少单独使用static声明变量。</li><li>静态变量在第一次被访问时创建，在程序结束时销毁。</li><li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。</li><li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li><li>静态变量可以通过：ClassName.VariableName的方式访问。</li><li>类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git rebase</title>
      <link href="/2017/09/16/git/git-rebase/"/>
      <url>/2017/09/16/git/git-rebase/</url>
      
        <content type="html"><![CDATA[<h2 id="变基">变基</h2><p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。</p><h3 id="变基的基本操作">变基的基本操作</h3><p>请回顾之前在 <a href="https://git-scm.com/book/zh/v2/ch00/_basic_merging">分支的合并</a> 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。</p><p><img src="https://git-scm.com/book/zh/v2/images/basic-rebase-1.png" alt="分叉的提交历史。"></p><p>Figure 35. 分叉的提交历史</p><p>之前介绍过，整合分支最容易的方法是 <code>merge</code> 命令。 它会把两个分支的最新快照（<code>C3</code> 和 <code>C4</code>）以及二者最近的共同祖先（<code>C2</code>）进行三方合并，合并的结果是生成一个新的快照（并提交）。</p><p><img src="https://git-scm.com/book/zh/v2/images/basic-rebase-2.png" alt="通过合并操作来整合分叉了的历史。"></p><p>Figure 36. 通过合并操作来整合分叉的历史</p><p>其实，还有一种方法：你可以提取在 <code>C4</code> 中引入的补丁和修改，然后在 <code>C3</code> 的基础上应用一次。 在 Git 中，这种操作就叫做 <strong>变基（rebase）</strong>。 你可以使用 <code>rebase</code> 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p><p>在这个例子中，你可以检出 <code>experiment</code> 分支，然后将它变基到 <code>master</code> 分支上：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout experiment</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase master</span></span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: added staged command</span><br></pre></td></tr></table></figure><p>它的原理是首先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的目标基底分支 <code>master</code>） 的最近共同祖先 <code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 <code>C3</code>, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同）</p><p><img src="https://git-scm.com/book/zh/v2/images/basic-rebase-3.png" alt="将  中的修改变基到  上。"></p><p>Figure 37. 将 <code>C4</code> 中的修改变基到 <code>C3</code> 上</p><p>现在回到 <code>master</code> 分支，进行一次快进合并。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge experiment</span></span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/zh/v2/images/basic-rebase-4.png" alt=" 分支的快进合并。"></p><p>Figure 38. <code>master</code> 分支的快进合并</p><p>此时，<code>C4'</code> 指向的快照就和 <a href="https://git-scm.com/book/zh/v2/ch00/ebasing-merging-example">the merge example</a> 中 <code>C5</code> 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p><p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 <code>origin/master</code> 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p><p>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p><h3 id="更有趣的变基例子">更有趣的变基例子</h3><p>在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 <a href="https://git-scm.com/book/zh/v2/ch00/bdiag_e">从一个主题分支里再分出一个主题分支的提交历史</a> 中的例子那样。 你创建了一个主题分支 <code>server</code>，为服务端添加了一些功能，提交了 <code>C3</code> 和 <code>C4</code>。 然后从 <code>C3</code> 上创建了主题分支 <code>client</code>，为客户端添加了一些功能，提交了 <code>C8</code> 和 <code>C9</code>。 最后，你回到 <code>server</code> 分支，又提交了 <code>C10</code>。</p><p><img src="https://git-scm.com/book/zh/v2/images/interesting-rebase-1.png" alt="从一个主题分支里再分出一个主题分支的提交历史。"></p><p>Figure 39. 从一个主题分支里再分出一个主题分支的提交历史</p><p>假设你希望将 <code>client</code> 中的修改合并到主分支并发布，但暂时并不想合并 <code>server</code> 中的修改， 因为它们还需要经过更全面的测试。这时，你就可以使用 <code>git rebase</code> 命令的 <code>--onto</code> 选项， 选中在 <code>client</code> 分支里但不在 <code>server</code> 分支里的修改（即 <code>C8</code> 和 <code>C9</code>），将它们在 <code>master</code> 分支上重放：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase --onto master server client</span></span><br></pre></td></tr></table></figure><p>以上命令的意思是：“取出 <code>client</code> 分支，找出它从 <code>server</code> 分支分歧之后的补丁， 然后把这些补丁在 <code>master</code> 分支上重放一遍，让 <code>client</code> 看起来像直接基于 <code>master</code> 修改一样”。这理解起来有一点复杂，不过效果非常酷。</p><p><img src="https://git-scm.com/book/zh/v2/images/interesting-rebase-2.png" alt="截取主题分支上的另一个主题分支，然后变基到其他分支。"></p><p>Figure 40. 截取主题分支上的另一个主题分支，然后变基到其他分支</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge client</span></span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/zh/v2/images/interesting-rebase-3.png" alt="快进合并  分支，使之包含来自  分支的修改。"></p><p>Figure 41. 快进合并 <code>master</code> 分支，使之包含来自 <code>client</code> 分支的修改</p><p>接下来你决定将 <code>server</code> 分支中的修改也整合进来。 使用 <code>git rebase &lt;basebranch&gt; &lt;topicbranch&gt;</code> 命令可以直接将主题分支 （即本例中的 <code>server</code>）变基到目标分支（即 <code>master</code>）上。 这样做能省去你先切换到 <code>server</code> 分支，再对其执行变基命令的多个步骤。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase master server</span></span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/zh/v2/images/interesting-rebase-4.png" alt="将  中的修改变基到  上。"></p><p>Figure 42. 将 <code>server</code> 中的修改变基到 <code>master</code> 上</p><p>然后就可以快进合并主分支 <code>master</code> 了：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge server</span></span><br></pre></td></tr></table></figure><p>至此，<code>client</code> 和 <code>server</code> 分支中的修改都已经整合到主分支里了， 你可以删除这两个分支，最终提交历史会变成图 <a href="https://git-scm.com/book/zh/v2/ch00/bdiag_i">最终的提交历史</a> 中的样子：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d client</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d server</span></span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/zh/v2/images/interesting-rebase-5.png" alt="最终的提交历史。"></p><p>Figure 43. 最终的提交历史</p><h3 id="变基的风险">变基的风险</h3><p>呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：</p><p><strong>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。</strong></p><p>如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p><p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p><p>让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：</p><p><img src="https://git-scm.com/book/zh/v2/images/perils-of-rebasing-1.png" alt="克隆一个仓库，然后在它的基础上进行了一些开发。"></p><p>Figure 44. 克隆一个仓库，然后在它的基础上进行了一些开发</p><p>然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：</p><p><img src="https://git-scm.com/book/zh/v2/images/perils-of-rebasing-2.png" alt="抓取别人的提交，合并到自己的开发分支。"></p><p>Figure 45. 抓取别人的提交，合并到自己的开发分支</p><p>接下来，这个人又决定把合并操作回滚，改用变基；继而又用 <code>git push --force</code> 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。</p><p><img src="https://git-scm.com/book/zh/v2/images/perils-of-rebasing-3.png" alt="有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交。"></p><p>Figure 46. 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交</p><p>结果就是你们两人的处境都十分尴尬。 如果你执行 <code>git pull</code> 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：</p><p><img src="https://git-scm.com/book/zh/v2/images/perils-of-rebasing-4.png" alt="你将相同的内容又合并了一次，生成了一个新的提交。"></p><p>Figure 47. 你将相同的内容又合并了一次，生成了一个新的提交</p><p>此时如果你执行 <code>git log</code> 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 <code>C4</code> 和 <code>C6</code>，因为之前就是他把这两个提交通过变基丢弃的。</p><h3 id="用变基解决变基">用变基解决变基</h3><p>如果你 <strong>真的</strong> 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。</p><p>实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patch-id”。</p><p>如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。</p><ul><li><p>检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</p></li><li><p>检查其中哪些提交不是合并操作的结果（C2，C3，C4）</p></li><li><p>检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’）</p></li><li><p>把查到的这些提交应用在 <code>teamone/master</code> 上面</p></li></ul><p><img src="https://git-scm.com/book/zh/v2/images/perils-of-rebasing-5.png" alt="在一个被变基然后强制推送的分支上再次执行变基。"></p><p>Figure 48. 在一个被变基然后强制推送的分支上再次执行变基</p><p>要想上述方案有效，还需要对方在变基时确保 <code>C4'</code> 和 <code>C4</code> 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 <code>C4</code> 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。</p><p>在本例中另一种简单的方法是使用 <code>git pull --rebase</code> 命令而不是直接 <code>git pull</code>。 又或者你可以自己手动完成这个过程，先 <code>git fetch</code>，再 <code>git rebase teamone/master</code>。</p><p>如果你习惯使用 <code>git pull</code> ，同时又希望默认使用选项 <code>--rebase</code>，你可以执行这条语句 <code>git config --global pull.rebase true</code> 来更改 <code>pull.rebase</code> 的默认配置。</p><p>如果你只对不会离开你电脑的提交执行变基，那就不会有事。 如果你对已经推送过的提交执行变基，但别人没有基于它的提交，那么也不会有事。 如果你对已经推送至共用仓库的提交上执行变基命令，并因此丢失了一些别人的开发所基于的提交， 那你就有大麻烦了，你的同事也会因此鄙视你。</p><p>如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 <code>git pull --rebase</code> 命令，这样尽管不能避免伤痛，但能有所缓解。</p><h3 id="变基-vs-合并">变基 vs. 合并</h3><p>至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。</p><p>有一种观点认为，仓库的提交历史即是 <strong>记录实际发生过什么</strong>。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 <em>谎言</em> 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p><p>另一种观点则正好相反，他们认为提交历史是 <strong>项目过程中发生的事</strong>。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 <code>rebase</code> 及 <code>filter-branch</code> 等工具来编写故事，怎么方便后来的读者就怎么写。</p><p>现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p><p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git flow</title>
      <link href="/2017/09/15/git/git-flow/"/>
      <url>/2017/09/15/git/git-flow/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-Flow">Git Flow</h2><p>Git Flow 是一种基于 Git 的分支模型，旨在帮助团队更好地管理和发布软件。</p><p>Git Flow 由 Vincent Driessen 在 2010 年提出，并通过一套标准的分支命名和工作流程，使开发、测试和发布过程更加有序和高效。</p><p>Git Flow 主要由以下几类分支组成：<code>master</code>、<code>develop</code>、<code>feature</code>、<code>release</code>、<code>hotfix</code>。</p><h2 id="Git-Flow-安装">Git Flow 安装</h2><h3 id="Linux">Linux</h3><p><strong>Debian/Ubuntu:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git-flow</span><br></pre></td></tr></table></figure><p><strong>Fedora:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install gitflow</span><br><span class="line">sudo apt-get install git-flow</span><br></pre></td></tr></table></figure><h3 id="macOS">macOS</h3><p>在 macOS 上，你可以使用 Homebrew 来安装 Git Flow:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git-flow</span><br></pre></td></tr></table></figure><h3 id="源码安装">源码安装</h3><p>如果你的发行版的包管理器中没有 Git Flow，你也可以从源代码进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/nvie/gitflow.git</span><br><span class="line">cd gitflow</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>安装完成后，你可以通过以下命令验证 Git Flow 是否成功安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow version</span><br></pre></td></tr></table></figure><h3 id="Windows">Windows</h3><p>在 Windows 上，你可以通过以下方式安装 Git Flow：</p><ul><li><p><strong>使用 Git for Windows</strong>: Git for Windows 包含了 Git Flow。你可以从 <a href="https://gitforwindows.org/">Git for Windows</a> 安装 Git，然后使用 Git Bash 来使用 Git Flow。</p></li><li><p><strong>使用 Scoop</strong>: 如果你使用 Scoop 包管理工具，可以通过以下命令安装 Git Flow：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop install git-flow</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 Chocolatey</strong>: 如果你使用 Chocolatey 包管理工具，可以通过以下命令安装 Git Flow：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install gitflow</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="Git-Flow-分支模型">Git Flow 分支模型</h2><p><strong><code>master</code> 分支</strong>：</p><ul><li>永远保持稳定和可发布的状态。</li><li>每次发布一个新的版本时，都会从 <code>develop</code> 分支合并到 <code>master</code> 分支。</li></ul><p><strong><code>develop</code> 分支</strong>：</p><ul><li>用于集成所有的开发分支。</li><li>代表了最新的开发进度。</li><li>功能分支、发布分支和修复分支都从这里分支出去，最终合并回这里。</li></ul><p><strong><code>feature</code> 分支</strong>：</p><ul><li>用于开发新功能。</li><li>从 <code>develop</code> 分支创建，开发完成后合并回 <code>develop</code> 分支。</li><li>命名规范：<code>feature/feature-name</code>。</li></ul><p><strong><code>release</code> 分支</strong>：</p><ul><li>用于准备新版本的发布。</li><li>从 <code>develop</code> 分支创建，进行最后的测试和修复，然后合并回 <code>develop</code> 和 <code>master</code> 分支，并打上版本标签。</li><li>命名规范：<code>release/release-name</code>。</li></ul><p><strong><code>hotfix</code> 分支</strong>：</p><ul><li>用于修复紧急问题。</li><li>从 <code>master</code> 分支创建，修复完成后合并回 <code>master</code> 和 <code>develop</code> 分支，并打上版本标签。</li><li>命名规范：<code>hotfix/hotfix-name</code>。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2024/07/git-flow.png" alt=""></p><h3 id="分支操作原理">分支操作原理</h3><ul><li>Master 分支上的每个 Commit 应打上 Tag，Develop 分支基于 Master 创建。</li><li>Feature 分支完成后合并回 Develop 分支，并通常删除该分支。</li><li>Release 分支基于 Develop 创建，用于测试和修复 Bug，发布后合并回 Master 和 Develop，并打 Tag 标记版本号。</li><li>Hotfix 分支基于 Master 创建，完成后合并回 Master 和 Develop，并打 Tag 1。</li></ul><h3 id="Git-Flow-命令示例">Git Flow 命令示例</h3><ul><li>开始 Feature 分支：<code>git flow feature start MYFEATURE</code></li><li>完成 Feature 分支：<code>git flow feature finish MYFEATURE</code></li><li>开始 Release 分支：<code>git flow release start RELEASE [BASE]</code></li><li>完成 Release 分支：合并到 Master 和 Develop，打 Tag，删除 Release 分支。</li><li>开始 Hotfix 分支：<code>git flow hotfix start HOTFIX [BASE]</code></li><li>完成 Hotfix 分支：合并到 Master 和 Develop，打 Tag，删除 Hotfix 分支。</li></ul><h3 id="Git-Flow-工作流程">Git Flow 工作流程</h3><h4 id="1-初始化-Git-Flow">1. 初始化 Git Flow</h4><p>首先，在项目中初始化 Git Flow。可以使用 Git Flow 插件（例如 <code>git-flow</code>）来简化操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow init</span><br></pre></td></tr></table></figure><p>初始化时，你需要设置分支命名规则和默认分支。</p><h4 id="2-创建功能分支">2. 创建功能分支</h4><p>当开始开发一个新功能时，从 <code>develop</code> 分支创建一个功能分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow feature start feature-name</span><br></pre></td></tr></table></figure><p>完成开发后，将功能分支合并回 <code>develop</code> 分支，并删除功能分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow feature finish feature-name</span><br></pre></td></tr></table></figure><h4 id="3-创建发布分支">3. 创建发布分支</h4><p>当准备发布一个新版本时，从 <code>develop</code> 分支创建一个发布分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow release start release-name</span><br></pre></td></tr></table></figure><p>在发布分支上进行最后的测试和修复，准备好发布后，将发布分支合并回 <code>develop</code> 和 <code>master</code> 分支，并打上版本标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow release finish release-name</span><br></pre></td></tr></table></figure><h4 id="4-创建修复分支">4. 创建修复分支</h4><p>当发现需要紧急修复的问题时，从 <code>master</code> 分支创建一个修复分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow hotfix start hotfix-name</span><br></pre></td></tr></table></figure><p>修复完成后，将修复分支合并回 <code>master</code> 和 <code>develop</code> 分支，并打上版本标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow hotfix finish hotfix-name</span><br></pre></td></tr></table></figure><h3 id="实例操作">实例操作</h3><p>以下是一个实际使用 Git Flow 的综合实例。</p><p><strong>初始化 Git Flow</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow init</span><br></pre></td></tr></table></figure><p><strong>创建和完成功能分支</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git flow feature start new-feature # 开发新功能</span><br><span class="line">git flow feature finish new-feature</span><br></pre></td></tr></table></figure><p><strong>创建和完成发布分支</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git flow release start v1.0.0 # 测试和修复</span><br><span class="line">git flow release finish v1.0.0</span><br></pre></td></tr></table></figure><p><strong>创建和完成修复分支</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git flow hotfix start hotfix-1.0.1. # 修复紧急问题</span><br><span class="line">git flow hotfix finish hotfix-1.0.1</span><br></pre></td></tr></table></figure><h3 id="优点和缺点">优点和缺点</h3><p><strong>优点</strong></p><ul><li><strong>明确的分支模型</strong>：清晰的分支命名和使用规则，使得开发过程井然有序。</li><li><strong>隔离开发和发布</strong>：开发和发布过程分离，减少了开发中的不确定性对发布的影响。</li><li><strong>版本管理</strong>：每次发布和修复都会打上版本标签，方便回溯和管理。</li></ul><p><strong>缺点</strong></p><ul><li><strong>复杂性</strong>：对于小型团队或简单项目，Git Flow 的分支模型可能显得过于复杂。</li><li><strong>频繁的合并</strong>：在大型团队中，频繁的分支合并可能导致合并冲突增加。</li></ul><p>Git Flow 是一种结构化的分支管理模型，通过定义明确的分支和工作流程，帮助团队更好地管理软件开发和发布过程。虽然它增加了一定的复杂性，但对于大型项目和团队协作，Git Flow 提供了强大的支持和管理能力。</p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git教程</title>
      <link href="/2017/08/12/git/git%E6%95%99%E7%A8%8B/"/>
      <url>/2017/08/12/git/git%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="初始化仓库">初始化仓库:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m &#x27;initial project version&#x27;</span><br></pre></td></tr></table></figure><p><img src="/assets/images/fileStatusLifecycle.png" alt="image"></p><h5 id="忽略某些文件">忽略某些文件</h5><p>我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。<br>文件 .gitignore 的格式规范如下：</p><ul><li>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式最后跟反斜杠（/）说明要忽略的是目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li></ul><p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。</p><p>我们再看一个 .gitignore 文件的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line"># 忽略所有 .a 结尾的文件</span><br><span class="line">*.a</span><br><span class="line"># 但 lib.a 除外</span><br><span class="line">!lib.a</span><br><span class="line"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"># 忽略 build/ 目录下的所有文件</span><br><span class="line">build/</span><br><span class="line"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"># 忽略 doc/ 目录下所有扩展名为 txt 的文件</span><br><span class="line">doc/**/*.txt</span><br></pre></td></tr></table></figure><h5 id="跟踪新文件">跟踪新文件</h5><p>使用命令 git add 开始跟踪一个新文件。所以，要跟踪 README 文件，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add README</span><br></pre></td></tr></table></figure><h5 id="提交更新">提交更新</h5><p>每次准备提交前，先用 git status 看下，是不是都已暂存起来了，然后再运行提交命令 git commit：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></table></figure><p>这种方式会启动文本编辑器以便输入本次提交的说明。（默认会启用 shell 的环境变量 $EDITOR 所指定的软件，一般都是 vim 或 emacs。当然也可以按照第一章介绍的方式，使用 ++git config --global core.editor++ 命令设定你喜欢的编辑软件。）</p><p>默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。（如果觉得这还不够，可以用 -v 选项将修改差异的每一行都包含到注释中来。）退出编辑器时，Git 会丢掉注释行，将说明内容和本次更新提交到仓库。</p><p>另外也可以用 +±m++ 参数后跟提交说明的方式，在一行命令中提交更新：</p><p>跳过使用暂存区域<br>Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 <strong>git commit 加上 -a</strong> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤</p><h5 id="移除文件">移除文件</h5><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 <strong>git rm</strong> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><h5 id="移动文件">移动文件</h5><p>要在 Git 中对文件改名，可以这么做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mv file_from file_to</span><br></pre></td></tr></table></figure><p>运行 git mv 就相当于运行了下面三条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv README.txt README</span><br><span class="line">$ git rm README.txt</span><br><span class="line">$ git add README</span><br></pre></td></tr></table></figure><h5 id="查看提交历史">查看提交历史</h5><p>默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。看到了吗，每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间，最后缩进一个段落显示提交说明。</p><p>git log 有许多选项可以帮助你搜寻感兴趣的提交，接下来我们介绍些最常用的。</p><p>我们常用 -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新</p><p>某些时候，单词层面的对比，比行层面的对比，更加容易观察。Git 提供了 +±-word-diff++ 选项。我们可以将其添加到 ++git log -p++ 命令的后面，从而获取单词层面上的对比。在程序代码中进行单词层面的对比常常是没什么用的。不过当你需要在书籍、论文这种很大的文本文件上进行对比的时候，这个功能就显出用武之地了。</p><p>另外，git log 还提供了许多摘要选项可以用，比如 --stat，仅显示简要的增改行数统计</p><p>用 oneline 或 format 时结合 --graph 选项，可以看到开头多出一些 ASCII 字符串表示的简单图形，形象地展示了每个提交所在的分支及其分化衍合情况。</p><p>另外还有按照时间作限制的选项，比如 --since 和 --until。</p><h5 id="撤消操作">撤消操作</h5><p>有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用 --amend 选项重新提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%92%A4%E6%B6%88%E6%93%8D%E4%BD%9C">撤消操作</a></p><h5 id="远程仓库的使用">远程仓库的使用</h5><p>查看当前的远程库<br>要查看当前配置有哪些远程仓库，可以用 git remote 命令，它会列出每个远程库的简短名字。<br>也可以加上 -v 选项（译注：此为 --verbose 的简写，取首字母），显示对应的克隆地址</p><p>添加远程仓库</p><p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add [shortname] [url]：</span><br></pre></td></tr></table></figure><p>现在可以用字符串 pb 指代对应的仓库地址了。比如说，要抓取所有 Paul 有的，但本地仓库没有的信息，可以运行 git fetch pb</p><p>从远程仓库抓取数据</p><p>正如之前所看到的，可以用下面的命令从远程仓库抓取数据到本地：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch [remote-name]</span><br></pre></td></tr></table></figure><p>推送数据到远程仓库</p><p>目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库中的数据推送到远程仓库。实现这个任务的命令很简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [remote-name] [branch-name]。</span><br></pre></td></tr></table></figure><p>如果要把本地的 master 分支推送到 origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>查看远程仓库信息<br>我们可以通过命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show [remote-name]</span><br></pre></td></tr></table></figure><p>查看某个远程仓库的详细信息</p><p>远程仓库的删除和重命名<br>在新版 Git 中可以用 git remote rename 命令修改某个远程仓库在本地的简称，比如想把 pb 改成 paul，可以这么运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure><p>碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><h5 id="打标签">打标签</h5><p><a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE/">打标签</a></p><h5 id="Git-命令别名">Git 命令别名</h5><p>Git 并不会推断你输入的几个字符将会是哪条命令，不过如果想偷懒，少敲几个命令的字符，可以用 git config 为命令设置别名。来看看下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure><p>取消暂存文件时的输入比较繁琐，可以自己设置一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.unstage &#x27;reset HEAD --&#x27;</span><br></pre></td></tr></table></figure><p>这样一来，下面的两条命令完全等同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git unstage fileA</span><br><span class="line">$ git reset HEAD fileA</span><br></pre></td></tr></table></figure><p>显然，使用别名的方式看起来更清楚。另外，我们还经常设置 last 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.last &#x27;log -1 HEAD&#x27;</span><br></pre></td></tr></table></figure><p>然后要看最后一次的提交信息，就变得简单多了</p><h5 id="分支的新建与切换">分支的新建与切换</h5><p>要新建并切换到该分支，运行 git checkout 并加上 -b 参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b iss53</span><br><span class="line">Switched to a new branch &#x27;iss53&#x27;</span><br></pre></td></tr></table></figure><p>回到 master 分支并把它合并进来，然后发布到生产服务器。用 git merge 命令来进行合并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge hotfix</span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> README | 1 -</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br></pre></td></tr></table></figure><p>这相当于执行下面这两条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch iss53</span><br><span class="line">$ git checkout iss53</span><br></pre></td></tr></table></figure><p>如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。</p><p>合并之后，master 分支和 hotfix 分支指向同一位置。<br>由于当前 hotfix 分支和 master 都指向相同的提交对象，所以 hotfix 已经完成了历史使命，可以删掉了。使用 git branch 的 -d 选项执行删除操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d hotfix</span><br><span class="line">Deleted branch hotfix (was 3a0874c).</span><br></pre></td></tr></table></figure><h5 id="遇到冲突时的分支合并">遇到冲突时的分支合并</h5><p>有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）。<br>Git 作了合并，但没有提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用 <strong>git status</strong> 查阅</p><p>任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line">=======</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">  please contact us at support@github.com</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53</span><br></pre></td></tr></table></figure><p>可以看到 ======= 隔开的上半部分，是 HEAD（即 master 分支，在运行 merge 命令时所切换到的分支）中的内容，下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">please contact us at email.support@github.com</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这个解决方案各采纳了两个分支中的一部分内容，而且我还删除了 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，======= 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行。在解决了所有文件里的所有冲突后，运行 git add 将把它们标记为已解决状态（译注：实际上就是来一次快照保存到暂存区域。）。</p><p>再运行一次 git status 来确认所有冲突都已解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   index.html</span><br></pre></td></tr></table></figure><p>如果觉得满意了，并且确认所有冲突都已解决，也就是进入了暂存区，就可以用 git commit 来完成这次合并提交。提交的记录差不多是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Merge branch &#x27;iss53&#x27;</span><br><span class="line"></span><br><span class="line">Conflicts:</span><br><span class="line">  index.html</span><br><span class="line">#</span><br><span class="line"># It looks like you may be committing a merge.</span><br><span class="line"># If this is not correct, please remove the file</span><br><span class="line">#       .git/MERGE_HEAD</span><br><span class="line"># and try again.</span><br><span class="line">#</span><br></pre></td></tr></table></figure><h5 id="查看当前的远程库">查看当前的远程库</h5><p>要查看当前配置有哪些远程仓库，可以用 git remote 命令，它会列出每个远程库的简短名字。<br>可以加上 -v 选项（译注：此为 --verbose 的简写，取首字母），显示对应的克隆地址</p><h5 id="添加远程仓库">添加远程仓库</h5><p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add [shortname] [url]：</span><br></pre></td></tr></table></figure><h5 id="从远程仓库抓取数据">从远程仓库抓取数据</h5><p>正如之前所看到的，可以用下面的命令从远程仓库抓取数据到本地：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch [remote-name]</span><br></pre></td></tr></table></figure><p>推送数据到远程仓库<br>项目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库中的数据推送到远程仓库。实现这个任务的命令很简单： git push [remote-name] [branch-name]。如果要把本地的 master 分支推送到 origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。</p><p>查看远程仓库信息<br>我们可以通过命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show [remote-name]</span><br></pre></td></tr></table></figure><p>查看某个远程仓库的详细信息</p><h1></h1><p>远程仓库的删除和重命名<br>在新版 Git 中可以用 git remote rename 命令修改某个远程仓库在本地的简称，比如想把 pb 改成 paul，可以这么运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure><p>注意，对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 pb/master 分支现在成了 paul/master。</p><p>碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><h5 id="远程分支">远程分支</h5><p>我们用 ==(远程仓库名)/(分支名)== 这样的形式表示远程分支。比如我们想看看上次同 origin 仓库通讯时 master 分支的样子，就应该查看 origin/master 分支。如果你和同伴一起修复某个问题，但他们先推送了一个 iss53 分支到远程仓库，虽然你可能也有一个本地的 iss53 分支，但指向服务器上最新更新的却应该是 origin/iss53 分支。</p><p>可以运行 git fetch origin 来同步远程服务器上的数据到本地。该命令首先找到 origin 是哪个服务器（本例为 <a href="http://git.ourcompany.com">git.ourcompany.com</a>），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 origin/master 的指针移到它最新的位置上<br><img src="/assets/images/gitfetch.png" alt="image"></p><p>为了演示拥有多个远程分支（在不同的远程服务器上）的项目是如何工作的，我们假设你还有另一个仅供你的敏捷开发小组使用的内部服务器 <a href="http://git.team1.ourcompany.com">git.team1.ourcompany.com</a>。可以用第二章中提到的 git remote add 命令把它加为当前项目的远程分支之一。我们把它命名为 teamone，以便代替完整的 Git URL 以方便使用<br><img src="/assets/images/gitaddremote.png" alt="image"><br>现在你可以用 git fetch teamone 来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你 origin 服务器上的子集，Git 不会下载任何数据，而只是简单地创建一个名为 teamone/master 的远程分支，指向 teamone 服务器上 master 分支所在的提交对象 31b8e（见图 3-26）。</p><p><img src="/assets/images/gitfetchremote.png" alt="image"></p><h5 id="推送本地分支">推送本地分支</h5><p>要想和其他人分享某个本地分支，你需要把它推送到一个你拥有写权限的远程仓库。你创建的本地分支不会因为你的写入操作而被自动同步到你引入的远程服务器上，你需要明确地执行推送分支的操作。</p><p>如果你有个叫 serverfix 的分支需要和他人一起开发，可以运行 git push (远程仓库名) (分支名)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin serverfix</span><br><span class="line">Counting objects: 20, done.</span><br><span class="line">Compressing objects: 100% (14/14), done.</span><br><span class="line">Writing objects: 100% (15/15), 1.74 KiB, done.</span><br><span class="line">Total 15 (delta 5), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new branch]      serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure><p>这里其实走了一点捷径。Git 自动把 serverfix 分支名扩展为 refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的 serverfix 分支，推送到远程仓库的 serverfix 分支中去”。</p><p>也可以运行 ==git push origin serverfix:serverfix== 来实现相同的效果，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作 awesomebranch，可以用 git push origin serverfix:awesomebranch 来推送数据。</p><h5 id="跟踪远程分支">跟踪远程分支</h5><p>从远程分支 checkout 出来的本地分支，称为 跟踪分支 (tracking branch)。跟踪分支是一种和某个远程分支有直接联系的本地分支。在跟踪分支里输入 git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。同样，在这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来。</p><p>在克隆仓库时，Git 通常会自动创建一个名为 master 的分支来跟踪 origin/master。这正是 git push 和 git pull 一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如 origin 上除了 master 之外的其它分支。刚才我们已经看到了这样的一个例子：git checkout -b [分支名] [远程名]/[分支名]。如果你有 1.6.2 以上版本的 Git，还可以用 --track 选项简化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout --track origin/serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;serverfix&#x27;</span><br></pre></td></tr></table></figure><p>要为本地分支设定不同于远程分支的名字，只需在第一个版本的命令里换个名字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b sf origin/serverfix</span><br><span class="line">Branch sf set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;sf&#x27;</span><br></pre></td></tr></table></figure><p>现在你的本地分支 sf 会自动将推送和抓取数据的位置定位到 origin/serverfix 了</p><h5 id="删除远程分支">删除远程分支</h5><p>如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的 master 分支（或任何其他存放稳定代码的分支），可以用这个非常无厘头的语法来删除它：git push [远程名] :[分支名]。如果想在服务器上删除 serverfix 分支，运行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :serverfix</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure><p>咚！服务器上的分支没了。你最好特别留心这一页，因为你一定会用到那个命令，而且你很可能会忘掉它的语法。有种方便记忆这条命令的方法：==记住我们不久前见过的 git push [远程名] [本地分支]:[远程分支] 语法，如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]”==。</p><h5 id="解决远程分支和本地冲突">解决远程分支和本地冲突</h5><p>1.先将本地修改储存起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>2.pull内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>3.还原暂存内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><p>4.解决冲突</p><p>5.提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#x27;&#x27;</span><br></pre></td></tr></table></figure><ol start="6"><li>打标签</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.1 -m &#x27;&#x27;</span><br></pre></td></tr></table></figure><p>7.列标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -l</span><br></pre></td></tr></table></figure><p>8.获取标签代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout </span><br></pre></td></tr></table></figure><p>9.提交标签到远程端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push tag </span><br></pre></td></tr></table></figure><h5 id="拉取本地没有的远程分支">拉取本地没有的远程分支</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 本地分支名 origin/远程分支名</span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E5%8F%98%E5%9F%BA/">后续:变基rebase</a></p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iptables</title>
      <link href="/2017/04/28/iptables/"/>
      <url>/2017/04/28/iptables/</url>
      
        <content type="html"><![CDATA[<h2 id="基本操作">基本操作</h2><hr><h3 id="查看iptable版本">查看iptable版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -q iptables</span><br></pre></td></tr></table></figure><h3 id="查看iptables-规则">查看iptables 规则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service iptables status</span><br><span class="line"># 或</span><br><span class="line">service -L --line-numbers</span><br></pre></td></tr></table></figure><h2 id="表">表</h2><p>iptables的4个表分别是：</p><ul><li>filter（过滤）：数据包过滤/拦截，可以包含INPUT、FORWARD、OUTPUT这3个内置chain。</li><li>nat（地址转换）：IP地址或端口号转换，可以包含PREROUTING、OUTPUT、POSTROUTING 3个内置chain，nat table在会话建立时会记录转换的对应关系，同一会话的回包和后续报文会自动地址转换，这是因为nat使用了ip_conntrack模块。</li><li>mangle（包管理）：用来修改IP报文，可以包含PREROUTING、OUTPUT、INPUT、FORWARD、POSTROUTING 5个内置chain。</li><li>raw：此表的优先级高于ip_conntrack模块和其它的table，主要用于将有会话状态的连接（比如tcp）的数据包排除在会话外。可以包含POSTROUTING、OUTPUT两个内置chain。</li></ul><p>看到这里肯定会有这样的疑问，为什么table只能包含一些而不是全部的chain呢？我想这个构架是按需设计而不是按功能设计的，尽管table不是包含所有的chain，但是每种功能的table都包含了实现这种功能所需的chain，即使包含更多的chain也是累赘或者无用的，而且实际上用起来也的确如此，够用了。</p><p>还有就是不同table生效优先顺序问题，先后优先级是这样的：</p><p>raw &gt; mangle &gt; nat &gt; filter</p><p>所以，如果有filter禁止ping目的地址2.2.2.2，而nat又有策略将目的地址1.1.1.1转换成2.2.2.2，那么ping 1.1.1.1是ping不通的。</p><p>不过一般情况下filter是不会和nat的策略打起架来，比如INPUT chain能做filter，却不能做nat，PREROUTING能做nat却不能做filter，而且PREROUTING只能做目的地址转换，不会对源地址过滤的需求造成麻烦，所以通常是不会相互干扰的。</p><h2 id="规则链-chain">规则链(chain)</h2><p>iptables内置的5个chain：PREROUTING、INPUT、OUPUT、FORWARD、POSTROUGING，这5个chain分别与netfilter中数据转发路径上的5个不同的位置挂钩，以匹配筛选不同类型的数据流，如下图所示：</p><p>其中：</p><ul><li>PREROUTING链：应用于所有进入机器的ip包，包括目的地址是本机和目的地址非本机的包。</li><li>INPUT链：应用于所有目的是本机的包，也就是目的IP是本机接口地址，所有发给本地socket的数据都经过它。</li><li>OUPUT链：应用于所有由本机产生的包，所有应用程序发出的数据都经过它。</li><li>FORWARD链：应用于所有经过路由决策被转发的包，也就是目的地址不是本机的数据包。</li><li>POSTROUGING链：应用于所有发出机器的IP包，包括本机发出的和从本机转发的数据包。</li></ul><p>策略匹配按照重上到下的顺序进行，当测试到某策略匹配时执行target并跳出，不再向下匹配，当测试到最后一条策略仍不匹配时，则采用policy指定的动作，如下图：</p><p>除了内置chain外，还可以自定义chain，自定义chain并不能利用netfilter的hook来捕捉数据包，但是可用于策略的分类，比如有3类不同的用户访问主机上的不同服务，如果所有策略都放在INPUT chain中策略会多而难以维护，这个时候就可以定义3个自定义chain，分别配置不同的策略，同时在INPUT chain中添加策略对来访者分类并将目标指向3个自定义chain。</p><p>自定义chain大显神威的地方在于动态生成策略，例如VPN服务器上，需要对不同分组的用户区别对待管理，但是用户IP是随机分配的，不能根据IP来区分用户组，这时候可以预先定义好各组chain，利用VPN服务端软件的一些钩子，当用户登陆时自动添加策略引导到自定义chain上来匹配。如果这时候没有自定义chain，那么策略的数量将是（用户数×所属组策略数），每增加一个用户，都要把所属组的全部策略添加一遍，这样大量的时间花费在策略匹配上，性能下降很快。</p><hr><h2 id="各指令的含义">各指令的含义</h2><hr><h3 id="APPEND-A">-APPEND -A</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A chain firewall-rule</span><br></pre></td></tr></table></figure><p>将规则添加到末尾。</p><p>一般情况下,iptables 中最后的规则是丢弃所有数据包。</p><p>于是使用-A参数添加的规则在丢弃规则后，将不起作用。</p><hr><h3 id="DELETE-D">-DELETE -D</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iptables -D chain firewall-rule</span><br><span class="line"># 删除对应规则direwall-rule的那一条</span><br><span class="line"># 或</span><br><span class="line">iptables -D chain rulenum</span><br><span class="line"># 删除chain中编号为rulenum的那一条.1表示第一条。</span><br></pre></td></tr></table></figure><hr><h3 id="INSERT-I">-INSERT -I</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I chain [rulenum] firewall-rule.</span><br></pre></td></tr></table></figure><p>将firewall-rule添加为chain中的第rulenum条规则,原先的第rulenum条规则及以后的各条顺次+1。如未指定rulenum,则默认为1.</p><hr><h3 id="REPLACE-R">-REPLACE -R</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -R chain [rulenum] firewall-rule.</span><br></pre></td></tr></table></figure><p>将firewall-rule添加为chain中的第rulenum条规则,原先的第rulenum条规则及以后的各条顺次+1。如未指定rulenum,则默认为1.</p><hr><h3 id="LIST-L">-LIST -L</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -L chain [rulenum] firewall-rule.</span><br></pre></td></tr></table></figure><p>列出chain或所有chain的第rulenum条规则或所有规则，在-L后再加上–lube-numbers，则显示序号</p><hr><h3 id="LIST-RULES-S">-LIST-RULES -S</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -S chain [rulenum] </span><br></pre></td></tr></table></figure><p>打印全部规则</p><hr><h3 id="FLUSH-F">-FLUSH -F</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -F chain</span><br></pre></td></tr></table></figure><p>情况chain(或全部chain)中的规则</p><hr><h3 id="ZERO-Z">-ZERO -Z</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -Z chain [rulenum] </span><br></pre></td></tr></table></figure><p>清空chain或所有chain的包和字节计数器</p><hr><h3 id="NEW-N">-NEW -N</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -N chain [rulenum] </span><br></pre></td></tr></table></figure><p>创建名称为chain的新链</p><hr><h3 id="DELETE-CHAIN-X">-DELETE-CHAIN -X</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -X [chain] </span><br></pre></td></tr></table></figure><p>删除用户自定义chain或所有用户定义的chain,该指令不影响预设规则</p><hr><h3 id="POLICY-P">-POLICY -P</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -P chain target </span><br></pre></td></tr></table></figure><p>改变chain的策略为target</p><hr><h3 id="RENAME-CHAIN-E">-RENAME-CHAIN -E</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -E old-chain new-chain</span><br></pre></td></tr></table></figure><p>将old-chain名更换为new-chain,使得old-chain的规则失效</p><hr><h2 id="各参数的含义">各参数的含义</h2><hr><h3 id="P-代表协议（PROTOCOL）">-P 代表协议（PROTOCOL）</h3><ul><li>指明当前规则针对的传输协议（如 TCP、UDP、ICMP 等）</li><li>可能的参数值有：tcp, udp, icmp, all</li><li>使用 “all” 表示适用于所有协议。而如果在规则中不指定 -p 参数，则默认使用 “all” 参数。一般不使用 “all” 这个值，要么指定某个特定的协议，要么就指定 -p 参数。</li><li>-p 的参数值既可以用名称（如 tcp）也可以用协议对应的数值（如 6 代表 tcp 协议）</li><li>/etc/protocols 文件中包含了所有允许的协议名称和相应数值</li><li>也可以用长的参数名 –protocol</li></ul><h3 id="S-代表源地址（SOURCE）">-S 代表源地址（SOURCE）</h3><ul><li>指定数据包的源地址</li><li>可以是 ip 地址，或者网络地址，或者主机名（hostname）</li><li>例如：-s 192.168.1.101 表示针对特定的 ip 地址</li><li>对于网络掩码，使用 /mask。例如，“-s 192.168.1.0/24″ 表示网络掩码为 255.255.255.0 的所有 192.168.1.x 地址都匹配。</li><li>如果不指定 -s 参数，默认匹配所有源地址</li><li>也可以用长参数名 –src 或者 –source</li></ul><h3 id="D-代表目的地址（DESTINATION）">-D 代表目的地址（DESTINATION）</h3><ul><li>指定数据包的目的地址</li><li>使用方式与上面的 “-s” 一样（不同之处仅在于 -s 指源，而 -d 表示目的地址）</li><li>也可以用长参数名 –dst 或者 –destination</li></ul><h3 id="J-代表跳转（TARGET）">-J 代表跳转（TARGET）</h3><ul><li>j 的意思是 “jump”（跳转） 到目标</li><li>指定当某个数据包满足该规则的时候的就跳转到的下一个处理规则，而不再顺序执行后面的规则判断</li><li>可能的值有：ACCEPT, DROP, QUEUE, RETURN，分别表示接受、丢弃、进入队列，返回（跳出，通常是从某个 chain 中跳回到调用该 chain 的上层 chain）</li><li>也可以跳转到某个自定义的 chain 中，使用该 chain 的名称做为跳转目标</li></ul><h3 id="I-代表-IN-INTERFACE（入站接口）">-I 代表 IN INTERFACE（入站接口）</h3><ul><li>i 表示 “input interface”（输入接口，即，指定网络数据处理的网卡，一般 eth0 即表示第一块有线网卡的外网接口，lo 表示局域网接口）</li><li>可以直接理解为 “-i” 表示接口。不过，-i 和 -o 都表示接口，-i 表示输入时的接口，而 -o 特指输出用的接口。</li><li>指定数据包进入 INPUT、FORWARD 和 PREROUTING 链时经由的接口。</li><li>例如：-i eth0 表示该规则应该针对从 eth0 接口进来的数据包。</li><li>如果不指定 -i 参数，则经由系统中所有可用的接口进入的数据包都可以匹配该规则。</li><li>也可以使用长参数 –in-interface</li></ul><h3 id="O-代表-OUT-INTERFACE（出站接口）">-O 代表 OUT INTERFACE（出站接口）</h3><ul><li>o 表示 “output interface”（出站经由接口）</li><li>指定发送出去的数据包进入 INPUT、FORWARD 和 PREROUTING 链时经由的接口。</li><li>如果不指定 -o 参数，则经由系统中所有可用的接口发出的数据包都可以匹配该规则。</li><li>也可以使用长参数 –out-interface</li></ul><hr><h2 id="其它防火墙参数选项">其它防火墙参数选项</h2><p>上面某些防火墙参数还有属于它自己的参数选项，可以与其配合使用。下面是一些常用的选项。</p><p>要使用这些参数选项，需要指定相应的参数，例如，要使用 “–sport” 选项，应该在规则中指定 “-p tcp” （或者 “-p udp”）等参数。</p><p>注意：所有这些选项前面都是 –（2个短横线 – ）。</p><h3 id="–SPORT-表示-SOURCE-PORT-源端口，用于-P-TCP-或者-P-UDP">–SPORT 表示 SOURCE PORT (源端口，用于 -P TCP, 或者 -P UDP)</h3><ul><li>默认匹配所有端口（未特别指定时）</li><li>可以指定端口号（数字），也可以指定端口名称。例如，默认的 SSH 端口号码为 22，名称为 ssh，可以表示为 “–sport 22″ 或者 “–sport ssh”。</li><li>/etc/services 文件包含了所有允许的端口名称和对应的端口号码。</li><li>在规则中使用号码比使用名称要好（效率高些）</li><li>要匹配一个端口范围，使用英文半角冒号（:），如 22:100 匹配从 22 到 100 的所有端口号。</li><li>也可以使用长名称 –source-port</li></ul><h3 id="–DPORT-表示-DESTINATION-PORT-目的端口，-P-TCP-或者-P-UDP">–DPORT 表示 DESTINATION PORT (目的端口，-P TCP, 或者 -P UDP)</h3><ul><li>与 –sport 的用法相同，区别仅在于对象是目的端口</li><li>也可以使用长名称 –destination-port</li></ul><h3 id="–TCP-FLAGS-表示-TCP-FLAGS-用于-P-TCP">–TCP-FLAGS 表示 TCP FLAGS (用于 -P TCP)</h3><ul><li>可以使用英文半角逗号（,）来指定多个 TCP 状态标识</li><li>可能值有：SYN, ACK, FIN, RST, URG, PSH。可以全用，也可以不用。</li></ul><h3 id="–ICMP-TYPE-表示-ICMP-TYPE-ICMP-类型，用于-P-ICMP">–ICMP-TYPE 表示 ICMP TYPE (ICMP 类型，用于 -P ICMP)</h3><ul><li>当使用 icmp 协议 “-p icmp” 的时候，可以使用 “–icmp-type” 特别指定 ICMP 类型</li><li>例如，使用 “–icmp-type 0″ 表示 “Echo Reply”，“–icmp-type 8″ 表示 “Echo”。</li></ul><p>添加VIP:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0:1 192.168.1.22 broadcast 192.168.1.2 netmask 255.255.255.0 up</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础</title>
      <link href="/2017/04/28/linux/linux%E5%9F%BA%E7%A1%80/"/>
      <url>/2017/04/28/linux/linux%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1>Linux 基础操作笔记</h1><h2 id="1-文件操作">1. 文件操作</h2><h3 id="1-1-创建文件">1.1 创建文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建单个文件</span></span><br><span class="line"><span class="built_in">touch</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量创建文件（创建love_1_linux.txt到love_10_linux.txt）</span></span><br><span class="line"><span class="built_in">touch</span> love_&#123;1..10&#125;_linux.txt</span><br></pre></td></tr></table></figure><h3 id="1-2-文件权限查看">1.2 文件权限查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l  <span class="comment"># 详细列表显示文件权限</span></span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 user group 1024 Mar 1 10:00 example.txt</span><br></pre></td></tr></table></figure><p>权限字段说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[文件类型][所有者权限][组权限][其他用户权限]</span><br><span class="line">d rwx r-x r-x</span><br></pre></td></tr></table></figure><ul><li>文件类型：<code>-</code>普通文件，<code>d</code>目录，<code>l</code>链接文件</li><li>权限组成：<code>r</code>读(4) + <code>w</code>写(2) + <code>x</code>执行(1)</li></ul><h2 id="2-帮助系统">2. 帮助系统</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">man &lt;<span class="built_in">command</span>&gt;  <span class="comment"># 查看命令手册</span></span><br><span class="line">man <span class="built_in">ls</span>         <span class="comment"># 示例：查看ls命令手册</span></span><br></pre></td></tr></table></figure><p>常用操作键：</p><ul><li>空格键：向下翻页</li><li><code>q</code>：退出手册</li><li><code>/</code>：搜索内容</li></ul><h2 id="3-用户管理">3. 用户管理</h2><h3 id="3-1-用户查看命令">3.1 用户查看命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">whoami</span>        <span class="comment"># 显示当前用户名</span></span><br><span class="line"><span class="built_in">who</span> am i      <span class="comment"># 显示登录信息</span></span><br><span class="line"><span class="built_in">who</span> -m        <span class="comment"># 同&quot;who am i&quot;</span></span><br><span class="line"><span class="built_in">who</span> mom likes <span class="comment"># 显示特定用户信息（需实际用户存在）</span></span><br></pre></td></tr></table></figure><h3 id="3-2-用户操作">3.2 用户操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户（自动创建home目录）</span></span><br><span class="line"><span class="built_in">sudo</span> adduser lilei</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已创建用户</span></span><br><span class="line"><span class="built_in">ls</span> /home</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换用户</span></span><br><span class="line">su -l lilei   <span class="comment"># &quot;-l&quot;模拟完整登录环境</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除用户及home目录</span></span><br><span class="line"><span class="built_in">sudo</span> deluser lilei --remove-home</span><br></pre></td></tr></table></figure><h2 id="4-用户组管理">4. 用户组管理</h2><h3 id="4-1-用户组查看">4.1 用户组查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看指定用户所属组</span></span><br><span class="line"><span class="built_in">groups</span> shiyanlou</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有组（按字母排序）</span></span><br><span class="line"><span class="built_in">cat</span> /etc/group | <span class="built_in">sort</span></span><br></pre></td></tr></table></figure><p><code>/etc/group</code> 文件格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group_name:password:GID:user_list</span><br></pre></td></tr></table></figure><h3 id="4-2-用户组操作">4.2 用户组操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加用户到组（需要root权限）</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG <span class="built_in">sudo</span> lilei  <span class="comment"># 示例：添加sudo组</span></span><br></pre></td></tr></table></figure><h2 id="5-权限管理">5. 权限管理</h2><h3 id="5-1-文件权限修改">5.1 文件权限修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变更文件所有者</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> shiyanlou iphone6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变更文件所属组</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chgrp</span> group_name file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改所有权限（所有者/组/其他用户）</span></span><br><span class="line"><span class="built_in">chmod</span> 755 filename  <span class="comment"># rwxr-xr-x</span></span><br></pre></td></tr></table></figure><h3 id="5-2-权限数字表示法">5.2 权限数字表示法</h3><table><thead><tr><th>权限</th><th>数字</th></tr></thead><tbody><tr><td>r–</td><td>4</td></tr><tr><td>-w-</td><td>2</td></tr><tr><td>–x</td><td>1</td></tr><tr><td>rwx</td><td>7 (4+2+1)</td></tr></tbody></table><h2 id="6-文件类型说明">6. 文件类型说明</h2><p>Linux 一切皆文件，主要类型包括：</p><ul><li><code>-</code>：普通文件</li><li><code>d</code>：目录文件</li><li><code>l</code>：符号链接（相当于快捷方式）</li><li><code>c</code>：字符设备文件</li><li><code>b</code>：块设备文件</li><li><code>s</code>：套接字文件</li><li><code>p</code>：管道文件</li></ul><h2 id="7-重要补充说明">7. 重要补充说明</h2><ol><li><p>目录权限特殊含义：</p><ul><li>读权限：可查看目录内容</li><li>写权限：可创建/删除文件</li><li>执行权限：可进入目录</li></ul></li><li><p>新建用户默认会：</p><ul><li>创建同名用户组</li><li>在<code>/home</code>下创建用户目录</li><li>基本配置文件从<code>/etc/skel</code>复制</li></ul></li><li><p>sudo权限配置路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/sudoers</span><br><span class="line">/etc/sudoers.d/</span><br></pre></td></tr></table></figure></li></ol><p>建议后续可补充：</p><ul><li>实际权限修改案例</li><li>用户组管理实验</li><li>sudoers文件的配置方法</li><li>ACL高级权限控制</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql基础教程</title>
      <link href="/2015/10/12/mysql%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
      <url>/2015/10/12/mysql%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>为什么需要数据库？</p><p>因为应用程序需要保存用户的数据，比如Word需要把用户文档保存起来，以便下次继续编辑或者拷贝到另一台电脑。</p><p>要保存用户的数据，一个最简单的方法是把用户数据写入文件。例如，要保存一个班级所有学生的信息，可以向文件中写入一个CSV文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id,name,gender,score</span><br><span class="line">1,小明,M,90</span><br><span class="line">2,小红,F,95</span><br><span class="line">3,小军,M,88</span><br><span class="line">4,小丽,F,88</span><br></pre></td></tr></table></figure><p>如果要保存学校所有班级的信息，可以写入另一个CSV文件。</p><p>但是，随着应用程序的功能越来越复杂，数据量越来越大，如何管理这些数据就成了大问题：</p><ul><li>读写文件并解析出数据需要大量重复代码；</li><li>从成千上万的数据中快速查询出指定数据需要复杂的逻辑。</li></ul><p>如果每个应用程序都各自写自己的读写数据的代码，一方面效率低，容易出错，另一方面，每个应用程序访问数据的接口都不相同，数据难以复用。</p><p>所以，数据库作为一种专门管理数据的软件就出现了。应用程序不需要自己管理数据，而是通过数据库软件提供的接口来读写数据。至于数据本身如何存储到文件，那是数据库软件的事情，应用程序自己并不关心：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌───────────┐</span><br><span class="line">│application│</span><br><span class="line">└───────────┘</span><br><span class="line">     ▲ │</span><br><span class="line">     │ │</span><br><span class="line"> read│ │write</span><br><span class="line">     │ │</span><br><span class="line">     │ ▼</span><br><span class="line">┌───────────┐</span><br><span class="line">│ database  │</span><br><span class="line">└───────────┘</span><br></pre></td></tr></table></figure><p>这样一来，编写应用程序的时候，数据读写的功能就被大大地简化了。</p><h3 id="数据模型">数据模型</h3><p>数据库按照数据结构来组织、存储和管理数据，实际上，数据库一共有三种模型：</p><ul><li>层次模型</li><li>网状模型</li><li>关系模型</li></ul><p>层次模型就是以“上下级”的层次关系来组织数据的一种方式，层次模型的数据结构看起来就像一颗树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">            ┌─────┐</span><br><span class="line">            │     │</span><br><span class="line">            └─────┘</span><br><span class="line">               │</span><br><span class="line">       ┌───────┴───────┐</span><br><span class="line">       │               │</span><br><span class="line">    ┌─────┐         ┌─────┐</span><br><span class="line">    │     │         │     │</span><br><span class="line">    └─────┘         └─────┘</span><br><span class="line">       │               │</span><br><span class="line">   ┌───┴───┐       ┌───┴───┐</span><br><span class="line">   │       │       │       │</span><br><span class="line">┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐</span><br><span class="line">│     │ │     │ │     │ │     │</span><br><span class="line">└─────┘ └─────┘ └─────┘ └─────┘</span><br></pre></td></tr></table></figure><p>网状模型把每个数据节点和其他很多节点都连接起来，它的数据结构看起来就像很多城市之间的路网：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     ┌─────┐      ┌─────┐</span><br><span class="line">   ┌─│     │──────│     │──┐</span><br><span class="line">   │ └─────┘      └─────┘  │</span><br><span class="line">   │    │            │     │</span><br><span class="line">   │    └──────┬─────┘     │</span><br><span class="line">   │           │           │</span><br><span class="line">┌─────┐     ┌─────┐     ┌─────┐</span><br><span class="line">│     │─────│     │─────│     │</span><br><span class="line">└─────┘     └─────┘     └─────┘</span><br><span class="line">   │           │           │</span><br><span class="line">   │     ┌─────┴─────┐     │</span><br><span class="line">   │     │           │     │</span><br><span class="line">   │  ┌─────┐     ┌─────┐  │</span><br><span class="line">   └──│     │─────│     │──┘</span><br><span class="line">      └─────┘     └─────┘</span><br></pre></td></tr></table></figure><p>关系模型把数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，它的数据模型看起来就是一个Excel表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌─────┬─────┬─────┬─────┬─────┐</span><br><span class="line">│     │     │     │     │     │</span><br><span class="line">├─────┼─────┼─────┼─────┼─────┤</span><br><span class="line">│     │     │     │     │     │</span><br><span class="line">├─────┼─────┼─────┼─────┼─────┤</span><br><span class="line">│     │     │     │     │     │</span><br><span class="line">├─────┼─────┼─────┼─────┼─────┤</span><br><span class="line">│     │     │     │     │     │</span><br><span class="line">└─────┴─────┴─────┴─────┴─────┘</span><br></pre></td></tr></table></figure><p>随着时间的推移和市场竞争，最终，基于关系模型的关系数据库获得了绝对市场份额。</p><p>为什么关系数据库获得了最广泛的应用？</p><p>因为相比层次模型和网状模型，关系模型理解和使用起来最简单。</p><p>关系数据库的关系模型是基于数学理论建立的。我们把域（Domain）定义为一组具有相同数据类型的值的集合，给定一组域D1,D2,…,Dn，它们的笛卡尔集定义为D1×D2×……×Dn={(d1,d2,…,dn)|di∈Di,i=1,2,…,n}， 而D1×D2×……×Dn的子集叫作在域D1,D2,…,Dn上的关系，表示为R(D1,D2,…,Dn)，这里的R表示#%&amp;^@!&amp;$#;!~％¥%……算了，根本讲不明白，大家也不用理解。</p><p>基于数学理论的关系模型虽然讲起来挺复杂，但是，基于日常生活的关系模型却十分容易理解。我们以学校班级为例，一个班级的学生就可以用一个表格存起来，并且定义如下：</p><table><thead><tr><th>ID</th><th>姓名</th><th>班级ID</th><th>性别</th><th>年龄</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>201</td><td>M</td><td>9</td></tr><tr><td>2</td><td>小红</td><td>202</td><td>F</td><td>8</td></tr><tr><td>3</td><td>小军</td><td>202</td><td>M</td><td>8</td></tr><tr><td>4</td><td>小白</td><td>201</td><td>F</td><td>9</td></tr></tbody></table><p>其中，班级ID对应着另一个班级表：</p><table><thead><tr><th>ID</th><th>名称</th><th>班主任</th></tr></thead><tbody><tr><td>201</td><td>二年级一班</td><td>王老师</td></tr><tr><td>202</td><td>二年级二班</td><td>李老师</td></tr></tbody></table><p>通过给定一个班级名称，可以查到一条班级记录，根据班级ID，又可以查到多条学生记录，这样，二维表之间就通过ID映射建立了“一对多”关系。</p><h3 id="数据类型">数据类型</h3><p>对于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>INT</td><td>整型</td><td>4字节整数类型，范围约+/-21亿</td></tr><tr><td>BIGINT</td><td>长整型</td><td>8字节整数类型，范围约+/-922亿亿</td></tr><tr><td>REAL</td><td>浮点型</td><td>4字节浮点数，范围约+/-1038</td></tr><tr><td>DOUBLE</td><td>浮点型</td><td>8字节浮点数，范围约+/-10308</td></tr><tr><td>DECIMAL(M,N)</td><td>高精度小数</td><td>由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算</td></tr><tr><td>CHAR(N)</td><td>定长字符串</td><td>存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串</td></tr><tr><td>VARCHAR(N)</td><td>变长字符串</td><td>存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串</td></tr><tr><td>BOOLEAN</td><td>布尔类型</td><td>存储True或者False</td></tr><tr><td>DATE</td><td>日期类型</td><td>存储日期，例如，2018-06-22</td></tr><tr><td>TIME</td><td>时间类型</td><td>存储时间，例如，12:20:59</td></tr><tr><td>DATETIME</td><td>日期和时间类型</td><td>存储日期+时间，例如，2018-06-22 12:20:59</td></tr></tbody></table><p>上面的表中列举了最常用的数据类型。很多数据类型还有别名，例如，<code>REAL</code>又可以写成<code>FLOAT(24)</code>。还有一些不常用的数据类型，例如，<code>TINYINT</code>（范围在0~255）。各数据库厂商还会支持特定的数据类型，例如<code>JSON</code>。</p><p>选择数据类型的时候，要根据业务规则选择合适的类型。通常来说，<code>BIGINT</code>能满足整数存储的需求，<code>VARCHAR(N)</code>能满足字符串存储的需求，这两种类型是使用最广泛的。</p><h3 id="主流关系数据库">主流关系数据库</h3><p>目前，主流的关系数据库主要分为以下几类：</p><ol><li>商用数据库，例如：<a href="https://www.oracle.com/">Oracle</a>，<a href="https://www.microsoft.com/sql-server/">SQL Server</a>，<a href="https://www.ibm.com/db2/">DB2</a>等；</li><li>开源数据库，例如：<a href="https://www.mysql.com/">MySQL</a>，<a href="https://www.postgresql.org/">PostgreSQL</a>等；</li><li>桌面数据库，以微软<a href="https://products.office.com/access">Access</a>为代表，适合桌面应用程序使用；</li><li>嵌入式数据库，以<a href="https://sqlite.org/">Sqlite</a>为代表，适合手机应用和桌面程序。</li></ol><h3 id="SQL">SQL</h3><p>什么是SQL？SQL是结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。不同的数据库，都支持SQL，这样，我们通过学习SQL这一种语言，就可以操作各种不同的数据库。</p><p>虽然SQL已经被ANSI组织定义为标准，不幸地是，各个不同的数据库对标准的SQL支持不太一致。并且，大部分数据库都在标准的SQL上做了扩展。也就是说，如果只使用标准SQL，理论上所有数据库都可以支持，但如果使用某个特定数据库的扩展SQL，换一个数据库就不能执行了。例如，Oracle把自己扩展的SQL称为<code>PL/SQL</code>，Microsoft把自己扩展的SQL称为<code>T-SQL</code>。</p><p>现实情况是，如果我们只使用标准SQL的核心功能，那么所有数据库通常都可以执行。不常用的SQL功能，不同的数据库支持的程度都不一样。而各个数据库支持的各自扩展的功能，通常我们把它们称之为“方言”。</p><p>总的来说，SQL语言定义了这么几种操作数据库的能力：</p><h4 id="DDL：Data-Definition-Language">DDL：Data Definition Language</h4><p>DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。</p><h4 id="DML：Data-Manipulation-Language">DML：Data Manipulation Language</h4><p>DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。</p><h4 id="DQL：Data-Query-Language">DQL：Data Query Language</h4><p>DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。</p><h3 id="语法特点">语法特点</h3><p>SQL语言关键字不区分大小写！！！但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。同一个数据库，有的在Linux上区分大小写，有的在Windows上不区分大小写。</p><p>所以，本教程约定：SQL关键字总是大写，以示突出，表名和列名均使用小写。</p><p>MySQL是目前应用最广泛的开源关系数据库。MySQL最早是由瑞典的MySQL AB公司开发，该公司在2008年被SUN公司收购，紧接着，SUN公司在2009年被Oracle公司收购，所以MySQL最终就变成了Oracle旗下的产品。</p><p>和其他关系数据库有所不同的是，MySQL本身实际上只是一个SQL接口，它的内部还包含了多种数据引擎，常用的包括：</p><ul><li>InnoDB：由Innobase Oy公司开发的一款支持事务的数据库引擎，2006年被Oracle收购；</li><li>MyISAM：MySQL早期集成的默认数据库引擎，不支持事务。</li></ul><p>MySQL接口和数据库引擎的关系就好比某某浏览器和浏览器引擎（IE引擎或Webkit引擎）的关系。对用户而言，切换浏览器引擎不影响浏览器界面，切换MySQL引擎不影响自己写的应用程序使用MySQL的接口。</p><p>使用MySQL时，不同的表还可以使用不同的数据库引擎。如果你不知道应该采用哪种引擎，记住总是选择<em>InnoDB</em>就好了。</p><p>因为MySQL一开始就是开源的，所以基于MySQL的开源版本，又衍生出了各种版本：</p><h3 id="MariaDB">MariaDB</h3><p>由MySQL的创始人创建的一个开源分支版本，使用XtraDB引擎。</p><h3 id="Aurora">Aurora</h3><p>由Amazon改进的一个MySQL版本，专门提供给在AWS托管MySQL用户，号称5倍的性能提升。</p><h3 id="PolarDB">PolarDB</h3><p>由Alibaba改进的一个MySQL版本，专门提供给在阿里云托管的MySQL用户，号称6倍的性能提升。</p><p>而MySQL官方版本又分了好几个版本：</p><ul><li>Community Edition：社区开源版本，免费；</li><li>Standard Edition：标准版；</li><li>Enterprise Edition：企业版；</li><li>Cluster Carrier Grade Edition：集群版。</li></ul><p>以上版本的功能依次递增，价格也依次递增。不过，功能增加的主要是监控、集群等管理功能，对于基本的SQL功能是完全一样的。</p><p>所以使用MySQL就带来了一个巨大的好处：可以在自己的电脑上安装免费的Community Edition版本，进行学习、开发、测试，部署的时候，可以选择付费的高级版本，或者云服务商提供的兼容版本，而不需要对应用程序本身做改动。</p><h3 id="安装MySQL">安装MySQL</h3><p>要安装MySQL，可以从MySQL官方网站下载最新的MySQL Community Server版本：</p><p><a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></p><p>选择对应的操作系统版本，下载安装即可。在安装过程中，MySQL会自动创建一个<code>root</code>用户，并提示输入<code>root</code>口令。</p><p>要在Linux上安装MySQL，可以使用发行版的包管理器。例如，Debian和Ubuntu用户可以简单地通过命令<code>apt install mysql-server</code>安装最新的MySQL版本。</p><p>MySQL安装后会自动在后台运行。为了验证MySQL安装是否正确，我们需要通过<code>mysql</code>这个命令行程序来连接MySQL服务器。</p><p>在命令提示符下输入<code>mysql -u root -p</code>，然后输入口令，如果一切正确，就会连接到MySQL服务器，同时提示符变为<code>mysql&gt;</code>。</p><p>输入<code>exit</code>退出MySQL命令行。注意，MySQL服务器仍在后台运行。</p><h3 id="使用Docker运行MySQL">使用Docker运行MySQL</h3><p>另一种运行MySQL的方式不需要下载安装包，而是直接通过Docker安装最新的MySQL：</p><p>首先安装<a href="https://www.docker.com/products/docker-desktop/">Docker Desktop</a>，然后在命令行输入以下命令拉取MySQL最新版：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull mysql</span><br></pre></td></tr></table></figure><p>拉取完成后，输入以下命令直接启动MySQL服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=password -v /Users/chankein/mysql-data:/var/lib/mysql mysql</span><br></pre></td></tr></table></figure><p>命令<code>docker run</code>表示启动一个容器，后面各参数含义如下：</p><ul><li><code>-d</code>：表示在后台执行；</li><li><code>--name mysql</code>：表示容器的名字，不输入Docker会自动选择一个名字；</li><li><code>-p 3306:3306</code>：表示把容器的端口3306映射到本机，这样可以在本机通过3306端口连接MySQL；</li><li><code>-e MYSQL_ROOT_PASSWORD=password</code>：表示传入一个环境变量，作为root的口令，这里设置的口令是<code>password</code>，不输入此项则会自动生成一个口令，需要查看日志才能知道口令；</li><li><code>-v /Users/chankein/mysql-data:/var/lib/mysql</code>：表示将本地目录映射到容器目录<code>/var/lib/mysql</code>作为MySQL数据库存放的位置，需要将<code>/Users/chankein/mysql-data</code>改为你的电脑上的实际目录；</li><li><code>mysql</code>：最后一个参数是Docker镜像的名称。</li></ul><p>可以在Docker Desktop的管理窗口中选择<code>Containers</code>，看到正在运行的MySQL：</p><p><img src="https://liaoxuefeng.com/books/sql/rdbms/install-mysql/docker-mysql.png" alt="docker-mysql"></p><p>点击MySQL查看日志：</p><p><img src="https://liaoxuefeng.com/books/sql/rdbms/install-mysql/docker-mysql-log.png" alt="docker-mysql-log"></p><p>点击Exec进入命令行，输入命令<code>mysql -u root -p</code>，输入口令，即可进入MySQL命令行界面：</p><p><img src="https://liaoxuefeng.com/books/sql/rdbms/install-mysql/docker-mysql-exec.png" alt="docker-mysql-exec"></p><p>使用Docker运行MySQL时，任何时候都可以删除MySQL容器并重新运行。如果删除了本地映射的目录，重新运行就相当于一个全新的MySQL，因此，建议仅作为学习和开发使用，不要存储重要的数据。</p><h2 id="关系模型">关系模型</h2><p>我们已经知道，关系数据库是建立在关系模型上的。而关系模型本质上就是若干个存储数据的二维表，可以把它们看作很多Excel表。</p><p>表的每一行称为记录（Record），记录是一个逻辑意义上的数据。</p><p>表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。</p><p>字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为<code>NULL</code>。注意<code>NULL</code>表示字段数据不存在。一个整型字段如果为<code>NULL</code>不表示它的值为<code>0</code>，同样的，一个字符串型字段为<code>NULL</code>也不表示它的值为空串<code>''</code>。</p><p>提示</p><p>通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。</p><p>和Excel表有所不同的是，关系数据库的表和表之间需要建立“一对多”，“多对一”和“一对一”的关系，这样才能够按照应用程序的逻辑来组织和存储数据。</p><p>例如，一个班级表：</p><table><thead><tr><th>ID</th><th>名称</th><th>班主任</th></tr></thead><tbody><tr><td>201</td><td>二年级一班</td><td>王老师</td></tr><tr><td>202</td><td>二年级二班</td><td>李老师</td></tr></tbody></table><p>每一行对应着一个班级，而一个班级对应着多个学生，所以班级表和学生表的关系就是“一对多”：</p><table><thead><tr><th>ID</th><th>姓名</th><th>班级ID</th><th>性别</th><th>年龄</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>201</td><td>M</td><td>9</td></tr><tr><td>2</td><td>小红</td><td>202</td><td>F</td><td>8</td></tr><tr><td>3</td><td>小军</td><td>202</td><td>M</td><td>8</td></tr><tr><td>4</td><td>小白</td><td>201</td><td>F</td><td>9</td></tr></tbody></table><p>反过来，如果我们先在学生表中定位了一行记录，例如<code>ID=1</code>的小明，要确定他的班级，只需要根据他的“班级ID”对应的值<code>201</code>找到班级表中<code>ID=201</code>的记录，即二年级一班。所以，学生表和班级表是“多对一”的关系。</p><p>如果我们把班级表分拆得细一点，例如，单独创建一个教师表：</p><table><thead><tr><th>ID</th><th>名称</th><th>年龄</th></tr></thead><tbody><tr><td>A1</td><td>王老师</td><td>26</td></tr><tr><td>A2</td><td>张老师</td><td>39</td></tr><tr><td>A3</td><td>李老师</td><td>32</td></tr><tr><td>A4</td><td>赵老师</td><td>27</td></tr></tbody></table><p>班级表只存储教师ID：</p><table><thead><tr><th>ID</th><th>名称</th><th>班主任ID</th></tr></thead><tbody><tr><td>201</td><td>二年级一班</td><td>A1</td></tr><tr><td>202</td><td>二年级二班</td><td>A3</td></tr></tbody></table><p>这样，一个班级总是对应一个教师，班级表和教师表就是“一对一”关系。</p><p>在关系数据库中，关系是通过<em>主键</em>和<em>外键</em>来维护的。我们在后面会分别深入讲解。</p><h2 id="主键">主键</h2><p>在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。例如，<code>students</code>表的两行记录：</p><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>gender</th><th>score</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>M</td><td>90</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>F</td><td>95</td></tr></tbody></table><p>每一条记录都包含若干定义好的字段。同一个表的所有记录都有相同的字段定义。</p><p>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为<em>主键</em>。</p><p>例如，假设我们把<code>name</code>字段作为主键，那么通过名字<code>小明</code>或<code>小红</code>就能唯一确定一条记录。但是，这么设定，就没法存储同名的同学了，因为插入相同主键的两条记录是不被允许的。</p><p>对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。</p><p>由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。</p><p>所以，选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。</p><p>因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均<em>不可</em>用作主键。</p><p>作为主键最好是完全业务无关的字段，我们一般把这个字段命名为<code>id</code>。常见的可作为<code>id</code>字段的类型有：</p><ol><li>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</li><li>全局唯一GUID类型：也称UUID，使用一种全局唯一的字符串作为主键，类似<code>8f55d96b-8acc-4636-8cb8-76bf8abc2f57</code>。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</li></ol><p>对于大部分应用来说，通常自增类型的主键就能满足需求。我们在<code>students</code>表中定义的主键也是<code>BIGINT NOT NULL AUTO_INCREMENT</code>类型。</p><p>注意</p><p>如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。</p><h3 id="联合主键">联合主键</h3><p>关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。</p><p>对于联合主键，允许一列有重复，只要不是所有主键列都重复即可：</p><table><thead><tr><th>id_num</th><th>id_type</th><th>other columns…</th></tr></thead><tbody><tr><td>1</td><td>A</td><td>…</td></tr><tr><td>2</td><td>A</td><td>…</td></tr><tr><td>2</td><td>B</td><td>…</td></tr></tbody></table><p>如果我们把上述表的<code>id_num</code>和<code>id_type</code>这两列作为联合主键，那么上面的3条记录都是允许的，因为没有两列主键组合起来是相同的。</p><p>没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。</p><h3 id="小结">小结</h3><p>主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许<code>NULL</code>。</p><p>可以使用多个列作为联合主键，但联合主键并不常用。</p><p>当我们用主键唯一标识记录时，我们就可以在<code>students</code>表中确定任意一个学生的记录：</p><table><thead><tr><th>id</th><th>name</th><th>other columns…</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>…</td></tr><tr><td>2</td><td>小红</td><td>…</td></tr></tbody></table><p>我们还可以在<code>classes</code>表中确定任意一个班级记录：</p><table><thead><tr><th>id</th><th>name</th><th>other columns…</th></tr></thead><tbody><tr><td>1</td><td>一班</td><td>…</td></tr><tr><td>2</td><td>二班</td><td>…</td></tr></tbody></table><p>但是我们如何确定<code>students</code>表的一条记录，例如，<code>id=1</code>的小明，属于哪个班级呢？</p><p>由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个<code>classes</code>的记录可以对应多个<code>students</code>表的记录。</p><p>为了表达这种一对多的关系，我们需要在<code>students</code>表中加入一列<code>class_id</code>，让它的值与<code>classes</code>表的某条记录相对应：</p><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>other columns…</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>…</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>…</td></tr><tr><td>5</td><td>2</td><td>小白</td><td>…</td></tr></tbody></table><p>这样，我们就可以根据<code>class_id</code>这个列直接定位出一个<code>students</code>表的记录应该对应到<code>classes</code>的哪条记录。</p><p>例如：</p><ul><li>小明的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li><li>小红的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li><li>小白的<code>class_id</code>是<code>2</code>，因此，对应的<code>classes</code>表的记录是<code>id=2</code>的二班。</li></ul><p>在<code>students</code>表中，通过<code>class_id</code>的字段，可以把数据与另一张表关联起来，这种列称为<code>外键</code>。</p><p>外键并不是通过列名实现的，而是通过定义外键约束实现的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD CONSTRAINT</span> fk_class_id</span><br><span class="line"><span class="keyword">FOREIGN KEY</span> (class_id)</span><br><span class="line"><span class="keyword">REFERENCES</span> classes (id);</span><br></pre></td></tr></table></figure><p>其中，外键约束的名称<code>fk_class_id</code>可以任意，<code>FOREIGN KEY (class_id)</code>指定了<code>class_id</code>作为外键，<code>REFERENCES classes (id)</code>指定了这个外键将关联到<code>classes</code>表的<code>id</code>列（即<code>classes</code>表的主键）。</p><p>通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果<code>classes</code>表不存在<code>id=99</code>的记录，<code>students</code>表就无法插入<code>class_id=99</code>的记录。</p><p>由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，<code>class_id</code>仅仅是一个普通的列，只是它起到了外键的作用而已。</p><p>要删除一个外键约束，也是通过<code>ALTER TABLE</code>实现的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FOREIGN KEY</span> fk_class_id;</span><br></pre></td></tr></table></figure><p>注意：删除外键约束并没有删除外键这一列。删除列是通过<code>DROP COLUMN ...</code>实现的。</p><h3 id="多对多">多对多</h3><p>通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。</p><p>多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系：</p><p><code>teachers</code>表：</p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>张老师</td></tr><tr><td>2</td><td>王老师</td></tr><tr><td>3</td><td>李老师</td></tr><tr><td>4</td><td>赵老师</td></tr></tbody></table><p><code>classes</code>表：</p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>一班</td></tr><tr><td>2</td><td>二班</td></tr></tbody></table><p>中间表<code>teacher_class</code>关联两个一对多关系：</p><table><thead><tr><th>id</th><th>teacher_id</th><th>class_id</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>1</td><td>2</td></tr><tr><td>3</td><td>2</td><td>1</td></tr><tr><td>4</td><td>2</td><td>2</td></tr><tr><td>5</td><td>3</td><td>1</td></tr><tr><td>6</td><td>4</td><td>2</td></tr></tbody></table><p>通过中间表<code>teacher_class</code>可知<code>teachers</code>到<code>classes</code>的关系：</p><ul><li><code>id=1</code>的张老师对应<code>id=1,2</code>的一班和二班；</li><li><code>id=2</code>的王老师对应<code>id=1,2</code>的一班和二班；</li><li><code>id=3</code>的李老师对应<code>id=1</code>的一班；</li><li><code>id=4</code>的赵老师对应<code>id=2</code>的二班。</li></ul><p>同理可知<code>classes</code>到<code>teachers</code>的关系：</p><ul><li><code>id=1</code>的一班对应<code>id=1,2,3</code>的张老师、王老师和李老师；</li><li><code>id=2</code>的二班对应<code>id=1,2,4</code>的张老师、王老师和赵老师；</li></ul><p>因此，通过中间表，我们就定义了一个“多对多”关系。</p><h3 id="一对一">一对一</h3><p>一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。</p><p>例如，<code>students</code>表的每个学生可以有自己的联系方式，如果把联系方式存入另一个表<code>contacts</code>，我们就可以得到一个“一对一”关系：</p><table><thead><tr><th>id</th><th>student_id</th><th>mobile</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>135xxxx6300</td></tr><tr><td>2</td><td>2</td><td>138xxxx2209</td></tr><tr><td>3</td><td>5</td><td>139xxxx8086</td></tr></tbody></table><p>有细心的童鞋会问，既然是一对一关系，那为啥不给<code>students</code>表增加一个<code>mobile</code>列，这样就能合二为一了？</p><p>如果业务允许，完全可以把两个表合为一个表。但是，有些时候，如果某个学生没有手机号，那么，<code>contacts</code>表就不存在对应的记录。实际上，一对一关系准确地说，是<code>contacts</code>表一对一对应<code>students</code>表。</p><p>还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表<code>user_info</code>和用户详细信息表<code>user_profiles</code>，大部分时候，只需要查询<code>user_info</code>表，并不需要查询<code>user_profiles</code>表，这样就提高了查询速度。</p><h3 id="小结-2">小结</h3><p>关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。</p><p>在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。</p><p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。</p><p>例如，对于<code>students</code>表：</p><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>gender</th><th>score</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>M</td><td>90</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>F</td><td>95</td></tr><tr><td>3</td><td>1</td><td>小军</td><td>M</td><td>88</td></tr></tbody></table><p>如果要经常根据<code>score</code>列进行查询，就可以对<code>score</code>列创建索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_score (score);</span><br></pre></td></tr></table></figure><p>使用<code>ADD INDEX idx_score (score)</code>就创建了一个名称为<code>idx_score</code>，使用列<code>score</code>的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_name_score (name, score);</span><br></pre></td></tr></table></figure><p>索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如<code>gender</code>列，大约一半的记录值是<code>M</code>，另一半是<code>F</code>，因此，对该列创建索引就没有意义。</p><p>可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。</p><p>对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。</p><h3 id="唯一索引">唯一索引</h3><p>在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。</p><p>但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。例如，我们假设<code>students</code>表的<code>name</code>不能重复：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX uni_name (name);</span><br></pre></td></tr></table></figure><p>通过<code>UNIQUE</code>关键字我们就添加了一个唯一索引。</p><p>也可以只对某一列添加一个唯一约束而不创建唯一索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD CONSTRAINT</span> uni_name <span class="keyword">UNIQUE</span> (name);</span><br></pre></td></tr></table></figure><p>这种情况下，<code>name</code>列没有索引，但仍然具有唯一性保证。</p><p>无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。</p><h3 id="小结-3">小结</h3><p>通过对数据库表创建索引，可以提高查询速度；</p><p>通过创建唯一索引，可以保证某一列的值具有唯一性；</p><p>数据库索引对于用户和应用程序来说都是透明的。</p><p>在关系数据库中，最常用的操作就是查询。</p><h3 id="准备数据">准备数据</h3><p>为了便于讲解和练习，我们先准备好了一个<code>students</code>表和一个<code>classes</code>表，它们的结构和数据如下：</p><p><code>students</code>表存储了学生信息：</p><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>gender</th><th>score</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>M</td><td>90</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>F</td><td>95</td></tr><tr><td>3</td><td>1</td><td>小军</td><td>M</td><td>88</td></tr><tr><td>4</td><td>1</td><td>小米</td><td>F</td><td>73</td></tr><tr><td>5</td><td>2</td><td>小白</td><td>F</td><td>81</td></tr><tr><td>6</td><td>2</td><td>小兵</td><td>M</td><td>55</td></tr><tr><td>7</td><td>2</td><td>小林</td><td>M</td><td>85</td></tr><tr><td>8</td><td>3</td><td>小新</td><td>F</td><td>91</td></tr><tr><td>9</td><td>3</td><td>小王</td><td>M</td><td>89</td></tr><tr><td>10</td><td>3</td><td>小丽</td><td>F</td><td>85</td></tr></tbody></table><p><code>classes</code>表存储了班级信息：</p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>一班</td></tr><tr><td>2</td><td>二班</td></tr><tr><td>3</td><td>三班</td></tr><tr><td>4</td><td>四班</td></tr></tbody></table><p>请注意，和<code>MySQL</code>的持久化存储不同的是，由于我们使用的是<a href="https://alasql.org/">AlaSQL</a>内存数据库，两张表的数据在页面加载时导入，并且只存在于浏览器的内存中，因此，刷新页面后，数据会重置为上述初始值。</p><h3 id="MySQL">MySQL</h3><p>如果你想用MySQL练习，可以<a href="https://liaoxuefeng.com/books/sql/query/mysql-init-test-data.sql">下载这个SQL脚本</a>，然后在命令行运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u root -p &lt; init-test-data.sql</span><br></pre></td></tr></table></figure><p>就可以自动创建<code>test</code>数据库，并且在<code>test</code>数据库下创建<code>students</code>表和<code>classes</code>表，以及必要的初始化数据。</p><p>和内存数据库不同的是，对MySQL数据库做的所有修改，都会保存下来。如果你希望恢复到初始状态，可以再次运行该脚本。</p><h2 id="基本查询">基本查询</h2><p>要查询数据库表的数据，我们使用如下的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>假设表名是<code>students</code>，要查询<code>students</code>表的所有行，我们用如下SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询students表的所有数据</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>使用<code>SELECT * FROM students</code>时，<code>SELECT</code>是关键字，表示将要执行一个查询，<code>*</code>表示“所有列”，<code>FROM</code>表示将要从哪个表查询，本例中是<code>students</code>表。</p><p>该SQL将查询出<code>students</code>表的所有数据。注意：查询结果也是一个二维表，它包含列名和每一行的数据。</p><p>要查询<code>classes</code>表的所有行，我们用如下SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询classes表的所有数据</span><br><span class="line">SELECT * FROM classes;</span><br></pre></td></tr></table></figure><p>运行上述SQL语句，观察查询结果。</p><p><code>SELECT</code>语句其实并不要求一定要有<code>FROM</code>子句。我们来试试下面的<code>SELECT</code>语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 计算100+200</span><br><span class="line">SELECT 100+200;</span><br></pre></td></tr></table></figure><p>上述查询会直接计算出表达式的结果。虽然<code>SELECT</code>可以用作计算，但它并不是SQL的强项。但是，不带<code>FROM</code>子句的<code>SELECT</code>语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条<code>SELECT 1;</code>来测试数据库连接。</p><h3 id="小结-4">小结</h3><p>使用SELECT查询的基本语句<code>SELECT * FROM &lt;表名&gt;</code>可以查询一个表的所有行和所有列的数据；</p><p>SELECT查询的结果是一个二维表。</p><p>使用<code>SELECT * FROM &lt;表名&gt;</code>可以查询到一张表的所有记录。但是，很多时候，我们并不希望获得所有记录，而是根据条件选择性地获取指定条件的记录，例如，查询分数在80分以上的学生记录。在一张表有数百万记录的情况下，获取所有记录不仅费时，还费内存和网络带宽。</p><p>SELECT语句可以通过<code>WHERE</code>条件来设定查询条件，查询结果是满足查询条件的记录。例如，要指定条件“分数在80分或以上的学生”，写成<code>WHERE</code>条件就是<code>SELECT * FROM students WHERE score &gt;= 80</code>。</p><p>其中，<code>WHERE</code>关键字后面的<code>score &gt;= 80</code>就是条件。<code>score</code>是列名，该列存储了学生的成绩，因此，<code>score &gt;= 80</code>就筛选出了指定条件的记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按条件查询students:</span><br><span class="line">SELECT * FROM students WHERE score &gt;= 80;</span><br></pre></td></tr></table></figure><p>因此，条件查询的语法就是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>条件表达式可以用<code>&lt;条件1&gt; AND &lt;条件2&gt;</code>表达满足条件1并且满足条件2。例如，符合条件“分数在80分或以上”，并且还符合条件“男生”，把这两个条件写出来：</p><ul><li>条件1：根据score列的数据判断：<code>score &gt;= 80</code>；</li><li>条件2：根据gender列的数据判断：<code>gender = 'M'</code>，注意<code>gender</code>列存储的是字符串，需要用单引号括起来。</li></ul><p>就可以写出<code>WHERE</code>条件：<code>score &gt;= 80 AND gender = 'M'</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按AND条件查询students:</span><br><span class="line">SELECT * FROM students WHERE score &gt;= 80 AND gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure><p>第二种条件是<code>&lt;条件1&gt; OR &lt;条件2&gt;</code>，表示满足条件1或者满足条件2。例如，把上述<code>AND</code>查询的两个条件改为<code>OR</code>，查询结果就是“分数在80分或以上”或者“男生”，满足任意之一的条件即选出该记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按OR条件查询students:</span><br><span class="line">SELECT * FROM students WHERE score &gt;= 80 OR gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure><p>很显然<code>OR</code>条件要比<code>AND</code>条件宽松，返回的符合条件的记录也更多。</p><p>第三种条件是<code>NOT &lt;条件&gt;</code>，表示“不符合该条件”的记录。例如，写一个“不是2班的学生”这个条件，可以先写出“是2班的学生”：<code>class_id = 2</code>，再加上<code>NOT</code>：<code>NOT class_id = 2</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按NOT条件查询students:</span><br><span class="line">SELECT * FROM students WHERE NOT class_id = 2;</span><br></pre></td></tr></table></figure><p>上述<code>NOT</code>条件<code>NOT class_id = 2</code>其实等价于<code>class_id &lt;&gt; 2</code>，因此，<code>NOT</code>查询不是很常用。</p><p>要组合三个或者更多的条件，就需要用小括号<code>()</code>表示如何进行条件运算。例如，编写一个复杂的条件：分数在80以下或者90以上，并且是男生：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按多个条件查询students:</span><br><span class="line">SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure><p>如果不加括号，条件运算按照<code>NOT</code>、<code>AND</code>、<code>OR</code>的优先级进行，即<code>NOT</code>优先级最高，其次是<code>AND</code>，最后是<code>OR</code>。加上括号可以改变优先级。</p><h3 id="常用的条件表达式">常用的条件表达式</h3><table><thead><tr><th>条件</th><th>表达式举例1</th><th>表达式举例2</th><th>说明</th></tr></thead><tbody><tr><td>使用=判断相等</td><td>score = 80</td><td>name = ‘abc’</td><td>字符串需要用单引号括起来</td></tr><tr><td>使用&gt;判断大于</td><td>score &gt; 80</td><td>name &gt; ‘abc’</td><td>字符串比较根据ASCII码，中文字符比较根据数据库设置</td></tr><tr><td>使用&gt;=判断大于或相等</td><td>score &gt;= 80</td><td>name &gt;= ‘abc’</td><td></td></tr><tr><td>使用&lt;判断小于</td><td>score &lt; 80</td><td>name &lt;= ‘abc’</td><td></td></tr><tr><td>使用&lt;=判断小于或相等</td><td>score &lt;= 80</td><td>name &lt;= ‘abc’</td><td></td></tr><tr><td>使用&lt;&gt;判断不相等</td><td>score &lt;&gt; 80</td><td>name &lt;&gt; ‘abc’</td><td></td></tr><tr><td>使用LIKE判断相似</td><td>name LIKE ‘ab%’</td><td>name LIKE ‘%bc%’</td><td>%表示任意字符，例如’ab%‘将匹配’ab’，‘abc’，‘abcd’</td></tr></tbody></table><p>查询分数在60分(含)～90分(含)之间的学生可以使用的WHERE语句是：</p><h3 id="小结-5">小结</h3><p>通过<code>WHERE</code>条件查询，可以筛选出符合指定条件的记录，而不是整个表的所有记录。</p><h2 id="投影查询">投影查询</h2><p>使用<code>SELECT * FROM &lt;表名&gt; WHERE &lt;条件&gt;</code>可以选出表中的若干条记录。我们注意到返回的二维表结构和原表是相同的，即结果集的所有列与原表的所有列都一一对应。</p><p>如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用<code>SELECT 列1, 列2, 列3 FROM ...</code>，让结果集仅包含指定列。这种操作称为投影查询。</p><p>例如，从<code>students</code>表中返回<code>id</code>、<code>score</code>和<code>name</code>这三列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用投影查询</span><br><span class="line">SELECT id, score, name FROM students;</span><br></pre></td></tr></table></figure><p>这样返回的结果集就只包含了我们指定的列，并且，结果集的列的顺序和原表可以不一样。</p><p>使用<code>SELECT 列1, 列2, 列3 FROM ...</code>时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是<code>SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...</code>。</p><p>例如，以下<code>SELECT</code>语句将列名<code>score</code>重命名为<code>points</code>，而<code>id</code>和<code>name</code>列名保持不变：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用投影查询，并将列名重命名：</span><br><span class="line">SELECT id, score points, name FROM students;</span><br></pre></td></tr></table></figure><p>投影查询同样可以接<code>WHERE</code>条件，实现复杂的查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用投影查询+WHERE条件：</span><br><span class="line">SELECT id, score points, name FROM students WHERE gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure><h3 id="小结-6">小结</h3><p>使用<code>SELECT *</code>表示查询表的所有列，使用<code>SELECT 列1, 列2, 列3</code>则可以仅返回指定列，这种操作称为投影；</p><p><code>SELECT</code>语句可以对结果集的列进行重命名。</p><h2 id="排序">排序</h2><h3 id="排序-2">排序</h3><p>我们使用SELECT查询时，细心的读者可能注意到，查询结果集通常是按照<code>id</code>排序的，也就是根据主键排序。这也是大部分数据库的做法。如果我们要根据其他条件排序怎么办？可以加上<code>ORDER BY</code>子句。例如按照成绩从低到高进行排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按score从低到高:</span><br><span class="line">SELECT id, name, gender, score FROM students ORDER BY score;</span><br></pre></td></tr></table></figure><p>如果要反过来，按照成绩从高到底排序，我们可以加上<code>DESC</code>表示“倒序”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按score从高到低:</span><br><span class="line">SELECT id, name, gender, score FROM students ORDER BY score DESC;</span><br></pre></td></tr></table></figure><p>如果<code>score</code>列有相同的数据，要进一步排序，可以继续添加列名。例如，使用<code>ORDER BY score DESC, gender</code>表示先按<code>score</code>列倒序，如果有相同分数的，再按<code>gender</code>列排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按score, gender排序:</span><br><span class="line">SELECT id, name, gender, score FROM students ORDER BY score DESC, gender;</span><br></pre></td></tr></table></figure><p>默认的排序规则是<code>ASC</code>：“升序”，即从小到大。<code>ASC</code>可以省略，即<code>ORDER BY score ASC</code>和<code>ORDER BY score</code>效果一样。</p><p>如果有<code>WHERE</code>子句，那么<code>ORDER BY</code>子句要放到<code>WHERE</code>子句后面。例如，查询一班的学生成绩，并按照倒序排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 带WHERE条件的ORDER BY:</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">WHERE class_id = 1</span><br><span class="line">ORDER BY score DESC;</span><br></pre></td></tr></table></figure><p>这样，结果集仅包含符合<code>WHERE</code>条件的记录，并按照<code>ORDER BY</code>的设定排序。</p><h3 id="小结-7">小结</h3><p>使用<code>ORDER BY</code>可以对结果集进行排序；</p><p>可以对多列进行升序、倒序排序。</p><p>使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。</p><p>要实现分页功能，实际上就是从结果集中显示第1~100条记录作为第1页，显示第101~200条记录作为第2页，以此类推。</p><p>因此，分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过<code>LIMIT &lt;N-M&gt; OFFSET &lt;M&gt;</code>子句实现。我们先把所有学生按照成绩从高到低进行排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按score从高到低:</span><br><span class="line">SELECT id, name, gender, score FROM students ORDER BY score DESC;</span><br></pre></td></tr></table></figure><p>现在，我们把结果集分页，每页3条记录。要获取第1页的记录，可以使用<code>LIMIT 3 OFFSET 0</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询第1页:</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 0;</span><br></pre></td></tr></table></figure><p>上述查询<code>LIMIT 3 OFFSET 0</code>表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。</p><p>如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把<code>OFFSET</code>设定为3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询第2页:</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 3;</span><br></pre></td></tr></table></figure><p>类似的，查询第3页的时候，<code>OFFSET</code>应该设定为6:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询第3页:</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 6;</span><br></pre></td></tr></table></figure><p>查询第4页的时候，<code>OFFSET</code>应该设定为9:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询第4页:</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 9;</span><br></pre></td></tr></table></figure><p>由于第4页只有1条记录，因此最终结果集按实际数量1显示。<code>LIMIT 3</code>表示的意思是“最多3条记录”。</p><p>可见，分页查询的关键在于，首先要确定每页需要显示的结果数量<code>pageSize</code>（这里是3），然后根据当前页的索引<code>pageIndex</code>（从1开始），确定<code>LIMIT</code>和<code>OFFSET</code>应该设定的值：</p><ul><li><code>LIMIT</code>总是设定为<code>pageSize</code>；</li><li><code>OFFSET</code>计算公式为<code>pageSize * (pageIndex - 1)</code>。</li></ul><p>这样就能正确查询出第N页的记录集。</p><p>如果原本记录集一共就10条记录，但我们把<code>OFFSET</code>设置为20，会得到什么结果呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- OFFSET设定为20:</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 20;</span><br></pre></td></tr></table></figure><p><code>OFFSET</code>超过了查询的最大数量并不会报错，而是得到一个空的结果集。</p><h3 id="注意">注意</h3><p><code>OFFSET</code>是可选的，如果只写<code>LIMIT 15</code>，那么相当于<code>LIMIT 15 OFFSET 0</code>。</p><p>在MySQL中，<code>LIMIT 15 OFFSET 30</code>还可以简写成<code>LIMIT 30, 15</code>。</p><p>使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>分页时，随着<code>N</code>越来越大，查询效率也会越来越低。</p><h3 id="思考">思考</h3><p>在分页查询之前，如何计算一共有几页？</p><h3 id="小结-8">小结</h3><p>使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>可以对结果集进行分页，每次查询返回结果集的一部分；</p><p>分页查询需要先确定每页的数量和当前页数，然后确定<code>LIMIT</code>和<code>OFFSET</code>的值。</p><p>如果我们要统计一张表的数据量，例如，想查询<code>students</code>表一共有多少条记录，难道必须用<code>SELECT * FROM students</code>查出来然后再数一数有多少行吗？</p><p>这个方法当然可以，但是比较弱智。对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。</p><p>仍然以查询<code>students</code>表一共有多少条记录为例，我们可以使用SQL内置的<code>COUNT()</code>函数查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用聚合查询:</span><br><span class="line">SELECT COUNT(*) FROM students;</span><br></pre></td></tr></table></figure><p><code>COUNT(*)</code>表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是<code>COUNT(*)</code>。</p><p>通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用聚合查询并设置结果集的列名为num:</span><br><span class="line">SELECT COUNT(*) num FROM students;</span><br></pre></td></tr></table></figure><p><code>COUNT(*)</code>和<code>COUNT(id)</code>实际上是一样的效果。另外注意，聚合查询同样可以使用<code>WHERE</code>条件，因此我们可以方便地统计出有多少男生、多少女生、多少80分以上的学生等：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用聚合查询并设置WHERE条件:</span><br><span class="line">SELECT COUNT(*) boys FROM students WHERE gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure><p>除了<code>COUNT()</code>函数外，SQL还提供了如下聚合函数：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SUM</td><td>计算某一列的合计值，该列必须为数值类型</td></tr><tr><td>AVG</td><td>计算某一列的平均值，该列必须为数值类型</td></tr><tr><td>MAX</td><td>计算某一列的最大值</td></tr><tr><td>MIN</td><td>计算某一列的最小值</td></tr></tbody></table><p>注意，<code>MAX()</code>和<code>MIN()</code>函数并不限于数值类型。如果是字符类型，<code>MAX()</code>和<code>MIN()</code>会返回排序最后和排序最前的字符。</p><p>要统计男生的平均成绩，我们用下面的聚合查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用聚合查询计算男生平均成绩:</span><br><span class="line">SELECT AVG(score) average FROM students WHERE gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure><p>要特别注意：如果聚合查询的<code>WHERE</code>条件没有匹配到任何行，<code>COUNT()</code>会返回0，而<code>SUM()</code>、<code>AVG()</code>、<code>MAX()</code>和<code>MIN()</code>会返回<code>NULL</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- WHERE条件gender = &#x27;X&#x27;匹配不到任何行:</span><br><span class="line">SELECT AVG(score) average FROM students WHERE gender = &#x27;X&#x27;;</span><br></pre></td></tr></table></figure><h3 id="分组">分组</h3><p>如果我们要统计一班的学生数量，我们知道，可以用<code>SELECT COUNT(*) num FROM students WHERE class_id = 1;</code>。如果要继续统计二班、三班的学生数量，难道必须不断修改<code>WHERE</code>条件来执行<code>SELECT</code>语句吗？</p><p>对于聚合查询，SQL还提供了“分组聚合”的功能。我们观察下面的聚合查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按class_id分组:</span><br><span class="line">SELECT COUNT(*) num FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure><p>执行这个查询，<code>COUNT()</code>的结果不再是一个，而是3个，这是因为，<code>GROUP BY</code>子句指定了按<code>class_id</code>分组，因此，执行该<code>SELECT</code>语句时，会把<code>class_id</code>相同的列先分组，再分别计算，因此，得到了3行结果。</p><p>但是这3行结果分别是哪三个班级的，不好看出来，所以我们可以把<code>class_id</code>列也放入结果集中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按class_id分组:</span><br><span class="line">SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure><p>这下结果集就可以一目了然地看出各个班级的学生人数。我们再试试把<code>name</code>放入结果集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按class_id分组:</span><br><span class="line">SELECT name, class_id, COUNT(*) num FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure><p>不出意外，执行这条查询我们会得到一个语法错误，因为在任意一个分组中，只有<code>class_id</code>都相同，<code>name</code>是不同的，SQL引擎不能把多个<code>name</code>的值放入一行记录中。因此，聚合查询的列中，只能放入分组的列。</p><p>注意</p><p>AlaSQL并没有严格执行SQL标准，上述SQL在浏览器可以正常执行，但是在MySQL、Oracle等环境下将报错，请自行在MySQL中测试。</p><p>也可以使用多个列进行分组。例如，我们想统计各班的男生和女生人数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按class_id, gender分组:</span><br><span class="line">SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender;</span><br></pre></td></tr></table></figure><p>上述查询结果集一共有6条记录，分别对应各班级的男生和女生人数。</p><h3 id="练习">练习</h3><p>请使用一条SELECT查询查出每个班级的平均分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查出每个班级的平均分，结果集应当有3条记录:</span><br><span class="line">SELECT &#x27;TODO&#x27;;</span><br></pre></td></tr></table></figure><p>请使用一条SELECT查询查出每个班级男生和女生的平均分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查出每个班级的平均分，结果集应当有6条记录:</span><br><span class="line">SELECT &#x27;TODO&#x27;;</span><br></pre></td></tr></table></figure><h3 id="小结-9">小结</h3><p>使用SQL提供的聚合查询，我们可以方便地计算总数、合计值、平均值、最大值和最小值；</p><p>聚合查询可以用<code>GROUP BY</code>分组聚合；</p><p>聚合查询也可以添加<code>WHERE</code>条件。</p><p>SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：<code>SELECT * FROM &lt;表1&gt; &lt;表2&gt;</code>。</p><p>例如，同时从<code>students</code>表和<code>classes</code>表的“乘积”，即查询数据，可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- FROM students, classes:</span><br><span class="line">SELECT * FROM students, classes;</span><br></pre></td></tr></table></figure><p>这种一次查询两个表的数据，查询的结果也是一个二维表，它是<code>students</code>表和<code>classes</code>表的“乘积”，即<code>students</code>表的每一行与<code>classes</code>表的每一行都两两拼在一起返回。结果集的列数是<code>students</code>表和<code>classes</code>表的列数之和，行数是<code>students</code>表和<code>classes</code>表的行数之积。</p><p>这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。</p><p>你可能还注意到了，上述查询的结果集有两列<code>id</code>和两列<code>name</code>，两列<code>id</code>是因为其中一列是<code>students</code>表的<code>id</code>，而另一列是<code>classes</code>表的<code>id</code>，但是在结果集中，不好区分。两列<code>name</code>同理</p><p>要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的<code>id</code>和<code>name</code>列起别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- set alias:</span><br><span class="line">SELECT</span><br><span class="line">    students.id sid,</span><br><span class="line">    students.name,</span><br><span class="line">    students.gender,</span><br><span class="line">    students.score,</span><br><span class="line">    classes.id cid,</span><br><span class="line">    classes.name cname</span><br><span class="line">FROM students, classes;</span><br></pre></td></tr></table></figure><p>注意，多表查询时，要使用<code>表名.列名</code>这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用<code>表名.列名</code>这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- set table alias:</span><br><span class="line">SELECT</span><br><span class="line">    s.id sid,</span><br><span class="line">    s.name,</span><br><span class="line">    s.gender,</span><br><span class="line">    s.score,</span><br><span class="line">    c.id cid,</span><br><span class="line">    c.name cname</span><br><span class="line">FROM students s, classes c;</span><br></pre></td></tr></table></figure><p>注意到<code>FROM</code>子句给表设置别名的语法是<code>FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;</code>。这样我们用别名<code>s</code>和<code>c</code>分别表示<code>students</code>表和<code>classes</code>表。</p><p>多表查询也是可以添加<code>WHERE</code>条件的，我们来试试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- set where clause:</span><br><span class="line">SELECT</span><br><span class="line">    s.id sid,</span><br><span class="line">    s.name,</span><br><span class="line">    s.gender,</span><br><span class="line">    s.score,</span><br><span class="line">    c.id cid,</span><br><span class="line">    c.name cname</span><br><span class="line">FROM students s, classes c</span><br><span class="line">WHERE s.gender = &#x27;M&#x27; AND c.id = 1;</span><br></pre></td></tr></table></figure><p>这个查询的结果集每行记录都满足条件<code>s.gender = 'M'</code>和<code>c.id = 1</code>。添加<code>WHERE</code>条件后结果集的数量大大减少了。</p><h3 id="小结-10">小结</h3><p>使用多表查询可以获取M x N行记录；</p><p>多表查询的结果集可能非常巨大，要小心使用。</p><p>连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。</p><p>例如，我们想要选出<code>students</code>表的所有学生信息，可以用一条简单的SELECT语句完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 选出所有学生:</span><br><span class="line">SELECT s.id, s.name, s.class_id, s.gender, s.score FROM students s;</span><br></pre></td></tr></table></figure><p>但是，假设我们希望结果集同时包含所在班级的名称，上面的结果集只有<code>class_id</code>列，缺少对应班级的<code>name</code>列。</p><p>现在问题来了，存放班级名称的<code>name</code>列存储在<code>classes</code>表中，只有根据<code>students</code>表的<code>class_id</code>，找到<code>classes</code>表对应的行，再取出<code>name</code>列，就可以获得班级名称。</p><p>这时，连接查询就派上了用场。我们先使用最常用的一种内连接——INNER JOIN来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 选出所有学生，同时返回班级名称:</span><br><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">INNER JOIN classes c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure><p>注意INNER JOIN查询的写法是：</p><ol><li>先确定主表，仍然使用<code>FROM &lt;表1&gt;</code>的语法；</li><li>再确定需要连接的表，使用<code>INNER JOIN &lt;表2&gt;</code>的语法；</li><li>然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示<code>students</code>表的<code>class_id</code>列与<code>classes</code>表的<code>id</code>列相同的行需要连接；</li><li>可选：加上<code>WHERE</code>子句、<code>ORDER BY</code>等子句。</li></ol><p>使用别名不是必须的，但可以更好地简化查询语句。</p><p>那什么是内连接（INNER JOIN）呢？先别着急，有内连接（INNER JOIN）就有外连接（OUTER JOIN）。我们把内连接查询改成外连接查询，看看效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 使用OUTER JOIN:</span><br><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">RIGHT OUTER JOIN classes c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure><p>执行上述RIGHT OUTER JOIN可以看到，和INNER JOIN相比，RIGHT OUTER JOIN多了一行，多出来的一行是“四班”，但是，学生相关的列如<code>name</code>、<code>gender</code>、<code>score</code>都为<code>NULL</code>。</p><p>这也容易理解，因为根据<code>ON</code>条件<code>s.class_id = c.id</code>，<code>classes</code>表的<code>id=4</code>的行正是“四班”，但是，<code>students</code>表中并不存在<code>class_id=4</code>的行。</p><p>有RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN。它们的区别是：</p><p>INNER JOIN只返回同时存在于两张表的行数据，由于<code>students</code>表的<code>class_id</code>包含1，2，3，<code>classes</code>表的<code>id</code>包含1，2，3，4，所以，INNER JOIN根据条件<code>s.class_id = c.id</code>返回的结果集仅包含1，2，3。</p><p>RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以<code>NULL</code>填充剩下的字段。</p><p>LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加<code>class_id=5</code>，由于classes表并不存在<code>id=5</code>的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的<code>class_name</code>是<code>NULL</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 先增加一列class_id=5:</span><br><span class="line">INSERT INTO students (class_id, name, gender, score) values (5, &#x27;新生&#x27;, &#x27;M&#x27;, 88);</span><br><span class="line">-- 使用LEFT OUTER JOIN:</span><br><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">LEFT OUTER JOIN classes c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure><p>最后，我们使用FULL OUTER JOIN，它会把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 使用FULL OUTER JOIN:</span><br><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">FULL OUTER JOIN classes c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure><p>对于这么多种JOIN查询，到底什么使用应该用哪种呢？其实我们用图来表示结果集就一目了然了。</p><p>假设查询语句是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> tableA ??? <span class="keyword">JOIN</span> tableB <span class="keyword">ON</span> tableA.column1 <span class="operator">=</span> tableB.column2;</span><br></pre></td></tr></table></figure><p>我们把tableA看作左表，把tableB看成右表，那么INNER JOIN是选出两张表都存在的记录：</p><p><img src="https://liaoxuefeng.com/books/sql/query/join/inner-join.jpg" alt="inner-join"></p><p>LEFT OUTER JOIN是选出左表存在的记录：</p><p><img src="https://liaoxuefeng.com/books/sql/query/join/left-outer-join.jpg" alt="left-outer-join"></p><p>RIGHT OUTER JOIN是选出右表存在的记录：</p><p><img src="https://liaoxuefeng.com/books/sql/query/join/right-outer-join.jpg" alt="right-outer-join"></p><p>FULL OUTER JOIN则是选出左右表都存在的记录：</p><p><img src="https://liaoxuefeng.com/books/sql/query/join/full-outer-join.jpg" alt="full-outer-join"></p><h3 id="小结-11">小结</h3><p>JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上；</p><p>INNER JOIN是最常用的一种JOIN查询，它的语法是<code>SELECT ... FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; ON &lt;条件...&gt;</code>；</p><p>JOIN查询仍然可以使用<code>WHERE</code>条件和<code>ORDER BY</code>排序。</p><p>关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve、Update、Delete。其中，对于查询，我们已经详细讲述了<code>SELECT</code>语句的详细用法。</p><p>而对于增、删、改，对应的SQL语句分别是：</p><ul><li>INSERT：插入新记录；</li><li>UPDATE：更新已有记录；</li><li>DELETE：删除已有记录。</li></ul><p>我们将分别讨论这三种修改数据的语句的使用方法。</p><h2 id="插入数据">插入数据</h2><p>当我们需要向数据库表中插入一条新记录时，就必须使用<code>INSERT</code>语句。</p><p><code>INSERT</code>语句的基本语法是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> (字段<span class="number">1</span>, 字段<span class="number">2</span>, ...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...);</span><br></pre></td></tr></table></figure><p>例如，我们向<code>students</code>表插入一条新记录，先列举出需要插入的字段名称，然后在<code>VALUES</code>子句中依次写出对应字段的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 添加一条新记录:</span><br><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES (2, &#x27;大牛&#x27;, &#x27;M&#x27;, 80);</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>注意到我们并没有列出<code>id</code>字段，也没有列出<code>id</code>字段对应的值，这是因为<code>id</code>字段是一个自增主键，它的值可以由数据库自己推算出来。此外，如果一个字段有默认值，那么在<code>INSERT</code>语句中也可以不出现。</p><p>要注意，<code>INSERT</code>字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和<code>INSERT</code>字段顺序一致。也就是说，可以写<code>INSERT INTO students (score, gender, name, class_id) ...</code>，但是对应的<code>VALUES</code>就得变成<code>(80, 'M', '大牛', 2)</code>。</p><p>还可以一次性添加多条记录，只需要在<code>VALUES</code>子句中指定多个记录值，每个记录是由<code>(...)</code>包含的一组值，每组值用逗号<code>,</code>分隔：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 一次性添加多条新记录:</span><br><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES</span><br><span class="line">  (1, &#x27;大宝&#x27;, &#x27;M&#x27;, 87),</span><br><span class="line">  (2, &#x27;二宝&#x27;, &#x27;M&#x27;, 81),</span><br><span class="line">  (3, &#x27;三宝&#x27;, &#x27;M&#x27;, 83);</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><h3 id="小结-12">小结</h3><p>使用<code>INSERT</code>，我们就可以一次向一个表中插入一条或多条记录。</p><hr><hr><p>如果要更新数据库表中的记录，我们就必须使用<code>UPDATE</code>语句。</p><p><code>UPDATE</code>语句的基本语法是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">SET</span> 字段<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>, 字段<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>, ... <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure><p>例如，我们想更新<code>students</code>表<code>id=1</code>的记录的<code>name</code>和<code>score</code>这两个字段，先写出<code>UPDATE students SET name='大牛', score=66</code>，然后在<code>WHERE</code>子句中写出需要更新的行的筛选条件<code>id=1</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 更新id=1的记录:</span><br><span class="line">UPDATE students SET name=&#x27;大牛&#x27;, score=66 WHERE id=1;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students WHERE id=1;</span><br></pre></td></tr></table></figure><p>注意到<code>UPDATE</code>语句的<code>WHERE</code>条件和<code>SELECT</code>语句的<code>WHERE</code>条件其实是一样的，因此完全可以一次更新多条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 更新id=5,6,7的记录:</span><br><span class="line">UPDATE students SET name=&#x27;小牛&#x27;, score=77 WHERE id&gt;=5 AND id&lt;=7;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>在<code>UPDATE</code>语句中，更新字段时可以使用表达式。例如，把所有80分以下的同学的成绩加10分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 更新score&lt;80的记录:</span><br><span class="line">UPDATE students SET score=score+10 WHERE score&lt;80;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>其中，<code>SET score=score+10</code>就是给当前行的<code>score</code>字段的值加上了10。</p><p>如果<code>WHERE</code>条件没有匹配到任何记录，<code>UPDATE</code>语句不会报错，也不会有任何记录被更新。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 更新id=999的记录:</span><br><span class="line">UPDATE students SET score=100 WHERE id=999;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>最后，要特别小心的是，<code>UPDATE</code>语句可以没有<code>WHERE</code>条件，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> students <span class="keyword">SET</span> score<span class="operator">=</span><span class="number">60</span>;</span><br></pre></td></tr></table></figure><p>这时，整个表的所有记录都会被更新。所以，在执行<code>UPDATE</code>语句时要非常小心，最好先用<code>SELECT</code>语句来测试<code>WHERE</code>条件是否筛选出了期望的记录集，然后再用<code>UPDATE</code>更新。</p><h3 id="MySQL-2">MySQL</h3><p>在使用MySQL这类真正的关系数据库时，<code>UPDATE</code>语句会返回更新的行数以及<code>WHERE</code>条件匹配的行数。</p><p>例如，更新<code>id=1</code>的记录时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UPDATE students SET name=&#x27;大宝&#x27; WHERE id=1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure><p>MySQL会返回<code>1</code>，可以从打印的结果<code>Rows matched: 1 Changed: 1</code>看到。</p><p>当更新<code>id=999</code>的记录时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UPDATE students SET name=&#x27;大宝&#x27; WHERE id=999;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Rows matched: 0  Changed: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>MySQL会返回<code>0</code>，可以从打印的结果<code>Rows matched: 0 Changed: 0</code>看到。</p><h3 id="小结-13">小结</h3><p>使用<code>UPDATE</code>，我们就可以一次更新表中的一条或多条记录。</p><h2 id="删除数据">删除数据</h2><p>如果要删除数据库表中的记录，我们可以使用<code>DELETE</code>语句。</p><p><code>DELETE</code>语句的基本语法是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure><p>例如，我们想删除<code>students</code>表中<code>id=1</code>的记录，就需要这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 删除id=1的记录:</span><br><span class="line">DELETE FROM students WHERE id=1;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>注意到<code>DELETE</code>语句的<code>WHERE</code>条件也是用来筛选需要删除的行，因此和<code>UPDATE</code>类似，<code>DELETE</code>语句也可以一次删除多条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 删除id=5,6,7的记录:</span><br><span class="line">DELETE FROM students WHERE id&gt;=5 AND id&lt;=7;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>如果<code>WHERE</code>条件没有匹配到任何记录，<code>DELETE</code>语句不会报错，也不会有任何记录被删除。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 删除id=999的记录:</span><br><span class="line">DELETE FROM students WHERE id=999;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>最后，要特别小心的是，和<code>UPDATE</code>类似，不带<code>WHERE</code>条件的<code>DELETE</code>语句会删除整个表的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure><p>这时，整个表的所有记录都会被删除。所以，在执行<code>DELETE</code>语句时也要非常小心，最好先用<code>SELECT</code>语句来测试<code>WHERE</code>条件是否筛选出了期望的记录集，然后再用<code>DELETE</code>删除。</p><h3 id="MySQL-3">MySQL</h3><p>在使用MySQL这类真正的关系数据库时，<code>DELETE</code>语句也会返回删除的行数以及<code>WHERE</code>条件匹配的行数。</p><p>例如，分别执行删除<code>id=1</code>和<code>id=999</code>的记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELETE FROM students WHERE id=1;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; DELETE FROM students WHERE id=999;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><h3 id="小结-14">小结</h3><p>使用<code>DELETE</code>，我们就可以一次删除表中的一条或多条记录。</p><h2 id="MySQL-4">MySQL</h2><p>安装完MySQL后，除了MySQL Server，即真正的MySQL服务器外，还附赠一个MySQL Client程序。MySQL Client是一个命令行客户端，可以通过MySQL Client登录MySQL，然后，输入SQL语句并执行。</p><p>打开命令提示符，输入命令<code>mysql -u root -p</code>，提示输入口令。填入MySQL的root口令，如果正确，就连上了MySQL Server，同时提示符变为<code>mysql&gt;</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────┐</span><br><span class="line">│Windows PowerShell                                 - □ x │</span><br><span class="line">├─────────────────────────────────────────────────────────┤</span><br><span class="line">│Windows PowerShell                                       │</span><br><span class="line">│Copyright (C) Microsoft Corporation. All rights reserved.│</span><br><span class="line">│                                                         │</span><br><span class="line">│PS C:\Users\chankein&gt; mysql -u root -p                │</span><br><span class="line">│Enter password: ******                                   │</span><br><span class="line">│                                                         │</span><br><span class="line">│Server version: 5.7                                      │</span><br><span class="line">│Copyright (c) 2000, 2018, ...                            │</span><br><span class="line">│Type &#x27;help;&#x27; or &#x27;\h&#x27; for help.                           │</span><br><span class="line">│                                                         │</span><br><span class="line">│mysql&gt;                                                   │</span><br><span class="line">│                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>输入<code>exit</code>断开与MySQL Server的连接并返回到命令提示符。</p><p>提示</p><p>MySQL Client的可执行程序是mysql，MySQL Server的可执行程序是mysqld。</p><p>MySQL Client和MySQL Server的关系如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────┐  SQL   ┌──────────────┐</span><br><span class="line">│ MySQL Client │───────▶│ MySQL Server │</span><br><span class="line">└──────────────┘  TCP   └──────────────┘</span><br></pre></td></tr></table></figure><p>在MySQL Client中输入的SQL语句通过TCP连接发送到MySQL Server。默认端口号是3306，即如果发送到本机MySQL Server，地址就是<code>127.0.0.1:3306</code>。</p><p>也可以只安装MySQL Client，然后连接到远程MySQL Server。假设远程MySQL Server的IP地址是<code>10.0.1.99</code>，那么就使用<code>-h</code>指定IP或域名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 10.0.1.99 -u root -p</span><br></pre></td></tr></table></figure><h3 id="小结-15">小结</h3><p>命令行程序<code>mysql</code>实际上是MySQL客户端，真正的MySQL服务器程序是<code>mysqld</code>，在后台运行。</p><hr><hr><p>要管理MySQL，可以使用可视化图形界面<a href="https://dev.mysql.com/downloads/workbench/">MySQL Workbench</a>。</p><p>MySQL Workbench可以用可视化的方式查询、创建和修改数据库表，但是，归根到底，MySQL Workbench是一个图形客户端，它对MySQL的操作仍然是发送SQL语句并执行。因此，本质上，MySQL Workbench和MySQL Client命令行都是客户端，和MySQL交互，唯一的接口就是SQL。</p><p>因此，MySQL提供了大量的SQL语句用于管理。虽然可以使用MySQL Workbench图形界面来直接管理MySQL，但是，很多时候，通过SSH远程连接时，只能使用SQL命令，所以，了解并掌握常用的SQL管理操作是必须的。</p><h3 id="数据库">数据库</h3><p>在一个运行MySQL的服务器上，实际上可以创建多个数据库（Database）。要列出所有数据库，使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| shici              |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">| school             |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure><p>其中，<code>information_schema</code>、<code>mysql</code>、<code>performance_schema</code>和<code>sys</code>是系统库，不要去改动它们。其他的是用户创建的数据库。</p><p>注意：在MySQL命令行客户端输入SQL后，记得加一个<code>;</code>表示SQL语句结束，再回车就可以执行该SQL语句。虽然有些SQL命令不需要<code>;</code>也能执行，但类似<code>SELECT</code>等语句不加<code>;</code>会让MySQL客户端换行后继续等待输入。如果在图形界面或程序开发中集成SQL则不需要加<code>;</code>。</p><p>要创建一个新数据库，使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE test;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>要删除一个数据库，使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP DATABASE test;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>注意：删除一个数据库将导致该数据库的所有表全部被删除。</p><p>对一个数据库进行操作时，要首先将其切换为当前数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE test;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure><h3 id="表">表</h3><p>列出当前数据库的所有表，使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES;</span><br><span class="line">+---------------------+</span><br><span class="line">| Tables_in_test      |</span><br><span class="line">+---------------------+</span><br><span class="line">| classes             |</span><br><span class="line">| statistics          |</span><br><span class="line">| students            |</span><br><span class="line">| students_of_class1  |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><p>要查看一个表的结构，使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DESC students;</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field    | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id       | bigint(20)   | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| class_id | bigint(20)   | NO   |     | NULL    |                |</span><br><span class="line">| name     | varchar(100) | NO   |     | NULL    |                |</span><br><span class="line">| gender   | varchar(1)   | NO   |     | NULL    |                |</span><br><span class="line">| score    | int(11)      | NO   |     | NULL    |                |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>还可以使用以下命令查看创建表的SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW CREATE TABLE students;</span><br><span class="line">+----------+-------------------------------------------------------+</span><br><span class="line">| students | CREATE TABLE `students` (                             |</span><br><span class="line">|          |   `id` bigint(20) NOT NULL AUTO_INCREMENT,            |</span><br><span class="line">|          |   `class_id` bigint(20) NOT NULL,                     |</span><br><span class="line">|          |   `name` varchar(100) NOT NULL,                       |</span><br><span class="line">|          |   `gender` varchar(1) NOT NULL,                       |</span><br><span class="line">|          |   `score` int(11) NOT NULL,                           |</span><br><span class="line">|          |   PRIMARY KEY (`id`)                                  |</span><br><span class="line">|          | ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 |</span><br><span class="line">+----------+-------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>创建表使用<code>CREATE TABLE</code>语句，而删除表使用<code>DROP TABLE</code>语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP TABLE students;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>修改表就比较复杂。如果要给<code>students</code>表新增一列<code>birth</code>，使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;</span><br></pre></td></tr></table></figure><p>要修改<code>birth</code>列，例如把列名改为<code>birthday</code>，类型改为<code>VARCHAR(20)</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;</span><br></pre></td></tr></table></figure><p>要删除列，使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students DROP COLUMN birthday;</span><br></pre></td></tr></table></figure><h3 id="退出MySQL">退出MySQL</h3><p>使用<code>EXIT</code>命令退出MySQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXIT</span><br><span class="line">Bye</span><br></pre></td></tr></table></figure><p>注意<code>EXIT</code>仅仅断开了客户端和服务器的连接，MySQL服务器仍然继续运行。</p><p>在编写SQL时，灵活运用一些技巧，可以大大简化程序逻辑。</p><h3 id="插入或替换">插入或替换</h3><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用<code>REPLACE</code>语句，这样就不必先查询，再决定是否先删除再插入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLACE <span class="keyword">INTO</span> students (id, class_id, name, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">99</span>);</span><br></pre></td></tr></table></figure><p>若<code>id=1</code>的记录不存在，<code>REPLACE</code>语句将插入新记录，否则，当前<code>id=1</code>的记录将被删除，然后再插入新记录。</p><h3 id="插入或更新">插入或更新</h3><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用<code>INSERT INTO ... ON DUPLICATE KEY UPDATE ...</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> students (id, class_id, name, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">99</span>) <span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> name<span class="operator">=</span><span class="string">&#x27;小明&#x27;</span>, gender<span class="operator">=</span><span class="string">&#x27;F&#x27;</span>, score<span class="operator">=</span><span class="number">99</span>;</span><br></pre></td></tr></table></figure><p>若<code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，当前<code>id=1</code>的记录将被更新，更新的字段由<code>UPDATE</code>指定。</p><h3 id="插入或忽略">插入或忽略</h3><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用<code>INSERT IGNORE INTO ...</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> IGNORE <span class="keyword">INTO</span> students (id, class_id, name, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">99</span>);</span><br></pre></td></tr></table></figure><p>若<code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，不执行任何操作。</p><h3 id="快照">快照</h3><p>如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合<code>CREATE TABLE</code>和<code>SELECT</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 对class_id=1的记录进行快照，并存储为新表students_of_class1:</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> students_of_class1 <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> class_id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>新创建的表结构和<code>SELECT</code>使用的表结构完全一致。</p><h3 id="写入查询结果集">写入查询结果集</h3><p>如果查询结果集需要写入到表中，可以结合<code>INSERT</code>和<code>SELECT</code>，将<code>SELECT</code>语句的结果集直接插入到指定表中。</p><p>例如，创建一个统计成绩的表<code>statistics</code>，记录各班的平均成绩：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> statistics (</span><br><span class="line">    id <span class="type">BIGINT</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">    class_id <span class="type">BIGINT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    average <span class="keyword">DOUBLE</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后，我们就可以用一条语句写入各班的平均成绩：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> statistics (class_id, average) <span class="keyword">SELECT</span> class_id, <span class="built_in">AVG</span>(score) <span class="keyword">FROM</span> students <span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id;</span><br></pre></td></tr></table></figure><p>确保<code>INSERT</code>语句的列和<code>SELECT</code>语句的列能一一对应，就可以在<code>statistics</code>表中直接保存查询的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM statistics;</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">| id | class_id | average      |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">|  1 |        1 |         86.5 |</span><br><span class="line">|  2 |        2 | 73.666666666 |</span><br><span class="line">|  3 |        3 | 88.333333333 |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="强制使用指定索引">强制使用指定索引</h3><p>在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用<code>FORCE INDEX</code>强制查询使用指定的索引。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students FORCE INDEX (idx_class_id) <span class="keyword">WHERE</span> class_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>指定索引的前提是索引<code>idx_class_id</code>必须存在。</p><h2 id="事务">事务</h2><p>在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 从id=1的账户给id=2的账户转账100元</span></span><br><span class="line"><span class="comment">-- 第一步：将id=1的A账户余额减去100</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 第二步：将id=2的B账户余额加上100</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。</p><p>这种把多条语句作为一个整体进行操作的功能，被称为数据库<em>事务</em>。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。</p><p>可见，数据库事务具有ACID这4个特性：</p><ul><li>A：Atomicity，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；</li><li>C：Consistency，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；</li><li>I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；</li><li>D：Durability，持久性，即事务完成后，对数据库数据的修改被持久化存储。</li></ul><p>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为<em>隐式事务</em>。</p><p>要手动把多条SQL语句作为一个事务执行，使用<code>BEGIN</code>开启一个事务，使用<code>COMMIT</code>提交一个事务，这种事务被称为<em>显式事务</em>，例如，把上述的转账操作作为一个显式事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>很显然多条SQL语句要想作为一个事务执行，就必须使用显式事务。</p><p><code>COMMIT</code>是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果<code>COMMIT</code>语句执行失败了，整个事务也会失败。</p><p>有些时候，我们希望主动让事务失败，这时，可以用<code>ROLLBACK</code>回滚事务，整个事务会失败：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><p>数据库事务是由数据库系统保证的，我们只需要根据业务逻辑使用它就可以。</p><h3 id="隔离级别">隔离级别</h3><p>对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。</p><p>SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：</p><table><thead><tr><th>Isolation Level</th><th>脏读（Dirty Read）</th><th>不可重复读（Non Repeatable Read）</th><th>幻读（Phantom Read）</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Read Committed</td><td>-</td><td>Yes</td><td>Yes</td></tr><tr><td>Repeatable Read</td><td>-</td><td>-</td><td>Yes</td></tr><tr><td>Serializable</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p>我们会依次介绍4种隔离级别的数据一致性问题。</p><h3 id="小结-16">小结</h3><p>数据库事务具有ACID特性，用来保证多条SQL的全部执行。</p><h2 id="Read-Uncommitted">Read Uncommitted</h2><p>Read Uncommitted是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。</p><p>我们来看一个例子。</p><p>首先，我们准备好<code>students</code>表的数据，该表仅一行记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p><table><thead><tr><th>时刻</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td><td>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td></tr><tr><td>2</td><td>BEGIN;</td><td>BEGIN;</td></tr><tr><td>3</td><td>UPDATE students SET name = ‘Bob’ WHERE id = 1;</td><td></td></tr><tr><td>4</td><td></td><td>SELECT * FROM students WHERE id = 1;</td></tr><tr><td>5</td><td>ROLLBACK;</td><td></td></tr><tr><td>6</td><td></td><td>SELECT * FROM students WHERE id = 1;</td></tr><tr><td>7</td><td></td><td>COMMIT;</td></tr></tbody></table><p>当事务A执行完第3步时，它更新了<code>id=1</code>的记录，但并未提交，而事务B在第4步读取到的数据就是未提交的数据。</p><p>随后，事务A在第5步进行了回滚，事务B再次读取<code>id=1</code>的记录，发现和上一次读取到的数据不一致，这就是脏读。</p><p>可见，在Read Uncommitted隔离级别下，一个事务可能读取到另一个事务更新但未提交的数据，这个数据有可能是脏数据。</p><h2 id="Read-Committed">Read Committed</h2><p>在Read Committed隔离级别下，一个事务不会读到另一个事务还没有提交的数据，但可能会遇到不可重复读（Non Repeatable Read）的问题。</p><p>不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。</p><p>我们仍然先准备好<code>students</code>表的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p><table><thead><tr><th>时刻</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td><td>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td></tr><tr><td>2</td><td>BEGIN;</td><td>BEGIN;</td></tr><tr><td>3</td><td></td><td>SELECT * FROM students WHERE id = 1; – Alice</td></tr><tr><td>4</td><td>UPDATE students SET name = ‘Bob’ WHERE id = 1;</td><td></td></tr><tr><td>5</td><td>COMMIT;</td><td></td></tr><tr><td>6</td><td></td><td>SELECT * FROM students WHERE id = 1; – Bob</td></tr><tr><td>7</td><td></td><td>COMMIT;</td></tr></tbody></table><p>当事务B第一次执行第3步的查询时，得到的结果是<code>Alice</code>，随后，由于事务A在第4步更新了这条记录并提交，所以，事务B在第6步再次执行同样的查询时，得到的结果就变成了<code>Bob</code>，因此，在Read Committed隔离级别下，事务不可重复读同一条记录，因为很可能读到的结果不一致。</p><h2 id="Repeatable-Read">Repeatable Read</h2><p>在Repeatable Read隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。</p><p>幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。</p><p>我们仍然先准备好<code>students</code>表的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p><table><thead><tr><th>时刻</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td><td>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td></tr><tr><td>2</td><td>BEGIN;</td><td>BEGIN;</td></tr><tr><td>3</td><td></td><td>SELECT * FROM students WHERE id = 99; – empty</td></tr><tr><td>4</td><td>INSERT INTO students (id, name) VALUES (99, ‘Bob’);</td><td></td></tr><tr><td>5</td><td>COMMIT;</td><td></td></tr><tr><td>6</td><td></td><td>SELECT * FROM students WHERE id = 99; – empty</td></tr><tr><td>7</td><td></td><td>UPDATE students SET name = ‘Alice’ WHERE id = 99; – 1 row affected</td></tr><tr><td>8</td><td></td><td>SELECT * FROM students WHERE id = 99; – Alice</td></tr><tr><td>9</td><td></td><td>COMMIT;</td></tr></tbody></table><p>事务B在第3步第一次读取<code>id=99</code>的记录时，读到的记录为空，说明不存在<code>id=99</code>的记录。随后，事务A在第4步插入了一条<code>id=99</code>的记录并提交。事务B在第6步再次读取<code>id=99</code>的记录时，读到的记录仍然为空，但是，事务B在第7步试图更新这条不存在的记录时，竟然成功了，并且，事务B在第8步再次读取<code>id=99</code>的记录时，记录出现了。</p><p>可见，幻读就是没有读到的记录，以为不存在，但其实是可以更新成功的，并且，更新成功后，再次读取，就出现了。</p><hr><hr><p>Serializable是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。</p><p>虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。</p><h3 id="默认隔离级别">默认隔离级别</h3><p>如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read。</p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> cheat sheet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言-线性回归</title>
      <link href="/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
      <url>/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h2 id="R-线性回归">R - 线性回归</h2><p><a href="https://www.runoob.com/r/r-examples.html"><img src="https://www.runoob.com/images/up.gif" alt="R 语言实例"> R 语言实例</a></p><p>在统计学中，线性回归(Linear Regression)是利用称为线性回归方程的最小平方函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。</p><p>简单对来说就是用来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。</p><p>回归分析中，只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为一元线性回归分析。如果回归分析中包括两个或两个以上的自变量，且因变量和自变量之间是线性关系，则称为多元线性回归分析。</p><p>一元线性回归分析法的数学方程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = ax + b</span><br></pre></td></tr></table></figure><ul><li><p><strong>y</strong> 是因变量的值。</p></li><li><p><strong>x</strong> 是自变量的值。</p></li><li><p><strong>a</strong> 与 <strong>b</strong> 为一元线性回归方程的参数。</p></li></ul><p>接下来我们可以创建一个人体身高与体重的预测模型：</p><ul><li>1、收集样本数据：身高与体重。</li><li>2、使用 lm() 函数来创建一个关系模型。</li><li>3、从创建的模型中找到系数，并创建数学方程式。</li><li>4、获取关系模型的概要，了解平均误差即残差（估计值与真实值之差）。</li><li>5、使用 predict() 函数来预测人的体重。</li></ul><h3 id="准备数据">准备数据</h3><p>以下是人的身高与体重数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 身高，单位 cm</span><br><span class="line">151, 174, 138, 186, 128, 136, 179, 163, 152, 131</span><br><span class="line"></span><br><span class="line"># 体重，单位 kg</span><br><span class="line">63, 81, 56, 91, 47, 57, 76, 72, 62, 48</span><br></pre></td></tr></table></figure><h3 id="lm-函数">lm() 函数</h3><p>在 R 中，你可以通过函数 lm() 进行线性回归。</p><p>lm() 函数用于创建自变量与因变量之间的关系模型。</p><p>lm() 函数语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lm(formula,data)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>formula - 一个符号公式，表示 x 和 y 之间的关系。</li><li>data - 应用数据。</li></ul><p>创建关系模型，并获取系数：</p><h2 id="实例">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\# 样本数据  </span><br><span class="line">x &lt;- c(151, 174, 138, 186, 128, 136, 179, 163, 152, 131)  </span><br><span class="line">y &lt;- c(63, 81, 56, 91, 47, 57, 76, 72, 62, 48)</span><br><span class="line"></span><br><span class="line">\# 提交给 lm() 函数  </span><br><span class="line">relation &lt;- lm(y~x)</span><br><span class="line"></span><br><span class="line">print(relation)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Call:</span><br><span class="line">lm(formula = y ~ x)</span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">(Intercept)            x  </span><br><span class="line">    -38.4551       0.6746  </span><br></pre></td></tr></table></figure><p>使用 <strong>summary()</strong> 函数获取关系模型的概要:</p><h2 id="实例-2">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(151, 174, 138, 186, 128, 136, 179, 163, 152, 131)  </span><br><span class="line">y &lt;- c(63, 81, 56, 91, 47, 57, 76, 72, 62, 48)</span><br><span class="line"></span><br><span class="line">\# 提交给 lm() 函数  </span><br><span class="line">relation &lt;- lm(y~x)</span><br><span class="line"></span><br><span class="line">print(summary(relation))</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Call:</span><br><span class="line">lm(formula = y ~ x)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">    Min      1Q     Median      3Q     Max </span><br><span class="line">-6.3002    -1.6629  0.0412    1.8944  3.9775 </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">             Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept) -38.45509    8.04901  -4.778  0.00139 ** </span><br><span class="line">x             0.67461    0.05191  12.997 1.16e-06 ***</span><br><span class="line">---</span><br><span class="line">Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</span><br><span class="line"></span><br><span class="line">Residual standard error: 3.253 on 8 degrees of freedom</span><br><span class="line">Multiple R-squared:  0.9548,    Adjusted R-squared:  0.9491 </span><br><span class="line">F-statistic: 168.9 on 1 and 8 DF,  p-value: 1.164e-06</span><br></pre></td></tr></table></figure><h3 id="predict-函数">predict() 函数</h3><p>predict() 函数用于根据我们建立的模型来预测数值。</p><p>predict() 函数语法格式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predict(object, newdata)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>object - lm() 函数创建的公式。</li><li>newdata - 要预测的值。</li></ul><p>以下实例我们预测一个新的体重值：</p><h2 id="实例-3">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\# 样本数据  </span><br><span class="line">x &lt;- c(151, 174, 138, 186, 128, 136, 179, 163, 152, 131)  </span><br><span class="line">y &lt;- c(63, 81, 56, 91, 47, 57, 76, 72, 62, 48)</span><br><span class="line"></span><br><span class="line">\# 提交给 lm() 函数  </span><br><span class="line">relation &lt;- lm(y~x)</span><br><span class="line"></span><br><span class="line">\# 判断身高为 170cm 的体重  </span><br><span class="line">a &lt;- data.frame(x \= 170)  </span><br><span class="line">result &lt;-  predict(relation,a)  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 </span><br><span class="line">76.22869 </span><br></pre></td></tr></table></figure><p>我们也可以生成一个图表：</p><h2 id="实例-4">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\# 样本数据  </span><br><span class="line">x &lt;- c(151, 174, 138, 186, 128, 136, 179, 163, 152, 131)  </span><br><span class="line">y &lt;- c(63, 81, 56, 91, 47, 57, 76, 72, 62, 48)  </span><br><span class="line">relation &lt;- lm(y~x)</span><br><span class="line"></span><br><span class="line">\# 生成 png 图片  </span><br><span class="line">png(file \= &quot;linearregression.png&quot;)</span><br><span class="line"></span><br><span class="line">\# 生成图表  </span><br><span class="line">plot(y,x,col \= &quot;blue&quot;,main \= &quot;Height &amp; Weight Regression&quot;,  </span><br><span class="line">abline(lm(x~y)),cex \= 1.3,pch \= 16,xlab \= &quot;Weight in Kg&quot;,ylab \= &quot;Height in cm&quot;)</span><br></pre></td></tr></table></figure><p>图表如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/08/linearregression.png" alt=""></p><p><a href="https://www.runoob.com/r/r-examples.html"><img src="https://www.runoob.com/images/up.gif" alt="R 语言实例"> R 语言实例</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> R语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言-绘图</title>
      <link href="/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"/>
      <url>/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="R-绘图-饼图">R 绘图 - 饼图</h2><p>R 语言提供来大量的库来实现绘图功能。</p><p>饼图，或称饼状图，是一个划分为几个扇形的圆形统计图表，用于描述量、频率或百分比之间的相对关系。</p><p>R 语言使用 pie() 函数来实现饼图，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pie(x, labels = names(x), edges = 200, radius = 0.8,</span><br><span class="line">    clockwise = FALSE, init.angle = if(clockwise) 90 else 0,</span><br><span class="line">    density = NULL, angle = 45, col = NULL, border = NULL,</span><br><span class="line">    lty = NULL, main = NULL, …)</span><br></pre></td></tr></table></figure><ul><li>x: 数值向量，表示每个扇形的面积。</li><li>labels: 字符型向量，表示各扇形面积标签。</li><li>edges: 这个参数用处不大，指的是多边形的边数（圆的轮廓类似很多边的多边形）。</li><li>radius: 饼图的半径。</li><li>main: 饼图的标题。</li><li>clockwise: 是一个逻辑值,用来指示饼图各个切片是否按顺时针做出分割。</li><li>angle: 设置底纹的斜率。</li><li>density: 底纹的密度。默认值为 NULL。</li><li>col: 是表示每个扇形的颜色，相当于调色板。</li></ul><p>绘制饼状图要做这些准备：反映数量的向量、各部分的标签、各部分的颜色（可选）。</p><p>接下来我们绘制一个简单的饼图：</p><h2 id="实例">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\# 数据准备  </span><br><span class="line">info = c(1, 2, 4, 8)</span><br><span class="line"></span><br><span class="line">\# 命名  </span><br><span class="line">names = c(&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;, &quot;Weibo&quot;)</span><br><span class="line"></span><br><span class="line">\# 涂色（可选）  </span><br><span class="line">cols = c(&quot;#ED1C24&quot;,&quot;#22B14C&quot;,&quot;#FFC90E&quot;,&quot;#3f48CC&quot;)</span><br><span class="line"></span><br><span class="line">\# 绘图  </span><br><span class="line">pie(info, labels\=names, col\=cols)</span><br></pre></td></tr></table></figure><p>执行绘图程序，会在当前目录下生存一个 PDF 文件（Rplots.pdf）,打开文件可以看到图形效果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/CE239EAD-2217-4623-A99C-6BB2DB7C72D9.jpg" alt=""></p><p>我们也可以使用 png()、jpeg()、bmp() 函数设置输出的文件格式为图片：</p><h2 id="实例-2">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\# 数据准备  </span><br><span class="line">info \= c(1, 2, 4, 8)</span><br><span class="line"></span><br><span class="line">\# 命名  </span><br><span class="line">names \= c(&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;, &quot;Weibo&quot;)</span><br><span class="line"></span><br><span class="line">\# 涂色（可选）  </span><br><span class="line">cols \= c(&quot;#ED1C24&quot;,&quot;#22B14C&quot;,&quot;#FFC90E&quot;,&quot;#3f48CC&quot;)</span><br><span class="line"></span><br><span class="line">\# 设置输出图片  </span><br><span class="line">png(file\=&#x27;runoob-pie.png&#x27;, height\=300, width\=300)  </span><br><span class="line">\# 绘图  </span><br><span class="line">pie(info, labels\=names, col\=cols)</span><br></pre></td></tr></table></figure><p>接下来我们给饼图设置标题，中文字体需要设置字体参数 family=‘GB1’，也可以自己设置字体库，详细参考：<a href="https://www.runoob.com/r/r-charts-cn.html">R 绘图 - 中文支持</a>。</p><h2 id="实例-3">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\# 数据准备  </span><br><span class="line">info = c(1, 2, 4, 8)</span><br><span class="line"></span><br><span class="line">\# 命名  </span><br><span class="line">names = c(&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;, &quot;Weibo&quot;)</span><br><span class="line"></span><br><span class="line">\# 涂色（可选）  </span><br><span class="line">cols = c(&quot;#ED1C24&quot;,&quot;#22B14C&quot;,&quot;#FFC90E&quot;,&quot;#3f48CC&quot;)  </span><br><span class="line">\# 计算百分比  </span><br><span class="line">piepercent = paste(round(100\*info/sum(info)), &quot;%&quot;)  </span><br><span class="line">\# 绘图  </span><br><span class="line">pie(info, labels\=piepercent, main = &quot;网站分析&quot;, col\=cols, family\=&#x27;GB1&#x27;)  </span><br><span class="line">\# 添加颜色样本标注  </span><br><span class="line">legend(&quot;topright&quot;, names, cex\=0.8, fill\=cols)</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/065BA223-69F9-4AF5-A3D4-D92A6A895D89.jpg" alt=""></p><p>如果要绘制 3D 的饼图，可以使用 plotrix 库的 pie3D() 函数，使用前我们需要先安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(&quot;plotrix&quot;, repos = &quot;https://mirrors.ustc.edu.cn/CRAN/&quot;)</span><br></pre></td></tr></table></figure><h2 id="实例-4">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">\# 载入 plotrix  </span><br><span class="line">library(plotrix)  </span><br><span class="line">\# 数据准备  </span><br><span class="line">info \= c(1, 2, 4, 8)</span><br><span class="line"></span><br><span class="line">\# 命名  </span><br><span class="line">names \= c(&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;, &quot;Weibo&quot;)</span><br><span class="line"></span><br><span class="line">\# 涂色（可选）  </span><br><span class="line">cols \= c(&quot;#ED1C24&quot;,&quot;#22B14C&quot;,&quot;#FFC90E&quot;,&quot;#3f48CC&quot;)</span><br><span class="line"></span><br><span class="line">\# 设置文件名，输出为 png  </span><br><span class="line">png(file \= &quot;3d\_pie\_chart.png&quot;)</span><br><span class="line"></span><br><span class="line">\# 绘制 3D 图，family 要设置你系统支持的中文字体库  </span><br><span class="line">pie3D(info,labels \= names,explode \= 0.1, main \= &quot;3D 图&quot;,family \= &quot;STHeitiTC-Light&quot;)</span><br></pre></td></tr></table></figure><p>生成图片如下所示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/3d_pie_chart.png" alt=""></p><h2 id="R-绘图-条形图">R 绘图 - 条形图</h2><p>条形图，也称为柱状图条形图，是一种以长方形的长度为变量的统计图表。</p><p>条形图可以是水平或垂直的，每个长方形可以有不同的颜色。</p><p>R 语言使用 barplot() 函数来创建条形图，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">barplot(H,xlab,ylab,main, names.arg,col,beside)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><strong>H</strong> 向量或矩阵，包含图表用的数字值，每个数值表示矩形条的高度。</li><li><strong>xlab</strong> x 轴标签。</li><li><strong>ylab</strong> y 轴标签。</li><li><strong>main</strong> 图表标题。</li><li><strong>names.arg</strong> 每个矩形条的名称。</li><li><strong>col</strong> 每个矩形条的颜色。</li></ul><p>接下来我们创建一个简单的条形图：</p><h2 id="实例-5">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\# 准备一个向量  </span><br><span class="line">cvd19 \= c(83534,2640626,585493)</span><br><span class="line"></span><br><span class="line">\# 显示条形图  </span><br><span class="line">barplot(cvd19)</span><br></pre></td></tr></table></figure><p>执行绘图程序，会在当前目录下生存一个 PDF 文件（Rplots.pdf）,打开文件可以看到图形效果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-bar-1.png" alt=""></p><p>为了更好地表达信息，我们可以在图表上添加标题、颜色及每个矩形条的名称。</p><p>以下我们创建 2020 年 7 月 1 日中国、美国和印度的新冠疫情确诊人数统计图。</p><p>中文字体需要设置字体参数 family=‘GB1’：</p><h2 id="实例-6">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cvd19 \= c(83534,2640626,585493)</span><br><span class="line"></span><br><span class="line">barplot(cvd19,  </span><br><span class="line">    main\=&quot;新冠疫情条形图&quot;,  </span><br><span class="line">    col\=c(&quot;#ED1C24&quot;,&quot;#22B14C&quot;,&quot;#FFC90E&quot;),  </span><br><span class="line">    names.arg\=c(&quot;中国&quot;,&quot;美国&quot;,&quot;印度&quot;),  </span><br><span class="line">    family\=&#x27;GB1&#x27;  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-bar-2.png" alt=""></p><p>barplot 中的数据既可以是向量，也可以是矩阵，现在我们生成一张新冠疫情 6 月和 7 月对比图。</p><p>首先准备数据：</p><table><thead><tr><th></th><th>中国</th><th>美国</th><th>印度</th></tr></thead><tbody><tr><td>6 月</td><td>83017</td><td>1794546</td><td>190535</td></tr><tr><td>7 月</td><td>83534</td><td>2640626</td><td>585493</td></tr></tbody></table><p>转换成矩阵，生成条形图，按并排格式显示，而且要显示颜色样本。</p><p>这里我们设置了自己的字体库，详细内容可以参考 <a href="https://www.runoob.com/r/r-charts-cn.html">R 绘图 - 中文支持</a></p><h2 id="实例-7">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">library(showtext);  </span><br><span class="line">font\_add(&quot;SyHei&quot;, &quot;SourceHanSansSC-Bold.otf&quot;);  </span><br><span class="line">cvd19 \= matrix(  </span><br><span class="line">  c(83017, 83534, 1794546, 2640626, 190535, 585493),  </span><br><span class="line">  2, 3  </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">\# 设置文件名，输出为 png  </span><br><span class="line">png(file \= &quot;runoob-bar-1.png&quot;)</span><br><span class="line"></span><br><span class="line">#加载字体  </span><br><span class="line">showtext\_begin();</span><br><span class="line"></span><br><span class="line">colnames(cvd19) \= c(&quot;中国&quot;, &quot;美国&quot;, &quot;印度&quot;)  </span><br><span class="line">rownames(cvd19) \= c(&quot;6月&quot;, &quot;7月&quot;)  </span><br><span class="line">barplot(cvd19, main \= &quot;新冠疫情条形图&quot;, beside\=TRUE, legend\=TRUE,  family\=&#x27;SyHei&#x27;)</span><br><span class="line"></span><br><span class="line">\# 去掉字体  </span><br><span class="line">showtext\_end();</span><br></pre></td></tr></table></figure><p>以下代码会在当前程序目录下生存一个 runoob-bar-1.png 文件，如下所示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/runoob-bar-1.png" alt=""></p><p>我们设置的颜色样本将是每各组的颜色样本：</p><h2 id="实例-8">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">library(plotrix)  </span><br><span class="line">library(showtext);  </span><br><span class="line">font\_add(&quot;SyHei&quot;, &quot;SourceHanSansSC-Bold.otf&quot;);  </span><br><span class="line">cvd19 \= matrix(  </span><br><span class="line">  c(83017, 83534, 1794546, 2640626, 190535, 585493),  </span><br><span class="line">  2, 3  </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">\# 设置文件名，输出为 png  </span><br><span class="line">png(file \= &quot;runoob-bar-2.png&quot;)  </span><br><span class="line">#加载字体  </span><br><span class="line">showtext\_begin();  </span><br><span class="line">colnames(cvd19) \= c(&quot;中国&quot;, &quot;美国&quot;, &quot;印度&quot;)  </span><br><span class="line">rownames(cvd19) \= c(&quot;6月&quot;, &quot;7月&quot;)</span><br><span class="line"></span><br><span class="line">barplot(cvd19, main \= &quot;新冠疫情条形图&quot;, beside\=TRUE, legend\=TRUE,col\=c(&quot;blue&quot;,&quot;green&quot;),  family\=&#x27;SyHei&#x27;)  </span><br><span class="line">\# 去掉字体  </span><br><span class="line">showtext\_end();</span><br></pre></td></tr></table></figure><p>以下代码会在当前程序目录下生存一个 runoob-bar-2.png 文件，如下所示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/runoob-bar-2.png" alt=""></p><h3 id="beside-参数">beside 参数</h3><p>beside 设置矩形条堆叠的方式，默认为 FALSE：</p><ul><li><p><strong>beside=FALSE</strong> 时，条形图的高度是矩阵的数值，矩形条是水平堆叠的。</p></li><li><p><strong>beside=TRUE</strong> 时，条形图的高度是矩阵的数值，矩形条是并列的。</p></li></ul><h2 id="实例-9">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">library(showtext);  </span><br><span class="line">font\_add(&quot;SyHei&quot;, &quot;SourceHanSansSC-Bold.otf&quot;);  </span><br><span class="line">cvd19 \= matrix(  </span><br><span class="line">  c(83017, 83534, 1794546, 2640626, 190535, 585493),  </span><br><span class="line">  2, 3  </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">\# 设置文件名，输出为 png  </span><br><span class="line">png(file \= &quot;runoob-bar-3.png&quot;)  </span><br><span class="line">#加载字体  </span><br><span class="line">showtext\_begin();  </span><br><span class="line">colnames(cvd19) \= c(&quot;中国&quot;, &quot;美国&quot;, &quot;印度&quot;)  </span><br><span class="line">rownames(cvd19) \= c(&quot;6月&quot;, &quot;7月&quot;)</span><br><span class="line"></span><br><span class="line">barplot(cvd19, main \= &quot;新冠疫情条形图&quot;, beside\=FALSE, legend\=TRUE,col\=c(&quot;blue&quot;,&quot;green&quot;),  family\=&#x27;SyHei&#x27;)  </span><br><span class="line">\# 去掉字体  </span><br><span class="line">showtext\_end();</span><br></pre></td></tr></table></figure><p>以下代码会在当前程序目录下生存一个 runoob-bar-3.png 文件，如下所示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/runoob-bar-3.png" alt=""></p><h2 id="R-绘图-函数曲线图">R 绘图 - 函数曲线图</h2><p>函数曲线图是研究函数的重要工具。</p><p>R 中 curve() 函数可以绘制函数的图像，代码格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curve(expr, from = NULL, to = NULL, n = 101, add = FALSE,</span><br><span class="line">      type = &quot;l&quot;, xname = &quot;x&quot;, xlab = xname, ylab = NULL,</span><br><span class="line">      log = NULL, xlim = NULL, …)</span><br><span class="line"></span><br><span class="line"># S3 函数的方法</span><br><span class="line">plot(x, y = 0, to = 1, from = y, xlim = NULL, ylab = NULL, …)</span><br></pre></td></tr></table></figure><p>**注：**R 语言的类有 S3 类和 S4 类，S3 类用的比较广，创建简单粗糙但是灵活，而 S4 类比较精细。</p><p>参数：</p><ul><li>expr：函数表达式</li><li>from 和 to：绘图的起止范围</li><li>n：一个整数值，表示 x 取值的数量</li><li>add：是一个逻辑值，当为 TRUE 时，表示将绘图添加到已存在的绘图中。</li><li>type：绘图的类型，p 为点、l 为直线， o 同时绘制点和线，且线穿过点。</li><li>xname：用于 x 轴变量的名称。</li><li>xlim 和 ylim 表示x轴和y轴的范围。</li><li>xlab，ylab：x 轴和 y 轴的标签名称。</li></ul><p>plot 函数中，x 和 y 分别表示所绘图形的横坐标和纵坐标。</p><p>以下我们绘制一个 sin(x) 函数的图表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curve(sin(x), -2 * pi, 2 * pi)</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-line-1.png" alt=""></p><p>注意：任何计算机绘图工具绘制的都是模式图，它并不能保证与真的函数图像一模一样，它只是每隔一段距离取一个点，然后计算这个点的&quot;高度&quot;并绘制出来，为了保证曲线连续性，相邻两个点之间会有直线连接，所以在某些情况下例如 tan(x) 可能会出现错误：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-line-2.png" alt=""></p><p>在每一个 (2n+1)Pi / 2 的位置都会出现断点，但是 R 的图像将它们连接了，希望大家理解这一点。</p><p>当然，不是所有的函数都像 sin 一样支持向量处理，我们也可以手动生成一个数字序列然后用 plot 函数生成函数图像。假设函数 f 仅支持单个数值作为参数：</p><h2 id="实例-10">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">\# 定义函数 f  </span><br><span class="line">f \= function (x) &#123;  </span><br><span class="line">    if (x \&gt;= 0) &#123;  </span><br><span class="line">        x  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        x ^ 2  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\# 生成自变量序列  </span><br><span class="line">x \= seq(\-2, 2, length\=100)</span><br><span class="line"></span><br><span class="line">\# 生成因变量序列  </span><br><span class="line">y \= rep(0, length(x))  </span><br><span class="line">j \= 1  </span><br><span class="line">for (i in x) &#123;  </span><br><span class="line">    y\[j\] \= f(i)  </span><br><span class="line">    j \= j + 1  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\# 绘制图像  </span><br><span class="line">plot(x, y, type\=&#x27;l&#x27;)</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-line-3.png" alt=""></p><p>接下来我们使用 plot() 函数对向量数据进行绘图：</p><h2 id="实例-11">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\# 向量数据  </span><br><span class="line">v &lt;- c(7,12,28,3,41)</span><br><span class="line"></span><br><span class="line">\# 生成图片  </span><br><span class="line">png(file \= &quot;line\_chart\_label\_colored.jpg&quot;)</span><br><span class="line"></span><br><span class="line">\# 绘图、线图颜色为红色，main 参数用于设置标题  </span><br><span class="line">plot(v,type \= &quot;o&quot;, col \= &quot;red&quot;, xlab \= &quot;Month&quot;, ylab \= &quot;Rain fall&quot;,  </span><br><span class="line">   main \= &quot;Rain fall chart&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/line_chart_label_colored.png" alt=""></p><h2 id="R-绘图-散点图">R 绘图 - 散点图</h2><p>散点图是将所有的数据以点的形式展现在直角坐标系上，以显示变量之间的相互影响程度，点的位置由变量的数值决定，每个点对应一个 X 和 Y 轴点坐标。</p><p>散点图可以使用 plot() 函数来绘制，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot(x, y, type=&quot;p&quot;, main, xlab, ylab, xlim, ylim, axes)</span><br></pre></td></tr></table></figure><ul><li><p><strong>x</strong> 横坐标 x 轴的数据集合</p></li><li><p><strong>y</strong> 纵坐标 y 轴的数据集合</p></li><li><p>type：绘图的类型，p 为点、l 为直线， o 同时绘制点和线，且线穿过点。</p></li><li><p><strong>main</strong> 图表标题。</p></li><li><p><strong>xlab、ylab</strong> x 轴和 y 轴的标签名称。</p></li><li><p><strong>xlim、ylim</strong> x 轴和 y 轴的范围。</p></li><li><p><strong>axes</strong> 布尔值，是否绘制两个 x 轴。</p></li></ul><p>type 参数可选择值：</p><ul><li>p：点图</li><li>l：线图</li><li>b：同时绘制点和线</li><li>c：仅绘制参数 b 所示的线</li><li>o：同时绘制点和线，且线穿过点</li><li>h：绘制出点到横坐标轴的垂直线</li><li>s：阶梯图，先横后纵</li><li>S：阶梯图，先纵后竖</li><li>n： 空图</li></ul><p>创建一个简单的线图：</p><h2 id="实例-12">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x&lt;-c(10,40)  </span><br><span class="line">y&lt;-c(20,60)  </span><br><span class="line">\# 生成 png 图片  </span><br><span class="line">png(file \= &quot;runnob-test-plot2.png&quot;)</span><br><span class="line"></span><br><span class="line">plot(x, y, &quot;l&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/runnob-test-plot2.png" alt=""></p><p>创建一个简单的线图，type 使用 o 参数，同时绘制点和线，且线穿过点：</p><h2 id="实例-13">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x&lt;-c(10,40)  </span><br><span class="line">y&lt;-c(20,60)  </span><br><span class="line">\# 生成 png 图片  </span><br><span class="line">png(file \= &quot;runnob-test-plot.png&quot;)</span><br><span class="line"></span><br><span class="line">plot(x, y, &quot;o&quot;)</span><br></pre></td></tr></table></figure><p>接下来我们使用 R 语言的内置数据集 mtcars 来进行测试。</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/runnob-test-plot.png" alt=""></p><p>我们使用 mtcars 数据集的 wt 和 mpg 列：</p><h2 id="实例-14">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input &lt;- mtcars\[,c(&#x27;wt&#x27;,&#x27;mpg&#x27;)\]  </span><br><span class="line">print(head(input))  </span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wt  mpg</span><br><span class="line">Mazda RX4         2.620 21.0</span><br><span class="line">Mazda RX4 Wag     2.875 21.0</span><br><span class="line">Datsun 710        2.320 22.8</span><br><span class="line">Hornet 4 Drive    3.215 21.4</span><br><span class="line">Hornet Sportabout 3.440 18.7</span><br><span class="line">Valiant           3.460 18.1</span><br></pre></td></tr></table></figure><p>接着我们使用以上数据生存一个散点图</p><p>：</p><h2 id="实例-15">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\# 数据  </span><br><span class="line">input &lt;- mtcars\[,c(&#x27;wt&#x27;,&#x27;mpg&#x27;)\]</span><br><span class="line"></span><br><span class="line">\# 生成 png 图片  </span><br><span class="line">png(file \= &quot;scatterplot.png&quot;)</span><br><span class="line"></span><br><span class="line">\# 设置坐标 x 轴范围 2.5 到 5, y 轴范围 15 到 30.  </span><br><span class="line">plot(x \= input$wt,y \= input$mpg,  </span><br><span class="line">   xlab \= &quot;Weight&quot;,  </span><br><span class="line">   ylab \= &quot;Milage&quot;,  </span><br><span class="line">   xlim \= c(2.5,5),  </span><br><span class="line">   ylim \= c(15,30),                </span><br><span class="line">   main \= &quot;Weight vs Milage&quot;  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/scatterplot.png" alt=""></p><h3 id="散点图矩阵">散点图矩阵</h3><p>散点图矩阵是借助两变量散点图的作图方法，它可以看作是一个大的图形方阵，其每一个非主对角元素的位置上是对应行的变量与对应列的变量的散点图。而主对角元素位置上是各变量名，这样，借助散点图矩阵可以清晰地看到所研究多个变量两两之间的相关关系。</p><p>散点图矩阵就是把数据集中的每个数值变量两两绘制散点图。</p><p>R 语言使用以下函数创建散点图矩阵：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pairs(formula, data)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><p><strong>formula</strong> 变量系列</p></li><li><p><strong>data</strong> 变量的数据集</p></li></ul><h2 id="实例-16">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\# 输出图片  </span><br><span class="line">png(file \= &quot;scatterplot\_matrices.png&quot;)</span><br><span class="line"></span><br><span class="line">\# 4 个变量绘制矩阵，12 个图</span><br><span class="line"></span><br><span class="line">pairs(~wt+mpg+disp+cyl,data \= mtcars, main \= &quot;Scatterplot Matrix&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/scatterplot_matrices.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> R语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言-读取数据</title>
      <link href="/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
      <url>/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="R-CSV-文件">R CSV 文件</h2><p>R 作为统计学专业工具，如果只能人工的导入和导出数据将使其功能变得没有意义，所以 R 支持批量的从主流的表格存储格式文件（例如 CSV、Excel、XML 等）中获取数据。</p><h3 id="CSV-表格交互">CSV 表格交互</h3><p>CSV（Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符也可以不是逗号） 是一种非常流行的表格存储文件格式，这种格式适合储存中型或小型数据规模的数据。</p><p>由于大多数软件支持这个文件格式，所以常用于数据的储存与交互。</p><p>CSV 本质是文本，它的文件格式极度简单：数据一行一行的用文本保存起来而已，每条记录被分隔符分隔为字段，每条记录都有同样的字段序列。</p><p>以下是一个简单的 sites.csv 文件（存储在测试程序的相同目录下）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id,name,url,likes</span><br><span class="line">1,Google,www.google.com,111</span><br><span class="line">2,Runoob,www.runoob.com,222</span><br><span class="line">3,Taobao,www.taobao.com,333</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>CSV 用逗号来分割列，如果数据中含有逗号，就要用双引号将整个数据块包括起来。</p><p>**注意：**包含非英文字符的文本要注意保存的编码，由于很多计算机普遍使用 UTF-8 编码，所以我是用 UTF-8 进行保存的。</p><p><strong>注意：</strong> CSV 文件最后一行需要保留一个空行，不然执行程序会有警告信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Warning message:</span><br><span class="line">In read.table(file = file, header = header, sep = sep, quote = quote,  :</span><br><span class="line">  incomplete final line found by readTableHeader on &#x27;sites.csv&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/057FE509-4EE4-4A74-9F7D-786AC2C5282E.jpg" alt=""></p><h3 id="读取-CSV-文件">读取 CSV 文件</h3><p>接下来我们就可以使用 read.csv() 函数来读取 CSV 文件的数据：</p><h2 id="实例">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data &lt;- read.csv(&quot;sites.csv&quot;, encoding\=&quot;UTF-8&quot;)  </span><br><span class="line">print(data)  </span><br></pre></td></tr></table></figure><p>如果不设置 encoding 属性，read.csv 函数将默认以操作系统默认的文字编码进行读取，如果你使用的是 Windows 中文版系统且没有设置过系统的默认编码，那系统的默认编码应该是 GBK。所以大家请尽可能地统一文字编码以防出错。</p><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  id   name            url likes</span><br><span class="line">1  1 Google www.google.com   111</span><br><span class="line">2  2 Runoob www.runoob.com   222</span><br><span class="line">3  3 Taobao www.taobao.com   333</span><br></pre></td></tr></table></figure><p>read.csv() 函数返回的是数据框，我们可以很方便的对数据进行统计处理，以下实例我们查看行数和列数：</p><h2 id="实例-2">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data &lt;- read.csv(&quot;sites.csv&quot;, encoding\=&quot;UTF-8&quot;)</span><br><span class="line"></span><br><span class="line">print(is.data.frame(data))  \# 查看是否是数据框  </span><br><span class="line">print(ncol(data))  \# 列数  </span><br><span class="line">print(nrow(data))  \# 行数</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1] TRUE</span><br><span class="line">[1] 4</span><br><span class="line">[1] 3</span><br></pre></td></tr></table></figure><p>以下统计数据框中 likes 字段最大对数据：</p><h2 id="实例-3">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data &lt;- read.csv(&quot;sites.csv&quot;, encoding\=&quot;UTF-8&quot;)</span><br><span class="line"></span><br><span class="line">\# likes 最大的数据  </span><br><span class="line">like &lt;- max(data$likes)  </span><br><span class="line">print(like)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] 333</span><br></pre></td></tr></table></figure><p>我们也可以指定查找条件，类似 SQL where 子句一样查询数据，需要用到到函数是 <strong>subset()</strong>。</p><p>以下实例查找 likes 为 222 到数据：</p><h2 id="实例-4">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data &lt;- read.csv(&quot;sites.csv&quot;, encoding\=&quot;UTF-8&quot;)</span><br><span class="line"></span><br><span class="line">\# likes 为 222 的数据  </span><br><span class="line">retval &lt;- subset(data, likes \== 222)  </span><br><span class="line">print(retval)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  id   name            url likes</span><br><span class="line">2  2 Runoob www.runoob.com   222</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：条件语句等于使用 ==。</p><p>多个条件使用 &amp; 分隔符，以下实例查找 likes 大于 1 name 为 Runoob 的数据：</p><h2 id="实例-5">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data &lt;- read.csv(&quot;sites.csv&quot;, encoding\=&quot;UTF-8&quot;)</span><br><span class="line"></span><br><span class="line">\# likes 大于 1 name 为 Runoob 的数据  </span><br><span class="line">retval &lt;- subset(data, likes \&gt; 1 &amp; name\==&quot;Runoob&quot;)  </span><br><span class="line">print(retval)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  id   name            url likes</span><br><span class="line">2  2 Runoob www.runoob.com   222</span><br></pre></td></tr></table></figure><h3 id="保存为-CSV-文件">保存为 CSV 文件</h3><p>R 语言可以使用 <strong>write.csv()</strong> 函数将数据保存为 CSV 文件。</p><p>接着以上实例，我们将 likes 为 222 的数据 保存到 runoob.csv 文件：</p><h2 id="实例-6">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data &lt;- read.csv(&quot;sites.csv&quot;, encoding\=&quot;UTF-8&quot;)</span><br><span class="line"></span><br><span class="line">\# likes 为 222 的数据  </span><br><span class="line">retval &lt;- subset(data, likes \== 222)</span><br><span class="line"></span><br><span class="line">\# 写入新的文件  </span><br><span class="line">write.csv(retval,&quot;runoob.csv&quot;)  </span><br><span class="line">newdata &lt;- read.csv(&quot;runoob.csv&quot;)  </span><br><span class="line">print(newdata)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> X id   name            url likes</span><br><span class="line">1 2  2 Runoob www.runoob.com   222</span><br></pre></td></tr></table></figure><p>X 来自数据集 newper，可以通过参数 row.names = FALSE 来删除它：</p><h2 id="实例-7">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data &lt;- read.csv(&quot;sites.csv&quot;, encoding\=&quot;UTF-8&quot;)</span><br><span class="line"></span><br><span class="line">\# likes 为 222 的数据  </span><br><span class="line">retval &lt;- subset(data, likes \== 222)</span><br><span class="line"></span><br><span class="line">\# 写入新的文件  </span><br><span class="line">write.csv(retval,&quot;runoob.csv&quot;, row.names \= FALSE)  </span><br><span class="line">newdata &lt;- read.csv(&quot;runoob.csv&quot;)  </span><br><span class="line">print(newdata)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  id   name            url likes</span><br><span class="line">1  2 Runoob www.runoob.com   222</span><br></pre></td></tr></table></figure><p>执行完后，我们就可以看到 runoob.csv 文件生存：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-csv-1.jpeg" alt=""></p><h2 id="R-Excel-文件">R Excel 文件</h2><p>Excel 格式的文件主要是 xls 或 xlsx，这两种文件可以在 R 语言中导入 xlsx 库来实现直接的读取。</p><p>R 语言读写 Excel 文件需要安装扩展包，我们可以在 R 到控制台输入以下命令来安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(&quot;xlsx&quot;, repos = &quot;https://mirrors.ustc.edu.cn/CRAN/&quot;)</span><br></pre></td></tr></table></figure><p>安装过程如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/4C19EC49-38CA-4C21-9A11-B15995728BCD.jpg" alt=""></p><p>事实上，几乎所有的 Excel 软件与大多数表格软件一样支持 CSV 格式的数据，所以完全可以通过 CSV 与 R 交互，没必要再使用 Excel。</p><p>查看 xlsx 是否安装成功：</p><h2 id="实例-8">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\# 验证包是否安装  </span><br><span class="line">any(grepl(&quot;xlsx&quot;,installed.packages()))  </span><br><span class="line">\# 载入包  </span><br><span class="line">library(&quot;xlsx&quot;)  </span><br><span class="line">library(&quot;xlsx&quot;)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1] TRUE</span><br><span class="line">Loading required package: rJava</span><br><span class="line">Loading required package: methods</span><br><span class="line">Loading required package: xlsxjars</span><br></pre></td></tr></table></figure><p>Excel 文件数据：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/55596D4D-4122-4605-B40E-1826D638A572.jpg" alt=""></p><p>点击链接下载 Excel 测试数据：<a href="https://static.jyshare.com/download/sites.xlsx">https://static.jyshare.com/download/sites.xlsx</a></p><p>接下来，我们可以使用 read.xlsx() 函数来读取 Excel 数据：</p><h2 id="实例-9">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\# 读取 sites.xlsx 第一个工作表数据  </span><br><span class="line">data &lt;- read.xlsx(&quot;sites.xlsx&quot;, sheetIndex \= 1)  </span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure><h2 id="R-XML-文件">R XML 文件</h2><p>XML 指的是可扩展标记语言（eXtensible Markup Language），XML 被设计用来传输和存储数据。</p><p>如果你对 XML 还不了解，可以先查阅：<a href="https://www.runoob.com/xml/xml-tutorial.html">XML 教程</a></p><p>R 语言读写 XML 文件需要安装扩展包，我们可以在 R 到控制台输入以下命令来安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(&quot;XML&quot;, repos = &quot;https://mirrors.ustc.edu.cn/CRAN/&quot;)</span><br></pre></td></tr></table></figure><p>查看是否安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; any(grepl(&quot;XML&quot;,installed.packages()))</span><br><span class="line">[1] TRUE</span><br></pre></td></tr></table></figure><p>创建 sites.xml 文件，xml 文件与测试脚本同一目录下，代码如下：</p><h2 id="实例-10">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;sites\&gt; &lt;site\&gt; &lt;id\&gt;1&lt;/id\&gt; &lt;name\&gt;Google&lt;/name\&gt; &lt;url\&gt;www.google.com&lt;/url\&gt; &lt;likes\&gt;111&lt;/likes\&gt; &lt;/site\&gt; &lt;site\&gt; &lt;id\&gt;2&lt;/id\&gt; &lt;name\&gt;Runoob&lt;/name\&gt; &lt;url\&gt;www.runoob.com&lt;/url\&gt; &lt;likes\&gt;222&lt;/likes\&gt; &lt;/site\&gt; &lt;site\&gt; &lt;id\&gt;3&lt;/id\&gt; &lt;name\&gt;Taobao&lt;/name\&gt; &lt;url\&gt;www.taobao.com&lt;/url\&gt; &lt;likes\&gt;333&lt;/likes\&gt; &lt;/site\&gt; &lt;/sites\&gt;</span><br></pre></td></tr></table></figure><p>接下来我们可以使用 XML 包来载入 xml 文件的数据：</p><h2 id="实例-11">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\# 载入 XML 包  </span><br><span class="line">library(&quot;XML&quot;)</span><br><span class="line"></span><br><span class="line">\# 设置文件名  </span><br><span class="line">result &lt;- xmlParse(file \= &quot;sites.xml&quot;)</span><br><span class="line"></span><br><span class="line">\# 输出结果  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>统计 xml 数据量：</p><h2 id="实例-12">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\# 载入 XML 包  </span><br><span class="line">library(&quot;XML&quot;)</span><br><span class="line"></span><br><span class="line">\# 设置文件名  </span><br><span class="line">result &lt;- xmlParse(file \= &quot;sites.xml&quot;)</span><br><span class="line"></span><br><span class="line">\# 提取根节点  </span><br><span class="line">rootnode &lt;- xmlRoot(result)</span><br><span class="line"></span><br><span class="line">\# 统计数据量  </span><br><span class="line">rootsize &lt;- xmlSize(rootnode)</span><br><span class="line"></span><br><span class="line">\# 输出结果  </span><br><span class="line">print(rootsize)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] 3</span><br></pre></td></tr></table></figure><p>查看节点数据，某一行使用 [ ], 指定的行和列使用 [[ ]]:</p><h2 id="实例-13">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">\# 载入 XML 包  </span><br><span class="line">library(&quot;XML&quot;)</span><br><span class="line"></span><br><span class="line">\# 设置文件名  </span><br><span class="line">result &lt;- xmlParse(file \= &quot;sites.xml&quot;)</span><br><span class="line"></span><br><span class="line">\# 提取根节点  </span><br><span class="line">rootnode &lt;- xmlRoot(result)</span><br><span class="line"></span><br><span class="line">\# 查看第 2 个节点数据  </span><br><span class="line">print(rootnode\[2\])</span><br><span class="line"></span><br><span class="line">\# 查看第 2 个节点的第  1 个数据  </span><br><span class="line">print(rootnode\[\[2\]\]\[\[1\]\])</span><br><span class="line"></span><br><span class="line">\# 查看第 2 个节点的第 3 个数据</span><br><span class="line"></span><br><span class="line">print(rootnode\[\[2\]\]\[\[3\]\])</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$site</span><br><span class="line">&lt;site&gt;</span><br><span class="line">  &lt;id&gt;2&lt;/id&gt;</span><br><span class="line">  &lt;name&gt;Runoob&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;www.runoob.com&lt;/url&gt;</span><br><span class="line">  &lt;likes&gt;222&lt;/likes&gt;</span><br><span class="line">&lt;/site&gt; </span><br><span class="line"></span><br><span class="line">attr(,&quot;class&quot;)</span><br><span class="line">[1] &quot;XMLInternalNodeList&quot; &quot;XMLNodeList&quot;        </span><br><span class="line">&lt;id&gt;2&lt;/id&gt; </span><br><span class="line">&lt;url&gt;www.runoob.com&lt;/url&gt; </span><br></pre></td></tr></table></figure><h3 id="XML-转为数据列表">XML 转为数据列表</h3><p>以上代码对输出都是 xml 格式，我们使用 xmlToList() 函数可以将文件对数据转为列表格式，更方便读取：</p><h2 id="实例-14">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\# 载入 XML 包  </span><br><span class="line">library(&quot;XML&quot;)</span><br><span class="line"></span><br><span class="line">\# 设置文件名  </span><br><span class="line">result &lt;- xmlParse(file \= &quot;sites.xml&quot;)</span><br><span class="line"></span><br><span class="line">\# 转为列表  </span><br><span class="line">xml\_data &lt;- xmlToList(result)</span><br><span class="line"></span><br><span class="line">print(xml\_data)  </span><br><span class="line">print(&quot;============================&quot;)</span><br><span class="line"></span><br><span class="line">\# 输出第一行第二列的数据  </span><br><span class="line">print(xml\_data\[\[1\]\]\[\[2\]\])</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">$site</span><br><span class="line">$site$id</span><br><span class="line">[1] &quot;1&quot;</span><br><span class="line"></span><br><span class="line">$site$name</span><br><span class="line">[1] &quot;Google&quot;</span><br><span class="line"></span><br><span class="line">$site$url</span><br><span class="line">[1] &quot;www.google.com&quot;</span><br><span class="line"></span><br><span class="line">$site$likes</span><br><span class="line">[1] &quot;111&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$site</span><br><span class="line">$site$id</span><br><span class="line">[1] &quot;2&quot;</span><br><span class="line"></span><br><span class="line">$site$name</span><br><span class="line">[1] &quot;Runoob&quot;</span><br><span class="line"></span><br><span class="line">$site$url</span><br><span class="line">[1] &quot;www.runoob.com&quot;</span><br><span class="line"></span><br><span class="line">$site$likes</span><br><span class="line">[1] &quot;222&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$site</span><br><span class="line">$site$id</span><br><span class="line">[1] &quot;3&quot;</span><br><span class="line"></span><br><span class="line">$site$name</span><br><span class="line">[1] &quot;Taobao&quot;</span><br><span class="line"></span><br><span class="line">$site$url</span><br><span class="line">[1] &quot;www.taobao.com&quot;</span><br><span class="line"></span><br><span class="line">$site$likes</span><br><span class="line">[1] &quot;333&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[1] &quot;============================&quot;</span><br><span class="line">[1] &quot;Google&quot;</span><br></pre></td></tr></table></figure><h3 id="XML-转为数据框">XML 转为数据框</h3><p>XML 文件数据可以转为数据框类型，这样我们就更方便对数据进行操作：</p><h2 id="实例-15">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\# 载入 XML 包  </span><br><span class="line">library(&quot;XML&quot;)</span><br><span class="line"></span><br><span class="line">\# xml 文件数据转为数据框  </span><br><span class="line">xmldataframe &lt;- xmlToDataFrame(&quot;sites.xml&quot;)  </span><br><span class="line">print(xmldataframe)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  id   name            url likes</span><br><span class="line">1  1 Google www.google.com   111</span><br><span class="line">2  2 Runoob www.runoob.com   222</span><br><span class="line">3  3 Taobao www.taobao.com   333</span><br></pre></td></tr></table></figure><h2 id="R-JSON-文件">R JSON 文件</h2><p>JSON: <strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation(JavaScript 对象表示法)。</p><p>JSON 是存储和交换文本信息的语法。</p><p>JSON 类似 XML，但比 XML 更小、更快，更易解析。</p><p>如果你对 JSON 还不了解，可以先查阅：<a href="https://www.runoob.com/json/json-tutorial.html">JSON 教程</a></p><p>R 语言读写 JSON 文件需要安装扩展包，我们可以在 R 到控制台输入以下命令来安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(&quot;rjson&quot;, repos = &quot;https://mirrors.ustc.edu.cn/CRAN/&quot;)</span><br></pre></td></tr></table></figure><p>查看是否安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; any(grepl(&quot;rjson&quot;,installed.packages()))</span><br><span class="line">[1] TRUE</span><br></pre></td></tr></table></figure><p>创建 sites.json 文件，json 文件与测试脚本同一目录下，代码如下：</p><h2 id="实例-16">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;id&quot;:\[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;\], &quot;name&quot;:\[&quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;\], &quot;url&quot;:\[&quot;www.google.com&quot;,&quot;www.runoob.com&quot;,&quot;www.taobao.com&quot;\], &quot;likes&quot;:\[ 111,222,333\] &#125;</span><br></pre></td></tr></table></figure><p>接下来我们可以使用 rjson 包来载入 json 文件的数据。</p><p>查看数据，某一行使用 [ ], 指定的行和列使用 [[ ]]:</p><h2 id="实例-17">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">\# 载入 rjson 包  </span><br><span class="line">library(&quot;rjson&quot;)</span><br><span class="line"></span><br><span class="line">\# 获取 json 数据  </span><br><span class="line">result &lt;- fromJSON(file \= &quot;sites.json&quot;)</span><br><span class="line"></span><br><span class="line">\# 输出结果  </span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">print(&quot;===============&quot;)</span><br><span class="line"></span><br><span class="line">\# 输出第 1 列的结果  </span><br><span class="line">print(result\[1\])</span><br><span class="line"></span><br><span class="line">print(&quot;===============&quot;)  </span><br><span class="line">\# 输出第 2 行第 2 列的结果  </span><br><span class="line">print(result\[\[2\]\]\[\[2\]\])</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$id</span><br><span class="line">[1] &quot;1&quot; &quot;2&quot; &quot;3&quot;</span><br><span class="line"></span><br><span class="line">$name</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot; &quot;Taobao&quot;</span><br><span class="line"></span><br><span class="line">$url</span><br><span class="line">[1] &quot;www.google.com&quot; &quot;www.runoob.com&quot; &quot;www.taobao.com&quot;</span><br><span class="line"></span><br><span class="line">$likes</span><br><span class="line">[1] 111 222 333</span><br><span class="line"></span><br><span class="line">[1] &quot;===============&quot;</span><br><span class="line">$id</span><br><span class="line">[1] &quot;1&quot; &quot;2&quot; &quot;3&quot;</span><br><span class="line"></span><br><span class="line">[1] &quot;===============&quot;</span><br><span class="line">[1] &quot;Runoob&quot;</span><br></pre></td></tr></table></figure><p>我们也可以使用 <strong>as.data.frame()</strong> 函数将 json 文件数据可以转为数据框类型，这样我们就更方便对数据进行操作：</p><h2 id="实例-18">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\# 载入 rjson 包  </span><br><span class="line">library(&quot;rjson&quot;)</span><br><span class="line"></span><br><span class="line">\# 获取 json 数据  </span><br><span class="line">result &lt;- fromJSON(file \= &quot;sites.json&quot;)</span><br><span class="line"></span><br><span class="line">\# 转为数据框  </span><br><span class="line">json\_data\_frame &lt;- as.data.frame(result)</span><br><span class="line"></span><br><span class="line">print(json\_data\_frame)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  id   name            url likes</span><br><span class="line">1  1 Google www.google.com   111</span><br><span class="line">2  2 Runoob www.runoob.com   222</span><br><span class="line">3  3 Taobao www.taobao.com   333</span><br></pre></td></tr></table></figure><h2 id="R-MySQL-连接">R MySQL 连接</h2><p>MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。</p><p>如果你对 MySQL 还不了解，可以先查阅：<a href="https://www.runoob.com/mysql/mysql-tutorial.html">MySQL 教程</a></p><p>R 语言读写 MySQL 文件需要安装扩展包，我们可以在 R 到控制台输入以下命令来安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(&quot;RMySQL&quot;, repos = &quot;https://mirrors.ustc.edu.cn/CRAN/&quot;)</span><br></pre></td></tr></table></figure><p>查看是否安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; any(grepl(&quot;RMySQL&quot;,installed.packages()))</span><br><span class="line">[1] TRUE</span><br></pre></td></tr></table></figure><p>MySQL 目前被甲骨文收购，所以很多人使用来它的复制版本 MariaDB，MariaDB 在 GNU GPL下开源，MariaDB 的开发是由 MySQL 的一些原始开发者领导的，所以语法操作都差不多：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(&quot;RMariaDB&quot;, repos = &quot;https://mirrors.ustc.edu.cn/CRAN/&quot;)</span><br></pre></td></tr></table></figure><p>在 test 数据库中创建数据表 runoob，表结构及数据代码如下：</p><h2 id="实例-19">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\-- -- 表的结构 \`runoob\` \-- CREATE TABLE \`runoob\` ( \`id\` int(11) NOT NULL, \`name\` char(20) NOT NULL, \`url\` varchar(255) NOT NULL, \`likes\` int(11) NOT NULL ) ENGINE\=InnoDB DEFAULT CHARSET\=utf8mb4; \-- -- 转存表中的数据 \`runoob\` \-- INSERT INTO \`runoob\` (\`id\`, \`name\`, \`url\`, \`likes\`) VALUES (1, &#x27;Google&#x27;, &#x27;www.google.com&#x27;, 111), (2, &#x27;Runoob&#x27;, &#x27;www.runoob.com&#x27;, 222), (3, &#x27;Taobao&#x27;, &#x27;www.taobao.com&#x27;, 333);</span><br></pre></td></tr></table></figure><p>接下来我们可以使用 RMySQL 包来读取数据：</p><h2 id="实例-20">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">library(RMySQL)</span><br><span class="line"></span><br><span class="line">\# dbname 为数据库名，这边的参数请根据自己实际情况填写  </span><br><span class="line">mysqlconnection \= dbConnect(MySQL(), user \= &#x27;root&#x27;, password \= &#x27;&#x27;, dbname \= &#x27;test&#x27;,host \= &#x27;localhost&#x27;)</span><br><span class="line"></span><br><span class="line">\# 查看数据  </span><br><span class="line">dbListTables(mysqlconnection)</span><br></pre></td></tr></table></figure><p>接下来我们可以使用 dbSendQuery 来读取数据库的表，结果集通过 fetch() 函数来获取：</p><h2 id="实例-21">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">library(RMySQL)  </span><br><span class="line">\# 查询 sites 表，增删改查操作可以通过第二个参数的 SQL 语句来实现  </span><br><span class="line">result \= dbSendQuery(mysqlconnection, &quot;select \* from sites&quot;)</span><br><span class="line"></span><br><span class="line">\# 获取前面两行数据  </span><br><span class="line">data.frame \= fetch(result, n \= 2)  </span><br><span class="line">print(data.frame)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> R语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言-基础</title>
      <link href="/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"/>
      <url>/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="R-语言基础">R 语言基础</h2><p>一门新的语言学习一般是从输出 “Hello, World!” 程序开始，R 语言的 “Hello, World!” 程序代码如下：</p><h2 id="实例（helloworld-R）">实例（helloworld.R）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myString &lt;- &quot;Hello, World!&quot;</span><br><span class="line"></span><br><span class="line">print ( myString )</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/try/runcode.php?filename=helloworld&amp;type=r">运行实例 »</a></p><p>以上实例将字符串 “Hello, World!” 赋值给 myString 变量，然后使用 print() 函数输出。</p><p>**注意：**R 语言赋值使用的是左箭头 &lt;- 符号，不过一些新版本也支持等号 <strong>=</strong>。</p><h3 id="变量">变量</h3><p>R 语言的有效的变量名称由字母，数字以及点号 . 或下划线 _ 组成。</p><p>变量名称以字母或点开头。</p><table><thead><tr><th>变量名</th><th>是否正确</th><th>原因</th></tr></thead><tbody><tr><td>var_name2.</td><td>正确</td><td>字符开头，并由字母、数字、下划线和点号组成</td></tr><tr><td>var_name%</td><td>错误</td><td>% 是非法字符</td></tr><tr><td>2var_name</td><td>错误</td><td>不能数字开头</td></tr><tr><td>.var_name,<a href="http://var.name">var.name</a></td><td>正确</td><td>可以 . 号开头，但是要注意 . 号开头后面不能跟着数字</td></tr><tr><td>.2var_name</td><td>错误</td><td>. 号开头后面不能跟着数字</td></tr><tr><td>_var_name</td><td>错误</td><td>不能以下划线 _ 开头</td></tr></tbody></table><h3 id="变量赋值">变量赋值</h3><p>最新版本的 R 语言的赋值可以使用左箭头 &lt;-、等号 = 、右箭头 -&gt; 赋值:</p><h2 id="实例">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\# 使用等号 = 号赋值  </span><br><span class="line">\&gt; var.1 \= c(0,1,2,3)            </span><br><span class="line">\&gt; print(var.1)  </span><br><span class="line">\[1\] 0 1 2 3</span><br><span class="line"></span><br><span class="line">\# 使用左箭头 &lt;-赋值  </span><br><span class="line">\&gt; var.2 &lt;- c(&quot;learn&quot;,&quot;R&quot;)    </span><br><span class="line">\&gt; print(var.2)  </span><br><span class="line">\[1\] &quot;learn&quot; &quot;R&quot;</span><br><span class="line"></span><br><span class="line">    \# 使用右箭头 -&gt; 赋值  </span><br><span class="line">\&gt; c(TRUE,1) \-&gt; var.3  </span><br><span class="line">\&gt; print(var.3)  </span><br><span class="line">\[1\] 1 1</span><br></pre></td></tr></table></figure><p>查看已定义的变量可以使用 <strong>ls()</strong> 函数：</p><h2 id="实例-2">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\&gt; print(ls())  </span><br><span class="line">\[1\] &quot;var.1&quot; &quot;var.2&quot; &quot;var.3&quot;  </span><br></pre></td></tr></table></figure><p>删除变量可以使用 <strong>rm()</strong> 函数：</p><h2 id="实例-3">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\&gt; rm(var.3)  </span><br><span class="line">\&gt; print(ls())  </span><br><span class="line">\[1\] &quot;var.1&quot; &quot;var.2&quot;  </span><br><span class="line">\&gt;  </span><br></pre></td></tr></table></figure><p>上一章节中我们已经学会来如何安装 R 的编程环境，接下来我们将为大家介绍 R 语言的交互式编程与文件脚本编程。</p><h3 id="交互式编程">交互式编程</h3><p>我们只需要在命令行中执行 R 命令就可以进入交互式的编程窗口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R</span><br></pre></td></tr></table></figure><p>执行完这个命令后会调出 R 语言的解释器，我们在 &gt; 符后面输入代码即可。</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/AA89F11A-9180-4BD0-8A6A-4BE2FD5F1E8E.jpg" alt=""></p><p>交互式命令可以通过输入 q() 来退出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; q()</span><br><span class="line">Save workspace image? [y/n/c]: y</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/DDF9B88F-3BBC-4679-9D93-565E4D0ABBAB.jpg" alt=""></p><h3 id="文件脚本">文件脚本</h3><p>R 语言文件后缀为 .R。</p><p>接下来我们创建一个 runoob-test.R 文件：代码如下：</p><h2 id="runoob-test-R-文件">runoob-test.R 文件</h2><p>myString &lt;- “RUNOOB”</p><p>print ( myString )</p><p>接下来我们在命令行窗口使用 Rscript 来执行该脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rscript runoob-test.R</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;RUNOOB&quot;</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/0E277616-7A0A-423B-A3FB-8BCF0D381C80.jpg" alt=""></p><hr><h2 id="输入输出">输入输出</h2><h3 id="print-输出">print() 输出</h3><p>print() 是 R 语言的输出函数。</p><p>和其他编程语言一样，R 语言支持数字、字符等输出。</p><p>输出的语句十分简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;RUNOOB&quot;)</span><br><span class="line">print(123)</span><br><span class="line">print(3e2)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;RUNOOB&quot;</span><br><span class="line">[1] 123</span><br><span class="line">[1] 300</span><br></pre></td></tr></table></figure><p>R 语言与 node.js 和 Python 一样，是解释型的语言，所以我们往往可以像使用命令行一样使用 R 语言。</p><p>如果我们在一行上进输入一个值，那么 R 也会把它直接标准化输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 5e-2</span><br><span class="line">[1] 0.05</span><br></pre></td></tr></table></figure><h3 id="cat-函数">cat() 函数</h3><p>如果需要输出结果的拼接，我们可以使用 cat() 函数：</p><h2 id="实例-4">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\&gt; cat(1, &quot;加&quot;, 1, &quot;等于&quot;, 2, &#x27;\\n&#x27;)  </span><br><span class="line">1 加 1 等于 2  </span><br></pre></td></tr></table></figure><p>cat() 函数会在每两个拼接元素之间自动加上空格。</p><h3 id="输出内容到文件">输出内容到文件</h3><p>R 语言输出到文件的方法十分多样，而且很方便。</p><p>cat() 函数支持直接输出结果到文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat(&quot;RUNOOB&quot;, file=&quot;/Users/runoob/runoob-test/r_test.txt&quot;)</span><br></pre></td></tr></table></figure><p>这个语句不会在控制台产生结果，而是把 “RUNOOB” 输出到 “/Users/runoob/runoob-test/r_test.txt” 文件中去。</p><p>file 参数可以是绝对路径或相对路径，建议使用绝对路径，Windows 路径格式为 D:\\r_test.txt。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat(&quot;RUNOOB&quot;, file=&quot;D:\\r_test.txt&quot;)</span><br></pre></td></tr></table></figure><p>注意：这个操作是&quot;覆盖写入&quot;操作，请谨慎使用，因为它会将输出文件的原有数据清除。如果想&quot;追加写入&quot;，请不要忘记设置 append 参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat(&quot;GOOGLE&quot;, file=&quot;/Users/runoob/runoob-test/r_test.txt&quot;, append=TRUE)</span><br></pre></td></tr></table></figure><p>执行以上代码后，打开 r_test.txt 文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUNOOBGOOGLE</span><br></pre></td></tr></table></figure><h3 id="sink">sink()</h3><p>sink() 函数可以把控制台输出的文字直接输出到文件中去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sink(&quot;/Users/runoob/runoob-test/r_test.txt&quot;)</span><br></pre></td></tr></table></figure><p>这条语句执行以后，任何控制台上的输出都会被写入到 “/Users/runoob/runoob-test/r_test.txt” 文件中去，控制台将不会显示输出。</p><p>注意：这个操作也是&quot;覆盖写入&quot;操作，会直接清除原有的文件内容。</p><p>如果我们依然想保留控制台的输出，可以设置 split 属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sink(&quot;/Users/runoob/runoob-test/r_test.txt&quot;, split=TRUE)</span><br></pre></td></tr></table></figure><p>如果想取消输出到文件，可以调用无参数的 sink ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sink()</span><br></pre></td></tr></table></figure><h2 id="实例-5">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sink(&quot;r\_test.txt&quot;, split\=TRUE)  \# 控制台同样输出  </span><br><span class="line">for (i in 1:5)  </span><br><span class="line">    print(i)  </span><br><span class="line">sink()   \# 取消输出到文件</span><br><span class="line"></span><br><span class="line">sink(&quot;r\_test.txt&quot;, append\=TRUE) \# 控制台不输出，追加写入文件  </span><br><span class="line">print(&quot;RUNOOB&quot;)</span><br></pre></td></tr></table></figure><p>执行以上代码，当前目录下会生存一个 r_test.txt 文件，打开文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1] 1</span><br><span class="line">[1] 2</span><br><span class="line">[1] 3</span><br><span class="line">[1] 4</span><br><span class="line">[1] 5</span><br><span class="line">[1] &quot;RUNOOB&quot;</span><br></pre></td></tr></table></figure><p>控制台输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1] 1</span><br><span class="line">[1] 2</span><br><span class="line">[1] 3</span><br><span class="line">[1] 4</span><br><span class="line">[1] 5</span><br></pre></td></tr></table></figure><h3 id="文字输入">文字输入</h3><p>可能我们会联想到 C 语言中的 scanf 、Java 中的 java.util.Scanner，如果你学习过 Python 可能对 input() 函数更熟悉。但是 R 语言本身作为一种解释型的语言，更类似于一些终端脚本语言（比如 bash 或者 PowerShell），这些语言是基于命令系统的，本身就需要输入和输出且不适合开发面向用户的应用程序（因为他们本身就是给最终用户使用的）。因此 R 语言没有专门再从控制台读取的函数，文字输入在 R 的使用中一直在进行。</p><h3 id="从文件读入文字">从文件读入文字</h3><p>R 语言中有丰富的文件读取函数，但是如果纯粹的想将某个文件中的内容读取为字符串，可以使用 readLines 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readLines(&quot;/Users/runoob/runoob-test/r_test.txt&quot;)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;RUNOOBGOOGLE&quot;</span><br></pre></td></tr></table></figure><p>读取结果是两个字符串，分别是所读取的文件包含的两行内容。</p><blockquote><p>**注意：**所读取的文本文件每一行 (包括最后一行) 的结束必须有换行符，否则会报错。</p></blockquote><h3 id="其他方式">其他方式</h3><p>除了文字的简单输入输出以外，R 还提供了很多输入数据和输出数据的方法，R 语言最方便的地方就是可以将数据结构直接保存到文件中去，而且支持保存为 CSV、Excel 表格等形式，并且支持直接地读取。这对于数学研究者来说无疑是非常方便的。但是这些功能对于 R 语言的学习影响不大，我们将在之后的章节提到。</p><h3 id="工作目录">工作目录</h3><p>对于文件操作，我们需要设置文件的路径，R 语言可以通过以下两个函数来获取和设置当前的工作目录：</p><ul><li><strong>getwd()</strong> : 获取当前工作目录</li><li><strong>setwd()</strong> : 设置当前工作目录</li></ul><h2 id="实例-6">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\# 当前工作目录  </span><br><span class="line">print(getwd())</span><br><span class="line"></span><br><span class="line">\# 设置当前工作目录  </span><br><span class="line">setwd(&quot;/Users/runoob/runoob-test2&quot;)</span><br><span class="line"></span><br><span class="line">\# 查看当前工作目录  </span><br><span class="line">print(getwd())</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;/Users/runoob/runoob-test&quot;</span><br><span class="line">[1] &quot;/Users/tianqixin/runoob-test2&quot;</span><br></pre></td></tr></table></figure><h2 id="R-注释">R 注释</h2><p>注释主要用于一段代码的解析，可以让阅读者更易理解，编程语言的注释会被编译器忽略掉，且不会影响代码的执行。</p><p>一般编程语言的注释分为单行注释与多行注释，但是 R 语言只支持单行注释，注释符号为 #。</p><p>其实如果有多行注释我们只需要在每一行添加 # 号就好了。</p><h2 id="单行注释">单行注释</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\# 这是我的第一个编程代码  </span><br><span class="line">myString &lt;- &quot;Hello, World!&quot;</span><br><span class="line"></span><br><span class="line">print ( myString )</span><br></pre></td></tr></table></figure><h2 id="多行注释">多行注释</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\# R 语言实现两个数相加</span><br><span class="line"></span><br><span class="line">  \# 变量赋值  </span><br><span class="line">a &lt;- 9  </span><br><span class="line">b &lt;- 4</span><br><span class="line"></span><br><span class="line">  \# 输出结果  </span><br><span class="line">print(a + b)</span><br></pre></td></tr></table></figure><p>其实多行注释还有一个变通的写法，就是使用 if 语言，如下实例：</p><h2 id="多行注释-2">多行注释</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(FALSE) &#123;  </span><br><span class="line">    &quot;  </span><br><span class="line">    这是一个多行注释的实例  </span><br><span class="line">    注释内容放在单引号或双引号之间  </span><br><span class="line">    &quot;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myString &lt;- &quot;Hello, World!&quot;  </span><br><span class="line">print ( myString)</span><br></pre></td></tr></table></figure><h2 id="R-基础运算">R 基础运算</h2><p>本章介绍 R 语言的简单运算。</p><h3 id="赋值">赋值</h3><p>一般语言的赋值是 <strong>=</strong> 号，但是 R 语言是数学语言，所以赋值符号与我们数学书上的伪代码很相似，是一个左箭头 &lt;- ：</p><h2 id="实例-7">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- 123  </span><br><span class="line">b &lt;- 456  </span><br><span class="line">print(a + b)  </span><br></pre></td></tr></table></figure><p>以上代码执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] 579</span><br></pre></td></tr></table></figure><p>这个赋值符号是 R 语言的一个形式上的优点和操作上的缺点：形式上更适合数学工作者，毕竟不是所有的数学工作者都习惯于使用 <strong>=</strong> 作为赋值符号。</p><p>操作上来讲，&lt; 符号和 - 符号都不是很好打的字符，这会让很多程序员不适应。因此，R 语言的比较新的版本也支持 = 作为赋值符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 123</span><br><span class="line">b = 456</span><br><span class="line">print(a + b)</span><br></pre></td></tr></table></figure><p>这也是合法的 R 程序。</p><p>**注意：**很难考证从 R 的哪个版本开始支持了 <strong>=</strong> 赋值，但是本教程习用的 R 版本是 4.0.0。</p><h3 id="数学运算符">数学运算符</h3><p>下表列出了主要的数学运算符以及他们的运算顺序：</p><table><thead><tr><th>优先级</th><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>()</td><td>括号</td></tr><tr><td>2</td><td>^</td><td>乘方运算</td></tr><tr><td>3</td><td>%%</td><td>整除求余</td></tr><tr><td></td><td>%/%</td><td>整除</td></tr><tr><td>4</td><td>*</td><td>乘法</td></tr><tr><td></td><td>/</td><td>除法</td></tr><tr><td>5</td><td>+</td><td>加法</td></tr><tr><td></td><td>-</td><td>减法</td></tr></tbody></table><p>以下实例演示了简单的数学运算：</p><h2 id="实例-8">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">\&gt; 1 + 2 \* 3  </span><br><span class="line">\[1\] 7  </span><br><span class="line">\&gt; (1 + 2) \* 3  </span><br><span class="line">\[1\] 9  </span><br><span class="line">\&gt; 3 / 4  </span><br><span class="line">\[1\] 0.75  </span><br><span class="line">\&gt; 3.4 \- 1.2  </span><br><span class="line">\[1\] 2.2  </span><br><span class="line">\&gt; 1 \- 4 \* 0.5^3  </span><br><span class="line">\[1\] 0.5  </span><br><span class="line">\&gt; 8 / 3 %% 2  </span><br><span class="line">\[1\] 8  </span><br><span class="line">\&gt; 8 / 4 %% 2  </span><br><span class="line">\[1\] Inf  </span><br><span class="line">\&gt; 3 %% 2^2  </span><br><span class="line">\[1\] 3  </span><br><span class="line">\&gt; 10 / 3 %/% 2  </span><br><span class="line">\[1\] 10  </span><br></pre></td></tr></table></figure><h3 id="关系运算符">关系运算符</h3><p>下表列出了 R 语言支持的关系运算符，关系运算符比较两个向量，将第一向量与第二向量的每个元素进行比较，结果返回一个布尔值。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&gt;</td><td>判断第一个向量的每个元素是否大于第二个向量的相对应元素。</td></tr><tr><td>&lt;</td><td>判断第一个向量的每个元素是否小于第二个向量的相对应元素。</td></tr><tr><td>==</td><td>判断第一个向量的每个元素是否等于第二个向量的相对应元素。</td></tr><tr><td>!=</td><td>判断第一个向量的每个元素是否不等于第二个向量的相对应元素。</td></tr><tr><td>&gt;=</td><td>判断第一个向量的每个元素是否大于等于第二个向量的相对应元素。</td></tr><tr><td>&lt;=</td><td>判断第一个向量的每个元素是否小于等于第二个向量的相对应元素。</td></tr></tbody></table><h2 id="实例-9">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v &lt;- c(2,4,6,9)  </span><br><span class="line">t &lt;- c(1,4,7,9)  </span><br><span class="line">print(v\&gt;t)  </span><br><span class="line">print(v &lt; t)  </span><br><span class="line">print(v \== t)  </span><br><span class="line">print(v!=t)  </span><br><span class="line">print(v\&gt;=t)  </span><br><span class="line">print(v&lt;=t)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1]  TRUE FALSE FALSE FALSE</span><br><span class="line">[1] FALSE FALSE  TRUE FALSE</span><br><span class="line">[1] FALSE  TRUE FALSE  TRUE</span><br><span class="line">[1]  TRUE FALSE  TRUE FALSE</span><br><span class="line">[1]  TRUE  TRUE FALSE  TRUE</span><br><span class="line">[1] FALSE  TRUE  TRUE  TRUE</span><br></pre></td></tr></table></figure><h3 id="逻辑运算符">逻辑运算符</h3><p>下表列出了 R 语言支持的逻辑运算符，可用于数字、逻辑和复数类型的向量。</p><p>非 0 的数字（正数或负数）都为 TRUE。</p><p>逻辑运算符比较两个向量，将第一向量与第二向量的每个元素进行比较，结果返回一个布尔值。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>元素逻辑与运算符，将第一个向量的每个元素与第二个向量的相对应元素进行组合，如果两个元素都为 TRUE，则结果为 TRUE，否则为 FALSE。</td></tr><tr><td>｜</td><td>元素逻辑或运算符，将第一个向量的每个元素与第二个向量的相对应元素进行组合，如果两个元素中有一个为 TRUE，则结果为 TRUE，如果都为 FALSE，则返回 FALSE。</td></tr><tr><td>!</td><td>逻辑非运算符，返回向量每个元素相反的逻辑值，如果元素为 TRUE 则返回 FALSE，如果元素为 FALSE 则返回 TRUE。</td></tr><tr><td>&amp;&amp;</td><td>逻辑与运算符，只对两个向量对第一个元素进行判断，如果两个元素都为 TRUE，则结果为 TRUE，否则为 FALSE。</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="实例-10">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">v &lt;- c(3,1,TRUE,2+3i)  </span><br><span class="line">t &lt;- c(4,1,FALSE,2+3i)  </span><br><span class="line">print(v&amp;t)  </span><br><span class="line">print(v|t)  </span><br><span class="line">print(!v)</span><br><span class="line"></span><br><span class="line">\# &amp;&amp;、||只对第一个元素进行比较  </span><br><span class="line">v &lt;- c(3,0,TRUE,2+2i)  </span><br><span class="line">t &lt;- c(1,3,TRUE,2+3i)  </span><br><span class="line">print(v&amp;&amp;t)</span><br><span class="line"></span><br><span class="line">v &lt;- c(0,0,TRUE,2+2i)  </span><br><span class="line">t &lt;- c(0,3,TRUE,2+3i)  </span><br><span class="line">print(v||t)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1]  TRUE  TRUE FALSE  TRUE</span><br><span class="line">[1] TRUE TRUE TRUE TRUE</span><br><span class="line">[1] FALSE FALSE FALSE FALSE</span><br><span class="line">[1] TRUE</span><br><span class="line">[1] FALSE</span><br></pre></td></tr></table></figure><h3 id="赋值运算符">赋值运算符</h3><p>R 语言变量可以使用向左，向右或等于操作符来赋值。</p><p>下表列出了 R 语言支持的赋值运算符。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;−</code>, <code>=</code>，<code>&lt;&lt;−</code></td><td>向左赋值。</td></tr><tr><td><code>−&gt;</code>, <code>−&gt;&gt;</code></td><td>向右赋值。</td></tr></tbody></table><h2 id="实例-11">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\# 向左赋值  </span><br><span class="line">v1 &lt;- c(3,1,TRUE,&quot;runoob&quot;)  </span><br><span class="line">v2 &lt;&lt;- c(3,1,TRUE,&quot;runoob&quot;)  </span><br><span class="line">v3 \= c(3,1,TRUE,&quot;runoob&quot;)  </span><br><span class="line">print(v1)  </span><br><span class="line">print(v2)  </span><br><span class="line">print(v3)</span><br><span class="line"></span><br><span class="line">\# 向右赋值  </span><br><span class="line">c(3,1,TRUE,&quot;runoob&quot;) \-&gt; v1  </span><br><span class="line">c(3,1,TRUE,&quot;runoob&quot;) \-&gt;&gt; v2  </span><br><span class="line">print(v1)  </span><br><span class="line">print(v2)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;3&quot;      &quot;1&quot;      &quot;TRUE&quot;   &quot;runoob&quot;</span><br><span class="line">[1] &quot;3&quot;      &quot;1&quot;      &quot;TRUE&quot;   &quot;runoob&quot;</span><br><span class="line">[1] &quot;3&quot;      &quot;1&quot;      &quot;TRUE&quot;   &quot;runoob&quot;</span><br><span class="line">[1] &quot;3&quot;      &quot;1&quot;      &quot;TRUE&quot;   &quot;runoob&quot;</span><br><span class="line">[1] &quot;3&quot;      &quot;1&quot;      &quot;TRUE&quot;   &quot;runoob&quot;</span><br></pre></td></tr></table></figure><h3 id="其他运算符">其他运算符</h3><p>R 语言还包含了一些特别的运算符。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>:</td><td>冒号运算符，用于创建一系列数字的向量。</td></tr><tr><td>%in%</td><td>用于判断元素是否在向量里，返回布尔值，有的话返回 TRUE，没有返回 FALSE。</td></tr><tr><td>%*%</td><td>用于矩阵与它转置的矩阵相乘。</td></tr></tbody></table><h2 id="实例-12">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\# 1 到 10 的向量  </span><br><span class="line">v &lt;- 1:10  </span><br><span class="line">print(v)</span><br><span class="line"></span><br><span class="line">\# 判断数字是否在向量 v 中  </span><br><span class="line">v1 &lt;- 3  </span><br><span class="line">v2 &lt;- 15  </span><br><span class="line">print(v1 %in% v)  </span><br><span class="line">print(v2 %in% v)</span><br><span class="line"></span><br><span class="line">\# 矩阵与它转置的矩阵相乘  </span><br><span class="line">M \= matrix( c(2,6,5,1,10,4), nrow \= 2,ncol \= 3,byrow \= TRUE)  </span><br><span class="line">t \= M %\*% t(M)  </span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1]  1  2  3  4  5  6  7  8  9 10</span><br><span class="line">[1] TRUE</span><br><span class="line">[1] FALSE</span><br><span class="line">     [,1] [,2]</span><br><span class="line">[1,]   65   82</span><br><span class="line">[2,]   82  117</span><br></pre></td></tr></table></figure><h3 id="数学函数">数学函数</h3><p>常见对一些数学函数有：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>sqrt(n)</td><td>n的平方根</td></tr><tr><td>exp(n)</td><td>自然常数e的n次方，</td></tr><tr><td>log(m,n)</td><td>m的对数函数，返回n的几次方等于m</td></tr><tr><td>log10(m)</td><td>相当于log(m,10)</td></tr></tbody></table><p>以下实例演示了数学函数的应用：</p><h2 id="实例-13">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\&gt; sqrt(4)  </span><br><span class="line">\[1\] 2  </span><br><span class="line">\&gt; exp(1)  </span><br><span class="line">\[1\] 2.718282  </span><br><span class="line">\&gt; exp(2)  </span><br><span class="line">\[1\] 7.389056  </span><br><span class="line">\&gt; log(2,4)  </span><br><span class="line">\[1\] 0.5  </span><br><span class="line">\&gt; log10(10000)  </span><br><span class="line">\[1\] 4  </span><br></pre></td></tr></table></figure><p>取整函数：</p><table><thead><tr><th>名称</th><th>参数模型</th><th>含义</th></tr></thead><tbody><tr><td>round</td><td>(n)</td><td>对 n 四舍五入取整</td></tr><tr><td></td><td>(n, m)</td><td>对 n 保留 m 位小数四舍五入</td></tr><tr><td>ceiling</td><td>(n)</td><td>对 n 向上取整</td></tr><tr><td>floor</td><td>(n)</td><td>对 n 向下取整</td></tr></tbody></table><p>以下实例演示了取整函数的应用：</p><h2 id="实例-14">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\&gt; round(1.5)  </span><br><span class="line">\[1\] 2  </span><br><span class="line">\&gt; round(2.5)  </span><br><span class="line">\[1\] 2  </span><br><span class="line">\&gt; round(3.5)  </span><br><span class="line">\[1\] 4  </span><br><span class="line">\&gt; round(4.5)  </span><br><span class="line">\[1\] 4  </span><br></pre></td></tr></table></figure><p><strong>注意</strong>：R 中的 round 函数有些情况下可能会&quot;舍掉五&quot;。</p><p>当取整位是偶数的时候，五也会被舍去，这一点与 C 语言有所不同。</p><p>R 的三角函数是弧度制：</p><h2 id="实例-15">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\&gt; sin(pi/6)  </span><br><span class="line">\[1\] 0.5  </span><br><span class="line">\&gt; cos(pi/4)  </span><br><span class="line">\[1\] 0.7071068  </span><br><span class="line">\&gt; tan(pi/3)  </span><br><span class="line">\[1\] 1.732051  </span><br></pre></td></tr></table></figure><p>反三角函数：</p><h2 id="实例-16">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\&gt; asin(0.5)  </span><br><span class="line">\[1\] 0.5235988  </span><br><span class="line">\&gt; acos(0.7071068)  </span><br><span class="line">\[1\] 0.7853981  </span><br><span class="line">\&gt; atan(1.732051)  </span><br><span class="line">\[1\] 1.047198  </span><br></pre></td></tr></table></figure><p>如果学习过概率论和统计学，应该对以下的概率分布函数比较了解，因为 R 语言为数学工作者设计，所以经常会用到：</p><h2 id="实例-17">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\&gt; dnorm(0)  </span><br><span class="line">\[1\] 0.3989423  </span><br><span class="line">\&gt; pnorm(0)  </span><br><span class="line">\[1\] 0.5  </span><br><span class="line">\&gt; qnorm(0.95)  </span><br><span class="line">\[1\] 1.644854  </span><br><span class="line">\&gt; rnorm(3, 5, 2) \# 产生 3 个平均值为 5，标准差为 2 的正态随机数  </span><br><span class="line">\[1\] 4.177589 6.413927 4.206032  </span><br></pre></td></tr></table></figure><p>这四个都是用来计算正态分布的函数。它们的名字都以 norm 结尾，代表&quot;正态分布&quot;。</p><p>分布函数名字的前缀有四种：</p><ul><li><strong>d</strong> - 概率密度函数</li><li><strong>p</strong> - 概率密度积分函数（从无限小到 x 的积分）</li><li><strong>q</strong> - 分位数函数</li><li><strong>r</strong> - 随机数函数（常用于概率仿真）</li></ul><p><strong>注</strong>：由于本教程不是阐述数学专业理论的教程，所以对有关概率分布的数学理论不作详细解释。R 语言除了含有正态分布函数以外还有泊松分布 (pois, Poisson) 等常见分布函数，如果想详细了解可以学习&quot;概率论与数理统计&quot;。</p><h2 id="R-数据类型">R 数据类型</h2><p>数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。</p><p>变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。</p><p>R 语言中的最基本数据类型主要有三种：</p><ul><li>数字</li><li>逻辑</li><li>文本</li></ul><p>数字常量主要有两种：</p><table><thead><tr><th>一般型</th><th>123 -0.125</th></tr></thead><tbody><tr><td>科学计数法</td><td>1.23e2 -1.25E-1</td></tr></tbody></table><p>逻辑类型在许多其他编程语言中常称为布尔型（Boolean），常量值只有 <strong>TRUE</strong> 和 <strong>FALSE</strong>。</p><p>**注意：**R 语言区分大小写，true 或 True 不能代表 TRUE。</p><p>最直观的数据类型就是文本类型。文本就是其它语言中常出现的字符串（String），常量用双引号包含。在 R 语言中，文本常量既可以用单引号包含，也可以用双引号包含，例如：</p><h2 id="实例-18">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\&gt; &#x27;runoob&#x27; \== &quot;runoob&quot;  </span><br><span class="line">\[1\] TRUE  </span><br></pre></td></tr></table></figure><p>有关于 R 语言的变量定义，并不像一些强类型语言中的语法规则，需要专门为变量设置名称和数据类型，每当在 R 中使用赋值运算符时，实际上就是定义了一个新的变量：</p><h2 id="实例-19">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a \= 1  </span><br><span class="line">b &lt;- TRUE  </span><br><span class="line">b \= &quot;abc&quot;  </span><br></pre></td></tr></table></figure><p>按对象类型来分是以下 6 种（后面会详细介绍这几种类型）：</p><ul><li>向量（vector）</li><li><a href="https://www.runoob.com/r/r-list.html">列表（list）</a></li><li><a href="https://www.runoob.com/r/r-matrix.html">矩阵（matrix）</a></li><li><a href="https://www.runoob.com/r/r-array.html">数组（array）</a></li><li><a href="https://www.runoob.com/r/r-factor.html">因子（factor)</a></li><li><a href="https://www.runoob.com/r/r-data-frame.html">数据框（data.frame)</a></li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/52988954-D570-42FD-9CFC-90CD78D361C3.jpg" alt=""></p><h3 id="向量">向量</h3><p>向量（Vector）在 Java、Rust、C# 这些专门编程的的语言的标准库里往往会提供，这是因为向量在数学运算中是不可或缺的工具——我们最常见的向量是二维向量，这种向量在平面坐标系中必然会用到。</p><p>向量从数据结构上看就是一个线性表，可以看成一个数组。</p><p>R 语言中向量作为一种类型存在可以让向量的操作变得更加容易：</p><h2 id="实例-20">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\&gt; a \= c(3, 4)  </span><br><span class="line">\&gt; b \= c(5, 0)  </span><br><span class="line">\&gt; a + b  </span><br><span class="line">\[1\] 8 4  </span><br><span class="line">\&gt;  </span><br></pre></td></tr></table></figure><p>c() 是一个创造向量的函数。</p><p>这里把两个二维向量相加，得到一个新的二维向量 (8, 4)。如果将一个二维向量和三维向量做运算，将失去数学意义，虽然不会停止运行，但会被警告。</p><p>我建议大家从习惯上杜绝这种情况的出现。</p><p>向量中的每一个元素可以通过下标单独取出：</p><h2 id="实例-21">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\&gt; a \= c(10, 20, 30, 40, 50)  </span><br><span class="line">\&gt; a\[2\]  </span><br><span class="line">\[1\] 20  </span><br></pre></td></tr></table></figure><p>**注意：**R 语言中的&quot;下标&quot;不代表偏移量，而代表第几个，也就是说是从 1 开始的！</p><p>R 也可以方便的取出向量的一部分：</p><h2 id="实例-22">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\&gt; a\[1:4\] \# 取出第 1 到 4 项，包含第 1 和第 4 项  </span><br><span class="line">\[1\] 10 20 30 40  </span><br><span class="line">\&gt; a\[c(1, 3, 5)\] \# 取出第 1, 3, 5 项  </span><br><span class="line">\[1\] 10 30 50  </span><br><span class="line">\&gt; a\[c(\-1, \-5)\] \# 去掉第 1 和第 5 项  </span><br><span class="line">\[1\] 20 30 40  </span><br></pre></td></tr></table></figure><p>这三种部分取出方法是最常用的。</p><p>向量支持标量计算：</p><h2 id="实例-23">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\&gt; c(1.1, 1.2, 1.3) \- 0.5  </span><br><span class="line">\[1\] 0.6 0.7 0.8  </span><br><span class="line">\&gt; a \= c(1,2)  </span><br><span class="line">\&gt; a ^ 2  </span><br><span class="line">\[1\] 1 4  </span><br></pre></td></tr></table></figure><p>之前讲述的常用的数学运算函数，如 sqrt 、exp 等，同样可以用于对向量作标量运算。</p><p>&quot;向量&quot;作为线性表结构，应该具备一些常用的线性表处理函数，R 确实具备这些函数：</p><p>向量排序：</p><h2 id="实例-24">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\&gt; a \= c(1, 3, 5, 2, 4, 6)  </span><br><span class="line">\&gt; sort(a)  </span><br><span class="line">\[1\] 1 2 3 4 5 6  </span><br><span class="line">\&gt; rev(a)  </span><br><span class="line">\[1\] 6 4 2 5 3 1  </span><br><span class="line">\&gt; order(a)  </span><br><span class="line">\[1\] 1 4 2 5 3 6  </span><br><span class="line">\&gt; a\[order(a)\]  </span><br><span class="line">\[1\] 1 2 3 4 5 6  </span><br></pre></td></tr></table></figure><p>order() 函数返回的是一个向量排序之后的下标向量。</p><p><strong>向量统计</strong></p><p>R 中有十分完整的统计学函数：</p><table><thead><tr><th><strong>函数名</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>sum</td><td>求和</td></tr><tr><td>mean</td><td>求平均值</td></tr><tr><td>var</td><td>方差</td></tr><tr><td>sd</td><td>标准差</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>range</td><td>取值范围（二维向量，最大值和最小值）</td></tr></tbody></table><p>向量统计实例：</p><h2 id="实例-25">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\&gt; sum(1:5)  </span><br><span class="line">\[1\] 15  </span><br><span class="line">\&gt; sd(1:5)  </span><br><span class="line">\[1\] 1.581139  </span><br><span class="line">\&gt; range(1:5)  </span><br><span class="line">\[1\] 1 5  </span><br></pre></td></tr></table></figure><p><strong>向量生成</strong></p><p>向量的生成可以用 <strong>c()</strong> 函数生成，也可以用 min:max 运算符生成连续的序列。</p><p>如果想生成有间隙的等差数列，可以用 seq 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; seq(1, 9, 2)</span><br><span class="line">[1] 1 3 5 7 9</span><br></pre></td></tr></table></figure><p>seq 还可以生成从 m 到 n 的等差数列，只需要指定 m, n 以及数列的长度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; seq(0, 1, length.out=3)</span><br><span class="line">[1] 0.0 0.5 1.0</span><br></pre></td></tr></table></figure><p>rep 是 repeat（重复）的意思，可以用于产生重复出现的数字序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rep(0, 5)</span><br><span class="line">[1] 0 0 0 0 0</span><br></pre></td></tr></table></figure><p>向量中常会用到 NA 和 NULL ，这里介绍一下这两个词语与区别：</p><ul><li>NA 代表的是&quot;缺失&quot;，NULL 代表的是&quot;不存在&quot;。</li><li>NA 缺失就像占位符，代表这里没有一个值，但位置存在。</li><li>NULL 代表的就是数据不存在。</li></ul><p>实例说明：</p><h2 id="实例-26">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\&gt; length(c(NA, NA, NULL))  </span><br><span class="line">\[1\] 2  </span><br><span class="line">\&gt; c(NA, NA, NULL, NA)  </span><br><span class="line">\[1\] NA NA NA  </span><br></pre></td></tr></table></figure><p>很显然， NULL 在向量中没有任何意义。</p><hr><h2 id="逻辑型">逻辑型</h2><p>逻辑向量主要用于向量的逻辑运算，例如：</p><h2 id="实例-27">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\&gt; c(11, 12, 13) \&gt; 12  </span><br><span class="line">\[1\] FALSE FALSE  TRUE  </span><br></pre></td></tr></table></figure><p>which 函数是十分常见的逻辑型向量处理函数，可以用于筛选我们需要的数据的下标:</p><h2 id="实例-28">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\&gt; a \= c(11, 12, 13)  </span><br><span class="line">\&gt; b \= a \&gt; 12  </span><br><span class="line">\&gt; print(b)  </span><br><span class="line">\[1\] FALSE FALSE  TRUE  </span><br><span class="line">\&gt; which(b)  </span><br><span class="line">\[1\] 3  </span><br></pre></td></tr></table></figure><p>例如我们需要从一个线性表中筛选大于等于 60 且小于 70 的数据：</p><h2 id="实例-29">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\&gt; vector \= c(10, 40, 78, 64, 53, 62, 69, 70)  </span><br><span class="line">\&gt; print(vector\[which(vector \&gt;= 60 &amp; vector &lt; 70)\])  </span><br><span class="line">\[1\] 64 62 69  </span><br></pre></td></tr></table></figure><p>类似的函数还有 all 和 any：</p><h2 id="实例-30">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\&gt; all(c(TRUE, TRUE, TRUE))  </span><br><span class="line">\[1\] TRUE  </span><br><span class="line">\&gt; all(c(TRUE, TRUE, FALSE))  </span><br><span class="line">\[1\] FALSE  </span><br><span class="line">\&gt; any(c(TRUE, FALSE, FALSE))  </span><br><span class="line">\[1\] TRUE  </span><br><span class="line">\&gt; any(c(FALSE, FALSE, FALSE))  </span><br><span class="line">\[1\] FALSE  </span><br></pre></td></tr></table></figure><p>all() 用于检查逻辑向量是否全部为 TRUE，any() 用于检查逻辑向量是否含有 TRUE。</p><hr><h2 id="字符串">字符串</h2><p>字符串数据类型本身并不复杂，这里注重介绍字符串的操作函数：</p><h2 id="实例-31">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">\&gt; toupper(&quot;Runoob&quot;) \# 转换为大写  </span><br><span class="line">\[1\] &quot;RUNOOB&quot;  </span><br><span class="line">\&gt; tolower(&quot;Runoob&quot;) \# 转换为小写  </span><br><span class="line">\[1\] &quot;runoob&quot;  </span><br><span class="line">\&gt; nchar(&quot;中文&quot;, type\=&quot;bytes&quot;) \# 统计字节长度  </span><br><span class="line">\[1\] 4  </span><br><span class="line">\&gt; nchar(&quot;中文&quot;, type\=&quot;char&quot;) \# 总计字符数量  </span><br><span class="line">\[1\] 2  </span><br><span class="line">\&gt; substr(&quot;123456789&quot;, 1, 5) \# 截取字符串，从 1 到 5  </span><br><span class="line">\[1\] &quot;12345&quot;  </span><br><span class="line">\&gt; substring(&quot;1234567890&quot;, 5) \# 截取字符串，从 5 到结束  </span><br><span class="line">\[1\] &quot;567890&quot;  </span><br><span class="line">\&gt; as.numeric(&quot;12&quot;) \# 将字符串转换为数字  </span><br><span class="line">\[1\] 12  </span><br><span class="line">\&gt; as.character(12.34) \# 将数字转换为字符串  </span><br><span class="line">\[1\] &quot;12.34&quot;  </span><br><span class="line">\&gt; strsplit(&quot;2019;10;1&quot;, &quot;;&quot;) \# 分隔符拆分字符串  </span><br><span class="line">\[\[1\]\]  </span><br><span class="line">\[1\] &quot;2019&quot; &quot;10&quot;   &quot;1&quot;  </span><br><span class="line">\&gt; gsub(&quot;/&quot;, &quot;-&quot;, &quot;2019/10/1&quot;) \# 替换字符串  </span><br><span class="line">\[1\] &quot;2019-10-1&quot;  </span><br></pre></td></tr></table></figure><p>在 Windows 计算机上实现，使用的是 GBK 编码标准，所以一个中文字符是两个字节，如果在 UTF-8 编码的计算机上运行，单个中文字符的字节长度应该是 3。</p><p>R 支持 perl 语言格式的正则表达式：</p><h2 id="实例-32">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\&gt; gsub(&quot;\[\[:alpha:\]\]+&quot;, &quot;$&quot;, &quot;Two words&quot;)  </span><br><span class="line">\[1\] &quot;$ $&quot;  </span><br></pre></td></tr></table></figure><p>更多字符串内容参考：<a href="https://www.runoob.com/r/r-string.html">R 语言字符串介绍</a>。</p><hr><h2 id="矩阵">矩阵</h2><p>R 语言为线性代数的研究提供了矩阵类型，这种数据结构很类似于其它语言中的二维数组，但 R 提供了语言级的矩阵运算支持。</p><p>首先看看矩阵的生成：</p><h2 id="实例-33">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\&gt; vector\=c(1, 2, 3, 4, 5, 6)  </span><br><span class="line">\&gt; matrix(vector, 2, 3)  </span><br><span class="line">     \[,1\] \[,2\] \[,3\]  </span><br><span class="line">\[1,\]    1    3    5  </span><br><span class="line">\[2,\]    2    4    6  </span><br></pre></td></tr></table></figure><p>矩阵初始化内容是由一个向量来传递的，其次要表达一个矩阵有几行、有几列。</p><p>向量中的值会一列一列的填充到矩阵中。如果想按行填充，需要指定 byrow 属性：</p><h2 id="实例-34">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\&gt; matrix(vector, 2, 3, byrow\=TRUE)  </span><br><span class="line">     \[,1\] \[,2\] \[,3\]  </span><br><span class="line">\[1,\]    1    2    3  </span><br><span class="line">\[2,\]    4    5    6  </span><br></pre></td></tr></table></figure><p>矩阵中的每一个值都可以被直接访问：</p><h2 id="实例-35">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\&gt; m1 \= matrix(vector, 2, 3, byrow\=TRUE)  </span><br><span class="line">\&gt; m1\[1,1\] \# 第 1 行 第 1 列  </span><br><span class="line">\[1\] 1  </span><br><span class="line">\&gt; m1\[1,3\] \# 第 1 行 第 3 列  </span><br><span class="line">\[1\] 3  </span><br></pre></td></tr></table></figure><p>R 中的矩阵的每一个列和每一行都可以设定名称，这个过程通过字符串向量批量完成：</p><h2 id="实例-36">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\&gt; colnames(m1) \= c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)  </span><br><span class="line">\&gt; rownames(m1) \= c(&quot;a&quot;, &quot;b&quot;)  </span><br><span class="line">\&gt; m1  </span><br><span class="line">  x y z  </span><br><span class="line">a 1 2 3  </span><br><span class="line">b 4 5 6  </span><br><span class="line">\&gt; m1\[&quot;a&quot;, \]  </span><br><span class="line">x y z  </span><br><span class="line">1 2 3  </span><br></pre></td></tr></table></figure><p>矩阵的四则运算与向量基本一致，既可以与标量做运算，也可以与同规模的矩阵做对应位置的运算。</p><p>矩阵乘法运算：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/MVGBECflKCDs5GnJ__thumbnail.png" alt=""></p><h2 id="实例-37">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\&gt; m1 \= matrix(c(1, 2), 1, 2)  </span><br><span class="line">\&gt; m2 \= matrix(c(3, 4), 2, 1)  </span><br><span class="line">\&gt; m1 %\*% m2  </span><br><span class="line">     \[,1\]  </span><br><span class="line">\[1,\]   11  </span><br></pre></td></tr></table></figure><p>逆矩阵：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/GOSMbhCW6t98uvPl__thumbnail.png" alt=""></p><h2 id="实例-38">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\&gt; A \= matrix(c(1, 3, 2, 4), 2, 2)  </span><br><span class="line">\&gt; solve(A)  </span><br><span class="line">     \[,1\] \[,2\]  </span><br><span class="line">\[1,\] \-2.0  1.0  </span><br><span class="line">\[2,\]  1.5 \-0.5  </span><br></pre></td></tr></table></figure><p><strong>solve()</strong> 函数用于求解线性代数方程，基本用法是 solve(A,b)，其中，<strong>A</strong> 为方程组的系数矩阵，<strong>b</strong> 方程的向量或矩阵。</p><p><strong>apply()</strong> 函数可以将矩阵的每一行或每一列当作向量来进行操作：</p><h2 id="实例-39">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\&gt; (A \= matrix(c(1, 3, 2, 4), 2, 2))  </span><br><span class="line">     \[,1\] \[,2\]  </span><br><span class="line">\[1,\]    1    2  </span><br><span class="line">\[2,\]    3    4  </span><br><span class="line">\&gt; apply(A, 1, sum) \# 第二个参数为 1 按行操作，用 sum() 函数  </span><br><span class="line">\[1\] 3 7  </span><br><span class="line">\&gt; apply(A, 2, sum) \# 第二个参数为 2 按列操作  </span><br><span class="line">\[1\] 4 6  </span><br></pre></td></tr></table></figure><p>更多矩阵内容参考：<a href="https://www.runoob.com/r/r-matrix.html">R 矩阵</a>。</p><h2 id="R-判断语句">R 判断语句</h2><p>判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。</p><p>下面是大多数编程语言中典型的判断结构的一般形式：</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/12/if.png" alt=""></p><p>R 语言提供了以下类型的判断语句：</p><ul><li>if 语句</li><li>if…else 语句</li><li>switch 语句</li></ul><h3 id="if-语句">if 语句</h3><p>一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(boolean_expression) &#123;</span><br><span class="line">    // 布尔表达式为真将执行的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果布尔表达式 boolean_expression 为 ture 执行这里面的代码，如果 为 false 则不执行。</p><h2 id="实例-40">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 50L  </span><br><span class="line">if(is.integer(x)) &#123;  </span><br><span class="line">   print(&quot;X 是一个整数&quot;)  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;X 是一个整数&quot;</span><br></pre></td></tr></table></figure><h3 id="if…else-语句">if…else 语句</h3><p>一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(boolean_expression) &#123;</span><br><span class="line">    // 如果布尔表达式为真将执行的语句</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 如果布尔表达式为假将执行的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果布尔表达式 boolean_expression 为 true，则执行 if 块内的代码。如果布尔表达式为 false，则执行 else 块内的代码。</p><h2 id="实例-41">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(&quot;google&quot;,&quot;runoob&quot;,&quot;taobao&quot;)</span><br><span class="line"></span><br><span class="line">if(&quot;runoob&quot; %in% x) &#123;  </span><br><span class="line">   print(&quot;包含 runoob&quot;)  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">   print(&quot;不包含 runoob&quot;)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;包含 runoob&quot;</span><br></pre></td></tr></table></figure><p>如果有多个条件判断，可以使用 if…else if…else：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(boolean_expression 1) &#123;</span><br><span class="line">    // 如果布尔表达式 boolean_expression 1 为真将执行的语句</span><br><span class="line">&#125; else if( boolean_expression 2) &#123;</span><br><span class="line">    // 如果布尔表达式 boolean_expression 2 为真将执行的语句</span><br><span class="line">&#125; else if( boolean_expression 3) &#123;</span><br><span class="line">    // 如果布尔表达式 boolean_expression 3 为真将执行的语句</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 以上所有的布尔表达式都为 false 时执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例-42">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(&quot;google&quot;,&quot;runoob&quot;,&quot;taobao&quot;)</span><br><span class="line"></span><br><span class="line">if(&quot;weibo&quot; %in% x) &#123;  </span><br><span class="line">   print(&quot;第一个 if 包含 weibo&quot;)  </span><br><span class="line">&#125; else if (&quot;runoob&quot; %in% x) &#123;  </span><br><span class="line">   print(&quot;第二个 if 包含 runoob&quot;)  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">   print(&quot;没有找到&quot;)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;第二个 if 包含 runoob&quot;</span><br></pre></td></tr></table></figure><h3 id="switch-语句">switch 语句</h3><p>一个 switch 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch(expression, case1, case2, case3....)</span><br></pre></td></tr></table></figure><p><strong>switch</strong> 语句必须遵循下面的规则：</p><ul><li><strong>switch</strong> 语句中的 <strong>expression</strong> 是一个常量表达式，可以是整数或字符串，如果是整数则返回对应的 case 位置值，如果整数不在位置的范围内则返回 NULL。</li><li>如果匹配到多个值则返回第一个。</li><li><strong>expression</strong>如果是字符串，则对应的是 case 中的变量名对应的值，没有匹配则没有返回值。</li><li>switch 没有默认参数可用。</li></ul><p>以下实例返回第三个值：</p><h2 id="实例-43">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- switch(  </span><br><span class="line">   3,  </span><br><span class="line">   &quot;google&quot;,  </span><br><span class="line">   &quot;runoob&quot;,  </span><br><span class="line">   &quot;taobao&quot;,  </span><br><span class="line">   &quot;weibo&quot;  </span><br><span class="line">)  </span><br><span class="line">print(x)  </span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;taobao&quot;</span><br></pre></td></tr></table></figure><p>如果是字符串返回字符串变量对应的值：</p><h2 id="实例-44">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">you.like&lt;-&quot;runoob&quot;  </span><br><span class="line">switch(you.like, google\=&quot;www.google.com&quot;, runoob \= &quot;www.runoob.com&quot;, taobao \= &quot;www.taobao.com&quot;)  </span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;www.runoob.com&quot;</span><br></pre></td></tr></table></figure><p>如果整数不在范围内的则返回 NULL</p><h2 id="实例-45">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\&gt; x &lt;- switch(4,&quot;google&quot;,&quot;runoob&quot;,&quot;taobao&quot;)  </span><br><span class="line">\&gt; x  </span><br><span class="line">NULL  </span><br><span class="line">\&gt; x &lt;- switch(4,&quot;google&quot;,&quot;runoob&quot;,&quot;taobao&quot;)  </span><br><span class="line">\&gt; x  </span><br><span class="line">NULL</span><br></pre></td></tr></table></figure><h2 id="R-循环">R 循环</h2><p>有的时候，我们可能需要多次执行同一块代码。一般情况下，语句是按顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。</p><p>编程语言提供了更为复杂执行路径的多种控制结构。</p><p>循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的流程图：</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/12/loop.png" alt="循环结构"></p><p>R 语言提供的循环类型有:</p><ul><li>repeat 循环</li><li>while 循环</li><li>for 循环</li></ul><p>R 语言提供的循环控制语句有：</p><ul><li>break 语句</li><li>Next 语句</li></ul><p>循环控制语句改变你代码的执行顺序，通过它你可以实现代码的跳转。</p><h2 id="循环类型">循环类型</h2><h3 id="repeat">repeat</h3><p>repeat 循环会一直执行代码，直到条件语句为 true 时才退出循环，退出要使用到 break 语句。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">repeat &#123; </span><br><span class="line">    // 相关代码 </span><br><span class="line">    if(condition) &#123;</span><br><span class="line">       break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下实例在变量 cnt 为 5 时退出循环，cnt 为计数变量：</p><h2 id="实例-46">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v &lt;- c(&quot;Google&quot;,&quot;Runoob&quot;)  </span><br><span class="line">cnt &lt;- 2</span><br><span class="line"></span><br><span class="line">repeat &#123;  </span><br><span class="line">   print(v)  </span><br><span class="line">   cnt &lt;- cnt+1</span><br><span class="line"></span><br><span class="line">       if(cnt \&gt; 5) &#123;  </span><br><span class="line">      break  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上代码，输入结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br></pre></td></tr></table></figure><h3 id="while">while</h3><p>只要给定的条件为 true，R 语言中的 while 循环语句会重复执行一个目标语句。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(condition)</span><br><span class="line">&#123;</span><br><span class="line">   statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，statement(s) 可以是一个单独的语句，也可以是几个语句组成的代码块。</p><p>condition 可以是任意的表达式，当为任意非零值时都为 true。当条件为 true 时执行循环。 当条件为 false 时，退出循环，程序流将继续执行紧接着循环的下一条语句。</p><p>以下实例在在变量 cnt 小于 7 时输出 while 语句块中的内容，cnt 为计数变量：</p><h2 id="实例-47">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v &lt;- c(&quot;Google&quot;,&quot;Runoob&quot;)  </span><br><span class="line">cnt &lt;- 2</span><br><span class="line"></span><br><span class="line">while (cnt &lt; 7) &#123;  </span><br><span class="line">   print(v)  </span><br><span class="line">   cnt \= cnt + 1  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上代码，输入结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br></pre></td></tr></table></figure><h3 id="for">for</h3><p>R 编程语言中 for 循环语句可以重复执行指定语句，重复次数可在 for 语句中控制。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (value in vector) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>R 语言的 for 循环特别灵活，不仅可以循环整数变量，还可以对字符向量，逻辑向量，列表等数据类型进行迭代。</p><p>以下实例输出 26 个字母对前面四个字母：</p><h2 id="实例-48">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v &lt;- LETTERS\[1:4\]  </span><br><span class="line">for ( i in v) &#123;  </span><br><span class="line">   print(i)  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>执行以上代码，输入结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;A&quot;</span><br><span class="line">[1] &quot;B&quot;</span><br><span class="line">[1] &quot;C&quot;</span><br><span class="line">[1] &quot;D&quot;</span><br></pre></td></tr></table></figure><hr><h2 id="循环控制">循环控制</h2><h3 id="break">break</h3><p>R 语言的 break 语句插入在循环体中，用于退出当前循环或语句，并开始脚本执行紧接着的语句。</p><p>如果你使用循环嵌套，break 语句将停止最内层循环的执行，并开始执行的外层的循环语句。</p><p>break 也常用于 switch 语句中。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break</span><br></pre></td></tr></table></figure><p>以下实例在变量 cnt 为 5 时使用 break 退出循环，cnt 为计数变量：</p><h2 id="实例-49">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v &lt;- c(&quot;Google&quot;,&quot;Runoob&quot;)  </span><br><span class="line">cnt &lt;- 2</span><br><span class="line"></span><br><span class="line">repeat &#123;  </span><br><span class="line">   print(v)  </span><br><span class="line">   cnt &lt;- cnt+1</span><br><span class="line"></span><br><span class="line">       if(cnt \&gt; 5) &#123;  </span><br><span class="line">      break  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上代码，输入结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot;</span><br></pre></td></tr></table></figure><h3 id="next">next</h3><p>next 语句用于跳过当前循环，开始下一次循环（类似其他语言的 continue）。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next</span><br></pre></td></tr></table></figure><p>以下实例输出 26 个字母的前面 6 个字母，在字母为 D 的时候跳过当前的循环，进行下一次循环：</p><h2 id="实例-50">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v &lt;- LETTERS\[1:6\]  </span><br><span class="line">for ( i in v) &#123;</span><br><span class="line"></span><br><span class="line">       if (i \== &quot;D&quot;) &#123;  \# D 不会输出，跳过这次循环，进入下一次  </span><br><span class="line">      next  </span><br><span class="line">   &#125;  </span><br><span class="line">   print(i)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上代码，输入结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;A&quot;</span><br><span class="line">[1] &quot;B&quot;</span><br><span class="line">[1] &quot;C&quot;</span><br><span class="line">[1] &quot;E&quot;</span><br><span class="line">[1] &quot;F&quot;</span><br></pre></td></tr></table></figure><h2 id="R-函数">R 函数</h2><p>函数是一组一起执行一个任务的语句。R 语言本身提供了很多的内置函数，当然我们也可以自己创建函数。</p><p>您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</p><p>函数<strong>声明</strong>告诉编译器函数的名称、返回类型和参数。函数<strong>定义</strong>提供了函数的实际主体。</p><p>R 语言中函数是一个对象，可以拥有属性。</p><h2 id="定义函数">定义函数</h2><p>函数定义通常由以下几个部分组成：</p><ul><li><strong>函数名:</strong> 为函数指定一个唯一的名称，以便在调用时使用。</li><li><strong>参数:</strong> 定义函数接受的输入值。参数是可选的，可以有多个。</li><li><strong>函数体:</strong> 包含实际执行的代码块，用大括号 {} 括起来。</li><li><strong>返回值:</strong> 指定函数的输出结果，使用关键字<code>return</code>。</li></ul><p>R 语言中的函数定义使用 function 关键字，一般形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function_name &lt;- function(arg_1, arg_2, ...) &#123;</span><br><span class="line">    # 函数体</span><br><span class="line">    # 执行的代码块</span><br><span class="line">    return(output)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>function_name : 为函数名</li><li>arg_1, arg_2, … : 形式参数列表</li></ul><p>函数返回值使用 return()。</p><p>以下是一个简单的例子，展示如何定义和使用函数：</p><h2 id="实例-51">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\# 定义一个加法函数  </span><br><span class="line">add\_numbers &lt;- function(x, y) &#123;  </span><br><span class="line">  result &lt;- x + y  </span><br><span class="line">  return(result)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\# 调用函数  </span><br><span class="line">sum\_result &lt;- add\_numbers(3, 4)  </span><br><span class="line">print(sum\_result)  \# 输出 7</span><br></pre></td></tr></table></figure><p>以上代码中，我们定义了一个名为 <strong>add_numbers</strong> 的函数，它接受两个参数 <strong>x</strong> 和 <strong>y</strong>。函数体中的代码将这两个参数相加，并将结果存储在变量 <strong>result</strong> 中。最后，使用 <strong>return</strong> 关键字返回结果。</p><p>要调用函数，我们使用函数名后跟参数列表的形式，将参数的值传递给函数。在本例中，我们调用 <strong>add_numbers</strong> 函数，并传递参数 3 和 4。函数执行后，返回结果 7，我们将其存储在变量 <strong>sum_result</strong> 中，并打印输出。</p><h3 id="自定义函数">自定义函数</h3><p>我们可以自己创建函数，用于特定到功能，定义后可以向内置函数一样使用它们。</p><p>下面演示两如何自定义函数：</p><h2 id="实例-52">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\# 定义一个函数，用于计数一个系列到平方值  </span><br><span class="line">new.function &lt;- function(a) &#123;  </span><br><span class="line">   for(i in 1:a) &#123;  </span><br><span class="line">      b &lt;- i^2  </span><br><span class="line">      print(b)  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>接下来我们可以调用函数：</p><h2 id="实例-53">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new.function &lt;- function(a) &#123;  </span><br><span class="line">    for(i in 1:a) &#123;  </span><br><span class="line">       b &lt;- i^2  </span><br><span class="line">       print(b)  </span><br><span class="line">    &#125;  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  \# 调用函数，并传递参数  </span><br><span class="line">new.function(6)</span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1] 1</span><br><span class="line">[1] 4</span><br><span class="line">[1] 9</span><br><span class="line">[1] 16</span><br><span class="line">[1] 25</span><br><span class="line">[1] 36</span><br></pre></td></tr></table></figure><p>我们也可以创建一个不带参数的函数：</p><h2 id="实例-54">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new.function &lt;- function() &#123;  </span><br><span class="line">    for(i in 1:5) &#123;  </span><br><span class="line">        print(i^2)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  \# 调用函数，不需要传递参数  </span><br><span class="line">new.function()</span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1] 1</span><br><span class="line">[1] 4</span><br><span class="line">[1] 9</span><br><span class="line">[1] 16</span><br><span class="line">[1] 25</span><br></pre></td></tr></table></figure><h3 id="带有参数值的函数">带有参数值的函数</h3><p>函数参数，可以按函数创建时的顺序来传递，也可以不按顺序，但需要指定参数名：</p><h2 id="实例-55">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\# 创建函数  </span><br><span class="line">new.function &lt;- function(a,b,c) &#123;  </span><br><span class="line">   result &lt;- a \* b + c  </span><br><span class="line">   print(result)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\# 不带参数名  </span><br><span class="line">new.function(5,3,11)</span><br><span class="line"></span><br><span class="line">\# 带参数名  </span><br><span class="line">new.function(a \= 11, b \= 5, c \= 3)</span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1] 26</span><br><span class="line">[1] 58</span><br></pre></td></tr></table></figure><p>函数创建时也可以为参数指定默认值，如果调用的时候不传递参数就会使用默认值：</p><h2 id="实例-56">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\# 创建带默认参数的函数  </span><br><span class="line">new.function &lt;- function(a \= 3, b \= 6) &#123;  </span><br><span class="line">   result &lt;- a \* b  </span><br><span class="line">   print(result)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\# 调用函数，但不传递参数，会使用默认的  </span><br><span class="line">new.function()</span><br><span class="line"></span><br><span class="line">\# 调用函数，传递参数  </span><br><span class="line">new.function(9,5)</span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><p>[1] 18 [1] 45</p><h3 id="懒惰计算的函数">懒惰计算的函数</h3><p>懒惰计算将推迟计算工作直到系统需要这些计算的结果。如果不需要结果，将不用进行计算。</p><p>默认情况下，R 函数对参数的计算是懒惰的，就是只有我们在计算它的时候才会调用：</p><h2 id="实例-57">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(x) &#123;  </span><br><span class="line">  10  </span><br><span class="line">&#125;  </span><br><span class="line">f()  </span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] 10</span><br></pre></td></tr></table></figure><p>以上代码执行，并没有报错，虽然我们没有传入参数，但函数体内没有使用参数 x，所以不会去调用它，也不会报错。</p><h2 id="实例-58">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new.function &lt;- function(a, b) &#123;  </span><br><span class="line">   print(a^2)  </span><br><span class="line">   print(a)  </span><br><span class="line">   print(b)  \# 使用到 b，但未传入，所以会报错  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\# 传入一个参数  </span><br><span class="line">new.function(6)</span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1] 36</span><br><span class="line">[1] 6</span><br><span class="line">Error in print(b) : 缺少参数&quot;b&quot;,也没有缺省值</span><br><span class="line">Calls: new.function -&gt; print</span><br><span class="line">停止执行</span><br></pre></td></tr></table></figure><hr><h2 id="内置函数">内置函数</h2><p>R 语言提供了很多有用的内置函数，我们无需定义它就可以直接使用。</p><p>例如：seq(), mean(), max(), sum(x) 以及 paste(…) 等。</p><h2 id="实例-59">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\# 输出  32 到 44 到的所有数字  </span><br><span class="line">print(seq(32,44))</span><br><span class="line"></span><br><span class="line">\# 计算两个数的平均数  </span><br><span class="line">print(mean(25:82))</span><br><span class="line"></span><br><span class="line">\# 计算 41 到 68 所有数字之和  </span><br><span class="line">print(sum(41:68))</span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> [1] 32 33 34 35 36 37 38 39 40 41 42 43 44</span><br><span class="line">[1] 53.5</span><br><span class="line">[1] 1526</span><br></pre></td></tr></table></figure><p>sum(): 计算向量或矩阵的总和。</p><h2 id="实例-60">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\# 向量求和  </span><br><span class="line">x &lt;- c(1, 2, 3, 4, 5)  </span><br><span class="line">total &lt;- sum(x)  </span><br><span class="line">print(total)  \# 输出 15</span><br><span class="line"></span><br><span class="line">\# 矩阵求和  </span><br><span class="line">matrix &lt;- matrix(1:9, nrow \= 3)  </span><br><span class="line">total &lt;- sum(matrix)  </span><br><span class="line">print(total)  \# 输出 45</span><br></pre></td></tr></table></figure><p>mean(): 计算向量或矩阵的平均值。</p><h2 id="实例-61">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\# 向量平均值  </span><br><span class="line">x &lt;- c(1, 2, 3, 4, 5)  </span><br><span class="line">avg &lt;- mean(x)  </span><br><span class="line">print(avg)  \# 输出 3</span><br><span class="line"></span><br><span class="line">\# 矩阵平均值  </span><br><span class="line">matrix &lt;- matrix(1:9, nrow \= 3)  </span><br><span class="line">avg &lt;- mean(matrix)  </span><br><span class="line">print(avg)  \# 输出 5</span><br></pre></td></tr></table></figure><p>paste(): 将多个字符串连接成一个字符串。</p><h2 id="实例-62">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- &quot;Hello&quot;  </span><br><span class="line">y &lt;- &quot;World&quot;  </span><br><span class="line">result &lt;- paste(x, y)  </span><br><span class="line">print(result)  \# 输出 &quot;Hello World&quot;  </span><br></pre></td></tr></table></figure><p>length(): 返回向量的长度或对象的元素个数。</p><h2 id="实例-63">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(1, 2, 3, 4, 5)  </span><br><span class="line">length\_x &lt;- length(x)  </span><br><span class="line">print(length\_x)  \# 输出 5</span><br><span class="line"></span><br><span class="line">matrix &lt;- matrix(1:9, nrow \= 3)  </span><br><span class="line">length\_matrix &lt;- length(matrix)  </span><br><span class="line">print(length\_matrix)  \# 输出 9</span><br></pre></td></tr></table></figure><p>str(): 显示对象的结构和内容摘要。</p><h2 id="实例-64">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(1, 2, 3, 4, 5)  </span><br><span class="line">str(x)  </span><br><span class="line">\# 输出：  </span><br><span class="line">\# num \[1:5\] 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">matrix &lt;- matrix(1:9, nrow \= 3)  </span><br><span class="line">str(matrix)  </span><br><span class="line">\# 输出：  </span><br><span class="line">\#  int \[1:3, 1:3\] 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>以上只列举了一小部分的 R 语言函数实例，R 有大量的内置函数和扩展包提供的函数，可以满足各种数据处理、统计分析、绘图等需求，您可以查阅 R 语言的官方文档获得更详细的函数列表和使用说明。</p><h2 id="R-字符串">R 字符串</h2><p>R 语言中，字符串是一种表示文本数据的数据类型，它由字符（字符向量）组成，可以包含字母、数字、符号和空格等字符。</p><p>R 语言字符串可以使用一对单引号 ’ ’ 或一对双引号 &quot; &quot; 来表示。</p><ul><li>单引号字符串中可以包含双引号。</li><li>单引号字符串中不可以包含单引号。</li><li>双引号字符串中可以包含单引号。</li><li>双引号字符串中不可以包含双引号。</li></ul><p>**创建字符串：**您可以使用单引号或双引号来创建字符串。</p><p>以下实例演示来字符串的使用：</p><h2 id="实例-65">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- &#x27;使用单引号&#x27;  </span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">b &lt;- &quot;使用双引号&quot;  </span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">c &lt;- &quot;双引号字符串中可以包含单引号（&#x27;） &quot;  </span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">d &lt;- &#x27;单引号字符串中可以包含双引号（&quot;） &#x27;  </span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;使用单引号&quot;</span><br><span class="line">[1] &quot;使用双引号&quot;</span><br><span class="line">[1] &quot;双引号字符串中可以包含单引号（&#x27;） &quot;</span><br><span class="line">[1] &quot;单引号字符串中可以包含双引号（\&quot;） &quot;</span><br></pre></td></tr></table></figure><hr><h2 id="字符串操作">字符串操作</h2><p>R 语言提供了多种操作字符串的函数和操作符，使得处理和操作文本数据变得方便。</p><p>以下我们来看下 R 语言一些内置函数对字符串对操作。</p><h3 id="paste-函数">paste() 函数</h3><p>paste() 函数用于使用指定对分隔符来对字符串进行连接，默认的分隔符为空格。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste(..., sep = &quot; &quot;, collapse = NULL)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>… ： 字符串列表</li><li>sep ： 分隔符，默认为空格</li><li>collapse ： 两个或者更多字符串对象根据元素对应关系拼接到一起，在字符串进行连接后，再使用 collapse 指定对连接符进行连接</li></ul><h2 id="实例-66">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- &quot;Google&quot;  </span><br><span class="line">b &lt;- &#x27;Runoob&#x27;  </span><br><span class="line">c &lt;- &quot;Taobao&quot;</span><br><span class="line"></span><br><span class="line">print(paste(a,b,c))</span><br><span class="line"></span><br><span class="line">print(paste(a,b,c, sep \= &quot;-&quot;))</span><br><span class="line"></span><br><span class="line">print(paste(letters\[1:6\],1:6, sep \= &quot;&quot;, collapse \= &quot;=&quot;))  </span><br><span class="line">paste(letters\[1:6\],1:6, collapse \= &quot;.&quot;)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;Google Runoob Taobao&quot;</span><br><span class="line">[1] &quot;Google-Runoob-Taobao&quot;</span><br><span class="line">[1] &quot;a1=b2=c3=d4=e5=f6&quot;</span><br><span class="line">[1] &quot;a 1.b 2.c 3.d 4.e 5.f 6&quot;</span><br></pre></td></tr></table></figure><h3 id="format-函数">format() 函数</h3><p>format() 函数用于格式化字符串，format() 可作用于字符串或数字。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">format(x, digits, nsmall, scientific, width, justify = c(&quot;left&quot;, &quot;right&quot;, &quot;centre&quot;, &quot;none&quot;)) </span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>x ： 输入对向量</li><li>digits ： 显示的位数</li><li>nsmall ： 小数点右边显示的最少位数</li><li>scientific ： 设置科学计数法</li><li>width ： 通过开头填充空白来显示最小的宽度</li><li>justify：设置位置，显示可以是左边、右边、中间等。</li></ul><h2 id="实例-67">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">\# 显示 9 位，最后一位四舍五入  </span><br><span class="line">result &lt;- format(23.123456789, digits \= 9)  </span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">\# 使用科学计数法显示  </span><br><span class="line">result &lt;- format(c(6, 13.14521), scientific \= TRUE)  </span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">\# 小数点右边最小显示 5 位，没有的以 0 补充  </span><br><span class="line">result &lt;- format(23.47, nsmall \= 5)  </span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">\# 将数字转为字符串  </span><br><span class="line">result &lt;- format(6)  </span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">\# 宽度为 6 位，不够的在开头添加空格  </span><br><span class="line">result &lt;- format(13.7, width \= 6)  </span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">\# 左对齐字符串  </span><br><span class="line">result &lt;- format(&quot;Runoob&quot;, width \= 9, justify \= &quot;l&quot;)  </span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">\# 居中显示  </span><br><span class="line">result &lt;- format(&quot;Runoob&quot;, width \= 10, justify \= &quot;c&quot;)  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;23.1234568&quot;</span><br><span class="line">[1] &quot;6.000000e+00&quot; &quot;1.314521e+01&quot;</span><br><span class="line">[1] &quot;23.47000&quot;</span><br><span class="line">[1] &quot;6&quot;</span><br><span class="line">[1] &quot;  13.7&quot;</span><br><span class="line">[1] &quot;Runoob   &quot;</span><br><span class="line">[1] &quot;  Runoob  &quot;</span><br></pre></td></tr></table></figure><h3 id="nchar-函数">nchar() 函数</h3><p>nchar() 函数用于计数字符串或数字列表的长度。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nchar(x)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>x ： 向量或字符串</li></ul><h2 id="实例-68">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result &lt;- nchar(&quot;Google Runoob Taobao&quot;)  </span><br><span class="line">print(result)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] 20</span><br></pre></td></tr></table></figure><h3 id="toupper-tolower-函数">toupper() &amp; tolower() 函数</h3><p>toupper() &amp; tolower() 函数用于将字符串的字母转化为大写或者小写。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toupper(x)</span><br><span class="line">tolower(x)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>x ： 向量或字符串</li></ul><p># 转大写</p><h2 id="实例-69">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result &lt;- toupper(&quot;Runoob&quot;)  </span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">\# 转小写  </span><br><span class="line">result &lt;- tolower(&quot;Runoob&quot;)  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;RUNOOB&quot;</span><br><span class="line">[1] &quot;runoob&quot;</span><br></pre></td></tr></table></figure><h3 id="substring-函数">substring() 函数</h3><p>substring() 函数用于截取字符串。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">substring(x,first,last)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>x ： 向量或字符串</li><li>first ： 开始截取的位置</li><li>last： 结束截取的位置</li></ul><h2 id="实例-70">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\# 从第 2 位截取到第 5 位  </span><br><span class="line">result &lt;- substring(&quot;Runoob&quot;, 2, 5)  </span><br><span class="line">print(result)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;unoo&quot;</span><br></pre></td></tr></table></figure><h3 id="字符串替换">字符串替换</h3><p>使用 <strong>gsub()</strong> 函数来替换字符串中的特定字符或模式。</p><h2 id="实例-71">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str &lt;- &quot;Hello, World!&quot;  </span><br><span class="line">new\_str &lt;- gsub(&quot;World&quot;, &quot;R&quot;, str)  </span><br><span class="line">\# 输出： &quot;Hello, R!&quot;  </span><br></pre></td></tr></table></figure><h3 id="字符串拆分">字符串拆分</h3><p>使用 <strong>strsplit()</strong> 函数将字符串拆分为子字符串。</p><h2 id="实例-72">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str &lt;- &quot;Hello, World!&quot;  </span><br><span class="line">split\_str &lt;- strsplit(str, &quot;,&quot;)  </span><br><span class="line">\# 输出： List of 1  </span><br><span class="line">\#         \[\[1\]\]  </span><br><span class="line">\#         \[1\] &quot;Hello&quot;   &quot; World!&quot;  </span><br></pre></td></tr></table></figure><p>以上只列举了一小部分的 R 语言字符串操作实例，R 有大量的字符串处理函数和操作符，例如模式匹配、大小写转换、字符串比较等，您可以查阅 R 语言的官方文档获得更多字符串操作函数列表和使用说明。</p><h2 id="R-列表">R 列表</h2><p>列表是 R 语言的对象集合，可以用来保存不同类型的数据，可以是数字、字符串、向量、另一个列表、矩阵、数据框等，当然还可以包含矩阵和函数。</p><p>列表是一种灵活的数据结构，可以存储和操作多种类型的数据对象。</p><h3 id="创建列表">创建列表</h3><p>R 语言创建列表使用 list() 函数。</p><p>如下实例，我们创建一个列表，包含了字符串、向量和数字：</p><h2 id="实例-73">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list\_data &lt;- list(&quot;runoob&quot;, &quot;google&quot;, c(11,22,33), 123, 51.23, 119.1)  </span><br><span class="line">print(list\_data)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[[1]]</span><br><span class="line">[1] &quot;runoob&quot;</span><br><span class="line"></span><br><span class="line">[[2]]</span><br><span class="line">[1] &quot;google&quot;</span><br><span class="line"></span><br><span class="line">[[3]]</span><br><span class="line">[1] 11 22 33</span><br><span class="line"></span><br><span class="line">[[4]]</span><br><span class="line">[1] 123</span><br><span class="line"></span><br><span class="line">[[5]]</span><br><span class="line">[1] 51.23</span><br><span class="line"></span><br><span class="line">[[6]]</span><br><span class="line">[1] 119.1</span><br></pre></td></tr></table></figure><p>我们也可以使用 c() 函数来创建列表，也可以使用该函数将多个对象合并为一个列表，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_list &lt;- c(object1, object2, object3)</span><br></pre></td></tr></table></figure><h2 id="实例-74">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\# 创建包含数字的向量  </span><br><span class="line">numbers &lt;- c(1, 2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line">\# 创建包含字符的向量  </span><br><span class="line">characters &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;)</span><br><span class="line"></span><br><span class="line">\# 合并两个数字向量  </span><br><span class="line">merged\_vector &lt;- c(numbers, c(6, 7, 8))</span><br><span class="line"></span><br><span class="line">\# 合并两个字符向量  </span><br><span class="line">merged\_characters &lt;- c(characters, c(&quot;grape&quot;, &quot;melon&quot;))</span><br></pre></td></tr></table></figure><p>我们可以使用 names() 函数给列表的元素命名：</p><h2 id="实例-75">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\# 列表包含向量、矩阵、列表  </span><br><span class="line">list\_data &lt;- list(c(&quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;), matrix(c(1,2,3,4,5,6), nrow \= 2),  </span><br><span class="line">   list(&quot;runoob&quot;,12.3))</span><br><span class="line"></span><br><span class="line">\# 给列表元素设置名字  </span><br><span class="line">names(list\_data) &lt;- c(&quot;Sites&quot;, &quot;Numbers&quot;, &quot;Lists&quot;)</span><br><span class="line"></span><br><span class="line">\# 显示列表  </span><br><span class="line">print(list\_data)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$Sites</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot; &quot;Taobao&quot;</span><br><span class="line"></span><br><span class="line">$Numbers</span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    1    3    5</span><br><span class="line">[2,]    2    4    6</span><br><span class="line"></span><br><span class="line">$Lists</span><br><span class="line">$Lists[[1]]</span><br><span class="line">[1] &quot;runoob&quot;</span><br><span class="line"></span><br><span class="line">$Lists[[2]]</span><br><span class="line">[1] 12.3</span><br></pre></td></tr></table></figure><h3 id="访问列表">访问列表</h3><p>列表中的元素可以使用索引来访问，如果使用来 <strong>names()</strong> 函数命名后，我们还可以使用对应名字来访问：</p><h2 id="实例-76">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">\# 列表包含向量、矩阵、列表  </span><br><span class="line">list\_data &lt;- list(c(&quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;), matrix(c(1,2,3,4,5,6), nrow \= 2),  </span><br><span class="line">   list(&quot;runoob&quot;,12.3))</span><br><span class="line"></span><br><span class="line">\# 给列表元素设置名字  </span><br><span class="line">names(list\_data) &lt;- c(&quot;Sites&quot;, &quot;Numbers&quot;, &quot;Lists&quot;)</span><br><span class="line"></span><br><span class="line">\# 显示列表  </span><br><span class="line">print(list\_data\[1\])</span><br><span class="line"></span><br><span class="line">\# 访问列表的第三个元素  </span><br><span class="line">print(list\_data\[3\])</span><br><span class="line"></span><br><span class="line">\# 访问第一个向量元素  </span><br><span class="line">print(list\_data$Numbers)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$Sites</span><br><span class="line">[1] &quot;Google&quot; &quot;Runoob&quot; &quot;Taobao&quot;</span><br><span class="line"></span><br><span class="line">$Lists</span><br><span class="line">$Lists[[1]]</span><br><span class="line">[1] &quot;runoob&quot;</span><br><span class="line"></span><br><span class="line">$Lists[[2]]</span><br><span class="line">[1] 12.3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    1    3    5</span><br><span class="line">[2,]    2    4    6</span><br></pre></td></tr></table></figure><h3 id="操作列表元素">操作列表元素</h3><p>我们可以对列表进行添加、删除、更新的操作，如下实例：</p><h2 id="实例-77">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">\# 列表包含向量、矩阵、列表  </span><br><span class="line">list\_data &lt;- list(c(&quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;), matrix(c(1,2,3,4,5,6), nrow \= 2),  </span><br><span class="line">   list(&quot;runoob&quot;,12.3))</span><br><span class="line"></span><br><span class="line">\# 给列表元素设置名字  </span><br><span class="line">names(list\_data) &lt;- c(&quot;Sites&quot;, &quot;Numbers&quot;, &quot;Lists&quot;)</span><br><span class="line"></span><br><span class="line">\# 添加元素  </span><br><span class="line">list\_data\[4\] &lt;- &quot;新元素&quot;  </span><br><span class="line">print(list\_data\[4\])</span><br><span class="line"></span><br><span class="line">\# 删除元素  </span><br><span class="line">list\_data\[4\] &lt;- NULL</span><br><span class="line"></span><br><span class="line">\# 删除后输出为 NULL  </span><br><span class="line">print(list\_data\[4\])</span><br><span class="line"></span><br><span class="line">\# 更新元素  </span><br><span class="line">list\_data\[3\] &lt;- &quot;我替换来第三个元素&quot;  </span><br><span class="line">print(list\_data\[3\])</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[1]]</span><br><span class="line">[1] &quot;新元素&quot;</span><br><span class="line"></span><br><span class="line">$&lt;NA&gt;</span><br><span class="line">NULL</span><br><span class="line"></span><br><span class="line">$Lists</span><br><span class="line">[1] &quot;我替换来第三个元素&quot;</span><br></pre></td></tr></table></figure><p>使用 for 循环遍历列表时：</p><h2 id="实例-78">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\# 创建一个包含数字和字符的列表  </span><br><span class="line">my\_list &lt;- list(1, 2, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</span><br><span class="line"></span><br><span class="line">\# 使用 for 循环遍历列表中的每个元素  </span><br><span class="line">for (element in my\_list) &#123;  </span><br><span class="line">  print(element)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，for 循环会依次遍历列表 my_list 中的每个元素，并将每个元素存储在变量 element 中。然后，我们可以在循环体内对每个元素执行特定的操作，例如使用 print() 函数打印元素的值。</p><p>for 循环遍历列表时，每次循环都将当前元素赋值给变量 element。因此，在循环体内可以对 element 进行任何需要的操作，例如计算、条件判断等。</p><p>需要注意的是，使用 for 循环遍历列表时，循环变量 element 将依次取到列表中的每个元素，但不能直接修改列表元素本身。如果需要修改列表中的元素值，可以通过索引来实现，例如 my_list[[index]] &lt;- new_value。</p><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1] 1</span><br><span class="line">[1] 2</span><br><span class="line">[1] 3</span><br><span class="line">[1] &quot;a&quot;</span><br><span class="line">[1] &quot;b&quot;</span><br><span class="line">[1] &quot;c&quot;</span><br></pre></td></tr></table></figure><h3 id="合并列表">合并列表</h3><p>我们可以使用 c() 函数将多个列表合并为一个列表：</p><h2 id="实例-79">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\# 创建两个列表  </span><br><span class="line">list1 &lt;- list(1,2,3)  </span><br><span class="line">list2 &lt;- list(&quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;)</span><br><span class="line"></span><br><span class="line">\# 合并列表  </span><br><span class="line">merged.list &lt;- c(list1,list2)</span><br><span class="line"></span><br><span class="line">\# 显示合并后的列表  </span><br><span class="line">print(merged.list)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[[1]]</span><br><span class="line">[1] 1</span><br><span class="line"></span><br><span class="line">[[2]]</span><br><span class="line">[1] 2</span><br><span class="line"></span><br><span class="line">[[3]]</span><br><span class="line">[1] 3</span><br><span class="line"></span><br><span class="line">[[4]]</span><br><span class="line">[1] &quot;Google&quot;</span><br><span class="line"></span><br><span class="line">[[5]]</span><br><span class="line">[1] &quot;Runoob&quot;</span><br><span class="line"></span><br><span class="line">[[6]]</span><br><span class="line">[1] &quot;Taobao&quot;</span><br></pre></td></tr></table></figure><h3 id="列表转换为向量">列表转换为向量</h3><p>要将列表转换为向量可以使用 unlist() 函数，将列表转换为向量，可以方便我们进行算术运算：</p><h2 id="实例-80">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">\# 创建列表  </span><br><span class="line">list1 &lt;- list(1:5)  </span><br><span class="line">print(list1)</span><br><span class="line"></span><br><span class="line">list2 &lt;-list(10:14)  </span><br><span class="line">print(list2)</span><br><span class="line"></span><br><span class="line">\# 转换为向量  </span><br><span class="line">v1 &lt;- unlist(list1)  </span><br><span class="line">v2 &lt;- unlist(list2)</span><br><span class="line"></span><br><span class="line">print(v1)  </span><br><span class="line">print(v2)</span><br><span class="line"></span><br><span class="line">\# 两个向量相加  </span><br><span class="line">result &lt;- v1+v2  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[1]]</span><br><span class="line">[1] 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">[[1]]</span><br><span class="line">[1] 10 11 12 13 14</span><br><span class="line"></span><br><span class="line">[1] 1 2 3 4 5</span><br><span class="line">[1] 10 11 12 13 14</span><br><span class="line">[1] 11 13 15 17 19</span><br></pre></td></tr></table></figure><h3 id="归纳总结">归纳总结</h3><p>以下是一些常用的 R 语言列表操作和函数：</p><p><strong>创建列表：</strong></p><ul><li>使用 c() 函数：例如，list1 &lt;- c(1, 2, 3) 创建一个包含 1、2 和 3 的列表。</li><li>使用 list() 函数：例如，list2 &lt;- list(1, “a”, TRUE) 创建一个包含不同类型元素的列表。</li></ul><p><strong>访问列表元素：</strong></p><ul><li>使用索引：通过索引访问列表中的元素。例如，list1[1] 返回列表中的第一个元素。</li><li>使用元素名称：如果列表中的元素有名称，可以使用名称来访问它们。例如，list3 &lt;- list(a = 1, b = 2) 可以通过 list3a 和 list3b 来访问元素。</li></ul><p><strong>列表操作：</strong></p><ul><li>长度：使用 length() 函数获取列表的长度。例如，length(list1) 返回列表 list1 的长度。</li><li>合并：使用 c() 函数或 append() 函数将两个或多个列表合并为一个列表。例如，list4 &lt;- c(list1, list2) 合并列表 list1 和 list2。</li><li>增加元素：使用 c() 函数将元素添加到现有列表中。例如，list1 &lt;- c(list1, 4) 将 4 添加到列表 list1 的末尾。</li><li>删除元素：使用索引和负索引操作符 - 删除列表中的元素。例如，list1 &lt;- list1[-2] 删除列表 list1 中的第二个元素。</li></ul><p><strong>列表循环：</strong></p><ul><li>for 循环：使用 for 循环遍历列表中的元素。例如，for (element in list1) { … } 遍历列表 list1 中的每个元素。</li><li>lapply() 函数：将一个函数应用于列表中的每个元素，并返回结果列表。例如，new_list &lt;- lapply(list1, function(x) x * 2) 将列表 list1 中的每个元素乘以 2。</li></ul><h2 id="R-矩阵">R 矩阵</h2><p>R 语言为线性代数的研究提供了矩阵类型，这种数据结构很类似于其它语言中的二维数组，但 R 提供了语言级的矩阵运算支持。</p><p>矩阵里的元素可以是数字、符号或数学式。</p><p>一个 M x N 的矩阵是一个由 <strong>M（row） 行</strong> 和 **N 列（column）**元素排列成的矩形阵列。</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/Matrix_zh-hans.png" alt=""></p><p>以下是一个由 6 个数字元素构成的 2 行 3 列的矩阵：</p><p><img src="https://static.jyshare.com/images/mix/61f786996bcfb75972dd77712c90122bc8765269.svg" alt=""></p><p>R 语言的矩阵可以使用 matrix() 函数来创建，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE,dimnames = NULL)</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><p><strong>data</strong> 向量，矩阵的数据</p></li><li><p><strong>nrow</strong> 行数</p></li><li><p><strong>ncol</strong> 列数</p></li><li><p><strong>byrow</strong> 逻辑值，为 FALSE 按列排列，为 TRUE 按行排列</p></li><li><p><strong>dimname</strong> 设置行和列的名称</p></li></ul><p>创建一个数字矩阵：</p><h2 id="实例-81">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\# byrow 为 TRUE 元素按行排列  </span><br><span class="line">M &lt;- matrix(c(3:14), nrow \= 4, byrow \= TRUE)  </span><br><span class="line">print(M)</span><br><span class="line"></span><br><span class="line">\# Ebyrow 为 FALSE 元素按列排列  </span><br><span class="line">N &lt;- matrix(c(3:14), nrow \= 4, byrow \= FALSE)  </span><br><span class="line">print(N)</span><br><span class="line"></span><br><span class="line">\# 定义行和列的名称  </span><br><span class="line">rownames \= c(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;, &quot;row4&quot;)  </span><br><span class="line">colnames \= c(&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;)</span><br><span class="line"></span><br><span class="line">P &lt;- matrix(c(3:14), nrow \= 4, byrow \= TRUE, dimnames \= list(rownames, colnames))  </span><br><span class="line">print(P)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[,1] [,2] [,3]</span><br><span class="line">[1,]    3    4    5</span><br><span class="line">[2,]    6    7    8</span><br><span class="line">[3,]    9   10   11</span><br><span class="line">[4,]   12   13   14</span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    3    7   11</span><br><span class="line">[2,]    4    8   12</span><br><span class="line">[3,]    5    9   13</span><br><span class="line">[4,]    6   10   14</span><br><span class="line">     col1 col2 col3</span><br><span class="line">row1    3    4    5</span><br><span class="line">row2    6    7    8</span><br><span class="line">row3    9   10   11</span><br><span class="line">row4   12   13   14</span><br></pre></td></tr></table></figure><h3 id="转置矩阵">转置矩阵</h3><p>R 语言矩阵提供了 t() 函数，可以实现矩阵的行列互换。</p><p>例如有个 m 行 n 列的矩阵，使用 t() 函数就能转换为 n 行 m 列的矩阵。</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/Matrix_transpose.gif" alt=""></p><p><img src="https://static.jyshare.com/images/mix/4a92835c45d5cd15dd00a8d90c14bdb4b8150ef0.svg" alt=""></p><p><img src="https://static.jyshare.com/images/mix/8a1e10800e0d0e3ffa90917139532cfb8348fc63.svg" alt=""></p><h2 id="实例-82">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\# 创建一个 2 行 3 列的矩阵  </span><br><span class="line">M \= matrix( c(2,6,5,1,10,4), nrow \= 2,ncol \= 3,byrow \= TRUE)  </span><br><span class="line">print(M)  </span><br><span class="line">     \[,1\] \[,2\] \[,3\]  </span><br><span class="line">\[1,\]    2    6    5  </span><br><span class="line">\[2,\]    1   10    4  </span><br><span class="line">\# 转换为 3 行 2 列的矩阵  </span><br><span class="line">print(t(M))  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    2    6    5</span><br><span class="line">[2,]    1   10    4</span><br><span class="line">[1] &quot;-----转换-----&quot;</span><br><span class="line">     [,1] [,2]</span><br><span class="line">[1,]    2    1</span><br><span class="line">[2,]    6   10</span><br><span class="line">[3,]    5    4</span><br></pre></td></tr></table></figure><h3 id="访问矩阵元素">访问矩阵元素</h3><p>如果想获取矩阵元素，可以通过使用元素的列索引和行索引，类似坐标形式。</p><h2 id="实例-83">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">\# 定义行和列的名称  </span><br><span class="line">rownames \= c(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;, &quot;row4&quot;)  </span><br><span class="line">colnames \= c(&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;)</span><br><span class="line"></span><br><span class="line">\# 创建矩阵  </span><br><span class="line">P &lt;- matrix(c(3:14), nrow \= 4, byrow \= TRUE, dimnames \= list(rownames, colnames))  </span><br><span class="line">print(P)  </span><br><span class="line">\# 获取第一行第三列的元素  </span><br><span class="line">print(P\[1,3\])</span><br><span class="line"></span><br><span class="line">\# 获取第四行第二列的元素  </span><br><span class="line">print(P\[4,2\])</span><br><span class="line"></span><br><span class="line">\# 获取第二行  </span><br><span class="line">print(P\[2,\])</span><br><span class="line"></span><br><span class="line">\# 获取第三列  </span><br><span class="line">print(P\[,3\])</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">col1 col2 col3</span><br><span class="line">row1    3    4    5</span><br><span class="line">row2    6    7    8</span><br><span class="line">row3    9   10   11</span><br><span class="line">row4   12   13   14</span><br><span class="line">[1] 5</span><br><span class="line">[1] 13</span><br><span class="line">col1 col2 col3 </span><br><span class="line">    6    7    8 </span><br><span class="line">row1 row2 row3 row4 </span><br><span class="line">    5    8   11   14 </span><br></pre></td></tr></table></figure><h3 id="矩阵计算">矩阵计算</h3><p>大小相同（行数列数都相同）的矩阵之间可以相互加减，具体是对每个位置上的元素做加减法。矩阵的乘法则较为复杂。两个矩阵可以相乘，当且仅当第一个矩阵的列数等于第二个矩阵的行数。</p><h3 id="矩阵加减法">矩阵加减法</h3><h2 id="实例-84">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">\# 创建 2 行 3 列的矩阵  </span><br><span class="line">matrix1 &lt;- matrix(c(7, 9, \-1, 4, 2, 3), nrow \= 2)  </span><br><span class="line">print(matrix1)</span><br><span class="line"></span><br><span class="line">matrix2 &lt;- matrix(c(6, 1, 0, 9, 3, 2), nrow \= 2)  </span><br><span class="line">print(matrix2)</span><br><span class="line"></span><br><span class="line">\# 两个矩阵相加  </span><br><span class="line">result &lt;- matrix1 + matrix2  </span><br><span class="line">cat(&quot;相加结果：&quot;,&quot;\\n&quot;)  </span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">\# 两个矩阵相减  </span><br><span class="line">result &lt;- matrix1 \- matrix2  </span><br><span class="line">cat(&quot;相减结果：&quot;,&quot;\\n&quot;)  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[,1] [,2] [,3]</span><br><span class="line">[1,]    7   -1    2</span><br><span class="line">[2,]    9    4    3</span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    6    0    3</span><br><span class="line">[2,]    1    9    2</span><br><span class="line">相加结果： </span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]   13   -1    5</span><br><span class="line">[2,]   10   13    5</span><br><span class="line">相减结果： </span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    1   -1   -1</span><br><span class="line">[2,]    8   -5    1</span><br></pre></td></tr></table></figure><h3 id="矩阵乘除法">矩阵乘除法</h3><h2 id="实例-85">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">\# 创建 2 行 3 列的矩阵  </span><br><span class="line">matrix1 &lt;- matrix(c(7, 9, \-1, 4, 2, 3), nrow \= 2)  </span><br><span class="line">print(matrix1)</span><br><span class="line"></span><br><span class="line">matrix2 &lt;- matrix(c(6, 1, 0, 9, 3, 2), nrow \= 2)  </span><br><span class="line">print(matrix2)</span><br><span class="line"></span><br><span class="line">\# 两个矩阵相乘  </span><br><span class="line">result &lt;- matrix1 \* matrix2  </span><br><span class="line">cat(&quot;相乘结果：&quot;,&quot;\\n&quot;)  </span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">\# 两个矩阵相除  </span><br><span class="line">result &lt;- matrix1 / matrix2  </span><br><span class="line">cat(&quot;相除结果：&quot;,&quot;\\n&quot;)  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[,1] [,2] [,3]</span><br><span class="line">[1,]    7   -1    2</span><br><span class="line">[2,]    9    4    3</span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    6    0    3</span><br><span class="line">[2,]    1    9    2</span><br><span class="line">相乘结果： </span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]   42    0    6</span><br><span class="line">[2,]    9   36    6</span><br><span class="line">相除结果： </span><br><span class="line">         [,1]      [,2]      [,3]</span><br><span class="line">[1,] 1.166667      -Inf 0.6666667</span><br><span class="line">[2,] 9.000000 0.4444444 1.5000000</span><br></pre></td></tr></table></figure><h2 id="R-数组">R 数组</h2><p>数组也是 R 语言的对象，R 语言可以创建一维或多维数组。</p><p>R 语言数组是一个同一类型的集合，前面我们学的矩阵 matrix 其实就是一个二维数组。</p><p>向量、矩阵、数组关系可以看下图：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/2039-08-06Done.png" alt=""></p><p>R 语言数组创建使用 array() 函数，该函数使用向量作为输入参数，可以使用 dim 设置数组维度。</p><p>array() 函数语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array(data = NA, dim = length(data), dimnames = NULL)</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><strong>data</strong> - 指定数组的数据源，可以是一个向量、矩阵或列表。</li><li><strong>dim</strong> - 指定数组的维度，可以是一个整数向量或一个表示维度的元组，默认是一维数组。例如，dim = c(2, 3, 4) 表示创建一个 <strong>2x3x4</strong> 的三维数组。</li><li><strong>dimnames</strong> - 可选参数，用于指定数组每个维度的名称，可以是一个包含维度名称的列表。</li></ul><p>在 R 中，数组索引是从 1 开始的，与其他编程语言的习惯有所不同。</p><p>此外，R 还提供了丰富的函数和操作符用于处理数组数据，如索引、切片、重塑、聚合等。</p><p>在 R 中，可以使用<a href="https://www.runoob.com/r/r-matrix.html">矩阵（Matrix）</a>或<a href="https://www.runoob.com/r/r-list.html">列表（List）</a>来表示多维数组。</p><p>**矩阵（Matrix）：**矩阵是 R 中最常用的表示数组的形式，它是一个二维的结构，具有固定的行数和列数。</p><p>可以使用 matrix() 函数创建矩阵，指定数据元素和维度。</p><h2 id="实例-86">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\# 创建一个3x3的矩阵  </span><br><span class="line">my\_matrix &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow \= 3, ncol \= 3)  </span><br><span class="line">print(my\_matrix)  </span><br></pre></td></tr></table></figure><p><strong>列表（List）</strong>：列表是 R 中更通用的多维数组形式，它可以包含不同类型的元素，并且每个元素可以是一个矩阵、向量或其他数据结构。</p><h2 id="实例-87">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\# 创建一个包含矩阵和向量的列表  </span><br><span class="line">my\_list &lt;- list(matrix(c(1, 2, 3, 4), nrow \= 2), c(5, 6, 7))  </span><br><span class="line">print(my\_list)  </span><br></pre></td></tr></table></figure><h2 id="实例-88">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\# 创建一个包含矩阵和向量的列表  </span><br><span class="line">my\_list &lt;- list(matrix(c(1, 2, 3, 4), nrow \= 2), c(5, 6, 7))  </span><br><span class="line">print(my\_list)  </span><br></pre></td></tr></table></figure><p>除了矩阵和列表，R 还提供了其他数据结构来表示多维数组，如数组（Array）和数据帧（Data Frame）。</p><h3 id="实例-89">实例</h3><p>下面是一些示例来演示 <strong>array()</strong> 函数的使用：</p><p>使用向量创建一维数组：</p><h2 id="实例-90">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my\_vector &lt;- c(1, 2, 3, 4)  </span><br><span class="line">my\_array &lt;- array(my\_vector, dim \= c(4))  </span><br><span class="line">print(my\_array)  </span><br></pre></td></tr></table></figure><p>以下实例我们创建一个 3 行 3 列的的二维数组：</p><h2 id="实例-91">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\# 创建两个不同长度的向量  </span><br><span class="line">vector1 &lt;- c(5,9,3)  </span><br><span class="line">vector2 &lt;- c(10,11,12,13,14,15)</span><br><span class="line"></span><br><span class="line">\# 创建数组  </span><br><span class="line">result &lt;- array(c(vector1,vector2),dim \= c(3,3,2))  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">, , 1</span><br><span class="line"></span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    5   10   13</span><br><span class="line">[2,]    9   11   14</span><br><span class="line">[3,]    3   12   15</span><br><span class="line"></span><br><span class="line">, , 2</span><br><span class="line"></span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    5   10   13</span><br><span class="line">[2,]    9   11   14</span><br><span class="line">[3,]    3   12   15</span><br></pre></td></tr></table></figure><p>使用 dimnames 参数来设置各个维度的名称：：</p><h2 id="实例-92">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\# 创建两个不同长度的向量  </span><br><span class="line">vector1 &lt;- c(5,9,3)  </span><br><span class="line">vector2 &lt;- c(10,11,12,13,14,15)  </span><br><span class="line">column.names &lt;- c(&quot;COL1&quot;,&quot;COL2&quot;,&quot;COL3&quot;)  </span><br><span class="line">row.names &lt;- c(&quot;ROW1&quot;,&quot;ROW2&quot;,&quot;ROW3&quot;)  </span><br><span class="line">matrix.names &lt;- c(&quot;Matrix1&quot;,&quot;Matrix2&quot;)</span><br><span class="line"></span><br><span class="line">\# 创建数组，并设置各个维度的名称  </span><br><span class="line">result &lt;- array(c(vector1,vector2),dim \= c(3,3,2),dimnames \= list(row.names,column.names,matrix.names))  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">, , Matrix1</span><br><span class="line"></span><br><span class="line">     COL1 COL2 COL3</span><br><span class="line">ROW1    5   10   13</span><br><span class="line">ROW2    9   11   14</span><br><span class="line">ROW3    3   12   15</span><br><span class="line"></span><br><span class="line">, , Matrix2</span><br><span class="line"></span><br><span class="line">     COL1 COL2 COL3</span><br><span class="line">ROW1    5   10   13</span><br><span class="line">ROW2    9   11   14</span><br><span class="line">ROW3    3   12   15</span><br></pre></td></tr></table></figure><h3 id="访问数组元素">访问数组元素</h3><p>在 R 语言中，可以使用索引操作符 [ ] 来访问多维数组的元素。</p><p>索引操作符允许您按照指定的索引位置获取数组中的特定元素。</p><p>如果想获取数组元素，可以通过使用元素的列索引和行索引，类似坐标形式。</p><p>访问单个元素：</p><h2 id="实例-93">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my\_array &lt;- array(1:12, dim \= c(2, 3, 2))  \# 创建一个3维数组  </span><br><span class="line">element &lt;- my\_array\[1, 2, 1\]  \# 访问第一个维度为1，第二个维度为2，第三个维度为1的元素  </span><br><span class="line">print(element)  </span><br></pre></td></tr></table></figure><p>访问多个元素：</p><h2 id="实例-94">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my\_array &lt;- array(1:12, dim \= c(2, 3, 2))  \# 创建一个3维数组  </span><br><span class="line">elements &lt;- my\_array\[c(1, 2), c(2, 3), c(1, 2)\]  \# 访问多个元素，其中每个维度的索引分别为1和2  </span><br><span class="line">print(elements)  </span><br></pre></td></tr></table></figure><p>访问二维数组的元素：</p><h2 id="实例-95">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">\# 创建两个不同长度的向量  </span><br><span class="line">vector1 &lt;- c(5,9,3)  </span><br><span class="line">vector2 &lt;- c(10,11,12,13,14,15)  </span><br><span class="line">column.names &lt;- c(&quot;COL1&quot;,&quot;COL2&quot;,&quot;COL3&quot;)  </span><br><span class="line">row.names &lt;- c(&quot;ROW1&quot;,&quot;ROW2&quot;,&quot;ROW3&quot;)  </span><br><span class="line">matrix.names &lt;- c(&quot;Matrix1&quot;,&quot;Matrix2&quot;)</span><br><span class="line"></span><br><span class="line">\# 创建数组  </span><br><span class="line">result &lt;- array(c(vector1,vector2),dim \= c(3,3,2),dimnames \= list(row.names, column.names, matrix.names))</span><br><span class="line"></span><br><span class="line">\# 显示数组第二个矩阵中第三行的元素  </span><br><span class="line">print(result\[3,,2\])</span><br><span class="line"></span><br><span class="line">\# 显示数组第一个矩阵中第一行第三列的元素  </span><br><span class="line">print(result\[1,3,1\])</span><br><span class="line"></span><br><span class="line">\# 输出第二个矩阵  </span><br><span class="line">print(result\[,,2\])</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">COL1 COL2 COL3 </span><br><span class="line">   3   12   15 </span><br><span class="line">[1] 13</span><br><span class="line">     COL1 COL2 COL3</span><br><span class="line">ROW1    5   10   13</span><br><span class="line">ROW2    9   11   14</span><br><span class="line">ROW3    3   12   15</span><br></pre></td></tr></table></figure><p>使用逻辑条件进行筛选：</p><h2 id="实例-96">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my\_array &lt;- array(1:12, dim \= c(2, 3, 2))  \# 创建一个3维数组  </span><br><span class="line">filtered\_elements &lt;- my\_array\[my\_array \&gt; 5\]  \# 选择大于5的元素  </span><br><span class="line">print(filtered\_elements)  \# 输出：6 7 8 9 10 11 12  </span><br></pre></td></tr></table></figure><h3 id="操作数组元素">操作数组元素</h3><p>由于数组是由多个维度的矩阵组成，所以我们可以通过访问矩阵的元素来访问数组元素。</p><h2 id="实例-97">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">\# 创建两个不同长度的向量  </span><br><span class="line">vector1 &lt;- c(5,9,3)  </span><br><span class="line">vector2 &lt;- c(10,11,12,13,14,15)</span><br><span class="line"></span><br><span class="line">\# 创建数组  </span><br><span class="line">array1 &lt;- array(c(vector1,vector2),dim \= c(3,3,2))</span><br><span class="line"></span><br><span class="line">\# 创建两个不同长度的向量  </span><br><span class="line">vector3 &lt;- c(9,1,0)  </span><br><span class="line">vector4 &lt;- c(6,0,11,3,14,1,2,6,9)  </span><br><span class="line">array2 &lt;- array(c(vector3,vector4),dim \= c(3,3,2))</span><br><span class="line"></span><br><span class="line">\# 从数组中创建矩阵  </span><br><span class="line">matrix1 &lt;- array1\[,,2\]  </span><br><span class="line">matrix2 &lt;- array2\[,,2\]</span><br><span class="line"></span><br><span class="line">\# 矩阵相加  </span><br><span class="line">result &lt;- matrix1+matrix2  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    7   19   19</span><br><span class="line">[2,]   15   12   14</span><br><span class="line">[3,]   12   12   26</span><br></pre></td></tr></table></figure><p>另外我们可以使用 <strong>apply()</strong> 元素对数组元素进行跨维度计算，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply(X, MARGIN, FUN, ...)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>X</code>：要应用函数的数组或矩阵。</li><li><code>MARGIN</code>：指定应用函数的维度，可以是1表示行，2表示列，或者c(1, 2)表示同时应用于行和列。</li><li><code>FUN</code>：要应用的函数，可以是内置函数（如<code>mean</code>、<code>sum</code>等）或自定义函数。</li><li><code>...</code>：可选参数，用于传递给函数的其他参数。</li></ul><p>以下我们使用 apply() 函数来计算数组两个矩阵中每一行对数字之和。</p><h2 id="实例-98">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\# 创建两个不同长度的向量  </span><br><span class="line">vector1 &lt;- c(5,9,3)  </span><br><span class="line">vector2 &lt;- c(10,11,12,13,14,15)</span><br><span class="line"></span><br><span class="line">\# 创建数组  </span><br><span class="line">new.array &lt;- array(c(vector1,vector2),dim \= c(3,3,2))  </span><br><span class="line">print(new.array)</span><br><span class="line"></span><br><span class="line">\# 计算数组中所有矩阵第一行的数字之和  </span><br><span class="line">result &lt;- apply(new.array, c(1), sum)  </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">, , 1</span><br><span class="line"></span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    5   10   13</span><br><span class="line">[2,]    9   11   14</span><br><span class="line">[3,]    3   12   15</span><br><span class="line"></span><br><span class="line">, , 2</span><br><span class="line"></span><br><span class="line">     [,1] [,2] [,3]</span><br><span class="line">[1,]    5   10   13</span><br><span class="line">[2,]    9   11   14</span><br><span class="line">[3,]    3   12   15</span><br><span class="line"></span><br><span class="line">[1] 56 68 60</span><br></pre></td></tr></table></figure><p>对矩阵的行或列应用内置函数：</p><h2 id="实例-99">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\# 创建一个3x3的矩阵  </span><br><span class="line">my\_matrix &lt;- matrix(1:9, nrow \= 3)  </span><br><span class="line">\# 对每列应用sum函数  </span><br><span class="line">col\_sums &lt;- apply(my\_matrix, 2, sum)  </span><br><span class="line">print(col\_sums)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1]  6 15 24</span><br></pre></td></tr></table></figure><p>对矩阵的行或列应用自定义函数：</p><h2 id="实例-100">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\# 创建一个3x3的矩阵  </span><br><span class="line">my\_matrix &lt;- matrix(1:9, nrow \= 3)  </span><br><span class="line">\# 自定义函数：计算每行的平均值  </span><br><span class="line">row\_mean &lt;- function(x) &#123;  </span><br><span class="line">  return(mean(x))  </span><br><span class="line">&#125;  </span><br><span class="line">\# 对每行应用row\_mean函数  </span><br><span class="line">row\_means &lt;- apply(my\_matrix, 1, row\_mean)  </span><br><span class="line">print(row\_means)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] 4 5 6</span><br></pre></td></tr></table></figure><p>对数组的多个维度同时应用函数：</p><h2 id="实例-101">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\# 创建一个3维数组  </span><br><span class="line">my\_array &lt;- array(1:12, dim \= c(2, 3, 2))  </span><br><span class="line">\# 对第一个和第三个维度同时应用mean函数  </span><br><span class="line">result &lt;- apply(my\_array, c(1, 3), mean)  </span><br><span class="line">print(result)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     [,1] [,2]</span><br><span class="line">[1,]    3    9</span><br><span class="line">[2,]    4   10</span><br></pre></td></tr></table></figure><h2 id="R-因子">R 因子</h2><p>因子用于存储不同类别的数据类型，例如人的性别有男和女两个类别，年龄来分可以有未成年人和成年人。</p><p>R 语言创建因子使用 factor() 函数，向量作为输入参数。</p><p>factor() 函数语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">factor(x = character(), levels, labels = levels,</span><br><span class="line">       exclude = NA, ordered = is.ordered(x), nmax = NA)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>x：向量。</li><li>levels：指定各水平值, 不指定时由x的不同值来求得。</li><li>labels：水平的标签, 不指定时用各水平值的对应字符串。</li><li>exclude：排除的字符。</li><li>ordered：逻辑值，用于指定水平是否有序。</li><li>nmax：水平的上限数量。</li></ul><p>以下实例把字符型向量转换成因子：</p><h2 id="实例-102">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(&quot;男&quot;, &quot;女&quot;, &quot;男&quot;, &quot;男&quot;,  &quot;女&quot;)  </span><br><span class="line">sex &lt;- factor(x)  </span><br><span class="line">print(sex)  </span><br><span class="line">print(is.factor(sex))  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1] 男 女 男 男 女</span><br><span class="line">Levels: 男 女</span><br><span class="line">[1] TRUE</span><br></pre></td></tr></table></figure><p>以下实例设置因子水平为 c(‘男’,‘女’)：</p><h2 id="实例-103">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(&quot;男&quot;, &quot;女&quot;, &quot;男&quot;, &quot;男&quot;,  &quot;女&quot;,levels\=c(&#x27;男&#x27;,&#x27;女&#x27;))  </span><br><span class="line">sex &lt;- factor(x)  </span><br><span class="line">print(sex)  </span><br><span class="line">print(is.factor(sex))  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">levels1 levels2 </span><br><span class="line">男      女      男      男      女      男      女 </span><br><span class="line">Levels: 男 女</span><br><span class="line">[1] TRUE</span><br></pre></td></tr></table></figure><h3 id="因子水平标签">因子水平标签</h3><p>接下来我们使用 labels 参数为每个因子水平添加标签，labels 参数的字符顺序，要和 levels 参数的字符顺序保持一致，例如：</p><h2 id="实例-104">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sex\=factor(c(&#x27;f&#x27;,&#x27;m&#x27;,&#x27;f&#x27;,&#x27;f&#x27;,&#x27;m&#x27;),levels\=c(&#x27;f&#x27;,&#x27;m&#x27;),labels\=c(&#x27;female&#x27;,&#x27;male&#x27;),ordered\=TRUE)  </span><br><span class="line">print(sex)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1] female male   female female male  </span><br><span class="line">Levels: female &lt; male</span><br></pre></td></tr></table></figure><h3 id="生成因子水平">生成因子水平</h3><p>我们可以使用 gl() 函数来生成因子水平，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl(n, k, length = n*k, labels = seq_len(n), ordered = FALSE)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><strong>n</strong>: 设置 level 的个数</li><li><strong>k</strong>: 设置每个 level 重复的次数</li><li><strong>length</strong>: 设置长度</li><li><strong>labels</strong>: 设置 level 的值</li><li><strong>ordered</strong>: 设置是否 level 是排列好顺序的，布尔值。</li></ul><h2 id="实例-105">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v &lt;- gl(3, 4, labels \= c(&quot;Google&quot;, &quot;Runoob&quot;,&quot;Taobao&quot;))  </span><br><span class="line">print(v)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> [1] Google Google Google Google Runoob Runoob Runoob Runoob Taobao Taobao</span><br><span class="line">[11] Taobao Taobao</span><br><span class="line">Levels: Google Runoob Taobao</span><br></pre></td></tr></table></figure><h2 id="R-数据框">R 数据框</h2><p>数据框（Data frame）可以理解成我们常说的&quot;表格&quot;。</p><p>数据框是 R 语言的数据结构，是特殊的二维列表。</p><p>数据框每一列都有一个唯一的列名，长度都是相等的，同一列的数据类型需要一致，不同列的数据类型可以不一样。</p><p><img src="https://static.jyshare.com/images/mix/data-frame.svg" alt=""></p><p>R 语言数据框使用 data.frame() 函数来创建，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.frame(…, row.names = NULL, check.rows = FALSE,</span><br><span class="line">           check.names = TRUE, fix.empty.names = TRUE,</span><br><span class="line">           stringsAsFactors = default.stringsAsFactors())</span><br></pre></td></tr></table></figure><ul><li><strong>…</strong>: 列向量，可以是任何类型（字符型、数值型、逻辑型），一般以 tag = value 的形式表示，也可以是 value。</li><li><strong>row.names</strong>: 行名，默认为 NULL，可以设置为单个数字、字符串或字符串和数字的向量。</li><li><strong>check.rows</strong>: 检测行的名称和长度是否一致。</li><li><strong>check.names</strong>: 检测数据框的变量名是否合法。</li><li><strong>fix.empty.names</strong>: 设置未命名的参数是否自动设置名字。</li><li><strong>stringsAsFactors</strong>: 布尔值，字符是否转换为因子，factory-fresh 的默认值是 TRUE，可以通过设置选项（stringsAsFactors=FALSE）来修改。</li></ul><p>以下创建一个简单的数据框，包含姓名、工号、月薪：</p><h2 id="实例-106">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">table \= data.frame(  </span><br><span class="line">    姓名 \= c(&quot;张三&quot;, &quot;李四&quot;),  </span><br><span class="line">    工号 \= c(&quot;001&quot;,&quot;002&quot;),  </span><br><span class="line">    月薪 \= c(1000, 2000)</span><br><span class="line"></span><br><span class="line">    )  </span><br><span class="line">print(table) \# 查看 table 数据</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">姓名 工号 月薪</span><br><span class="line">1 张三  001 1000</span><br><span class="line">2 李四  002 2000</span><br></pre></td></tr></table></figure><p>数据框的数据结构可以通过 <strong>str()</strong> 函数来展示：</p><h2 id="实例-107">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">table \= data.frame(  </span><br><span class="line">    姓名 \= c(&quot;张三&quot;, &quot;李四&quot;),  </span><br><span class="line">    工号 \= c(&quot;001&quot;,&quot;002&quot;),  </span><br><span class="line">    月薪 \= c(1000, 2000)  </span><br><span class="line">)  </span><br><span class="line">\# 获取数据结构  </span><br><span class="line">str(table)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;data.frame&#x27;:   2 obs. of  3 variables:</span><br><span class="line"> $ 姓名: chr  &quot;张三&quot; &quot;李四&quot;</span><br><span class="line"> $ 工号: chr  &quot;001&quot; &quot;002&quot;</span><br><span class="line"> $ 月薪: num  1000 2000</span><br></pre></td></tr></table></figure><p><strong>summary()</strong> 可以显示数据框的概要信息：</p><h2 id="实例-108">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">table \= data.frame(  </span><br><span class="line">    姓名 \= c(&quot;张三&quot;, &quot;李四&quot;),  </span><br><span class="line">    工号 \= c(&quot;001&quot;,&quot;002&quot;),  </span><br><span class="line">    月薪 \= c(1000, 2000)</span><br><span class="line"></span><br><span class="line">    )  </span><br><span class="line">\# 显示概要  </span><br><span class="line">print(summary(table))</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">姓名               工号                月薪     </span><br><span class="line">Length:2           Length:2           Min.   :1000  </span><br><span class="line">Class :character   Class :character   1st Qu.:1250  </span><br><span class="line">Mode  :character   Mode  :character   Median :1500  </span><br><span class="line">                                      Mean   :1500  </span><br><span class="line">                                      3rd Qu.:1750  </span><br><span class="line">                                      Max.   :2000  </span><br></pre></td></tr></table></figure><p>我们也可以提取指定的列：</p><h2 id="实例-109">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">table \= data.frame(  </span><br><span class="line">    姓名 \= c(&quot;张三&quot;, &quot;李四&quot;),  </span><br><span class="line">    工号 \= c(&quot;001&quot;,&quot;002&quot;),  </span><br><span class="line">    月薪 \= c(1000, 2000)  </span><br><span class="line">)  </span><br><span class="line">\# 提取指定的列  </span><br><span class="line">result &lt;- data.frame(table$姓名,table$月薪)  </span><br><span class="line">print(result)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">table.姓名 table.月薪</span><br><span class="line">1       张三       1000</span><br><span class="line">2       李四       2000</span><br></pre></td></tr></table></figure><p>以下形式显示前面两行：</p><h2 id="实例-110">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">table \= data.frame(  </span><br><span class="line">    姓名 \= c(&quot;张三&quot;, &quot;李四&quot;,&quot;王五&quot;),  </span><br><span class="line">    工号 \= c(&quot;001&quot;,&quot;002&quot;,&quot;003&quot;),  </span><br><span class="line">    月薪 \= c(1000, 2000,3000)  </span><br><span class="line">)  </span><br><span class="line">print(table)  </span><br><span class="line">\# 提取前面两行  </span><br><span class="line">print(&quot;---输出前面两行----&quot;)  </span><br><span class="line">result &lt;- table\[1:2,\]  </span><br><span class="line">print(result)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">姓名 工号 月薪</span><br><span class="line">1 张三  001 1000</span><br><span class="line">2 李四  002 2000</span><br><span class="line">3 王五  003 3000</span><br><span class="line">[1] &quot;---输出前面两行----&quot;</span><br><span class="line">  姓名 工号 月薪</span><br><span class="line">1 张三  001 1000</span><br><span class="line">2 李四  002 2000</span><br></pre></td></tr></table></figure><p>我们可以通过类似坐标的形式读取指定行的某一列的数据，以下我们读取第 2 、3 行的第 1 、2 列数据：</p><h2 id="实例-111">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">table \= data.frame(  </span><br><span class="line">    姓名 \= c(&quot;张三&quot;, &quot;李四&quot;,&quot;王五&quot;),  </span><br><span class="line">    工号 \= c(&quot;001&quot;,&quot;002&quot;,&quot;003&quot;),  </span><br><span class="line">    月薪 \= c(1000, 2000,3000)  </span><br><span class="line">)  </span><br><span class="line">\# 读取第 2 、3 行的第 1 、2 列数据：  </span><br><span class="line">result &lt;- table\[c(2,3),c(1,2)\]  </span><br><span class="line">print(result)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">姓名 工号</span><br><span class="line">2 李四  002</span><br><span class="line">3 王五  003</span><br></pre></td></tr></table></figure><h3 id="扩展数据框">扩展数据框</h3><p>我们可以对已有的数据框进行扩展，以下实例我们添加部门列：</p><h2 id="实例-112">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">table \= data.frame(  </span><br><span class="line">    姓名 \= c(&quot;张三&quot;, &quot;李四&quot;,&quot;王五&quot;),  </span><br><span class="line">    工号 \= c(&quot;001&quot;,&quot;002&quot;,&quot;003&quot;),  </span><br><span class="line">    月薪 \= c(1000, 2000,3000)  </span><br><span class="line">)  </span><br><span class="line">\# 添加部门列  </span><br><span class="line">table$部门 &lt;- c(&quot;运营&quot;,&quot;技术&quot;,&quot;编辑&quot;)</span><br><span class="line"></span><br><span class="line">print(table)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">姓名 工号 月薪 部门</span><br><span class="line">1 张三  001 1000 运营</span><br><span class="line">2 李四  002 2000 技术</span><br><span class="line">3 王五  003 3000 编辑</span><br></pre></td></tr></table></figure><p>我们可以使用 <strong>cbind()</strong> 函数将多个向量合成一个数据框：</p><h2 id="实例-113">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\# 创建向量  </span><br><span class="line">sites &lt;- c(&quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;)  </span><br><span class="line">likes &lt;- c(222,111,123)  </span><br><span class="line">url &lt;- c(&quot;www.google.com&quot;,&quot;www.runoob.com&quot;,&quot;www.taobao.com&quot;)</span><br><span class="line"></span><br><span class="line">\# 将向量组合成数据框  </span><br><span class="line">addresses &lt;- cbind(sites,likes,url)</span><br><span class="line"></span><br><span class="line">\# 查看数据框  </span><br><span class="line">print(addresses)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     sites    likes url             </span><br><span class="line">[1,] &quot;Google&quot; &quot;222&quot; &quot;www.google.com&quot;</span><br><span class="line">[2,] &quot;Runoob&quot; &quot;111&quot; &quot;www.runoob.com&quot;</span><br><span class="line">[3,] &quot;Taobao&quot; &quot;123&quot; &quot;www.taobao.com&quot;</span><br></pre></td></tr></table></figure><p>如果要对两个数据框进行合并可以使用 <strong>rbind()</strong> 函数：</p><h2 id="实例-114">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">table \= data.frame(  </span><br><span class="line">    姓名 \= c(&quot;张三&quot;, &quot;李四&quot;,&quot;王五&quot;),  </span><br><span class="line">    工号 \= c(&quot;001&quot;,&quot;002&quot;,&quot;003&quot;),  </span><br><span class="line">    月薪 \= c(1000, 2000,3000)  </span><br><span class="line">)  </span><br><span class="line">newtable \= data.frame(  </span><br><span class="line">    姓名 \= c(&quot;小明&quot;, &quot;小白&quot;),  </span><br><span class="line">    工号 \= c(&quot;101&quot;,&quot;102&quot;),  </span><br><span class="line">    月薪 \= c(5000, 7000)  </span><br><span class="line">)  </span><br><span class="line">\# 合并两个数据框  </span><br><span class="line">result &lt;- rbind(table,newtable)  </span><br><span class="line">print(result)  </span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">姓名 工号 月薪</span><br><span class="line">1 张三  001 1000</span><br><span class="line">2 李四  002 2000</span><br><span class="line">3 王五  003 3000</span><br><span class="line">4 小明  101 5000</span><br><span class="line">5 小白  102 7000</span><br></pre></td></tr></table></figure><h2 id="R-数据重塑">R 数据重塑</h2><h3 id="合并数据框">合并数据框</h3><p>R 语言合并数据框使用 <strong>merge()</strong> 函数。</p><p>merge() 函数语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># S3 方法</span><br><span class="line">merge(x, y, …)</span><br><span class="line"></span><br><span class="line"># data.frame 的 S3 方法 </span><br><span class="line">merge(x, y, by = intersect(names(x), names(y)),</span><br><span class="line">      by.x = by, by.y = by, all = FALSE, all.x = all, all.y = all,</span><br><span class="line">      sort = TRUE, suffixes = c(&quot;.x&quot;,&quot;.y&quot;), no.dups = TRUE,</span><br><span class="line">      incomparables = NULL, …)</span><br></pre></td></tr></table></figure><p>常用参数说明：</p><ul><li>x, y： 数据框</li><li>by, by.x, by.y：指定两个数据框中匹配列名称，默认情况下使用两个数据框中相同列名称。</li><li>all：逻辑值; all = L 是 all.x = L 和 all.y = L 的简写，L 可以是 TRUE 或 FALSE。</li><li>all.x：逻辑值，默认为 FALSE。如果为 TRUE, 显示 x 中匹配的行，即便 y 中没有对应匹配的行，y 中没有匹配的行用 NA 来表示。</li><li>all.y：逻辑值，默认为 FALSE。如果为 TRUE, 显示 y 中匹配的行，即便 x 中没有对应匹配的行，x 中没有匹配的行用 NA 来表示。</li><li>sort：逻辑值，是否对列进行排序。</li></ul><p>merge() 函数和 SQL 的 JOIN 功能很相似：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-merge-join.jpg" alt=""></p><ul><li><strong>Natural join 或 INNER JOIN</strong>：如果表中有至少一个匹配，则返回行</li><li><strong>Left outer join 或 LEFT JOIN</strong>：即使右表中没有匹配，也从左表返回所有的行</li><li><strong>Right outer join 或 RIGHT JOIN</strong>：即使左表中没有匹配，也从右表返回所有的行</li><li><strong>Full outer join 或 FULL JOIN</strong>：只要其中一个表中存在匹配，则返回行</li></ul><h2 id="实例-115">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">\# data frame 1  </span><br><span class="line">df1 \= data.frame(SiteId \= c(1:6), Site \= c(&quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;,&quot;Facebook&quot;,&quot;Zhihu&quot;,&quot;Weibo&quot;))</span><br><span class="line"></span><br><span class="line">\# data frame 2  </span><br><span class="line">df2 \= data.frame(SiteId \= c(2, 4, 6, 7, 8), Country \= c(&quot;CN&quot;,&quot;USA&quot;,&quot;CN&quot;,&quot;USA&quot;,&quot;IN&quot;))</span><br><span class="line"></span><br><span class="line">\# INNER JOIN  </span><br><span class="line">df1 \= merge(x\=df1,y\=df2,by\=&quot;SiteId&quot;)  </span><br><span class="line">print(&quot;----- INNER JOIN -----&quot;)  </span><br><span class="line">print(df1)</span><br><span class="line"></span><br><span class="line">\# FULL JOIN  </span><br><span class="line">df2 \= merge(x\=df1,y\=df2,by\=&quot;SiteId&quot;,all\=TRUE)  </span><br><span class="line">print(&quot;----- FULL JOIN -----&quot;)  </span><br><span class="line">print(df2)</span><br><span class="line"></span><br><span class="line">\# LEFT JOIN  </span><br><span class="line">df3 \= merge(x\=df1,y\=df2,by\=&quot;SiteId&quot;,all.x\=TRUE)  </span><br><span class="line">print(&quot;----- LEFT JOIN -----&quot;)  </span><br><span class="line">print(df3)</span><br><span class="line"></span><br><span class="line">\# RIGHT JOIN  </span><br><span class="line">df4 \= merge(x\=df1,y\=df2,by\=&quot;SiteId&quot;,all.y\=TRUE)  </span><br><span class="line">print(&quot;----- RIGHT JOIN -----&quot;)  </span><br><span class="line">print(df4)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[1] &quot;----- INNER JOIN -----&quot;</span><br><span class="line">  SiteId     Site Country</span><br><span class="line">1      2   Runoob      CN</span><br><span class="line">2      4 Facebook     USA</span><br><span class="line">3      6    Weibo      CN</span><br><span class="line">[1] &quot;----- FULL JOIN -----&quot;</span><br><span class="line">  SiteId     Site Country.x Country.y</span><br><span class="line">1      2   Runoob        CN        CN</span><br><span class="line">2      4 Facebook       USA       USA</span><br><span class="line">3      6    Weibo        CN        CN</span><br><span class="line">4      7     &lt;NA&gt;      &lt;NA&gt;       USA</span><br><span class="line">5      8     &lt;NA&gt;      &lt;NA&gt;        IN</span><br><span class="line">[1] &quot;----- LEFT JOIN -----&quot;</span><br><span class="line">  SiteId   Site.x Country   Site.y Country.x Country.y</span><br><span class="line">1      2   Runoob      CN   Runoob        CN        CN</span><br><span class="line">2      4 Facebook     USA Facebook       USA       USA</span><br><span class="line">3      6    Weibo      CN    Weibo        CN        CN</span><br><span class="line">[1] &quot;----- RIGHT JOIN -----&quot;</span><br><span class="line">  SiteId   Site.x Country   Site.y Country.x Country.y</span><br><span class="line">1      2   Runoob      CN   Runoob        CN        CN</span><br><span class="line">2      4 Facebook     USA Facebook       USA       USA</span><br><span class="line">3      6    Weibo      CN    Weibo        CN        CN</span><br><span class="line">4      7     &lt;NA&gt;    &lt;NA&gt;     &lt;NA&gt;      &lt;NA&gt;       USA</span><br><span class="line">5      8     &lt;NA&gt;    &lt;NA&gt;     &lt;NA&gt;      &lt;NA&gt;        IN</span><br></pre></td></tr></table></figure><h3 id="数据整合和拆分">数据整合和拆分</h3><p>R 语言使用 <strong>melt()</strong> 和 <strong>cast()</strong> 函数来对数据进行整合和拆分。</p><ul><li>melt() ：宽格式数据转化成长格式。</li><li>cast() ：长格式数据转化成宽格式。</li></ul><p>下图很好展示来 melt() 和 cast() 函数的功能(后面实例会详细说明)：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/08/6634703-5e733d531862b668.webp" alt=""></p><p>melt() 将数据集的每个列堆叠到一个列中，函数语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">melt(data, ..., na.rm = FALSE, value.name = &quot;value&quot;)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>data：数据集。</li><li>…：传递给其他方法或来自其他方法的其他参数。</li><li>na.rm：是否删除数据集中的 NA 值。</li><li><a href="http://value.name">value.name</a> 变量名称，用于存储值。</li></ul><p>进行以下操作之前，我们先安装依赖包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 安装库，MASS 包含很多统计相关的函数，工具和数据集</span><br><span class="line">install.packages(&quot;MASS&quot;, repos = &quot;https://mirrors.ustc.edu.cn/CRAN/&quot;) </span><br><span class="line">  </span><br><span class="line">#  melt() 和 cast() 函数需要对库 </span><br><span class="line">install.packages(&quot;reshape2&quot;, repos = &quot;https://mirrors.ustc.edu.cn/CRAN/&quot;) </span><br><span class="line">install.packages(&quot;reshape&quot;, repos = &quot;https://mirrors.ustc.edu.cn/CRAN/&quot;) </span><br></pre></td></tr></table></figure><p>测试实例：</p><h2 id="实例-116">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">\# 载入库  </span><br><span class="line">library(MASS)  </span><br><span class="line">library(reshape2)  </span><br><span class="line">library(reshape)</span><br><span class="line"></span><br><span class="line">  \# 创建数据框  </span><br><span class="line">id&lt;\- c(1, 1, 2, 2)  </span><br><span class="line">time &lt;\- c(1, 2, 1, 2)  </span><br><span class="line">x1 &lt;\- c(5, 3, 6, 2)  </span><br><span class="line">x2 &lt;\- c(6, 5, 1, 4)  </span><br><span class="line">mydata &lt;\- data.frame(id, time, x1, x2)</span><br><span class="line"></span><br><span class="line">  \# 原始数据框  </span><br><span class="line">cat(&quot;原始数据框:\\n&quot;)  </span><br><span class="line">print(mydata)  </span><br><span class="line">\# 整合  </span><br><span class="line">md &lt;\- melt(mydata, id = c(&quot;id&quot;,&quot;time&quot;))</span><br><span class="line"></span><br><span class="line">  cat(&quot;\\n整合后:\\n&quot;)  </span><br><span class="line">print(md)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">原始数据框:</span><br><span class="line">id time x1 x2</span><br><span class="line">1  1    1  5  6</span><br><span class="line">2  1    2  3  5</span><br><span class="line">3  2    1  6  1</span><br><span class="line">4  2    2  2  4</span><br><span class="line"></span><br><span class="line">整合后:</span><br><span class="line">id time variable value</span><br><span class="line">1  1    1       x1     5</span><br><span class="line">2  1    2       x1     3</span><br><span class="line">3  2    1       x1     6</span><br><span class="line">4  2    2       x1     2</span><br><span class="line">5  1    1       x2     6</span><br><span class="line">6  1    2       x2     5</span><br><span class="line">7  2    1       x2     1</span><br><span class="line">8  2    2       x2     4</span><br></pre></td></tr></table></figure><p>cast 函数用于对合并对数据框进行还原，dcast() 返回数据框，acast() 返回一个向量/矩阵/数组。</p><p>cast() 函数语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dcast(</span><br><span class="line">  data,</span><br><span class="line">  formula,</span><br><span class="line">  fun.aggregate = NULL,</span><br><span class="line">  ...,</span><br><span class="line">  margins = NULL,</span><br><span class="line">  subset = NULL,</span><br><span class="line">  fill = NULL,</span><br><span class="line">  drop = TRUE,</span><br><span class="line">  value.var = guess_value(data)</span><br><span class="line">)</span><br><span class="line">acast(</span><br><span class="line">  data,</span><br><span class="line">  formula,</span><br><span class="line">  fun.aggregate = NULL,</span><br><span class="line">  ...,</span><br><span class="line">  margins = NULL,</span><br><span class="line">  subset = NULL,</span><br><span class="line">  fill = NULL,</span><br><span class="line">  drop = TRUE,</span><br><span class="line">  value.var = guess_value(data)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>data：合并的数据框。</li><li>formula：重塑的数据的格式，类似 x ~ y 格式，x 为行标签，y 为列标签 。</li><li>fun.aggregate：聚合函数，用于对 value 值进行处理。</li><li>margins：变量名称的向量（可以包含&quot;grand\_col&quot; 和 “grand\_row”），用于计算边距，设置 TURE 计算所有边距。</li><li>subset：对结果进行条件筛选，格式类似 <strong>subset = .(variable==“length”)</strong>。</li><li>drop：是否保留默认值。</li><li>value.var：后面跟要处理的字段。</li></ul><h2 id="实例-117">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">\# 载入库  </span><br><span class="line">library(MASS)  </span><br><span class="line">library(reshape2)  </span><br><span class="line">library(reshape)</span><br><span class="line"></span><br><span class="line">  \# 创建数据框  </span><br><span class="line">id&lt;- c(1, 1, 2, 2)  </span><br><span class="line">time &lt;- c(1, 2, 1, 2)  </span><br><span class="line">x1 &lt;- c(5, 3, 6, 2)  </span><br><span class="line">x2 &lt;- c(6, 5, 1, 4)  </span><br><span class="line">mydata &lt;- data.frame(id, time, x1, x2)  </span><br><span class="line">\# 整合  </span><br><span class="line">md &lt;- melt(mydata, id \= c(&quot;id&quot;,&quot;time&quot;))  </span><br><span class="line">\# Print recasted dataset using cast() function  </span><br><span class="line">cast.data &lt;- cast(md, id~variable, mean)</span><br><span class="line"></span><br><span class="line">  print(cast.data)</span><br><span class="line"></span><br><span class="line">  cat(&quot;\\n&quot;)  </span><br><span class="line">time.cast &lt;- cast(md, time~variable, mean)  </span><br><span class="line">print(time.cast)</span><br><span class="line"></span><br><span class="line">cat(&quot;\\n&quot;)  </span><br><span class="line">id.time &lt;- cast(md, id~time, mean)  </span><br><span class="line">print(id.time)</span><br><span class="line"></span><br><span class="line">cat(&quot;\\n&quot;)  </span><br><span class="line">id.time.cast &lt;- cast(md, id+time~variable)  </span><br><span class="line">print(id.time.cast)</span><br><span class="line"></span><br><span class="line">cat(&quot;\\n&quot;)  </span><br><span class="line">id.variable.time &lt;- cast(md, id+variable~time)  </span><br><span class="line">print(id.variable.time)</span><br><span class="line"></span><br><span class="line">cat(&quot;\\n&quot;)  </span><br><span class="line">id.variable.time2 &lt;- cast(md, id~variable+time)  </span><br><span class="line">print(id.variable.time2)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">id x1  x2</span><br><span class="line">1  1  4 5.5</span><br><span class="line">2  2  4 2.5</span><br><span class="line"></span><br><span class="line">  time  x1  x2</span><br><span class="line">1    1 5.5 3.5</span><br><span class="line">2    2 2.5 4.5</span><br><span class="line"></span><br><span class="line">  id   1 2</span><br><span class="line">1  1 5.5 4</span><br><span class="line">2  2 3.5 3</span><br><span class="line"></span><br><span class="line">  id time x1 x2</span><br><span class="line">1  1    1  5  6</span><br><span class="line">2  1    2  3  5</span><br><span class="line">3  2    1  6  1</span><br><span class="line">4  2    2  2  4</span><br><span class="line"></span><br><span class="line">  id variable 1 2</span><br><span class="line">1  1       x1 5 3</span><br><span class="line">2  1       x2 6 5</span><br><span class="line">3  2       x1 6 2</span><br><span class="line">4  2       x2 1 4</span><br><span class="line"></span><br><span class="line">  id x1_1 x1_2 x2_1 x2_2</span><br><span class="line">1  1    5    3    6    5</span><br><span class="line">2  2    6    2    1    4</span><br></pre></td></tr></table></figure><h2 id="R-包">R 包</h2><p>包是 R 函数、实例数据、预编译代码的集合，包括 R 程序，注释文档、实例、测试数据等。</p><p>R 语言相关的包一般存储安装目录下对 “library” 目录，默认情况在 R 语言安装完成已经自带来一些常用对包，当然我们也可以在后期自定义添加一些要使用的包。</p><p>R 语言完整的相关包可以查阅：<a href="https://cran.r-project.org/web/packages/available_packages_by_name.html">https://cran.r-project.org/web/packages/available_packages_by_name.html</a></p><p>接下来我们主要介绍如何安装 R 语言的包。</p><h3 id="查看-R-包的安装目录">查看 R 包的安装目录</h3><p>我们可以使用以下函数来查看 R 包的安装目录：</p><h2 id="实例-118">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\&gt; .libPaths()  </span><br><span class="line">\[1\] &quot;/Library/Frameworks/R.framework/Versions/4.0/Resources/library&quot;  </span><br><span class="line">\&gt;  </span><br></pre></td></tr></table></figure><h3 id="查看已安装的包">查看已安装的包</h3><p>我们可以使用以下函数来查看已安装的包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">library()</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">base                    The R Base Package</span><br><span class="line">boot                    Bootstrap Functions (Originally by Angelo Canty</span><br><span class="line">                        for S)</span><br><span class="line">class                   Functions for Classification</span><br><span class="line">cluster                 &quot;Finding Groups in Data&quot;: Cluster Analysis</span><br><span class="line">                        Extended Rousseeuw et al.</span><br><span class="line">codetools               Code Analysis Tools for R</span><br><span class="line">compiler                The R Compiler Package</span><br><span class="line">datasets                The R Datasets Package</span><br><span class="line">foreign                 Read Data Stored by &#x27;Minitab&#x27;, &#x27;S&#x27;, &#x27;SAS&#x27;,</span><br><span class="line">                        &#x27;SPSS&#x27;, &#x27;Stata&#x27;, &#x27;Systat&#x27;, &#x27;Weka&#x27;, &#x27;dBase&#x27;, ...</span><br><span class="line">graphics                The R Graphics Package</span><br><span class="line">grDevices               The R Graphics Devices and Support for Colours</span><br><span class="line">                        and Fonts</span><br><span class="line">grid                    The Grid Graphics Package</span><br><span class="line">KernSmooth              Functions for Kernel Smoothing Supporting Wand</span><br><span class="line">                        &amp; Jones (1995)</span><br><span class="line">lattice                 Trellis Graphics for R</span><br><span class="line">MASS                    Support Functions and Datasets for Venables and</span><br><span class="line">                        Ripley&#x27;s MASS</span><br></pre></td></tr></table></figure><h3 id="查看已载入的包">查看已载入的包</h3><p>我们可以使用以下函数来查看编译环境已载入的包：</p><h2 id="实例-119">实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\&gt; search()  </span><br><span class="line">\[1\] &quot;.GlobalEnv&quot;        &quot;package:stats&quot;     &quot;package:graphics&quot;  </span><br><span class="line">\[4\] &quot;package:grDevices&quot; &quot;package:utils&quot;     &quot;package:datasets&quot;  </span><br><span class="line">\[7\] &quot;package:methods&quot;   &quot;Autoloads&quot;         &quot;package:base&quot;    </span><br></pre></td></tr></table></figure><hr><h2 id="安装新包">安装新包</h2><p>安装新包可以使用 <strong>install.packages()</strong> 函数，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(&quot;要安装的包名&quot;)</span><br></pre></td></tr></table></figure><p>我们可以直接设置包名，从 <a href="https://cran.r-project.org/web/packages/available_packages_by_name.html">CRAN</a> 网站上获取包，如下实例我们载入 XML 包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装 XML 包</span><br><span class="line">install.packages(&quot;XML&quot;)</span><br></pre></td></tr></table></figure><p>或者我们可以直接在 <a href="https://cran.r-project.org/web/packages/available_packages_by_name.html">CRAN</a> 上下载相关包，直接在本地安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(&quot;./XML_3.98-1.3.zip&quot;)</span><br></pre></td></tr></table></figure><p>我们国内一般建议大家使用国内镜像，以下实例使用中国科学技术大学源进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装 XML 包</span><br><span class="line">install.packages(&quot;XML&quot;, repos = &quot;https://mirrors.ustc.edu.cn/CRAN/&quot;)</span><br></pre></td></tr></table></figure><p>CRAN (The Comprehensive R Archive Network) 镜像源配置文件之一是 .Rprofile (linux 下位于 ~/.Rprofile )。</p><p>在文末添加如下语句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options(&quot;repos&quot; = c(CRAN=&quot;https://mirrors.tuna.tsinghua.edu.cn/CRAN/&quot;))</span><br></pre></td></tr></table></figure><p>打开 R 即可使用该 CRAN 镜像源安装 R 软件包。</p><h3 id="使用包">使用包</h3><p>新安装的包需要先载入 R 编译环境中才可以使用，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">library(&quot;包名&quot;)</span><br></pre></td></tr></table></figure><p>以下实例载入 XML 包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">library(&quot;XML&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> R语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言-环境安装</title>
      <link href="/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="R-环境安装">R 环境安装</h2><p>R 语言的开发环境本身具备了图形开发环境，这与其他很多工程语言是不同的，所以开发环境最好安装在为桌面个人计算机设计的操作系统上（如 Windows, macOS 或 Ubuntu 桌面版 等）。</p><p>首先，我们需要下载 R 语言环境的安装包：</p><h3 id="Windows">Windows</h3><ul><li>官方地址：<a href="https://cloud.r-project.org/bin/windows/base/">https://cloud.r-project.org/bin/windows/base/</a></li><li>USTC 镜像：<a href="https://mirrors.ustc.edu.cn/CRAN/bin/windows/base/">https://mirrors.ustc.edu.cn/CRAN/bin/windows/base/</a></li><li>TUNA 镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/windows/base/">https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/windows/base/</a></li></ul><h3 id="Linux">Linux</h3><ul><li>官方地址：<a href="https://cloud.r-project.org/bin/linux/">https://cloud.r-project.org/bin/linux/</a></li><li>USTC 镜像：<a href="https://mirrors.ustc.edu.cn/CRAN/bin/linux/">https://mirrors.ustc.edu.cn/CRAN/bin/linux/</a></li><li>TUNA 镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/linux/">https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/linux/</a></li></ul><h3 id="macOS">macOS</h3><ul><li>官方地址：<a href="https://cloud.r-project.org/bin/macosx/">https://cloud.r-project.org/bin/macosx/</a></li><li>USTC 镜像：<a href="https://mirrors.ustc.edu.cn/CRAN/bin/macosx/">https://mirrors.ustc.edu.cn/CRAN/bin/macosx/</a></li><li>TUNA 镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/macosx/">https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/macosx/</a></li></ul><p>以上的版本有可能是过时的，如果你需要最新版本，可以访问：</p><ul><li>清华大学源： <a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/">https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/</a></li><li>官网：<a href="https://cloud.r-project.org/bin/">https://cloud.r-project.org/bin/</a></li></ul><hr><h2 id="Windows-操作系统">Windows 操作系统</h2><p>Windows 安装很简单，下载安装包后，双击下载的安装包，开始安装向导：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-setup-1.png" alt=""></p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-setup-2.png" alt=""></p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-setup-3.png" alt=""></p><p>**注意：**这里使用的操作系统是 64 位的，但现在仍有少数的计算机使用的是 32 位的操作系统，如果你的操作系统是 32 位的，请在此步骤选择&quot;32-bit 用户安装&quot;选项。</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-setup-4.png" alt=""></p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/r-setup-5.png" alt=""></p><p>当我们在交互式的命令窗口输入以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;Hello, world&quot;)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Hello, world&quot;</span><br></pre></td></tr></table></figure><h2 id="Linux-2">Linux</h2><h3 id="Ubuntu-安装">Ubuntu 安装</h3><p>执行以下命令安装 R 语言执行环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt update</span><br><span class="line"># sudo apt -y upgrade</span><br><span class="line"># sudo apt -y install r-base</span><br></pre></td></tr></table></figure><p>安装成功后，执行 R 命令就可以进入交互式的编程窗口了：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/AA1FF155-B2EB-48F9-8660-DB32706A134B.jpg" alt=""></p><h3 id="Centos-安装">Centos 安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo yum install R</span><br></pre></td></tr></table></figure><p>输入以下命令，查看安装的版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># R --version</span><br></pre></td></tr></table></figure><p>交互式命令可以通过输入 q() 来退出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; q()</span><br><span class="line">Save workspace image? [y/n/c]: y</span><br></pre></td></tr></table></figure><h2 id="macOS-安装">macOS 安装</h2><p>macOS 安装 R 语言环境类似 Windows，下载 pkg 安装包，双击安装包打开，然后按安装向导安装：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/R-setup-macos-1.jpg" alt=""></p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/R-setup-macos-2.jpg" alt=""></p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/R-setup-macos-3.jpg" alt=""></p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/R-setup-macos-4.jpg" alt=""></p><p>安装成功后，执行 R 命令就可以进入交互式的编程窗口了：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/AA89F11A-9180-4BD0-8A6A-4BE2FD5F1E8E.jpg" alt=""></p><p>交互式命令可以通过输入 q() 来退出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; q()</span><br><span class="line">Save workspace image? [y/n/c]: y</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/DDF9B88F-3BBC-4679-9D93-565E4D0ABBAB.jpg" alt=""></p><h3 id="脚本执行">脚本执行</h3><p>在 R 语言中，可以在命令行中使用 Rscript 命令来执行 R 脚本文件。</p><p>Rscript 命令允许您直接从命令行运行 R 脚本，而无需打开 R 控制台。。</p><p>要使用 Rscript命令 执行 R 脚本文件，可以按照以下步骤进行操作：</p><p>创建一个 R 脚本文件，其中包含要执行的R代码。例如，将以下代码保存为 <strong>script.R</strong> 文件：</p><h2 id="script-R-文件代码：">script.R 文件代码：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\# script.R  </span><br><span class="line">x &lt;- 1:10  </span><br><span class="line">y &lt;- x^2  </span><br><span class="line">print(y)  </span><br></pre></td></tr></table></figure><p>打开终端或命令行界面，进入当前文件 <strong>script.R</strong> 所在目录，在命令行中使用 Rscript 命令来执行脚本文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rscript script.R</span><br></pre></td></tr></table></figure><p>执行以上命令后，R 脚本文件将被 Rscript 解释器读取和执行。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> R语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
