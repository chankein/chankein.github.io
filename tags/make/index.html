
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>標籤: make - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Kein&#39;s blog">
<meta property="og:url" content="https://chankein.github.io/tags/make/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Kein Chan">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../#about"
            >
        
        
            <img class="header-picture" src="../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2021/05/23/makefile%E6%95%99%E7%A8%8B/"
                            aria-label=": makefile教程"
                        >
                            makefile教程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-05-23T12:48:01+08:00">
	
		    2021 年 5 月 23 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../categories/devops/">devops</a>, <a class="category-link" href="../../categories/devops/make/">make</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="简介">简介</h2>
<p>Linux的<code>make</code>程序用来自动化编译大型源码，很多时候，我们在Linux下编译安装软件，只需要敲一个<code>make</code>就可以全自动完成，非常方便。</p>
<p><code>make</code>能自动化完成这些工作，是因为项目提供了一个<code>Makefile</code>文件，它负责告诉<code>make</code>，应该如何编译和链接程序。</p>
<p><code>Makefile</code>相当于Java项目的<code>pom.xml</code>，Node工程的<code>package.json</code>，Rust项目的<code>Cargo.toml</code>，不同之处在于，<code>make</code>虽然最初是针对C语言开发，但它实际上并不限定C语言，而是可以应用到任意项目，甚至不是编程语言。此外，<code>make</code>主要用于Unix/Linux环境的自动化开发，掌握<code>Makefile</code>的写法，可以更好地在Linux环境下做开发，也可以为后续开发Linux内核做好准备。</p>
<p>在本教程中，我们将由浅入深，一步一步学习如何编写<code>Makefile</code>，完全针对零基础小白，只需要提前掌握如何使用Linux命令。</p>
<hr>
<p>在Linux环境下，当我们输入<code>make</code>命令时，它就在当前目录查找一个名为<code>Makefile</code>的文件，然后，根据这个文件定义的规则，自动化地执行任意命令，包括编译命令。</p>
<p><code>Makefile</code>这个单词，顾名思义，就是指如何生成文件。</p>
<p>我们举个例子：在当前目录下，有3个文本文件：<code>a.txt</code>，<code>b.txt</code>和<code>c.txt</code>。</p>
<p>现在，我们要合并<code>a.txt</code>与<code>b.txt</code>，生成中间文件<code>m.txt</code>，再用中间文件<code>m.txt</code>与<code>c.txt</code>合并，生成最终的目标文件<code>x.txt</code>，整个逻辑如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌─────┐ ┌─────┐ ┌─────┐</span><br><span class="line">│a.txt│ │b.txt│ │c.txt│</span><br><span class="line">└─────┘ └─────┘ └─────┘</span><br><span class="line">   │       │       │</span><br><span class="line">   └───┬───┘       │</span><br><span class="line">       │           │</span><br><span class="line">       ▼           │</span><br><span class="line">    ┌─────┐        │</span><br><span class="line">    │m.txt│        │</span><br><span class="line">    └─────┘        │</span><br><span class="line">       │           │</span><br><span class="line">       └─────┬─────┘</span><br><span class="line">             │</span><br><span class="line">             ▼</span><br><span class="line">          ┌─────┐</span><br><span class="line">          │x.txt│</span><br><span class="line">          └─────┘</span><br></pre></td></tr></table></figure>
<p>根据上述逻辑，我们来编写<code>Makefile</code>。</p>
<h3 id="规则">规则</h3>
<p><code>Makefile</code>由若干条规则（Rule）构成，每一条规则指出一个目标文件（Target），若干依赖文件（prerequisites），以及生成目标文件的命令。</p>
<p>例如，要生成<code>m.txt</code>，依赖<code>a.txt</code>与<code>b.txt</code>，规则如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 目标文件: 依赖文件1 依赖文件2</span><br><span class="line">m.txt: a.txt b.txt</span><br><span class="line">	cat a.txt b.txt &gt; m.txt</span><br></pre></td></tr></table></figure>
<p>一条规则的格式为<code>目标文件: 依赖文件1 依赖文件2 ...</code>，紧接着，以Tab开头的是命令，用来生成目标文件。上述规则使用<code>cat</code>命令合并了<code>a.txt</code>与<code>b.txt</code>，并写入到<code>m.txt</code>。用什么方式生成目标文件<code>make</code>并不关心，因为命令完全是我们自己写的，可以是编译命令，也可以是<code>cp</code>、<code>mv</code>等任何命令。</p>
<p>以<code>#</code>开头的是注释，会被<code>make</code>命令忽略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：Makefile的规则中，命令必须以Tab开头，不能是空格。</span><br></pre></td></tr></table></figure>
<p>类似的，我们写出生成<code>x.txt</code>的规则如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x.txt: m.txt c.txt</span><br><span class="line">	cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure>
<p>由于<code>make</code>执行时，默认执行第一条规则，所以，我们把规则<code>x.txt</code>放到前面。完整的<code>Makefile</code>如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x.txt: m.txt c.txt</span><br><span class="line">	cat m.txt c.txt &gt; x.txt</span><br><span class="line"></span><br><span class="line">m.txt: a.txt b.txt</span><br><span class="line">	cat a.txt b.txt &gt; m.txt</span><br></pre></td></tr></table></figure>
<p>在当前目录创建<code>a.txt</code>、<code>b.txt</code>和<code>c.txt</code>，输入一些内容，执行<code>make</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cat a.txt b.txt &gt; m.txt</span><br><span class="line">cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure>
<p><code>make</code>默认执行第一条规则，也就是创建<code>x.txt</code>，但是由于<code>x.txt</code>依赖的文件<code>m.txt</code>不存在（另一个依赖<code>c.txt</code>已存在），故需要先执行规则<code>m.txt</code>创建出<code>m.txt</code>文件，再执行规则<code>x.txt</code>。执行完成后，当前目录下生成了两个文件<code>m.txt</code>和<code>x.txt</code>。</p>
<p>可见，<code>Makefile</code>定义了一系列规则，每个规则在满足依赖文件的前提下执行命令，就能创建出一个目标文件，这就是英文Make file的意思。</p>
<p>把默认执行的规则放第一条，其他规则的顺序是无关紧要的，因为<code>make</code>执行时自动判断依赖。</p>
<p>此外，<code>make</code>会打印出执行的每一条命令，便于我们观察执行顺序以便调试。</p>
<p>如果我们再次运行<code>make</code>，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">make: `x.txt&#x27; is up to date.</span><br></pre></td></tr></table></figure>
<p><code>make</code>检测到<code>x.txt</code>已经是最新版本，无需再次执行，因为<code>x.txt</code>的创建时间晚于它依赖的<code>m.txt</code>和<code>c.txt</code>的最后修改时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make使用文件的创建和修改时间来判断是否应该更新一个目标文件。</span><br></pre></td></tr></table></figure>
<p>修改<code>c.txt</code>后，运行<code>make</code>，会触发<code>x.txt</code>的更新：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure>
<p>但并不会触发<code>m.txt</code>的更新，原因是<code>m.txt</code>的依赖<code>a.txt</code>与<code>b.txt</code>并未更新，所以，<code>make</code>只会根据<code>Makefile</code>去执行那些必要的规则，并不会把所有规则都无脑执行一遍。</p>
<p>在编译大型程序时，全量编译往往需要几十分钟甚至几个小时。全量编译完成后，如果仅修改了几个文件，再全部重新编译完全没有必要，用<code>Makefile</code>实现增量编译就十分节省时间。</p>
<p>当然，是否能正确地实现增量更新，取决于我们的规则写得对不对，<code>make</code>本身并不会检查规则逻辑是否正确。</p>
<h3 id="伪目标">伪目标</h3>
<p>因为<code>m.txt</code>与<code>x.txt</code>都是自动生成的文件，所以，可以安全地删除。</p>
<p>删除时，我们也不希望手动删除，而是编写一个<code>clean</code>规则来删除它们：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">	rm -f m.txt</span><br><span class="line">	rm -f x.txt</span><br></pre></td></tr></table></figure>
<p><code>clean</code>规则与我们前面编写的规则有所不同，它没有依赖文件，因此，要执行<code>clean</code>，必须用命令<code>make clean</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make clean</span><br><span class="line">rm -f m.txt</span><br><span class="line">rm -f x.txt</span><br></pre></td></tr></table></figure>
<p>然而，在执行<code>clean</code>时，我们并没有创建一个名为<code>clean</code>的文件，所以，因为目标文件<code>clean</code>不存在，每次运行<code>make clean</code>，都会执行这个规则的命令。</p>
<p>如果我们手动创建一个<code>clean</code>的文件，这个<code>clean</code>规则就不会执行了！</p>
<p>如果我们希望<code>make</code>把<code>clean</code>不要视为文件，可以添加一个标识：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f m.txt</span><br><span class="line">	rm -f x.txt</span><br></pre></td></tr></table></figure>
<p>此时，<code>clean</code>就不被视为一个文件，而是伪目标（Phony Target）。</p>
<p>大型项目通常会提供<code>clean</code>、<code>install</code>这些约定俗成的伪目标名称，方便用户快速执行特定任务。</p>
<p>一般来说，并不需要用<code>.PHONY</code>标识<code>clean</code>等约定俗成的伪目标名称，除非有人故意搞破坏，手动创建名字叫<code>clean</code>的文件。</p>
<h3 id="执行多条命令">执行多条命令</h3>
<p>一个规则可以有多条命令，例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd:</span></span><br><span class="line">	pwd</span><br><span class="line">	cd ..</span><br><span class="line">	pwd</span><br></pre></td></tr></table></figure>
<p>执行<code>cd</code>规则：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make cd</span><br><span class="line">pwd</span><br><span class="line">/home/ubuntu/makefile-tutorial/v1</span><br><span class="line">cd ..</span><br><span class="line">pwd</span><br><span class="line">/home/ubuntu/makefile-tutorial/v1</span><br></pre></td></tr></table></figure>
<p>观察输出，发现<code>cd ..</code>命令执行后，并未改变当前目录，两次输出的<code>pwd</code>是一样的，这是因为<code>make</code>针对每条命令，都会创建一个独立的Shell环境，类似<code>cd ..</code>这样的命令，并不会影响当前目录。</p>
<p>解决办法是把多条命令以<code>;</code>分隔，写到一行：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">	pwd; cd ..; pwd;</span><br></pre></td></tr></table></figure>
<p>再执行<code>cd_ok</code>目标就得到了预期结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make cd_ok</span><br><span class="line">pwd; cd ..; pwd</span><br><span class="line">/home/ubuntu/makefile-tutorial/v1</span><br><span class="line">/home/ubuntu/makefile-tutorial</span><br></pre></td></tr></table></figure>
<p>可以使用<code>\</code>把一行语句拆成多行，便于浏览：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">	pwd; \</span><br><span class="line">	cd ..; \</span><br><span class="line">	pwd</span><br></pre></td></tr></table></figure>
<p>另一种执行多条命令的语法是用<code>&amp;&amp;</code>，它的好处是当某条命令失败时，后续命令不会继续执行：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">	cd .. &amp;&amp; pwd</span><br></pre></td></tr></table></figure>
<h3 id="控制打印">控制打印</h3>
<p>默认情况下，<code>make</code>会打印出它执行的每一条命令。如果我们不想打印某一条命令，可以在命令前加上<code>@</code>，表示不打印命令（但是仍然会执行）：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">no_output:</span></span><br><span class="line">	@echo &#x27;not display&#x27;</span><br><span class="line">	echo &#x27;will display&#x27;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make no_output</span><br><span class="line">not display</span><br><span class="line">echo &#x27;will display&#x27;</span><br><span class="line">will display</span><br></pre></td></tr></table></figure>
<p>注意命令<code>echo 'not display'</code>本身没有打印，但命令仍然会执行，并且执行的结果仍然正常打印。</p>
<h3 id="控制错误">控制错误</h3>
<p><code>make</code>在执行命令时，会检查每一条命令的返回值，如果返回错误（非0值），就会中断执行。</p>
<p>例如，不使用<code>-f</code>删除一个不存在的文件会报错：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">has_error:</span></span><br><span class="line">	rm zzz.txt</span><br><span class="line">	echo &#x27;ok&#x27;</span><br></pre></td></tr></table></figure>
<p>执行上述目标，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make has_error</span><br><span class="line">rm zzz.txt</span><br><span class="line">rm: zzz.txt: No such file or directory</span><br><span class="line">make: *** [has_error] Error 1</span><br></pre></td></tr></table></figure>
<p>由于命令<code>rm zzz.txt</code>报错，导致后面的命令<code>echo 'ok'</code>并不会执行，<code>make</code>打印出错误，然后退出。</p>
<p>有些时候，我们想忽略错误，继续执行后续命令，可以在需要忽略错误的命令前加上<code>-</code>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ignore_error:</span></span><br><span class="line">	-rm zzz.txt</span><br><span class="line">	echo &#x27;ok&#x27;</span><br></pre></td></tr></table></figure>
<p>执行上述目标，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make ignore_error</span><br><span class="line">rm zzz.txt</span><br><span class="line">rm: zzz.txt: No such file or directory</span><br><span class="line">make: [ignore_error] Error 1 (ignored)</span><br><span class="line">echo &#x27;ok&#x27;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<p><code>make</code>检测到<code>rm zzz.txt</code>报错，并打印错误，但显示<code>(ignored)</code>，然后继续执行后续命令。</p>
<p>对于执行可能出错，但不影响逻辑的命令，可以用<code>-</code>忽略。</p>
<h3 id="参考源码">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v1">GitHub</a>下载源码。</p>
<h3 id="小结">小结</h3>
<p>编写<code>Makefile</code>就是编写一系列规则，用来告诉<code>make</code>如何执行这些规则，最终生成我们期望的目标文件。</p>
<p>查看官方手册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Rules.html">编写规则</a></li>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Execution.html">执行命令</a></li>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html">伪目标</a></li>
</ul>
<h2 id="编译C程序">编译C程序</h2>
<p>C程序的编译通常分两步：</p>
<ol>
<li>将每个<code>.c</code>文件编译为<code>.o</code>文件；</li>
<li>将所有<code>.o</code>文件链接为最终的可执行文件。</li>
</ol>
<p>我们假设如下的一个C项目，包含<code>hello.c</code>、<code>hello.h</code>和<code>main.c</code>。</p>
<p><code>hello.c</code>内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>hello.h</code>内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p><code>main.c</code>内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start...\n&quot;</span>);</span><br><span class="line">    hello();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>main.c</code>引用了头文件<code>hello.h</code>。我们很容易梳理出需要生成的文件，逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌───────┐ ┌───────┐ ┌───────┐</span><br><span class="line">│hello.c│ │main.c │ │hello.h│</span><br><span class="line">└───────┘ └───────┘ └───────┘</span><br><span class="line">    │         │         │</span><br><span class="line">    │         └────┬────┘</span><br><span class="line">    │              │</span><br><span class="line">    ▼              ▼</span><br><span class="line">┌───────┐      ┌───────┐</span><br><span class="line">│hello.o│      │main.o │</span><br><span class="line">└───────┘      └───────┘</span><br><span class="line">    │              │</span><br><span class="line">    └───────┬──────┘</span><br><span class="line">            │</span><br><span class="line">            ▼</span><br><span class="line">       ┌─────────┐</span><br><span class="line">       │world.out│</span><br><span class="line">       └─────────┘</span><br></pre></td></tr></table></figure>
<p>假定最终生成的可执行文件是<code>world.out</code>，中间步骤还需要生成<code>hello.o</code>和<code>main.o</code>两个文件。根据上述依赖关系，我们可以很容易地写出<code>Makefile</code>如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成可执行文件:</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">	cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 hello.c:</span></span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">	cc -c hello.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 main.c:</span></span><br><span class="line"><span class="section">main.o: main.c hello.h</span></span><br><span class="line">	cc -c main.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o world.out</span><br></pre></td></tr></table></figure>
<p>执行<code>make</code>，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -c main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>在当前目录下可以看到<code>hello.o</code>、<code>main.o</code>以及最终的可执行程序<code>world.out</code>。执行<code>world.out</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./world.out </span><br><span class="line">start...</span><br><span class="line">hello, world!</span><br><span class="line">exit.</span><br></pre></td></tr></table></figure>
<p>与我们预期相符。</p>
<p>修改<code>hello.c</code>，把输出改为<code>&quot;hello, bob!\n&quot;</code>，再执行<code>make</code>，观察输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>仅重新编译了<code>hello.c</code>，并未编译<code>main.c</code>。由于<code>hello.o</code>已更新，所以，仍然要重新生成<code>world.out</code>。执行<code>world.out</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./world.out </span><br><span class="line">start...</span><br><span class="line">hello, bob!</span><br><span class="line">exit.</span><br></pre></td></tr></table></figure>
<p>与我们预期相符。</p>
<p>修改<code>hello.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int 变为 void:</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>以及<code>hello.c</code>，再次执行<code>make</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -c main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>会触发<code>main.c</code>的编译，因为<code>main.c</code>依赖<code>hello.h</code>。</p>
<p>执行<code>make clean</code>会删除所有的<code>.o</code>文件，以及可执行文件<code>world.out</code>，再次执行<code>make</code>就会强制全量编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make clean &amp;&amp; make</span><br><span class="line">rm -f *.o world.out</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -c main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>这个简单的<code>Makefile</code>使我们能自动化编译C程序，十分方便。</p>
<p>不过，随着越来越多的<code>.c</code>文件被添加进来，如何高效维护<code>Makefile</code>的规则？我们后面继续讲解。</p>
<h3 id="参考源码-2">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v2">GitHub</a>下载源码。</p>
<h3 id="小结-2">小结</h3>
<p>在<code>Makefile</code>正确定义规则后，我们就能用<code>make</code>自动化编译C程序。</p>
<hr>
<hr>
<h2 id="使用隐式规则">使用隐式规则</h2>
<p>我们仍然以上一节的C项目为例，当我们添加越来越多的<code>.c</code>文件时，就需要编写越来越多的规则来生成<code>.o</code>文件。</p>
<p>实际上，有的同学可能发现了，即使我们把<code>.o</code>的规则删掉，也能正常编译：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只保留生成 world.out 的规则:</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">	cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o world.out</span><br></pre></td></tr></table></figure>
<p>执行<code>make</code>，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc    -c -o hello.o hello.c</span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>我们没有定义<code>hello.o</code>和<code>main.o</code>的规则，为什么<code>make</code>也能正常创建这两个文件？</p>
<p>因为<code>make</code>最初就是为了编译C程序而设计的，为了免去重复创建编译<code>.o</code>文件的规则，<code>make</code>内置了隐式规则（Implicit Rule），即遇到一个<code>xyz.o</code>时，如果没有找到对应的规则，就自动应用一个隐式规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">xyz.o: xyz.c</span></span><br><span class="line">	cc -c -o xyz.o xyz.c</span><br></pre></td></tr></table></figure>
<p><code>make</code>针对C、C++、ASM、Fortran等程序内置了一系列隐式规则，可以参考官方手册查看。</p>
<p>对于C程序来说，使用隐式规则有一个潜在问题，那就是无法跟踪<code>.h</code>文件的修改。如果我们修改了<code>hello.h</code>的定义，由于隐式规则<code>main.o: main.c</code>并不会跟踪<code>hello.h</code>的修改，导致<code>main.c</code>不会被重新编译，这个问题我们放到后面解决。</p>
<h3 id="参考源码-3">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v3">GitHub</a>下载源码。</p>
<h3 id="小结-3">小结</h3>
<p>针对C、C++、ASM、Fortran等程序，<code>make</code>内置了一系列隐式规则，使用隐式规则可减少大量重复的通用编译规则。</p>
<p>查看官方手册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Using-Implicit.html">使用隐式规则</a></li>
</ul>
<hr>
<hr>
<p>当我们在<code>Makefile</code>中重复写很多文件名时，一来容易写错，二来如果要改名，要全部替换，费时费力。</p>
<p>编程语言使用变量（Variable）来解决反复引用的问题，类似的，在<code>Makefile</code>中，也可以使用变量来解决重复问题。</p>
<p>以上一节的<code>Makefile</code>为例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">	cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o world.out</span><br></pre></td></tr></table></figure>
<p>编译的最终文件<code>world.out</code>重复出现了3次，因此，完全可以定义一个变量来替换它：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: hello.o main.o</span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>变量定义用<code>变量名 = 值</code>或者<code>变量名 := 值</code>，通常变量名全大写。引用变量用<code>$(变量名)</code>，非常简单。</p>
<p>注意到<code>hello.o main.o</code>这个“列表”也重复了，我们也可以用变量来替换：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OBJS = hello.o main.o</span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>如果有一种方式能让<code>make</code>自动生成<code>hello.o main.o</code>这个“列表”，就更好了。注意到每个<code>.o</code>文件是由对应的<code>.c</code>文件编译产生的，因此，可以让<code>make</code>先获取<code>.c</code>文件列表，再替换，得到<code>.o</code>文件列表：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $(wildcard *.c) 列出当前目录下的所有 .c 文件: hello.c main.c</span></span><br><span class="line"><span class="comment"># 用函数 patsubst 进行模式替换得到: hello.o main.o</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>这样，我们每添加一个<code>.c</code>文件，不需要修改<code>Makefile</code>，变量<code>OBJS</code>会自动更新。</p>
<p>思考：为什么我们不能直接定义<code>OBJS = $(wildcard *.o)</code>让<code>make</code>列出所有<code>.o</code>文件？</p>
<h3 id="内置变量">内置变量</h3>
<p>我们还可以用变量<code>$(CC)</code>替换命令<code>cc</code>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure>
<p>没有定义变量<code>CC</code>也可以引用它，因为它是<code>make</code>的内置变量（Builtin Variables），表示C编译器的名字，默认值是<code>cc</code>，我们也可以修改它，例如使用交叉编译时，指定编译器：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC = riscv64-linux-gnu-gcc</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="自动变量">自动变量</h3>
<p>在<code>Makefile</code>中，经常可以看到<code>$@</code>、<code>$&lt;</code>这样的变量，这种变量称为自动变量（Automatic Variable），它们在一个规则中自动指向某个值。</p>
<p>例如，<code>$@</code>表示目标文件，<code>$^</code>表示所有依赖文件，因此，我们可以这么写：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">	cc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure>
<p>在没有歧义时可以写<code>$@</code>，也可以写<code>$(@)</code>，有歧义时必须用括号，例如<code>$(@D)</code>。</p>
<p>为了更好地调试，我们还可以把变量打印出来：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">	@echo &#x27;$<span class="variable">$@</span> = <span class="variable">$@</span>&#x27; <span class="comment"># 变量 $@ 表示target</span></span><br><span class="line">	@echo &#x27;$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>&#x27; <span class="comment"># 变量 $&lt; 表示第一个依赖项</span></span><br><span class="line">	@echo &#x27;$<span class="variable">$^</span> = <span class="variable">$^</span>&#x27; <span class="comment"># 变量 $^ 表示所有依赖项</span></span><br><span class="line">	cc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure>
<p>执行结果输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$@ = world.out</span><br><span class="line">$&lt; = hello.o</span><br><span class="line">$^ = hello.o main.o</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<h3 id="参考源码-4">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v4">GitHub</a>下载源码。</p>
<h3 id="小结-4">小结</h3>
<p>使用变量可以让<code>Makefile</code>更加容易维护。</p>
<p>查看官方手册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Using-Variables.html">如何使用变量</a></li>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">自动变量</a></li>
</ul>
<h2 id="使用模式规则">使用模式规则</h2>
<p>前面我们讲了使用隐式规则可以让<code>make</code>在必要时自动创建<code>.o</code>文件的规则，但<code>make</code>的隐式规则的命令是固定的，对于<code>xyz.o: xyz.c</code>，它实际上是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>能修改的只有变量<code>$(CC)</code>和<code>$(CFLAGS)</code>。如果要执行多条命令，使用隐式规则就不行了。</p>
<p>这时，我们可以自定义模式规则（Pattern Rules），它允许<code>make</code>匹配模式规则，如果匹配上了，就自动创建一条模式规则。</p>
<p>我们修改上一节的<code>Makefile</code>如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式匹配规则：当make需要目标 xyz.o 时，自动生成一条 xyz.o: xyz.c 规则:</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	@echo &#x27;compiling <span class="variable">$&lt;</span>...&#x27;</span><br><span class="line">	cc -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>当<code>make</code>执行<code>world.out: hello.o main.o</code>时，发现没有<code>hello.o</code>文件，于是需要查找以<code>hello.o</code>为目标的规则，结果匹配到模式规则<code>%.o: %.c</code>，于是<code>make</code>自动根据模式规则为我们动态创建了如下规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">	@echo &#x27;compiling <span class="variable">$&lt;</span>...&#x27;</span><br><span class="line">	cc -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>查找<code>main.o</code>也是类似的匹配过程，于是我们执行<code>make</code>，就可以用模式规则完成编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">compiling hello.c...</span><br><span class="line">cc -c -o hello.o hello.c</span><br><span class="line">compiling main.c...</span><br><span class="line">cc -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>模式规则的命令完全由我们自己定义，因此，它比隐式规则更灵活。</p>
<p>但是，模式规则仍然没有解决修改<code>hello.h</code>头文件不会触发<code>main.c</code>重新编译的问题，这个依赖问题我们继续放到后面解决。</p>
<p>最后注意，模式规则是按需生成，如果我们在当前目录创建一个<code>zzz.o</code>文件，因为<code>make</code>并不会在执行过程中用到它，所以并不会自动生成<code>zzz.o: zzz.c</code>这个规则。</p>
<h3 id="参考源码-5">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v5">GitHub</a>下载源码。</p>
<h3 id="小结-5">小结</h3>
<p>使用模式规则可以灵活地按需动态创建规则，它比隐式规则更灵活。</p>
<p>查看官方手册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Pattern-Intro.html">模式规则</a></li>
</ul>
<hr>
<hr>
<p>前面我们讲了隐式规则和模式规则，这两种规则都可以解决自动把<code>.c</code>文件编译成<code>.o</code>文件，但都无法解决<code>.c</code>文件依赖<code>.h</code>文件的问题。</p>
<p>因为一个<code>.c</code>文件依赖哪个<code>.h</code>文件必须要分析文件内容才能确定，没有一个简单的文件名映射规则。</p>
<p>但是，要识别出<code>.c</code>文件的头文件依赖，可以用GCC提供的<code>-MM</code>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cc -MM main.c</span><br><span class="line">main.o: main.c hello.h</span><br></pre></td></tr></table></figure>
<p>上述输出告诉我们，编译<code>main.o</code>依赖<code>main.c</code>和<code>hello.h</code>两个文件。</p>
<p>因此，我们可以利用GCC的这个功能，对每个<code>.c</code>文件都生成一个依赖项，通常我们把它保存到<code>.d</code>文件中，再用<code>include</code>引入到<code>Makefile</code>，就相当于自动化完成了每个<code>.c</code>文件的精准依赖。</p>
<p>我们改写上一节的<code>Makefile</code>如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有 .c 文件:</span></span><br><span class="line">SRCS = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据SRCS生成 .o 文件列表:</span></span><br><span class="line">OBJS = $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据SRCS生成 .d 文件列表:</span></span><br><span class="line">DEPS = $(SRCS:.c=.d)</span><br><span class="line"></span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标:</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># xyz.d 的规则由 xyz.c 生成:</span></span><br><span class="line"><span class="section">%.d: %.c</span></span><br><span class="line">	rm -f <span class="variable">$@</span>; \</span><br><span class="line">	<span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> &gt;<span class="variable">$@</span>.tmp; \</span><br><span class="line">	sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.tmp &gt; <span class="variable">$@</span>; \</span><br><span class="line">	rm -f <span class="variable">$@</span>.tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式规则:</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf *.o *.d <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入所有 .d 文件:</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(DEPS)</span></span><br></pre></td></tr></table></figure>
<p>变量<code>$(SRCS)</code>通过扫描目录可以确定为<code>hello.c main.c</code>，因此，变量<code>$(OBJS)</code>赋值为<code>hello.o main.o</code>，变量<code>$(DEPS)</code>赋值为<code>hello.d main.d</code>。</p>
<p>通过<code>include $(DEPS)</code>我们引入<code>hello.d</code>和<code>main.d</code>文件，但是这两个文件一开始并不存在，不过，<code>make</code>通过模式规则匹配到<code>%.d: %.c</code>，这就给了我们一个机会，在这个模式规则内部，用<code>cc -MM</code>命令外加<code>sed</code>把<code>.d</code>文件创建出来。</p>
<p>运行<code>make</code>，首次输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">Makefile:31: hello.d: No such file or directory</span><br><span class="line">Makefile:31: main.d: No such file or directory</span><br><span class="line">rm -f main.d; \</span><br><span class="line">        cc -MM main.c &gt;main.d.tmp; \</span><br><span class="line">        sed &#x27;s,\(main\)\.o[ :]*,\1.o main.d : ,g&#x27; &lt; main.d.tmp &gt; main.d; \</span><br><span class="line">        rm -f main.d.tmp</span><br><span class="line">rm -f hello.d; \</span><br><span class="line">        cc -MM hello.c &gt;hello.d.tmp; \</span><br><span class="line">        sed &#x27;s,\(hello\)\.o[ :]*,\1.o hello.d : ,g&#x27; &lt; hello.d.tmp &gt; hello.d; \</span><br><span class="line">        rm -f hello.d.tmp</span><br><span class="line">cc -c -o hello.o hello.c</span><br><span class="line">cc -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p><code>make</code>会提示找不到<code>hello.d</code>和<code>main.d</code>，不过随后自动创建出<code>hello.d</code>和<code>main.d</code>。<code>hello.d</code>内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello.o hello.d : hello.c</span><br></pre></td></tr></table></figure>
<p>上述规则有两个目标文件，实际上相当于如下两条规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello.o : hello.c</span><br><span class="line">hello.d : hello.c</span><br></pre></td></tr></table></figure>
<p><code>main.d</code>内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o main.d : main.c hello.h</span><br></pre></td></tr></table></figure>
<p>因此，<code>main.o</code>依赖于<code>main.c</code>和<code>hello.h</code>，这个依赖关系就和我们手动指定的一致。</p>
<p>改动<code>hello.h</code>，再次运行<code>make</code>，可以触发<code>main.c</code>的编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">rm -f main.d; \</span><br><span class="line">        cc -MM main.c &gt;main.d.tmp; \</span><br><span class="line">        sed &#x27;s,\(main\)\.o[ :]*,\1.o main.d : ,g&#x27; &lt; main.d.tmp &gt; main.d; \</span><br><span class="line">        rm -f main.d.tmp</span><br><span class="line">cc -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>在实际项目中，对每个<code>.c</code>文件都可以生成一个对应的<code>.d</code>文件表示依赖关系，再通过<code>include</code>引入到<code>Makefile</code>，同时又能让<code>make</code>自动更新<code>.d</code>文件，有点蛋生鸡和鸡生蛋的关系，不过，这种机制能正常工作，除了<code>.d</code>文件不存在时会打印错误，有强迫症的同学肯定感觉不满意，这个问题我们后面解决。</p>
<h3 id="参考源码-6">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v6">GitHub</a>下载源码。</p>
<h3 id="小结-6">小结</h3>
<p>利用GCC生成<code>.d</code>文件，再用<code>include</code>引入<code>Makefile</code>，可解决一个<code>.c</code>文件应该如何正确触发编译的问题。</p>
<p>查看官方手册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Automatic-Prerequisites.html">自动生成依赖</a></li>
</ul>
<h2 id="完善Makefile">完善Makefile</h2>
<p>上一节我们解决了自动生成依赖的问题，这一节我们对项目目录进行整理，把所有源码放入<code>src</code>目录，所有编译生成的文件放入<code>build</code>目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">├── Makefile</span><br><span class="line">├── build</span><br><span class="line">└── src</span><br><span class="line">    ├── hello.c</span><br><span class="line">    ├── hello.h</span><br><span class="line">    └── main.c</span><br></pre></td></tr></table></figure>
<p>整理<code>Makefile</code>，内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">SRC_DIR = ./src</span><br><span class="line">BUILD_DIR = ./build</span><br><span class="line">TARGET = <span class="variable">$(BUILD_DIR)</span>/world.out</span><br><span class="line"></span><br><span class="line">CC = cc</span><br><span class="line">CFLAGS = -Wall</span><br><span class="line"></span><br><span class="line"><span class="comment"># ./src/*.c</span></span><br><span class="line">SRCS = <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(SRC_DIR)</span> -name &#x27;*.c&#x27;)</span></span><br><span class="line"><span class="comment"># ./src/*.c =&gt; ./build/*.o</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c,<span class="variable">$(BUILD_DIR)</span>/%.o,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line"><span class="comment"># ./src/*.c =&gt; ./build/*.d</span></span><br><span class="line">DEPS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c,<span class="variable">$(BUILD_DIR)</span>/%.d,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标:</span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build/xyz.d 的规则由 src/xyz.c 生成:</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.d: <span class="variable">$(SRC_DIR)</span>/%.c</span><br><span class="line">	@mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>; \</span><br><span class="line">	rm -f <span class="variable">$@</span>; \</span><br><span class="line">	<span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> &gt;<span class="variable">$@</span>.tmp; \</span><br><span class="line">	sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,<span class="variable">$(BUILD_DIR)</span>/\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.tmp &gt; <span class="variable">$@</span>; \</span><br><span class="line">	rm -f <span class="variable">$@</span>.tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># build/xyz.o 的规则由 src/xyz.c 生成:</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.o: <span class="variable">$(SRC_DIR)</span>/%.c</span><br><span class="line">	@mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接:</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	@echo <span class="string">&quot;buiding <span class="variable">$@</span>...&quot;</span></span><br><span class="line">	@mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理 build 目录:</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	@echo <span class="string">&quot;clean...&quot;</span></span><br><span class="line">	rm -rf <span class="variable">$(BUILD_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入所有 .d 文件:</span></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br></pre></td></tr></table></figure>
<p>这个<code>Makefile</code>定义了源码目录<code>SRC_DIR</code>、生成目录<code>BUILD_DIR</code>，以及其他变量，同时用<code>-include</code>消除了<code>.d</code>文件不存在的错误。执行<code>make</code>，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -Wall -c -o build/hello.o src/hello.c</span><br><span class="line">cc -Wall -c -o build/main.o src/main.c</span><br><span class="line">buiding build/world.out...</span><br><span class="line">cc -o ./build/world.out ./build/hello.o ./build/main.o</span><br></pre></td></tr></table></figure>
<p>可以说基本满足编译需求，收工！</p>
<h3 id="参考源码-7">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v7">GitHub</a>下载源码。</p>
<h3 id="小结-7">小结</h3>
<p>除了基础的用法外，<code>Makefile</code>还支持条件判断，环境变量，嵌套执行，变量展开等各种功能，需要用到时可以查询<a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/index.html">官方手册</a>。</p>
<hr>
<hr>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2021/05/23/makefile%E6%95%99%E7%A8%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">第 1 頁 共 1 頁</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 235 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
