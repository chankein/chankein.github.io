
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"Website","@id":"https://keinchan.com","author":{"@type":"Person","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg"},"name":"Kein's blog","description":"","url":"https://keinchan.com"}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Kein&#39;s blog">
<meta property="og:url" content="https://keinchan.com/page/12/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Kein Chan">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://keinchan.com../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../#about"
            >
        
        
            <img class="header-picture" src="../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2019/09/28/%E6%95%B0%E5%AD%A6/1-%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E6%95%B0%E6%8E%A8%E5%AF%BC/"
                            aria-label=": 1.初等函数的导数推导"
                        >
                            1.初等函数的导数推导
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-28T10:58:41+08:00">
	
		    2019 年 9 月 28 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../categories/%E5%9F%BA%E7%A1%80/">基础</a>, <a class="category-link" href="../../categories/%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%AD%A6/">数学</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="初等函数的导数推导">初等函数的导数推导</h2>
<h3 id="1-幂函数求导">1. 幂函数求导</h3>
<p>求 $$\textcolor{red}{f(x)=x^n}$$ 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">x=a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">=</span><span class="mord mathit">a</span></span></span></span> 处的导数：</p>
\begin{align*}
f'(x) 
&= \lim_{x\to a} \frac{f(x)-f(a)}{x-a} \\
&= \lim_{x\to a} \frac{x^n-a^n}{x-a} \\
&= \lim_{x\to a} \frac{(x^n-ax^{n-1}) + (ax^{n-1}-a^2x^{n-2}) + \cdots + a^{n-1}x-a^n}{x-a} \\
&= \lim_{x\to a} \left[(x^{n-1}) + (ax^{n-2}) + \cdots + a^{n-1}\right] \\
&= \lim_{x\to a} (x^{n-1}) + \lim_{x \to a} (ax^{n-2})...+\lim_{x\to a} a^{n-1} \\
&= na^{n-1}
\end{align*}

\begin{align*}
\therefore
f(x)=x^n \\
f'(x) = n x^{n-1}
\end{align*}

<hr>
<h3 id="2-正弦函数求导">2. 正弦函数求导</h3>
<p>求 $$\textcolor{red}{f(x)= \sin x}$$ 的导数：</p>
\begin{align*}
f'(x) &= \lim_{h\to 0} \frac{f(x+h)-f(x)}{h} \\
&= \lim_{h\to 0} \frac{\sin(x+h)-\sin x}{h} \\
&= \lim_{h\to 0} \frac{2\sin\left(\frac{h}{2}\right)\cos\left(x+\frac{h}{2}\right)}{h} \\
&= \lim_{h\to 0} \left(\frac{\sin\left(\frac{h}{2}\right)}{\frac{h}{2}} \cdot \cos\left(x+\frac{h}{2}\right)\right) \\
&= \cos x
\end{align*}

<hr>
<h3 id="3-余弦函数求导">3. 余弦函数求导</h3>
<p>求 $$\textcolor{red}{f(x)= \cos x}$$ 的导数：</p>
\begin{align*}
f'(x) 
&= \lim_{h\to 0} {f(x+h)-f(x) \over h} \\
&= \lim_{h\to 0} \frac{\cos(x+h)-\cos x}{h} \\
&= \lim_{h\to 0} \frac{-2\sin\left(\frac{h}{2}\right)\sin\left(x+\frac{h}{2}\right)}{h} \\
&= -\lim_{h\to 0} \left(\frac{\sin\left(\frac{h}{2}\right)}{\frac{h}{2}} \cdot \sin\left(x+\frac{h}{2}\right)\right) \\
&= -\sin x
\end{align*}

<hr>
<h3 id="4-指数函数求导">4. 指数函数求导</h3>
<p>求 $$\textcolor{red}{f(x)= a^x}$$ 的导数：</p>
\begin{align*}
f'(x) 
&= \lim_{h\to 0} {f(x+h)-f(x) \over h} \\
&= \lim_{h\to 0} \frac{a^{x+h}-a^x}{h} \\
&= \textcolor{red}{a^x \lim_{h\to 0} \frac{a^h-1}{h}} \\
&= \textcolor{red}{a^x \ln a}
\end{align*}

<p><strong>推导关键步骤</strong>：<br>
令 $$t = a^h - 1$$，则：</p>
\begin{align*}
a=log_a (t+1)
\end{align*}

\begin{align*}
此时有:
\textcolor{red}{
\lim_{h\to 0} \frac{a^h-1}{h} = \lim_{t\to 0} \frac{t}{\log_a(t+1)} = \ln a}
\end{align*}

<hr>
<h3 id="5-对数函数求导">5. 对数函数求导</h3>
<p>求 $$\textcolor{red}{f(x)= \log_a x}$$ 的导数：</p>
\begin{align*}
f'(x) 
&= \lim_{h\to 0} {f(x+h)-f(x) \over h} \\
&= \lim_{h\to 0} \frac{\log_a(x+h) - \log_a x}{h} \\
&= \lim_{h\to 0} {log_a \ {(x+h) \over x} \over h} \\
&= \lim_{h\to 0} \frac{1}{x} \cdot \textcolor{red}{\frac{\log_a\left(1+\frac{h}{x}\right)}{\frac{h}{x}}} \\
&\textcolor{red}{= \frac{1}{x \ln a}}
\end{align*}

<p><strong>特例</strong>：当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">a=e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mrel">=</span><span class="mord mathit">e</span></span></span></span> 时，</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>l</mi><mi>n</mi><mtext> </mtext><mi>x</mi></mrow><annotation encoding="application/x-tex">f(x)= ln \ x 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">n</span><span class="mord mspace"> </span><span class="mord mathit">x</span></span></span></span></span></p>
\begin{align*}
& f'(x) =(\ln x)' = \frac{1}{x}
\end{align*}


                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2019/09/28/%E6%95%B0%E5%AD%A6/1-%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E6%95%B0%E6%8E%A8%E5%AF%BC/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2019/09/13/%E6%95%B0%E5%AD%A6/0-%E4%B8%AD%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0/"
                            aria-label=": 0.中学数学复习"
                        >
                            0.中学数学复习
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-13T16:58:41+08:00">
	
		    2019 年 9 月 13 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../categories/%E5%9F%BA%E7%A1%80/">基础</a>, <a class="category-link" href="../../categories/%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%AD%A6/">数学</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h4 id="等比公式：">等比公式：</h4>
\begin{align*}
S_n=a_1(1-q^n)/(1-q)
\end{align*}

<h4 id="等差公式：">等差公式：</h4>
\begin{align*}
S_n=(a_1+a_n)n/2=na_1+n(n-1)d/2
\end{align*}

<hr>
<h3 id="排列组合：">排列组合：</h3>
<h4 id="排列">排列</h4>
\begin{align*}
A^m_n=n(n-1)(n-2)...(n-m+1)=\frac{n!}{(n-m)!}
\end{align*}

<h4 id="组合">组合</h4>
\begin{align*}
C^m_n={A^m_n \over m!}={n(n-1)(n-2)...(n-m+1)\over m!}={n! \over m!(n-m)!}
\end{align*}

<hr>
<h3 id="牛顿二项式">牛顿二项式</h3>
\begin{align*}
(a+b)^n=\sum^n_{k=0}C^k_nx^k
\end{align*}

<hr>
<h3 id="三角函数">三角函数</h3>
\begin{align*}
\sin(\alpha+\beta)=\sin(\alpha)\cos(\beta)+\cos(\alpha)\sin(\beta)

\therefore \sin(2\alpha)=2\sin(\alpha)\cos(\alpha)
\end{align*}

\begin{align*}
\cos(\alpha+\beta)=\cos(\alpha)\cos(\beta)-\sin(\alpha)s\in(\beta)

\therefore \cos(2\alpha)=\cos^2(\alpha)-\sin^2(\alpha)
\end{align*}

<hr>
<h3 id="对数函数">对数函数</h3>
<hr>
<p>e的定义</p>
\begin{align*}
\lim_{x\to \infty} (1+{1 \over {n}})^n=e
\end{align*}


                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2019/09/13/%E6%95%B0%E5%AD%A6/0-%E4%B8%AD%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2019/09/12/%E6%95%B0%E5%AD%A6/markdown-latex%E7%9A%84%E6%95%B0%E5%AD%A6%E5%BC%8F%E5%86%99%E6%B3%95/"
                            aria-label=": LaTeX的写法"
                        >
                            LaTeX的写法
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-12T15:24:55+08:00">
	
		    2019 年 9 月 12 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../categories/%E5%9F%BA%E7%A1%80/">基础</a>, <a class="category-link" href="../../categories/%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%AD%A6/">数学</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>数学符号和对应的LaTeX代码：</p>
<table>
<thead>
<tr>
<th>符号显示</th>
<th>LaTeX代码</th>
<th>符号显示</th>
<th>LaTeX代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>∑</td>
<td><code>$\sum$</code></td>
<td>∑_{i=0}^n</td>
<td><code>$\sum_&#123;i=0&#125;^n$</code></td>
</tr>
<tr>
<td>∏</td>
<td><code>$\prod$</code></td>
<td>∏_{i=0}^n</td>
<td><code>$\prod_&#123;i=0&#125;^n$</code></td>
</tr>
<tr>
<td>×</td>
<td><code>$\times$</code></td>
<td>∗</td>
<td><code>$\ast$</code></td>
</tr>
<tr>
<td>±</td>
<td><code>$\pm$</code></td>
<td>÷</td>
<td><code>$\div$</code></td>
</tr>
<tr>
<td>∣</td>
<td><code>$\mid$</code></td>
<td>⋅</td>
<td><code>$\cdot$</code></td>
</tr>
<tr>
<td>⨀</td>
<td><code>$\bigodot$</code></td>
<td>≈</td>
<td><code>$\approx$</code></td>
</tr>
<tr>
<td>≤</td>
<td><code>$\leq$</code></td>
<td>≥</td>
<td><code>$\geq$</code></td>
</tr>
<tr>
<td>≠</td>
<td><code>$\neq$</code></td>
<td>≡</td>
<td><code>$\equiv$</code></td>
</tr>
<tr>
<td>x̄</td>
<td><code>$\overline&#123;x&#125;$</code></td>
<td>x̲</td>
<td><code>$\underline&#123;x&#125;$</code></td>
</tr>
<tr>
<td>x̂</td>
<td><code>$\hat&#123;x&#125;$</code></td>
<td>x̌</td>
<td><code>$\check&#123;x&#125;$</code></td>
</tr>
<tr>
<td>x̆</td>
<td><code>$\breve&#123;x&#125;$</code></td>
<td>↑</td>
<td><code>$\uparrow$</code></td>
</tr>
<tr>
<td>↓</td>
<td><code>$\downarrow$</code></td>
<td>←</td>
<td><code>$\leftarrow$</code></td>
</tr>
<tr>
<td>→</td>
<td><code>$\rightarrow$</code></td>
<td>⇑</td>
<td><code>$\Uparrow$</code></td>
</tr>
<tr>
<td>⇓</td>
<td><code>$\Downarrow$</code></td>
<td>⇐</td>
<td><code>$\Leftarrow$</code></td>
</tr>
<tr>
<td>⇒</td>
<td><code>$\Rightarrow$</code></td>
<td>⟵</td>
<td><code>$\longleftarrow$</code></td>
</tr>
<tr>
<td>⟶</td>
<td><code>$\longrightarrow$</code></td>
<td>⟸</td>
<td><code>$\Longleftarrow$</code></td>
</tr>
<tr>
<td>⟹</td>
<td><code>$\Longrightarrow$</code></td>
<td>∵</td>
<td><code>$\because$</code></td>
</tr>
<tr>
<td>∴</td>
<td><code>$\therefore$</code></td>
<td>∀</td>
<td><code>$\forall$</code></td>
</tr>
<tr>
<td>∃</td>
<td><code>$\exists$</code></td>
<td>y′</td>
<td><code>$y'$</code></td>
</tr>
<tr>
<td>∫</td>
<td><code>$\int$</code></td>
<td>∬</td>
<td><code>$\iint$</code></td>
</tr>
<tr>
<td>∭</td>
<td><code>$\iiint$</code></td>
<td>∮</td>
<td><code>$\oint$</code></td>
</tr>
<tr>
<td>lim</td>
<td><code>$\lim$</code></td>
<td>∞</td>
<td><code>$\infty$</code></td>
</tr>
<tr>
<td>∇</td>
<td><code>$\nabla$</code></td>
<td>⊥</td>
<td><code>$\bot$</code></td>
</tr>
<tr>
<td>∠30°</td>
<td><code>$\angle 30^\circ$</code></td>
<td>sin</td>
<td><code>$\sin$</code></td>
</tr>
<tr>
<td>cos</td>
<td><code>$\cos$</code></td>
<td>tan</td>
<td><code>$\tan$</code></td>
</tr>
<tr>
<td>cot</td>
<td><code>$\cot$</code></td>
<td>sec</td>
<td><code>$\sec$</code></td>
</tr>
<tr>
<td>csc</td>
<td><code>$\csc$</code></td>
<td>log</td>
<td><code>$\log$</code></td>
</tr>
<tr>
<td>lg</td>
<td><code>$\lg$</code></td>
<td>ln</td>
<td><code>$\ln$</code></td>
</tr>
<tr>
<td>∅</td>
<td><code>$\emptyset$</code></td>
<td>∈</td>
<td><code>$\in$</code></td>
</tr>
<tr>
<td>∉</td>
<td><code>$\notin$</code></td>
<td>⊂</td>
<td><code>$\subset$</code></td>
</tr>
<tr>
<td>⊃</td>
<td><code>$\supset$</code></td>
<td>⊆</td>
<td><code>$\subseteq$</code></td>
</tr>
<tr>
<td>⊇</td>
<td><code>$\supseteq$</code></td>
<td>⋂</td>
<td><code>$\bigcap$</code></td>
</tr>
<tr>
<td>⋃</td>
<td><code>$\bigcup$</code></td>
<td>⋁</td>
<td><code>$\bigvee$</code></td>
</tr>
<tr>
<td>⋀</td>
<td><code>$\bigwedge$</code></td>
<td>⨄</td>
<td><code>$\biguplus$</code></td>
</tr>
<tr>
<td>⨆</td>
<td><code>$\bigsqcup$</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="分式与特殊符号">分式与特殊符号</h3>
<table>
<thead>
<tr>
<th>显示</th>
<th>LaTeX代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>1/(2x+1)</td>
<td><code>$\frac&#123;1&#125;&#123;2x+1&#125;$</code></td>
</tr>
<tr>
<td>1/(2x+1)</td>
<td><code>$&#123;&#123;1&#125; \over &#123;2x+1&#125;&#125;$</code></td>
</tr>
<tr>
<td>du/dx|_{x=0}</td>
<td>`$\left.\frac{du}{dx}\right</td>
</tr>
<tr>
<td>∛9</td>
<td><code>$\sqrt[3]&#123;9&#125;$</code></td>
</tr>
<tr>
<td>√16</td>
<td><code>$\sqrt&#123;16&#125;$</code></td>
</tr>
<tr>
<td>…</td>
<td><code>$\ldots$</code></td>
</tr>
<tr>
<td>f(x₁,x₂,…,xₙ)=x₁²+⋯+xₙ²</td>
<td><code>$f(x_1,x_2,\ldots,x_n)=x_1^2+\cdots+x_n^2$</code></td>
</tr>
<tr>
<td>a⃗</td>
<td><code>$\vec&#123;a&#125;$</code></td>
</tr>
<tr>
<td>∫₀¹ x²dx</td>
<td><code>$\int_0^1 x^2 dx$</code></td>
</tr>
<tr>
<td>limₙ→∞ 1/[n(n+1)]</td>
<td><code>$\lim_&#123;n\to\infty&#125;\frac&#123;1&#125;&#123;n(n+1)&#125;$</code></td>
</tr>
<tr>
<td>∑₁ⁿ 1/x²</td>
<td><code>$\sum_1^n \frac&#123;1&#125;&#123;x^2&#125;$</code></td>
</tr>
<tr>
<td>x∈[0,100]</td>
<td><code>$x \in [0,100]$</code></td>
</tr>
<tr>
<td>xʸᶻ=(1+eˣ)⁻²ˣʸʷ</td>
<td><code>$x^&#123;y^z&#125;=(1+e^x)^&#123;-2xy^w&#125;$</code></td>
</tr>
</tbody>
</table>
<h3 id="分段函数">分段函数</h3>
\begin{align*}
y = \begin{cases} 
x \\ 
\alpha 
\end{cases}
\end{align*}

<p>LaTeX代码：</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span>y =<span class="keyword">\begin</span>&#123;cases&#125; x<span class="keyword">\\</span> <span class="keyword">\alpha</span> <span class="keyword">\end</span>&#123;cases&#125;<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2019/09/12/%E6%95%B0%E5%AD%A6/markdown-latex%E7%9A%84%E6%95%B0%E5%AD%A6%E5%BC%8F%E5%86%99%E6%B3%95/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2019/05/24/java/JAVA-Spring%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E5%8E%9F%E7%90%86/"
                            aria-label=": JAVA-Spring主从数据库的配置和动态数据源切换原理"
                        >
                            JAVA-Spring主从数据库的配置和动态数据源切换原理
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-24T18:44:46+08:00">
	
		    2019 年 5 月 24 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>在大型应用程序中，配置主从数据库并使用读写分离是常见的设计模式。在Spring应用程序中，要实现读写分离，最好不要对现有代码进行改动，而是在底层透明地支持。</p>
<p>Spring内置了一个<code>AbstractRoutingDataSource</code>，它可以把多个数据源配置成一个Map，然后，根据不同的key返回不同的数据源。因为<code>AbstractRoutingDataSource</code>也是一个DataSource接口，因此，应用程序可以先设置好key， 访问数据库的代码就可以从<code>AbstractRoutingDataSource</code>拿到对应的一个真实的数据源，从而访问指定的数据库。它的结构看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────────┐</span><br><span class="line">   │        controller         │</span><br><span class="line">   │  set routing-key = &quot;xxx&quot;  │</span><br><span class="line">   └───────────────────────────┘</span><br><span class="line">                 │</span><br><span class="line">                 ▼</span><br><span class="line">   ┌───────────────────────────┐</span><br><span class="line">   │        logic code         │</span><br><span class="line">   └───────────────────────────┘</span><br><span class="line">                 │</span><br><span class="line">                 ▼</span><br><span class="line">   ┌───────────────────────────┐</span><br><span class="line">   │    routing datasource     │</span><br><span class="line">   └───────────────────────────┘</span><br><span class="line">                 │</span><br><span class="line">       ┌─────────┴─────────┐</span><br><span class="line">       │                   │</span><br><span class="line">       ▼                   ▼</span><br><span class="line">┌─────────────┐     ┌─────────────┐</span><br><span class="line">│ read-write  │     │  read-only  │</span><br><span class="line">│ datasource  │     │ datasource  │</span><br><span class="line">└─────────────┘     └─────────────┘</span><br><span class="line">       │                   │</span><br><span class="line">       ▼                   ▼</span><br><span class="line">┌─────────────┐     ┌─────────────┐</span><br><span class="line">│  Master DB  │────▶│  Slave DB   │</span><br><span class="line">└─────────────┘     └─────────────┘</span><br></pre></td></tr></table></figure>
<h3 id="第一步：配置多数据源">第一步：配置多数据源</h3>
<p>首先，我们在SpringBoot中配置两个数据源，其中第二个数据源是<code>ro-datasource</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">jdbc-url:</span> <span class="string">jdbc:mysql://localhost/test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">rw</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">rw_password</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">pool-name:</span> <span class="string">HikariCP</span></span><br><span class="line">      <span class="attr">auto-commit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="string">...</span></span><br><span class="line">  <span class="attr">ro-datasource:</span></span><br><span class="line">    <span class="attr">jdbc-url:</span> <span class="string">jdbc:mysql://localhost/test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">ro</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">ro_password</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">pool-name:</span> <span class="string">HikariCP</span></span><br><span class="line">      <span class="attr">auto-commit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>在开发环境下，没有必要配置主从数据库。只需要给数据库设置两个用户，一个<code>rw</code>具有读写权限，一个<code>ro</code>只有SELECT权限，这样就模拟了生产环境下对主从数据库的读写分离。</p>
<p>在SpringBoot的配置代码中，我们初始化两个数据源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySpringBootApplication</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Master data source.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;masterDataSource&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">    DataSource <span class="title function_">masterDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">       logger.info(<span class="string">&quot;create master datasource...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Slave (read only) data source.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;slaveDataSource&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.ro-datasource&quot;)</span></span><br><span class="line">    DataSource <span class="title function_">slaveDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;create slave datasource...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二步：编写RoutingDataSource">第二步：编写RoutingDataSource</h3>
<p>然后，我们用Spring内置的RoutingDataSource，把两个真实的数据源代理为一个动态数据源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoutingDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">determineCurrentLookupKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;masterDataSource&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对这个<code>RoutingDataSource</code>，需要在SpringBoot中配置好并设置为主数据源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySpringBootApplication</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    DataSource <span class="title function_">primaryDataSource</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;masterDataSource&quot;)</span> DataSource masterDataSource,</span></span><br><span class="line"><span class="params">            <span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;slaveDataSource&quot;)</span> DataSource slaveDataSource</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;create routing datasource...&quot;</span>);</span><br><span class="line">        Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;masterDataSource&quot;</span>, masterDataSource);</span><br><span class="line">        map.put(<span class="string">&quot;slaveDataSource&quot;</span>, slaveDataSource);</span><br><span class="line">        <span class="type">RoutingDataSource</span> <span class="variable">routing</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoutingDataSource</span>();</span><br><span class="line">        routing.setTargetDataSources(map);</span><br><span class="line">        routing.setDefaultTargetDataSource(masterDataSource);</span><br><span class="line">        <span class="keyword">return</span> routing;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，RoutingDataSource配置好了，但是，路由的选择是写死的，即永远返回<code>&quot;masterDataSource&quot;</code>，</p>
<p>现在问题来了：如何存储动态选择的key以及在哪设置key？</p>
<p>在Servlet的线程模型中，使用ThreadLocal存储key最合适，因此，我们编写一个RoutingDataSourceContext，来设置并动态存储key：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoutingDataSourceContext</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// holds data source key in thread local:</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocalDataSourceKey = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDataSourceRoutingKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> threadLocalDataSourceKey.get();</span><br><span class="line">        <span class="keyword">return</span> key == <span class="literal">null</span> ? <span class="string">&quot;masterDataSource&quot;</span> : key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RoutingDataSourceContext</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        threadLocalDataSourceKey.set(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        threadLocalDataSourceKey.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，修改RoutingDataSource，获取key的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoutingDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">determineCurrentLookupKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RoutingDataSourceContext.getDataSourceRoutingKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在某个地方，例如一个Controller的方法内部，就可以动态设置DataSource的Key：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@Get(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;slaveDataSource&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">RoutingDataSourceContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoutingDataSourceContext</span>(key)) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;html... www.liaoxuefeng.com&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止，我们已经成功实现了数据库的动态路由访问。</p>
<p>这个方法是可行的，但是，需要读从数据库的地方，就需要加上一大段<code>try (RoutingDataSourceContext ctx = ...) &#123;&#125;</code>代码，使用起来十分不便。有没有方法可以简化呢？</p>
<p>有！</p>
<p>我们仔细想想，Spring提供的声明式事务管理，就只需要一个<code>@Transactional()</code>注解，放在某个Java方法上，这个方法就自动具有了事务。</p>
<p>我们也可以编写一个类似的<code>@RoutingWith(&quot;slaveDataSource&quot;)</code>注解，放到某个Controller的方法上，这个方法内部就自动选择了对应的数据源。代码看起来应该像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@Get(&quot;/&quot;)</span></span><br><span class="line">    <span class="meta">@RoutingWith(&quot;slaveDataSource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;html... www.liaoxuefeng.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，完全不修改应用程序的逻辑，只在必要的地方加上注解，自动实现动态数据源切换，这个方法是最简单的。</p>
<p>想要在应用程序中少写代码，我们就得多做一点底层工作：必须使用类似Spring实现声明式事务的机制，即用AOP实现动态数据源切换。</p>
<p>实现这个功能也非常简单，编写一个<code>RoutingAspect</code>，利用AspectJ实现一个<code>Around</code>拦截：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoutingAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(routingWith)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">routingWithDataSource</span><span class="params">(ProceedingJoinPoint joinPoint, RoutingWith routingWith)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> routingWith.value();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">RoutingDataSourceContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoutingDataSourceContext</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意方法的第二个参数<code>RoutingWith</code>是Spring传入的注解实例，我们根据注解的<code>value()</code>获取配置的key。编译前需要添加一个Maven依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>到此为止，我们就实现了用注解动态选择数据源的功能。最后一步重构是用字符串常量替换散落在各处的<code>&quot;masterDataSource&quot;</code>和<code>&quot;slaveDataSource&quot;</code>。</p>
<h3 id="使用限制">使用限制</h3>
<p>受Servlet线程模型的局限，动态数据源不能在一个请求内设定后再修改，也就是<code>@RoutingWith</code>不能嵌套。此外，<code>@RoutingWith</code>和<code>@Transactional</code>混用时，要设定AOP的优先级。</p>
<p>本文代码需要SpringBoot支持，JDK 1.8编译并打开<code>-parameters</code>编译参数。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2019/05/24/java/JAVA-Spring%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E5%8E%9F%E7%90%86/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2018/04/21/docker/Docker%20Compose/"
                            aria-label=": Docker Compose"
                        >
                            Docker Compose
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-21T16:02:39+08:00">
	
		    2018 年 4 月 21 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../categories/devops/">devops</a>, <a class="category-link" href="../../categories/devops/Docker/">Docker</a>, <a class="category-link" href="../../categories/devops/Docker/Docker-Compose/">Docker Compose</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="Compose-简介"><a href="#compose-%E7%AE%80%E4%BB%8B">#</a> Compose 简介</h2>
<p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的 <code>Heat</code> 十分类似。</p>
<p>其代码目前在 <a target="_blank" rel="noopener" href="https://github.com/docker/compose">https://github.com/docker/compose (opens new window)</a> 上开源。</p>
<p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p>
<p>通过第一部分中的介绍，我们知道使用一个 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>
<p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<p><code>Compose</code> 中有两个重要的概念：</p>
<ul>
<li>
<p>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</p>
</li>
<li>
<p>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</p>
</li>
</ul>
<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>
<p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>
<h2 id="安装与卸载"><a href="#%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD">#</a> 安装与卸载</h2>
<p><code>Compose</code> 支持 Linux、macOS、Windows 三大平台。</p>
<p><code>Docker Desktop for Mac/Windows</code> 自带 <code>compose</code>，安装 Docker 之后可以直接使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker compose version</span><br><span class="line"></span><br><span class="line">Docker Compose version v2.6.0</span><br></pre></td></tr></table></figure>
<p>Linux 系统请使用以下介绍的方法安装。</p>
<h2 id="二进制包"><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85">#</a> 二进制包</h2>
<p>在 Linux 上的也安装十分简单，从 <a target="_blank" rel="noopener" href="https://github.com/docker/compose/releases">官方 GitHub Release (opens new window)</a> 处直接下载编译好的二进制文件即可。</p>
<p>例如，在 Linux 64 位系统上直接下载对应的二进制包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ DOCKER_CONFIG=/usr/local/lib/docker/cli-plugins</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p <span class="variable">$DOCKER_CONFIG</span>/cli-plugins</span><br><span class="line">$ <span class="built_in">sudo</span> curl -SL https://github.com/docker/compose/releases/download/v2.6.1/docker-compose-linux-x86_64 -o <span class="variable">$DOCKER_CONFIG</span>/cli-plugins/docker-compose</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">chmod</span> +x <span class="variable">$DOCKER_CONFIG</span>/cli-plugins</span><br><span class="line">$ docker compose version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 国内用户可以使用以下方式加快下载</span></span><br><span class="line">$ <span class="built_in">sudo</span> curl -SL https://download.fastgit.org/docker/compose/releases/download/v2.6.1/docker-compose-linux-x86_64 -o <span class="variable">$DOCKER_CONFIG</span>/cli-plugins/docker-compose</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#%E4%BD%BF%E7%94%A8">#</a> 使用</h2>
<h2 id="术语"><a href="#%E6%9C%AF%E8%AF%AD">#</a> 术语</h2>
<p>首先介绍几个术语。</p>
<ul>
<li>
<p>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</p>
</li>
<li>
<p>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。</p>
</li>
</ul>
<p>可见，一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</p>
<h2 id="场景"><a href="#%E5%9C%BA%E6%99%AF">#</a> 场景</h2>
<p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>
<p>下面我们用 <code>Python</code> 来建立一个能够记录页面访问次数的 web 网站。</p>
<h3 id="web-应用"><a href="#web-%E5%BA%94%E7%94%A8">#</a> web 应用</h3>
<p>新建文件夹，在该目录中编写 <code>app.py</code> 文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">redis = Redis(host=<span class="string">&#x27;redis&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    count = redis.incr(<span class="string">&#x27;hits&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World! 该页面已被访问 &#123;&#125; 次。\n&#x27;</span>.<span class="built_in">format</span>(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Dockerfile"><a href="#dockerfile">#</a> Dockerfile</h3>
<p>编写 <code>Dockerfile</code> 文件，内容为</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span>-alpine</span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /code</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install redis flask</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<h3 id="docker-compose-yml"><a href="#docker-compose-yml">#</a> docker-compose.yml</h3>
<p>编写 <code>docker-compose.yml</code> 文件，这个是 Compose 使用的主模板文件。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;redis:alpine&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="运行-compose-项目"><a href="#%E8%BF%90%E8%A1%8C-compose-%E9%A1%B9%E7%9B%AE">#</a> 运行 compose 项目</h3>
<p>此时访问本地 <code>5000</code> 端口，每次刷新页面，计数就会加 1。</p>
<h2 id="Compose-命令说明"><a href="#compose-%E5%91%BD%E4%BB%A4%E8%AF%B4%E6%98%8E">#</a> Compose 命令说明</h2>
<h2 id="命令对象与格式"><a href="#%E5%91%BD%E4%BB%A4%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%A0%BC%E5%BC%8F">#</a> 命令对象与格式</h2>
<p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>
<p>执行 <code>docker compose [COMMAND] --help</code> 可以查看具体某个命令的使用格式。</p>
<p><code>docker compose</code> 命令的基本的使用格式是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure>
<h2 id="命令选项"><a href="#%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9">#</a> 命令选项</h2>
<ul>
<li>
<p><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</p>
</li>
<li>
<p><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</p>
</li>
<li>
<p><code>--verbose</code> 输出更多调试信息。</p>
</li>
<li>
<p><code>-v, --version</code> 打印版本并退出。</p>
</li>
</ul>
<h2 id="命令使用说明"><a href="#%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E">#</a> 命令使用说明</h2>
<h3 id="build"><a href="#build">#</a> <code>build</code></h3>
<p>格式为 <code>docker compose build [options] [SERVICE...]</code>。</p>
<p>构建（重新构建）项目中的服务容器。</p>
<p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。</p>
<p>可以随时在项目目录下运行 <code>docker compose build</code> 来重新构建服务。</p>
<p>选项包括：</p>
<ul>
<li>
<p><code>--force-rm</code> 删除构建过程中的临时容器。</p>
</li>
<li>
<p><code>--no-cache</code> 构建镜像过程中不使用 cache（这将加长构建过程）。</p>
</li>
<li>
<p><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像。</p>
</li>
</ul>
<h3 id="config"><a href="#config">#</a> <code>config</code></h3>
<p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p>
<h3 id="down"><a href="#down">#</a> <code>down</code></h3>
<p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</p>
<h3 id="exec"><a href="#exec">#</a> <code>exec</code></h3>
<p>进入指定的容器。</p>
<h3 id="help"><a href="#help">#</a> <code>help</code></h3>
<p>获得一个命令的帮助。</p>
<h3 id="images"><a href="#images">#</a> <code>images</code></h3>
<p>列出 Compose 文件中包含的镜像。</p>
<h3 id="kill"><a href="#kill">#</a> <code>kill</code></h3>
<p>格式为 <code>docker compose kill [options] [SERVICE...]</code>。</p>
<p>通过发送 <code>SIGKILL</code> 信号来强制停止服务容器。</p>
<p>支持通过 <code>-s</code> 参数来指定发送的信号，例如通过如下指令发送 <code>SIGINT</code> 信号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker compose <span class="built_in">kill</span> -s SIGINT</span><br></pre></td></tr></table></figure>
<h3 id="logs"><a href="#logs">#</a> <code>logs</code></h3>
<p>格式为 <code>docker compose logs [options] [SERVICE...]</code>。</p>
<p>查看服务容器的输出。默认情况下，docker compose 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。</p>
<p>该命令在调试问题的时候十分有用。</p>
<h3 id="pause"><a href="#pause">#</a> <code>pause</code></h3>
<p>格式为 <code>docker compose pause [SERVICE...]</code>。</p>
<p>暂停一个服务容器。</p>
<h3 id="port"><a href="#port">#</a> <code>port</code></h3>
<p>格式为 <code>docker compose port [options] SERVICE PRIVATE_PORT</code>。</p>
<p>打印某个容器端口所映射的公共端口。</p>
<p>选项：</p>
<ul>
<li>
<p><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者 udp。</p>
</li>
<li>
<p><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</p>
</li>
</ul>
<h3 id="ps"><a href="#ps">#</a> <code>ps</code></h3>
<p>格式为 <code>docker compose ps [options] [SERVICE...]</code>。</p>
<p>列出项目中目前的所有容器。</p>
<p>选项：</p>
<ul>
<li><code>-q</code> 只打印容器的 ID 信息。</li>
</ul>
<h3 id="pull"><a href="#pull">#</a> <code>pull</code></h3>
<p>格式为 <code>docker compose pull [options] [SERVICE...]</code>。</p>
<p>拉取服务依赖的镜像。</p>
<p>选项：</p>
<ul>
<li><code>--ignore-pull-failures</code> 忽略拉取镜像过程中的错误。</li>
</ul>
<h3 id="push"><a href="#push">#</a> <code>push</code></h3>
<p>推送服务依赖的镜像到 Docker 镜像仓库。</p>
<h3 id="restart"><a href="#restart">#</a> <code>restart</code></h3>
<p>格式为 <code>docker compose restart [options] [SERVICE...]</code>。</p>
<p>重启项目中的服务。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li>
</ul>
<h3 id="rm"><a href="#rm">#</a> <code>rm</code></h3>
<p>格式为 <code>docker compose rm [options] [SERVICE...]</code>。</p>
<p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker compose stop</code> 命令来停止容器。</p>
<p>选项：</p>
<ul>
<li>
<p><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</p>
</li>
<li>
<p><code>-v</code> 删除容器所挂载的数据卷。</p>
</li>
</ul>
<h3 id="run"><a href="#run">#</a> <code>run</code></h3>
<p>格式为 <code>docker compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code>。</p>
<p>在指定服务上执行一个命令。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker compose run ubuntu ping docker.com</span><br></pre></td></tr></table></figure>
<p>将会启动一个 ubuntu 服务容器，并执行 <code>ping docker.com</code> 命令。</p>
<p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p>
<p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p>
<p>两个不同点：</p>
<ul>
<li>
<p>给定命令将会覆盖原有的自动运行命令；</p>
</li>
<li>
<p>不会自动创建端口，以避免冲突。</p>
</li>
</ul>
<p>如果不希望自动启动关联的容器，可以使用 <code>--no-deps</code> 选项，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker compose run --no-deps web python manage.py shell</span><br></pre></td></tr></table></figure>
<p>将不会启动 web 容器所关联的其它容器。</p>
<p>选项：</p>
<ul>
<li>
<p><code>-d</code> 后台运行容器。</p>
</li>
<li>
<p><code>--name NAME</code> 为容器指定一个名字。</p>
</li>
<li>
<p><code>--entrypoint CMD</code> 覆盖默认的容器启动指令。</p>
</li>
<li>
<p><code>-e KEY=VAL</code> 设置环境变量值，可多次使用选项来设置多个环境变量。</p>
</li>
<li>
<p><code>-u, --user=&quot;&quot;</code> 指定运行容器的用户名或者 uid。</p>
</li>
<li>
<p><code>--no-deps</code> 不自动启动关联的服务容器。</p>
</li>
<li>
<p><code>--rm</code> 运行命令后自动删除容器，<code>d</code> 模式下将忽略。</p>
</li>
<li>
<p><code>-p, --publish=[]</code> 映射容器端口到本地主机。</p>
</li>
<li>
<p><code>--service-ports</code> 配置服务端口并映射到本地主机。</p>
</li>
<li>
<p><code>-T</code> 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</p>
</li>
</ul>
<h3 id="start"><a href="#start">#</a> <code>start</code></h3>
<p>格式为 <code>docker compose start [SERVICE...]</code>。</p>
<p>启动已经存在的服务容器。</p>
<h3 id="stop"><a href="#stop">#</a> <code>stop</code></h3>
<p>格式为 <code>docker compose stop [options] [SERVICE...]</code>。</p>
<p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker compose start</code> 可以再次启动这些容器。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<h3 id="top"><a href="#top">#</a> <code>top</code></h3>
<p>查看各个服务容器内运行的进程。</p>
<h3 id="unpause"><a href="#unpause">#</a> <code>unpause</code></h3>
<p>格式为 <code>docker compose unpause [SERVICE...]</code>。</p>
<p>恢复处于暂停状态中的服务。</p>
<h3 id="up"><a href="#up">#</a> <code>up</code></h3>
<p>格式为 <code>docker compose up [options] [SERVICE...]</code>。</p>
<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>
<p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>
<p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>
<p>默认情况，<code>docker compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>
<p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p>
<p>如果使用 <code>docker compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>
<p>默认情况，如果服务容器已经存在，<code>docker compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p>
<p>选项：</p>
<ul>
<li>
<p><code>-d</code> 在后台运行服务容器。</p>
</li>
<li>
<p><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</p>
</li>
<li>
<p><code>--no-deps</code> 不启动服务所链接的容器。</p>
</li>
<li>
<p><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</p>
</li>
<li>
<p><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</p>
</li>
<li>
<p><code>--no-build</code> 不自动构建缺失的服务镜像。</p>
</li>
<li>
<p><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</p>
</li>
</ul>
<h3 id="version"><a href="#version">#</a> <code>version</code></h3>
<p>格式为 <code>docker compose version</code>。</p>
<p>打印版本信息。</p>
<h2 id="参考资料"><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">#</a> 参考资料</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/compose/reference/">官方文档 (opens new window)</a></li>
</ul>
<h2 id="Compose-模板文件"><a href="#compose-%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6">#</a> Compose 模板文件</h2>
<p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p>
<p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">examples/web</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/data&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p>
<p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p>
<p>下面分别介绍各个指令的用法。</p>
<h2 id="build-2"><a href="#build">#</a> <code>build</code></h2>
<p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./dir</span></span><br></pre></td></tr></table></figure>
<p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p>
<p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p>
<p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./dir</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile-alternate</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="attr">buildno:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>cache_from</code> 指定构建镜像的缓存</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">  <span class="attr">cache_from:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">alpine:latest</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">corp/web_app:3.14</span></span><br></pre></td></tr></table></figure>
<h2 id="cap-add-cap-drop"><a href="#cap-add-cap-drop">#</a> <code>cap_add, cap_drop</code></h2>
<p>指定容器的内核能力（capacity）分配。</p>
<p>例如，让容器拥有所有能力可以指定为：</p>
<p>去掉 NET_ADMIN 能力可以指定为：</p>
<h2 id="command"><a href="#command">#</a> <code>command</code></h2>
<p>覆盖容器启动后默认执行的命令。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">command:</span> <span class="string">echo</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="configs"><a href="#configs">#</a> <code>configs</code></h2>
<p>仅用于 <code>Swarm mode</code>，详细内容请查看 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/swarm_mode/"><code>Swarm mode</code></a> 一节。</p>
<h2 id="cgroup-parent"><a href="#cgroup-parent">#</a> <code>cgroup_parent</code></h2>
<p>指定父 <code>cgroup</code> 组，意味着将继承该组的资源限制。</p>
<p>例如，创建了一个 cgroup 组名称为 <code>cgroups_1</code>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cgroup_parent:</span> <span class="string">cgroups_1</span></span><br></pre></td></tr></table></figure>
<h2 id="container-name"><a href="#container-name">#</a> <code>container_name</code></h2>
<p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">container_name:</span> <span class="string">docker-web-container</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p>
</blockquote>
<h2 id="deploy"><a href="#deploy">#</a> <code>deploy</code></h2>
<p>仅用于 <code>Swarm mode</code>，详细内容请查看 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/swarm_mode/"><code>Swarm mode</code></a> 一节</p>
<h2 id="devices"><a href="#devices">#</a> <code>devices</code></h2>
<p>指定设备映射关系。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devices:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;/dev/ttyUSB1:/dev/ttyUSB0&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="depends-on"><a href="#depends-on">#</a> <code>depends_on</code></h2>
<p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p>
</blockquote>
<h2 id="dns"><a href="#dns">#</a> <code>dns</code></h2>
<p>自定义 <code>DNS</code> 服务器。可以是一个值，也可以是一个列表。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dns:</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span></span><br></pre></td></tr></table></figure>
<h2 id="dns-search"><a href="#dns-search">#</a> <code>dns_search</code></h2>
<p>配置 <code>DNS</code> 搜索域。可以是一个值，也可以是一个列表。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dns_search:</span> <span class="string">example.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dns_search:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">domain1.example.com</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">domain2.example.com</span></span><br></pre></td></tr></table></figure>
<h2 id="tmpfs"><a href="#tmpfs">#</a> <code>tmpfs</code></h2>
<p>挂载一个 tmpfs 文件系统到容器。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tmpfs:</span> <span class="string">/run</span></span><br><span class="line"><span class="attr">tmpfs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/run</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/tmp</span></span><br></pre></td></tr></table></figure>
<h2 id="env-file"><a href="#env-file">#</a> <code>env_file</code></h2>
<p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>
<p>如果通过 <code>docker compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p>
<p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">env_file: .<span class="built_in">env</span></span><br><span class="line"></span><br><span class="line">env_file:</span><br><span class="line">  - ./common.env</span><br><span class="line">  - ./apps/web.env</span><br><span class="line">  - /opt/secrets.env</span><br></pre></td></tr></table></figure>
<p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># common.env: Set development environment</span></span><br><span class="line">PROG_ENV=development</span><br></pre></td></tr></table></figure>
<h2 id="environment"><a href="#environment">#</a> <code>environment</code></h2>
<p>设置环境变量。你可以使用数组或字典两种格式。</p>
<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">RACK_ENV:</span> <span class="string">development</span></span><br><span class="line">  <span class="attr">SESSION_SECRET:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RACK_ENV=development</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SESSION_SECRET</span></span><br></pre></td></tr></table></figure>
<p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a target="_blank" rel="noopener" href="https://yaml.org/type/bool.html">布尔 (opens new window)</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y|Y|<span class="built_in">yes</span>|Yes|YES|n|N|no|No|NO|<span class="literal">true</span>|True|TRUE|<span class="literal">false</span>|False|FALSE|on|On|ON|off|Off|OFF</span><br></pre></td></tr></table></figure>
<h2 id="expose"><a href="#expose">#</a> <code>expose</code></h2>
<p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p>
<p>仅可以指定内部端口为参数</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">expose:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;3000&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;8000&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="external-links"><a href="#external-links">#</a> <code>external_links</code></h2>
<blockquote>
<p>注意：不建议使用该指令。</p>
</blockquote>
<p>链接到 <code>docker-compose.yml</code> 外部的容器，甚至并非 <code>Compose</code> 管理的外部容器。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">external_links:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">redis_1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">project_db_1:mysql</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">project_db_1:postgresql</span></span><br></pre></td></tr></table></figure>
<h2 id="extra-hosts"><a href="#extra-hosts">#</a> <code>extra_hosts</code></h2>
<p>类似 Docker 中的 <code>--add-host</code> 参数，指定额外的 host 名称映射信息。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extra_hosts:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;googledns:8.8.8.8&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;dockerhub:52.1.157.61&quot;</span></span><br></pre></td></tr></table></figure>
<p>会在启动后的服务容器中 <code>/etc/hosts</code> 文件中添加如下两条条目。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8.8.8.8 googledns</span><br><span class="line">52.1.157.61 dockerhub</span><br></pre></td></tr></table></figure>
<h2 id="healthcheck"><a href="#healthcheck">#</a> <code>healthcheck</code></h2>
<p>通过命令检查容器是否健康运行。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">healthcheck:</span></span><br><span class="line">  <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost&quot;</span>]</span><br><span class="line">  <span class="attr">interval:</span> <span class="string">1m30s</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">retries:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="image"><a href="#image">#</a> <code>image</code></h2>
<p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">orchardup/postgresql</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">a4bc65fd</span></span><br></pre></td></tr></table></figure>
<h2 id="labels"><a href="#labels">#</a> <code>labels</code></h2>
<p>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">labels:</span></span><br><span class="line">  <span class="attr">com.startupteam.description:</span> <span class="string">&quot;webapp for a startup team&quot;</span></span><br><span class="line">  <span class="attr">com.startupteam.department:</span> <span class="string">&quot;devops department&quot;</span></span><br><span class="line">  <span class="attr">com.startupteam.release:</span> <span class="string">&quot;rc3 for v1.0&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="links"><a href="#links">#</a> <code>links</code></h2>
<blockquote>
<p>注意：不推荐使用该指令。</p>
</blockquote>
<h2 id="logging"><a href="#logging">#</a> <code>logging</code></h2>
<p>配置日志选项。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">driver:</span> <span class="string">syslog</span></span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">    <span class="attr">syslog-address:</span> <span class="string">&quot;tcp://192.168.0.42:123&quot;</span></span><br></pre></td></tr></table></figure>
<p>目前支持三种日志驱动类型。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver:</span> <span class="string">&quot;json-file&quot;</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">&quot;syslog&quot;</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">&quot;none&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>options</code> 配置日志驱动的相关参数。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">options:</span></span><br><span class="line">  <span class="attr">max-size:</span> <span class="string">&quot;200k&quot;</span></span><br><span class="line">  <span class="attr">max-file:</span> <span class="string">&quot;10&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="network-mode"><a href="#network-mode">#</a> <code>network_mode</code></h2>
<p>设置网络模式。使用和 <code>docker run</code> 的 <code>--network</code> 参数一样的值。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;bridge&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;none&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;service:[service name]&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;container:[container name/id]&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="networks"><a href="#networks">#</a> <code>networks</code></h2>
<p>配置容器连接的网络。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">some-service:</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">some-network</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">other-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">some-network:</span></span><br><span class="line">  <span class="attr">other-network:</span></span><br></pre></td></tr></table></figure>
<h2 id="pid"><a href="#pid">#</a> <code>pid</code></h2>
<p>跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。</p>
<h2 id="ports"><a href="#ports">#</a> <code>ports</code></h2>
<p>暴露端口信息。</p>
<p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;3000&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;8000:8000&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;49100:22&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;127.0.0.1:8001:8001&quot;</span></span><br></pre></td></tr></table></figure>
<p><em>注意：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p>
<h2 id="secrets"><a href="#secrets">#</a> <code>secrets</code></h2>
<p>存储敏感数据，例如 <code>mysql</code> 服务密码。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.1&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mysql:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">MYSQL_ROOT_PASSWORD_FILE:</span> <span class="string">/run/secrets/db_root_password</span></span><br><span class="line">  <span class="attr">secrets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">db_root_password</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">my_other_secret</span></span><br><span class="line"></span><br><span class="line"><span class="attr">secrets:</span></span><br><span class="line">  <span class="attr">my_secret:</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">./my_secret.txt</span></span><br><span class="line">  <span class="attr">my_other_secret:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="security-opt"><a href="#security-opt">#</a> <code>security_opt</code></h2>
<p>指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">security_opt:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">label:user:USER</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">label:role:ROLE</span></span><br></pre></td></tr></table></figure>
<h2 id="stop-signal"><a href="#stop-signal">#</a> <code>stop_signal</code></h2>
<p>设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。</p>
<h2 id="sysctls"><a href="#sysctls">#</a> <code>sysctls</code></h2>
<p>配置容器内核参数。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">  <span class="attr">net.core.somaxconn:</span> <span class="number">1024</span></span><br><span class="line">  <span class="attr">net.ipv4.tcp_syncookies:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">net.core.somaxconn=1024</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">net.ipv4.tcp_syncookies=0</span></span><br></pre></td></tr></table></figure>
<h2 id="ulimits"><a href="#ulimits">#</a> <code>ulimits</code></h2>
<p>指定容器的 ulimits 限制值。</p>
<p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ulimits:</span></span><br><span class="line">  <span class="attr">nproc:</span> <span class="number">65535</span></span><br><span class="line">  <span class="attr">nofile:</span></span><br><span class="line">    <span class="attr">soft:</span> <span class="number">20000</span></span><br><span class="line">    <span class="attr">hard:</span> <span class="number">40000</span></span><br></pre></td></tr></table></figure>
<h2 id="volumes"><a href="#volumes">#</a> <code>volumes</code></h2>
<p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。</p>
<p>该指令中路径支持相对路径。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">/var/lib/mysql</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">cache/:/tmp/cache</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">~/configs:/etc/configs/:ro</span></span><br></pre></td></tr></table></figure>
<p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">my_src:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_data:/var/lib/mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql_data:</span>  </span><br></pre></td></tr></table></figure>
<h2 id="其它指令"><a href="#%E5%85%B6%E5%AE%83%E6%8C%87%E4%BB%A4">#</a> 其它指令</h2>
<p>此外，还有包括 <code>domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir</code> 等指令，基本跟 <code>docker run</code> 中对应参数的功能一致。</p>
<p>指定服务容器启动后执行的入口文件。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">entrypoint:</span> <span class="string">/code/entrypoint.sh</span></span><br></pre></td></tr></table></figure>
<p>指定容器中运行应用的用户名。</p>
<p>指定容器中工作目录。</p>
<p>指定容器中搜索域名、主机名、mac 地址等。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">domainname:</span> <span class="string">your_website.com</span></span><br><span class="line"><span class="attr">hostname:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">mac_address:</span> <span class="number">08</span><span class="number">-00</span><span class="number">-27</span><span class="number">-00</span><span class="string">-0C-0A</span></span><br></pre></td></tr></table></figure>
<p>允许容器中运行一些特权命令。</p>
<p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>。</p>
<p>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</p>
<p>打开标准输入，可以接受外部输入。</p>
<p>模拟一个伪终端。</p>
<h2 id="读取变量"><a href="#%E8%AF%BB%E5%8F%96%E5%8F%98%E9%87%8F">#</a> 读取变量</h2>
<p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 <code>.env</code> 文件中的变量。</p>
<p>例如，下面的 Compose 文件将从运行它的环境中读取变量 <code>$&#123;MONGO_VERSION&#125;</code> 的值，并写入执行的指令中。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">db:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">&quot;mongo:$&#123;MONGO_VERSION&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果执行 <code>MONGO_VERSION=3.2 docker compose up</code> 则会启动一个 <code>mongo:3.2</code> 镜像的容器；如果执行 <code>MONGO_VERSION=2.8 docker compose up</code> 则会启动一个 <code>mongo:2.8</code> 镜像的容器。</p>
<p>若当前目录存在 <code>.env</code> 文件，执行 <code>docker compose</code> 命令时将从该文件中读取变量。</p>
<p>在当前目录新建 <code>.env</code> 文件并写入以下内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 支持 # 号注释</span></span><br><span class="line">MONGO_VERSION=3.6</span><br></pre></td></tr></table></figure>
<p>执行 <code>docker compose up</code> 则会启动一个 <code>mongo:3.6</code> 镜像的容器。</p>
<h2 id="参考资料-2"><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">#</a> 参考资料</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file/">官方文档 (opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/docker/awesome-compose">awesome-compose (opens new window)</a></li>
</ul>
<h2 id="使用-Django"><a href="#%E4%BD%BF%E7%94%A8-django">#</a> 使用 Django</h2>
<blockquote>
<p>本小节内容适合 <code>Python</code> 开发人员阅读。</p>
</blockquote>
<p>我们现在将使用 <code>Docker Compose</code> 配置并运行一个 <code>Django/PostgreSQL</code> 应用。</p>
<p>在一切工作开始前，需要先编辑好三个必要的文件。</p>
<p>第一步，因为应用将要运行在一个满足所有环境依赖的 Docker 容器里面，那么我们可以通过编辑 <code>Dockerfile</code> 文件来指定 Docker 容器要安装内容。内容如下：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3</span></span><br><span class="line"><span class="keyword">ENV</span> PYTHONUNBUFFERED <span class="number">1</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /code</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt /code/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /code/</span></span><br></pre></td></tr></table></figure>
<p>以上内容指定应用将使用安装了 Python 以及必要依赖包的镜像。更多关于如何编写 <code>Dockerfile</code> 文件的信息可以查看 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/image/dockerfile/">Dockerfile 使用</a>。</p>
<p>第二步，在 <code>requirements.txt</code> 文件里面写明需要安装的具体依赖包名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Django&gt;=2.0,&lt;3.0</span><br><span class="line">psycopg2&gt;=2.7,&lt;3.0</span><br></pre></td></tr></table></figure>
<p>第三步，<code>docker-compose.yml</code> 文件将把所有的东西关联起来。它描述了应用的构成（一个 web 服务和一个数据库）、使用的 Docker 镜像、镜像之间的连接、挂载到容器的卷，以及服务开放的端口。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">&#x27;postgres&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">python</span> <span class="string">manage.py</span> <span class="string">runserver</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:8000</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.:/code</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8000:8000&quot;</span></span><br></pre></td></tr></table></figure>
<p>查看 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/compose/compose_file.html"><code>docker-compose.yml</code> 章节</a> 了解更多详细的工作机制。</p>
<p>现在我们就可以使用 <code>docker compose run</code> 命令启动一个 <code>Django</code> 应用了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker compose run web django-admin startproject django_example .</span><br></pre></td></tr></table></figure>
<p>由于 web 服务所使用的镜像并不存在，所以 Compose 会首先使用 <code>Dockerfile</code> 为 web 服务构建一个镜像，接着使用这个镜像在容器里运行 <code>django-admin startproject django_example</code> 指令。</p>
<p>这将在当前目录生成一个 <code>Django</code> 应用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">Dockerfile       docker-compose.yml          django_example       manage.py       requirements.txt</span><br></pre></td></tr></table></figure>
<p>如果你的系统是 Linux,记得更改文件权限。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">chown</span> -R <span class="variable">$USER</span>:<span class="variable">$USER</span> .</span><br></pre></td></tr></table></figure>
<p>首先，我们要为应用设置好数据库的连接信息。用以下内容替换 <code>django_example/settings.py</code> 文件中 <code>DATABASES = ...</code> 定义的节点内容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.postgresql&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;postgres&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;postgres&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;db&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PORT&#x27;</span>: <span class="number">5432</span>,</span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;postgres&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些信息是在 <a target="_blank" rel="noopener" href="https://hub.docker.com/_/postgres/">postgres (opens new window)</a> 镜像固定设置好的。然后，运行 <code>docker compose up</code> ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ docker compose up</span><br><span class="line"></span><br><span class="line">django_db_1 is up-to-date</span><br><span class="line">Creating django_web_1 ...</span><br><span class="line">Creating django_web_1 ... <span class="keyword">done</span></span><br><span class="line">Attaching to django_db_1, django_web_1</span><br><span class="line">db_1   | The files belonging to this database system will be owned by user <span class="string">&quot;postgres&quot;</span>.</span><br><span class="line">db_1   | This user must also own the server process.</span><br><span class="line">db_1   |</span><br><span class="line">db_1   | The database cluster will be initialized with locale <span class="string">&quot;en_US.utf8&quot;</span>.</span><br><span class="line">db_1   | The default database encoding has accordingly been <span class="built_in">set</span> to <span class="string">&quot;UTF8&quot;</span>.</span><br><span class="line">db_1   | The default text search configuration will be <span class="built_in">set</span> to <span class="string">&quot;english&quot;</span>.</span><br><span class="line"></span><br><span class="line">web_1  | Performing system checks...</span><br><span class="line">web_1  |</span><br><span class="line">web_1  | System check identified no issues (0 silenced).</span><br><span class="line">web_1  |</span><br><span class="line">web_1  | November 23, 2017 - 06:21:19</span><br><span class="line">web_1  | Django version 1.11.7, using settings <span class="string">&#x27;django_example.settings&#x27;</span></span><br><span class="line">web_1  | Starting development server at http://0.0.0.0:8000/</span><br><span class="line">web_1  | Quit the server with CONTROL-C.</span><br></pre></td></tr></table></figure>
<p>这个 <code>Django</code> 应用已经开始在你的 Docker 守护进程里监听着 <code>8000</code> 端口了。打开 <code>127.0.0.1:8000</code> 即可看到 <code>Django</code> 欢迎页面。</p>
<p>你还可以在 Docker 上运行其它的管理命令，例如对于同步数据库结构这种事，在运行完 <code>docker compose up</code> 后，在另外一个终端进入文件夹运行以下命令即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker compose run web python manage.py syncdb</span><br></pre></td></tr></table></figure>
<h2 id="使用-Rails"><a href="#%E4%BD%BF%E7%94%A8-rails">#</a> 使用 Rails</h2>
<blockquote>
<p>本小节内容适合 <code>Ruby</code> 开发人员阅读。</p>
</blockquote>
<p>我们现在将使用 <code>Compose</code> 配置并运行一个 <code>Rails/PostgreSQL</code> 应用。</p>
<p>在一切工作开始前，需要先设置好三个必要的文件。</p>
<p>首先，因为应用将要运行在一个满足所有环境依赖的 Docker 容器里面，那么我们可以通过编辑 <code>Dockerfile</code> 文件来指定 Docker 容器要安装内容。内容如下：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ruby</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update -qq &amp;&amp; apt-get install -y build-essential libpq-dev</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /myapp</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /myapp</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> Gemfile /myapp/Gemfile</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> bundle install</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /myapp</span></span><br></pre></td></tr></table></figure>
<p>以上内容指定应用将使用安装了 Ruby、Bundler 以及其依赖件的镜像。更多关于如何编写 Dockerfile 文件的信息可以查看 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/image/dockerfile/">Dockerfile 使用</a>。</p>
<p>下一步，我们需要一个引导加载 Rails 的文件 <code>Gemfile</code> 。 等一会儿它还会被 <code>rails new</code> 命令覆盖重写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> <span class="string">&#x27;https://rubygems.org&#x27;</span></span><br><span class="line">gem <span class="string">&#x27;rails&#x27;</span>, <span class="string">&#x27;4.0.2&#x27;</span></span><br></pre></td></tr></table></figure>
<p>最后，<code>docker-compose.yml</code> 文件才是最神奇的地方。 <code>docker-compose.yml</code> 文件将把所有的东西关联起来。它描述了应用的构成（一个 web 服务和一个数据库）、每个镜像的来源（数据库运行在使用预定义的 PostgreSQL 镜像，web 应用侧将从本地目录创建）、镜像之间的连接，以及服务开放的端口。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5432&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rackup</span> <span class="string">-p</span> <span class="number">3000</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.:/myapp</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3000:3000&quot;</span></span><br></pre></td></tr></table></figure>
<p>所有文件就绪后，我们就可以通过使用 <code>docker compose run</code> 命令生成应用的骨架了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker compose run web rails new . --force --database=postgresql --skip-bundle</span><br></pre></td></tr></table></figure>
<p><code>Compose</code> 会先使用 <code>Dockerfile</code> 为 web 服务创建一个镜像，接着使用这个镜像在容器里运行 <code>rails new</code> 和它之后的命令。一旦这个命令运行完后，应该就可以看一个崭新的应用已经生成了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">Dockerfile   app          docker-compose.yml      tmp</span><br><span class="line">Gemfile      bin          lib          vendor</span><br><span class="line">Gemfile.lock condocker-compose       <span class="built_in">log</span></span><br><span class="line">README.rdoc  condocker-compose.ru    public</span><br><span class="line">Rakefile     db           <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>在新的 <code>Gemfile</code> 文件去掉加载 <code>therubyracer</code> 的行的注释，这样我们便可以使用 Javascript 运行环境：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem <span class="string">&#x27;therubyracer&#x27;</span>, platforms: :ruby</span><br></pre></td></tr></table></figure>
<p>现在我们已经有一个新的 <code>Gemfile</code> 文件，需要再重新创建镜像。（这个会步骤会改变 Dockerfile 文件本身，所以需要重建一次）。</p>
<p>应用现在就可以启动了，但配置还未完成。Rails 默认读取的数据库目标是 <code>localhost</code> ，我们需要手动指定容器的 <code>db</code> 。同样的，还需要把用户名修改成和 postgres 镜像预定的一致。 打开最新生成的 <code>database.yml</code> 文件。用以下内容替换：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">development: &amp;default</span><br><span class="line">  adapter: postgresql</span><br><span class="line">  encoding: unicode</span><br><span class="line">  database: postgres</span><br><span class="line">  pool: 5</span><br><span class="line">  username: postgres</span><br><span class="line">  password:</span><br><span class="line">  host: db</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>:</span><br><span class="line">  &lt;&lt;: *default</span><br><span class="line">  database: myapp_test</span><br></pre></td></tr></table></figure>
<p>现在就可以启动应用了。</p>
<p>如果一切正常，你应该可以看到 PostgreSQL 的输出，几秒后可以看到这样的重复信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myapp_web_1 | [2014-01-17 17:16:29] INFO  WEBrick 1.3.1</span><br><span class="line">myapp_web_1 | [2014-01-17 17:16:29] INFO  ruby 2.0.0 (2013-11-22) [x86_64-linux-gnu]</span><br><span class="line">myapp_web_1 | [2014-01-17 17:16:29] INFO  WEBrick::HTTPServer#start: pid=1 port=3000</span><br></pre></td></tr></table></figure>
<p>最后， 我们需要做的是创建数据库，打开另一个终端，运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker compose run web rake db:create</span><br></pre></td></tr></table></figure>
<p>这个 web 应用已经开始在你的 docker 守护进程里面监听着 3000 端口了。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2018/04/21/docker/Docker%20Compose/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2018/04/20/docker/Kubernetes/"
                            aria-label=": Kubernetes"
                        >
                            Kubernetes
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-20T16:02:39+08:00">
	
		    2018 年 4 月 20 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../categories/devops/">devops</a>, <a class="category-link" href="../../categories/devops/Docker/">Docker</a>, <a class="category-link" href="../../categories/devops/Docker/Kubernetes/">Kubernetes</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="项目简介"><a href="#%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B">#</a> 项目简介</h2>
<p><img src="https://vuepress.mirror.docker-practice.com/assets/img/kubernetes_logo.328f5ccb.png" alt=""></p>
<p>Kubernetes 是 Google 团队发起的开源项目，它的目标是管理跨多个主机的容器，提供基本的部署，维护以及应用伸缩，主要实现语言为 Go 语言。Kubernetes 是：</p>
<ul>
<li>易学：轻量级，简单，容易理解</li>
<li>便携：支持公有云，私有云，混合云，以及多种云平台</li>
<li>可拓展：模块化，可插拔，支持钩子，可任意组合</li>
<li>自修复：自动重调度，自动重启，自动复制</li>
</ul>
<p>Kubernetes 构建于 Google 数十年经验，一大半来源于 Google 生产环境规模的经验。结合了社区最佳的想法和实践。</p>
<p>在分布式系统中，部署，调度，伸缩一直是最为重要的也最为基础的功能。Kubernetes 就是希望解决这一序列问题的。</p>
<p>Kubernetes 目前在<a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes">GitHub (opens new window)</a>进行维护。</p>
<h3 id="Kubernetes-能够运行在任何地方！"><a href="#kubernetes-%E8%83%BD%E5%A4%9F%E8%BF%90%E8%A1%8C%E5%9C%A8%E4%BB%BB%E4%BD%95%E5%9C%B0%E6%96%B9">#</a> Kubernetes 能够运行在任何地方！</h3>
<p>虽然 Kubernetes 最初是为 GCE 定制的，但是在后续版本中陆续增加了其他云平台的支持，以及本地数据中心的支持。</p>
<h2 id="基本概念"><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">#</a> 基本概念</h2>
<p><img src="https://vuepress.mirror.docker-practice.com/assets/img/kubernetes_design.94f04f39.jpg" alt=""></p>
<ul>
<li>节点（<code>Node</code>）：一个节点是一个运行 Kubernetes 中的主机。</li>
<li>容器组（<code>Pod</code>）：一个 Pod 对应于由若干容器组成的一个容器组，同个组内的容器共享一个存储卷(volume)。</li>
<li>容器组生命周期（<code>pos-states</code>）：包含所有容器状态集合，包括容器组状态类型，容器组生命周期，事件，重启策略，以及 replication controllers。</li>
<li>Replication Controllers：主要负责指定数量的 pod 在同一时间一起运行。</li>
<li>服务（<code>services</code>）：一个 Kubernetes 服务是容器组逻辑的高级抽象，同时也对外提供访问容器组的策略。</li>
<li>卷（<code>volumes</code>）：一个卷就是一个目录，容器对其有访问权限。</li>
<li>标签（<code>labels</code>）：标签是用来连接一组对象的，比如容器组。标签可以被用来组织和选择子对象。</li>
<li>接口权限（<code>accessing_the_api</code>）：端口，IP 地址和代理的防火墙规则。</li>
<li>web 界面（<code>ux</code>）：用户可以通过 web 界面操作 Kubernetes。</li>
<li>命令行操作（<code>cli</code>）：<code>kubectl</code>命令。</li>
</ul>
<h2 id="节点"><a href="#%E8%8A%82%E7%82%B9">#</a> 节点</h2>
<p>在 <code>Kubernetes</code> 中，节点是实际工作的点，节点可以是虚拟机或者物理机器，依赖于一个集群环境。每个节点都有一些必要的服务以运行容器组，并且它们都可以通过主节点来管理。必要服务包括 Docker，kubelet 和代理服务。</p>
<h3 id="容器状态"><a href="#%E5%AE%B9%E5%99%A8%E7%8A%B6%E6%80%81">#</a> 容器状态</h3>
<p>容器状态用来描述节点的当前状态。现在，其中包含三个信息：</p>
<h4 id="主机IP"><a href="#%E4%B8%BB%E6%9C%BAip">#</a> 主机IP</h4>
<p>主机 IP 需要云平台来查询，<code>Kubernetes</code> 把它作为状态的一部分来保存。如果 <code>Kubernetes</code> 没有运行在云平台上，节点 ID 就是必需的。IP 地址可以变化，并且可以包含多种类型的 IP 地址，如公共 IP，私有 IP，动态 IP，ipv6 等等。</p>
<h4 id="节点周期"><a href="#%E8%8A%82%E7%82%B9%E5%91%A8%E6%9C%9F">#</a> 节点周期</h4>
<p>通常来说节点有 <code>Pending</code>，<code>Running</code>，<code>Terminated</code> 三个周期，如果 Kubernetes 发现了一个节点并且其可用，那么 Kubernetes 就把它标记为 <code>Pending</code>。然后在某个时刻，Kubernetes 将会标记其为 <code>Running</code>。节点的结束周期称为 <code>Terminated</code>。一个已经 <code>Terminated</code> 的节点不会接受和调度任何请求，并且已经在其上运行的容器组也会删除。</p>
<h4 id="节点状态"><a href="#%E8%8A%82%E7%82%B9%E7%8A%B6%E6%80%81">#</a> 节点状态</h4>
<p>节点的状态主要是用来描述处于 <code>Running</code> 的节点。当前可用的有 <code>NodeReachable</code> 和 <code>NodeReady</code>。以后可能会增加其他状态。<code>NodeReachable</code> 表示集群可达。<code>NodeReady</code> 表示 kubelet 返回 Status Ok 并且 HTTP 状态检查健康。</p>
<h3 id="节点管理"><a href="#%E8%8A%82%E7%82%B9%E7%AE%A1%E7%90%86">#</a> 节点管理</h3>
<p>节点并非 Kubernetes 创建，而是由云平台创建，或者就是物理机器、虚拟机。在 Kubernetes 中，节点仅仅是一条记录，节点创建之后，Kubernetes 会检查其是否可用。在 Kubernetes 中，节点用如下结构保存：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.1.2.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Minion&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;apiVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;v1beta1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;resources&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;capacity&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;cpu&quot;</span><span class="punctuation">:</span> <span class="number">1000</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;memory&quot;</span><span class="punctuation">:</span> <span class="number">1073741824</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-first-k8s-node&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>Kubernetes 校验节点可用依赖于 ID。在当前的版本中，有两个接口可以用来管理节点：节点控制和 Kube 管理。</p>
<h3 id="节点控制"><a href="#%E8%8A%82%E7%82%B9%E6%8E%A7%E5%88%B6">#</a> 节点控制</h3>
<p>在 Kubernetes 主节点中，节点控制器是用来管理节点的组件。主要包含：</p>
<ul>
<li>集群范围内节点同步</li>
<li>单节点生命周期管理</li>
</ul>
<p>节点控制有一个同步轮寻，主要监听所有云平台的虚拟实例，会根据节点状态创建和删除。可以通过 <code>--node_sync_period</code>标志来控制该轮寻。如果一个实例已经创建，节点控制将会为其创建一个结构。同样的，如果一个节点被删除，节点控制也会删除该结构。在 Kubernetes 启动时可用通过 <code>--machines</code>标记来显示指定节点。同样可以使用 <code>kubectl</code> 来一条一条的添加节点，两者是相同的。通过设置 <code>--sync_nodes=false</code>标记来禁止集群之间的节点同步，你也可以使用 api/kubectl 命令行来增删节点。</p>
<h2 id="容器组"><a href="#%E5%AE%B9%E5%99%A8%E7%BB%84">#</a> 容器组</h2>
<p>在 Kubernetes 中，使用的最小单位是容器组，容器组是创建，调度，管理的最小单位。 一个容器组使用相同的 Docker 容器并共享卷（挂载点）。一个容器组是一个特定应用的打包集合，包含一个或多个容器。</p>
<p>和运行的容器类似，一个容器组被认为只有很短的运行周期。容器组被调度到一组节点运行，直到容器的生命周期结束或者其被删除。如果节点死掉，运行在其上的容器组将会被删除而不是重新调度。（也许在将来的版本中会添加容器组的移动）。</p>
<h3 id="容器组设计的初衷"><a href="#%E5%AE%B9%E5%99%A8%E7%BB%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%88%9D%E8%A1%B7">#</a> 容器组设计的初衷</h3>
<h3 id="资源共享和通信"><a href="#%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E5%92%8C%E9%80%9A%E4%BF%A1">#</a> 资源共享和通信</h3>
<p>容器组主要是为了数据共享和它们之间的通信。</p>
<p>在一个容器组中，容器都使用相同的网络地址和端口，可以通过本地网络来相互通信。每个容器组都有独立的 IP，可用通过网络来和其他物理主机或者容器通信。</p>
<p>容器组有一组存储卷（挂载点），主要是为了让容器在重启之后可以不丢失数据。</p>
<h3 id="容器组管理"><a href="#%E5%AE%B9%E5%99%A8%E7%BB%84%E7%AE%A1%E7%90%86">#</a> 容器组管理</h3>
<p>容器组是一个应用管理和部署的高层次抽象，同时也是一组容器的接口。容器组是部署、水平放缩的最小单位。</p>
<h3 id="容器组的使用"><a href="#%E5%AE%B9%E5%99%A8%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8">#</a> 容器组的使用</h3>
<p>容器组可以通过组合来构建复杂的应用，其本来的意义包含：</p>
<ul>
<li>内容管理，文件和数据加载以及本地缓存管理等。</li>
<li>日志和检查点备份，压缩，快照等。</li>
<li>监听数据变化，跟踪日志，日志和监控代理，消息发布等。</li>
<li>代理，网桥</li>
<li>控制器，管理，配置以及更新</li>
</ul>
<h3 id="替代方案"><a href="#%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88">#</a> 替代方案</h3>
<p>为什么不在一个单一的容器里运行多个程序？</p>
<ul>
<li>1.透明化。为了使容器组中的容器保持一致的基础设施和服务，比如进程管理和资源监控。这样设计是为了用户的便利性。</li>
<li>2.解偶软件之间的依赖。每个容器都可能重新构建和发布，Kubernetes 必须支持热发布和热更新（将来）。</li>
<li>3.方便使用。用户不必运行独立的程序管理，也不用担心每个应用程序的退出状态。</li>
<li>4.高效。考虑到基础设施有更多的职责，容器必须要轻量化。</li>
</ul>
<h3 id="容器组的生命状态"><a href="#%E5%AE%B9%E5%99%A8%E7%BB%84%E7%9A%84%E7%94%9F%E5%91%BD%E7%8A%B6%E6%80%81">#</a> 容器组的生命状态</h3>
<p>包括若干状态值：<code>pending</code>、<code>running</code>、<code>succeeded</code>、<code>failed</code>。</p>
<h4 id="pending"><a href="#pending">#</a> pending</h4>
<p>容器组已经被节点接受，但有一个或多个容器还没有运行起来。这将包含某些节点正在下载镜像的时间，这种情形会依赖于网络情况。</p>
<h4 id="running"><a href="#running">#</a> running</h4>
<p>容器组已经被调度到节点，并且所有的容器都已经启动。至少有一个容器处于运行状态（或者处于重启状态）。</p>
<h4 id="succeeded"><a href="#succeeded">#</a> succeeded</h4>
<p>所有的容器都正常退出。</p>
<h4 id="failed"><a href="#failed">#</a> failed</h4>
<p>容器组中所有容器都意外中断了。</p>
<h3 id="容器组生命周期"><a href="#%E5%AE%B9%E5%99%A8%E7%BB%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">#</a> 容器组生命周期</h3>
<p>通常来说，如果容器组被创建了就不会自动销毁，除非被某种行为触发，而触发此种情况可能是人为，或者复制控制器所为。唯一例外的是容器组由 succeeded 状态成功退出，或者在一定时间内重试多次依然失败。</p>
<p>如果某个节点死掉或者不能连接，那么节点控制器将会标记其上的容器组的状态为 <code>failed</code>。</p>
<p>举例如下。</p>
<ul>
<li>容器组状态 <code>running</code>，有 1 容器，容器正常退出
<ul>
<li>记录完成事件</li>
<li>如果重启策略为：
<ul>
<li>始终：重启容器，容器组保持 <code>running</code></li>
<li>失败时：容器组变为 <code>succeeded</code></li>
<li>从不：容器组变为 <code>succeeded</code></li>
</ul>
</li>
</ul>
</li>
<li>容器组状态 <code>running</code>，有1容器，容器异常退出
<ul>
<li>记录失败事件</li>
<li>如果重启策略为：
<ul>
<li>始终：重启容器，容器组保持 <code>running</code></li>
<li>失败时：重启容器，容器组保持 <code>running</code></li>
<li>从不：容器组变为 <code>failed</code></li>
</ul>
</li>
</ul>
</li>
<li>容器组状态 <code>running</code>，有2容器，有1容器异常退出
<ul>
<li>记录失败事件</li>
<li>如果重启策略为：
<ul>
<li>始终：重启容器，容器组保持 <code>running</code></li>
<li>失败时：重启容器，容器组保持 <code>running</code></li>
<li>从不：容器组保持 <code>running</code></li>
</ul>
</li>
<li>当有2容器退出
<ul>
<li>记录失败事件</li>
<li>如果重启策略为：
<ul>
<li>始终：重启容器，容器组保持 <code>running</code></li>
<li>失败时：重启容器，容器组保持 <code>running</code></li>
<li>从不：容器组变为 <code>failed</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>容器组状态 <code>running</code>，容器内存不足
<ul>
<li>标记容器错误中断</li>
<li>记录内存不足事件</li>
<li>如果重启策略为：
<ul>
<li>始终：重启容器，容器组保持 <code>running</code></li>
<li>失败时：重启容器，容器组保持 <code>running</code></li>
<li>从不：记录错误事件，容器组变为 <code>failed</code></li>
</ul>
</li>
</ul>
</li>
<li>容器组状态 <code>running</code>，一块磁盘死掉
<ul>
<li>杀死所有容器</li>
<li>记录事件</li>
<li>容器组变为 <code>failed</code></li>
<li>如果容器组运行在一个控制器下，容器组将会在其他地方重新创建</li>
</ul>
</li>
<li>容器组状态 <code>running</code>，对应的节点段溢出
<ul>
<li>节点控制器等到超时</li>
<li>节点控制器标记容器组 <code>failed</code></li>
<li>如果容器组运行在一个控制器下，容器组将会在其他地方重新创建</li>
</ul>
</li>
</ul>
<h2 id="Replication-Controllers"><a href="#replication-controllers">#</a> Replication Controllers</h2>
<h2 id="服务"><a href="#%E6%9C%8D%E5%8A%A1">#</a> 服务</h2>
<h2 id="卷"><a href="#%E5%8D%B7">#</a> 卷</h2>
<h2 id="标签"><a href="#%E6%A0%87%E7%AD%BE">#</a> 标签</h2>
<h2 id="接口权限"><a href="#%E6%8E%A5%E5%8F%A3%E6%9D%83%E9%99%90">#</a> 接口权限</h2>
<h2 id="web界面"><a href="#web%E7%95%8C%E9%9D%A2">#</a> web界面</h2>
<h2 id="命令行操作"><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C">#</a> 命令行操作</h2>
<h2 id="基本架构"><a href="#%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84">#</a> 基本架构</h2>
<p>任何优秀的项目都离不开优秀的架构设计。本小节将介绍 Kubernetes 在架构方面的设计考虑。</p>
<h2 id="基本考虑"><a href="#%E5%9F%BA%E6%9C%AC%E8%80%83%E8%99%91">#</a> 基本考虑</h2>
<p>如果让我们自己从头设计一套容器管理平台，有如下几个方面是很容易想到的：</p>
<ul>
<li>分布式架构，保证扩展性；</li>
<li>逻辑集中式的控制平面 + 物理分布式的运行平面；</li>
<li>一套资源调度系统，管理哪个容器该分配到哪个节点上；</li>
<li>一套对容器内服务进行抽象和 HA 的系统。</li>
</ul>
<h2 id="运行原理"><a href="#%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86">#</a> 运行原理</h2>
<p>下面这张图完整展示了 Kubernetes 的运行原理。</p>
<p><img src="https://vuepress.mirror.docker-practice.com/assets/img/k8s_architecture.1cde0882.png" alt="Kubernetes 架构"></p>
<p>可见，Kubernetes 首先是一套分布式系统，由多个节点组成，节点分为两类：一类是属于管理平面的主节点/控制节点（Master Node）；一类是属于运行平面的工作节点（Worker Node）。</p>
<p>显然，复杂的工作肯定都交给控制节点去做了，工作节点负责提供稳定的操作接口和能力抽象即可。</p>
<p>从这张图上，我们没有能发现 Kubernetes 中对于控制平面的分布式实现，但是由于数据后端自身就是一套分布式的数据库 Etcd，因此可以很容易扩展到分布式实现。</p>
<h2 id="控制平面"><a href="#%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2">#</a> 控制平面</h2>
<h3 id="主节点服务"><a href="#%E4%B8%BB%E8%8A%82%E7%82%B9%E6%9C%8D%E5%8A%A1">#</a> 主节点服务</h3>
<p>主节点上需要提供如下的管理服务：</p>
<ul>
<li><code>apiserver</code> 是整个系统的对外接口，提供一套 RESTful 的 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/overview/kubernetes-api/">Kubernetes API (opens new window)</a>，供客户端和其它组件调用；</li>
<li><code>scheduler</code> 负责对资源进行调度，分配某个 pod 到某个节点上。是 pluggable 的，意味着很容易选择其它实现方式；</li>
<li><code>controller-manager</code> 负责管理控制器，包括 endpoint-controller（刷新服务和 pod 的关联信息）和 replication-controller（维护某个 pod 的复制为配置的数值）。</li>
</ul>
<h3 id="Etcd"><a href="#etcd">#</a> Etcd</h3>
<p>这里 Etcd 即作为数据后端，又作为消息中间件。</p>
<p>通过 Etcd 来存储所有的主节点上的状态信息，很容易实现主节点的分布式扩展。</p>
<p>组件可以自动的去侦测 Etcd 中的数值变化来获得通知，并且获得更新后的数据来执行相应的操作。</p>
<h2 id="工作节点"><a href="#%E5%B7%A5%E4%BD%9C%E8%8A%82%E7%82%B9">#</a> 工作节点</h2>
<ul>
<li>kubelet 是工作节点执行操作的 agent，负责具体的容器生命周期管理，根据从数据库中获取的信息来管理容器，并上报 pod 运行状态等；</li>
<li>kube-proxy 是一个简单的网络访问代理，同时也是一个 Load Balancer。它负责将访问到某个服务的请求具体分配给工作节点上的 Pod（同一类标签）。</li>
</ul>
<p><img src="https://vuepress.mirror.docker-practice.com/assets/img/kube-proxy.e356ec8f.png" alt="Proxy 代理对服务的请求"></p>
<p><a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/">Docker 从入门到实践</a></p>
<p><a target="_blank" rel="noopener" href="https://docker_practice.gitee.io/pic/dpsig-wechat.jpg">微信交流群 (opens new window)</a></p>
<p><a target="_blank" rel="noopener" href="https://docker_practice.gitee.io/pic/dp-wechat-miniprogram.jpg">小程序 (opens new window)</a></p>
<p><a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/install/">安装 Docker</a></p>
<p><a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/">Docker 入门</a></p>
<p><a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/cases/os/">Docker 实战</a></p>
<p><a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/cases/ci/">CI/CD</a></p>
<p><a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/compose/">Compose</a></p>
<p><a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/kubernetes/">Kubernetes</a></p>
<p><a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/cloud/">云计算</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/act/cps/redirect?redirect=1062&amp;cps_key=3a5255852d5db99dcd5da4c72f05df61&amp;from=console">云服务器99/元首年特惠 (opens new window)</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice">GitHub (opens new window)</a></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/kubernetes/">Kubernetes</a></li>
<li><a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/kubernetes/setup/">部署 Kubernetes</a></li>
</ol>
<h2 id="部署-Kubernetes">部署 Kubernetes</h2>
<p>小于 1 分钟 约 102 字</p>
<hr>
<h2 id="部署-Kubernetes-2"><a href="#%E9%83%A8%E7%BD%B2-kubernetes">#</a> 部署 Kubernetes</h2>
<p>目前，Kubernetes 支持在多种环境下使用，包括本地主机（Ubuntu、Debian、CentOS、Fedora 等）、云服务（<a target="_blank" rel="noopener" href="https://cloud.tencent.com/act/cps/redirect?redirect=10058&amp;cps_key=3a5255852d5db99dcd5da4c72f05df61">腾讯云 (opens new window)</a>、<a target="_blank" rel="noopener" href="https://www.aliyun.com/product/kubernetes?source=5176.11533457&amp;userCode=8lx5zmtu&amp;type=copy">阿里云 (opens new window)</a>、<a target="_blank" rel="noopener" href="https://cloud.baidu.com/product/cce.html">百度云 (opens new window)</a> 等）。</p>
<p>你可以使用以下几种方式部署 Kubernetes：</p>
<ul>
<li>kubeadm</li>
<li>docker-desktop</li>
<li>k3s</li>
</ul>
<p>接下来的小节会对以上几种方式进行详细介绍。</p>
<p><a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/kubernetes/design/">基本架构</a> <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/kubernetes/setup/kubeadm/">使用 kubeadm 部署 kubernetes(CRI 使用 containerd)</a></p>
<h2 id="使用-kubeadm-部署-kubernetes-CRI-使用-containerd"><a href="#%E4%BD%BF%E7%94%A8-kubeadm-%E9%83%A8%E7%BD%B2-kubernetes-cri-%E4%BD%BF%E7%94%A8-containerd">#</a> 使用 kubeadm 部署 kubernetes(CRI 使用 containerd)</h2>
<p><code>kubeadm</code> 提供了 <code>kubeadm init</code> 以及 <code>kubeadm join</code> 这两个命令作为快速创建 <code>kubernetes</code> 集群的最佳实践。</p>
<h2 id="安装-containerd"><a href="#%E5%AE%89%E8%A3%85-containerd">#</a> 安装 containerd</h2>
<p>参考 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/kubernetes/install">安装 Docker</a> 一节添加 apt/yum 源，之后执行如下命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># debian 系</span></span><br><span class="line">$ <span class="built_in">sudo</span> apt install containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># rhel 系</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum install containerd.io</span><br></pre></td></tr></table></figure>
<h2 id="配置-containerd"><a href="#%E9%85%8D%E7%BD%AE-containerd">#</a> 配置 containerd</h2>
<p>新建 <code>/etc/systemd/system/cri-containerd.service</code> 文件</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=containerd container runtime for kubernetes</span><br><span class="line">Documentation=https://containerd.io</span><br><span class="line">After=network.target local-fs.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStartPre=-/sbin/modprobe overlay</span><br><span class="line">ExecStart=/usr/bin/containerd --config //etc/cri-containerd/config.toml</span><br><span class="line"></span><br><span class="line">Type=notify</span><br><span class="line">Delegate=yes</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=5</span><br><span class="line"># Having non-zero Limit*s causes performance problems due to accounting overhead</span><br><span class="line"># in the kernel. We recommend using cgroups to do container-local accounting.</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line"># Comment TasksMax if your systemd version does not supports it.</span><br><span class="line"># Only systemd 226 and above support this version.</span><br><span class="line">TasksMax=infinity</span><br><span class="line">OOMScoreAdjust=-999</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>新建 <code>/etc/cri-containerd/config.toml</code> containerd 配置文件</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version</span> = <span class="number">2</span></span><br><span class="line"><span class="comment"># persistent data location</span></span><br><span class="line"><span class="attr">root</span> = <span class="string">&quot;/var/lib/cri-containerd&quot;</span></span><br><span class="line"><span class="comment"># runtime state information</span></span><br><span class="line"><span class="attr">state</span> = <span class="string">&quot;/run/cri-containerd&quot;</span></span><br><span class="line"><span class="attr">plugin_dir</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">disabled_plugins</span> = []</span><br><span class="line"><span class="attr">required_plugins</span> = []</span><br><span class="line"><span class="comment"># set containerd&#x27;s OOM score</span></span><br><span class="line"><span class="attr">oom_score</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[grpc]</span></span><br><span class="line">  <span class="attr">address</span> = <span class="string">&quot;/run/cri-containerd/cri-containerd.sock&quot;</span></span><br><span class="line">  <span class="attr">tcp_address</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">tcp_tls_cert</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">tcp_tls_key</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="comment"># socket uid</span></span><br><span class="line">  <span class="attr">uid</span> = <span class="number">0</span></span><br><span class="line">  <span class="comment"># socket gid</span></span><br><span class="line">  <span class="attr">gid</span> = <span class="number">0</span></span><br><span class="line">  <span class="attr">max_recv_message_size</span> = <span class="number">16777216</span></span><br><span class="line">  <span class="attr">max_send_message_size</span> = <span class="number">16777216</span></span><br><span class="line"></span><br><span class="line"><span class="section">[debug]</span></span><br><span class="line">  <span class="attr">address</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">format</span> = <span class="string">&quot;json&quot;</span></span><br><span class="line">  <span class="attr">uid</span> = <span class="number">0</span></span><br><span class="line">  <span class="attr">gid</span> = <span class="number">0</span></span><br><span class="line">  <span class="attr">level</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[metrics]</span></span><br><span class="line">  <span class="attr">address</span> = <span class="string">&quot;127.0.0.1:1338&quot;</span></span><br><span class="line">  <span class="attr">grpc_histogram</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="section">[cgroup]</span></span><br><span class="line">  <span class="attr">path</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[timeouts]</span></span><br><span class="line">  <span class="attr">&quot;io.containerd.timeout.shim.cleanup&quot;</span> = <span class="string">&quot;5s&quot;</span></span><br><span class="line">  <span class="attr">&quot;io.containerd.timeout.shim.load&quot;</span> = <span class="string">&quot;5s&quot;</span></span><br><span class="line">  <span class="attr">&quot;io.containerd.timeout.shim.shutdown&quot;</span> = <span class="string">&quot;3s&quot;</span></span><br><span class="line">  <span class="attr">&quot;io.containerd.timeout.task.state&quot;</span> = <span class="string">&quot;2s&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[plugins]</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.gc.v1.scheduler&quot;]</span></span><br><span class="line">    <span class="attr">pause_threshold</span> = <span class="number">0.02</span></span><br><span class="line">    <span class="attr">deletion_threshold</span> = <span class="number">0</span></span><br><span class="line">    <span class="attr">mutation_threshold</span> = <span class="number">100</span></span><br><span class="line">    <span class="attr">schedule_delay</span> = <span class="string">&quot;0s&quot;</span></span><br><span class="line">    <span class="attr">startup_delay</span> = <span class="string">&quot;100ms&quot;</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span></span><br><span class="line">    <span class="attr">disable_tcp_service</span> = <span class="literal">true</span></span><br><span class="line">    <span class="attr">stream_server_address</span> = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    <span class="attr">stream_server_port</span> = <span class="string">&quot;0&quot;</span></span><br><span class="line">    <span class="attr">stream_idle_timeout</span> = <span class="string">&quot;4h0m0s&quot;</span></span><br><span class="line">    <span class="attr">enable_selinux</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">selinux_category_range</span> = <span class="number">1024</span></span><br><span class="line">    <span class="attr">sandbox_image</span> = <span class="string">&quot;registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.5&quot;</span></span><br><span class="line">    <span class="attr">stats_collect_period</span> = <span class="number">10</span></span><br><span class="line">    <span class="comment"># systemd_cgroup = false</span></span><br><span class="line">    <span class="attr">enable_tls_streaming</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">max_container_log_line_size</span> = <span class="number">16384</span></span><br><span class="line">    <span class="attr">disable_cgroup</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">disable_apparmor</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">restrict_oom_score_adj</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">max_concurrent_downloads</span> = <span class="number">3</span></span><br><span class="line">    <span class="attr">disable_proc_mount</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">unset_seccomp_profile</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">tolerate_missing_hugetlb_controller</span> = <span class="literal">true</span></span><br><span class="line">    <span class="attr">disable_hugetlb_controller</span> = <span class="literal">true</span></span><br><span class="line">    <span class="attr">ignore_image_defined_volumes</span> = <span class="literal">false</span></span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd]</span></span><br><span class="line">      <span class="attr">snapshotter</span> = <span class="string">&quot;overlayfs&quot;</span></span><br><span class="line">      <span class="attr">default_runtime_name</span> = <span class="string">&quot;runc&quot;</span></span><br><span class="line">      <span class="attr">no_pivot</span> = <span class="literal">false</span></span><br><span class="line">      <span class="attr">disable_snapshot_annotations</span> = <span class="literal">false</span></span><br><span class="line">      <span class="attr">discard_unpacked_layers</span> = <span class="literal">false</span></span><br><span class="line">      <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes]</span></span><br><span class="line">        <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]</span></span><br><span class="line">          <span class="attr">runtime_type</span> = <span class="string">&quot;io.containerd.runc.v2&quot;</span></span><br><span class="line">          <span class="attr">pod_annotations</span> = []</span><br><span class="line">          <span class="attr">container_annotations</span> = []</span><br><span class="line">          <span class="attr">privileged_without_host_devices</span> = <span class="literal">false</span></span><br><span class="line">          <span class="attr">base_runtime_spec</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">          <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]</span></span><br><span class="line">            <span class="comment"># SystemdCgroup enables systemd cgroups.</span></span><br><span class="line">            <span class="attr">SystemdCgroup</span> = <span class="literal">true</span></span><br><span class="line">            <span class="comment"># BinaryName is the binary name of the runc binary.</span></span><br><span class="line">            <span class="comment"># BinaryName = &quot;runc&quot;</span></span><br><span class="line">            <span class="comment"># BinaryName = &quot;crun&quot;</span></span><br><span class="line">            <span class="comment"># NoPivotRoot disables pivot root when creating a container.</span></span><br><span class="line">            <span class="comment"># NoPivotRoot = false</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># NoNewKeyring disables new keyring for the container.</span></span><br><span class="line">            <span class="comment"># NoNewKeyring = false</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># ShimCgroup places the shim in a cgroup.</span></span><br><span class="line">            <span class="comment"># ShimCgroup = &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># IoUid sets the I/O&#x27;s pipes uid.</span></span><br><span class="line">            <span class="comment"># IoUid = 0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># IoGid sets the I/O&#x27;s pipes gid.</span></span><br><span class="line">            <span class="comment"># IoGid = 0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Root is the runc root directory.</span></span><br><span class="line">            <span class="attr">Root</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># CriuPath is the criu binary path.</span></span><br><span class="line">            <span class="comment"># CriuPath = &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># CriuImagePath is the criu image path</span></span><br><span class="line">            <span class="comment"># CriuImagePath = &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># CriuWorkPath is the criu work path.</span></span><br><span class="line">            <span class="comment"># CriuWorkPath = &quot;&quot;</span></span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.cni]</span></span><br><span class="line">      <span class="attr">bin_dir</span> = <span class="string">&quot;/opt/cni/bin&quot;</span></span><br><span class="line">      <span class="attr">conf_dir</span> = <span class="string">&quot;/etc/cni/net.d&quot;</span></span><br><span class="line">      <span class="attr">max_conf_num</span> = <span class="number">1</span></span><br><span class="line">      <span class="attr">conf_template</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry]</span></span><br><span class="line">      <span class="attr">config_path</span> = <span class="string">&quot;/etc/cri-containerd/certs.d&quot;</span></span><br><span class="line">      <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.headers]</span></span><br><span class="line">        <span class="comment"># Foo = [&quot;bar&quot;]</span></span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.image_decryption]</span></span><br><span class="line">      <span class="attr">key_model</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.x509_key_pair_streaming]</span></span><br><span class="line">      <span class="attr">tls_cert_file</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attr">tls_key_file</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.internal.v1.opt&quot;]</span></span><br><span class="line">    <span class="attr">path</span> = <span class="string">&quot;/opt/cri-containerd&quot;</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.internal.v1.restart&quot;]</span></span><br><span class="line">    <span class="attr">interval</span> = <span class="string">&quot;10s&quot;</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.metadata.v1.bolt&quot;]</span></span><br><span class="line">    <span class="attr">content_sharing_policy</span> = <span class="string">&quot;shared&quot;</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.monitor.v1.cgroups&quot;]</span></span><br><span class="line">    <span class="attr">no_prometheus</span> = <span class="literal">false</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.runtime.v2.task&quot;]</span></span><br><span class="line">    <span class="attr">platforms</span> = [<span class="string">&quot;linux/amd64&quot;</span>]</span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.service.v1.diff-service&quot;]</span></span><br><span class="line">    <span class="attr">default</span> = [<span class="string">&quot;walking&quot;</span>]</span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.snapshotter.v1.devmapper&quot;]</span></span><br><span class="line">    <span class="attr">root_path</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">pool_name</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">base_image_size</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">async_remove</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="安装-kubelet-kubeadm-kubectl-cri-tools-kubernetes-cni"><a href="#%E5%AE%89%E8%A3%85-kubelet-kubeadm-kubectl-cri-tools-kubernetes-cni">#</a> 安装 <strong>kubelet</strong> <strong>kubeadm</strong> <strong>kubectl</strong> <strong>cri-tools</strong> <strong>kubernetes-cni</strong></h2>
<h3 id="Ubuntu-Debian"><a href="#ubuntu-debian">#</a> Ubuntu/Debian</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get update &amp;&amp; apt-get install -y apt-transport-https</span><br><span class="line">$ curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list</span></span><br><span class="line"><span class="string">deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">$ apt-get update</span><br><span class="line">$ apt-get install -y kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure>
<h3 id="CentOS-Fedora"><a href="#centos-fedora">#</a> CentOS/Fedora</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=1</span></span><br><span class="line"><span class="string">repo_gpgcheck=1</span></span><br><span class="line"><span class="string">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">sudo</span> yum install -y kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure>
<h2 id="修改内核的运行参数"><a href="#%E4%BF%AE%E6%94%B9%E5%86%85%E6%A0%B8%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0">#</a> 修改内核的运行参数</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables  = 1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward                 = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用配置</span></span><br><span class="line">$ sysctl --system</span><br></pre></td></tr></table></figure>
<h2 id="配置-kubelet"><a href="#%E9%85%8D%E7%BD%AE-kubelet">#</a> 配置 kubelet</h2>
<h3 id="修改-kubelet-service"><a href="#%E4%BF%AE%E6%94%B9-kubelet-service">#</a> 修改 <code>kubelet.service</code></h3>
<p><code>/etc/systemd/system/kubelet.service.d/10-proxy-ipvs.conf</code> 写入以下内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用 ipvs 相关内核模块</span></span><br><span class="line">[Service]</span><br><span class="line">ExecStartPre=-/sbin/modprobe ip_vs</span><br><span class="line">ExecStartPre=-/sbin/modprobe ip_vs_rr</span><br><span class="line">ExecStartPre=-/sbin/modprobe ip_vs_wrr</span><br><span class="line">ExecStartPre=-/sbin/modprobe ip_vs_sh</span><br></pre></td></tr></table></figure>
<p>执行以下命令应用配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<h2 id="部署"><a href="#%E9%83%A8%E7%BD%B2">#</a> 部署</h2>
<h3 id="master"><a href="#master">#</a> master</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="built_in">enable</span> cri-containerd</span><br><span class="line"></span><br><span class="line">$ systemctl start cri-containerd</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">sudo</span> kubeadm init \</span><br><span class="line">      --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers \</span><br><span class="line">      --pod-network-cidr 10.244.0.0/16 \</span><br><span class="line">      --cri-socket /run/cri-containerd/cri-containerd.sock \</span><br><span class="line">      --v 5 \</span><br><span class="line">      --ignore-preflight-errors=all</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--pod-network-cidr 10.244.0.0/16</code> 参数与后续 CNI 插件有关，这里以 <code>flannel</code> 为例，若后续部署其他类型的网络插件请更改此参数。</li>
</ul>
<blockquote>
<p>执行可能出现错误，例如缺少依赖包，根据提示安装即可。</p>
</blockquote>
<p>执行成功会输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">I1116 12:35:13.270407   86677 request.go:538] Throttling request took 181.409184ms, request: POST:https://192.168.199.100:6443/api/v1/namespaces/kube-system/serviceaccounts</span><br><span class="line">I1116 12:35:13.470292   86677 request.go:538] Throttling request took 186.088112ms, request: POST:https://192.168.199.100:6443/api/v1/namespaces/kube-system/configmaps</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> 192.168.199.100:6443 --token cz81zt.orsy9gm9v649e5lf \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:5edb316fd0d8ea2792cba15cdf1c899a366f147aa03cba52d4e5c5884ad836fe</span><br></pre></td></tr></table></figure>
<h3 id="node-工作节点"><a href="#node-%E5%B7%A5%E4%BD%9C%E8%8A%82%E7%82%B9">#</a> node 工作节点</h3>
<p>在 <strong>另一主机</strong> 重复 <strong>部署</strong> 小节以前的步骤，安装配置好 kubelet。根据提示，加入到集群。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="built_in">enable</span> cri-containerd</span><br><span class="line"></span><br><span class="line">$ systemctl start cri-containerd</span><br><span class="line"></span><br><span class="line">$ kubeadm <span class="built_in">join</span> 192.168.199.100:6443 \</span><br><span class="line">    --token cz81zt.orsy9gm9v649e5lf \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:5edb316fd0d8ea2792cba15cdf1c899a366f147aa03cba52d4e5c5884ad836fe \</span><br><span class="line">    --cri-socket /run/cri-containerd/cri-containerd.sock</span><br></pre></td></tr></table></figure>
<h2 id="查看服务"><a href="#%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1">#</a> 查看服务</h2>
<p>所有服务启动后，通过 <code>crictl</code> 查看本地实际运行的容器。这些服务大概分为三类：主节点服务、工作节点服务和其它服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER_RUNTIME_ENDPOINT=/run/cri-containerd/cri-containerd.sock crictl ps -a</span><br></pre></td></tr></table></figure>
<h3 id="主节点服务-2"><a href="#%E4%B8%BB%E8%8A%82%E7%82%B9%E6%9C%8D%E5%8A%A1">#</a> 主节点服务</h3>
<ul>
<li>
<p><code>apiserver</code> 是整个系统的对外接口，提供 RESTful 方式供客户端和其它组件调用；</p>
</li>
<li>
<p><code>scheduler</code> 负责对资源进行调度，分配某个 pod 到某个节点上；</p>
</li>
<li>
<p><code>controller-manager</code> 负责管理控制器，包括 endpoint-controller（刷新服务和 pod 的关联信息）和 replication-controller（维护某个 pod 的复制为配置的数值）。</p>
</li>
</ul>
<h3 id="工作节点服务"><a href="#%E5%B7%A5%E4%BD%9C%E8%8A%82%E7%82%B9%E6%9C%8D%E5%8A%A1">#</a> 工作节点服务</h3>
<ul>
<li><code>proxy</code> 为 pod 上的服务提供访问的代理。</li>
</ul>
<h3 id="其它服务"><a href="#%E5%85%B6%E5%AE%83%E6%9C%8D%E5%8A%A1">#</a> 其它服务</h3>
<ul>
<li>Etcd 是所有状态的存储数据库；</li>
</ul>
<h2 id="使用"><a href="#%E4%BD%BF%E7%94%A8">#</a> 使用</h2>
<p>将 <code>/etc/kubernetes/admin.conf</code> 复制到 <code>~/.kube/config</code></p>
<p>执行 <code>$ kubectl get all -A</code> 查看启动的服务。</p>
<p>由于未部署 CNI 插件，CoreDNS 未正常启动。如何使用 Kubernetes，请参考后续章节。</p>
<h2 id="部署-CNI"><a href="#%E9%83%A8%E7%BD%B2-cni">#</a> 部署 CNI</h2>
<p>这里以 <code>flannel</code> 为例进行介绍。</p>
<h3 id="flannel"><a href="#flannel">#</a> flannel</h3>
<p>检查 podCIDR 设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get node -o yaml | grep CIDR</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">    podCIDR: 10.244.0.0/16</span><br><span class="line">    podCIDRs:</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/v0.11.0/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>
<h2 id="master-节点默认不能运行-pod"><a href="#master-%E8%8A%82%E7%82%B9%E9%BB%98%E8%AE%A4%E4%B8%8D%E8%83%BD%E8%BF%90%E8%A1%8C-pod">#</a> master 节点默认不能运行 pod</h2>
<p>如果用 <code>kubeadm</code> 部署一个单节点集群，默认情况下无法使用，请执行以下命令解除限制</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl taint nodes --all node-role.kubernetes.io/master-</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复默认值</span></span><br><span class="line"><span class="comment"># $ kubectl taint nodes NODE_NAME node-role.kubernetes.io/master=true:NoSchedule</span></span><br></pre></td></tr></table></figure>
<h2 id="参考文档"><a href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3">#</a> 参考文档</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">官方文档 (opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/setup/production-environment/container-runtimes/#containerd">Container runtimes (opens new window)</a></li>
</ul>
<h2 id="Docker-Desktop-启用-Kubernetes"><a href="#docker-desktop-%E5%90%AF%E7%94%A8-kubernetes">#</a> Docker Desktop 启用 Kubernetes</h2>
<p>使用 Docker Desktop 可以很方便的启用 Kubernetes，由于国内获取不到 <code>k8s.gcr.io</code> 镜像，我们必须首先解决这一问题。</p>
<h2 id="获取-k8s-gcr-io-镜像"><a href="#%E8%8E%B7%E5%8F%96-k8s-gcr-io-%E9%95%9C%E5%83%8F">#</a> 获取 <code>k8s.gcr.io</code> 镜像</h2>
<p>由于国内拉取不到 <code>k8s.gcr.io</code> 镜像，我们可以使用开源项目 <a target="_blank" rel="noopener" href="https://github.com/AliyunContainerService/k8s-for-docker-desktop">AliyunContainerService/k8s-for-docker-desktop (opens new window)</a> 来获取所需的镜像。</p>
<h2 id="启用-Kubernetes"><a href="#%E5%90%AF%E7%94%A8-kubernetes">#</a> 启用 Kubernetes</h2>
<p>在 Docker Desktop 设置页面，点击 <code>Kubernetes</code>，选择 <code>Enable Kubernetes</code>，稍等片刻，看到左下方 <code>Kubernetes</code> 变为 <code>running</code>，Kubernetes 启动成功。</p>
<p><img src="https://github.com/AliyunContainerService/k8s-for-docker-desktop/raw/master/images/k8s.png" alt=""></p>
<h2 id="测试"><a href="#%E6%B5%8B%E8%AF%95">#</a> 测试</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl version</span><br></pre></td></tr></table></figure>
<p>如果正常输出信息，则证明 Kubernetes 成功启动。</p>
<h2 id="Kubernetes-Dashboard"><a href="#kubernetes-dashboard">#</a> Kubernetes Dashboard</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/kubernetes/dashboard">Kubernetes Dashboard (opens new window)</a> 是基于网页的 Kubernetes 用户界面。</p>
<p><img src="https://d33wubrfki0l68.cloudfront.net/349824f68836152722dab89465835e604719caea/6e0b7/images/docs/ui-dashboard.png" alt=""></p>
<h2 id="部署-2"><a href="#%E9%83%A8%E7%BD%B2">#</a> 部署</h2>
<p>执行以下命令即可部署 Dashboard：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure>
<h2 id="访问"><a href="#%E8%AE%BF%E9%97%AE">#</a> 访问</h2>
<p>通过命令行代理访问，执行以下命令：</p>
<p>到 <a target="_blank" rel="noopener" href="http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/">http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</a> 即可访问。</p>
<h2 id="登录"><a href="#%E7%99%BB%E5%BD%95">#</a> 登录</h2>
<p>目前，Dashboard 仅支持使用 Bearer 令牌登录。下面教大家如何创建该令牌：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create sa dashboard-admin -n kube-system</span><br><span class="line"></span><br><span class="line">$ kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin</span><br><span class="line"></span><br><span class="line">$ ADMIN_SECRET=$(kubectl get secrets -n kube-system | grep dashboard-admin | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">$ DASHBOARD_LOGIN_TOKEN=$(kubectl describe secret -n kube-system <span class="variable">$&#123;ADMIN_SECRET&#125;</span> | grep -E <span class="string">&#x27;^token&#x27;</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;DASHBOARD_LOGIN_TOKEN&#125;</span></span><br></pre></td></tr></table></figure>
<p>将结果粘贴到登录页面，即可登录。</p>
<h2 id="参考文档-2"><a href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3">#</a> 参考文档</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/tasks/access-application-cluster/web-ui-dashboard/">官方文档 (opens new window)</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2018/04/20/docker/Kubernetes/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2018/04/19/docker/18.%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%20Docker(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/"
                            aria-label=": 18.如何调试 Docker(Docker详细教程)"
                        >
                            18.如何调试 Docker(Docker详细教程)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-19T16:02:39+08:00">
	
		    2018 年 4 月 19 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../categories/devops/">devops</a>, <a class="category-link" href="../../categories/devops/Docker/">Docker</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="如何调试-Docker"><a href="#%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95-docker">#</a> 如何调试 Docker</h2>
<h2 id="开启-Debug-模式"><a href="#%E5%BC%80%E5%90%AF-debug-%E6%A8%A1%E5%BC%8F">#</a> 开启 Debug 模式</h2>
<p>在 dockerd 配置文件 daemon.json（默认位于 /etc/docker/）中添加</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;debug&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>重启守护进程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">kill</span> -SIGHUP $(pidof dockerd)</span><br></pre></td></tr></table></figure>
<p>此时 dockerd 会在日志中输入更多信息供分析。</p>
<h2 id="检查内核日志"><a href="#%E6%A3%80%E6%9F%A5%E5%86%85%E6%A0%B8%E6%97%A5%E5%BF%97">#</a> 检查内核日志</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> dmesg |grep dockerd</span><br><span class="line">$ <span class="built_in">sudo</span> dmesg |grep runc</span><br></pre></td></tr></table></figure>
<h2 id="Docker-不响应时处理"><a href="#docker-%E4%B8%8D%E5%93%8D%E5%BA%94%E6%97%B6%E5%A4%84%E7%90%86">#</a> Docker 不响应时处理</h2>
<p>可以杀死 dockerd 进程查看其堆栈调用情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">kill</span> -SIGUSR1 $(pidof dockerd)</span><br></pre></td></tr></table></figure>
<h2 id="重置-Docker-本地数据"><a href="#%E9%87%8D%E7%BD%AE-docker-%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE">#</a> 重置 Docker 本地数据</h2>
<p><em>注意，本操作会移除所有的 Docker 本地数据，包括镜像和容器等。</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/docker</span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2018/04/19/docker/18.%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%20Docker(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2018/04/18/docker/17.Dockerfile%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/"
                            aria-label=": 17.Dockerfile 最佳实践(Docker详细教程)"
                        >
                            17.Dockerfile 最佳实践(Docker详细教程)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-18T16:02:39+08:00">
	
		    2018 年 4 月 18 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../categories/devops/">devops</a>, <a class="category-link" href="../../categories/devops/Docker/">Docker</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="Dockerfile-最佳实践"><a href="#dockerfile-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">#</a> Dockerfile 最佳实践</h2>
<p>本附录是笔者对 Docker 官方文档中 <a target="_blank" rel="noopener" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Best practices for writing Dockerfiles (opens new window)</a> 的理解与翻译。</p>
<h2 id="一般性的指南和建议"><a href="#%E4%B8%80%E8%88%AC%E6%80%A7%E7%9A%84%E6%8C%87%E5%8D%97%E5%92%8C%E5%BB%BA%E8%AE%AE">#</a> 一般性的指南和建议</h2>
<h3 id="容器应该是短暂的"><a href="#%E5%AE%B9%E5%99%A8%E5%BA%94%E8%AF%A5%E6%98%AF%E7%9F%AD%E6%9A%82%E7%9A%84">#</a> 容器应该是短暂的</h3>
<p>通过 <code>Dockerfile</code> 构建的镜像所启动的容器应该尽可能短暂（生命周期短）。「短暂」意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置工作量应该是极小的。</p>
<h3 id="使用-dockerignore-文件"><a href="#%E4%BD%BF%E7%94%A8-dockerignore-%E6%96%87%E4%BB%B6">#</a> 使用 <code>.dockerignore</code> 文件</h3>
<p>使用 <code>Dockerfile</code> 构建镜像时最好是将 <code>Dockerfile</code> 放置在一个新建的空目录下。然后将构建镜像所需要的文件添加到该目录中。为了提高构建镜像的效率，你可以在目录下新建一个 <code>.dockerignore</code> 文件来指定要忽略的文件和目录。<code>.dockerignore</code> 文件的排除模式语法和 Git 的 <code>.gitignore</code> 文件相似。</p>
<h3 id="使用多阶段构建"><a href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">#</a> 使用多阶段构建</h3>
<p>在 <code>Docker 17.05</code> 以上版本中，你可以使用 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/image/multistage-builds.html">多阶段构建</a> 来减少所构建镜像的大小。</p>
<h3 id="避免安装不必要的包"><a href="#%E9%81%BF%E5%85%8D%E5%AE%89%E8%A3%85%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%8C%85">#</a> 避免安装不必要的包</h3>
<p>为了降低复杂性、减少依赖、减小文件大小、节约构建时间，你应该避免安装任何不必要的包。例如，不要在数据库镜像中包含一个文本编辑器。</p>
<h3 id="一个容器只运行一个进程"><a href="#%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E5%8F%AA%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B">#</a> 一个容器只运行一个进程</h3>
<p>应该保证在一个容器中只运行一个进程。将多个应用解耦到不同容器中，保证了容器的横向扩展和复用。例如 web 应用应该包含三个容器：web应用、数据库、缓存。</p>
<p>如果容器互相依赖，你可以使用 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/network/linking.html">Docker 自定义网络</a> 来把这些容器连接起来。</p>
<h3 id="镜像层数尽可能少"><a href="#%E9%95%9C%E5%83%8F%E5%B1%82%E6%95%B0%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%B0%91">#</a> 镜像层数尽可能少</h3>
<p>你需要在 <code>Dockerfile</code> 可读性（也包括长期的可维护性）和减少层数之间做一个平衡。</p>
<h3 id="将多行参数排序"><a href="#%E5%B0%86%E5%A4%9A%E8%A1%8C%E5%8F%82%E6%95%B0%E6%8E%92%E5%BA%8F">#</a> 将多行参数排序</h3>
<p>将多行参数按字母顺序排序（比如要安装多个包时）。这可以帮助你避免重复包含同一个包，更新包列表时也更容易。也便于 <code>PRs</code> 阅读和审查。建议在反斜杠符号 <code>\</code> 之前添加一个空格，以增加可读性。</p>
<p>下面是来自 <code>buildpack-deps</code> 镜像的例子：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">  bzr \</span></span><br><span class="line"><span class="language-bash">  cvs \</span></span><br><span class="line"><span class="language-bash">  git \</span></span><br><span class="line"><span class="language-bash">  mercurial \</span></span><br><span class="line"><span class="language-bash">  subversion</span></span><br></pre></td></tr></table></figure>
<h3 id="构建缓存"><a href="#%E6%9E%84%E5%BB%BA%E7%BC%93%E5%AD%98">#</a> 构建缓存</h3>
<p>在镜像的构建过程中，Docker 会遍历 <code>Dockerfile</code> 文件中的指令，然后按顺序执行。在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像，不再重复创建。如果你不想在构建过程中使用缓存，你可以在 <code>docker build</code> 命令中使用 <code>--no-cache=true</code> 选项。</p>
<p>但是，如果你想在构建的过程中使用缓存，你得明白什么时候会，什么时候不会找到匹配的镜像，遵循的基本规则如下：</p>
<ul>
<li>从一个基础镜像开始（<code>FROM</code> 指令指定），下一条指令将和该基础镜像的所有子镜像进行匹配，检查这些子镜像被创建时使用的指令是否和被检查的指令完全一样。如果不是，则缓存失效。</li>
<li>在大多数情况下，只需要简单地对比 <code>Dockerfile</code> 中的指令和子镜像。然而，有些指令需要更多的检查和解释。</li>
<li>对于 <code>ADD</code> 和 <code>COPY</code> 指令，镜像中对应文件的内容也会被检查，每个文件都会计算出一个校验和。文件的最后修改时间和最后访问时间不会纳入校验。在缓存的查找过程中，会将这些校验和和已存在镜像中的文件校验和进行对比。如果文件有任何改变，比如内容和元数据，则缓存失效。</li>
<li>除了 <code>ADD</code> 和 <code>COPY</code> 指令，缓存匹配过程不会查看临时容器中的文件来决定缓存是否匹配。例如，当执行完 <code>RUN apt-get -y update</code> 指令后，容器中一些文件被更新，但 Docker 不会检查这些文件。这种情况下，只有指令字符串本身被用来匹配缓存。</li>
</ul>
<p>一旦缓存失效，所有后续的 <code>Dockerfile</code> 指令都将产生新的镜像，缓存不会被使用。</p>
<h2 id="Dockerfile-指令"><a href="#dockerfile-%E6%8C%87%E4%BB%A4">#</a> Dockerfile 指令</h2>
<p>下面针对 <code>Dockerfile</code> 中各种指令的最佳编写方式给出建议。</p>
<h3 id="FROM"><a href="#from">#</a> FROM</h3>
<p>尽可能使用当前官方仓库作为你构建镜像的基础。推荐使用 <a target="_blank" rel="noopener" href="https://hub.docker.com/_/alpine/">Alpine (opens new window)</a> 镜像，因为它被严格控制并保持最小尺寸（目前小于 5 MB），但它仍然是一个完整的发行版。</p>
<h3 id="LABEL"><a href="#label">#</a> LABEL</h3>
<p>你可以给镜像添加标签来帮助组织镜像、记录许可信息、辅助自动化构建等。每个标签一行，由 <code>LABEL</code> 开头加上一个或多个标签对。下面的示例展示了各种不同的可能格式。<code>#</code> 开头的行是注释内容。</p>
<blockquote>
<p>注意：如果你的字符串中包含空格，必须将字符串放入引号中或者对空格使用转义。如果字符串内容本身就包含引号，必须对引号使用转义。</p>
</blockquote>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set one or more individual labels</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.version=<span class="string">&quot;0.0.1-beta&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> vendor=<span class="string">&quot;ACME Incorporated&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.release-date=<span class="string">&quot;2015-02-12&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.version.is-production=<span class="string">&quot;&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>一个镜像可以包含多个标签，但建议将多个标签放入到一个 <code>LABEL</code> 指令中。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set multiple labels at once, using line-continuation characters to break long lines</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> vendor=ACME\ Incorporated \</span></span><br><span class="line"><span class="language-bash">      com.example.is-beta= \</span></span><br><span class="line"><span class="language-bash">      com.example.is-production=<span class="string">&quot;&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      com.example.version=<span class="string">&quot;0.0.1-beta&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      com.example.release-date=<span class="string">&quot;2015-02-12&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>关于标签可以接受的键值对，参考 <a target="_blank" rel="noopener" href="https://docs.docker.com/config/labels-custom-metadata/">Understanding object labels (opens new window)</a>。关于查询标签信息，参考 <a target="_blank" rel="noopener" href="https://docs.docker.com/config/labels-custom-metadata/">Managing labels on objects (opens new window)</a>。</p>
<h3 id="RUN"><a href="#run">#</a> RUN</h3>
<p>为了保持 <code>Dockerfile</code> 文件的可读性，可理解性，以及可维护性，建议将长的或复杂的 <code>RUN</code> 指令用反斜杠 <code>\</code> 分割成多行。</p>
<h4 id="apt-get"><a href="#apt-get">#</a> apt-get</h4>
<p><code>RUN</code> 指令最常见的用法是安装包用的 <code>apt-get</code>。因为 <code>RUN apt-get</code> 指令会安装包，所以有几个问题需要注意。</p>
<p>不要使用 <code>RUN apt-get upgrade</code> 或 <code>dist-upgrade</code>，因为许多基础镜像中的「必须」包不会在一个非特权容器中升级。如果基础镜像中的某个包过时了，你应该联系它的维护者。如果你确定某个特定的包，比如 <code>foo</code>，需要升级，使用 <code>apt-get install -y foo</code> 就行，该指令会自动升级 <code>foo</code> 包。</p>
<p>永远将 <code>RUN apt-get update</code> 和 <code>apt-get install</code> 组合成一条 <code>RUN</code> 声明，例如：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">        package-bar \</span></span><br><span class="line"><span class="language-bash">        package-baz \</span></span><br><span class="line"><span class="language-bash">        package-foo</span></span><br></pre></td></tr></table></figure>
<p>将 <code>apt-get update</code> 放在一条单独的 <code>RUN</code> 声明中会导致缓存问题以及后续的 <code>apt-get install</code> 失败。比如，假设你有一个 <code>Dockerfile</code> 文件：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y curl</span></span><br></pre></td></tr></table></figure>
<p>构建镜像后，所有的层都在 Docker 的缓存中。假设你后来又修改了其中的 <code>apt-get install</code> 添加了一个包：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y curl nginx</span></span><br></pre></td></tr></table></figure>
<p>Docker 发现修改后的 <code>RUN apt-get update</code> 指令和之前的完全一样。所以，<code>apt-get update</code> 不会执行，而是使用之前的缓存镜像。因为 <code>apt-get update</code> 没有运行，后面的 <code>apt-get install</code> 可能安装的是过时的 <code>curl</code> 和 <code>nginx</code> 版本。</p>
<p>使用 <code>RUN apt-get update &amp;&amp; apt-get install -y</code> 可以确保你的 Dockerfiles 每次安装的都是包的最新的版本，而且这个过程不需要进一步的编码或额外干预。这项技术叫作 <code>cache busting</code>。你也可以显示指定一个包的版本号来达到 <code>cache-busting</code>，这就是所谓的固定版本，例如：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">    package-bar \</span></span><br><span class="line"><span class="language-bash">    package-baz \</span></span><br><span class="line"><span class="language-bash">    package-foo=1.3.*</span></span><br></pre></td></tr></table></figure>
<p>固定版本会迫使构建过程检索特定的版本，而不管缓存中有什么。这项技术也可以减少因所需包中未预料到的变化而导致的失败。</p>
<p>下面是一个 <code>RUN</code> 指令的示例模板，展示了所有关于 <code>apt-get</code> 的建议。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">    aufs-tools \</span></span><br><span class="line"><span class="language-bash">    automake \</span></span><br><span class="line"><span class="language-bash">    build-essential \</span></span><br><span class="line"><span class="language-bash">    curl \</span></span><br><span class="line"><span class="language-bash">    dpkg-sig \</span></span><br><span class="line"><span class="language-bash">    libcap-dev \</span></span><br><span class="line"><span class="language-bash">    libsqlite3-dev \</span></span><br><span class="line"><span class="language-bash">    mercurial \</span></span><br><span class="line"><span class="language-bash">    reprepro \</span></span><br><span class="line"><span class="language-bash">    ruby1.9.1 \</span></span><br><span class="line"><span class="language-bash">    ruby1.9.1-dev \</span></span><br><span class="line"><span class="language-bash">    s3cmd=1.1.* \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>s3cmd</code> 指令指定了一个版本号 <code>1.1.*</code>。如果之前的镜像使用的是更旧的版本，指定新的版本会导致 <code>apt-get udpate</code> 缓存失效并确保安装的是新版本。</p>
<p>另外，清理掉 apt 缓存 <code>var/lib/apt/lists</code> 可以减小镜像大小。因为 <code>RUN</code> 指令的开头为 <code>apt-get udpate</code>，包缓存总是会在 <code>apt-get install</code> 之前刷新。</p>
<blockquote>
<p>注意：官方的 Debian 和 Ubuntu 镜像会自动运行 apt-get clean，所以不需要显式的调用 apt-get clean。</p>
</blockquote>
<h3 id="CMD"><a href="#cmd">#</a> CMD</h3>
<p><code>CMD</code> 指令用于执行目标镜像中包含的软件，可以包含参数。<code>CMD</code> 大多数情况下都应该以 <code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;...]</code> 的形式使用。因此，如果创建镜像的目的是为了部署某个服务(比如 <code>Apache</code>)，你可能会执行类似于 <code>CMD [&quot;apache2&quot;, &quot;-DFOREGROUND&quot;]</code> 形式的命令。我们建议任何服务镜像都使用这种形式的命令。</p>
<p>多数情况下，<code>CMD</code> 都需要一个交互式的 <code>shell</code> (bash, Python, perl 等)，例如 <code>CMD [&quot;perl&quot;, &quot;-de0&quot;]</code>，或者 <code>CMD [&quot;PHP&quot;, &quot;-a&quot;]</code>。使用这种形式意味着，当你执行类似 <code>docker run -it python</code> 时，你会进入一个准备好的 <code>shell</code> 中。<code>CMD</code> 应该在极少的情况下才能以 <code>CMD [&quot;param&quot;, &quot;param&quot;]</code> 的形式与 <code>ENTRYPOINT</code> 协同使用，除非你和你的镜像使用者都对 <code>ENTRYPOINT</code> 的工作方式十分熟悉。</p>
<h3 id="EXPOSE"><a href="#expose">#</a> EXPOSE</h3>
<p><code>EXPOSE</code> 指令用于指定容器将要监听的端口。因此，你应该为你的应用程序使用常见的端口。例如，提供 <code>Apache</code> web 服务的镜像应该使用 <code>EXPOSE 80</code>，而提供 <code>MongoDB</code> 服务的镜像使用 <code>EXPOSE 27017</code>。</p>
<p>对于外部访问，用户可以在执行 <code>docker run</code> 时使用一个标志来指示如何将指定的端口映射到所选择的端口。</p>
<h3 id="ENV"><a href="#env">#</a> ENV</h3>
<p>为了方便新程序运行，你可以使用 <code>ENV</code> 来为容器中安装的程序更新 <code>PATH</code> 环境变量。例如使用 <code>ENV PATH /usr/local/nginx/bin:$PATH</code> 来确保 <code>CMD [&quot;nginx&quot;]</code> 能正确运行。</p>
<p><code>ENV</code> 指令也可用于为你想要容器化的服务提供必要的环境变量，比如 Postgres 需要的 <code>PGDATA</code>。</p>
<p>最后，<code>ENV</code> 也能用于设置常见的版本号，比如下面的示例：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> PG_MAJOR <span class="number">9.3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PG_VERSION <span class="number">9.3</span>.<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -SL http://example.com/postgres-<span class="variable">$PG_VERSION</span>.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>类似于程序中的常量，这种方法可以让你只需改变 <code>ENV</code> 指令来自动的改变容器中的软件版本。</p>
<h3 id="ADD-和-COPY"><a href="#add-%E5%92%8C-copy">#</a> ADD 和 COPY</h3>
<p>虽然 <code>ADD</code> 和 <code>COPY</code> 功能类似，但一般优先使用 <code>COPY</code>。因为它比 <code>ADD</code> 更透明。<code>COPY</code> 只支持简单将本地文件拷贝到容器中，而 <code>ADD</code> 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，<code>ADD</code> 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 <code>ADD rootfs.tar.xz</code>。</p>
<p>如果你的 <code>Dockerfile</code> 有多个步骤需要使用上下文中不同的文件。单独 <code>COPY</code> 每个文件，而不是一次性的 <code>COPY</code> 所有文件，这将保证每个步骤的构建缓存只在特定的文件变化时失效。例如：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt /tmp/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --requirement /tmp/requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /tmp/</span></span><br></pre></td></tr></table></figure>
<p>如果将 <code>COPY . /tmp/</code> 放置在 <code>RUN</code> 指令之前，只要 <code>.</code> 目录中任何一个文件变化，都会导致后续指令的缓存失效。</p>
<p>为了让镜像尽量小，最好不要使用 <code>ADD</code> 指令从远程 URL 获取包，而是使用 <code>curl</code> 和 <code>wget</code>。这样你可以在文件提取完之后删掉不再需要的文件来避免在镜像中额外添加一层。比如尽量避免下面的用法：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> http://example.com/big.tar.xz /usr/src/things/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/things all</span></span><br></pre></td></tr></table></figure>
<p>而是应该使用下面这种方法：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /usr/src/things \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; curl -SL http://example.com/big.tar.xz \</span></span><br><span class="line"><span class="language-bash">    | tar -xJC /usr/src/things \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/things all</span></span><br></pre></td></tr></table></figure>
<p>上面使用的管道操作，所以没有中间文件需要删除。</p>
<p>对于其他不需要 <code>ADD</code> 的自动提取功能的文件或目录，你应该使用 <code>COPY</code>。</p>
<h3 id="ENTRYPOINT"><a href="#entrypoint">#</a> ENTRYPOINT</h3>
<p><code>ENTRYPOINT</code> 的最佳用处是设置镜像的主命令，允许将镜像当成命令本身来运行（用 <code>CMD</code> 提供默认选项）。</p>
<p>例如，下面的示例镜像提供了命令行工具 <code>s3cmd</code>:</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;s3cmd&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;--help&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>现在直接运行该镜像创建的容器会显示命令帮助：</p>
<p>或者提供正确的参数来执行某个命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run s3cmd <span class="built_in">ls</span> s3://mybucket</span><br></pre></td></tr></table></figure>
<p>这样镜像名可以当成命令行的参考。</p>
<p><code>ENTRYPOINT</code> 指令也可以结合一个辅助脚本使用，和前面命令行风格类似，即使启动工具需要不止一个步骤。</p>
<p>例如，<code>Postgres</code> 官方镜像使用下面的脚本作为 <code>ENTRYPOINT</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&#x27;postgres&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">chown</span> -R postgres <span class="string">&quot;<span class="variable">$PGDATA</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="subst">$(ls -A <span class="string">&quot;<span class="variable">$PGDATA</span>&quot;</span>)</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        gosu postgres initdb</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exec</span> gosu postgres <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 1 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。</p>
</blockquote>
<p>该辅助脚本被拷贝到容器，并在容器启动时通过 <code>ENTRYPOINT</code> 执行：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-entrypoint.sh /</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/docker-entrypoint.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>该脚本可以让用户用几种不同的方式和 <code>Postgres</code> 交互。</p>
<p>你可以很简单地启动 <code>Postgres</code>：</p>
<p>也可以执行 <code>Postgres</code> 并传递参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run postgres postgres --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>最后，你还可以启动另外一个完全不同的工具，比如 <code>Bash</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --<span class="built_in">rm</span> -it postgres bash</span><br></pre></td></tr></table></figure>
<h3 id="VOLUME"><a href="#volume">#</a> VOLUME</h3>
<p><code>VOLUME</code> 指令用于暴露任何数据库存储文件，配置文件，或容器创建的文件和目录。强烈建议使用 <code>VOLUME</code> 来管理镜像中的可变部分和用户可以改变的部分。</p>
<h3 id="USER"><a href="#user">#</a> USER</h3>
<p>如果某个服务不需要特权执行，建议使用 <code>USER</code> 指令切换到非 root 用户。先在 <code>Dockerfile</code> 中使用类似 <code>RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</code> 的指令创建用户和用户组。</p>
<blockquote>
<p>注意：在镜像中，用户和用户组每次被分配的 UID/GID 都是不确定的，下次重新构建镜像时被分配到的 UID/GID 可能会不一样。如果要依赖确定的 UID/GID，你应该显式的指定一个 UID/GID。</p>
</blockquote>
<p>你应该避免使用 <code>sudo</code>，因为它不可预期的 TTY 和信号转发行为可能造成的问题比它能解决的问题还多。如果你真的需要和 <code>sudo</code> 类似的功能（例如，以 root 权限初始化某个守护进程，以非 root 权限执行它），你可以使用 <a target="_blank" rel="noopener" href="https://github.com/tianon/gosu">gosu (opens new window)</a>。</p>
<p>最后，为了减少层数和复杂度，避免频繁地使用 <code>USER</code> 来回切换用户。</p>
<h3 id="WORKDIR"><a href="#workdir">#</a> WORKDIR</h3>
<p>为了清晰性和可靠性，你应该总是在 <code>WORKDIR</code> 中使用绝对路径。另外，你应该使用 <code>WORKDIR</code> 来替代类似于 <code>RUN cd ... &amp;&amp; do-something</code> 的指令，后者难以阅读、排错和维护。</p>
<h2 id="官方镜像示例"><a href="#%E5%AE%98%E6%96%B9%E9%95%9C%E5%83%8F%E7%A4%BA%E4%BE%8B">#</a> 官方镜像示例</h2>
<p>这些官方镜像的 Dockerfile 都是参考典范：<a target="_blank" rel="noopener" href="https://github.com/docker-library/docs">https://github.com/docker-library/docs</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2018/04/18/docker/17.Dockerfile%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2018/04/17/docker/16.Docker%20%E5%91%BD%E4%BB%A4(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/"
                            aria-label=": 16.Docker 命令(Docker详细教程)"
                        >
                            16.Docker 命令(Docker详细教程)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-17T16:02:39+08:00">
	
		    2018 年 4 月 17 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../categories/devops/">devops</a>, <a class="category-link" href="../../categories/devops/Docker/">Docker</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="Docker-命令查询"><a href="#docker-%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2">#</a> Docker 命令查询</h2>
<h2 id="基本语法"><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">#</a> 基本语法</h2>
<p>Docker 命令有两大类，客户端命令和服务端命令。前者是主要的操作接口，后者用来启动 Docker Daemon。</p>
<ul>
<li>
<p>客户端命令：基本命令格式为 <code>docker [OPTIONS] COMMAND [arg...]</code>；</p>
</li>
<li>
<p>服务端命令：基本命令格式为 <code>dockerd [OPTIONS]</code>。</p>
</li>
</ul>
<p>可以通过 <code>man docker</code> 或 <code>docker help</code> 来查看这些命令。</p>
<p>接下来的小节对这两个命令进行介绍。</p>
<h2 id="客户端命令-docker"><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%91%BD%E4%BB%A4-docker">#</a> 客户端命令(docker)</h2>
<h2 id="客户端命令选项"><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9">#</a> 客户端命令选项</h2>
<ul>
<li><code>--config=&quot;&quot;</code>：指定客户端配置文件，默认为 <code>~/.docker</code>；</li>
<li><code>-D=true|false</code>：是否使用 debug 模式。默认不开启；</li>
<li><code>-H, --host=[]</code>：指定命令对应 Docker 守护进程的监听接口，可以为 unix 套接字 <code>unix:///path/to/socket</code>，文件句柄 <code>fd://socketfd</code> 或 tcp 套接字 <code>tcp://[host[:port]]</code>，默认为 <code>unix:///var/run/docker.sock</code>；</li>
<li><code>-l, --log-level=&quot;debug|info|warn|error|fatal&quot;</code>：指定日志输出级别；</li>
<li><code>--tls=true|false</code>：是否对 Docker 守护进程启用 TLS 安全机制，默认为否；</li>
<li><code>--tlscacert=/.docker/ca.pem</code>：TLS CA 签名的可信证书文件路径；</li>
<li><code>--tlscert=/.docker/cert.pem</code>：TLS 可信证书文件路径；</li>
<li><code>--tlscert=/.docker/key.pem</code>：TLS 密钥文件路径；</li>
<li><code>--tlsverify=true|false</code>：启用 TLS 校验，默认为否。</li>
</ul>
<h2 id="客户端命令"><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%91%BD%E4%BB%A4">#</a> 客户端命令</h2>
<p>可以通过 <code>docker COMMAND --help</code> 来查看这些命令的具体用法。</p>
<ul>
<li><code>attach</code>：依附到一个正在运行的容器中；</li>
<li><code>build</code>：从一个 Dockerfile 创建一个镜像；</li>
<li><code>commit</code>：从一个容器的修改中创建一个新的镜像；</li>
<li><code>cp</code>：在容器和本地宿主系统之间复制文件中；</li>
<li><code>create</code>：创建一个新容器，但并不运行它；</li>
<li><code>diff</code>：检查一个容器内文件系统的修改，包括修改和增加；</li>
<li><code>events</code>：从服务端获取实时的事件；</li>
<li><code>exec</code>：在运行的容器内执行命令；</li>
<li><code>export</code>：导出容器内容为一个 <code>tar</code> 包；</li>
<li><code>history</code>：显示一个镜像的历史信息；</li>
<li><code>images</code>：列出存在的镜像；</li>
<li><code>import</code>：导入一个文件（典型为 <code>tar</code> 包）路径或目录来创建一个本地镜像；</li>
<li><code>info</code>：显示一些相关的系统信息；</li>
<li><code>inspect</code>：显示一个容器的具体配置信息；</li>
<li><code>kill</code>：关闭一个运行中的容器 (包括进程和所有相关资源)；</li>
<li><code>load</code>：从一个 tar 包中加载一个镜像；</li>
<li><code>login</code>：注册或登录到一个 Docker 的仓库服务器；</li>
<li><code>logout</code>：从 Docker 的仓库服务器登出；</li>
<li><code>logs</code>：获取容器的 log 信息；</li>
<li><code>network</code>：管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；</li>
<li><code>node</code>：管理 swarm 集群中的节点，包括查看、更新、删除、提升/取消管理节点等；</li>
<li><code>pause</code>：暂停一个容器中的所有进程；</li>
<li><code>port</code>：查找一个 nat 到一个私有网口的公共口；</li>
<li><code>ps</code>：列出主机上的容器；</li>
<li><code>pull</code>：从一个Docker的仓库服务器下拉一个镜像或仓库；</li>
<li><code>push</code>：将一个镜像或者仓库推送到一个 Docker 的注册服务器；</li>
<li><code>rename</code>：重命名一个容器；</li>
<li><code>restart</code>：重启一个运行中的容器；</li>
<li><code>rm</code>：删除给定的若干个容器；</li>
<li><code>rmi</code>：删除给定的若干个镜像；</li>
<li><code>run</code>：创建一个新容器，并在其中运行给定命令；</li>
<li><code>save</code>：保存一个镜像为 tar 包文件；</li>
<li><code>search</code>：在 Docker index 中搜索一个镜像；</li>
<li><code>service</code>：管理 Docker 所启动的应用服务，包括创建、更新、删除等；</li>
<li><code>start</code>：启动一个容器；</li>
<li><code>stats</code>：输出（一个或多个）容器的资源使用统计信息；</li>
<li><code>stop</code>：终止一个运行中的容器；</li>
<li><code>swarm</code>：管理 Docker swarm 集群，包括创建、加入、退出、更新等；</li>
<li><code>tag</code>：为一个镜像打标签；</li>
<li><code>top</code>：查看一个容器中的正在运行的进程信息；</li>
<li><code>unpause</code>：将一个容器内所有的进程从暂停状态中恢复；</li>
<li><code>update</code>：更新指定的若干容器的配置信息；</li>
<li><code>version</code>：输出 Docker 的版本信息；</li>
<li><code>volume</code>：管理 Docker volume，包括查看、创建、删除等；</li>
<li><code>wait</code>：阻塞直到一个容器终止，然后输出它的退出符。</li>
</ul>
<h2 id="一张图总结-Docker-的命令"><a href="#%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%80%BB%E7%BB%93-docker-%E7%9A%84%E5%91%BD%E4%BB%A4">#</a> 一张图总结 Docker 的命令</h2>
<p><img src="https://vuepress.mirror.docker-practice.com/assets/img/cmd_logic.5970ea4d.png" alt="Docker 命令总结"></p>
<h2 id="参考"><a href="#%E5%8F%82%E8%80%83">#</a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/cli/">官方文档 (opens new window)</a></li>
</ul>
<h2 id="服务端命令-dockerd"><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%91%BD%E4%BB%A4-dockerd">#</a> 服务端命令(dockerd)</h2>
<h2 id="dockerd-命令选项"><a href="#dockerd-%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9">#</a> dockerd 命令选项</h2>
<ul>
<li><code>--api-cors-header=&quot;&quot;</code>：CORS 头部域，默认不允许 CORS，要允许任意的跨域访问，可以指定为 “*”；</li>
<li><code>--authorization-plugin=&quot;&quot;</code>：载入认证的插件；</li>
<li><code>-b=&quot;&quot;</code>：将容器挂载到一个已存在的网桥上。指定为 <code>none</code> 时则禁用容器的网络，与 <code>--bip</code> 选项互斥；</li>
<li><code>--bip=&quot;&quot;</code>：让动态创建的 <code>docker0</code> 网桥采用给定的 CIDR 地址; 与 <code>-b</code> 选项互斥；</li>
<li><code>--cgroup-parent=&quot;&quot;</code>：指定 cgroup 的父组，默认 fs cgroup 驱动为 <code>/docker</code>，systemd cgroup 驱动为 <code>system.slice</code>；</li>
<li><code>--cluster-store=&quot;&quot;</code>：构成集群（如 <code>Swarm</code>）时，集群键值数据库服务地址；</li>
<li><code>--cluster-advertise=&quot;&quot;</code>：构成集群时，自身的被访问地址，可以为 <code>host:port</code> 或 <code>interface:port</code>；</li>
<li><code>--cluster-store-opt=&quot;&quot;</code>：构成集群时，键值数据库的配置选项；</li>
<li><code>--config-file=&quot;/etc/docker/daemon.json&quot;</code>：daemon 配置文件路径；</li>
<li><code>--containerd=&quot;&quot;</code>：containerd 文件的路径；</li>
<li><code>-D, --debug=true|false</code>：是否使用 Debug 模式。缺省为 false；</li>
<li><code>--default-gateway=&quot;&quot;</code>：容器的 IPv4 网关地址，必须在网桥的子网段内；</li>
<li><code>--default-gateway-v6=&quot;&quot;</code>：容器的 IPv6 网关地址；</li>
<li><code>--default-ulimit=[]</code>：默认的 ulimit 值；</li>
<li><code>--disable-legacy-registry=true|false</code>：是否允许访问旧版本的镜像仓库服务器；</li>
<li><code>--dns=&quot;&quot;</code>：指定容器使用的 DNS 服务器地址；</li>
<li><code>--dns-opt=&quot;&quot;</code>：DNS 选项；</li>
<li><code>--dns-search=[]</code>：DNS 搜索域；</li>
<li><code>--exec-opt=[]</code>：运行时的执行选项；</li>
<li><code>--exec-root=&quot;&quot;</code>：容器执行状态文件的根路径，默认为 <code>/var/run/docker</code>；</li>
<li><code>--fixed-cidr=&quot;&quot;</code>：限定分配 IPv4 地址范围；</li>
<li><code>--fixed-cidr-v6=&quot;&quot;</code>：限定分配 IPv6 地址范围；</li>
<li><code>-G, --group=&quot;&quot;</code>：分配给 unix 套接字的组，默认为 <code>docker</code>；</li>
<li><code>-g, --graph=&quot;&quot;</code>：Docker 运行时的根路径，默认为 <code>/var/lib/docker</code>；</li>
<li><code>-H, --host=[]</code>：指定命令对应 Docker daemon 的监听接口，可以为 unix 套接字 <code>unix:///path/to/socket</code>，文件句柄 <code>fd://socketfd</code> 或 tcp 套接字 <code>tcp://[host[:port]]</code>，默认为 <code>unix:///var/run/docker.sock</code>；</li>
<li><code>--icc=true|false</code>：是否启用容器间以及跟 daemon 所在主机的通信。默认为 true。</li>
<li><code>--insecure-registry=[]</code>：允许访问给定的非安全仓库服务；</li>
<li><code>--ip=&quot;&quot;</code>：绑定容器端口时候的默认 IP 地址。缺省为 <code>0.0.0.0</code>；</li>
<li><code>--ip-forward=true|false</code>：是否检查启动在 Docker 主机上的启用 IP 转发服务，默认开启。注意关闭该选项将不对系统转发能力进行任何检查修改；</li>
<li><code>--ip-masq=true|false</code>：是否进行地址伪装，用于容器访问外部网络，默认开启；</li>
<li><code>--iptables=true|false</code>：是否允许 Docker 添加 iptables 规则。缺省为 true；</li>
<li><code>--ipv6=true|false</code>：是否启用 IPv6 支持，默认关闭；</li>
<li><code>-l, --log-level=&quot;debug|info|warn|error|fatal&quot;</code>：指定日志输出级别；</li>
<li><code>--label=&quot;[]&quot;</code>：添加指定的键值对标注；</li>
<li><code>--log-driver=&quot;json-file|syslog|journald|gelf|fluentd|awslogs|splunk|etwlogs|gcplogs|none&quot;</code>：指定日志后端驱动，默认为 <code>json-file</code>；</li>
<li><code>--log-opt=[]</code>：日志后端的选项；</li>
<li><code>--mtu=VALUE</code>：指定容器网络的 <code>mtu</code>；</li>
<li><code>-p=&quot;&quot;</code>：指定 daemon 的 PID 文件路径。缺省为 <code>/var/run/docker.pid</code>；</li>
<li><code>--raw-logs</code>：输出原始，未加色彩的日志信息；</li>
<li><code>--registry-mirror=&lt;scheme&gt;://&lt;host&gt;</code>：指定 <code>docker pull</code> 时使用的注册服务器镜像地址；</li>
<li><code>-s, --storage-driver=&quot;&quot;</code>：指定使用给定的存储后端；</li>
<li><code>--selinux-enabled=true|false</code>：是否启用 SELinux 支持。缺省值为 false。SELinux 目前尚不支持 overlay 存储驱动；</li>
<li><code>--storage-opt=[]</code>：驱动后端选项；</li>
<li><code>--tls=true|false</code>：是否对 Docker daemon 启用 TLS 安全机制，默认为否；</li>
<li><code>--tlscacert=/.docker/ca.pem</code>：TLS CA 签名的可信证书文件路径；</li>
<li><code>--tlscert=/.docker/cert.pem</code>：TLS 可信证书文件路径；</li>
<li><code>--tlscert=/.docker/key.pem</code>：TLS 密钥文件路径；</li>
<li><code>--tlsverify=true|false</code>：启用 TLS 校验，默认为否；</li>
<li><code>--userland-proxy=true|false</code>：是否使用用户态代理来实现容器间和出容器的回环通信，默认为 true；</li>
<li><code>--userns-remap=default|uid:gid|user:group|user|uid</code>：指定容器的用户命名空间，默认是创建新的 UID 和 GID 映射到容器内进程。</li>
</ul>
<h2 id="参考-2"><a href="#%E5%8F%82%E8%80%83">#</a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/dockerd/">官方文档 (opens new window)</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2018/04/17/docker/16.Docker%20%E5%91%BD%E4%BB%A4(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2018/04/16/docker/15.Docker%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/"
                            aria-label=": 15.Docker 常见问题总结(Docker详细教程)"
                        >
                            15.Docker 常见问题总结(Docker详细教程)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-16T16:02:39+08:00">
	
		    2018 年 4 月 16 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../categories/devops/">devops</a>, <a class="category-link" href="../../categories/devops/Docker/">Docker</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="常见问题总结"><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93">#</a> 常见问题总结</h2>
<h2 id="镜像相关"><a href="#%E9%95%9C%E5%83%8F%E7%9B%B8%E5%85%B3">#</a> 镜像相关</h2>
<h3 id="如何批量清理临时镜像文件？"><a href="#%E5%A6%82%E4%BD%95%E6%89%B9%E9%87%8F%E6%B8%85%E7%90%86%E4%B8%B4%E6%97%B6%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6">#</a> 如何批量清理临时镜像文件？</h3>
<p>答：可以使用 <code>docker image prune</code> 命令。</p>
<h3 id="如何查看镜像支持的环境变量？"><a href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F%E6%94%AF%E6%8C%81%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">#</a> 如何查看镜像支持的环境变量？</h3>
<p>答：可以使用 <code>docker run IMAGE env</code> 命令。</p>
<h3 id="本地的镜像文件都存放在哪里？"><a href="#%E6%9C%AC%E5%9C%B0%E7%9A%84%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E9%83%BD%E5%AD%98%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C">#</a> 本地的镜像文件都存放在哪里？</h3>
<p>答：与 Docker 相关的本地资源默认存放在 <code>/var/lib/docker/</code> 目录下，以 <code>overlay2</code> 文件系统为例，其中 <code>containers</code> 目录存放容器信息，<code>image</code> 目录存放镜像信息，<code>overlay2</code> 目录下存放具体的镜像层文件。</p>
<h3 id="构建-Docker-镜像应该遵循哪些原则？"><a href="#%E6%9E%84%E5%BB%BA-docker-%E9%95%9C%E5%83%8F%E5%BA%94%E8%AF%A5%E9%81%B5%E5%BE%AA%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%88%99">#</a> 构建 Docker 镜像应该遵循哪些原则？</h3>
<p>答：整体原则上，尽量保持镜像功能的明确和内容的精简，要点包括</p>
<ul>
<li>
<p>尽量选取满足需求但较小的基础系统镜像，例如大部分时候可以选择 <code>alpine</code> 镜像，仅有不足六兆大小；</p>
</li>
<li>
<p>清理编译生成文件、安装包的缓存等临时文件；</p>
</li>
<li>
<p>安装各个软件时候要指定准确的版本号，并避免引入不需要的依赖；</p>
</li>
<li>
<p>从安全角度考虑，应用要尽量使用系统的库和依赖；</p>
</li>
<li>
<p>如果安装应用时候需要配置一些特殊的环境变量，在安装后要还原不需要保持的变量值；</p>
</li>
<li>
<p>使用 Dockerfile 创建镜像时候要添加 .dockerignore 文件或使用干净的工作目录。</p>
</li>
</ul>
<p>更多内容请查看 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/appendix/best_practices.html">Dockerfile 最佳实践</a></p>
<h3 id="碰到网络问题，无法-pull-镜像，命令行指定-http-proxy-无效？"><a href="#%E7%A2%B0%E5%88%B0%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98-%E6%97%A0%E6%B3%95-pull-%E9%95%9C%E5%83%8F-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8C%87%E5%AE%9A-http-proxy-%E6%97%A0%E6%95%88">#</a> 碰到网络问题，无法 pull 镜像，命令行指定 http_proxy 无效？</h3>
<p>答：在 Docker 配置文件中添加 <code>export http_proxy=&quot;http://&lt;PROXY_HOST&gt;:&lt;PROXY_PORT&gt;&quot;</code>，之后重启 Docker 服务即可。</p>
<h2 id="容器相关"><a href="#%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3">#</a> 容器相关</h2>
<h3 id="容器退出后，通过-docker-container-ls-命令查看不到，数据会丢失么？"><a href="#%E5%AE%B9%E5%99%A8%E9%80%80%E5%87%BA%E5%90%8E-%E9%80%9A%E8%BF%87-docker-container-ls-%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E4%B8%8D%E5%88%B0-%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%A2%E5%A4%B1%E4%B9%88">#</a> 容器退出后，通过 docker container ls 命令查看不到，数据会丢失么？</h3>
<p>答：容器退出后会处于终止（exited）状态，此时可以通过 <code>docker container ls -a</code> 查看。其中的数据也不会丢失，还可以通过 <code>docker start</code> 命令来启动它。只有删除掉容器才会清除所有数据。</p>
<h3 id="如何停止所有正在运行的容器？"><a href="#%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E6%89%80%E6%9C%89%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8">#</a> 如何停止所有正在运行的容器？</h3>
<p>答：可以使用 <code>docker stop $(docker container ls -q)</code> 命令。</p>
<h3 id="如何批量清理已经停止的容器？"><a href="#%E5%A6%82%E4%BD%95%E6%89%B9%E9%87%8F%E6%B8%85%E7%90%86%E5%B7%B2%E7%BB%8F%E5%81%9C%E6%AD%A2%E7%9A%84%E5%AE%B9%E5%99%A8">#</a> 如何批量清理已经停止的容器？</h3>
<p>答：可以使用 <code>docker container prune</code> 命令。</p>
<h3 id="如何获取某个容器的-PID-信息？"><a href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84-pid-%E4%BF%A1%E6%81%AF">#</a> 如何获取某个容器的 PID 信息？</h3>
<p>答：可以使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format <span class="string">&#x27;&#123;&#123; .State.Pid &#125;&#125;&#x27;</span> &lt;CONTAINER ID or NAME&gt;</span><br></pre></td></tr></table></figure>
<h3 id="如何获取某个容器的-IP-地址？"><a href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84-ip-%E5%9C%B0%E5%9D%80">#</a> 如何获取某个容器的 IP 地址？</h3>
<p>答：可以使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format <span class="string">&#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27;</span> &lt;CONTAINER ID or NAME&gt;</span><br></pre></td></tr></table></figure>
<h3 id="如何给容器指定一个固定-IP-地址，而不是每次重启容器-IP-地址都会变？"><a href="#%E5%A6%82%E4%BD%95%E7%BB%99%E5%AE%B9%E5%99%A8%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%9B%BA%E5%AE%9A-ip-%E5%9C%B0%E5%9D%80-%E8%80%8C%E4%B8%8D%E6%98%AF%E6%AF%8F%E6%AC%A1%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8-ip-%E5%9C%B0%E5%9D%80%E9%83%BD%E4%BC%9A%E5%8F%98">#</a> 如何给容器指定一个固定 IP 地址，而不是每次重启容器 IP 地址都会变？</h3>
<p>答：使用以下命令启动容器可以使容器 IP 固定不变</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d bridge --subnet 172.25.0.0/16 my-net</span><br><span class="line"></span><br><span class="line">$ docker run --network=my-net --ip=172.25.3.3 -itd --name=my-container busybox</span><br></pre></td></tr></table></figure>
<h3 id="如何临时退出一个正在交互的容器的终端，而不终止它？"><a href="#%E5%A6%82%E4%BD%95%E4%B8%B4%E6%97%B6%E9%80%80%E5%87%BA%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E4%BA%A4%E4%BA%92%E7%9A%84%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BB%88%E7%AB%AF-%E8%80%8C%E4%B8%8D%E7%BB%88%E6%AD%A2%E5%AE%83">#</a> 如何临时退出一个正在交互的容器的终端，而不终止它？</h3>
<p>答：按 <code>Ctrl-p Ctrl-q</code>。如果按 <code>Ctrl-c</code> 往往会让容器内应用进程终止，进而会终止容器。</p>
<h3 id="使用-docker-port-命令映射容器的端口时，系统报错“Error-No-public-port-‘80’-published-for-xxx”？"><a href="#%E4%BD%BF%E7%94%A8-docker-port-%E5%91%BD%E4%BB%A4%E6%98%A0%E5%B0%84%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%97%B6-%E7%B3%BB%E7%BB%9F%E6%8A%A5%E9%94%99-error-no-public-port-80-published-for-xxx">#</a> 使用 <code>docker port</code> 命令映射容器的端口时，系统报错“Error: No public port ‘80’ published for xxx”？</h3>
<p>答：</p>
<ul>
<li>
<p>创建镜像时 <code>Dockerfile</code> 要通过 <code>EXPOSE</code> 指定正确的开放端口；</p>
</li>
<li>
<p>容器启动时指定 <code>PublishAllPort = true</code>。</p>
</li>
</ul>
<h3 id="可以在一个容器中同时运行多个应用进程么？"><a href="#%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E4%B9%88">#</a> 可以在一个容器中同时运行多个应用进程么？</h3>
<p>答：一般并不推荐在同一个容器内运行多个应用进程。如果有类似需求，可以通过一些额外的进程管理机制，比如 <code>supervisord</code> 来管理所运行的进程。可以参考 <a target="_blank" rel="noopener" href="https://docs.docker.com/config/containers/multi-service%5C_container/">https://docs.docker.com/config/containers/multi-service\_container/</a> 。</p>
<h3 id="如何控制容器占用系统资源（CPU、内存）的份额？"><a href="#%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E5%AE%B9%E5%99%A8%E5%8D%A0%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90-cpu%E3%80%81%E5%86%85%E5%AD%98-%E7%9A%84%E4%BB%BD%E9%A2%9D">#</a> 如何控制容器占用系统资源（CPU、内存）的份额？</h3>
<p>答：在使用 <code>docker create</code> 命令创建容器或使用 <code>docker run</code> 创建并启动容器的时候，可以使用 -c|–cpu-shares[=0] 参数来调整容器使用 CPU 的权重；使用 -m|–memory[=MEMORY] 参数来调整容器使用内存的大小。</p>
<h2 id="仓库相关"><a href="#%E4%BB%93%E5%BA%93%E7%9B%B8%E5%85%B3">#</a> 仓库相关</h2>
<h3 id="仓库（Repository）、注册服务器（Registry）、注册索引（Index）-有何关系？"><a href="#%E4%BB%93%E5%BA%93-repository-%E3%80%81%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%E5%99%A8-registry-%E3%80%81%E6%B3%A8%E5%86%8C%E7%B4%A2%E5%BC%95-index-%E6%9C%89%E4%BD%95%E5%85%B3%E7%B3%BB">#</a> 仓库（Repository）、注册服务器（Registry）、注册索引（Index） 有何关系？</h3>
<p>首先，仓库是存放一组关联镜像的集合，比如同一个应用的不同版本的镜像。</p>
<p>注册服务器是存放实际的镜像文件的地方。注册索引则负责维护用户的账号、权限、搜索、标签等的管理。因此，注册服务器利用注册索引来实现认证等管理。</p>
<h2 id="配置相关"><a href="#%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3">#</a> 配置相关</h2>
<h3 id="Docker-的配置文件放在哪里，如何修改配置？"><a href="#docker-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C-%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE">#</a> Docker 的配置文件放在哪里，如何修改配置？</h3>
<p>答：使用 <code>systemd</code> 的系统（如 Ubuntu 16.04、Centos 等）的配置文件在 <code>/etc/docker/daemon.json</code>。</p>
<h3 id="如何更改-Docker-的默认存储位置？"><a href="#%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9-docker-%E7%9A%84%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE">#</a> 如何更改 Docker 的默认存储位置？</h3>
<p>答：Docker 的默认存储位置是 <code>/var/lib/docker</code>，如果希望将 Docker 的本地文件存储到其他分区，可以使用 Linux 软连接的方式来完成，或者在启动 daemon 时通过 <code>-g</code> 参数指定，或者修改配置文件 <code>/etc/docker/daemon.json</code> 的 “data-root” 项 。可以使用 <code>docker system info | grep &quot;Root Dir&quot;</code> 查看当前使用的存储位置。</p>
<p>例如，如下操作将默认存储位置迁移到 /storage/docker。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@s26 ~]# <span class="built_in">df</span> -h</span><br><span class="line">Filesystem                    Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/VolGroup-lv_root   50G  5.3G   42G  12% /</span><br><span class="line">tmpfs                          48G  228K   48G   1% /dev/shm</span><br><span class="line">/dev/sda1                     485M   40M  420M   9% /boot</span><br><span class="line">/dev/mapper/VolGroup-lv_home  222G  188M  210G   1% /home</span><br><span class="line">/dev/sdb2                     2.7T  323G  2.3T  13% /storage</span><br><span class="line">[root@s26 ~]# service docker stop</span><br><span class="line">[root@s26 ~]# <span class="built_in">cd</span> /var/lib/</span><br><span class="line">[root@s26 lib]# <span class="built_in">mv</span> docker /storage/</span><br><span class="line">[root@s26 lib]# <span class="built_in">ln</span> -s /storage/docker/ docker</span><br><span class="line">[root@s26 lib]# <span class="built_in">ls</span> -la docker</span><br><span class="line">lrwxrwxrwx. 1 root root 15 11月 17 13:43 docker -&gt; /storage/docker</span><br><span class="line">[root@s26 lib]# service docker start</span><br></pre></td></tr></table></figure>
<h3 id="使用内存和-swap-限制启动容器时候报警告：“WARNING-Your-kernel-does-not-support-cgroup-swap-limit-WARNING-Your-kernel-does-not-support-swap-limit-capabilities-Limitation-discarded-”？"><a href="#%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E5%92%8C-swap-%E9%99%90%E5%88%B6%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8%E6%97%B6%E5%80%99%E6%8A%A5%E8%AD%A6%E5%91%8A-warning-your-kernel-does-not-support-cgroup-swap-limit-warning-your-kernel-does-not-support-swap-limit-capabilities-limitation-discarded">#</a> 使用内存和 swap 限制启动容器时候报警告：“WARNING: Your kernel does not support cgroup swap limit. WARNING: Your kernel does not support swap limit capabilities. Limitation discarded.”？</h3>
<p>答：这是因为系统默认没有开启对内存和 swap 使用的统计功能，引入该功能会带来性能的下降。要开启该功能，可以采取如下操作：</p>
<ul>
<li>
<p>编辑 <code>/etc/default/grub</code> 文件（Ubuntu 系统为例），配置 <code>GRUB_CMDLINE_LINUX=&quot;cgroup_enable=memory swapaccount=1&quot;</code></p>
</li>
<li>
<p>更新 grub：<code>$ sudo update-grub</code></p>
</li>
<li>
<p>重启系统，即可。</p>
</li>
</ul>
<h2 id="Docker-与虚拟化"><a href="#docker-%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%8C%96">#</a> Docker 与虚拟化</h2>
<h3 id="Docker-与-LXC（Linux-Container）有何不同？"><a href="#docker-%E4%B8%8E-lxc-linux-container-%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C">#</a> Docker 与 LXC（Linux Container）有何不同？</h3>
<p>答：LXC 利用 Linux 上相关技术实现了容器。Docker 则在如下的几个方面进行了改进：</p>
<ul>
<li>移植性：通过抽象容器配置，容器可以实现从一个平台移植到另一个平台；</li>
<li>镜像系统：基于 OverlayFS 的镜像系统为容器的分发带来了很多的便利，同时共同的镜像层只需要存储一份，实现高效率的存储；</li>
<li>版本管理：类似于Git的版本管理理念，用户可以更方便的创建、管理镜像文件；</li>
<li>仓库系统：仓库系统大大降低了镜像的分发和管理的成本；</li>
<li>周边工具：各种现有工具（配置管理、云平台）对 Docker 的支持，以及基于 Docker的 PaaS、CI 等系统，让 Docker 的应用更加方便和多样化。</li>
</ul>
<h3 id="Docker-与-Vagrant-有何不同？"><a href="#docker-%E4%B8%8E-vagrant-%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C">#</a> Docker 与 Vagrant 有何不同？</h3>
<p>答：两者的定位完全不同。</p>
<ul>
<li>
<p>Vagrant 类似 Boot2Docker（一款运行 Docker 的最小内核），是一套虚拟机的管理环境。Vagrant 可以在多种系统上和虚拟机软件中运行，可以在 Windows，Mac 等非 Linux 平台上为 Docker 提供支持，自身具有较好的包装性和移植性。</p>
</li>
<li>
<p>原生的 Docker 自身只能运行在 Linux 平台上，但启动和运行的性能都比虚拟机要快，往往更适合快速开发和部署应用的场景。</p>
</li>
</ul>
<p>简单说：Vagrant 适合用来管理虚拟机，而 Docker 适合用来管理应用环境。</p>
<h3 id="开发环境中-Docker-和-Vagrant-该如何选择？"><a href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%AD-docker-%E5%92%8C-vagrant-%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9">#</a> 开发环境中 Docker 和 Vagrant 该如何选择？</h3>
<p>答：Docker 不是虚拟机，而是进程隔离，对于资源的消耗很少，但是目前需要 Linux 环境支持。Vagrant 是虚拟机上做的封装，虚拟机本身会消耗资源。</p>
<p>如果本地使用的 Linux 环境，推荐都使用 Docker。</p>
<p>如果本地使用的是 macOS 或者 Windows 环境，那就需要开虚拟机，单一开发环境下 Vagrant 更简单；多环境开发下推荐在 Vagrant 里面再使用 Docker 进行环境隔离。</p>
<h2 id="其它"><a href="#%E5%85%B6%E5%AE%83">#</a> 其它</h2>
<h3 id="Docker-能在非-Linux-平台（比如-Windows-或-macOS-）上运行么？"><a href="#docker-%E8%83%BD%E5%9C%A8%E9%9D%9E-linux-%E5%B9%B3%E5%8F%B0-%E6%AF%94%E5%A6%82-windows-%E6%88%96-macos-%E4%B8%8A%E8%BF%90%E8%A1%8C%E4%B9%88">#</a> Docker 能在非 Linux 平台（比如 Windows 或 macOS ）上运行么？</h3>
<p>答：完全可以。安装方法请查看 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/install/">安装 Docker</a> 一节</p>
<h3 id="如何将一台宿主主机的-Docker-环境迁移到另外一台宿主主机？"><a href="#%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%80%E5%8F%B0%E5%AE%BF%E4%B8%BB%E4%B8%BB%E6%9C%BA%E7%9A%84-docker-%E7%8E%AF%E5%A2%83%E8%BF%81%E7%A7%BB%E5%88%B0%E5%8F%A6%E5%A4%96%E4%B8%80%E5%8F%B0%E5%AE%BF%E4%B8%BB%E4%B8%BB%E6%9C%BA">#</a> 如何将一台宿主主机的 Docker 环境迁移到另外一台宿主主机？</h3>
<p>答：停止 Docker 服务。将整个 Docker 存储文件夹复制到另外一台宿主主机，然后调整另外一台宿主主机的配置即可。</p>
<h3 id="如何进入-Docker-容器的网络命名空间？"><a href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5-docker-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">#</a> 如何进入 Docker 容器的网络命名空间？</h3>
<p>答：Docker 在创建容器后，删除了宿主主机上 <code>/var/run/netns</code> 目录中的相关的网络命名空间文件。因此，在宿主主机上是无法看到或访问容器的网络命名空间的。</p>
<p>用户可以通过如下方法来手动恢复它。</p>
<p>首先，使用下面的命令查看容器进程信息，比如这里的 1234。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect --format=<span class="string">&#x27;&#123;&#123;. State.Pid&#125;&#125; &#x27;</span> <span class="variable">$container_id</span></span><br><span class="line">1234</span><br></pre></td></tr></table></figure>
<p>接下来，在 <code>/proc</code> 目录下，把对应的网络命名空间文件链接到 <code>/var/run/netns</code> 目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">ln</span> -s /proc/1234/ns/net /var/run/netns/</span><br></pre></td></tr></table></figure>
<p>然后，在宿主主机上就可以看到容器的网络命名空间信息。例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> ip netns show</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>
<p>此时，用户可以通过正常的系统命令来查看或操作容器的命名空间了。例如修改容器的 IP 地址信息为 <code>172.17.0.100/16</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> 1234 ifconfig eth0 172.17.0.100/16</span><br></pre></td></tr></table></figure>
<h3 id="如何获取容器绑定到本地那个-veth-接口上？"><a href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%AE%B9%E5%99%A8%E7%BB%91%E5%AE%9A%E5%88%B0%E6%9C%AC%E5%9C%B0%E9%82%A3%E4%B8%AA-veth-%E6%8E%A5%E5%8F%A3%E4%B8%8A">#</a> 如何获取容器绑定到本地那个 veth 接口上？</h3>
<p>答：Docker 容器启动后，会通过 veth 接口对连接到本地网桥，veth 接口命名跟容器命名毫无关系，十分难以找到对应关系。</p>
<p>最简单的一种方式是通过查看接口的索引号，在容器中执行 <code>ip a</code> 命令，查看到本地接口最前面的接口索引号，如 <code>205</code>，将此值加上 1，即 <code>206</code>，然后在本地主机执行 <code>ip a</code> 命令，查找接口索引号为 <code>206</code> 的接口，两者即为连接的 veth 接口对。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2018/04/16/docker/15.Docker%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="../11/"
                aria-label="上一頁"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>上一頁</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="../13/"
                aria-label="下一頁"
            >
              <span>下一頁</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">第 12 頁 共 24 頁</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 234 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
