
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"Website","@id":"https://chankein.github.io","author":{"@type":"Person","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg"},"name":"Kein's blog","description":"","url":"https://chankein.github.io"}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Kein&#39;s blog">
<meta property="og:url" content="https://chankein.github.io/page/8/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Kein Chan">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../#about"
            >
        
        
            <img class="header-picture" src="../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2022/12/15/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%9C%8D%E5%8A%A1Travis-CI%E6%95%99%E7%A8%8B/"
                            aria-label=": 持续集成服务Travis CI教程"
                        >
                            持续集成服务Travis CI教程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-12-15T15:15:55+08:00">
	
		    2022 年 12 月 15 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../categories/devops/">devops</a>, <a class="category-link" href="../../categories/devops/CI-CD/">CI/CD</a>, <a class="category-link" href="../../categories/devops/CI-CD/TravisCI/">TravisCI</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>编写代码只是软件开发的一小部分，更多的时间往往花在构建（build）和测试（test）。</p>
<p>为了提高软件开发的效率，构建和测试的自动化工具层出不穷。<a target="_blank" rel="noopener" href="https://travis-ci.org/">Travis CI</a> 就是这类工具之中，<a target="_blank" rel="noopener" href="https://github.com/blog/2463-github-welcomes-all-ci-tools">市场份额</a>最大的一个。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017121901.png" alt=""></p>
<p>本文介绍 Travis CI 的基本用法。用好这个工具不仅可以提高效率，还能使开发流程更可靠和专业化，从而提高软件的价值。而且，它对于开源项目是免费的，不花一分钱，就能帮你做掉很多事情。</p>
<h2 id="一、什么是持续集成？">一、什么是持续集成？</h2>
<p>Travis CI 提供的是持续集成服务（Continuous Integration，简称 CI）。它绑定 Github 上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。</p>
<p>持续集成指的是只要代码有变更，就自动运行构建和测试，反馈运行结果。确保符合预期以后，再将新代码&quot;集成&quot;到主干。</p>
<p>持续集成的好处在于，每次代码的小幅变更，就能看到运行结果，从而不断累积小的变更，而不是在开发周期结束时，一下子合并一大块代码。</p>
<h2 id="二、使用准备">二、使用准备</h2>
<p>Travis CI 只支持 Github，不支持其他代码托管服务。这意味着，你必须满足以下条件，才能使用 Travis CI。</p>
<blockquote>
<ul>
<li>拥有 GitHub 帐号</li>
<li>该帐号下面有一个项目</li>
<li>该项目里面有可运行的代码</li>
<li>该项目还包含构建或测试脚本</li>
</ul>
</blockquote>
<p>如果这些条件都没问题，就可以开始使用 Travis CI 了。</p>
<p>首先，访问官方网站 <a target="_blank" rel="noopener" href="https://travis-ci.org/">travis-ci.org</a>，点击右上角的个人头像，使用 Github 账户登入 Travis CI。</p>
<p>Travis 会列出 Github 上面你的所有仓库，以及你所属于的组织。此时，选择你需要 Travis 帮你构建的仓库，打开仓库旁边的开关。一旦激活了一个仓库，Travis 会监听这个仓库的所有变化。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017121902.png" alt=""></p>
<h2 id="三、-travis-yml">三、.travis.yml</h2>
<p>Travis 要求项目的根目录下面，必须有一个<code>.travis.yml</code>文件。这是配置文件，指定了 Travis 的行为。该文件必须保存在 Github 仓库里面，一旦代码仓库有新的 Commit，Travis 就会去找这个文件，执行里面的命令。</p>
<p>这个文件采用 <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2016/07/yaml.html">YAML</a> 格式。下面是一个最简单的 Python 项目的<code>.travis.yml</code>文件。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">language</span>: python</span><br><span class="line"><span class="attr">script</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，设置了两个字段。<code>language</code>字段指定了默认运行环境，这里设定使用 Python 环境。<code>script</code>字段指定要运行的脚本，<code>script: true</code>表示不执行任何脚本，状态直接设为成功。</p>
<p>Travis 默认提供的运行环境，请参考<a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/languages">官方文档</a> 。目前一共支持31种语言，以后还会不断增加。</p>
<p>下面是一个稍微复杂一点的<code>.travis.yml</code>。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">language</span>: python</span><br><span class="line"><span class="attr">sudo</span>: required</span><br><span class="line"><span class="attr">before_install</span>: sudo pip install foo</span><br><span class="line"><span class="attr">script</span>: py.<span class="property">test</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，设置了四个字段：运行环境是 Python，需要<code>sudo</code>权限，在安装依赖之前需要安装<code>foo</code>模块，然后执行脚本<code>py.test</code>。</p>
<h2 id="四、运行流程">四、运行流程</h2>
<p>Travis 的运行流程很简单，任何项目都会经过两个阶段。</p>
<blockquote>
<ul>
<li>install 阶段：安装依赖</li>
<li>script 阶段：运行脚本</li>
</ul>
</blockquote>
<h3 id="4-1-install-字段">4.1 install 字段</h3>
<p><code>install</code>字段用来指定安装脚本。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">install</span>: ./install-dependencies.<span class="property">sh</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果有多个脚本，可以写成下面的形式。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">install</span>:</span><br><span class="line">  - command1</span><br><span class="line">  - command2</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，如果<code>command1</code>失败了，整个构建就会停下来，不再往下进行。</p>
<p>如果不需要安装，即跳过安装阶段，就直接设为<code>true</code>。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">install</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="4-2、script-字段">4.2、script 字段</h3>
<p><code>script</code>字段用来指定构建或测试脚本。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">script</span>: bundle exec thor build</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果有多个脚本，可以写成下面的形式。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">script</span>:</span><br><span class="line">  - command1</span><br><span class="line">  - command2</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意，<code>script</code>与<code>install</code>不一样，如果<code>command1</code>失败，<code>command2</code>会继续执行。但是，整个构建阶段的状态是失败。</p>
<p>如果<code>command2</code>只有在<code>command1</code>成功后才能执行，就要写成下面这样。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">script</span>: command1 &amp;&amp; command2</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="4-3-实例：Node-项目">4.3 实例：Node 项目</h3>
<p>Node 项目的环境需要写成下面这样。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">language</span>: node_js</span><br><span class="line"><span class="attr">node_js</span>:</span><br><span class="line">  - <span class="string">&quot;8&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>node_js</code>字段用来指定 Node 版本。</p>
<p>Node 项目的<code>install</code>和<code>script</code>阶段都有默认脚本，可以省略。</p>
<blockquote>
<ul>
<li><code>install</code>默认值：npm install</li>
<li><code>script</code>默认值：npm test</li>
</ul>
</blockquote>
<p>更多设置请看<a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/languages/javascript-with-nodejs/">官方文档</a>。</p>
<h3 id="4-4-部署">4.4 部署</h3>
<p><code>script</code>阶段结束以后，还可以设置<a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/notifications/">通知步骤</a>（notification）和<a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/deployment/">部署步骤</a>（deployment），它们不是必须的。</p>
<p>部署的脚本可以在<code>script</code>阶段执行，也可以使用 Travis 为几十种常见服务提供的快捷部署功能。比如，要部署到 <a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/deployment/pages/">Github Pages</a>，可以写成下面这样。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">deploy</span>:</span><br><span class="line">  <span class="attr">provider</span>: pages</span><br><span class="line">  <span class="attr">skip_cleanup</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attr">github_token</span>: $GITHUB_TOKEN # <span class="title class_">Set</span> <span class="keyword">in</span> travis-ci.<span class="property">org</span> dashboard</span><br><span class="line">  <span class="attr">on</span>:</span><br><span class="line">    <span class="attr">branch</span>: master</span><br></pre></td></tr></table></figure>
</blockquote>
<p>其他部署方式，请看<a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/deployment/">官方文档</a>。</p>
<h3 id="4-5-钩子方法">4.5 钩子方法</h3>
<p>Travis 为上面这些阶段提供了7个钩子。</p>
<blockquote>
<ul>
<li>before_install：install 阶段之前执行</li>
<li>before_script：script 阶段之前执行</li>
<li>after_failure：script 阶段失败时执行</li>
<li>after_success：script 阶段成功时执行</li>
<li>before_deploy：deploy 步骤之前执行</li>
<li>after_deploy：deploy 步骤之后执行</li>
<li>after_script：script 阶段之后执行</li>
</ul>
</blockquote>
<p>完整的生命周期，从开始到结束是下面的流程。</p>
<blockquote>
<ol>
<li>before_install</li>
<li>install</li>
<li>before_script</li>
<li>script</li>
<li>after<em>success or after</em>failure</li>
<li>[OPTIONAL] before_deploy</li>
<li>[OPTIONAL] deploy</li>
<li>[OPTIONAL] after_deploy</li>
<li>after_script</li>
</ol>
</blockquote>
<p>下面是一个<code>before_install</code>钩子的例子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">before_install</span>:</span><br><span class="line">  - sudo apt-get -qq update</span><br><span class="line">  - sudo apt-get install -y libxml2-dev</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码表示<code>before_install</code>阶段要做两件事，第一件事是要更新依赖，第二件事是安装<code>libxml2-dev</code>。用到的几个参数的含义如下：<code>-qq</code>表示减少中间步骤的输出，<code>-y</code>表示如果需要用户输入，总是输入<code>yes</code>。</p>
<h3 id="4-6-运行状态">4.6 运行状态</h3>
<p>最后，Travis 每次运行，可能会返回四种状态。</p>
<blockquote>
<ul>
<li>passed：运行成功，所有步骤的退出码都是<code>0</code></li>
<li>canceled：用户取消执行</li>
<li>errored：<code>before_install</code>、<code>install</code>、<code>before_script</code>有非零退出码，运行会立即停止</li>
<li>failed ：<code>script</code>有非零状态码 ，会继续运行</li>
</ul>
</blockquote>
<h2 id="五、使用技巧">五、使用技巧</h2>
<h3 id="5-1-环境变量">5.1 环境变量</h3>
<p><code>.travis.yml</code>的<code>env</code>字段可以定义环境变量。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">env</span>:</span><br><span class="line">  - <span class="variable constant_">DB</span>=postgres</span><br><span class="line">  - <span class="variable constant_">SH</span>=bash</span><br><span class="line">  - <span class="variable constant_">PACKAGE_VERSION</span>=<span class="string">&quot;1.0.*&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后，脚本内部就使用这些变量了。</p>
<p>有些环境变量（比如用户名和密码）不能公开，这时可以通过 Travis 网站，写在每个仓库的设置页里面，Travis 会自动把它们加入环境变量。这样一来，脚本内部依然可以使用这些环境变量，但是只有管理员才能看到变量的值。具体操作请看<a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/environment-variables">官方文档</a>。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017121903.png" alt=""></p>
<h3 id="5-2-加密信息">5.2 加密信息</h3>
<p>如果不放心保密信息明文存在 Travis 的网站，可以使用 Travis 提供的加密功能。</p>
<p>首先，安装 Ruby 的包<code>travis</code>。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ gem install travis</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后，就可以用<code>travis encrypt</code>命令加密信息。</p>
<p>在项目的根目录下，执行下面的命令。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ travis encrypt SOMEVAR=secretvalue</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令中，<code>SOMEVAR</code>是要加密的变量名，<code>secretvalue</code>是要加密的变量值。执行以后，屏幕上会输出如下信息。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">secure: <span class="string">&quot;.... encrypted data ....&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>现在，就可以把这一行加入<code>.travis.yml</code>。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">env</span>:</span><br><span class="line">  <span class="attr">global</span>:</span><br><span class="line">    - <span class="attr">secure</span>: <span class="string">&quot;.... encrypted data ....&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后，脚本里面就可以使用环境变量<code>$SOMEVAR</code>了，Travis 会在运行时自动对它解密。</p>
<p><code>travis encrypt</code>命令的<code>--add</code>参数会把输出自动写入<code>.travis.yml</code>，省掉了修改<code>env</code>字段的步骤。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ travis encrypt SOMEVAR=secretvalue --add</span><br></pre></td></tr></table></figure>
</blockquote>
<p>详细信息请看<a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/encryption-keys/">官方文档</a>。</p>
<h3 id="5-3-加密文件">5.3 加密文件</h3>
<p>如果要加密的是文件（比如私钥），Travis 提供了加密文件功能。</p>
<p>安装命令行客户端以后，使用下面的命令登入 Travis CI。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ travis login </span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后，进入项目的根目录，使用<code>travis encrypt-file</code>命令加密那些想要加密的文件。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ travis encrypt-file bacon.txt</span><br><span class="line"></span><br><span class="line">encrypting bacon.txt <span class="keyword">for</span> rkh/travis-encrypt-file-example</span><br><span class="line">storing result as bacon.txt.enc</span><br><span class="line">storing secure <span class="built_in">env</span> variables <span class="keyword">for</span> decryption</span><br><span class="line"></span><br><span class="line">Please add the following to your build script (before_install stage <span class="keyword">in</span> your .travis.yml, <span class="keyword">for</span> instance):</span><br><span class="line"></span><br><span class="line">    openssl aes-256-cbc -K <span class="variable">$encrypted_0a6446eb3ae3_key</span> -iv <span class="variable">$encrypted_0a6446eb3ae3_key</span> -<span class="keyword">in</span> bacon.txt.enc -out bacon.txt -d</span><br><span class="line"></span><br><span class="line">Pro Tip: You can add it automatically by running with --add.</span><br><span class="line"></span><br><span class="line">Make sure to add bacon.txt.enc to the git repository.</span><br><span class="line">Make sure not to add bacon.txt to the git repository.</span><br><span class="line">Commit all changes to your .travis.yml.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的代码对文件<code>bacon.txt</code>进行加密，加密后会生成<code>bacon.txt.enc</code>，该文件需要提交到代码库。此外，该命令还会生成一个环境变量<code>$encrypted_0a6446eb3ae3_key</code>，保存密钥，储存在 Travis CI，文件解密时需要这个环境变量。你需要把解密所需的<code>openssl</code>命令，写在<code>.travis.yml</code>的<code>before_install</code>字段里面。这些都写在上面的命令行提示里面。</p>
<p><code>--add</code>参数可以自动把环境变量写入<code>.travis.yml</code>。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ travis encrypt-file bacon.txt --add</span><br><span class="line"></span><br><span class="line">encrypting bacon.txt <span class="keyword">for</span> rkh/travis-encrypt-file-example</span><br><span class="line">storing result as bacon.txt.enc</span><br><span class="line">storing secure <span class="built_in">env</span> variables <span class="keyword">for</span> decryption</span><br><span class="line"></span><br><span class="line">Make sure to add bacon.txt.enc to the git repository.</span><br><span class="line">Make sure not to add bacon.txt to the git repository.</span><br><span class="line">Commit all changes to your .travis.yml.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>详细信息请看<a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/encrypting-files/">官方文档</a>，实际的例子可以参考下面两篇文章。</p>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://gist.github.com/domenic/ec8b0fc8ab45f39403dd">Auto-deploying built products to gh-pages with Travis</a></li>
<li><a target="_blank" rel="noopener" href="https://oncletom.io/2016/travis-ssh-deploy/">SSH deploys with Travis CI</a></li>
</ul>
</blockquote>
<p>（完）</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2022/12/15/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%9C%8D%E5%8A%A1Travis-CI%E6%95%99%E7%A8%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2022/11/05/Redis%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"
                            aria-label=": Redis使用详解"
                        >
                            Redis使用详解
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-11-05T13:42:45+08:00">
	
		    2022 年 11 月 5 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../categories/%E5%90%8E%E7%AB%AF/">后端</a>, <a class="category-link" href="../../categories/%E5%90%8E%E7%AB%AF/Redis/">Redis</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="Redis使用详解">Redis使用详解</h2>
<h2 id="一、NoSQL简介">一、NoSQL简介</h2>
<h3 id="NoSQL分类">NoSQL分类</h3>
<ul>
<li>键值（Key-Value）存储数据库：这一类数据库主要会使用到一个hash表，如Redis、Oracle BDB</li>
<li>列存储数据库：通常是用来应对分布式存储的海量数据，键仍然存在但是他们指向了多个列，如HBase、Riak</li>
<li>文档型数据库：该类型的数据模型是版本化的文档，比如JSON,允许之间进行嵌套，如MongoDB</li>
</ul>
<h3 id="非关系型数据库特点">非关系型数据库特点</h3>
<ul>
<li>
<p>数据模型比较简单</p>
</li>
<li>
<p>对于数据库性能要求较高</p>
</li>
<li>
<p>不需要高度的数据一致性</p>
</li>
</ul>
<h2 id="二、Redis简介">二、Redis简介</h2>
<p>以key-value形式存储，不一定遵循传统数据库的一些基本要求（非关系的、分布式的、开源的、水平可扩展的）</p>
<p><strong>优点</strong>：对数据高并发读写</p>
<p>​ 对海量数据的高效率存储和访问</p>
<p>​ 对数据的可扩展性和高可用性</p>
<p><strong>缺点</strong>：无法做太复杂的关系模型</p>
<p><strong>Redis单线程</strong>：指处理我们的网络请求的时候只有一个线程来处理【文件刷盘等用的是多线程】</p>
<p><strong>Redis单线程的好处</strong>：</p>
<ul>
<li>
<p>Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽，单线程实现比较简单</p>
</li>
<li>
<p>单线程避免了不必要的上下文切换和竞争条件以及加锁释放锁操作</p>
</li>
<li>
<p>使用多路I/O复用模型，非阻塞IO</p>
</li>
</ul>
<h2 id="三、Redis的安装">三、Redis的安装</h2>
<p>第一步：准备工作【解压tar包，创建Redis相关目录】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-5.0.2.tar.gz </span><br><span class="line">mkdir /opt/redis</span><br><span class="line">mkdir /opt/redis/conf</span><br><span class="line">mkdir /opt/redis/data</span><br></pre></td></tr></table></figure>
<p>第二步：编译redis</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#进入解压后的tar包执行</span><br><span class="line">make </span><br><span class="line">#执行结束之后进入src目录</span><br><span class="line">cd src</span><br><span class="line">make install PREFIX=/opt/redis</span><br></pre></td></tr></table></figure>
<p>第三步：移动配置文件到conf目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf /opt/redis/conf</span><br></pre></td></tr></table></figure>
<p>额外配置：</p>
<ul>
<li>redis开机自启</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rc.local</span><br><span class="line">#加入</span><br><span class="line">/opt/redis/bin/redis-server /opt/redis/conf/redis.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>配置数据保存目录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/redis/conf/redis.conf</span><br><span class="line">#修改</span><br><span class="line">dir ./    ---&gt;    dir /opt/redis/data/</span><br></pre></td></tr></table></figure>
<h2 id="四、Redis基本通用命令">四、Redis基本通用命令</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>KEYS [pattern]</td>
<td>查找出匹配的key【生成环境禁止使用，数据量太大阻塞生成环境】</td>
</tr>
<tr>
<td>DBSIZE</td>
<td>统计key总数【使用的是redis的内部计数，并不是全部扫描，生产可用】</td>
</tr>
<tr>
<td>EXISTS key [key …]</td>
<td>检查key是否存在【存在返回1，不存在返回0】</td>
</tr>
<tr>
<td>DEL key [key…]</td>
<td>删除key【成功删除返回1，不存在此key返回0】</td>
</tr>
<tr>
<td>EXPIRE key seconds</td>
<td>设置过期时间</td>
</tr>
<tr>
<td>TTL key</td>
<td>查看剩余的过期时间【-2代表已不存在，-1代表永不过期】</td>
</tr>
<tr>
<td>PERSIST key</td>
<td>取消key的过期设置</td>
</tr>
<tr>
<td>TYPE key</td>
<td>查询key的类型</td>
</tr>
</tbody>
</table>
<h2 id="五、Redis数据类型及其使用">五、Redis数据类型及其使用</h2>
<blockquote>
<p>注意：redis操作下标都是闭区间的</p>
</blockquote>
<h3 id="字符串【String】">字符串【String】</h3>
<p>String的值类型可以为字符类型、数字类型、bit类型</p>
<p>String类型是包含很多中类型的特殊类型，并且是二进制安全的。比如序列化的对象进行存储，比如一张图片进行二进制存储，比如一个简单地字符串，数值等等。</p>
<p>使用场景：缓存、计数器、分布式锁等</p>
<table>
<thead>
<tr>
<th>常用命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>{ <strong>GET</strong> key }，{ <strong>MGET</strong> key [key …] }</td>
<td>得到String</td>
</tr>
<tr>
<td>{ <strong>SET</strong> key value }，{ <strong>MSET</strong> key value [key value …] }</td>
<td>设置String</td>
</tr>
<tr>
<td>{ <strong>SETNX</strong> key value }，{ <strong>MSETNX</strong> key value [key value …] }</td>
<td>如果不存在则设置</td>
</tr>
<tr>
<td><strong>SET</strong> key value XX</td>
<td>如果存在则设置</td>
</tr>
<tr>
<td><strong>SETEX</strong> key second value</td>
<td>设置过期时间</td>
</tr>
<tr>
<td>{ <strong>INCR</strong> key }，{ <strong>INCRBY</strong> key increment }</td>
<td>自增操作</td>
</tr>
<tr>
<td>{ <strong>DECR</strong> key }，{ <strong>DECRBY</strong> key decrement }</td>
<td>自减操作</td>
</tr>
<tr>
<td><strong>GETSET</strong> key value</td>
<td>得到就值设置新值</td>
</tr>
<tr>
<td><strong>APPEND</strong> key value</td>
<td>追加字符串</td>
</tr>
<tr>
<td><strong>STRLEN</strong> key</td>
<td>得到字符串长度，内部存有计数</td>
</tr>
<tr>
<td><strong>GETRANGE</strong> key start end</td>
<td>得到指定长度的value</td>
</tr>
<tr>
<td><strong>SETRANGE</strong> key offset value</td>
<td>设置指定偏移量字符串内容</td>
</tr>
</tbody>
</table>
<h3 id="哈希【Hash】">哈希【Hash】</h3>
<p>使用场景：存储具有一定结构化的数据</p>
<table>
<thead>
<tr>
<th>常用命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>HGET</strong> key field</td>
<td>得到key对应field的value</td>
</tr>
<tr>
<td><strong>HSET</strong> key field value</td>
<td>设置key对应field的value</td>
</tr>
<tr>
<td><strong>HDEL</strong> key field</td>
<td>删除key对应field的value</td>
</tr>
<tr>
<td><strong>HEXISTS</strong> key field</td>
<td>判断key的field是否存在</td>
</tr>
<tr>
<td><strong>HLEN</strong> key</td>
<td>获取指定key的filed数量【内部计数，生成环境可用】</td>
</tr>
<tr>
<td><strong>HMGET</strong> key field [field …]</td>
<td>批量获得hash的field对应的value</td>
</tr>
<tr>
<td><strong>HMSET</strong> key field value [field value …]</td>
<td>批量设置hash的field和value</td>
</tr>
<tr>
<td><strong>HINCRBY</strong> key field increment</td>
<td>增加指定increment的对应key的field</td>
</tr>
<tr>
<td><strong>HGETALL</strong> key</td>
<td>获取key对应所有field和value【生成环境慎用】</td>
</tr>
<tr>
<td><strong>HVALS</strong> key</td>
<td>返回key对应的所有value【生成环境慎用】</td>
</tr>
<tr>
<td><strong>HKEYS</strong> key</td>
<td>返回key对应的所有field【生成环境慎用】</td>
</tr>
<tr>
<td><strong>HSETNX</strong> key field value</td>
<td>不存在此key对应的field则设置</td>
</tr>
</tbody>
</table>
<h3 id="列表【List】">列表【List】</h3>
<p>列表为有序、可重复结构。可指定位置插入和删除、也可从左右插入和弹出（模拟栈结构）</p>
<table>
<thead>
<tr>
<th>常用命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>**LPUSH</td>
<td>RPUSH** key value [value …]</td>
</tr>
<tr>
<td><strong>LINSERT</strong> key BEFORE</td>
<td>AFTER value newValue</td>
</tr>
<tr>
<td>**LPOP</td>
<td>RPOP** key</td>
</tr>
<tr>
<td><strong>LREM</strong> key count value</td>
<td>根据count值，从列表删除所有等于value的值【时间复杂度O(N)】</td>
</tr>
<tr>
<td>【count&gt;0，从左到右删除count个】</td>
<td></td>
</tr>
<tr>
<td>【count&lt;0，从右到坐删除count个】</td>
<td></td>
</tr>
<tr>
<td>【count=0，删除所有value相等的值】</td>
<td></td>
</tr>
<tr>
<td><strong>LTRIM</strong> key start end</td>
<td>按照索引范围保留list，删除大链表有用【时间复杂度O(N)】</td>
</tr>
<tr>
<td><strong>LRANGR</strong> key start end</td>
<td>获取列表指定索引范围内的值，数值为负则从右往左取值【时间复杂度O(N)】</td>
</tr>
<tr>
<td><strong>LINDEX</strong> key index</td>
<td>获取列表指定索引的值，数值为负则从右取值【时间复杂度O(N)】</td>
</tr>
<tr>
<td><strong>LLEN</strong> key</td>
<td>获取list长度【内部计数，生成环境可用】</td>
</tr>
<tr>
<td><strong>LSET</strong> key index newValue</td>
<td>设置指定位置的值【时间复杂度O(N)】</td>
</tr>
<tr>
<td>**BLPOP</td>
<td>RLPOP** key timeout</td>
</tr>
</tbody>
</table>
<p>使用技巧：</p>
<ul>
<li>LPUSH + LPOP = Stack</li>
<li>LPUSH + RPOP = Queue</li>
<li>LPUSH + LTRIM = Capped Collection【固定容量集合】</li>
<li>LPUSH + BRPOP = Block Queue</li>
</ul>
<h3 id="集合【Set】">集合【Set】</h3>
<p>Set无序、无重复、有集合间操作。</p>
<table>
<thead>
<tr>
<th>常用命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SADD</strong> key element [member …]</td>
<td>向集合key添加元素</td>
</tr>
<tr>
<td><strong>SREM</strong> key element</td>
<td>删除集合key中的element元素</td>
</tr>
<tr>
<td><strong>SCARD</strong> key</td>
<td>查询集合元素的个数【内部计数，生成环境可用】</td>
</tr>
<tr>
<td><strong>SISMEMBER</strong> key element</td>
<td>集合中是否存在element元素</td>
</tr>
<tr>
<td><strong>SRANDMEMBER</strong> key</td>
<td>随机得到一个元素</td>
</tr>
<tr>
<td><strong>SMEMBERS</strong> key</td>
<td>获取集合所有元素【慎用】</td>
</tr>
<tr>
<td><strong>SPOP</strong> key</td>
<td>随机弹出一个元素</td>
</tr>
<tr>
<td>{ <strong>SDIFF</strong> key [key …] }、{ <strong>SDIFFSTORE</strong> destination key [key …] }</td>
<td>返回/存储一个集合的全部成员，该集合是所有给定集合之间的差集</td>
</tr>
<tr>
<td>{ <strong>SINTER</strong> key [key …] }、{ <strong>SINTERSTORE</strong> destination key [key …] }</td>
<td>返回/存储一个集合的全部成员，该集合是所有给定集合的交集</td>
</tr>
<tr>
<td>{ <strong>SUNION</strong> key [key …] }、{ <strong>SUNIONSTORE</strong> destination key [key …] }</td>
<td>返回/存储一个集合的全部成员，该集合是所有给定集合的并集</td>
</tr>
</tbody>
</table>
<p>使用技巧</p>
<ul>
<li>
<p>SADD = Tagging</p>
</li>
<li>
<p>SPOP/SRANDMEMBER = Random Item</p>
</li>
<li>
<p>SADD + SINTER = Social Graph【共同关注、有着相同兴趣等】</p>
</li>
</ul>
<h3 id="有序集合【ZSet】">有序集合【ZSet】</h3>
<p>ZSet有序、无重复、包含分值与元素，有集合间操作。</p>
<p>使用场景：排行榜</p>
<table>
<thead>
<tr>
<th>常用命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ZADD</strong> key score member [score member …]</td>
<td>向集合添加元素</td>
</tr>
<tr>
<td><strong>ZREM</strong> key member [member …]</td>
<td>移除集合中的元素</td>
</tr>
<tr>
<td><strong>ZSCORE</strong> key member</td>
<td>得到元素的分数</td>
</tr>
<tr>
<td><strong>ZINCRBY</strong> key increment member</td>
<td>增长元素的分数</td>
</tr>
<tr>
<td><strong>ZCARD</strong> key</td>
<td>获得集合中元素的个数</td>
</tr>
<tr>
<td><strong>ZRANK</strong> key member</td>
<td>成员按分值递减(从小到大)排列的排名</td>
</tr>
<tr>
<td><strong>ZRANGE</strong> key start stop [WITHSCORES]</td>
<td>按score值递增(从小到大)排序，WITHSCORES返回分数</td>
</tr>
<tr>
<td><strong>ZRANGEBYSCORE</strong> key max min [WITHSCORES]</td>
<td>返回分数范围内数据，按score值递增(从小到大)排序，WITHSCORES返回分数</td>
</tr>
<tr>
<td><strong>ZCOUNT</strong> key min max</td>
<td>统计得到分数在min和max之间的元素个数</td>
</tr>
<tr>
<td>{ <strong>ZREMRANGEBYRANK</strong> key start stop }、{ <strong>ZREMRANGEBYSCORE</strong> key min max}</td>
<td>按照排名/分数范围删除元素</td>
</tr>
<tr>
<td><strong>ZREVRANK</strong> key member</td>
<td>成员按分值递减(从大到小)排列的排名</td>
</tr>
<tr>
<td><strong>ZREVRANGE</strong> key start stop [WITHSCORES]</td>
<td>按score值递增(从大到小)排序，WITHSCORES返回分数</td>
</tr>
<tr>
<td><strong>ZREVRANGEBYSCORE</strong> key max min [WITHSCORES]</td>
<td>返回分数范围内数据，按score值递增(从大到小)排序，WITHSCORES返回分数</td>
</tr>
</tbody>
</table>
<h2 id="六、Redis高级功能">六、Redis高级功能</h2>
<h3 id="慢查询日志">慢查询日志</h3>
<p><img src="https://mynamelancelot.github.io/img/redis/Redis-Life-Cycle.png" alt="Redis-Life-Cycle"></p>
<ul>
<li>慢查询发生在第三阶段</li>
<li>客户端超时不一定是慢查询导致，但慢查询可导致客户端超时</li>
</ul>
<p><strong>慢查询队列简介</strong></p>
<ul>
<li>先进先出的队列</li>
<li>固定长度</li>
<li>长度不够时，丢弃最早记录</li>
<li>保存在内存中</li>
</ul>
<p><strong>慢查询设置</strong></p>
<ul>
<li>
<p>slow-max-len【慢查询队列长度，默认128】</p>
</li>
<li>
<p>slowlog-log-slower-than【慢查询的阙值（微秒，1000000 微秒=1 秒），默认10000（10毫秒），建议为1000（1毫秒）】</p>
</li>
</ul>
<blockquote>
<p>更改慢查询参数建议使用<code>CONFIG SET parameter value</code>方式，而不是更改redis.conf文件重启redis</p>
</blockquote>
<p><strong>慢查询命令</strong></p>
<table>
<thead>
<tr>
<th>常用命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>slowlog get n</td>
<td>获取慢查询队列一条记录</td>
</tr>
<tr>
<td>slowlog len</td>
<td>获取慢查询队列长度</td>
</tr>
<tr>
<td>slowlog reset</td>
<td>清空慢查询队列</td>
</tr>
</tbody>
</table>
<p><strong>查询结果示例</strong></p>
<p><img src="https://mynamelancelot.github.io/img/redis/Redis-Slow-Examples.png" alt="Redis-Slow-Examples"></p>
<h3 id="Pipeline">Pipeline</h3>
<p><img src="https://mynamelancelot.github.io/img/redis/Redis-Process.png" alt="Redis-Process"></p>
<p>一般情况下客户端发送一条命令到Redis，Redis处理结束返回结果，即 N条命令 = N次网络时间 + N次计算时间</p>
<p>PipeLine将命令打包发送给客户端，Redis处理完返回结果，PipLine是一个异步处理方式，并不等待Redis返回。</p>
<p>Pipeline(N条命令) = 1次网络时间 + N次计算时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Jest执行参考</span><br><span class="line"> */</span><br><span class="line">long oldPipeline = Instant.now().toEpochMilli();</span><br><span class="line">for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">    Pipeline pipeline = jedis.pipelined();</span><br><span class="line">    for (int j = 0; j &lt; 100; j++) &#123;</span><br><span class="line">        pipeline.sadd(&quot;S&quot; + i * 100 + j, j + &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //pipeline.sync();异步不接受返回结果</span><br><span class="line">    pipeline.syncAndReturnAll(); //异步接受返回结果</span><br><span class="line">&#125;</span><br><span class="line">long nowPipeline = Instant.now().toEpochMilli();</span><br><span class="line">System.out.println(nowPipeline - oldPipeline);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * Spring Data Redis参考</span><br><span class="line">  */</span><br><span class="line">// 批量插入</span><br><span class="line">redisTemplate.executePipelined(new RedisCallback&lt;Void&gt;() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public Void doInRedis(RedisConnection connection) throws DataAccessException &#123;</span><br><span class="line">    String keyPrefix = &quot;pipeline-&quot;;</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">      String key = keyPrefix + i;</span><br><span class="line">      connection.set(key.getBytes(), String.valueOf(i).getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 批量获取</span><br><span class="line">List&lt;Object&gt; data = redisTemplate.executePipelined(new RedisCallback&lt;String&gt;() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public String doInRedis(RedisConnection connection) throws DataAccessException &#123;</span><br><span class="line">    String keyPrefix = &quot;pipeline-&quot;;</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">      String key = keyPrefix + i;</span><br><span class="line">      connection.get(key.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">data.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="发布订阅">发布订阅</h3>
<table>
<thead>
<tr>
<th>常用命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>PUBLISH</strong> channel message</td>
<td>将信息 <code>message</code> 发送到指定的频道 <code>channel</code></td>
</tr>
<tr>
<td><strong>SUBSCRIBE</strong> channel [channel …]</td>
<td>订阅给定的一个或多个频道的信息</td>
</tr>
<tr>
<td><strong>PSUBSCRIBE</strong> pattern [pattern …]</td>
<td>订阅一个或多个符合给定pattern的频道</td>
</tr>
<tr>
<td><strong>UNSUBSCRIBE</strong> [channel [channel …]]</td>
<td>取消订阅</td>
</tr>
</tbody>
</table>
<h3 id="Bitmap">Bitmap</h3>
<table>
<thead>
<tr>
<th>常用命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SETBIT</strong> key offset value</td>
<td>对 key所储存的字符串值，设置或清除指定偏移量上的位(bit)</td>
</tr>
<tr>
<td><strong>GETBIT</strong> key offset</td>
<td>对 key所储存的字符串值，获取指定偏移量上的位(bit)</td>
</tr>
<tr>
<td><strong>BITCOUNT</strong> key [start] [end]</td>
<td>计算给定字符串中，被设置为 1的比特位的数量</td>
</tr>
<tr>
<td><strong>BITOP</strong> operation destkey key [key …]</td>
<td>对一个或多个保存二进制位的字符串 key进行位元操作，并将结果保存到 destkey上</td>
</tr>
<tr>
<td><code>operation</code> 可以是 <code>AND</code> 、 <code>OR</code> 、 <code>NOT</code> 、 <code>XOR</code> 这四种操作中的任意一种</td>
<td></td>
</tr>
<tr>
<td><strong>BITPOS</strong> key bit [start] [end]</td>
<td>返回位图中第一个值为 <code>bit</code>的二进制位的位置</td>
</tr>
</tbody>
</table>
<h3 id="HyperLogLog">HyperLogLog</h3>
<p>实质：用String类型实现，不能取出具体值，有错误率</p>
<p>作用：极小的空间实现独立数量统计</p>
<table>
<thead>
<tr>
<th>常用命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>PFADD</strong> key element [element …]</td>
<td>将任意数量的元素添加到指定的HyperLogLog</td>
</tr>
<tr>
<td><strong>PFCOUNT</strong> key [key …]</td>
<td>计算HyperLogLog有多少值</td>
</tr>
<tr>
<td><strong>PFMERGE</strong> destkey sourcekey [sourcekey …]</td>
<td>将多个HyperLogLog合并为一个HyperLogLog</td>
</tr>
</tbody>
</table>
<h3 id="Geo">Geo</h3>
<p>Geo(地理信息定位)：存储经纬度，计算两地距离，范围计算等</p>
<p>Geo是使用ZSet实现</p>
<table>
<thead>
<tr>
<th>常用命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>GEOADD</strong> key longitude latitude member [longitude latitude member …]</td>
<td>longitude：经度，latitude：维度，member：标识</td>
</tr>
<tr>
<td><strong>GEOPOS</strong> key member [member …]</td>
<td>返回经纬度</td>
</tr>
<tr>
<td><strong>GEODIST</strong> key member1 member2 [unit]</td>
<td>返回两个给定位置之间的距离</td>
</tr>
<tr>
<td><strong>GEORADIUS</strong> key longitude latitude radius m</td>
<td>km</td>
</tr>
<tr>
<td><strong>ZREM</strong> key member</td>
<td>删除成员</td>
</tr>
</tbody>
</table>
<h2 id="七、Redis持久化">七、Redis持久化</h2>
<h3 id="RDB【Redis-Database】">RDB【Redis Database】</h3>
<p>​ RDB是Redis用来进行持久化的一种方式，是把当前内存中的数据集快照写入磁盘，也就是 Snapshot 快照（数据库中所有键值对数据）。恢复时是将快照文件直接读到内存里。</p>
<p><strong>触发机制</strong></p>
<ul>
<li>
<p>save</p>
<p>手动触发，同步命令，会阻塞线程</p>
</li>
<li>
<p>bgsave</p>
<p>手动触发，fork出一个子进程，异步命令，不会阻塞线程【阻塞仅仅会发生在fork出子进程的阶段】</p>
</li>
<li>
<p>自动</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1            #900秒改变1个就生成rdb文件</span><br><span class="line">save 300 10           #300秒改变10个就生成rdb文件</span><br><span class="line">save 60  10000        #60秒改变10000个就生成rdb文件</span><br></pre></td></tr></table></figure>
<p>一般情况下建议关闭自动策略</p>
</li>
<li>
<p>全量复制</p>
<p>从节点执行全量复制操作的时候，主节点会自动触发bgsave命令生存rdb文件并发送给从节点</p>
</li>
<li>
<p>debug reload</p>
<p>在执行debug reload重新加载redis的时候，也会自动触发bgsave</p>
</li>
<li>
<p>shutdown</p>
<p>默认情况下执行shutdown命令，如果没有开启AOF持久化功能，就会自动执行bgsave</p>
</li>
</ul>
<p><strong>RDB配置参数</strong></p>
<table>
<thead>
<tr>
<th>命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>rdbcompression</td>
<td>压缩RDB文件，默认yes</td>
</tr>
<tr>
<td>rdbchecksum</td>
<td>RDB文件是否进行校验，默认yes</td>
</tr>
<tr>
<td>dbfilename dump.rdb</td>
<td>RDB文件名【可使用dump-端口号.rdb区分不同的redis实例】</td>
</tr>
<tr>
<td>dir ./</td>
<td>RDB文件存储的目录</td>
</tr>
<tr>
<td>stop-writes-on-bgsave-error</td>
<td>bgsave出现错误时是否停止写入，默认yes</td>
</tr>
</tbody>
</table>
<h3 id="AOF【Append-Only-File】">AOF【Append-Only File】</h3>
<p>​ AOF是一个追加写入的日志文件从而实现持久化的方式，生成的AOF文件是可识别的纯文本文件。Redis默认使用RDB持久，开启AOF持久化需要设置<code>appendonly</code>为<code>yes</code></p>
<p><strong>AOF文件生成策略</strong></p>
<ul>
<li>
<p>always 不丢失数据，每次更新记录数据就进行io操作</p>
</li>
<li>
<p>everysec 可能会丢失1s数据，但io小</p>
</li>
<li>
<p>no 不启用AOF</p>
</li>
</ul>
<p><strong>AOF重写</strong></p>
<p>​ AOF支持AOF文件重写（从内存中读取的数据，并非读取上次的AOF文件进行重写）。AOF重写可以减少硬盘占用、加速恢复速度。</p>
<p><img src="https://mynamelancelot.github.io/img/redis/Aof-Rewrite.png" alt="Aof-Rewrite"></p>
<p><strong>AOF配置参数</strong></p>
<table>
<thead>
<tr>
<th>命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>appendonly</td>
<td>是否开启AOF，默认no</td>
</tr>
<tr>
<td>appendfilename</td>
<td>生成AOF文件明【可使用appendonly-端口号.aof区分不同的redis实例】</td>
</tr>
<tr>
<td>appendfsync</td>
<td>刷盘策略，默认everysecond</td>
</tr>
<tr>
<td>dir</td>
<td>保存文件的目录，默认./</td>
</tr>
<tr>
<td>no-appendfsync-on-rewrite</td>
<td>AOF重写过程中是否禁止append操作，默认no允许append</td>
</tr>
<tr>
<td>auto-aof-rewrite-min-size</td>
<td>进行AOF时文件最小尺寸，默认64mb</td>
</tr>
<tr>
<td>auto-aof-rewrite-percentage</td>
<td>下次进行AOF操作时的增量，默认100</td>
</tr>
<tr>
<td>aof-load-truncated</td>
<td>AOF文件结尾不完整，Redis重启忽略不完整记录，默认yes</td>
</tr>
</tbody>
</table>
<p>命令</p>
<ul>
<li>bgrewriteaof 手动进行AOF重写操作</li>
<li>aof_current_size 查看AOF当前尺寸</li>
</ul>
<p><code>redis-cli info Persistence</code>可以查看统计信息<code>aof_current_size</code>【当前AOF文件大小】和<code>aof_base_size</code>【上次重写AOF文件大小】</p>
<h3 id="RDB与AOF比较">RDB与AOF比较</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>丢数据</td>
<td>根据策略决定</td>
</tr>
<tr>
<td>轻重</td>
<td>重</td>
<td>轻</td>
</tr>
</tbody>
</table>
<h3 id="混合持久化">混合持久化</h3>
<p>Redis 4.0 开始支持 rdb 和 aof 的混合持久化(默认开启)，这样做的好处是可以结合 rdb 和 aof 的优点, 快速加载同时避免丢失过多的数据。缺点 aof 里面的 rdb 部分就是压缩格式不再是 aof 格式，可读性差。</p>
<ul>
<li>
<p>配置开启混合持久化<code>aof-use-rdb-preamble yes</code></p>
</li>
<li>
<p>命令开启混合持久化<code>config set aof-use-rdb-preamble yes</code></p>
</li>
</ul>
<p>开启混合持久化时，aof rewrite 的时候就直接把 rdb 的内容写到 aof 文件开头。aof 文件内容会变成如下</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+------------------------+</span><br><span class="line">|                        |   </span><br><span class="line">|                        |   </span><br><span class="line">|          RDB           |   </span><br><span class="line">|         FORMAT         |   </span><br><span class="line">|                        |   </span><br><span class="line">|                        |   </span><br><span class="line">|                        |   </span><br><span class="line">+------------------------+</span><br><span class="line">|                        |   </span><br><span class="line">|        AOF             |   </span><br><span class="line">|       FORMAT           |   </span><br><span class="line">+------------------------+</span><br></pre></td></tr></table></figure>
<h3 id="持久化相关优化">持久化相关优化</h3>
<p><strong>fork操作优化</strong></p>
<ul>
<li>
<p>控制redis实例最大可用内存：maxmemory</p>
</li>
<li>
<p>合理配置Linux内存分配策略：vm.overcommit_momory=1(默认0，当内存少时fork阻塞不进行)</p>
</li>
<li>
<p>降低fork频率：例如放宽AOF重写自动触发时机，不必要的全量复制</p>
</li>
</ul>
<p><strong>子进程</strong></p>
<ul>
<li>
<p>cpu</p>
<p>开销：RDB和AOF文件生成，属于CPU密集型</p>
<p>优化：不做CPU绑定，不和CPU密集型服务部署</p>
</li>
<li>
<p>内存</p>
<p>开销：fork内存开销，使用了linux的copy-on-write【父进程未发生改变的内存页，不进行copy-write】</p>
<p>优化：echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled【不分配大内存页】</p>
</li>
<li>
<p>硬盘</p>
<p>开销：AOF和RDB文件写入，可以结合iostat，iotop分析</p>
<p>优化：不和高硬盘负载服务部署一起，<code>no-appendfsync-on-rewrite</code>设置为yes</p>
</li>
</ul>
<h2 id="八、Redis主从复制原理和优化">八、Redis主从复制原理和优化</h2>
<ul>
<li>一个master可以有多个slave</li>
<li>一个slave只能有一个master</li>
<li>数据流向是单向的，master到slave</li>
</ul>
<h3 id="主从实现两种方式">主从实现两种方式</h3>
<ul>
<li>
<p>在从机上执行<code>slaveof masterIp masterPort</code>，此命令是异步。<code>slaveof no one</code>结束从属关系。</p>
</li>
<li>
<p>修改redis配置文件</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slaveof masterIp masterPort               #配置主从</span><br><span class="line">slave-read-only  yes                      #从节点只读</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>主从状态查看<code>info replication</code></p>
</blockquote>
<h3 id="全量复制和部分复制">全量复制和部分复制</h3>
<p>redis4后使用psync2实现复制使redis重启也可使用部分同步，还为解决在主库故障时候从库切换为主库时候使用部分同步机制。redis从库默认开启复制积压缓冲区功能，以便从库故障切换变化master后，其他落后该从库可以从缓冲区中获取缺少的命令。该过程的实现通过两组replid、offset替换原来的master runid和offset变量实现：</p>
<ul>
<li>
<p>第一组：master_replid和master_repl_offset</p>
<p>如果redis是主实例，则表示为自己的replid和复制偏移量； 如果redis是从实例，则表示为自己主实例的replid1和同步主实例的复制偏移量。</p>
</li>
<li>
<p>第二组：master_replid2和second_repl_offset</p>
<p>无论主从，都表示自己上次主实例repid1和复制偏移量；用于兄弟实例或级联复制，主库故障切换psync</p>
</li>
</ul>
<p>判断是否使用部分复制条件：如果从库提供的master_replid与master的replid不同，且与master的replid2不同，或同步速度快于master； 就必须进行全量复制，否则执行部分复制。</p>
<p>以下常见的主从切换都可以使用部分复制：</p>
<ul>
<li>一主一从发生切换，A-&gt;B 切换变成 B-&gt;A</li>
<li>一主多从发生切换，兄弟节点变成父子节点时</li>
<li>级别复制发生切换， A-&gt;B-&gt;C 切换变成 B-&gt;C-&gt;A</li>
</ul>
<h3 id="全量复制开销">全量复制开销</h3>
<ul>
<li>bgsave时间</li>
<li>RDB文件网络时间</li>
<li>从节点清空数据时间</li>
<li>从节点加载RDB时间</li>
<li>可能的AOF重写时间</li>
</ul>
<p>当从库与主库断开时间过长导致自己的偏移量不在<code>master_repl_offset</code>允许的范围之内，会触发全量复制</p>
<h3 id="主从相关参数配置">主从相关参数配置</h3>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">##############从库##############</span><br><span class="line"></span><br><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt; </span><br><span class="line">#设置该数据库为其他数据库的从数据库</span><br><span class="line"></span><br><span class="line">masterauth &lt;master-password&gt;</span><br><span class="line">#主从复制中，设置连接master服务器的密码（前提master启用了认证）</span><br><span class="line"></span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"># 当从库同主库失去连接或者复制正在进行，从库有两种运行方式：</span><br><span class="line"># 1) 如果slave-serve-stale-data设置为yes(默认设置)，从库会继续相应客户端的请求</span><br><span class="line"># 2) 如果slave-serve-stale-data设置为no，除了INFO和SLAVOF命令之外的任何请求都会返回一个错误&quot;SYNC with master in progress&quot;</span><br><span class="line"></span><br><span class="line">slave-priority 100</span><br><span class="line">#当主库发生宕机时候，哨兵会选择优先级最高的一个称为主库，从库优先级配置默认100，数值越小优先级越高</span><br><span class="line"></span><br><span class="line">slave-read-only yes</span><br><span class="line">#从节点是否只读；默认yes只读，为了保持数据一致性，应保持默认</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############主库##############</span><br><span class="line"></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line">#在slave和master同步后（发送psync/sync），后续的同步是否设置成TCP_NODELAY假如设置成yes，则redis会合并小的TCP包从而节省带宽，但会增加同步延迟（40ms），造成master与slave数据不一致假如设置成no，则redis master会立即发送同步数据，没有延迟</span><br><span class="line">#前者关注性能，后者关注一致性</span><br><span class="line"></span><br><span class="line">repl-ping-slave-period 10</span><br><span class="line">#从库会按照一个时间间隔向主库发送PING命令来判断主服务器是否在线，默认是10秒</span><br><span class="line"></span><br><span class="line">repl-backlog-size 1mb</span><br><span class="line">#复制积压缓冲区大小设置</span><br><span class="line"></span><br><span class="line">repl-backlog-ttl 3600</span><br><span class="line">#master没有slave一段时间会释放复制缓冲区的内存，repl-backlog-ttl用来设置该时间长度。单位为秒。</span><br><span class="line"></span><br><span class="line">min-slaves-to-write 3</span><br><span class="line">min-slaves-max-lag 10</span><br><span class="line">#设置某个时间断内，如果从库数量小于该某个值则不允许主机进行写操作，以上参数表示10秒内如果主库的从节点小于3个，则主库不接受写请求，min-slaves-to-write 0代表关闭此功能。</span><br></pre></td></tr></table></figure>
<p><strong>主从配置问题</strong></p>
<p>maxmomory不一致导致丢失数据</p>
<p>数据结构参数优化只有优化了主机，从机未配置导致内存不一致，数据错误或丢失</p>
<h2 id="九、Redis-Sentinel">九、Redis Sentinel</h2>
<ul>
<li>主观下线：Sentinel根据配置条件，发现redis节点达到故障标准，则此Sentinel认为此redis节点下线</li>
<li>客观下线：当Sentinel中认为此redis客观下线的总数达到配置阙值，则认为此节点客观下线</li>
</ul>
<h3 id="安装Sentinel">安装Sentinel</h3>
<p>配置sentinel.conf文件</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#没有开启bind和密码的情况下，保护模式默认被开启。只接受来自环回IPv4和IPv6地址的连接。拒绝外部连接</span><br><span class="line">bind 127.0.0.1 192.168.1.1</span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line">#端口</span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line">#是否守护进程模式运行</span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line">#pid以及日志文件位置</span><br><span class="line">pidfile /var/run/redis-sentinel.pid</span><br><span class="line">logfile &quot;&quot;</span><br><span class="line"></span><br><span class="line">#工作目录</span><br><span class="line">dir /tmp</span><br><span class="line"></span><br><span class="line">#监控的master</span><br><span class="line">#mymaster指此主从组的名称【Sentinel可以监控多个主从组】</span><br><span class="line">#最后一个数字代码多少个sentinel主观认为此master宕机为客观宕机事实</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line">#当多少毫秒master不返回ping结果即认为主观宕机</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line">#master重新选举之后slave并发复制master数据的并发量</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line">#故障转移超时时间，默认为3分钟</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line">#当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会调用这个脚本</span><br><span class="line">#如果脚本以“1”退出，则稍后重试执行（最多可执行10次），脚本的最长运行时间为60秒</span><br><span class="line">#sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"></span><br><span class="line">#当master因failover而发生改变，这个脚本将被调用，通知相关的客户端关于master地址已经发生改变的信息</span><br><span class="line">#sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br><span class="line"></span><br><span class="line">#不允许使用SENTINEL SET设置notification-script和client-reconfig-script</span><br><span class="line">sentinel deny-scripts-reconfig yes</span><br></pre></td></tr></table></figure>
<h3 id="Sentinel三个定时任务">Sentinel三个定时任务</h3>
<ul>
<li>每10秒每个sentinel对master和slave执行info
<ul>
<li>发现slave</li>
<li>确认主从关系</li>
</ul>
</li>
<li>每2秒每个sentinel通过master节点的channel交换信息（pub/sub模式）
<ul>
<li>通过<code>__sentinel__:hello</code>频道交互</li>
<li>交互各节点的“看法”及自身信息</li>
</ul>
</li>
<li>每1秒每个sentinel对其他sentinel和redis节点执行ping
<ul>
<li>心跳检查、失败依据</li>
</ul>
</li>
</ul>
<h3 id="Master选举过程">Master选举过程</h3>
<p><strong>第一步：Sentinel选举出leader</strong></p>
<p>原因：只需要一个Sentinel完成故障转移</p>
<p>选举：通过<code>sentinel is-master-down-by-addr</code>命令都希望自己成为领导者</p>
<ul>
<li>每个做主观下线的Sentinel节点向其它Sentinel节点发送命令，要求它给自己投票</li>
<li>收到命令的Sentinel节点如果没有同意其它Sentinel节点发送的命令，则同意投票否则拒绝</li>
<li>如果该Sentinel节点发现自己的票数已经超过Sentinel半数，那么它将成为leader</li>
<li>如果此过程未选出leader则等待一段时间继续选举</li>
</ul>
<p><strong>第二步：故障转移选举Master</strong></p>
<ul>
<li>
<p>从slave节点中选出一个“合适”的节点作为新的master节点</p>
<ul>
<li>选择<code>slave-prority</code>最高的slave节点，如果存在则返回【一般不修改】</li>
<li>选择复制偏移量最大的slave节点，如果存在则返回</li>
<li>选择runId最小的slave节点</li>
</ul>
</li>
<li>
<p>对上面的slave节点执行<code>slaveof no one</code>命令让其成为master节点</p>
</li>
<li>
<p>向剩余的slave节点发送<code>slaveof</code>命令，让它们成为master节点的slave节点，复制规则和<code>paraller-sync</code>参数有关</p>
</li>
<li>
<p>更新对原来master节点配置为slave，并保存对其“关注”，当其恢复后命令它去复制新的master节点</p>
</li>
</ul>
<blockquote>
<p>手动下线master机器<code>sentinel failover &lt;masterName&gt;</code></p>
</blockquote>
<h2 id="十、Redis-Cluster">十、Redis Cluster</h2>
<h3 id="数据分布概论">数据分布概论</h3>
<p><img src="https://mynamelancelot.github.io/img/redis/Data-Distribution.png" alt="Data-Distribution"></p>
<table>
<thead>
<tr>
<th>分布方式</th>
<th>特点</th>
<th>典型产品</th>
</tr>
</thead>
<tbody>
<tr>
<td>哈希分布</td>
<td>数据分散度高</td>
<td></td>
</tr>
<tr>
<td>Memcache</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Redis Cluster</p>
<p>|<br>
| 键值分布业务无关 |<br>
| 无法顺序访问 |<br>
| 支持批量操作 |<br>
| 顺序分布 | 数据分散度易倾斜 |</p>
<p>BigTable</p>
<p>HBase</p>
<p>|<br>
| 键值分布业务相关 |<br>
| 可顺序访问 |<br>
| 支持批量操作 |</p>
<h3 id="哈希分布方式">哈希分布方式</h3>
<p><strong>节点取余分区</strong></p>
<p><img src="https://mynamelancelot.github.io/img/redis/Delivery-Partition.png" alt="Delivery-Partition"></p>
<p>进行取模运算，将余数相等的放入同一节点，简单易操作，增加节点时数据偏移,导致数据的前移达到80%，翻倍扩容可以使数据迁移从80%降到50%</p>
<p><strong>一致性hash分区</strong></p>
<p><img src="https://mynamelancelot.github.io/img/redis/Consistency-Hash.png" alt="Consistency-Hash"></p>
<p>为系统中每个节点分配一个token，范围一般在0~2的32次方，这些token构成哈希环。数据读写执行节点查找操作时，先根据key计算hash值，然后顺时针找到第一个大于等于该哈希值的token节点，往往一个节点会对应多个token。加减节点会造成哈希环中部分数据无法命中，需要手动处理或者忽略这些数据，常用于缓存场景</p>
<p><strong>虚拟哈希分区</strong></p>
<p><img src="https://mynamelancelot.github.io/img/redis/Slot-Partition.png" alt="Slot-Partition"></p>
<p>虚拟分槽使用哈希函数把所有数据映射到一个固定范围的整数集合中，整数定义为槽（slot）。槽数范围远远大于节点数（redisCluster槽的范围是0~16383），每一个节点负责维护一部分槽以及所映射的键值数据</p>
<h3 id="基本架构">基本架构</h3>
<p><img src="https://mynamelancelot.github.io/img/redis/cluster-architecture.jpg" alt="cluster-architecture"></p>
<ul>
<li>
<p>所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽</p>
</li>
<li>
<p>节点的fail是通过集群中超过半数的master节点检测失效时才生效</p>
</li>
<li>
<p>客户端与redis节点直连,不需要中间proxy层.客户端连接集群中任何一个可用节点即可</p>
</li>
<li>
<p>redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;key</p>
</li>
</ul>
<h3 id="安装Cluster">安装Cluster</h3>
<p>修改redis配置文件</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cluster-enable yes</span><br><span class="line">cluster-config-file nodes-$&#123;port&#125;.conf</span><br></pre></td></tr></table></figure>
<p><strong>原生安装</strong></p>
<ul>
<li>
<p>启动所有节点</p>
</li>
<li>
<p>执行<code>redis-cli -p $&#123;port&#125; cluster meet $&#123;ip&#125; $&#123;port&#125;</code>使节点相遇</p>
</li>
<li>
<p>执行<code>cluster addslots slot [slot...]</code>分配槽</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">start=$1</span><br><span class="line">end=$2</span><br><span class="line">port=$3</span><br><span class="line">for slot in `seq $&#123;start&#125; $&#123;end&#125;`</span><br><span class="line">do</span><br><span class="line">  echo &quot;slot:$&#123;slot&#125;&quot;</span><br><span class="line">  /opt/redis/bin/redis-cli -p $&#123;port&#125; cluster addslots $&#123;slot&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>执行<code>redis-cli -p $&#123;port&#125; cluster replicate $&#123;nodeId&#125;</code>执行主从分配</p>
</li>
</ul>
<p><strong>集群命令安装</strong></p>
<ul>
<li>
<p><code>redis-cli --cluster create --cluster-replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</code></p>
<p>–cluster-replicas代表集群的每个主节点的从节点个数</p>
<blockquote>
<p>ruby安装已废弃</p>
</blockquote>
</li>
</ul>
<p><strong>cluster配置参数</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cluster-enable yes</span><br><span class="line">cluster-config-file nodes-$&#123;port&#125;.conf</span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line">cluster-require-full-coverage yes 		#必须集群所有节点能提供服务才提供服务</span><br></pre></td></tr></table></figure>
<h3 id="集群伸缩">集群伸缩</h3>
<p><strong>扩展集群</strong></p>
<p>扩展步骤原理</p>
<ol>
<li>对目标节点发送cluster setslot {slot} importing {targetNodeId}命令，让目标节点准备导入槽的数据</li>
<li>对源节点发送cluster setslot {slot} migrating {sourceNodeId}命令，让源节点准备槽数据的导出</li>
<li>源节点上循环执行cluster getkeyinslot {slot} count 命令，每次获取属于这个槽中键的个数</li>
<li>在源节点上执行migrate {sourceIp} {sourcePort} key 0 {timeout}命令，迁移指定的key</li>
<li>重复执行步骤3~4直到槽下所有数据完成迁移</li>
<li>向集群内所有主节点发送cluster setslot {slot} node {targetNodeId}命令，通知槽分配给目标节点</li>
</ol>
<p><img src="https://mynamelancelot.github.io/img/redis/Cluster-Expend.png" alt="Cluster-Expend"></p>
<p>扩展执行步骤</p>
<ul>
<li>
<p>加入集群</p>
<p>执行<code>redis-cli -p $&#123;port&#125; cluster meet $&#123;ip&#125; $&#123;port&#125;</code>将节点加入集群</p>
</li>
<li>
<p>设置主从关系</p>
<p><code>redis-cli -p $&#123;port&#125; cluster replicate $&#123;nodeId&#125;</code>设置主从关系</p>
</li>
<li>
<p>任意节点执行迁移槽命令，后续过程根据提示进行</p>
<p><code>redis-cli --cluster reshard &#123;ip&#125;:&#123;port&#125;</code></p>
</li>
<li>
<p>查看节点分配情况</p>
<p><code>redis-cli -p &#123;prot&#125; cluster nodes | grep master</code></p>
</li>
</ul>
<p><strong>集群缩容</strong></p>
<p><img src="https://mynamelancelot.github.io/img/redis/Cluster-Shrink.png" alt="Cluster-Shrink"></p>
<p>迁移槽命令和扩展集群的迁移命令相同，迁移完成之后使用<code>redis-cli cluster forget &#123;downNodeId&#125;</code>下线节点</p>
<ul>
<li>
<p>迁移数据</p>
<p><code>redis-cli --cluster reshard &#123;ip&#125;:&#123;port&#125; --cluster-from &#123;sourceNodeId&#125; --cluster-to &#123;targetNodeId&#125; --cluster-slots &#123;slotsNum&#125;</code></p>
</li>
<li>
<p>下线节点</p>
<p><code>redis-cli --cluster del-node &#123;ip&#125;:&#123;port&#125; &#123;shutdownNodeId&#125;</code></p>
</li>
</ul>
<h3 id="客户端路由">客户端路由</h3>
<blockquote>
<p>使用cluster keyslot ${key}可查看key对应的hash值</p>
</blockquote>
<p><strong>moved重定向</strong></p>
<p><img src="https://mynamelancelot.github.io/img/redis/Cluster-Move.png" alt="Cluster-Move"></p>
<p><strong>ask重定向</strong></p>
<p><img src="https://mynamelancelot.github.io/img/redis/Cluster-Ask.png" alt="Cluster-Ask"></p>
<p><strong>smart客户端</strong></p>
<p>实现原理：追求性能</p>
<ol>
<li>从集群中选一个可运行节点，使用<code>cluster slots</code>初始化槽和节点映射</li>
<li>将cluster slots的结果映射到本地缓存，为每个节点创建JedisPool</li>
<li>准备执行命令(使用CRC16计算key对应的槽，找到映射节点执行)</li>
</ol>
<p><img src="https://mynamelancelot.github.io/img/redis/Smart-Client.png" alt="Smart-Client"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Set&lt;HostAndPort&gt; nodes = new HashSet&lt;HostAndPort&gt;();</span><br><span class="line">    nodes.add(new HostAndPort(&quot;192.168.1.158&quot;, 7000));</span><br><span class="line">    nodes.add(new HostAndPort(&quot;192.168.1.158&quot;, 7001));</span><br><span class="line">    nodes.add(new HostAndPort(&quot;192.168.1.158&quot;, 7002));</span><br><span class="line">    nodes.add(new HostAndPort(&quot;192.168.1.158&quot;, 7003));</span><br><span class="line">    nodes.add(new HostAndPort(&quot;192.168.1.158&quot;, 7004));</span><br><span class="line">    nodes.add(new HostAndPort(&quot;192.168.1.158&quot;, 7005));</span><br><span class="line">    JedisCluster jedisCluster = new JedisCluster(nodes);</span><br><span class="line">    jedisCluster.set(&quot;hello&quot;, &quot;cluster&quot;);</span><br><span class="line">    System.out.println(jedisCluster.get(&quot;hello&quot;));</span><br><span class="line">    jedisCluster.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="批量操作">批量操作</h3>
<p>Redis主要提供了以下几种批量操作方式：</p>
<ul>
<li>批量get/set(multi get/set)</li>
<li>管道(pipelining)</li>
<li>事务(transaction)</li>
<li>基于事务的管道(transaction in pipelining)</li>
</ul>
<p>批量操作必须key在同一个槽，导致以上用法异常苛刻</p>
<p><strong>方案一：传统的串行IO操作，也就说n个key，分n次串行操作来获取key，复杂度是o(n)</strong></p>
<p><strong>方案二：将mget操作(n个key)，利用已知的hash函数算出key对应的节点，这样就可以得到一个这样的关系：Map&lt;node, somekeys&gt;，也就是每个节点对应的一些keys，这样将之前的o(n)的效率降低到o(node.size())</strong></p>
<p><img src="https://mynamelancelot.github.io/img/redis/MuliCmd-Serial-Io.webp" alt="MuliCmd-Serial-Io"></p>
<p><strong>方案三：在方案二的基础上将串行取数据改为并行取数据，进一步提高效率</strong></p>
<p><img src="https://mynamelancelot.github.io/img/redis/MuliCmd-parell-Io.webp" alt="MuliCmd-parell-Io"></p>
<p><strong>方案四：通过redis自带的hashtag功能，强制一批key分配到某台机器上【不建议，大量数据会造成数据倾斜】</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//使用&#123;user&#125;作为key，使key统一</span><br><span class="line">jedisCluster.mset(&quot;&#123;user&#125;1001&quot;,&quot;zhangsan&quot;,&quot;&#123;user&#125;1002&quot;,&quot;lisi&quot;,&quot;&#123;user&#125;1003&quot;,&quot;wangwu&quot;);</span><br><span class="line">List&lt;String&gt; users = jedisCluster.mget(&quot;&#123;user&#125;1001&quot;,&quot;&#123;user&#125;1002&quot;,&quot;&#123;user&#125;1003&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="故障转移">故障转移</h3>
<p><strong>故障发现</strong></p>
<ul>
<li>通过ping/pong信息实现故障发现，当半数以上持有槽的主节点都标记某节点主观下线则为客观下线【向集群广播下线节点的fail消息】</li>
<li>客观下线发送通知故障节点的从节点触发故障转义流程</li>
</ul>
<p><strong>故障恢复</strong></p>
<ul>
<li>资格审查
<ul>
<li>每个从节点检查与故障主节点的断线时间</li>
<li>超过<code>cluster-node-timeout * cluster-slave-validity-factor</code>取消资格</li>
<li><code>cluster-slave-validity-factor</code>默认是10</li>
</ul>
</li>
<li>准备选举时间
<ul>
<li>最接近主节点的偏移量的从节点率先发起选举，稍后其他从节点发起选举</li>
</ul>
</li>
<li>选举投票
<ul>
<li>收集票数大于N/2+1即为选举成功</li>
</ul>
</li>
<li>替换主节点
<ul>
<li>当前从节点取消复制变为主节点（slave no one）</li>
<li>执行clusterDelSlot撤销故障主节点负责的槽，并执行clusterAddSlot把这些槽分配给自己</li>
<li>向集群广播自己的pong消息，表明已经替换了故障从节点</li>
</ul>
</li>
</ul>
<h3 id="集群运维问题">集群运维问题</h3>
<p><strong>集群完整性</strong></p>
<p><code>cluster-require-full-coverage yes</code>默认为yes</p>
<ul>
<li>集群中16384个槽全部可用：保证集群完整性</li>
<li>节点故障或者正在故障转移，集群不可使用</li>
</ul>
<p>大多数情况下业务无法容忍，建议<code>cluster-require-full-coverage</code>设置为no</p>
<p><strong>PubSub广播</strong></p>
<p>任意节点发布消息所有节点都会订阅到消息，消耗带宽较多。JedisCluster只会订阅任意一个节点</p>
<p><strong>数据倾斜</strong></p>
<p>造成的原因：</p>
<ul>
<li>节点槽分配不均</li>
<li>不同槽对应的键值数量差异较大【可能存在hashTag】</li>
<li>包含bigkey</li>
<li>内存相关配置不一致</li>
</ul>
<blockquote>
<p>使用<code>redis-cli --cluster info &#123;ip&#125;:&#123;port&#125;</code>可以查看key、slot分布情况</p>
<p>使用<code>redis-cli --cluster rebalance &#123;ip&#125;:&#123;port&#125;</code>进行数据平衡【慎用】</p>
</blockquote>
<p><strong>从机读写问题</strong></p>
<p>在集群模式下从节点不接受任何读写请求</p>
<ul>
<li>命令会重定向到负责槽的主节点</li>
<li>readonly命令可以读取【连接级别】</li>
</ul>
<p><strong>数据迁移</strong></p>
<p>官方工具不只能从单机向集群迁移，不支持断点续传，不支持在线迁移，单线程影响速度，不建议使用官方工具</p>
<h2 id="十一、缓存设计与优化">十一、缓存设计与优化</h2>
<h3 id="缓存使用的成本">缓存使用的成本</h3>
<ul>
<li>数据不一致：缓存层和数据层有时间窗口不一致，和更新策略有关</li>
<li>代码维护成本：多了一层缓存逻辑</li>
<li>运维成本：例如Redis Cluster</li>
</ul>
<h3 id="缓存更新策略">缓存更新策略</h3>
<p>redis里面存储的过期时间，都是绝对时间点，所以如果两台机器时钟不同步，那么超过的数据会全部删除。</p>
<ul>
<li>slaves不会独立删除数据，而是等待master给它发送删除指令的时候，再删除数据</li>
<li>如果slave当选为master的时候，会先淘汰keys，然后再成为master</li>
</ul>
<hr>
<ul>
<li>
<p>设置<code>maxmemory-policy</code>值指定算法</p>
<table>
<thead>
<tr>
<th>更新策略</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>volatile-lru</td>
<td>过期的键使用LRU策略剔除，没有可删除对象则退回到noeviction</td>
</tr>
<tr>
<td>allkeys-lru</td>
<td>所有键均使用LRU策略剔除，直到腾出足够空间</td>
</tr>
<tr>
<td>volatile-lfu</td>
<td>过期的键使用LFU策略剔除，没有可删除对象则退回到noeviction</td>
</tr>
<tr>
<td>allkeys-lfu</td>
<td>所有键均使用LFU策略剔除，直到腾出足够空间</td>
</tr>
<tr>
<td>volatile-random</td>
<td>过期的键使用随机策略剔除，没有可删除对象则退回到noeviction</td>
</tr>
<tr>
<td>allkeys-random</td>
<td>所有键均使用随机策略剔除，直到腾出足够空间</td>
</tr>
<tr>
<td>volatile-ttl</td>
<td>剔除TTL最小的键，没有可删除对象则退回到noeviction</td>
</tr>
<tr>
<td>noeviction</td>
<td>默认策略，不做任何事，返回写错误</td>
</tr>
</tbody>
</table>
<blockquote>
<p>LRU【Least Recently Used】最近最少被使用</p>
<p>LFU【Least Frequently Used】最不常用</p>
</blockquote>
</li>
<li>
<p>被动更新</p>
<p>当客户端方位key的时候，主动检测这些key是否过期，过期就删除</p>
</li>
<li>
<p>主动更新</p>
<p>每秒检测10次以下操作，测试随机的20个keys进行相关过期检测，删除所有的过期的keys，如果有多于25%的keys过期，重复此操作</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>策略</th>
<th>一致性</th>
<th>维护成本</th>
</tr>
</thead>
<tbody>
<tr>
<td>算法剔除</td>
<td>最差</td>
<td>低</td>
</tr>
<tr>
<td>被动更新</td>
<td>较差</td>
<td>低</td>
</tr>
<tr>
<td>主动更新</td>
<td>强</td>
<td>高</td>
</tr>
</tbody>
</table>
<blockquote>
<p>低一致性：最大内存和淘汰策略</p>
<p>高一致性：超时剔除和主动更新结合，最大内存和淘汰策略兜底</p>
</blockquote>
<h3 id="缓存穿透-缓存雪崩-无底洞">缓存穿透&amp;缓存雪崩&amp;无底洞</h3>
<p><strong>缓存穿透</strong></p>
<p><img src="https://mynamelancelot.github.io/img/redis/Cache-Miss.png" alt="Cache-Miss"></p>
<p>特点：</p>
<p>当缓存和数据库中都没有数据的时候，当查询Redis没有数据的时候，会继续查询数据库，数据库也没有数据，当大量查询请求发生或遭到恶意攻击时，这些访问全部透过Redis，并且数据库也没有数据，这种现象称为“缓存穿透”。</p>
<p>解决方案：</p>
<ol>
<li>缓存空对象，storage返回一个空对象，将键存储在缓存层，下次请求此键之间返回空对象
<ul>
<li>需要更多的键，建议设置过期时间</li>
<li>缓存层和存储层数据“短期”不一致</li>
</ul>
</li>
<li><a href="#bloomFilter">布隆过滤器</a></li>
</ol>
<p><strong>缓存击穿</strong></p>
<p>特点：</p>
<p>当Redis的热点数据key失效时，大量并发查询直接打到数据库，此时数据库负载压力骤增，这种现象称为“缓存击穿”</p>
<p><img src="https://mynamelancelot.github.io/img/redis/hotkey-expir.png" alt="hotkey-expir"></p>
<p>解决方案：</p>
<p>1.设置key值永不过期</p>
<p>2.使用互斥锁，查到后就回填缓存</p>
<p><strong>缓存雪崩</strong></p>
<p>特点：</p>
<p>缓存雪崩是指在短时间内，有大量缓存同时过期，导致大量的请求直接查询数据库，从而对数据库造成了巨大的压力，严重情况下可能会导致数据库宕机的情况叫做缓存雪崩。</p>
<p><img src="https://mynamelancelot.github.io/img/redis/crash.png" alt="crash"></p>
<p>解决方案：</p>
<ul>
<li>随机设置key过期时间</li>
<li>随机延时，让一部分查询先将数据缓存起来</li>
<li>设置key值永不过期</li>
</ul>
<p><strong>无底洞问题</strong></p>
<p>现象：增加节点机器性能没提升反而下降</p>
<p><img src="https://mynamelancelot.github.io/img/redis/Cache-Node-Add.png" alt="Cache-Node-Add"></p>
<p>解决方案参考<a href="#Multi-Operator">批量操作</a></p>
<h3 id="热点key的重建优化">热点key的重建优化</h3>
<p><img src="https://mynamelancelot.github.io/img/redis/Hot-Key.png" alt="Hot-Key"></p>
<p>现象：热点key缓存重建过程过长导致浪费了不必要的资源</p>
<p>解决方案：</p>
<ol>
<li>
<p>互斥锁【使用redis构建锁机制】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String get(String key) &#123;</span><br><span class="line">    String value = redis.get(key);</span><br><span class="line">    if(value == null) &#123;</span><br><span class="line">        String mutexKey = &quot;mutex:key:&quot;+key;</span><br><span class="line">        if(redis.SetParams.setParams().ex(180).nx()) &#123;</span><br><span class="line">            value = db.get(key);</span><br><span class="line">            redis.set(key,value);</span><br><span class="line">            redis.delete(mutexKey);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>永不过期</p>
<ul>
<li>缓存层面：没有设置过期时间</li>
<li>功能层面：为每个value添加逻辑过期时间，但发现超过逻辑过期时间后，会使用单独的线程取构建缓存</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>互斥锁</td>
<td>思路简单</td>
<td>代码复杂度增加</td>
</tr>
<tr>
<td>保证一致性</td>
<td>存在死锁的风险</td>
<td></td>
</tr>
<tr>
<td>永不过期</td>
<td>基本杜绝热点key重建问题</td>
<td>不保证一致性</td>
</tr>
<tr>
<td>逻辑过期时间增加维护成本和内存成本</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="十二、Redis布隆过滤器">十二、Redis布隆过滤器</h2>
<h3 id="布隆过滤器的原理">布隆过滤器的原理</h3>
<p><img src="https://mynamelancelot.github.io/img/redis/Bloom-Filter.jpg" alt="Bloom-Filter"></p>
<ol>
<li>首先需要k个hash函数，每个函数可以把key散列成为1个整数</li>
<li>初始化时，需要一个长度为n比特的数组，每个比特位初始化为0</li>
<li>某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1</li>
<li>判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中</li>
</ol>
<p>优点：不需要存储key，节省空间</p>
<p>缺点：算法判断key在集合中时，有一定的概率key其实不在集合中，且无法删除</p>
<blockquote>
<p>google-guava库实现了java版的布隆过滤器</p>
</blockquote>
<h3 id="Redis布隆过滤器">Redis布隆过滤器</h3>
<p><strong>使用插件的方式部署</strong></p>
<p>redis4.0之后支持使用插件的方式使用Bloom filters和cuckoo filters，redis4.0之前需手动使用代码的方式编写布隆过滤器，安装步骤参考下列链接</p>
<p><a target="_blank" rel="noopener" href="https://github.com/RedisLabsModules/redisbloom">GitHub地址</a> <a target="_blank" rel="noopener" href="http://redisbloom.io/">使用文档</a></p>
<p>建议在conf配置文件中配置，不使用<code>redis-server --loadmodule /path/to/rebloom.so</code>启动</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadmodule /path/to/rebloom.so</span><br></pre></td></tr></table></figure>
<p><strong>布隆过滤器命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>BF.RESERVE</strong> {key} {error_rate} {size}</td>
<td>创建布隆过滤器，error_rate为错误率，size为预期数据大小</td>
</tr>
<tr>
<td><strong>BF.ADD</strong> {key} {item}</td>
<td>添加item到指定布隆过滤器</td>
</tr>
<tr>
<td><strong>BF.MADD</strong> {key} {item} [item …]</td>
<td>批量添加item到指定布隆过滤器</td>
</tr>
<tr>
<td><strong>BF.EXISTS</strong> {key} {item}</td>
<td>判断item是否存在与指定布隆过滤器</td>
</tr>
<tr>
<td><strong>BF.MEXISTS</strong> {key} {item} [item …]</td>
<td>批量判断item是否存在与指定布隆过滤器</td>
</tr>
</tbody>
</table>
<p><strong>JavaAPI</strong></p>
<p>导入maven依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.redislabs&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jrebloom&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>Api使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    JedisPool jedisPool = new JedisPool(&quot;192.168.1.158&quot;, 6379);</span><br><span class="line">    Client client = new Client(jedisPool);</span><br><span class="line">    client.createFilter(&quot;main6&quot;, 10000, 0.000001);</span><br><span class="line">    //批量插入数据</span><br><span class="line">    for (int i = 0; i &lt;100; i++) &#123;</span><br><span class="line">        String values[] = new String[100];</span><br><span class="line">        for (int j = 0; j &lt; 100; j++) &#123;</span><br><span class="line">            String value = &quot;item&quot; + (i * 100 +j);</span><br><span class="line">            values[j] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        client.addMulti(&quot;main6&quot;, values);</span><br><span class="line">    &#125;</span><br><span class="line">	//判断是否存在</span><br><span class="line">    System.out.println(client.exists(&quot;main6&quot;, &quot;item1&quot;));</span><br><span class="line">    System.out.println(client.exists(&quot;main6&quot;, &quot;a&quot;));</span><br><span class="line">    jedisPool.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="十三、Redis开发规范">十三、Redis开发规范</h2>
<h3 id="BigKey处理">BigKey处理</h3>
<p><strong>发现BigKey</strong></p>
<ul>
<li><code>debug object &#123;key&#125;</code> 查看指定key的详细信息</li>
<li><code>redis-cli --bigkeys</code> 扫描出BigKey【全表扫描，阻塞，建议从节点本地执行】</li>
</ul>
<p><strong>BigKey删除</strong></p>
<p>场景：当key非常大时，delete命令执行十分缓慢，会发生阻塞【过期bigkey也是进行删除操作也会阻塞】</p>
<p>redis4.0之后：可以使用<code>unlink</code>命令进行后台删除，不阻塞前台</p>
<h3 id="生命周期管理">生命周期管理</h3>
<ul>
<li>
<p>使用<code>OBJECT IDLETIME &#123;key&#125;</code>查看key的闲置时间</p>
</li>
<li>
<p>过期时间不易集中</p>
</li>
</ul>
<h3 id="命令优化">命令优化</h3>
<p>有遍历需求可以使用<code>hscan</code>、<code>sscan</code>、<code>zscan</code>代替【<strong>这些扫描命令在field较少时COUNT参数不会生效</strong>】</p>
<p>必要情况下使用<code>monitor</code>命令监控，注意时间不要过长</p>
<h3 id="Java客户端优化">Java客户端优化</h3>
<table>
<thead>
<tr>
<th>参数名</th>
<th>含义</th>
<th>默认值</th>
<th>建议</th>
</tr>
</thead>
<tbody>
<tr>
<td>testWhileIdle</td>
<td>是否开启空闲资源检测</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>timeBetweenEvictionRunsMillis</td>
<td>空闲资源检测周期</td>
<td>-1</td>
<td>自选，也可使用JedisPoolConfig中的默认值</td>
</tr>
<tr>
<td>minEvictiableIdleTimeMillis</td>
<td>资源池中资源最小空闲时间</td>
<td>30分钟</td>
<td>自选，也可使用JedisPoolConfig中的默认值</td>
</tr>
<tr>
<td>numTestsPerEvictionRun</td>
<td>做空闲资源检测每次的采样数</td>
<td>3</td>
<td>自选，如果设置为-1则为全部做空闲检测</td>
</tr>
</tbody>
</table>
<p>maxIdle需要设置为接近maxTotal</p>
<blockquote>
<p>预估maxTotal方法的例子：</p>
<p>一次命令时间平均耗时1ms，一个连接QPS大约1000，业务期忘的QPS时50000，理论上maxTotal=50000/1000=50</p>
</blockquote>
<h2 id="十四、内存管理">十四、内存管理</h2>
<h3 id="内存消耗">内存消耗</h3>
<p><strong>内存统计</strong></p>
<p>执行<code>info memory</code>命令可以查看内存信息</p>
<table>
<thead>
<tr>
<th>主要属性名</th>
<th>属性说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>used_memory</td>
<td>实际存储数据的内存总量</td>
</tr>
<tr>
<td>used_memory_rss</td>
<td>redis进程占用的总物理内存</td>
</tr>
<tr>
<td>maxmemory</td>
<td>最大内存</td>
</tr>
<tr>
<td>maxmemory_policy</td>
<td>内存剔除策略</td>
</tr>
<tr>
<td>mem_fragmentation_ratio</td>
<td>used_memory_rss/used_memory比值，表示内存碎片率</td>
</tr>
</tbody>
</table>
<p><strong>内存消耗划分</strong></p>
<p><img src="https://mynamelancelot.github.io/img/redis/Memory-Used.png" alt="Memory-Used"></p>
<ul>
<li>
<p>客户端缓冲区设置规则</p>
<p>client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds></p>
<p><class>:客户端类型，分为三种</p>
<p>​ (a)normal:普通客户端</p>
<p>​ (b)slave:用从节点用于复制，伪裝成客户端</p>
<p>​ ©pubsub:发布订阅客户端 <hardlimit>:如客户使用的输出冲区大于hardlimit客户端会被立即关闭</p>
<p><soft limit> 和<soft seconds>:如果客户端使用的输出缓冲区超过了 <soft limit>并且持续了<soft seconds>，客户会被立即关闭</p>
<ul>
<li>普通客户端默认：client-output-buffer-limit normal 0 0 0</li>
<li>salve客户端默认：client-output-buffer-limit slave 256mb 64mb 60</li>
<li>pubsub客户端默认：client-output-buffer-limit slave 32mb 8mb 60</li>
</ul>
</li>
<li>
<p>复制缓冲区：用于slave和master断开重连时不进行全量复制保存偏移数据使用</p>
<p>默认为<code>repl-backlog-size 1mb</code></p>
</li>
<li>
<p>AOF缓冲区：AOF重写期间，AOF缓冲区，没有容量限制</p>
</li>
</ul>
<h3 id="内存回收策略">内存回收策略</h3>
<p>删除过期值</p>
<ul>
<li>惰性删除：访问key-&gt;expired dict-&gt;del key【先在过期表中找，发现过期删除key，返回null】</li>
<li>定时删除：每秒运行10次，采样删除</li>
</ul>
<p>超过maxmemory使用maxmemory-policy进行控制，参见<a href="#cache_update">缓存更新策略</a></p>
<h2 id="十五、开发运维事项">十五、开发运维事项</h2>
<h3 id="Linux内核优化">Linux内核优化</h3>
<p><strong>vm.overcommit_memory</strong></p>
<p>Redis建议vm.overcommit_memory = 1(影响fork操作）</p>
<p>立即生效：</p>
<p>永久生效：vm.overcommit_memory = 1写入到/etc/sysctl.conf文件中</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>表示内核将检查是否有足够可用的内存。如果有足够可用的内存，内存申请通过，否则内存申请失败，并返回错误给进程</td>
</tr>
<tr>
<td>1</td>
<td>表示内核允许超量使用内存直到用完为止</td>
</tr>
<tr>
<td>2</td>
<td>表示内存绝不过量使用，即整个系统内存不能超过swap+50%的RAM值</td>
</tr>
</tbody>
</table>
<p><strong>swappiness</strong></p>
<table>
<thead>
<tr>
<th>值</th>
<th>策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Linux3.5及以上：宁愿OOM Killer也不用swap</td>
</tr>
<tr>
<td>Linux3.5及以下：宁愿swap也不用OOM Killer</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>Linux3.5及以上：宁愿swap也不用OOM Killer</td>
</tr>
<tr>
<td>60</td>
<td>默认值</td>
</tr>
<tr>
<td>100</td>
<td>操作系统会主动使用swap</td>
</tr>
</tbody>
</table>
<p>建议：Linux3.5以上vm.swappiness = 1，否则vm.swappiness = 0</p>
<p>立即生效：echo {bestValue} &gt; /proc/sys/vm/swappiness</p>
<p>永久生效：vm.swappiness = {bestValue} 写入到/etc/sysctl.conf</p>
<p><strong>THP(Transparent huge page)</strong></p>
<p>建议禁用，Centos7在<code>/sys/kernel/mm/transparent_hugepage/enabled</code>下设置为never即可</p>
<p>THP为大内存页时fork子线程时Copy-On-Write可能造成延迟</p>
<p><strong>ulimit</strong></p>
<p>建议将Redis启动用户的文件句柄限制调成10032，限制文件<code>etc/security/limits</code></p>
<p><strong>TCP backlog</strong></p>
<p>建议将<code>/proc/sys/net/core/somaxconn</code>系统TCP backlog的限制设置为与Redis一样默认511</p>
<h3 id="Redis安全问题">Redis安全问题</h3>
<p>在配置文件中配置</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#将命令更改为另一个字符串，原命令失效。如果字符串为空则表示禁用此命令</span><br><span class="line">rename-command &#123;cmd&#125; &#123;str&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>附各种数据类型的内部编码：</p>
<p><img src="https://mynamelancelot.github.io/img/redis/Data-Encoding.png" alt="Data-Encoding"></p>
<p>附Redis云平台CacheCloud【一键部署、监控、运维、数据迁移工具等】 <a target="_blank" rel="noopener" href="https://github.com/sohutv/cachecloud">GitHub项目地址</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2022/11/05/Redis%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2022/10/27/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-Elasticsearch-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"
                            aria-label=": 全文搜索引擎 Elasticsearch 入门教程"
                        >
                            全文搜索引擎 Elasticsearch 入门教程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-27T13:35:38+08:00">
	
		    2022 年 10 月 27 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../categories/%E5%90%8E%E7%AB%AF/">后端</a>, <a class="category-link" href="../../categories/%E5%90%8E%E7%AB%AF/Elasticsearch/">Elasticsearch</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E">全文搜索</a>属于最常见的需求，开源的 <a target="_blank" rel="noopener" href="https://www.elastic.co/">Elasticsearch</a> （以下简称 Elastic）是目前全文搜索引擎的首选。</p>
<p>它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017081701.jpg" alt=""></p>
<p>Elastic 的底层是开源库 <a target="_blank" rel="noopener" href="https://lucene.apache.org/">Lucene</a>。但是，你没法直接用 Lucene，必须自己写代码去调用它的接口。Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。</p>
<p>本文从零开始，讲解如何使用 Elastic 搭建自己的全文搜索引擎。每一步都有详细的说明，大家跟着做就能学会。</p>
<h2 id="一、安装">一、安装</h2>
<p>Elastic 需要 Java 8 环境。如果你的机器还没安装 Java，可以参考<a target="_blank" rel="noopener" href="https://www.digitalocean.com/community/tutorials/how-to-install-java-with-apt-get-on-debian-8">这篇文章</a>，注意要保证环境变量<code>JAVA_HOME</code>正确设置。</p>
<p>安装完 Java，就可以跟着<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/zip-targz.html">官方文档</a>安装 Elastic。直接下载压缩包比较简单。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.1.zip</span><br><span class="line">$ unzip elasticsearch-5.5.1.zip</span><br><span class="line">$ <span class="built_in">cd</span> elasticsearch-5.5.1/ </span><br></pre></td></tr></table></figure>
</blockquote>
<p>接着，进入解压后的目录，运行下面的命令，启动 Elastic。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ ./bin/elasticsearch</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果这时<a target="_blank" rel="noopener" href="https://github.com/spujadas/elk-docker/issues/92">报错</a>&quot;max virtual memory areas vm.max<em>map</em>count [65530] is too low&quot;，要运行下面的命令。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ <span class="built_in">sudo</span> sysctl -w vm.max_map_count=262144</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果一切正常，Elastic 就会在默认的9200端口运行。这时，打开另一个命令行窗口，请求该端口，会得到说明信息。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ curl localhost:9200</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span> : <span class="string">&quot;atntrTf&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cluster_name&quot;</span> : <span class="string">&quot;elasticsearch&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cluster_uuid&quot;</span> : <span class="string">&quot;tf9250XhQ6ee4h7YI11anA&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;number&quot;</span> : <span class="string">&quot;5.5.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_hash&quot;</span> : <span class="string">&quot;19c13d0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_date&quot;</span> : <span class="string">&quot;2017-07-18T20:44:24.823Z&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_snapshot&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;lucene_version&quot;</span> : <span class="string">&quot;6.6.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;tagline&quot;</span> : <span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，请求9200端口，Elastic 返回一个 JSON 对象，包含当前节点、集群、版本等信息。</p>
<p>按下 Ctrl + C，Elastic 就会停止运行。</p>
<p>默认情况下，Elastic 只允许本机访问，如果需要远程访问，可以修改 Elastic 安装目录的<code>config/elasticsearch.yml</code>文件，去掉<code>network.host</code>的注释，将它的值改成<code>0.0.0.0</code>，然后重新启动 Elastic。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">network.host: 0.0.0.0</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，设成<code>0.0.0.0</code>让任何人都可以访问。线上服务不要这样设置，要设成具体的 IP。</p>
<h2 id="二、基本概念">二、基本概念</h2>
<h3 id="2-1-Node-与-Cluster">2.1 Node 与 Cluster</h3>
<p>Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。</p>
<p>单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。</p>
<h3 id="2-2-Index">2.2 Index</h3>
<p>Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。</p>
<p>所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。</p>
<p>下面的命令可以查看当前节点的所有 Index。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ curl -X GET <span class="string">&#x27;http://localhost:9200/_cat/indices?v&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-3-Document">2.3 Document</h3>
<p>Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。</p>
<p>Document 使用 JSON 格式表示，下面是一个例子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;user&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;工程师&quot;</span>,</span><br><span class="line">  <span class="string">&quot;desc&quot;</span>: <span class="string">&quot;数据库管理&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</p>
<h3 id="2-4-Type">2.4 Type</h3>
<p>Document 可以分组，比如<code>weather</code>这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。</p>
<p>不同的 Type 应该有相似的结构（schema），举例来说，<code>id</code>字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/guide/current/mapping.html">一个区别</a>。性质完全不同的数据（比如<code>products</code>和<code>logs</code>）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。</p>
<p>下面的命令可以列出每个 Index 所包含的 Type。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ curl <span class="string">&#x27;localhost:9200/_mapping?pretty=true&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>根据<a target="_blank" rel="noopener" href="https://www.elastic.co/blog/index-type-parent-child-join-now-future-in-elasticsearch">规划</a>，Elastic 6.x 版只允许每个 Index 包含一个 Type，7.x 版将会彻底移除 Type。</p>
<h2 id="三、新建和删除-Index">三、新建和删除 Index</h2>
<p>新建 Index，可以直接向 Elastic 服务器发出 PUT 请求。下面的例子是新建一个名叫<code>weather</code>的 Index。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ curl -X PUT <span class="string">&#x27;localhost:9200/weather&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>服务器返回一个 JSON 对象，里面的<code>acknowledged</code>字段表示操作成功。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;acknowledged&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;shards_acknowledged&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后，我们发出 DELETE 请求，删除这个 Index。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ curl -X DELETE <span class="string">&#x27;localhost:9200/weather&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="四、中文分词设置">四、中文分词设置</h2>
<p>首先，安装中文分词插件。这里使用的是 <a target="_blank" rel="noopener" href="https://github.com/medcl/elasticsearch-analysis-ik/">ik</a>，也可以考虑其他插件（比如 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/plugins/current/analysis-smartcn.html">smartcn</a>）。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ ./bin/elasticsearch-plugin install <span class="attr">https</span>:<span class="comment">//github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.5.1/elasticsearch-analysis-ik-5.5.1.zip</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码安装的是5.5.1版的插件，与 Elastic 5.5.1 配合使用。</p>
<p>接着，重新启动 Elastic，就会自动加载这个新安装的插件。</p>
<p>然后，新建一个 Index，指定需要分词的字段。这一步根据数据结构而异，下面的命令只针对本文。基本上，凡是需要搜索的中文字段，都要单独设置一下。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ curl -X PUT <span class="string">&#x27;localhost:9200/accounts&#x27;</span> -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;mappings&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;person&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;properties&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;user&quot;: &#123;</span></span><br><span class="line"><span class="string">          &quot;type&quot;: &quot;text&quot;,</span></span><br><span class="line"><span class="string">          &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span></span><br><span class="line"><span class="string">          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &quot;title&quot;: &#123;</span></span><br><span class="line"><span class="string">          &quot;type&quot;: &quot;text&quot;,</span></span><br><span class="line"><span class="string">          &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span></span><br><span class="line"><span class="string">          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &quot;desc&quot;: &#123;</span></span><br><span class="line"><span class="string">          &quot;type&quot;: &quot;text&quot;,</span></span><br><span class="line"><span class="string">          &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span></span><br><span class="line"><span class="string">          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，首先新建一个名称为<code>accounts</code>的 Index，里面有一个名称为<code>person</code>的 Type。<code>person</code>有三个字段。</p>
<blockquote>
<ul>
<li>user</li>
<li>title</li>
<li>desc</li>
</ul>
</blockquote>
<p>这三个字段都是中文，而且类型都是文本（text），所以需要指定中文分词器，不能使用默认的英文分词器。</p>
<p>Elastic 的分词器称为 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html">analyzer</a>。我们对每个字段指定分词器。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;user&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">  <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line">  <span class="string">&quot;search_analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>analyzer</code>是字段文本的分词器，<code>search_analyzer</code>是搜索词的分词器。<code>ik_max_word</code>分词器是插件<code>ik</code>提供的，可以对文本进行最大数量的分词。</p>
<h2 id="五、数据操作">五、数据操作</h2>
<h3 id="5-1-新增记录">5.1 新增记录</h3>
<p>向指定的 /Index/Type 发送 PUT 请求，就可以在 Index 里面新增一条记录。比如，向<code>/accounts/person</code>发送请求，就可以新增一条人员记录。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ curl -X PUT <span class="string">&#x27;localhost:9200/accounts/person/1&#x27;</span> -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;user&quot;: &quot;张三&quot;,</span></span><br><span class="line"><span class="string">  &quot;title&quot;: &quot;工程师&quot;,</span></span><br><span class="line"><span class="string">  &quot;desc&quot;: &quot;数据库管理&quot;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> </span><br></pre></td></tr></table></figure>
</blockquote>
<p>服务器返回的 JSON 对象，会给出 Index、Type、Id、Version 等信息。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;_index&quot;</span>:<span class="string">&quot;accounts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_version&quot;</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;result&quot;</span>:<span class="string">&quot;created&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span>:&#123;<span class="string">&quot;total&quot;</span>:<span class="number">2</span>,<span class="string">&quot;successful&quot;</span>:<span class="number">1</span>,<span class="string">&quot;failed&quot;</span>:<span class="number">0</span>&#125;,</span><br><span class="line">  <span class="string">&quot;created&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果你仔细看，会发现请求路径是<code>/accounts/person/1</code>，最后的<code>1</code>是该条记录的 Id。它不一定是数字，任意字符串（比如<code>abc</code>）都可以。</p>
<p>新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ curl -X POST <span class="string">&#x27;localhost:9200/accounts/person&#x27;</span> -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;user&quot;: &quot;李四&quot;,</span></span><br><span class="line"><span class="string">  &quot;title&quot;: &quot;工程师&quot;,</span></span><br><span class="line"><span class="string">  &quot;desc&quot;: &quot;系统管理&quot;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，向<code>/accounts/person</code>发出一个 POST 请求，添加一个记录。这时，服务器返回的 JSON 对象里面，<code>_id</code>字段就是一个随机字符串。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;_index&quot;</span>:<span class="string">&quot;accounts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;AV3qGfrC6jMbsbXb6k1p&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_version&quot;</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;result&quot;</span>:<span class="string">&quot;created&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span>:&#123;<span class="string">&quot;total&quot;</span>:<span class="number">2</span>,<span class="string">&quot;successful&quot;</span>:<span class="number">1</span>,<span class="string">&quot;failed&quot;</span>:<span class="number">0</span>&#125;,</span><br><span class="line">  <span class="string">&quot;created&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意，如果没有先创建 Index（这个例子是<code>accounts</code>），直接执行上面的命令，Elastic 也不会报错，而是直接生成指定的 Index。所以，打字的时候要小心，不要写错 Index 的名称。</p>
<h3 id="5-2-查看记录">5.2 查看记录</h3>
<p>向<code>/Index/Type/Id</code>发出 GET 请求，就可以查看这条记录。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/1?pretty=true&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码请求查看<code>/accounts/person/1</code>这条记录，URL 的参数<code>pretty=true</code>表示以易读的格式返回。</p>
<p>返回的数据中，<code>found</code>字段表示查询成功，<code>_source</code>字段返回原始记录。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;accounts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_type&quot;</span> : <span class="string">&quot;person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_version&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;found&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;_source&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;user&quot;</span> : <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="string">&quot;title&quot;</span> : <span class="string">&quot;工程师&quot;</span>,</span><br><span class="line">    <span class="string">&quot;desc&quot;</span> : <span class="string">&quot;数据库管理&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果 Id 不正确，就查不到数据，<code>found</code>字段就是<code>false</code>。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ curl <span class="string">&#x27;localhost:9200/weather/beijing/abc?pretty=true&#x27;</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;accounts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_type&quot;</span> : <span class="string">&quot;person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">  <span class="string">&quot;found&quot;</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="5-3-删除记录">5.3 删除记录</h3>
<p>删除记录就是发出 DELETE 请求。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ curl -X DELETE <span class="string">&#x27;localhost:9200/accounts/person/1&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这里先不要删除这条记录，后面还要用到。</p>
<h3 id="5-4-更新记录">5.4 更新记录</h3>
<p>更新记录就是使用 PUT 请求，重新发送一次数据。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ curl -X PUT <span class="string">&#x27;localhost:9200/accounts/person/1&#x27;</span> -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;user&quot; : &quot;张三&quot;,</span></span><br><span class="line"><span class="string">    &quot;title&quot; : &quot;工程师&quot;,</span></span><br><span class="line"><span class="string">    &quot;desc&quot; : &quot;数据库管理，软件开发&quot;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;_index&quot;</span>:<span class="string">&quot;accounts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_version&quot;</span>:2,</span><br><span class="line">  <span class="string">&quot;result&quot;</span>:<span class="string">&quot;updated&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span>:&#123;<span class="string">&quot;total&quot;</span>:2,<span class="string">&quot;successful&quot;</span>:1,<span class="string">&quot;failed&quot;</span>:0&#125;,</span><br><span class="line">  <span class="string">&quot;created&quot;</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，我们将原始数据从&quot;数据库管理&quot;改成&quot;数据库管理，软件开发&quot;。 返回结果里面，有几个字段发生了变化。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;_version&quot;</span> : 2,</span><br><span class="line"><span class="string">&quot;result&quot;</span> : <span class="string">&quot;updated&quot;</span>,</span><br><span class="line"><span class="string">&quot;created&quot;</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>可以看到，记录的 Id 没变，但是版本（version）从<code>1</code>变成<code>2</code>，操作类型（result）从<code>created</code>变成<code>updated</code>，<code>created</code>字段变成<code>false</code>，因为这次不是新建记录。</p>
<h2 id="六、数据查询">六、数据查询</h2>
<h3 id="6-1-返回所有记录">6.1 返回所有记录</h3>
<p>使用 GET 方法，直接请求<code>/Index/Type/_search</code>，就会返回所有记录。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;took&quot;</span>:2,</span><br><span class="line">  <span class="string">&quot;timed_out&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span>:&#123;<span class="string">&quot;total&quot;</span>:5,<span class="string">&quot;successful&quot;</span>:5,<span class="string">&quot;failed&quot;</span>:0&#125;,</span><br><span class="line">  <span class="string">&quot;hits&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span>:2,</span><br><span class="line">    <span class="string">&quot;max_score&quot;</span>:1.0,</span><br><span class="line">    <span class="string">&quot;hits&quot;</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_index&quot;</span>:<span class="string">&quot;accounts&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;AV3qGfrC6jMbsbXb6k1p&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_score&quot;</span>:1.0,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;user&quot;</span>: <span class="string">&quot;李四&quot;</span>,</span><br><span class="line">          <span class="string">&quot;title&quot;</span>: <span class="string">&quot;工程师&quot;</span>,</span><br><span class="line">          <span class="string">&quot;desc&quot;</span>: <span class="string">&quot;系统管理&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_index&quot;</span>:<span class="string">&quot;accounts&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_score&quot;</span>:1.0,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;user&quot;</span> : <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">          <span class="string">&quot;title&quot;</span> : <span class="string">&quot;工程师&quot;</span>,</span><br><span class="line">          <span class="string">&quot;desc&quot;</span> : <span class="string">&quot;数据库管理，软件开发&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，返回结果的 <code>took</code>字段表示该操作的耗时（单位为毫秒），<code>timed_out</code>字段表示是否超时，<code>hits</code>字段表示命中的记录，里面子字段的含义如下。</p>
<blockquote>
<ul>
<li><code>total</code>：返回记录数，本例是2条。</li>
<li><code>max_score</code>：最高的匹配程度，本例是<code>1.0</code>。</li>
<li><code>hits</code>：返回的记录组成的数组。</li>
</ul>
</blockquote>
<p>返回的记录中，每条记录都有一个<code>_score</code>字段，表示匹配的程序，默认是按照这个字段降序排列。</p>
<h3 id="6-2-全文搜索">6.2 全文搜索</h3>
<p>Elastic 的查询非常特别，使用自己的<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl.html">查询语法</a>，要求 GET 请求带有数据体。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;软件&quot; &#125;&#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码使用 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl-match-query.html">Match 查询</a>，指定的匹配条件是<code>desc</code>字段里面包含&quot;软件&quot;这个词。返回结果如下。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;took&quot;</span>:<span class="number">3</span>,</span><br><span class="line">  <span class="string">&quot;timed_out&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span>:&#123;<span class="string">&quot;total&quot;</span>:<span class="number">5</span>,<span class="string">&quot;successful&quot;</span>:<span class="number">5</span>,<span class="string">&quot;failed&quot;</span>:<span class="number">0</span>&#125;,</span><br><span class="line">  <span class="string">&quot;hits&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;max_score&quot;</span>:<span class="number">0.28582606</span>,</span><br><span class="line">    <span class="string">&quot;hits&quot;</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_index&quot;</span>:<span class="string">&quot;accounts&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_score&quot;</span>:<span class="number">0.28582606</span>,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;user&quot;</span> : <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">          <span class="string">&quot;title&quot;</span> : <span class="string">&quot;工程师&quot;</span>,</span><br><span class="line">          <span class="string">&quot;desc&quot;</span> : <span class="string">&quot;数据库管理，软件开发&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Elastic 默认一次返回10条结果，可以通过<code>size</code>字段改变这个设置。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;管理&quot; &#125;&#125;,</span></span><br><span class="line"><span class="string">  &quot;size&quot;: 1</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码指定，每次只返回一条结果。</p>
<p>还可以通过<code>from</code>字段，指定位移。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;管理&quot; &#125;&#125;,</span></span><br><span class="line"><span class="string">  &quot;from&quot;: 1,</span></span><br><span class="line"><span class="string">  &quot;size&quot;: 1</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码指定，从位置1开始（默认是从位置0开始），只返回一条结果。</p>
<h3 id="6-3-逻辑运算">6.3 逻辑运算</h3>
<p>如果有多个搜索关键字， Elastic 认为它们是<code>or</code>关系。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;软件 系统&quot; &#125;&#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码搜索的是<code>软件 or 系统</code>。</p>
<p>如果要执行多个关键词的<code>and</code>搜索，必须使用<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl-bool-query.html">布尔查询</a>。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;query&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;bool&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;must&quot;: [</span></span><br><span class="line"><span class="string">        &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;软件&quot; &#125; &#125;,</span></span><br><span class="line"><span class="string">        &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;系统&quot; &#125; &#125;</span></span><br><span class="line"><span class="string">      ]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="七、参考链接">七、参考链接</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html">ElasticSearch 官方手册</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/blog/a-practical-introduction-to-elasticsearch">A Practical Introduction to Elasticsearch</a></li>
</ul>
<p>（完）</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2022/10/27/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-Elasticsearch-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2022/05/22/ansible/ansible%E6%95%99%E7%A8%8B-hands-on/"
                            aria-label=": ansible教程-hands-on"
                        >
                            ansible教程-hands-on
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-05-22T18:27:00+08:00">
	
		    2022 年 5 月 22 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../categories/devops/">devops</a>, <a class="category-link" href="../../categories/devops/ansible/">ansible</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1>Ansible 学习笔记</h1>
<h2 id="简介">简介</h2>
<ul>
<li>基于Python开发的自动化运维工具</li>
<li>集合了众多运维工具(puppet、cfengine、chef、func、fabric)的优点</li>
<li>基于模块工作，本身没有批量部署能力，批量部署由运行的模块实现</li>
<li>提供自动化运维框架</li>
</ul>
<h2 id="作用">作用</h2>
<ul>
<li>批量系统配置</li>
<li>批量程序部署</li>
<li>批量运行命令</li>
</ul>
<h2 id="框架组成">框架组成</h2>
<ul>
<li><strong>Connection Plugins</strong>：负责和被监控端实现通信</li>
<li><strong>Host Inventory</strong>：定义监控主机的配置文件</li>
<li><strong>模块</strong>：
<ul>
<li>核心模块</li>
<li>command模块</li>
<li>自定义模块</li>
</ul>
</li>
<li><strong>插件</strong>：完成记录日志邮件等功能</li>
<li><strong>Playbook</strong>：剧本，非必需，可让节点一次性运行多个任务</li>
</ul>
<h2 id="架构图">架构图</h2>
<p><img src="/assets/images/ansible1.png" alt="Ansible架构图"></p>
<h2 id="架构字段解释">架构字段解释</h2>
<ul>
<li><strong>Ansible</strong>：核心程序</li>
<li><strong>Host Inventory</strong>：主机清单(可定义主机组和主机)</li>
<li><strong>模块</strong>：实际执行任务的组件</li>
<li><strong>Playbook</strong>：Yaml定义的剧本文件(类似shell脚本)</li>
<li><strong>Connect Plugin</strong>：连接插件</li>
</ul>
<h2 id="工作原理">工作原理</h2>
<ol>
<li>控制端通过inventory定义主机组</li>
<li>通过编写playbook或AD-HOC命令</li>
<li>使用SSH将模块推送到被控端</li>
<li>被控端执行任务(要求被控端有Python2环境)</li>
<li>任务完成后返回结果</li>
</ol>
<h2 id="命令执行过程">命令执行过程</h2>
<ol>
<li>加载配置文件(/etc/ansible/ansible.cfg)</li>
<li>查找主机配置文件</li>
<li>加载对应模块文件</li>
<li>生成临时Python脚本并传输到远程主机</li>
<li>存储在远程主机的<code>~/.ansible/tmp/</code>目录</li>
<li>添加执行权限</li>
<li>执行并返回结果</li>
<li>删除临时文件</li>
</ol>
<h2 id="执行流程理解图">执行流程理解图</h2>
<p><img src="/assets/images/ansible2.png" alt="执行流程"></p>
<h2 id="特性">特性</h2>
<ul>
<li><strong>No Agents</strong>：无需在被控端安装客户端</li>
<li><strong>No Server</strong>：无服务端架构</li>
<li><strong>Modules in Any Languages</strong>：支持任意语言开发模块</li>
<li><strong>YAML</strong>：使用YAML语言编写playbook</li>
<li><strong>SSH by Default</strong>：默认基于SSH工作</li>
<li><strong>Multi-tier Solution</strong>：支持多级指挥</li>
</ul>
<h2 id="配置文件">配置文件</h2>
<p>配置文件优先级(从高到低)：</p>
<ol>
<li>项目目录下的<code>ansible.cfg</code></li>
<li>用户家目录下的<code>.ansible.cfg</code></li>
<li>默认的<code>/etc/ansible/ansible.cfg</code></li>
</ol>
<h3 id="主要配置项">主要配置项</h3>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#inventory = /etc/ansible/hosts      # 主机列表</span></span><br><span class="line"><span class="comment">#library = /usr/share/my_modules/     # 模块库目录</span></span><br><span class="line"><span class="comment">#remote_tmp = ~/.ansible/tmp          # 远程临时目录</span></span><br><span class="line"><span class="comment">#local_tmp = ~/.ansible/tmp           # 本地临时目录</span></span><br><span class="line"><span class="comment">#forks = 5                            # 并发数</span></span><br><span class="line"><span class="comment">#sudo_user = root                     # 默认sudo用户</span></span><br><span class="line"><span class="comment">#ask_sudo_pass = True                 # 是否询问sudo密码</span></span><br><span class="line"><span class="comment">#ask_pass = True                      # 是否询问SSH密码</span></span><br><span class="line"><span class="comment">#remote_port = 22                     # 远程端口</span></span><br><span class="line"><span class="attr">host_key_checking</span> = <span class="literal">False</span>             <span class="comment"># 跳过主机指纹检查</span></span><br><span class="line"><span class="attr">log_path</span> = /var/log/ansible.log       <span class="comment"># 日志路径</span></span><br></pre></td></tr></table></figure>
<h2 id="优点">优点</h2>
<ul>
<li>轻量级，客户端无需安装agent</li>
<li>批量任务可写成脚本且无需分发</li>
<li>基于Python，维护简单</li>
<li>支持sudo</li>
</ul>
<h2 id="环境搭建">环境搭建</h2>
<h3 id="主机规划">主机规划</h3>
<table>
<thead>
<tr>
<th>主机</th>
<th>IP</th>
<th>角色</th>
</tr>
</thead>
<tbody>
<tr>
<td>h1</td>
<td>192.168.50.60</td>
<td>master</td>
</tr>
<tr>
<td>h2</td>
<td>192.168.50.61</td>
<td>host1</td>
</tr>
<tr>
<td>h3</td>
<td>192.168.50.62</td>
<td>host2</td>
</tr>
<tr>
<td>h4</td>
<td>192.168.50.63</td>
<td>host3</td>
</tr>
</tbody>
</table>
<h3 id="SSH免密登录配置">SSH免密登录配置</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t dsa -f ~/.ssh/id_dsa -P <span class="string">&quot;&quot;</span></span><br><span class="line">ssh-copy-id -i ~/.ssh/id_dsa.pub root@192.168.50.61</span><br></pre></td></tr></table></figure>
<h3 id="安装">安装</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y ansible</span><br></pre></td></tr></table></figure>
<h3 id="主机清单配置">主机清单配置</h3>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[hosts]</span></span><br><span class="line">192.168.50.61</span><br><span class="line">192.168.50.62</span><br><span class="line">192.168.50.63</span><br><span class="line"></span><br><span class="line"><span class="section">[local]</span></span><br><span class="line">127.0.0.1</span><br></pre></td></tr></table></figure>
<h3 id="测试">测试</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ansible webservers -m <span class="built_in">command</span> -a <span class="string">&#x27;uptime&#x27;</span></span><br><span class="line">ansible all -m ping</span><br></pre></td></tr></table></figure>
<h2 id="常用模块">常用模块</h2>
<h3 id="setup模块">setup模块</h3>
<p>查看远程主机基本信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible webservers -m setup</span><br></pre></td></tr></table></figure>
<h3 id="fetch模块">fetch模块</h3>
<p>从主机获取文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible 192.168.50.61 -m fetch -a <span class="string">&#x27;src=/root/t2 dest=/root&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="file模块">file模块</h3>
<p>设置文件属性</p>
<p><strong>选项</strong>:</p>
<ul>
<li><code>force</code>: 强制创建软链接(yes|no)</li>
<li><code>group</code>: 文件属组</li>
<li><code>mode</code>: 文件权限</li>
<li><code>owner</code>: 文件属主</li>
<li><code>path</code>: 文件路径(必选)</li>
<li><code>recurse</code>: 递归设置属性(仅目录)</li>
<li><code>src</code>: 源文件路径(仅state=link时)</li>
<li><code>dest</code>: 链接目标路径(仅state=link时)</li>
<li><code>state</code>:
<ul>
<li><code>directory</code>: 创建目录</li>
<li><code>file</code>: 不创建文件</li>
<li><code>link</code>: 创建软链接</li>
<li><code>hard</code>: 创建硬链接</li>
<li><code>touch</code>: 创建空文件或更新修改时间</li>
<li><code>absent</code>: 删除文件/目录</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建符号链接</span></span><br><span class="line">ansible hosts -m file -a <span class="string">&quot;src=/etc/resolv.conf dest=/root/resolv.conf state=link&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="copy模块">copy模块</h3>
<p>复制文件到远程主机</p>
<p><strong>选项</strong>:</p>
<ul>
<li><code>backup</code>: 覆盖前备份(yes|no)</li>
<li><code>content</code>: 直接设置文件内容(替代src)</li>
<li><code>dest</code>: 目标绝对路径(必选)</li>
<li><code>directory_mode</code>: 递归设置目录权限</li>
<li><code>force</code>: 强制覆盖(yes|no)</li>
<li><code>src</code>: 本地源文件路径</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible hosts -m copy -a <span class="string">&quot;src=/etc/ansible/ansible.cfg dest=/tmp/ansible.cfg owner=root group=root mode=0755&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="command模块">command模块</h3>
<p>在远程主机执行命令</p>
<p><strong>选项</strong>:</p>
<ul>
<li><code>creates</code>: 文件存在时不执行</li>
<li><code>free_form</code>: Linux命令</li>
<li><code>chdir</code>: 执行前切换目录</li>
<li><code>removes</code>: 文件不存在时不执行</li>
<li><code>executable</code>: 指定shell路径</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ansible webservers -m <span class="built_in">command</span> -a <span class="string">&quot;ls -al /tmp&quot;</span></span><br><span class="line">ansible webservers -m <span class="built_in">command</span> -a <span class="string">&#x27;useradd abc&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="shell模块">shell模块</h3>
<p>支持管道操作的命令执行</p>
<p><strong>示例</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行远程脚本</span></span><br><span class="line">ansible hosts -m shell -a <span class="string">&quot;/root/test.sh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量添加用户密码</span></span><br><span class="line">ansible hosts -m shell -a <span class="string">&#x27;useradd abc &amp;&amp; echo 123 |passwd --stdin abc&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="cron模块">cron模块</h3>
<p>管理计划任务</p>
<p><strong>选项</strong>:</p>
<ul>
<li><code>minute/hour/day/month/weekday</code>: 时间设置</li>
<li><code>job</code>: 任务命令</li>
<li><code>name</code>: 任务名称</li>
<li><code>user</code>: 执行用户</li>
<li><code>state</code>: present(添加)|absent(删除)</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建任务</span></span><br><span class="line">ansible all -m cron -a <span class="string">&quot;minute=&#x27;*/5&#x27; job=&#x27;/usr/sbin/ntpdate 192.168.50.60 &amp;&gt;/dev/null&#x27; name=&#x27;sync time&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除任务</span></span><br><span class="line">ansible all -m cron -a <span class="string">&quot;name=&#x27;sync time&#x27; state=absent&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="hostname模块">hostname模块</h3>
<p>管理主机名</p>
<p><strong>示例</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改主机名</span></span><br><span class="line">ansible 192.168.50.63 -m hostname -a <span class="string">&quot;name=t4&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="yum模块">yum模块</h3>
<p>软件包管理</p>
<p><strong>示例</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装tree</span></span><br><span class="line">ansible all -m yum -a <span class="string">&quot;name=tree&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">ansible all -m yum -a <span class="string">&#x27;name=tree state=absent&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="service模块">service模块</h3>
<p>服务管理</p>
<p><strong>示例</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动ntpdate服务</span></span><br><span class="line">ansible all -m service -a <span class="string">&quot;name=ntpdate state=started enabled=true&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="group模块">group模块</h3>
<p>用户组管理</p>
<p><strong>示例</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加系统组</span></span><br><span class="line">ansible all -m group -a <span class="string">&quot;name=gansible system=true&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="user模块">user模块</h3>
<p>用户管理</p>
<p><strong>选项</strong>:</p>
<ul>
<li><code>name</code>: 用户名</li>
<li><code>state</code>: present(新增)|absent(删除)</li>
<li><code>force</code>: 删除时是否删除家目录</li>
<li><code>system</code>: 是否系统用户</li>
<li><code>uid</code>: 指定UID</li>
<li><code>shell</code>: 指定shell</li>
<li><code>home</code>: 指定家目录</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加系统用户</span></span><br><span class="line">ansible all -m user -a <span class="string">&quot;name=ccc system=true&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="YAML语法">YAML语法</h2>
<ul>
<li>数据序列化格式</li>
<li>基本结构:<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">key:</span> <span class="string">value</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">item1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">item2</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">item3</span></span><br></pre></td></tr></table></figure>
例如: <code>&#123;name: jerry, age: 21&#125;</code></li>
</ul>
<h2 id="Playbook">Playbook</h2>
<h3 id="核心元素">核心元素</h3>
<ul>
<li>Tasks: 任务列表</li>
<li>Variables: 变量</li>
<li>Templates: 模板文件</li>
<li>Handlers: 条件触发任务</li>
<li>Roles: 角色</li>
</ul>
<h3 id="基础组件">基础组件</h3>
<ul>
<li><code>Hosts</code>: 目标主机</li>
<li><code>remote_user</code>: 执行用户</li>
<li><code>sudo_user</code>: sudo用户</li>
<li><code>tasks</code>: 任务列表</li>
</ul>
<h3 id="运行Playbook">运行Playbook</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法检查</span></span><br><span class="line">ansible-playbook --syntax-check playbook.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试运行</span></span><br><span class="line">ansible-playbook -C playbook.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际运行</span></span><br><span class="line">ansible-playbook playbook.yaml</span><br></pre></td></tr></table></figure>
<h3 id="示例">示例</h3>
<h4 id="1-添加用户和组">1. 添加用户和组</h4>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">a</span> <span class="string">group</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">name=test</span> <span class="string">system=test</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">a</span> <span class="string">user</span></span><br><span class="line">      <span class="attr">user:</span> <span class="string">name=test</span> <span class="string">group=test</span> <span class="string">system=true</span></span><br></pre></td></tr></table></figure>
<h4 id="2-配置HTTP服务">2. 配置HTTP服务</h4>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">hosts</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">yum:</span> <span class="string">name=httpd</span> <span class="string">state=latest</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">conf</span></span><br><span class="line">      <span class="attr">copy:</span> <span class="string">src=/root/httpd.conf</span> <span class="string">dest=/etc/httpd/conf/httpd.conf.bak</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">start</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=reloaded</span> <span class="string">enabled=true</span></span><br></pre></td></tr></table></figure>
<h2 id="更多模块">更多模块</h2>
<ul>
<li><code>synchronize</code>: 使用rsync同步文件</li>
<li><code>raw</code>: 直接执行命令(类似shell)</li>
</ul>
<h2 id="模块帮助">模块帮助</h2>
<pre><code class="language-bash"># 列出所有模块
ansible-doc -l

# 查看模块帮助
ansible-doc -s MOD_NAME
</code></pre>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2022/05/22/ansible/ansible%E6%95%99%E7%A8%8B-hands-on/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2022/05/22/ansible/ansible%E6%95%99%E7%A8%8B-%E6%A6%82%E5%BF%B5/"
                            aria-label=": ansible教程-概念"
                        >
                            ansible教程-概念
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-05-22T18:20:08+08:00">
	
		    2022 年 5 月 22 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../categories/devops/">devops</a>, <a class="category-link" href="../../categories/devops/ansible/">ansible</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="Ansible-概念">Ansible 概念</h2>
<p>这些概念适用于 Ansible 的所有用途。在使用 Ansible 或阅读文档之前，您应该了解它们。</p>
<ul>
<li>
<p>[控制节点]</p>
</li>
<li>
<p>[被管理节点]</p>
</li>
<li>
<p>[清单]</p>
</li>
<li>
<p>[剧本]</p>
<ul>
<li>
<p>[剧集]</p>
<ul>
<li>
<p>[角色]</p>
</li>
<li>
<p>[任务]</p>
</li>
<li>
<p>[处理器]</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>[模块]</p>
</li>
<li>
<p>[插件]</p>
</li>
<li>
<p>[集合]</p>
</li>
</ul>
<h2 id="控制节点">[控制节点]</h2>
<p>运行 Ansible CLI 工具（<code>ansible-playbook</code>、<code>ansible</code>、<code>ansible-vault</code> 等）的机器。您可以使用任何满足软件要求的计算机作为控制节点——笔记本电脑、共享桌面和服务器都可以运行 Ansible。您也可以在称为<a target="_blank" rel="noopener" href="https://docs.ansible.org.cn/ansible/latest/getting_started_ee/index.html#getting-started-ee-index">执行环境</a>的容器中运行 Ansible。</p>
<p>可以使用多个控制节点，但 Ansible 本身并不协调它们之间的工作，有关此类功能，请参见<code>AAP</code>。</p>
<h2 id="被管理节点">[被管理节点]</h2>
<p>也称为“主机”，这些是您旨在用 Ansible 管理的目标设备（服务器、网络设备或任何计算机）。</p>
<p>除非您使用<code>ansible-pull</code>，否则通常不会在被管理节点上安装 Ansible，但这很少见，也不是推荐的设置。</p>
<h2 id="清单">[清单]</h2>
<p>由一个或多个“清单源”提供的被管理节点列表。您的清单可以指定每个节点的特定信息，例如 IP 地址。它还用于分配组，这既允许在剧集中选择节点，也允许批量分配变量。</p>
<p>要了解有关清单的更多信息，请参阅<a target="_blank" rel="noopener" href="https://docs.ansible.org.cn/ansible/latest/inventory_guide/intro_inventory.html#intro-inventory">使用清单</a>部分。有时，清单源文件也称为“主机文件”。</p>
<h2 id="剧本">[剧本]</h2>
<p>它们包含剧集（这是 Ansible 执行的基本单元）。这既是“执行概念”，也是我们用来描述<code>ansible-playbook</code>操作的文件的方式。</p>
<p>剧本是用 YAML 编写的，易于阅读、编写、共享和理解。要了解有关剧本的更多信息，请参阅<a target="_blank" rel="noopener" href="https://docs.ansible.org.cn/ansible/latest/playbook_guide/playbooks_intro.html#about-playbooks">Ansible 剧本</a>。</p>
<h3 id="剧集">[剧集]</h3>
<p>Ansible 执行的主要上下文，此剧本对象将被管理节点（主机）映射到任务。剧集包含变量、角色和已排序的任务列表，并且可以重复运行。它基本上由对映射的主机和任务的隐式循环组成，并定义如何迭代它们。</p>
<h4 id="角色">[角色]</h4>
<p>可在剧集内部使用的可重用 Ansible 内容（任务、处理器、变量、插件、模板和文件）的有限分发。</p>
<p>要使用任何角色资源，必须将角色本身导入剧集。</p>
<h4 id="任务">[任务]</h4>
<p>应用于被管理主机的“操作”的定义。您可以使用<code>ansible</code>或<code>ansible-console</code>（两者都会创建一个虚拟剧集）一次执行单个任务。</p>
<h4 id="处理器">[处理器]</h4>
<p>任务的一种特殊形式，仅在之前的任务发出通知并且导致“已更改”状态时才执行。</p>
<h2 id="模块">[模块]</h2>
<p>Ansible 复制到并在每个被管理节点上执行（如有需要）的代码或二进制文件，以完成每个任务中定义的操作。</p>
<p>每个模块都有其特定的用途，从管理特定类型数据库上的用户到管理特定类型网络设备上的 VLAN 接口。</p>
<p>您可以使用任务调用单个模块，也可以在剧本中调用多个不同的模块。Ansible 模块分组在集合中。要了解 Ansible 包含多少集合，请参阅<a target="_blank" rel="noopener" href="https://docs.ansible.org.cn/ansible/latest/collections/index.html#list-of-collections">集合索引</a>。</p>
<h2 id="插件">[插件]</h2>
<p>扩展 Ansible 核心功能的代码片段。插件可以控制您如何连接到被管理节点（连接插件）、操作数据（过滤器插件），甚至控制在控制台中显示的内容（回调插件）。</p>
<p>有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.ansible.org.cn/ansible/latest/plugins/plugins.html#working-with-plugins">使用插件</a>。</p>
<h2 id="集合">[集合]</h2>
<p>Ansible 内容的分发格式，可以包含剧本、角色、模块和插件。您可以通过<a target="_blank" rel="noopener" href="https://galaxy.ansible.com/">Ansible Galaxy</a>安装和使用集合。</p>
<p>要了解有关集合的更多信息，请参阅<a target="_blank" rel="noopener" href="https://docs.ansible.org.cn/ansible/latest/collections_guide/index.html#collections">使用 Ansible 集合</a>。</p>
<p>集合资源可以彼此独立且离散地使用。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2022/05/22/ansible/ansible%E6%95%99%E7%A8%8B-%E6%A6%82%E5%BF%B5/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2022/05/22/ansible/ansible%E6%95%99%E7%A8%8B-%E5%85%A5%E9%97%A8%E7%AF%87/"
                            aria-label=": ansible教程-入门篇"
                        >
                            ansible教程-入门篇
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-05-22T17:52:27+08:00">
	
		    2022 年 5 月 22 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../categories/devops/">devops</a>, <a class="category-link" href="../../categories/devops/ansible/">ansible</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="Ansible-简介">Ansible 简介</h2>
<p>Ansible 提供开源自动化，可降低复杂性并在任何地方运行。使用 Ansible 可以自动执行几乎任何任务。以下是 Ansible 的一些常见用例</p>
<ul>
<li>
<p>消除重复并简化工作流程</p>
</li>
<li>
<p>管理和维护系统配置</p>
</li>
<li>
<p>持续部署复杂的软件</p>
</li>
<li>
<p>执行零停机滚动更新</p>
</li>
</ul>
<p>Ansible 使用简单的、人类可读的脚本（称为剧本）来自动化您的任务。您在剧本中声明本地或远程系统的期望状态。Ansible 确保系统保持在该状态。</p>
<p>作为自动化技术，Ansible 围绕以下原则设计</p>
<p>无代理架构</p>
<p>通过避免在 IT 基础设施上安装额外软件来降低维护开销。</p>
<p>简单性</p>
<p>自动化剧本使用简单的 YAML 语法，代码就像文档一样易于阅读。Ansible 也是分散式的，使用 SSH 和现有的操作系统凭据来访问远程机器。</p>
<p>可扩展性和灵活性</p>
<p>通过模块化设计轻松快速地扩展您自动化的系统，该设计支持各种操作系统、云平台和网络设备。</p>
<p>幂等性和可预测性</p>
<p>当系统处于您的剧本描述的状态时，即使多次运行剧本，Ansible 也不会更改任何内容。</p>
<h2 id="使用-Ansible-开始自动化">使用 Ansible 开始自动化</h2>
<p>通过创建自动化项目、构建清单和创建“Hello World”剧本开始使用 Ansible。</p>
<ol>
<li>
<p>安装 Ansible。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install ansible</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在您的文件系统上创建一个项目文件夹。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ansible_quickstart &amp;&amp; cd ansible_quickstart</span><br></pre></td></tr></table></figure>
<p>使用单一目录结构可以更轻松地添加到源代码管理，以及重用和共享自动化内容。</p>
</li>
</ol>
<h2 id="构建清单">构建清单</h2>
<p>清单将受管节点组织在集中式文件中，这些文件为 Ansible 提供系统信息和网络位置。使用清单文件，Ansible 可以使用单个命令管理大量主机。</p>
<p>要完成以下步骤，您需要至少一个主机系统的 IP 地址或完全限定域名 (FQDN)。出于演示目的，主机可以在容器或虚拟机中本地运行。您还必须确保您的公共 SSH 密钥已添加到每个主机上的 <code>authorized_keys</code> 文件中。</p>
<p>继续 Ansible 入门并按如下步骤构建清单</p>
<ol>
<li>
<p>在您在 上一步中创建的 <code>ansible_quickstart</code> 目录中创建一个名为 <code>inventory.ini</code> 的文件。</p>
</li>
<li>
<p>向 <code>inventory.ini</code> 文件添加一个新的 <code>[myhosts]</code> 组，并指定每个主机系统的 IP 地址或完全限定域名 (FQDN)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[myhosts]</span><br><span class="line">192.0.2.50</span><br><span class="line">192.0.2.51</span><br><span class="line">192.0.2.52</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>验证您的清单。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-inventory -i inventory.ini --list</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Ping 清单中的 <code>myhosts</code> 组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible myhosts -m ping -i inventory.ini</span><br></pre></td></tr></table></figure>
<p>注意</p>
<p>如果控制节点和受管节点上的用户名不同，请使用 <code>ansible</code> 命令传递 <code>-u</code> 选项。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">192.0.2.50 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python3&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line">192.0.2.51 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python3&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line">192.0.2.52 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python3&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="INI-或-YAML-格式的清单">INI 或 YAML 格式的清单</h2>
<p>您可以使用 <code>INI</code> 文件或 <code>YAML</code> 创建清单。在大多数情况下，例如上一步中的示例，对于少量受管节点，<code>INI</code> 文件简单易读。</p>
<p>随着受管节点数量的增加，使用 <code>YAML</code> 格式创建清单变得更合理。例如，以下是 <code>inventory.ini</code> 的等效项，它声明受管节点的唯一名称并使用 <code>ansible_host</code> 字段</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">myhosts:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="attr">my_host_01:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.50</span></span><br><span class="line">    <span class="attr">my_host_02:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.51</span></span><br><span class="line">    <span class="attr">my_host_03:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.52</span></span><br></pre></td></tr></table></figure>
<h2 id="构建清单的技巧">构建清单的技巧</h2>
<ul>
<li>
<p>确保组名有意义且唯一。组名也区分大小写。</p>
</li>
<li>
<p>避免在组名中使用空格、连字符和前导数字（使用 <code>floor_19</code>，而不是 <code>19th_floor</code>）。</p>
</li>
<li>
<p>根据主机的**什么**、**哪里**和**何时**逻辑地将主机分组到您的清单中。</p>
<p>什么</p>
<p>根据拓扑结构对主机分组，例如：db、web、leaf、spine。</p>
<p>哪里</p>
<p>按地理位置对主机分组，例如：数据中心、区域、楼层、建筑物。</p>
<p>何时</p>
<p>按阶段对主机分组，例如：开发、测试、过渡、生产。</p>
</li>
</ul>
<h3 id="使用元组">使用元组</h3>
<p>使用以下语法创建一个元组来组织清单中的多个组</p>
<p>以下清单说明了数据中心的结构基础。此示例清单包含一个 <code>network</code> 元组，其中包括所有网络设备，以及一个 <code>datacenter</code> 元组，其中包括 <code>network</code> 组和所有 Web 服务器。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">leafs:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="attr">leaf01:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.100</span></span><br><span class="line">    <span class="attr">leaf02:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.110</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spines:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="attr">spine01:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.120</span></span><br><span class="line">    <span class="attr">spine02:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.130</span></span><br><span class="line"></span><br><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">children:</span></span><br><span class="line">    <span class="attr">leafs:</span></span><br><span class="line">    <span class="attr">spines:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">webservers:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="attr">webserver01:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.140</span></span><br><span class="line">    <span class="attr">webserver02:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.150</span></span><br><span class="line"></span><br><span class="line"><span class="attr">datacenter:</span></span><br><span class="line">  <span class="attr">children:</span></span><br><span class="line">    <span class="attr">network:</span></span><br><span class="line">    <span class="attr">webservers:</span></span><br></pre></td></tr></table></figure>
<h3 id="创建变量">创建变量</h3>
<p>变量设置受管节点的值，例如 IP 地址、FQDN、操作系统和 SSH 用户，因此您无需在运行 Ansible 命令时传递它们。</p>
<p>变量可以应用于特定主机。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">webservers:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="attr">webserver01:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.140</span></span><br><span class="line">      <span class="attr">http_port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">webserver02:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.150</span></span><br><span class="line">      <span class="attr">http_port:</span> <span class="number">443</span></span><br></pre></td></tr></table></figure>
<p>变量也可以应用于组中的所有主机。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">webservers:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="attr">webserver01:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.140</span></span><br><span class="line">      <span class="attr">http_port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">webserver02:</span></span><br><span class="line">      <span class="attr">ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.150</span></span><br><span class="line">      <span class="attr">http_port:</span> <span class="number">443</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">ansible_user:</span> <span class="string">my_server_user</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="创建剧本">创建剧本</h2>
<p>剧本是 Ansible 用于部署和配置受管节点的自动化蓝图，采用 <code>YAML</code> 格式。</p>
<p>剧本</p>
<p>一系列定义 Ansible 执行操作顺序的剧目，自上而下，以实现总体目标。</p>
<p>剧目</p>
<p>一个有序的任务列表，映射到清单中的受管节点。</p>
<p>任务</p>
<p>对单个模块的引用，定义 Ansible 执行的操作。</p>
<p>模块</p>
<p>Ansible 在受管节点上运行的代码或二进制单元。Ansible 模块按集合分组，每个模块都有一个<a target="_blank" rel="noopener" href="https://docs.ansible.org.cn/ansible/latest/reference_appendices/glossary.html#term-Fully-Qualified-Collection-Name-FQCN">完全限定的集合名称 (FQCN)</a>。</p>
<p>完成以下步骤以创建用于 ping 主机并打印“Hello world”消息的剧本</p>
<ol>
<li>
<p>在您之前创建的 <code>ansible_quickstart</code> 目录中创建一个名为 <code>playbook.yaml</code> 的文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">My</span> <span class="string">first</span> <span class="string">play</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">myhosts</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Ping</span> <span class="string">my</span> <span class="string">hosts</span></span><br><span class="line">     <span class="attr">ansible.builtin.ping:</span></span><br><span class="line"></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Print</span> <span class="string">message</span></span><br><span class="line">     <span class="attr">ansible.builtin.debug:</span></span><br><span class="line">       <span class="attr">msg:</span> <span class="string">Hello</span> <span class="string">world</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>运行您的剧本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook -i inventory.ini playbook.yaml</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Ansible 返回以下输出</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">PLAY [My first play] ****************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [Gathering Facts] **************************************************************************</span><br><span class="line">ok: [192.0.2.50]</span><br><span class="line">ok: [192.0.2.51]</span><br><span class="line">ok: [192.0.2.52]</span><br><span class="line"></span><br><span class="line">TASK [Ping my hosts] ****************************************************************************</span><br><span class="line">ok: [192.0.2.50]</span><br><span class="line">ok: [192.0.2.51]</span><br><span class="line">ok: [192.0.2.52]</span><br><span class="line"></span><br><span class="line">TASK [Print message] ****************************************************************************</span><br><span class="line">ok: [192.0.2.50] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;Hello world&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [192.0.2.51] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;Hello world&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [192.0.2.52] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;Hello world&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP **************************************************************************************</span><br><span class="line">192.0.2.50: ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br><span class="line">192.0.2.51: ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br><span class="line">192.0.2.52: ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure>
<p>在此输出中，您可以看到</p>
<ul>
<li>
<p>您为剧目和每个任务指定的名称。您应始终使用易于验证和排查剧本问题的描述性名称。</p>
</li>
<li>
<p>“收集事实”任务隐式运行。默认情况下，Ansible 会收集有关您的清单的信息，以便在剧本中使用。</p>
</li>
<li>
<p>每个任务的状态。每个任务的状态为 <code>ok</code>，表示它已成功运行。</p>
</li>
<li>
<p>剧目摘要，总结了每个主机上所有任务的结果。在此示例中，共有三个任务，因此 <code>ok=3</code> 表示每个任务都已成功运行。</p>
</li>
</ul>
<p>恭喜，您已开始使用 Ansible！</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2022/05/22/ansible/ansible%E6%95%99%E7%A8%8B-%E5%85%A5%E9%97%A8%E7%AF%87/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2021/05/23/makefile%E6%95%99%E7%A8%8B/"
                            aria-label=": makefile教程"
                        >
                            makefile教程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-05-23T12:48:01+08:00">
	
		    2021 年 5 月 23 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../categories/devops/">devops</a>, <a class="category-link" href="../../categories/devops/make/">make</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="简介">简介</h2>
<p>Linux的<code>make</code>程序用来自动化编译大型源码，很多时候，我们在Linux下编译安装软件，只需要敲一个<code>make</code>就可以全自动完成，非常方便。</p>
<p><code>make</code>能自动化完成这些工作，是因为项目提供了一个<code>Makefile</code>文件，它负责告诉<code>make</code>，应该如何编译和链接程序。</p>
<p><code>Makefile</code>相当于Java项目的<code>pom.xml</code>，Node工程的<code>package.json</code>，Rust项目的<code>Cargo.toml</code>，不同之处在于，<code>make</code>虽然最初是针对C语言开发，但它实际上并不限定C语言，而是可以应用到任意项目，甚至不是编程语言。此外，<code>make</code>主要用于Unix/Linux环境的自动化开发，掌握<code>Makefile</code>的写法，可以更好地在Linux环境下做开发，也可以为后续开发Linux内核做好准备。</p>
<p>在本教程中，我们将由浅入深，一步一步学习如何编写<code>Makefile</code>，完全针对零基础小白，只需要提前掌握如何使用Linux命令。</p>
<hr>
<p>在Linux环境下，当我们输入<code>make</code>命令时，它就在当前目录查找一个名为<code>Makefile</code>的文件，然后，根据这个文件定义的规则，自动化地执行任意命令，包括编译命令。</p>
<p><code>Makefile</code>这个单词，顾名思义，就是指如何生成文件。</p>
<p>我们举个例子：在当前目录下，有3个文本文件：<code>a.txt</code>，<code>b.txt</code>和<code>c.txt</code>。</p>
<p>现在，我们要合并<code>a.txt</code>与<code>b.txt</code>，生成中间文件<code>m.txt</code>，再用中间文件<code>m.txt</code>与<code>c.txt</code>合并，生成最终的目标文件<code>x.txt</code>，整个逻辑如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌─────┐ ┌─────┐ ┌─────┐</span><br><span class="line">│a.txt│ │b.txt│ │c.txt│</span><br><span class="line">└─────┘ └─────┘ └─────┘</span><br><span class="line">   │       │       │</span><br><span class="line">   └───┬───┘       │</span><br><span class="line">       │           │</span><br><span class="line">       ▼           │</span><br><span class="line">    ┌─────┐        │</span><br><span class="line">    │m.txt│        │</span><br><span class="line">    └─────┘        │</span><br><span class="line">       │           │</span><br><span class="line">       └─────┬─────┘</span><br><span class="line">             │</span><br><span class="line">             ▼</span><br><span class="line">          ┌─────┐</span><br><span class="line">          │x.txt│</span><br><span class="line">          └─────┘</span><br></pre></td></tr></table></figure>
<p>根据上述逻辑，我们来编写<code>Makefile</code>。</p>
<h3 id="规则">规则</h3>
<p><code>Makefile</code>由若干条规则（Rule）构成，每一条规则指出一个目标文件（Target），若干依赖文件（prerequisites），以及生成目标文件的命令。</p>
<p>例如，要生成<code>m.txt</code>，依赖<code>a.txt</code>与<code>b.txt</code>，规则如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 目标文件: 依赖文件1 依赖文件2</span><br><span class="line">m.txt: a.txt b.txt</span><br><span class="line">	cat a.txt b.txt &gt; m.txt</span><br></pre></td></tr></table></figure>
<p>一条规则的格式为<code>目标文件: 依赖文件1 依赖文件2 ...</code>，紧接着，以Tab开头的是命令，用来生成目标文件。上述规则使用<code>cat</code>命令合并了<code>a.txt</code>与<code>b.txt</code>，并写入到<code>m.txt</code>。用什么方式生成目标文件<code>make</code>并不关心，因为命令完全是我们自己写的，可以是编译命令，也可以是<code>cp</code>、<code>mv</code>等任何命令。</p>
<p>以<code>#</code>开头的是注释，会被<code>make</code>命令忽略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：Makefile的规则中，命令必须以Tab开头，不能是空格。</span><br></pre></td></tr></table></figure>
<p>类似的，我们写出生成<code>x.txt</code>的规则如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x.txt: m.txt c.txt</span><br><span class="line">	cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure>
<p>由于<code>make</code>执行时，默认执行第一条规则，所以，我们把规则<code>x.txt</code>放到前面。完整的<code>Makefile</code>如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x.txt: m.txt c.txt</span><br><span class="line">	cat m.txt c.txt &gt; x.txt</span><br><span class="line"></span><br><span class="line">m.txt: a.txt b.txt</span><br><span class="line">	cat a.txt b.txt &gt; m.txt</span><br></pre></td></tr></table></figure>
<p>在当前目录创建<code>a.txt</code>、<code>b.txt</code>和<code>c.txt</code>，输入一些内容，执行<code>make</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cat a.txt b.txt &gt; m.txt</span><br><span class="line">cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure>
<p><code>make</code>默认执行第一条规则，也就是创建<code>x.txt</code>，但是由于<code>x.txt</code>依赖的文件<code>m.txt</code>不存在（另一个依赖<code>c.txt</code>已存在），故需要先执行规则<code>m.txt</code>创建出<code>m.txt</code>文件，再执行规则<code>x.txt</code>。执行完成后，当前目录下生成了两个文件<code>m.txt</code>和<code>x.txt</code>。</p>
<p>可见，<code>Makefile</code>定义了一系列规则，每个规则在满足依赖文件的前提下执行命令，就能创建出一个目标文件，这就是英文Make file的意思。</p>
<p>把默认执行的规则放第一条，其他规则的顺序是无关紧要的，因为<code>make</code>执行时自动判断依赖。</p>
<p>此外，<code>make</code>会打印出执行的每一条命令，便于我们观察执行顺序以便调试。</p>
<p>如果我们再次运行<code>make</code>，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">make: `x.txt&#x27; is up to date.</span><br></pre></td></tr></table></figure>
<p><code>make</code>检测到<code>x.txt</code>已经是最新版本，无需再次执行，因为<code>x.txt</code>的创建时间晚于它依赖的<code>m.txt</code>和<code>c.txt</code>的最后修改时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make使用文件的创建和修改时间来判断是否应该更新一个目标文件。</span><br></pre></td></tr></table></figure>
<p>修改<code>c.txt</code>后，运行<code>make</code>，会触发<code>x.txt</code>的更新：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure>
<p>但并不会触发<code>m.txt</code>的更新，原因是<code>m.txt</code>的依赖<code>a.txt</code>与<code>b.txt</code>并未更新，所以，<code>make</code>只会根据<code>Makefile</code>去执行那些必要的规则，并不会把所有规则都无脑执行一遍。</p>
<p>在编译大型程序时，全量编译往往需要几十分钟甚至几个小时。全量编译完成后，如果仅修改了几个文件，再全部重新编译完全没有必要，用<code>Makefile</code>实现增量编译就十分节省时间。</p>
<p>当然，是否能正确地实现增量更新，取决于我们的规则写得对不对，<code>make</code>本身并不会检查规则逻辑是否正确。</p>
<h3 id="伪目标">伪目标</h3>
<p>因为<code>m.txt</code>与<code>x.txt</code>都是自动生成的文件，所以，可以安全地删除。</p>
<p>删除时，我们也不希望手动删除，而是编写一个<code>clean</code>规则来删除它们：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">	rm -f m.txt</span><br><span class="line">	rm -f x.txt</span><br></pre></td></tr></table></figure>
<p><code>clean</code>规则与我们前面编写的规则有所不同，它没有依赖文件，因此，要执行<code>clean</code>，必须用命令<code>make clean</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make clean</span><br><span class="line">rm -f m.txt</span><br><span class="line">rm -f x.txt</span><br></pre></td></tr></table></figure>
<p>然而，在执行<code>clean</code>时，我们并没有创建一个名为<code>clean</code>的文件，所以，因为目标文件<code>clean</code>不存在，每次运行<code>make clean</code>，都会执行这个规则的命令。</p>
<p>如果我们手动创建一个<code>clean</code>的文件，这个<code>clean</code>规则就不会执行了！</p>
<p>如果我们希望<code>make</code>把<code>clean</code>不要视为文件，可以添加一个标识：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f m.txt</span><br><span class="line">	rm -f x.txt</span><br></pre></td></tr></table></figure>
<p>此时，<code>clean</code>就不被视为一个文件，而是伪目标（Phony Target）。</p>
<p>大型项目通常会提供<code>clean</code>、<code>install</code>这些约定俗成的伪目标名称，方便用户快速执行特定任务。</p>
<p>一般来说，并不需要用<code>.PHONY</code>标识<code>clean</code>等约定俗成的伪目标名称，除非有人故意搞破坏，手动创建名字叫<code>clean</code>的文件。</p>
<h3 id="执行多条命令">执行多条命令</h3>
<p>一个规则可以有多条命令，例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd:</span></span><br><span class="line">	pwd</span><br><span class="line">	cd ..</span><br><span class="line">	pwd</span><br></pre></td></tr></table></figure>
<p>执行<code>cd</code>规则：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make cd</span><br><span class="line">pwd</span><br><span class="line">/home/ubuntu/makefile-tutorial/v1</span><br><span class="line">cd ..</span><br><span class="line">pwd</span><br><span class="line">/home/ubuntu/makefile-tutorial/v1</span><br></pre></td></tr></table></figure>
<p>观察输出，发现<code>cd ..</code>命令执行后，并未改变当前目录，两次输出的<code>pwd</code>是一样的，这是因为<code>make</code>针对每条命令，都会创建一个独立的Shell环境，类似<code>cd ..</code>这样的命令，并不会影响当前目录。</p>
<p>解决办法是把多条命令以<code>;</code>分隔，写到一行：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">	pwd; cd ..; pwd;</span><br></pre></td></tr></table></figure>
<p>再执行<code>cd_ok</code>目标就得到了预期结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make cd_ok</span><br><span class="line">pwd; cd ..; pwd</span><br><span class="line">/home/ubuntu/makefile-tutorial/v1</span><br><span class="line">/home/ubuntu/makefile-tutorial</span><br></pre></td></tr></table></figure>
<p>可以使用<code>\</code>把一行语句拆成多行，便于浏览：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">	pwd; \</span><br><span class="line">	cd ..; \</span><br><span class="line">	pwd</span><br></pre></td></tr></table></figure>
<p>另一种执行多条命令的语法是用<code>&amp;&amp;</code>，它的好处是当某条命令失败时，后续命令不会继续执行：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">	cd .. &amp;&amp; pwd</span><br></pre></td></tr></table></figure>
<h3 id="控制打印">控制打印</h3>
<p>默认情况下，<code>make</code>会打印出它执行的每一条命令。如果我们不想打印某一条命令，可以在命令前加上<code>@</code>，表示不打印命令（但是仍然会执行）：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">no_output:</span></span><br><span class="line">	@echo &#x27;not display&#x27;</span><br><span class="line">	echo &#x27;will display&#x27;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make no_output</span><br><span class="line">not display</span><br><span class="line">echo &#x27;will display&#x27;</span><br><span class="line">will display</span><br></pre></td></tr></table></figure>
<p>注意命令<code>echo 'not display'</code>本身没有打印，但命令仍然会执行，并且执行的结果仍然正常打印。</p>
<h3 id="控制错误">控制错误</h3>
<p><code>make</code>在执行命令时，会检查每一条命令的返回值，如果返回错误（非0值），就会中断执行。</p>
<p>例如，不使用<code>-f</code>删除一个不存在的文件会报错：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">has_error:</span></span><br><span class="line">	rm zzz.txt</span><br><span class="line">	echo &#x27;ok&#x27;</span><br></pre></td></tr></table></figure>
<p>执行上述目标，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make has_error</span><br><span class="line">rm zzz.txt</span><br><span class="line">rm: zzz.txt: No such file or directory</span><br><span class="line">make: *** [has_error] Error 1</span><br></pre></td></tr></table></figure>
<p>由于命令<code>rm zzz.txt</code>报错，导致后面的命令<code>echo 'ok'</code>并不会执行，<code>make</code>打印出错误，然后退出。</p>
<p>有些时候，我们想忽略错误，继续执行后续命令，可以在需要忽略错误的命令前加上<code>-</code>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ignore_error:</span></span><br><span class="line">	-rm zzz.txt</span><br><span class="line">	echo &#x27;ok&#x27;</span><br></pre></td></tr></table></figure>
<p>执行上述目标，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make ignore_error</span><br><span class="line">rm zzz.txt</span><br><span class="line">rm: zzz.txt: No such file or directory</span><br><span class="line">make: [ignore_error] Error 1 (ignored)</span><br><span class="line">echo &#x27;ok&#x27;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<p><code>make</code>检测到<code>rm zzz.txt</code>报错，并打印错误，但显示<code>(ignored)</code>，然后继续执行后续命令。</p>
<p>对于执行可能出错，但不影响逻辑的命令，可以用<code>-</code>忽略。</p>
<h3 id="参考源码">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v1">GitHub</a>下载源码。</p>
<h3 id="小结">小结</h3>
<p>编写<code>Makefile</code>就是编写一系列规则，用来告诉<code>make</code>如何执行这些规则，最终生成我们期望的目标文件。</p>
<p>查看官方手册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Rules.html">编写规则</a></li>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Execution.html">执行命令</a></li>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html">伪目标</a></li>
</ul>
<h2 id="编译C程序">编译C程序</h2>
<p>C程序的编译通常分两步：</p>
<ol>
<li>将每个<code>.c</code>文件编译为<code>.o</code>文件；</li>
<li>将所有<code>.o</code>文件链接为最终的可执行文件。</li>
</ol>
<p>我们假设如下的一个C项目，包含<code>hello.c</code>、<code>hello.h</code>和<code>main.c</code>。</p>
<p><code>hello.c</code>内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>hello.h</code>内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p><code>main.c</code>内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start...\n&quot;</span>);</span><br><span class="line">    hello();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>main.c</code>引用了头文件<code>hello.h</code>。我们很容易梳理出需要生成的文件，逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌───────┐ ┌───────┐ ┌───────┐</span><br><span class="line">│hello.c│ │main.c │ │hello.h│</span><br><span class="line">└───────┘ └───────┘ └───────┘</span><br><span class="line">    │         │         │</span><br><span class="line">    │         └────┬────┘</span><br><span class="line">    │              │</span><br><span class="line">    ▼              ▼</span><br><span class="line">┌───────┐      ┌───────┐</span><br><span class="line">│hello.o│      │main.o │</span><br><span class="line">└───────┘      └───────┘</span><br><span class="line">    │              │</span><br><span class="line">    └───────┬──────┘</span><br><span class="line">            │</span><br><span class="line">            ▼</span><br><span class="line">       ┌─────────┐</span><br><span class="line">       │world.out│</span><br><span class="line">       └─────────┘</span><br></pre></td></tr></table></figure>
<p>假定最终生成的可执行文件是<code>world.out</code>，中间步骤还需要生成<code>hello.o</code>和<code>main.o</code>两个文件。根据上述依赖关系，我们可以很容易地写出<code>Makefile</code>如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成可执行文件:</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">	cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 hello.c:</span></span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">	cc -c hello.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 main.c:</span></span><br><span class="line"><span class="section">main.o: main.c hello.h</span></span><br><span class="line">	cc -c main.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o world.out</span><br></pre></td></tr></table></figure>
<p>执行<code>make</code>，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -c main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>在当前目录下可以看到<code>hello.o</code>、<code>main.o</code>以及最终的可执行程序<code>world.out</code>。执行<code>world.out</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./world.out </span><br><span class="line">start...</span><br><span class="line">hello, world!</span><br><span class="line">exit.</span><br></pre></td></tr></table></figure>
<p>与我们预期相符。</p>
<p>修改<code>hello.c</code>，把输出改为<code>&quot;hello, bob!\n&quot;</code>，再执行<code>make</code>，观察输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>仅重新编译了<code>hello.c</code>，并未编译<code>main.c</code>。由于<code>hello.o</code>已更新，所以，仍然要重新生成<code>world.out</code>。执行<code>world.out</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./world.out </span><br><span class="line">start...</span><br><span class="line">hello, bob!</span><br><span class="line">exit.</span><br></pre></td></tr></table></figure>
<p>与我们预期相符。</p>
<p>修改<code>hello.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int 变为 void:</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>以及<code>hello.c</code>，再次执行<code>make</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -c main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>会触发<code>main.c</code>的编译，因为<code>main.c</code>依赖<code>hello.h</code>。</p>
<p>执行<code>make clean</code>会删除所有的<code>.o</code>文件，以及可执行文件<code>world.out</code>，再次执行<code>make</code>就会强制全量编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make clean &amp;&amp; make</span><br><span class="line">rm -f *.o world.out</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -c main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>这个简单的<code>Makefile</code>使我们能自动化编译C程序，十分方便。</p>
<p>不过，随着越来越多的<code>.c</code>文件被添加进来，如何高效维护<code>Makefile</code>的规则？我们后面继续讲解。</p>
<h3 id="参考源码-2">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v2">GitHub</a>下载源码。</p>
<h3 id="小结-2">小结</h3>
<p>在<code>Makefile</code>正确定义规则后，我们就能用<code>make</code>自动化编译C程序。</p>
<hr>
<hr>
<h2 id="使用隐式规则">使用隐式规则</h2>
<p>我们仍然以上一节的C项目为例，当我们添加越来越多的<code>.c</code>文件时，就需要编写越来越多的规则来生成<code>.o</code>文件。</p>
<p>实际上，有的同学可能发现了，即使我们把<code>.o</code>的规则删掉，也能正常编译：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只保留生成 world.out 的规则:</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">	cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o world.out</span><br></pre></td></tr></table></figure>
<p>执行<code>make</code>，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc    -c -o hello.o hello.c</span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>我们没有定义<code>hello.o</code>和<code>main.o</code>的规则，为什么<code>make</code>也能正常创建这两个文件？</p>
<p>因为<code>make</code>最初就是为了编译C程序而设计的，为了免去重复创建编译<code>.o</code>文件的规则，<code>make</code>内置了隐式规则（Implicit Rule），即遇到一个<code>xyz.o</code>时，如果没有找到对应的规则，就自动应用一个隐式规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">xyz.o: xyz.c</span></span><br><span class="line">	cc -c -o xyz.o xyz.c</span><br></pre></td></tr></table></figure>
<p><code>make</code>针对C、C++、ASM、Fortran等程序内置了一系列隐式规则，可以参考官方手册查看。</p>
<p>对于C程序来说，使用隐式规则有一个潜在问题，那就是无法跟踪<code>.h</code>文件的修改。如果我们修改了<code>hello.h</code>的定义，由于隐式规则<code>main.o: main.c</code>并不会跟踪<code>hello.h</code>的修改，导致<code>main.c</code>不会被重新编译，这个问题我们放到后面解决。</p>
<h3 id="参考源码-3">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v3">GitHub</a>下载源码。</p>
<h3 id="小结-3">小结</h3>
<p>针对C、C++、ASM、Fortran等程序，<code>make</code>内置了一系列隐式规则，使用隐式规则可减少大量重复的通用编译规则。</p>
<p>查看官方手册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Using-Implicit.html">使用隐式规则</a></li>
</ul>
<hr>
<hr>
<p>当我们在<code>Makefile</code>中重复写很多文件名时，一来容易写错，二来如果要改名，要全部替换，费时费力。</p>
<p>编程语言使用变量（Variable）来解决反复引用的问题，类似的，在<code>Makefile</code>中，也可以使用变量来解决重复问题。</p>
<p>以上一节的<code>Makefile</code>为例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">	cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o world.out</span><br></pre></td></tr></table></figure>
<p>编译的最终文件<code>world.out</code>重复出现了3次，因此，完全可以定义一个变量来替换它：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: hello.o main.o</span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>变量定义用<code>变量名 = 值</code>或者<code>变量名 := 值</code>，通常变量名全大写。引用变量用<code>$(变量名)</code>，非常简单。</p>
<p>注意到<code>hello.o main.o</code>这个“列表”也重复了，我们也可以用变量来替换：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OBJS = hello.o main.o</span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>如果有一种方式能让<code>make</code>自动生成<code>hello.o main.o</code>这个“列表”，就更好了。注意到每个<code>.o</code>文件是由对应的<code>.c</code>文件编译产生的，因此，可以让<code>make</code>先获取<code>.c</code>文件列表，再替换，得到<code>.o</code>文件列表：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $(wildcard *.c) 列出当前目录下的所有 .c 文件: hello.c main.c</span></span><br><span class="line"><span class="comment"># 用函数 patsubst 进行模式替换得到: hello.o main.o</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>这样，我们每添加一个<code>.c</code>文件，不需要修改<code>Makefile</code>，变量<code>OBJS</code>会自动更新。</p>
<p>思考：为什么我们不能直接定义<code>OBJS = $(wildcard *.o)</code>让<code>make</code>列出所有<code>.o</code>文件？</p>
<h3 id="内置变量">内置变量</h3>
<p>我们还可以用变量<code>$(CC)</code>替换命令<code>cc</code>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure>
<p>没有定义变量<code>CC</code>也可以引用它，因为它是<code>make</code>的内置变量（Builtin Variables），表示C编译器的名字，默认值是<code>cc</code>，我们也可以修改它，例如使用交叉编译时，指定编译器：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC = riscv64-linux-gnu-gcc</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="自动变量">自动变量</h3>
<p>在<code>Makefile</code>中，经常可以看到<code>$@</code>、<code>$&lt;</code>这样的变量，这种变量称为自动变量（Automatic Variable），它们在一个规则中自动指向某个值。</p>
<p>例如，<code>$@</code>表示目标文件，<code>$^</code>表示所有依赖文件，因此，我们可以这么写：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">	cc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure>
<p>在没有歧义时可以写<code>$@</code>，也可以写<code>$(@)</code>，有歧义时必须用括号，例如<code>$(@D)</code>。</p>
<p>为了更好地调试，我们还可以把变量打印出来：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">	@echo &#x27;$<span class="variable">$@</span> = <span class="variable">$@</span>&#x27; <span class="comment"># 变量 $@ 表示target</span></span><br><span class="line">	@echo &#x27;$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>&#x27; <span class="comment"># 变量 $&lt; 表示第一个依赖项</span></span><br><span class="line">	@echo &#x27;$<span class="variable">$^</span> = <span class="variable">$^</span>&#x27; <span class="comment"># 变量 $^ 表示所有依赖项</span></span><br><span class="line">	cc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure>
<p>执行结果输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$@ = world.out</span><br><span class="line">$&lt; = hello.o</span><br><span class="line">$^ = hello.o main.o</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<h3 id="参考源码-4">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v4">GitHub</a>下载源码。</p>
<h3 id="小结-4">小结</h3>
<p>使用变量可以让<code>Makefile</code>更加容易维护。</p>
<p>查看官方手册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Using-Variables.html">如何使用变量</a></li>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">自动变量</a></li>
</ul>
<h2 id="使用模式规则">使用模式规则</h2>
<p>前面我们讲了使用隐式规则可以让<code>make</code>在必要时自动创建<code>.o</code>文件的规则，但<code>make</code>的隐式规则的命令是固定的，对于<code>xyz.o: xyz.c</code>，它实际上是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>能修改的只有变量<code>$(CC)</code>和<code>$(CFLAGS)</code>。如果要执行多条命令，使用隐式规则就不行了。</p>
<p>这时，我们可以自定义模式规则（Pattern Rules），它允许<code>make</code>匹配模式规则，如果匹配上了，就自动创建一条模式规则。</p>
<p>我们修改上一节的<code>Makefile</code>如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式匹配规则：当make需要目标 xyz.o 时，自动生成一条 xyz.o: xyz.c 规则:</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	@echo &#x27;compiling <span class="variable">$&lt;</span>...&#x27;</span><br><span class="line">	cc -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>当<code>make</code>执行<code>world.out: hello.o main.o</code>时，发现没有<code>hello.o</code>文件，于是需要查找以<code>hello.o</code>为目标的规则，结果匹配到模式规则<code>%.o: %.c</code>，于是<code>make</code>自动根据模式规则为我们动态创建了如下规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">	@echo &#x27;compiling <span class="variable">$&lt;</span>...&#x27;</span><br><span class="line">	cc -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>查找<code>main.o</code>也是类似的匹配过程，于是我们执行<code>make</code>，就可以用模式规则完成编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">compiling hello.c...</span><br><span class="line">cc -c -o hello.o hello.c</span><br><span class="line">compiling main.c...</span><br><span class="line">cc -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>模式规则的命令完全由我们自己定义，因此，它比隐式规则更灵活。</p>
<p>但是，模式规则仍然没有解决修改<code>hello.h</code>头文件不会触发<code>main.c</code>重新编译的问题，这个依赖问题我们继续放到后面解决。</p>
<p>最后注意，模式规则是按需生成，如果我们在当前目录创建一个<code>zzz.o</code>文件，因为<code>make</code>并不会在执行过程中用到它，所以并不会自动生成<code>zzz.o: zzz.c</code>这个规则。</p>
<h3 id="参考源码-5">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v5">GitHub</a>下载源码。</p>
<h3 id="小结-5">小结</h3>
<p>使用模式规则可以灵活地按需动态创建规则，它比隐式规则更灵活。</p>
<p>查看官方手册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Pattern-Intro.html">模式规则</a></li>
</ul>
<hr>
<hr>
<p>前面我们讲了隐式规则和模式规则，这两种规则都可以解决自动把<code>.c</code>文件编译成<code>.o</code>文件，但都无法解决<code>.c</code>文件依赖<code>.h</code>文件的问题。</p>
<p>因为一个<code>.c</code>文件依赖哪个<code>.h</code>文件必须要分析文件内容才能确定，没有一个简单的文件名映射规则。</p>
<p>但是，要识别出<code>.c</code>文件的头文件依赖，可以用GCC提供的<code>-MM</code>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cc -MM main.c</span><br><span class="line">main.o: main.c hello.h</span><br></pre></td></tr></table></figure>
<p>上述输出告诉我们，编译<code>main.o</code>依赖<code>main.c</code>和<code>hello.h</code>两个文件。</p>
<p>因此，我们可以利用GCC的这个功能，对每个<code>.c</code>文件都生成一个依赖项，通常我们把它保存到<code>.d</code>文件中，再用<code>include</code>引入到<code>Makefile</code>，就相当于自动化完成了每个<code>.c</code>文件的精准依赖。</p>
<p>我们改写上一节的<code>Makefile</code>如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有 .c 文件:</span></span><br><span class="line">SRCS = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据SRCS生成 .o 文件列表:</span></span><br><span class="line">OBJS = $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据SRCS生成 .d 文件列表:</span></span><br><span class="line">DEPS = $(SRCS:.c=.d)</span><br><span class="line"></span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标:</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># xyz.d 的规则由 xyz.c 生成:</span></span><br><span class="line"><span class="section">%.d: %.c</span></span><br><span class="line">	rm -f <span class="variable">$@</span>; \</span><br><span class="line">	<span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> &gt;<span class="variable">$@</span>.tmp; \</span><br><span class="line">	sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.tmp &gt; <span class="variable">$@</span>; \</span><br><span class="line">	rm -f <span class="variable">$@</span>.tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式规则:</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf *.o *.d <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入所有 .d 文件:</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(DEPS)</span></span><br></pre></td></tr></table></figure>
<p>变量<code>$(SRCS)</code>通过扫描目录可以确定为<code>hello.c main.c</code>，因此，变量<code>$(OBJS)</code>赋值为<code>hello.o main.o</code>，变量<code>$(DEPS)</code>赋值为<code>hello.d main.d</code>。</p>
<p>通过<code>include $(DEPS)</code>我们引入<code>hello.d</code>和<code>main.d</code>文件，但是这两个文件一开始并不存在，不过，<code>make</code>通过模式规则匹配到<code>%.d: %.c</code>，这就给了我们一个机会，在这个模式规则内部，用<code>cc -MM</code>命令外加<code>sed</code>把<code>.d</code>文件创建出来。</p>
<p>运行<code>make</code>，首次输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">Makefile:31: hello.d: No such file or directory</span><br><span class="line">Makefile:31: main.d: No such file or directory</span><br><span class="line">rm -f main.d; \</span><br><span class="line">        cc -MM main.c &gt;main.d.tmp; \</span><br><span class="line">        sed &#x27;s,\(main\)\.o[ :]*,\1.o main.d : ,g&#x27; &lt; main.d.tmp &gt; main.d; \</span><br><span class="line">        rm -f main.d.tmp</span><br><span class="line">rm -f hello.d; \</span><br><span class="line">        cc -MM hello.c &gt;hello.d.tmp; \</span><br><span class="line">        sed &#x27;s,\(hello\)\.o[ :]*,\1.o hello.d : ,g&#x27; &lt; hello.d.tmp &gt; hello.d; \</span><br><span class="line">        rm -f hello.d.tmp</span><br><span class="line">cc -c -o hello.o hello.c</span><br><span class="line">cc -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p><code>make</code>会提示找不到<code>hello.d</code>和<code>main.d</code>，不过随后自动创建出<code>hello.d</code>和<code>main.d</code>。<code>hello.d</code>内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello.o hello.d : hello.c</span><br></pre></td></tr></table></figure>
<p>上述规则有两个目标文件，实际上相当于如下两条规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello.o : hello.c</span><br><span class="line">hello.d : hello.c</span><br></pre></td></tr></table></figure>
<p><code>main.d</code>内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o main.d : main.c hello.h</span><br></pre></td></tr></table></figure>
<p>因此，<code>main.o</code>依赖于<code>main.c</code>和<code>hello.h</code>，这个依赖关系就和我们手动指定的一致。</p>
<p>改动<code>hello.h</code>，再次运行<code>make</code>，可以触发<code>main.c</code>的编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">rm -f main.d; \</span><br><span class="line">        cc -MM main.c &gt;main.d.tmp; \</span><br><span class="line">        sed &#x27;s,\(main\)\.o[ :]*,\1.o main.d : ,g&#x27; &lt; main.d.tmp &gt; main.d; \</span><br><span class="line">        rm -f main.d.tmp</span><br><span class="line">cc -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>在实际项目中，对每个<code>.c</code>文件都可以生成一个对应的<code>.d</code>文件表示依赖关系，再通过<code>include</code>引入到<code>Makefile</code>，同时又能让<code>make</code>自动更新<code>.d</code>文件，有点蛋生鸡和鸡生蛋的关系，不过，这种机制能正常工作，除了<code>.d</code>文件不存在时会打印错误，有强迫症的同学肯定感觉不满意，这个问题我们后面解决。</p>
<h3 id="参考源码-6">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v6">GitHub</a>下载源码。</p>
<h3 id="小结-6">小结</h3>
<p>利用GCC生成<code>.d</code>文件，再用<code>include</code>引入<code>Makefile</code>，可解决一个<code>.c</code>文件应该如何正确触发编译的问题。</p>
<p>查看官方手册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Automatic-Prerequisites.html">自动生成依赖</a></li>
</ul>
<h2 id="完善Makefile">完善Makefile</h2>
<p>上一节我们解决了自动生成依赖的问题，这一节我们对项目目录进行整理，把所有源码放入<code>src</code>目录，所有编译生成的文件放入<code>build</code>目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">├── Makefile</span><br><span class="line">├── build</span><br><span class="line">└── src</span><br><span class="line">    ├── hello.c</span><br><span class="line">    ├── hello.h</span><br><span class="line">    └── main.c</span><br></pre></td></tr></table></figure>
<p>整理<code>Makefile</code>，内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">SRC_DIR = ./src</span><br><span class="line">BUILD_DIR = ./build</span><br><span class="line">TARGET = <span class="variable">$(BUILD_DIR)</span>/world.out</span><br><span class="line"></span><br><span class="line">CC = cc</span><br><span class="line">CFLAGS = -Wall</span><br><span class="line"></span><br><span class="line"><span class="comment"># ./src/*.c</span></span><br><span class="line">SRCS = <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(SRC_DIR)</span> -name &#x27;*.c&#x27;)</span></span><br><span class="line"><span class="comment"># ./src/*.c =&gt; ./build/*.o</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c,<span class="variable">$(BUILD_DIR)</span>/%.o,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line"><span class="comment"># ./src/*.c =&gt; ./build/*.d</span></span><br><span class="line">DEPS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c,<span class="variable">$(BUILD_DIR)</span>/%.d,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标:</span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build/xyz.d 的规则由 src/xyz.c 生成:</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.d: <span class="variable">$(SRC_DIR)</span>/%.c</span><br><span class="line">	@mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>; \</span><br><span class="line">	rm -f <span class="variable">$@</span>; \</span><br><span class="line">	<span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> &gt;<span class="variable">$@</span>.tmp; \</span><br><span class="line">	sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,<span class="variable">$(BUILD_DIR)</span>/\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.tmp &gt; <span class="variable">$@</span>; \</span><br><span class="line">	rm -f <span class="variable">$@</span>.tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># build/xyz.o 的规则由 src/xyz.c 生成:</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.o: <span class="variable">$(SRC_DIR)</span>/%.c</span><br><span class="line">	@mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接:</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	@echo <span class="string">&quot;buiding <span class="variable">$@</span>...&quot;</span></span><br><span class="line">	@mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理 build 目录:</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	@echo <span class="string">&quot;clean...&quot;</span></span><br><span class="line">	rm -rf <span class="variable">$(BUILD_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入所有 .d 文件:</span></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br></pre></td></tr></table></figure>
<p>这个<code>Makefile</code>定义了源码目录<code>SRC_DIR</code>、生成目录<code>BUILD_DIR</code>，以及其他变量，同时用<code>-include</code>消除了<code>.d</code>文件不存在的错误。执行<code>make</code>，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -Wall -c -o build/hello.o src/hello.c</span><br><span class="line">cc -Wall -c -o build/main.o src/main.c</span><br><span class="line">buiding build/world.out...</span><br><span class="line">cc -o ./build/world.out ./build/hello.o ./build/main.o</span><br></pre></td></tr></table></figure>
<p>可以说基本满足编译需求，收工！</p>
<h3 id="参考源码-7">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v7">GitHub</a>下载源码。</p>
<h3 id="小结-7">小结</h3>
<p>除了基础的用法外，<code>Makefile</code>还支持条件判断，环境变量，嵌套执行，变量展开等各种功能，需要用到时可以查询<a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/index.html">官方手册</a>。</p>
<hr>
<hr>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2021/05/23/makefile%E6%95%99%E7%A8%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2021/05/09/database/oracelDB%E5%9F%BA%E7%A1%80/"
                            aria-label=": oracelDB基础"
                        >
                            oracelDB基础
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-05-09T07:15:08+08:00">
	
		    2021 年 5 月 9 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../categories/database/">database</a>, <a class="category-link" href="../../categories/database/oracleDB/">oracleDB</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1>OracleDB 笔记整理</h1>
<h2 id="1-SQL-分类">1. SQL 分类</h2>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DML</strong> (Data Manipulation Language)</td>
<td>数据操作语言</td>
<td><code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>MERGE</code></td>
</tr>
<tr>
<td><strong>DDL</strong> (Data Definition Language)</td>
<td>数据定义语言</td>
<td><code>CREATE</code>, <code>ALTER</code>, <code>DROP</code>, <code>RENAME</code>, <code>TRUNCATE</code>, <code>COMMENT</code></td>
</tr>
<tr>
<td><strong>DCL</strong> (Data Control Language)</td>
<td>数据控制语言</td>
<td><code>GRANT</code>, <code>REVOKE</code></td>
</tr>
<tr>
<td><strong>事务</strong> (Transaction)</td>
<td>事务控制</td>
<td><code>COMMIT</code>, <code>ROLLBACK</code>, <code>SAVEPOINT</code></td>
</tr>
</tbody>
</table>
<h2 id="2-OracleDB-构成">2. OracleDB 构成</h2>
<h3 id="2-1-基本构成">2.1 基本构成</h3>
<p>OracleDB 由 <strong>Oracle实例(instance)</strong> 和 <strong>Database</strong> 构成：</p>
<ul>
<li><strong>实例(Instance)</strong> 由：
<ul>
<li><strong>SGA(System Global Area)</strong>：内存区域</li>
<li><strong>Background Process</strong>：后台进程</li>
</ul>
</li>
<li><strong>Database</strong> 由：
<ul>
<li>控制文件（制御ファイル）</li>
<li>REDO 文件（REDO ログ）</li>
<li>数据文件（データファイル）</li>
</ul>
</li>
</ul>
<h3 id="2-2-进程视角">2.2 进程视角</h3>
<p>除了实例中的 <strong>Background Process</strong>，还包括：</p>
<ul>
<li>用户进程</li>
<li>服务器进程</li>
<li>监听进程</li>
</ul>
<h3 id="2-3-工具列表">2.3 工具列表</h3>
<h4 id="安装和升级相关工具">安装和升级相关工具</h4>
<table>
<thead>
<tr>
<th>工具名</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>Oracle Universal Installer (OUI)</td>
<td>安装 Oracle 软件</td>
</tr>
<tr>
<td>Oracle Database Configuration Assistant (DBCA)</td>
<td>创建数据库</td>
</tr>
<tr>
<td>Oracle Database Upgrade Assistant (DBUA)</td>
<td>升级现有数据库到新版本</td>
</tr>
</tbody>
</table>
<h4 id="网络相关工具">网络相关工具</h4>
<table>
<thead>
<tr>
<th>工具名</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>Oracle Net Manager (netmgr)</td>
<td>配置 Oracle 网络</td>
</tr>
<tr>
<td>Oracle Net Configuration Assistant (netca)</td>
<td>配置 Oracle 网络</td>
</tr>
</tbody>
</table>
<h4 id="实例和数据库管理工具">实例和数据库管理工具</h4>
<table>
<thead>
<tr>
<th>工具名</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>Oracle Enterprise Manager (EM)</td>
<td>管理 Oracle DB</td>
</tr>
<tr>
<td>SQL*Plus</td>
<td>SQL 命令行工具</td>
</tr>
<tr>
<td>SQL Developer</td>
<td>图形化数据库管理工具</td>
</tr>
<tr>
<td>Recovery Manager (RMAN)</td>
<td>数据库备份、恢复、复原</td>
</tr>
<tr>
<td>Oracle Secure Backup</td>
<td>备份管理</td>
</tr>
<tr>
<td>Data Pump</td>
<td>数据库间高速数据传输</td>
</tr>
<tr>
<td>SQL*Loader</td>
<td>外部文件数据批量导入</td>
</tr>
</tbody>
</table>
<h2 id="3-安装">3. 安装</h2>
<h3 id="3-1-OUI-功能">3.1 OUI 功能</h3>
<ul>
<li>显示已安装的 Oracle 软件</li>
<li>安装新软件</li>
<li>删除软件</li>
<li>查看在线帮助</li>
<li>检查安装需求</li>
</ul>
<h3 id="3-2-系统要求">3.2 系统要求</h3>
<ul>
<li><strong>内存</strong>：1GB</li>
<li><strong>SWAP</strong>：1.5GB</li>
<li><strong>硬盘空间</strong>：
<ul>
<li>最小 1GB</li>
<li>一般需要 6.1GB</li>
</ul>
</li>
</ul>
<h3 id="3-3-创建用户和组">3.3 创建用户和组</h3>
<ul>
<li><strong>软件所有者</strong>：Oracle 用户</li>
<li><strong>Oracle Inventory Group</strong>：用于管理 Oracle 软件</li>
<li><strong>DB 管理组</strong>：
<ul>
<li><code>OSDBA</code>：数据库管理员组</li>
<li><code>OSOPER</code>：受限制的数据库管理员组</li>
</ul>
</li>
</ul>
<h3 id="3-4-环境变量">3.4 环境变量</h3>
<table>
<thead>
<tr>
<th>变量名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ORACLE_BASE</code></td>
<td>Oracle 主目录</td>
</tr>
<tr>
<td><code>ORACLE_HOME</code></td>
<td>Oracle 软件安装位置</td>
</tr>
<tr>
<td><code>ORACLE_SID</code></td>
<td>系统标识（实例名）</td>
</tr>
<tr>
<td><code>LD_LIBRARY_PATH</code></td>
<td>共享库路径（如 <code>$ORACLE_HOME/lib</code>）</td>
</tr>
</tbody>
</table>
<h3 id="3-5-安装脚本">3.5 安装脚本</h3>
<table>
<thead>
<tr>
<th>脚本名</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>orainstRoot.sh</code></td>
<td>生成 inventory pointer 文件</td>
</tr>
<tr>
<td><code>root.sh</code></td>
<td>生成 <code>oratab</code> 并设置环境变量 (<code>oraenv</code> 和 <code>coraenv</code>)，指定 <code>dbstart</code> 和 <code>dbshut</code> 脚本</td>
</tr>
</tbody>
</table>
<h3 id="3-6-创建数据库（DBCA）">3.6 创建数据库（DBCA）</h3>
<h4 id="3-6-1-指定-Global-DB-名">3.6.1 指定 Global DB 名</h4>
<p>格式：<code>database_name.domain_name</code></p>
<h4 id="3-6-2-Enterprise-Manager-选项">3.6.2 Enterprise Manager 选项</h4>
<ul>
<li><strong>Database Express</strong>：单数据库管理</li>
<li><strong>Cloud Control</strong>：集中管理多个数据库（需预先安装 Cloud Control）</li>
</ul>
<h4 id="3-6-3-存储类型">3.6.3 存储类型</h4>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件系统</td>
<td>使用操作系统文件</td>
</tr>
<tr>
<td>ASM (Automatic Storage Management)</td>
<td>文件存储在 ASM 磁盘组，需额外实例</td>
</tr>
</tbody>
</table>
<h4 id="3-6-4-数据库文件位置">3.6.4 数据库文件位置</h4>
<ul>
<li><strong>使用模板的文件位置</strong></li>
<li><strong>所有数据库文件共享文件夹</strong></li>
<li><strong>Oracle Managed Files</strong>：由 Oracle 直接管理文件</li>
</ul>
<h4 id="3-6-5-模板">3.6.5 模板</h4>
<p>模板包含以下信息：</p>
<ul>
<li>数据库选项</li>
<li>初始化参数</li>
<li>存储属性（数据文件、表空间、控制文件、REDO 日志属性）</li>
</ul>
<h5 id="模板分类">模板分类</h5>
<table>
<thead>
<tr>
<th>模板类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>通用事务处理（默认）</td>
<td>适用于 OLTP 场景</td>
</tr>
<tr>
<td>数据仓库 (Data Warehouse)</td>
<td>适用于复杂查询和大数据处理</td>
</tr>
<tr>
<td>自定义模板</td>
<td>用户自定义配置</td>
</tr>
</tbody>
</table>
<h5 id="模板形式">模板形式</h5>
<table>
<thead>
<tr>
<th>形式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sheet Template</td>
<td>包含现有数据库结构和物理文件</td>
</tr>
<tr>
<td>Non-Sheet Template</td>
<td>仅包含数据库特性</td>
</tr>
</tbody>
</table>
<h2 id="4-EM-Express">4. EM Express</h2>
<h3 id="4-1-功能">4.1 功能</h3>
<ul>
<li>提供数据库管理功能（<strong>不包括启动/停止数据库</strong>）</li>
<li>如需启动/停止数据库，需使用 <strong>Oracle Enterprise Manager Cloud Control</strong></li>
</ul>
<h3 id="4-2-手动配置-EM-Express">4.2 手动配置 EM Express</h3>
<ol>
<li><strong>启动监听进程</strong></li>
<li><strong>初始化 <code>DISPATCHERS</code> 参数</strong>（设置 <code>PROTOCOL=TCP</code>）：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatchers<span class="operator">=</span>&quot;(PROTOCOL=TCP)(SERVICE=&lt;sid&gt;XDB)&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><strong>设置端口</strong>（需 <code>SYSDBA</code> 权限）：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> DBMS_XDB_CONFIG.setHTTPSPORT(<span class="number">5500</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="4-3-使用-EM-Express">4.3 使用 EM Express</h3>
<h4 id="4-3-1-查询-EM-Express-端口">4.3.1 查询 EM Express 端口</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DBMS_XDB_CONFIG.getHTTPSPort <span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-2-权限分配">4.3.2 权限分配</h4>
<table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EM_EXPRESS_BASIC</code></td>
<td>只读模式</td>
</tr>
<tr>
<td><code>EM_EXPRESS_ALL</code></td>
<td>完全权限</td>
</tr>
</tbody>
</table>
<h3 id="4-4-连接数据库">4.4 连接数据库</h3>
<h4 id="4-4-1-SQL-Plus-连接方式">4.4.1 SQL*Plus 连接方式</h4>
<ol>
<li>运行 <code>oraenv</code> 设置环境变量：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. oraenv</span><br></pre></td></tr></table></figure>
</li>
<li>启动 SQL*Plus（<code>/nolog</code> 表示不登录数据库）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlplus /nolog</span><br></pre></td></tr></table></figure>
</li>
<li>连接数据库：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span><span class="operator">/</span><span class="operator">&lt;</span>密码<span class="operator">&gt;</span> [<span class="keyword">AS</span> SYSDBA <span class="operator">|</span> <span class="keyword">AS</span> SYSOPER]</span><br></pre></td></tr></table></figure>
</li>
<li>其他功能：
<ul>
<li>执行 SQL 脚本：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="operator">&lt;</span><span class="keyword">sql</span>文件名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>执行操作系统命令：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOST <span class="operator">&lt;</span>命令<span class="operator">&gt;</span>  # 例如：HOST ls</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="4-4-2-SQL-Developer-连接方式">4.4.2 SQL Developer 连接方式</h4>
<ol>
<li>运行 <code>oraenv</code> 设置环境变量：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. oraenv</span><br></pre></td></tr></table></figure>
</li>
<li>启动 SQL Developer：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$ORACLE_HOME</span>/sqldeveloper</span><br><span class="line">sh sqldeveloper.sh</span><br></pre></td></tr></table></figure>
</li>
<li>功能：
<ul>
<li><strong>普通模式</strong>：查看、创建、编辑、删除表、视图等对象</li>
<li><strong>DBA Navigator</strong>：连接 DBA 用户后可启动/停止数据库</li>
</ul>
</li>
</ol>
<h2 id="5-Oracle-网络构成">5. Oracle 网络构成</h2>
<h3 id="5-1-Oracle-Net-概述">5.1 Oracle Net 概述</h3>
<ul>
<li><strong>功能</strong>：提供网络服务</li>
<li><strong>安装方式</strong>：随 Oracle 数据库软件或客户端一同安装</li>
<li><strong>通信模式</strong>：
<ul>
<li><strong>客户端-服务端模式</strong>：两端均需安装 Oracle Net</li>
<li><strong>客户端-Web 服务器-DB 服务器模式</strong>：客户端和 Web 服务器需安装 Oracle Net</li>
</ul>
</li>
</ul>
<h3 id="5-2-通信条件">5.2 通信条件</h3>
<table>
<thead>
<tr>
<th><strong>角色</strong></th>
<th><strong>要求</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DB 服务端</strong></td>
<td>1. 网络服务器在线<br>2. 已安装 Oracle DB<br>3. 支持 TCP/IP 协议<br>4. 监听进程已启动</td>
</tr>
<tr>
<td><strong>客户端</strong></td>
<td>1. 网络服务器在线<br>2. 已安装 Oracle 客户端<br>3. 支持 TCP/IP 协议</td>
</tr>
</tbody>
</table>
<h3 id="5-3-监听进程">5.3 监听进程</h3>
<ul>
<li>
<p><strong>自动安装</strong>：通过 OUI 初始化 DB 时，NetCA 会默认安装监听进程</p>
</li>
<li>
<p><strong>作用</strong>：处理客户端连接请求（连接建立后不再参与通信）</p>
</li>
<li>
<p><strong>关键命令</strong>：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lsnrctl start &lt;监听进程名&gt;</code></td>
<td>启动监听进程</td>
</tr>
<tr>
<td><code>lsnrctl stop &lt;监听进程名&gt;</code></td>
<td>停止监听进程</td>
</tr>
<tr>
<td><code>lsnrctl status &lt;监听进程名&gt;</code></td>
<td>查看状态</td>
</tr>
<tr>
<td><code>lsnrctl services &lt;监听进程名&gt;</code></td>
<td>查看支持的服务</td>
</tr>
<tr>
<td><code>LSNRCTL&gt; set current_listener &lt;名称&gt;</code></td>
<td>切换监听进程（需交互模式）</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="5-4-客户端构成">5.4 客户端构成</h3>
<ul>
<li><strong>数据库连接示例</strong>：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> hr@(DESCRIPTION <span class="operator">=</span> </span><br><span class="line">  (ADDRESS <span class="operator">=</span> (PROTOCOL <span class="operator">=</span> TCP)(HOST <span class="operator">=</span> proj1<span class="operator">-</span>sv)(PORT <span class="operator">=</span> <span class="number">1521</span>))</span><br><span class="line">  (CONNECT_DATA <span class="operator">=</span> (SERVICE_NAME <span class="operator">=</span> sales.edifist.com)))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-5-命名方法">5.5 命名方法</h3>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>存储位置</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>本地命名</strong></td>
<td>客户端 <code>tnsnames.ora</code></td>
<td>网络服务名映射存储在本地文件</td>
</tr>
<tr>
<td><strong>LDAP 基准</strong></td>
<td>LDAP 服务器</td>
<td>集中管理服务名映射</td>
</tr>
<tr>
<td><strong>简易连接命名</strong></td>
<td>无</td>
<td>直接使用 TCP/IP 连接字符串（如 <code>connect scott@host名/服务名</code>）</td>
</tr>
<tr>
<td><strong>外部命名</strong></td>
<td>第三方命名服务（如 NIS）</td>
<td>依赖非 Oracle 服务</td>
</tr>
</tbody>
</table>
<h4 id="本地命名配置方法">本地命名配置方法</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netca  <span class="comment"># 启动图形化配置工具</span></span><br></pre></td></tr></table></figure>
<h4 id="简易连接示例">简易连接示例</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlplus <span class="operator">/</span>nolog</span><br><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">CONNECT</span> hr<span class="operator">/</span>hr<span class="variable">@oracle_sv</span><span class="operator">/</span>orcl.edifist.com</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="6-数据库服务器架构概要">6. 数据库服务器架构概要</h2>
<h3 id="6-1-核心组件">6.1 核心组件</h3>
<ul>
<li><strong>Oracle 实例</strong>：内存结构（SGA） + 后台进程</li>
<li><strong>Oracle 数据库</strong>：物理文件集合</li>
</ul>
<h3 id="6-2-SGA-System-Global-Area-构成">6.2 SGA (System Global Area) 构成</h3>
<table>
<thead>
<tr>
<th><strong>组件</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据库缓存</strong></td>
<td>存储数据块（Buffer Cache）</td>
</tr>
<tr>
<td><strong>REDO 日志 Buffer</strong></td>
<td>记录数据变更历史</td>
</tr>
<tr>
<td><strong>共享池</strong></td>
<td>缓存 SQL/PLSQL 解析结果、执行计划、数据字典</td>
</tr>
<tr>
<td><strong>Large Pool</strong></td>
<td>可选，用于共享服务器模式、并行查询、RMAN 备份等</td>
</tr>
<tr>
<td><strong>Java Pool</strong></td>
<td>支持 Java 虚拟机（JVM）</td>
</tr>
<tr>
<td><strong>Stream Pool</strong></td>
<td>支持 Oracle Stream 数据复制</td>
</tr>
</tbody>
</table>
<h3 id="6-3-关键后台进程">6.3 关键后台进程</h3>
<table>
<thead>
<tr>
<th><strong>进程</strong></th>
<th><strong>名称</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SMON</strong></td>
<td>System Monitor</td>
<td>实例恢复（如崩溃后自动修复）</td>
</tr>
<tr>
<td><strong>PMON</strong></td>
<td>Process Monitor</td>
<td>清理异常终止的用户进程资源</td>
</tr>
<tr>
<td><strong>DBWn</strong></td>
<td>Database Writer</td>
<td>将脏缓冲区写入数据文件</td>
</tr>
<tr>
<td><strong>CKPT</strong></td>
<td>Checkpoint</td>
<td>触发 DBWn 写入，更新控制文件（用于灾难恢复）</td>
</tr>
<tr>
<td><strong>LGWR</strong></td>
<td>Log Writer</td>
<td>将 REDO 日志缓冲区写入磁盘</td>
</tr>
<tr>
<td><strong>ARCn</strong></td>
<td>Archiver</td>
<td>归档 REDO 日志</td>
</tr>
<tr>
<td><strong>MMON</strong></td>
<td>Manageability Monitor</td>
<td>执行 AWR（自动工作负载仓库）相关任务</td>
</tr>
</tbody>
</table>
<h3 id="6-4-用户与服务器进程">6.4 用户与服务器进程</h3>
<ul>
<li><strong>用户进程</strong>：运行应用程序（如 SQL*Plus）</li>
<li><strong>服务器进程</strong>：处理用户提交的 SQL 查询</li>
</ul>
<h3 id="6-5-PGA-Program-Global-Area">6.5 PGA (Program Global Area)</h3>
<ul>
<li><strong>特点</strong>：非共享内存，仅限单个进程访问</li>
<li><strong>用途</strong>：存储 SQL 执行时的排序区、会话信息等</li>
</ul>
<hr>
<h2 id="7-实例启停">7. 实例启停</h2>
<h3 id="7-1-启动方法">7.1 启动方法</h3>
<ul>
<li>SQL*Plus（<code>STARTUP</code> 命令）</li>
<li>Windows 服务管理器</li>
<li>SQL Developer</li>
<li>Enterprise Manager Cloud Control</li>
</ul>
<h3 id="7-2-启动状态迁移">7.2 启动状态迁移</h3>
<table>
<thead>
<tr>
<th><strong>状态</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>NOMOUNT</strong></td>
<td>读取参数文件，分配 SGA，启动后台进程（控制文件未打开）</td>
</tr>
<tr>
<td><strong>MOUNT</strong></td>
<td>打开控制文件（获知数据文件/日志文件路径，但未打开文件）</td>
</tr>
<tr>
<td><strong>OPEN</strong></td>
<td>打开所有数据文件和 REDO 日志，数据库可用</td>
</tr>
</tbody>
</table>
<h3 id="7-3-权限要求">7.3 权限要求</h3>
<table>
<thead>
<tr>
<th><strong>权限</strong></th>
<th><strong>能力</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SYSDBA</strong></td>
<td>完全控制（包括启停实例、用户授权）</td>
</tr>
<tr>
<td><strong>SYSOPER</strong></td>
<td>仅限启停实例（无权管理用户对象）</td>
</tr>
</tbody>
</table>
<h4 id="连接示例">连接示例</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> 用户名<span class="operator">/</span>密码 <span class="keyword">AS</span> &#123;SYSOPER <span class="operator">|</span> SYSDBA&#125;</span><br><span class="line">sqlplus <span class="operator">/</span>nolog</span><br><span class="line"><span class="keyword">CONNECT</span> sys <span class="keyword">AS</span> sysdba</span><br><span class="line">STARTUP</span><br></pre></td></tr></table></figure>
<h3 id="7-4-停止流程">7.4 停止流程</h3>
<ol>
<li><strong>关闭数据库</strong>（OPEN → CLOSED）
<ul>
<li>执行 Checkpoint，写入数据文件和 REDO 日志</li>
<li>关闭数据文件和 REDO 日志（控制文件仍打开）</li>
</ul>
</li>
<li><strong>卸载数据库</strong>（CLOSED → DISMOUNT）
<ul>
<li>实例与数据库分离</li>
</ul>
</li>
<li><strong>停止实例</strong>（DISMOUNT → SHUTDOWN）
<ul>
<li>终止后台进程，释放 SGA 内存</li>
</ul>
</li>
</ol>
<h3 id="7-5-停止模式对比">7.5 停止模式对比</h3>
<table>
<thead>
<tr>
<th><strong>行为</strong></th>
<th>NORMAL</th>
<th>TRANSACTIONAL</th>
<th>IMMEDIATE</th>
<th>ABORT</th>
</tr>
</thead>
<tbody>
<tr>
<td>接受新连接</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>等待当前会话结束</td>
<td>✓</td>
<td>✓</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>等待当前事务结束</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>×</td>
</tr>
<tr>
<td>执行 Checkpoint 后关闭</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>×</td>
</tr>
</tbody>
</table>
<h3 id="7-6-初始化参数文件">7.6 初始化参数文件</h3>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>名称</strong></th>
<th><strong>特点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>静态</strong></td>
<td>PFILE（文本文件）</td>
<td>手动编辑，需重启生效</td>
</tr>
<tr>
<td><strong>动态</strong></td>
<td>SPFILE（二进制文件）</td>
<td>支持在线修改（<code>ALTER SYSTEM</code>），优先使用</td>
</tr>
</tbody>
</table>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2021/05/09/database/oracelDB%E5%9F%BA%E7%A1%80/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2021/03/12/vim%E6%95%99%E7%A8%8B/"
                            aria-label=": vim教程"
                        >
                            vim教程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-03-12T16:01:20+08:00">
	
		    2021 年 3 月 12 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../categories/devops/">devops</a>, <a class="category-link" href="../../categories/devops/vim/">vim</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1>Vim 编辑器使用笔记整理</h1>
<h2 id="1-退出-Vim">1. 退出 Vim</h2>
<h3 id="命令行模式退出方式">命令行模式退出方式</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>:wq</code></td>
<td>保存并退出</td>
</tr>
<tr>
<td><code>:q!</code></td>
<td>强制退出，不保存</td>
</tr>
<tr>
<td><code>:q</code></td>
<td>退出(未修改时)</td>
</tr>
<tr>
<td><code>:wq!</code></td>
<td>强制保存并退出</td>
</tr>
<tr>
<td><code>:w &lt;文件路径&gt;</code></td>
<td>另存为指定文件</td>
</tr>
<tr>
<td><code>:saveas 文件路径</code></td>
<td>另存为指定文件</td>
</tr>
<tr>
<td><code>:x</code></td>
<td>保存并退出(类似:wq)</td>
</tr>
</tbody>
</table>
<h3 id="普通模式退出方式">普通模式退出方式</h3>
<ul>
<li>输入 <code>Shift+zz</code> 即可保存退出</li>
</ul>
<h2 id="2-删除文本">2. 删除文本</h2>
<h3 id="普通模式删除命令">普通模式删除命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x</code></td>
<td>删除游标所在字符</td>
</tr>
<tr>
<td><code>X</code></td>
<td>删除游标前一个字符</td>
</tr>
<tr>
<td><code>Delete</code></td>
<td>同 <code>x</code></td>
</tr>
<tr>
<td><code>dd</code></td>
<td>删除整行</td>
</tr>
<tr>
<td><code>dw</code></td>
<td>删除一个单词(不适用中文)</td>
</tr>
<tr>
<td><code>d$</code> 或 <code>D</code></td>
<td>删除至行尾</td>
</tr>
<tr>
<td><code>d^</code></td>
<td>删除至行首</td>
</tr>
<tr>
<td><code>dG</code></td>
<td>删除到文档结尾</td>
</tr>
<tr>
<td><code>d1G</code></td>
<td>删除至文档开头</td>
</tr>
<tr>
<td><code>:%d</code></td>
<td>清空整个文档内容（删除所有行）</td>
</tr>
<tr>
<td><code>:1,$d</code></td>
<td>同 <code>:%d</code>，删除从第一行到最后一行</td>
</tr>
<tr>
<td><code>ggdG</code></td>
<td>普通模式下清空文档的快捷方式（先跳转到首行，然后删除到末尾）</td>
</tr>
</tbody>
</table>
<p>注意：这些命令会立即生效且不可撤销，使用前请确保已保存重要内容</p>
<h3 id="数字前缀用法">数字前缀用法</h3>
<ul>
<li><code>2dd</code> 表示一次删除2行</li>
<li><code>3dw</code> 表示删除3个单词</li>
</ul>
<h2 id="3-重复执行命令">3. 重复执行命令</h2>
<ul>
<li>普通模式下 <code>.</code> (小数点)表示重复上一次命令</li>
<li>数字前缀：<code>10x</code> 删除10个连续字符</li>
</ul>
<h2 id="4-游标跳转">4. 游标跳转</h2>
<h3 id="行间跳转">行间跳转</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nG</code></td>
<td>跳转到第n行(需先<code>:set nu</code>显示行号)</td>
</tr>
<tr>
<td><code>gg</code></td>
<td>跳转到第一行</td>
</tr>
<tr>
<td><code>G</code></td>
<td>跳转到最后一行</td>
</tr>
</tbody>
</table>
<h3 id="行内跳转">行内跳转</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>w</code></td>
<td>到下一个单词开头</td>
</tr>
<tr>
<td><code>e</code></td>
<td>到当前单词结尾</td>
</tr>
<tr>
<td><code>b</code></td>
<td>到前一个单词开头</td>
</tr>
<tr>
<td><code>ge</code></td>
<td>到前一个单词结尾</td>
</tr>
<tr>
<td><code>0</code> 或 <code>^</code></td>
<td>到行头</td>
</tr>
<tr>
<td><code>$</code></td>
<td>到行尾</td>
</tr>
<tr>
<td><code>f&lt;字母&gt;</code></td>
<td>向后搜索字母并跳转</td>
</tr>
<tr>
<td><code>F&lt;字母&gt;</code></td>
<td>向前搜索字母并跳转</td>
</tr>
<tr>
<td><code>t&lt;字母&gt;</code></td>
<td>向后搜索字母并跳转到匹配前</td>
</tr>
<tr>
<td><code>T&lt;字母&gt;</code></td>
<td>向前搜索字母并跳转到匹配后</td>
</tr>
</tbody>
</table>
<h2 id="5-复制粘贴和剪切">5. 复制粘贴和剪切</h2>
<h3 id="复制命令-yank">复制命令(yank)</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>yy</code></td>
<td>复制整行(3yy复制3行)</td>
</tr>
<tr>
<td><code>y^</code></td>
<td>复制至行首</td>
</tr>
<tr>
<td><code>y$</code></td>
<td>复制至行尾</td>
</tr>
<tr>
<td><code>yw</code></td>
<td>复制一个单词</td>
</tr>
<tr>
<td><code>yG</code></td>
<td>复制至文本末</td>
</tr>
<tr>
<td><code>y1G</code></td>
<td>复制至文本开头</td>
</tr>
</tbody>
</table>
<h3 id="粘贴命令">粘贴命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>p</code></td>
<td>粘贴至光标后</td>
</tr>
<tr>
<td><code>P</code></td>
<td>粘贴至光标前</td>
</tr>
</tbody>
</table>
<h2 id="6-替换和撤销">6. 替换和撤销</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>r+&lt;字母&gt;</code></td>
<td>替换游标所在字母</td>
</tr>
<tr>
<td><code>R</code></td>
<td>连续替换(按Esc结束)</td>
</tr>
<tr>
<td><code>cc</code></td>
<td>替换整行</td>
</tr>
<tr>
<td><code>cw</code></td>
<td>替换一个单词</td>
</tr>
<tr>
<td><code>C</code></td>
<td>替换至行末</td>
</tr>
<tr>
<td><code>~</code></td>
<td>反转字母大小写</td>
</tr>
<tr>
<td><code>u</code></td>
<td>撤销操作</td>
</tr>
<tr>
<td><code>U</code></td>
<td>撤销当前行所有修改</td>
</tr>
<tr>
<td><code>Ctrl+r</code></td>
<td>重做(redo)</td>
</tr>
</tbody>
</table>
<h2 id="7-缩进调整">7. 缩进调整</h2>
<h3 id="缩进命令">缩进命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&gt;&gt;</code></td>
<td>整行向右缩进</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>整行向左回退</td>
</tr>
<tr>
<td><code>:set shiftwidth=n</code></td>
<td>设置缩进字符数</td>
</tr>
</tbody>
</table>
<h3 id="文本位置调整">文本位置调整</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>:ce</code></td>
<td>本行内容居中</td>
</tr>
<tr>
<td><code>:ri</code></td>
<td>本行文本靠右</td>
</tr>
<tr>
<td><code>:le</code></td>
<td>本行内容靠左</td>
</tr>
</tbody>
</table>
<h2 id="8-查找功能">8. 查找功能</h2>
<h3 id="基本查找">基本查找</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/字符串</code></td>
<td>向下查找</td>
</tr>
<tr>
<td><code>?字符串</code></td>
<td>向上查找</td>
</tr>
<tr>
<td><code>n</code></td>
<td>继续查找</td>
</tr>
<tr>
<td><code>N</code></td>
<td>反向查找</td>
</tr>
</tbody>
</table>
<h3 id="高级查找">高级查找</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>向后查找当前单词</td>
</tr>
<tr>
<td><code>#</code></td>
<td>向前查找当前单词</td>
</tr>
<tr>
<td><code>g*</code></td>
<td>向后查找部分匹配单词</td>
</tr>
<tr>
<td><code>g#</code></td>
<td>向前查找部分匹配单词</td>
</tr>
</tbody>
</table>
<h2 id="9-多文件编辑">9. 多文件编辑</h2>
<h3 id="多文件操作">多文件操作</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>:n</code></td>
<td>编辑下一个文件</td>
</tr>
<tr>
<td><code>:N</code></td>
<td>编辑上一个文件</td>
</tr>
<tr>
<td><code>:e 文件名</code></td>
<td>打开新文件</td>
</tr>
<tr>
<td><code>:e#</code></td>
<td>回到前一个文件</td>
</tr>
<tr>
<td><code>:ls</code></td>
<td>列出编辑过的文档</td>
</tr>
<tr>
<td><code>:b 文件名/编号</code></td>
<td>切换到指定文件</td>
</tr>
<tr>
<td><code>:bd 文件名/编号</code></td>
<td>从列表删除文件</td>
</tr>
<tr>
<td><code>:f</code></td>
<td>显示当前文件名</td>
</tr>
</tbody>
</table>
<h3 id="文件恢复">文件恢复</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim -r 文件名</span><br><span class="line">:ewcover 文件名</span><br></pre></td></tr></table></figure>
<h2 id="10-可视模式">10. 可视模式</h2>
<h3 id="进入可视模式">进入可视模式</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>v</code></td>
<td>字符选择模式</td>
</tr>
<tr>
<td><code>V</code></td>
<td>行选择模式</td>
</tr>
<tr>
<td><code>Ctrl+v</code></td>
<td>区域选择模式</td>
</tr>
</tbody>
</table>
<h3 id="可视模式操作">可视模式操作</h3>
<ul>
<li><code>d</code> 删除选中区域</li>
<li><code>y</code> 复制选中区域</li>
</ul>
<h2 id="11-视窗操作">11. 视窗操作</h2>
<h3 id="窗口分割">窗口分割</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>:new</code></td>
<td>新建窗口</td>
</tr>
<tr>
<td><code>:sp 文件名</code></td>
<td>水平分割窗口</td>
</tr>
<tr>
<td><code>:vsp 文件名</code></td>
<td>垂直分割窗口</td>
</tr>
<tr>
<td><code>Ctrl+w s</code></td>
<td>水平分割当前窗口</td>
</tr>
<tr>
<td><code>Ctrl+w v</code></td>
<td>垂直分割当前窗口</td>
</tr>
</tbody>
</table>
<h3 id="窗口切换">窗口切换</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ctrl+w j/k/h/l</code></td>
<td>向下/上/左/右切换窗口</td>
</tr>
<tr>
<td><code>Ctrl+w q</code></td>
<td>关闭当前窗口</td>
</tr>
<tr>
<td><code>Ctrl+w o</code></td>
<td>只保留当前窗口</td>
</tr>
</tbody>
</table>
<h2 id="12-其他功能">12. 其他功能</h2>
<h3 id="文档加密">文档加密</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -x 文件名</span><br></pre></td></tr></table></figure>
<h3 id="执行外部命令">执行外部命令</h3>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:!命令</span><br><span class="line">:<span class="keyword">w</span> 文件名  # 另存为</span><br></pre></td></tr></table></figure>
<h3 id="帮助系统">帮助系统</h3>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:F1        # 打开帮助</span><br><span class="line">:h 主题    # 查看特定帮助</span><br><span class="line">:ver       # 显示版本</span><br></pre></td></tr></table></figure>
<h3 id="功能设定">功能设定</h3>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">set</span> <span class="keyword">nu</span>    # 显示行号</span><br><span class="line">:<span class="keyword">set</span> ai    # 自动缩进</span><br><span class="line">:<span class="keyword">set</span> aw    # 自动保存</span><br><span class="line">:<span class="keyword">set</span> cin   # C语言风格缩进</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：所有设置可通过修改 <code>~/.vimrc</code> 文件永久保存</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2021/03/12/vim%E6%95%99%E7%A8%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2021/02/15/GitHub-Actions-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"
                            aria-label=": GitHub Actions 入门教程"
                        >
                            GitHub Actions 入门教程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-02-15T15:09:17+08:00">
	
		    2021 年 2 月 15 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../categories/devops/">devops</a>, <a class="category-link" href="../../categories/devops/CI-CD/">CI/CD</a>, <a class="category-link" href="../../categories/devops/CI-CD/GitHubActions/">GitHubActions</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><a target="_blank" rel="noopener" href="https://github.com/features/actions">GitHub Actions</a> 是 GitHub 的<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2015/09/continuous-integration.html">持续集成服务</a>，于2018年10月<a target="_blank" rel="noopener" href="https://github.blog/changelog/2018-10-16-github-actions-limited-beta/">推出</a>。</p>
<p>这些天，我一直在试用，觉得它非常强大，有创意，比 <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html">Travis CI</a> 玩法更多。</p>
<p>本文是一个简单教程，演示如何使用 GitHub Actions 自动发布一个 React 应用到 <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html">GitHub Pages</a>。</p>
<p><img src="https://cdn.beekka.com/blogimg/asset/201909/bg2019091201.jpg" alt=""></p>
<h2 id="一、GitHub-Actions-是什么？">一、GitHub Actions 是什么？</h2>
<p>大家知道，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。</p>
<p>很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。</p>
<p>如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。</p>
<p>GitHub 做了一个<a target="_blank" rel="noopener" href="https://github.com/marketplace?type=actions">官方市场</a>，可以搜索到他人提交的 actions。另外，还有一个 <a target="_blank" rel="noopener" href="https://github.com/sdras/awesome-actions">awesome actions</a> 的仓库，也可以找到不少 action。</p>
<p><img src="https://cdn.beekka.com/blogimg/asset/201909/bg2019091105.jpg" alt=""></p>
<p>上面说了，每个 action 就是一个独立脚本，因此可以做成代码仓库，使用<code>userName/repoName</code>的语法引用 action。比如，<code>actions/setup-node</code>就表示<code>github.com/actions/setup-node</code>这个<a target="_blank" rel="noopener" href="https://github.com/actions/setup-node">仓库</a>，它代表一个 action，作用是安装 Node.js。事实上，GitHub 官方的 actions 都放在 <a target="_blank" rel="noopener" href="https://github.com/actions">github.com/actions</a> 里面。</p>
<p>既然 actions 是代码仓库，当然就有版本的概念，用户可以引用某个具体版本的 action。下面都是合法的 action 引用，用的就是 Git 的指针概念，详见<a target="_blank" rel="noopener" href="https://help.github.com/en/articles/about-actions#versioning-your-action">官方文档</a>。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">actions/setup-node@74bc508 <span class="comment"># 指向一个 commit</span></span><br><span class="line">actions/[email protected]    <span class="comment"># 指向一个标签</span></span><br><span class="line">actions/setup-node@master  <span class="comment"># 指向一个分支</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="二、基本概念">二、基本概念</h2>
<p>GitHub Actions 有一些自己的术语。</p>
<p>（1）<strong>workflow</strong> （工作流程）：持续集成一次运行的过程，就是一个 workflow。</p>
<p>（2）<strong>job</strong> （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。</p>
<p>（3）<strong>step</strong>（步骤）：每个 job 由多个 step 构成，一步步完成。</p>
<p>（4）<strong>action</strong> （动作）：每个 step 可以依次执行一个或多个命令（action）。</p>
<h2 id="三、workflow-文件">三、workflow 文件</h2>
<p>GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的<code>.github/workflows</code>目录。</p>
<p>workflow 文件采用 <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2016/07/yaml.html">YAML 格式</a>，文件名可以任意取，但是后缀名统一为<code>.yml</code>，比如<code>foo.yml</code>。一个库可以有多个 workflow 文件。GitHub 只要发现<code>.github/workflows</code>目录里面有<code>.yml</code>文件，就会自动运行该文件。</p>
<p>workflow 文件的配置字段非常多，详见<a target="_blank" rel="noopener" href="https://help.github.com/en/articles/workflow-syntax-for-github-actions">官方文档</a>。下面是一些基本字段。</p>
<p><strong>（1）<code>name</code></strong></p>
<p><code>name</code>字段是 workflow 的名称。如果省略该字段，默认为当前 workflow 的文件名。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">name: GitHub Actions Demo</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>（2）<code>on</code></strong></p>
<p><code>on</code>字段指定触发 workflow 的条件，通常是某些事件。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">on: push</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码指定，<code>push</code>事件触发 workflow。</p>
<p><code>on</code>字段也可以是事件的数组。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">on: [push, pull_request]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码指定，<code>push</code>事件或<code>pull_request</code>事件都可以触发 workflow。</p>
<p>完整的事件列表，请查看<a target="_blank" rel="noopener" href="https://help.github.com/en/articles/events-that-trigger-workflows">官方文档</a>。除了代码库事件，GitHub Actions 也支持外部事件触发，或者定时运行。</p>
<p><strong>（3）<code>on.&lt;push|pull_request&gt;.&lt;tags|branches&gt;</code></strong></p>
<p>指定触发事件时，可以限定分支或标签。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:    </span><br><span class="line">      - master</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码指定，只有<code>master</code>分支发生<code>push</code>事件时，才会触发 workflow。</p>
<p><strong>（4）<code>jobs.&lt;job_id&gt;.name</code></strong></p>
<p>workflow 文件的主体是<code>jobs</code>字段，表示要执行的一项或多项任务。</p>
<p><code>jobs</code>字段里面，需要写出每一项任务的<code>job_id</code>，具体名称自定义。<code>job_id</code>里面的<code>name</code>字段是任务的说明。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">jobs</span>:</span><br><span class="line">  <span class="attr">my_first_job</span>:</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">My</span> first job</span><br><span class="line">  <span class="attr">my_second_job</span>:</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">My</span> second job</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码的<code>jobs</code>字段包含两项任务，<code>job_id</code>分别是<code>my_first_job</code>和<code>my_second_job</code>。</p>
<p><strong>（5）<code>jobs.&lt;job_id&gt;.needs</code></strong></p>
<p><code>needs</code>字段指定当前任务的依赖关系，即运行顺序。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">jobs</span>:</span><br><span class="line">  <span class="attr">job1</span>:</span><br><span class="line">  <span class="attr">job2</span>:</span><br><span class="line">    <span class="attr">needs</span>: job1</span><br><span class="line">  <span class="attr">job3</span>:</span><br><span class="line">    <span class="attr">needs</span>: [job1, job2]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>job1</code>必须先于<code>job2</code>完成，而<code>job3</code>等待<code>job1</code>和<code>job2</code>的完成才能运行。因此，这个 workflow 的运行顺序依次为：<code>job1</code>、<code>job2</code>、<code>job3</code>。</p>
<p><strong>（6）<code>jobs.&lt;job_id&gt;.runs-on</code></strong></p>
<p><code>runs-on</code>字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下。</p>
<blockquote>
<ul>
<li><code>ubuntu-latest</code>，<code>ubuntu-18.04</code>或<code>ubuntu-16.04</code></li>
<li><code>windows-latest</code>，<code>windows-2019</code>或<code>windows-2016</code></li>
<li><code>macOS-latest</code>或<code>macOS-10.14</code></li>
</ul>
</blockquote>
<p>下面代码指定虚拟机环境为<code>ubuntu-18.04</code>。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">runs-<span class="attr">on</span>: ubuntu-<span class="number">18.04</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>（7）<code>jobs.&lt;job_id&gt;.steps</code></strong></p>
<p><code>steps</code>字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段。</p>
<blockquote>
<ul>
<li><code>jobs.&lt;job_id&gt;.steps.name</code>：步骤名称。</li>
<li><code>jobs.&lt;job_id&gt;.steps.run</code>：该步骤运行的命令或者 action。</li>
<li><code>jobs.&lt;job_id&gt;.steps.env</code>：该步骤所需的环境变量。</li>
</ul>
</blockquote>
<p>下面是一个完整的 workflow 文件的范例。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">name</span>: <span class="title class_">Greeting</span> <span class="keyword">from</span> <span class="title class_">Mona</span></span><br><span class="line"><span class="attr">on</span>: push</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs</span>:</span><br><span class="line">  my-<span class="attr">job</span>:</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">My</span> <span class="title class_">Job</span></span><br><span class="line">    runs-<span class="attr">on</span>: ubuntu-latest</span><br><span class="line">    <span class="attr">steps</span>:</span><br><span class="line">    - <span class="attr">name</span>: <span class="title class_">Print</span> a greeting</span><br><span class="line">      <span class="attr">env</span>:</span><br><span class="line">        <span class="attr">MY_VAR</span>: <span class="title class_">Hi</span> there! <span class="title class_">My</span> name is</span><br><span class="line">        <span class="attr">FIRST_NAME</span>: <span class="title class_">Mona</span></span><br><span class="line">        <span class="attr">MIDDLE_NAME</span>: <span class="title class_">The</span></span><br><span class="line">        <span class="attr">LAST_NAME</span>: <span class="title class_">Octocat</span></span><br><span class="line">      <span class="attr">run</span>: |</span><br><span class="line">        echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>steps</code>字段只包括一个步骤。该步骤先注入四个环境变量，然后执行一条 Bash 命令。</p>
<h2 id="四、实例：React-项目发布到-GitHub-Pages">四、实例：React 项目发布到 GitHub Pages</h2>
<p>下面是一个实例，通过 GitHub Actions 构建一个 React 项目，并发布到 GitHub Pages。最终代码都在<a target="_blank" rel="noopener" href="https://github.com/ruanyf/github-actions-demo">这个仓库</a>里面，发布后的参考网址为<a target="_blank" rel="noopener" href="https://ruanyf.github.io/github-actions-demo">ruanyf.github.io/github-actions-demo</a>。</p>
<p>第一步，GitHub Actions 目前还处在测试阶段，需要到<a target="_blank" rel="noopener" href="https://github.com/features/actions/signup/">这个网址</a>申请测试资格。申请以后，可能需要几天才能通过。据说，2019年11月就会放开。</p>
<p>获得资格后，仓库顶部的菜单会出现<code>Actions</code>一项。</p>
<p><img src="https://cdn.beekka.com/blogimg/asset/201909/bg2019091106.jpg" alt=""></p>
<p>第二步，这个示例需要将构建成果发到 GitHub 仓库，因此需要 GitHub 密钥。按照<a target="_blank" rel="noopener" href="https://help.github.com/en/articles/creating-a-personal-access-token-for-the-command-line">官方文档</a>，生成一个密钥。然后，将这个密钥储存到当前仓库的<code>Settings/Secrets</code>里面。</p>
<p><img src="https://cdn.beekka.com/blogimg/asset/201909/bg2019091107.jpg" alt=""></p>
<p>上图是储存秘密的环境变量的地方。环境变量的名字可以随便起，这里用的是<code>ACCESS_TOKEN</code>。如果你不用这个名字，后面脚本里的变量名也要跟着改。</p>
<p>第三步，本地计算机使用<a target="_blank" rel="noopener" href="https://github.com/facebook/create-react-app"><code>create-react-app</code></a>，生成一个标准的 React 应用。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ npx create-react-app github-actions-demo</span><br><span class="line">$ <span class="built_in">cd</span> github-actions-demo</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后，打开<code>package.json</code>文件，加一个<code>homepage</code>字段，表示该应用发布后的根目录（参见<a target="_blank" rel="noopener" href="https://create-react-app.dev/docs/deployment#building-for-relative-paths">官方文档</a>）。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;homepage&quot;</span>: <span class="string">&quot;https://[username].github.io/github-actions-demo&quot;</span>,</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，将<code>[username]</code>替换成你的 GitHub 用户名，参见<a target="_blank" rel="noopener" href="https://github.com/ruanyf/github-actions-demo/blob/master/package.json#L10">范例</a>。</p>
<p>第四步，在这个仓库的<code>.github/workflows</code>目录，生成一个 workflow 文件，名字可以随便取，这个示例是<code>ci.yml</code>。</p>
<p>我们选用一个别人已经写好的 action：<a target="_blank" rel="noopener" href="https://github.com/marketplace/actions/deploy-to-github-pages">JamesIves/github-pages-deploy-action</a>，它提供了 workflow 的范例文件，直接拷贝过来就行了（查看<a target="_blank" rel="noopener" href="https://github.com/ruanyf/github-actions-demo/blob/master/.github/workflows/ci.yml">源码</a>）。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">name</span>: <span class="title class_">GitHub</span> <span class="title class_">Actions</span> <span class="title class_">Build</span> and <span class="title class_">Deploy</span> <span class="title class_">Demo</span></span><br><span class="line"><span class="attr">on</span>:</span><br><span class="line">  <span class="attr">push</span>:</span><br><span class="line">    <span class="attr">branches</span>:</span><br><span class="line">      - master</span><br><span class="line"><span class="attr">jobs</span>:</span><br><span class="line">  build-and-<span class="attr">deploy</span>:</span><br><span class="line">    runs-<span class="attr">on</span>: ubuntu-latest</span><br><span class="line">    <span class="attr">steps</span>:</span><br><span class="line">    - <span class="attr">name</span>: <span class="title class_">Checkout</span></span><br><span class="line">      <span class="attr">uses</span>: actions/checkout@master</span><br><span class="line"></span><br><span class="line">    - <span class="attr">name</span>: <span class="title class_">Build</span> and <span class="title class_">Deploy</span></span><br><span class="line">      <span class="attr">uses</span>: <span class="title class_">JamesIves</span>/github-pages-deploy-action@master</span><br><span class="line">      <span class="attr">env</span>:</span><br><span class="line">        <span class="attr">ACCESS_TOKEN</span>: $&#123;&#123; secrets.<span class="property">ACCESS_TOKEN</span> &#125;&#125;</span><br><span class="line">        <span class="attr">BRANCH</span>: gh-pages</span><br><span class="line">        <span class="attr">FOLDER</span>: build</span><br><span class="line">        <span class="attr">BUILD_SCRIPT</span>: npm install &amp;&amp; npm run build</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面这个 workflow 文件的要点如下。</p>
<blockquote>
<ol>
<li>整个流程在<code>master</code>分支发生<code>push</code>事件时触发。</li>
<li>只有一个<code>job</code>，运行在虚拟机环境<code>ubuntu-latest</code>。</li>
<li>第一步是获取源码，使用的 action 是<code>actions/checkout</code>。</li>
<li>第二步是构建和部署，使用的 action 是<code>JamesIves/github-pages-deploy-action</code>。</li>
<li>第二步需要四个环境变量，分别为 GitHub 密钥、发布分支、构建成果所在目录、构建脚本。其中，只有 GitHub 密钥是秘密变量，需要写在双括号里面，其他三个都可以直接写在文件里。</li>
</ol>
</blockquote>
<p>第五步，保存上面的文件后，将整个仓库推送到 GitHub。</p>
<p>GitHub 发现了 workflow 文件以后，就会自动运行。你可以在网站上实时查看<a target="_blank" rel="noopener" href="https://github.com/ruanyf/github-actions-demo/commit/24fbf6a875351297f31434fd44bc3146accf9e59/checks">运行日志</a>，日志默认保存30天。</p>
<p><img src="https://cdn.beekka.com/blogimg/asset/201909/bg2019091108.jpg" alt=""></p>
<p>等到 workflow 运行结束，访问 <a target="_blank" rel="noopener" href="https://ruanyf.github.io/github-actions-demo/">GitHub Page</a>，会看到构建成果已经发上网了。</p>
<p><img src="https://cdn.beekka.com/blogimg/asset/201909/bg2019091109.jpg" alt=""></p>
<p>以后，每次修改后推送源码，GitHub Actions 都会自动运行，将构建产物发布到网页。</p>
<h2 id="五、参考链接">五、参考链接</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://help.github.com/en/categories/automating-your-workflow-with-github-actions">GitHub Pages 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://lukeboyle.com/blog-posts/2019/08/github-actions-for-web-apps/">Github Actions for web apps</a>, Luke Boyle</li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@adam.zolyak/my-first-week-with-github-actions-5d92de4c4851">My First Week With GitHub Actions</a>, Adam Zolyak</li>
</ul>
<p>（完）</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2021/02/15/GitHub-Actions-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="../7/"
                aria-label="上一頁"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>上一頁</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="../9/"
                aria-label="下一頁"
            >
              <span>下一頁</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">第 8 頁 共 24 頁</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 235 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
