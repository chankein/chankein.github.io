
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>JAVA-Spring开发-集成第三方组件 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg"},"articleBody":"Spring框架不仅提供了标准的IoC容器、AOP支持、数据库访问以及WebMVC等标准功能，还可以非常方便地集成许多常用的第三方组件：\n\n可以集成JavaMail发送邮件；\n可以集成JMS消息服务；\n可以集成Quartz实现定时任务；\n可以集成Redis等服务。\n\n本章我们介绍如何在Spring中简单快捷地集成这些第三方组件。\n我们在发送Email和接收Email中已经介绍了如何通过JavaMail来收发电子邮件。在Spring中，同样可以集成JavaMail。\n因为在服务器端，主要以发送邮件为主，例如在注册成功、登录时、购物付款后通知用户，基本上不会遇到接收用户邮件的情况，所以本节我们只讨论如何在Spring中发送邮件。\n在Spring中，发送邮件最终也是需要JavaMail，Spring只对JavaMail做了一点简单的封装，目的是简化代码。为了在Spring中集成JavaMail，我们在pom.xml中添加以下依赖：\n\norg.springframework:spring-context-support:6.0.0\njakarta.mail:jakarta.mail-api:2.0.1\ncom.sun.mail:jakarta.mail:2.0.1\n\n以及其他Web相关依赖。\n我们希望用户在注册成功后能收到注册邮件，为此，我们先定义一个JavaMailSender的Bean：\n12345678910111213141516171819202122232425262728@BeanJavaMailSender createJavaMailSender(        // smtp.properties:        @Value(&quot;$&#123;smtp.host&#125;&quot;) String host,        @Value(&quot;$&#123;smtp.port&#125;&quot;) int port,        @Value(&quot;$&#123;smtp.auth&#125;&quot;) String auth,        @Value(&quot;$&#123;smtp.username&#125;&quot;) String username,        @Value(&quot;$&#123;smtp.password&#125;&quot;) String password,        @Value(&quot;$&#123;smtp.debug:true&#125;&quot;) String debug)&#123;    var mailSender = new JavaMailSenderImpl();    mailSender.setHost(host);    mailSender.setPort(port);    mailSender.setUsername(username);    mailSender.setPassword(password);    Properties props = mailSender.getJavaMailProperties();    props.put(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;);    props.put(&quot;mail.smtp.auth&quot;, auth);    if (port == 587) &#123;        props.put(&quot;mail.smtp.starttls.enable&quot;, &quot;true&quot;);    &#125;    if (port == 465) &#123;        props.put(&quot;mail.smtp.socketFactory.port&quot;, &quot;465&quot;);        props.put(&quot;mail.smtp.socketFactory.class&quot;, &quot;javax.net.ssl.SSLSocketFactory&quot;);    &#125;    props.put(&quot;mail.debug&quot;, debug);    return mailSender;&#125;\n这个JavaMailSender接口的实现类是JavaMailSenderImpl，初始化时，传入的参数与JavaMail是完全一致的。\n另外注意到需要注入的属性是从smtp.properties中读取的，因此，AppConfig导入的就不止一个.properties文件，可以导入多个：\n12345678@Configuration@ComponentScan@EnableWebMvc@EnableTransactionManagement@PropertySource(&#123; &quot;classpath:/jdbc.properties&quot;, &quot;classpath:/smtp.properties&quot; &#125;)public class AppConfig &#123;    ...&#125;\n下一步是封装一个MailService，并定义sendRegistrationMail()方法：\n1234567891011121314151617181920212223@Componentpublic class MailService &#123;    @Value(&quot;$&#123;smtp.from&#125;&quot;)    String from;    @Autowired    JavaMailSender mailSender;    public void sendRegistrationMail(User user) &#123;        try &#123;            MimeMessage mimeMessage = mailSender.createMimeMessage();            MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, &quot;utf-8&quot;);            helper.setFrom(from);            helper.setTo(user.getEmail());            helper.setSubject(&quot;Welcome to Java course!&quot;);            String html = String.format(&quot;&lt;p&gt;Hi, %s,&lt;/p&gt;&lt;p&gt;Welcome to Java course!&lt;/p&gt;&lt;p&gt;Sent at %s&lt;/p&gt;&quot;, user.getName(), LocalDateTime.now());            helper.setText(html, true);            mailSender.send(mimeMessage);        &#125; catch (MessagingException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n观察上述代码，MimeMessage是JavaMail的邮件对象，而MimeMessageHelper是Spring提供的用于简化设置MimeMessage的类，比如我们设置HTML邮件就可以直接调用setText(String text, boolean html)方法，而不必再调用比较繁琐的JavaMail接口方法。\n最后一步是调用JavaMailSender.send()方法把邮件发送出去。\n在MVC的某个Controller方法中，当用户注册成功后，我们就启动一个新线程来异步发送邮件：\n123456User user = userService.register(email, password, name);logger.info(&quot;user registered: &#123;&#125;&quot;, user.getEmail());// send registration mail:new Thread(() -&gt; &#123;    mailService.sendRegistrationMail(user);&#125;).start();\n因为发送邮件是一种耗时的任务，从几秒到几分钟不等，因此，异步发送是保证页面能快速显示的必要措施。这里我们直接启动了一个新的线程，但实际上还有更优化的方法，我们在下一节讨论。\n练习\n使用Spring发送邮件。\n下载练习\n小结\nSpring可以集成JavaMail，通过简单的封装，能简化邮件发送代码。其核心是定义一个JavaMailSender的Bean，然后调用其send()方法。\nJMS即Java Message Service，是JavaEE的消息服务接口。JMS主要有两个版本：1.1和2.0。2.0和1.1相比，主要是简化了收发消息的代码。\n所谓消息服务，就是两个进程之间，通过消息服务器传递消息：\n123┌────────┐    ┌──────────────┐    ┌────────┐│Producer│───▶│Message Server│───▶│Consumer│└────────┘    └──────────────┘    └────────┘\n使用消息服务，而不是直接调用对方的API，它的好处是：\n\n双方各自无需知晓对方的存在，消息可以异步处理，因为消息服务器会在Consumer离线的时候自动缓存消息；\n如果Producer发送的消息频率高于Consumer的处理能力，消息可以积压在消息服务器，不至于压垮Consumer；\n通过一个消息服务器，可以连接多个Producer和多个Consumer。\n\n因为消息服务在各类应用程序中非常有用，所以JavaEE专门定义了JMS规范。注意到JMS是一组接口定义，如果我们要使用JMS，还需要选择一个具体的JMS产品。常用的JMS服务器有开源的ActiveMQ，商业服务器如WebLogic、WebSphere等也内置了JMS支持。这里我们选择开源的ActiveMQ作为JMS服务器，因此，在开发JMS之前我们必须首先安装ActiveMQ。\n现在问题来了：从官网下载ActiveMQ时，蹦出一个页面，让我们选择ActiveMQ Classic或者ActiveMQ Artemis，这两个是什么关系，又有什么区别？\n实际上ActiveMQ Classic原来就叫ActiveMQ，是Apache开发的基于JMS 1.1的消息服务器，目前稳定版本号是5.x，而ActiveMQ Artemis是由RedHat捐赠的HornetQ服务器代码的基础上开发的，目前稳定版本号是2.x。和ActiveMQ Classic相比，Artemis版的代码与Classic完全不同，并且，它支持JMS 2.0，使用基于Netty的异步IO，大大提升了性能。此外，Artemis不仅提供了JMS接口，它还提供了AMQP接口，STOMP接口和物联网使用的MQTT接口。选择Artemis，相当于一鱼四吃。\n所以，我们这里直接选择ActiveMQ Artemis。从官网下载最新的2.x版本，解压后设置环境变量ARTEMIS_HOME，指向Artemis根目录，例如C:\\Apps\\artemis，然后，把ARTEMIS_HOME/bin加入PATH环境变量：\n\nWindows下添加%ARTEMIS_HOME%\\bin到Path路径；\nMac和Linux下添加$ARTEMIS_HOME/bin到PATH路径。\n\nArtemis有个很好的设计，就是它把程序和数据完全分离了。我们解压后的ARTEMIS_HOME目录是程序目录，要启动一个Artemis服务，还需要创建一个数据目录。我们把数据目录直接设定在项目spring-integration-jms的jms-data目录下。执行命令artemis create jms-data：\n12345678910111213141516171819202122232425262728$ pwd/Users/liaoxuefeng/workspace/spring-integration-jms$ artemis create jms-dataCreating ActiveMQ Artemis instance at: /Users/liaoxuefeng/workspace/spring-integration-jms/jms-data--user: is a mandatory property!Please provide the default username:admin--password: is mandatory with this configuration:Please provide the default password:********--allow-anonymous | --require-login: is a mandatory property!Allow anonymous access?, valid values are Y,N,True,FalseNAuto tuning journal ...done! Your system can make 0.09 writes per millisecond, your journal-buffer-timeout will be 11392000You can now start the broker by executing:     &quot;/Users/liaoxuefeng/workspace/spring-integration-jms/jms-data/bin/artemis&quot; runOr you can run the broker in the background using:   &quot;/Users/liaoxuefeng/workspace/spring-integration-jms/jms-data/bin/artemis-service&quot; start\n在创建过程中，会要求输入连接用户和口令，这里我们设定admin和password，以及是否允许匿名访问（这里选择N）。\n此数据目录jms-data不仅包含消息数据、日志，还自动创建了两个启动服务的命令bin/artemis和bin/artemis-service，前者在前台启动运行，按Ctrl+C结束，后者会一直在后台运行。\n我们把目录切换到jms-data/bin，直接运行artemis run即可启动Artemis服务：\n12345678910111213$ ./artemis run     _        _               _    / \\  ____| |_  ___ __  __(_) _____   / _ \\|  _ \\ __|/ _ \\  \\/  | |/  __/  / ___ \\ | \\/ |_/  __/ |\\/| | |\\___ \\ /_/   \\_\\|   \\__\\____|_|  |_|_|/___ / Apache ActiveMQ Artemis 2.13.0...2020-06-02 07:50:21,718 INFO  [org.apache.activemq.artemis] AMQ241001: HTTP Server started at http://localhost:81612020-06-02 07:50:21,718 INFO  [org.apache.activemq.artemis] AMQ241002: Artemis Jolokia REST API available at http://localhost:8161/console/jolokia2020-06-02 07:50:21,719 INFO  [org.apache.activemq.artemis] AMQ241004: Artemis Console available at http://localhost:8161/console\n启动成功后，Artemis提示可以通过URLhttp://localhost:8161/console访问管理后台。注意不要关闭命令行窗口。\n注意\n如果Artemis启动时显示警告：AMQ222212: Disk Full! … Clients will report blocked.这是因为磁盘空间不够，可以在etc/broker.xml配置中找到并改为99。\n在编写JMS代码之前，我们首先得理解JMS的消息模型。JMS把生产消息的一方称为Producer，处理消息的一方称为Consumer。有两种类型的消息通道，一种是Queue：\n123┌────────┐    ┌────────┐    ┌────────┐│Producer│───▶│ Queue  │───▶│Consumer│└────────┘    └────────┘    └────────┘\n一种是Topic：\n123456789                            ┌────────┐                         ┌─▶│Consumer│                         │  └────────┘┌────────┐    ┌────────┐ │  ┌────────┐│Producer│───▶│ Topic  │─┼─▶│Consumer│└────────┘    └────────┘ │  └────────┘                         │  ┌────────┐                         └─▶│Consumer│                            └────────┘\n它们的区别在于，Queue是一种一对一的通道，如果Consumer离线无法处理消息时，Queue会把消息存起来，等Consumer再次连接的时候发给它。设定了持久化机制的Queue不会丢失消息。如果有多个Consumer接入同一个Queue，那么它们等效于以集群方式处理消息，例如，发送方发送的消息是A，B，C，D，E，F，两个Consumer可能分别收到A，C，E和B，D，F，即每个消息只会交给其中一个Consumer处理。\nTopic则是一种一对多通道。一个Producer发出的消息，会被多个Consumer同时收到，即每个Consumer都会收到一份完整的消息流。那么问题来了：如果某个Consumer暂时离线，过一段时间后又上线了，那么在它离线期间产生的消息还能不能收到呢？\n这取决于消息服务器对Topic类型消息的持久化机制。如果消息服务器不存储Topic消息，那么离线的Consumer会丢失部分离线时期的消息，如果消息服务器存储了Topic消息，那么离线的Consumer可以收到自上次离线时刻开始后产生的所有消息。JMS规范通过Consumer指定一个持久化订阅可以在上线后收取所有离线期间的消息，如果指定的是非持久化订阅，那么离线期间的消息会全部丢失。\n细心的童鞋可以看出来，如果一个Topic的消息全部都持久化了，并且只有一个Consumer，那么它和Queue其实是一样的。实际上，很多消息服务器内部都只有Topic类型的消息架构，Queue可以通过Topic“模拟”出来。\n无论是Queue还是Topic，对Producer没有什么要求。多个Producer也可以写入同一个Queue或者Topic，此时消息服务器内部会自动排序确保消息总是有序的。\n以上是消息服务的基本模型。具体到某个消息服务器时，Producer和Consumer通常是通过TCP连接消息服务器，在编写JMS程序时，又会遇到ConnectionFactory、Connection、Session等概念，其实这和JDBC连接是类似的：\n\nConnectionFactory：代表一个到消息服务器的连接池，类似JDBC的DataSource；\nConnection：代表一个到消息服务器的连接，类似JDBC的Connection；\nSession：代表一个经过认证后的连接会话；\nMessage：代表一个消息对象。\n\n在JMS 1.1中，发送消息的典型代码如下：\n12345678910111213141516171819202122try &#123;    Connection connection = null;    try &#123;        // 创建连接:        connection = connectionFactory.createConnection();        // 创建会话:        Session session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE);        // 创建一个Producer并关联到某个Queue:        MessageProducer messageProducer = session.createProducer(queue);        // 创建一个文本消息:        TextMessage textMessage = session.createTextMessage(text);        // 发送消息:        messageProducer.send(textMessage);    &#125; finally &#123;        // 关闭连接:        if (connection != null) &#123;            connection.close();        &#125;    &#125;&#125; catch (JMSException ex) &#123;    // 处理JMS异常&#125;\nJMS 2.0改进了一些API接口，发送消息变得更简单：\n123try (JMSContext context = connectionFactory.createContext()) &#123;    context.createProducer().send(queue, text);&#125;\nJMSContext实现了AutoCloseable接口，可以使用try(resource)语法，代码更简单。\n有了以上预备知识，我们就可以开始开发JMS应用了。\n首先，我们在pom.xml中添加如下依赖：\n\norg.springframework:spring-jms:6.0.0\norg.apache.activemq:artemis-jakarta-client:2.27.0\n\nArtemis的Client接口依赖了jakarta.jms:jakarta.jms-api，因此不必再引入JMS API的依赖。\n在AppConfig中，通过@EnableJms让Spring自动扫描JMS相关的Bean，并加载JMS配置文件jms.properties：\n123456789@Configuration@ComponentScan@EnableWebMvc@EnableJms // 启用JMS@EnableTransactionManagement@PropertySource(&#123; &quot;classpath:/jdbc.properties&quot;, &quot;classpath:/jms.properties&quot; &#125;)public class AppConfig &#123;    ...&#125;\n首先要创建的Bean是ConnectionFactory，即连接消息服务器的连接池：\n12345678@BeanConnectionFactory createJMSConnectionFactory(    @Value(&quot;$&#123;jms.uri:tcp://localhost:61616&#125;&quot;) String uri,    @Value(&quot;$&#123;jms.username:admin&#125;&quot;) String username,    @Value(&quot;$&#123;jms.password:password&#125;&quot;) String password)&#123;    return new ActiveMQJMSConnectionFactory(uri, username, password);&#125;\n因为我们使用的消息服务器是ActiveMQ Artemis，所以ConnectionFactory的实现类就是消息服务器提供的ActiveMQJMSConnectionFactory，它需要的参数均由配置文件读取后传入，并设置了默认值。\n我们再创建一个JmsTemplate，它是Spring提供的一个工具类，和JdbcTemplate类似，可以简化发送消息的代码：\n1234@BeanJmsTemplate createJmsTemplate(@Autowired ConnectionFactory connectionFactory) &#123;    return new JmsTemplate(connectionFactory);&#125;\n下一步要创建的是JmsListenerContainerFactory，\n123456@Bean(&quot;jmsListenerContainerFactory&quot;)DefaultJmsListenerContainerFactory createJmsListenerContainerFactory(@Autowired ConnectionFactory connectionFactory) &#123;    var factory = new DefaultJmsListenerContainerFactory();    factory.setConnectionFactory(connectionFactory);    return factory;&#125;\n除了必须指定Bean的名称为jmsListenerContainerFactory外，这个Bean的作用是处理和Consumer相关的Bean。我们先跳过它的原理，继续编写MessagingService来发送消息：\n1234567891011121314@Componentpublic class MessagingService &#123;    @Autowired ObjectMapper objectMapper;    @Autowired JmsTemplate jmsTemplate;    public void sendMailMessage(MailMessage msg) throws Exception &#123;        String text = objectMapper.writeValueAsString(msg);        jmsTemplate.send(&quot;jms/queue/mail&quot;, new MessageCreator() &#123;            public Message createMessage(Session session) throws JMSException &#123;                return session.createTextMessage(text);            &#125;        &#125;);    &#125;&#125;\nJMS的消息类型支持以下几种：\n\nTextMessage：文本消息；\nBytesMessage：二进制消息；\nMapMessage：包含多个Key-Value对的消息；\nObjectMessage：直接序列化Java对象的消息；\nStreamMessage：一个包含基本类型序列的消息。\n\n最常用的是发送基于JSON的文本消息，上述代码通过JmsTemplate创建一个TextMessage并发送到名称为jms/queue/mail的Queue。\n注意：Artemis消息服务器默认配置下会自动创建Queue，因此不必手动创建一个名为jms/queue/mail的Queue，但不是所有的消息服务器都会自动创建Queue，生产环境的消息服务器通常会关闭自动创建功能，需要手动创建Queue。\n再注意到MailMessage是我们自己定义的一个JavaBean，真正的JMS消息是创建的TextMessage，它的内容是JSON。\n当用户注册成功后，我们就调用MessagingService.sendMailMessage()发送一条JMS消息，此代码十分简单，这里不再贴出。\n下面我们要详细讨论的是如何处理消息，即编写Consumer。从理论上讲，可以创建另一个Java进程来处理消息，但对于我们这个简单的Web程序来说没有必要，直接在同一个Web应用中接收并处理消息即可。\n处理消息的核心代码是编写一个Bean，并在处理方法上标注@JmsListener：\n12345678910111213141516171819@Componentpublic class MailMessageListener &#123;    final Logger logger = LoggerFactory.getLogger(getClass());    @Autowired ObjectMapper objectMapper;    @Autowired MailService mailService;    @JmsListener(destination = &quot;jms/queue/mail&quot;, concurrency = &quot;10&quot;)    public void onMailMessageReceived(Message message) throws Exception &#123;        logger.info(&quot;received message: &quot; + message);        if (message instanceof TextMessage) &#123;            String text = ((TextMessage) message).getText();            MailMessage mm = objectMapper.readValue(text, MailMessage.class);            mailService.sendRegistrationMail(mm);        &#125; else &#123;            logger.error(&quot;unable to process non-text message!&quot;);        &#125;    &#125;&#125;\n注意到@JmsListener指定了Queue的名称，因此，凡是发到此Queue的消息都会被这个onMailMessageReceived()方法处理，方法参数是JMS的Message接口，我们通过强制转型为TextMessage并提取JSON，反序列化后获得自定义的JavaBean，也就获得了发送邮件所需的所有信息。\n下面问题来了：Spring处理JMS消息的流程是什么？\n如果我们直接调用JMS的API来处理消息，那么编写的代码大致如下：\n1234567891011121314// 创建JMS连接:Connection connection = connectionFactory.createConnection();// 创建会话:Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);// 创建一个Consumer:MessageConsumer consumer = session.createConsumer(queue);// 为Consumer指定一个消息处理器:consumer.setMessageListener(new MessageListener() &#123;     public void onMessage(Message message) &#123;        // 在此处理消息...     &#125;&#125;);// 启动接收消息的循环:connection.start();\n我们自己编写的MailMessageListener.onMailMessageReceived()相当于消息处理器：\n12345consumer.setMessageListener(new MessageListener() &#123;     public void onMessage(Message message) &#123;        mailMessageListener.onMailMessageReceived(message);     &#125;&#125;);\n所以，Spring根据AppConfig的注解@EnableJms自动扫描带有@JmsListener的Bean方法，并为其创建一个MessageListener把它包装起来。\n注意到前面我们还创建了一个JmsListenerContainerFactory的Bean，它的作用就是为每个MessageListener创建MessageConsumer并启动消息接收循环。\n再注意到@JmsListener还有一个concurrency参数，10表示可以最多同时并发处理10个消息，5-10表示并发处理的线程可以在5~10之间调整。\n因此，Spring在通过MessageListener接收到消息后，并不是直接调用mailMessageListener.onMailMessageReceived()，而是用线程池调用，因此，要时刻牢记，onMailMessageReceived()方法可能被多线程并发执行，一定要保证线程安全。\n我们总结一下Spring接收消息的步骤：\n通过JmsListenerContainerFactory配合@EnableJms扫描所有@JmsListener方法，自动创建MessageConsumer、MessageListener以及线程池，启动消息循环接收处理消息，最终由我们自己编写的@JmsListener方法处理消息，可能会由多线程同时并发处理。\n要验证消息发送和处理，我们注册一个新用户，可以看到如下日志输出：\n12342020-06-02 08:04:27 INFO  c.i.learnjava.web.UserController - user registered: bob@example.com2020-06-02 08:04:27 INFO  c.i.l.service.MailMessageListener - received message: ActiveMQMessage[ID:9fc5...]:PERSISTENT/ClientMessageImpl[messageID=983, durable=true, address=jms/queue/mail, ...]]2020-06-02 08:04:27 INFO  c.i.learnjava.service.MailService - [send mail] sending registration mail to bob@example.com...2020-06-02 08:04:30 INFO  c.i.learnjava.service.MailService - [send mail] registration mail was sent to bob@example.com.\n可见，消息被成功发送到Artemis，然后在很短的时间内被接收处理了。\n使用消息服务对发送Email进行改造的好处是，发送Email的能力通常是有限的，通过JMS消息服务，如果短时间内需要给大量用户发送Email，可以先把消息堆积在JMS服务器上慢慢发送，对于批量发送邮件、短信等尤其有用。\n练习\n使用JMS。\n下载练习\n小结\nJMS是Java消息服务，可以通过JMS服务器实现消息的异步处理。\n消息服务主要解决Producer和Consumer生产和处理速度不匹配的问题。\n在很多应用程序中，经常需要执行定时任务。例如，每天或每月给用户发送账户汇总报表，定期检查并发送系统状态报告，等等。\n定时任务我们在使用线程池一节中已经讲到了，Java标准库本身就提供了定时执行任务的功能。在Spring中，使用定时任务更简单，不需要手写线程池相关代码，只需要两个注解即可。\n我们还是以实际代码为例，建立工程spring-integration-schedule，无需额外的依赖，我们可以直接在AppConfig中加上@EnableScheduling就开启了定时任务的支持：\n123456789@Configuration@ComponentScan@EnableWebMvc@EnableScheduling@EnableTransactionManagement@PropertySource(&#123; &quot;classpath:/jdbc.properties&quot;, &quot;classpath:/task.properties&quot; &#125;)public class AppConfig &#123;    ...&#125;\n接下来，我们可以直接在一个Bean中编写一个public void无参数方法，然后加上@Scheduled注解：\n123456789@Componentpublic class TaskService &#123;    final Logger logger = LoggerFactory.getLogger(getClass());    @Scheduled(initialDelay = 60_000, fixedRate = 60_000)    public void checkSystemStatusEveryMinute() &#123;        logger.info(&quot;Start check system status...&quot;);    &#125;&#125;\n上述注解指定了启动延迟60秒，并以60秒的间隔执行任务。现在，我们直接运行应用程序，就可以在控制台看到定时任务打印的日志：\n1232020-06-03 18:47:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start check system status...2020-06-03 18:48:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start check system status...2020-06-03 18:49:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start check system status...\n如果没有看到定时任务的日志，需要检查：\n\n是否忘记了在AppConfig中标注@EnableScheduling；\n是否忘记了在定时任务的方法所在的class标注@Component。\n\n除了可以使用fixedRate外，还可以使用fixedDelay，两者的区别我们已经在使用线程池一节中讲过，这里不再重复。\n有的童鞋在实际开发中会遇到一个问题，因为Java的注解全部是常量，写死了fixedDelay=30000，如果根据实际情况要改成60秒怎么办，只能重新编译？\n我们可以把定时任务的配置放到配置文件中，例如task.properties：\n1task.checkDiskSpace=30000\n这样就可以随时修改配置文件而无需动代码。但是在代码中，我们需要用fixedDelayString取代fixedDelay：\n123456789@Componentpublic class TaskService &#123;    ...    @Scheduled(initialDelay = 30_000, fixedDelayString = &quot;$&#123;task.checkDiskSpace:30000&#125;&quot;)    public void checkDiskSpaceEveryMinute() &#123;        logger.info(&quot;Start check disk space...&quot;);    &#125;&#125;\n注意到上述代码的注解参数fixedDelayString是一个属性占位符，并配有默认值30000，Spring在处理@Scheduled注解时，如果遇到String，会根据占位符自动用配置项替换，这样就可以灵活地修改定时任务的配置。\n此外，fixedDelayString还可以使用更易读的Duration，例如：\n1@Scheduled(initialDelay = 30_000, fixedDelayString = &quot;$&#123;task.checkDiskSpace:PT2M30S&#125;&quot;)\n以字符串PT2M30S表示的Duration就是2分30秒，请参考LocalDateTime一节的Duration相关部分。\n多个@Scheduled方法完全可以放到一个Bean中，这样便于统一管理各类定时任务。\n使用Cron任务\n还有一类定时任务，它不是简单的重复执行，而是按时间触发，我们把这类任务称为Cron任务，例如：\n\n每天凌晨2:15执行报表任务；\n每个工作日12:00执行特定任务；\n……\n\nCron源自Unix/Linux系统自带的crond守护进程，以一个简洁的表达式定义任务触发时间。在Spring中，也可以使用Cron表达式来执行Cron任务，在Spring中，它的格式是：\n1秒 分 小时 天 月份 星期 年\n年是可以忽略的，通常不写。每天凌晨2:15执行的Cron表达式就是：\n10 15 2 * * *\n每个工作日12:00执行的Cron表达式就是：\n10 0 12 * * MON-FRI\n每个月1号，2号，3号和10号12:00执行的Cron表达式就是：\n10 0 12 1-3,10 * *\n在Spring中，我们定义一个每天凌晨2:15执行的任务：\n123456789@Componentpublic class TaskService &#123;    ...    @Scheduled(cron = &quot;$&#123;task.report:0 15 2 * * *&#125;&quot;)    public void cronDailyReport() &#123;        logger.info(&quot;Start daily report task...&quot;);    &#125;&#125;\nCron任务同样可以使用属性占位符，这样修改起来更加方便。\nCron表达式还可以表达每10分钟执行，例如：\n10 */10 * * * *\n这样，在每个小时的0:00，10:00，20:00，30:00，40:00，50:00均会执行任务，实际上它可以取代fixedRate类型的定时任务。\n集成Quartz\n在Spring中使用定时任务和Cron任务都十分简单，但是要注意到，这些任务的调度都是在每个JVM进程中的。如果在本机启动两个进程，或者在多台机器上启动应用，这些进程的定时任务和Cron任务都是独立运行的，互不影响。\n如果一些定时任务要以集群的方式运行，例如每天23:00执行检查任务，只需要集群中的一台运行即可，这个时候，可以考虑使用Quartz。\nQuartz可以配置一个JDBC数据源，以便存储所有的任务调度计划以及任务执行状态。也可以使用内存来调度任务，但这样配置就和使用Spring的调度没啥区别了，额外集成Quartz的意义就不大。\nQuartz的JDBC配置比较复杂，Spring对其也有一定的支持。要详细了解Quartz的集成，请参考Spring的文档。\n思考：如果不使用Quartz的JDBC配置，多个Spring应用同时运行时，如何保证某个任务只在某一台机器执行？\n练习\n使用Scheduler执行定时任务。\n下载练习\n小结\nSpring内置定时任务和Cron任务的支持，编写调度任务十分方便。\n在Spring中，可以方便地集成JMX。\n那么第一个问题来了：什么是JMX？\nJMX是Java Management Extensions，它是一个Java平台的管理和监控接口。为什么要搞JMX呢？因为在所有的应用程序中，对运行中的程序进行监控都是非常重要的，Java应用程序也不例外。我们肯定希望知道Java应用程序当前的状态，例如，占用了多少内存，分配了多少内存，当前有多少活动线程，有多少休眠线程等等。如何获取这些信息呢？\n为了标准化管理和监控，Java平台使用JMX作为管理和监控的标准接口，任何程序，只要按JMX规范访问这个接口，就可以获取所有管理与监控信息。\n实际上，常用的运维监控如Zabbix、Nagios等工具对JVM本身的监控都是通过JMX获取的信息。\n因为JMX是一个标准接口，不但可以用于管理JVM，还可以管理应用程序自身。下图是JMX的架构：\n1234567891011121314    ┌─────────┐  ┌─────────┐    │jconsole │  │   Web   │    └─────────┘  └─────────┘         │            │┌ ─ ─ ─ ─│─ ─ ─ ─ ─ ─ ┼ ─ ─ ─ ─ JVM     ▼            ▼        ││   ┌─────────┐  ┌─────────┐  ┌─┤Connector├──┤ Adaptor ├─┐ ││ │ └─────────┘  └─────────┘ │  │       MBeanServer        │ ││ │ ┌──────┐┌──────┐┌──────┐ │  └─┤MBean1├┤MBean2├┤MBean3├─┘ ││   └──────┘└──────┘└──────┘ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘\nJMX把所有被管理的资源都称为MBean（Managed Bean），这些MBean全部由MBeanServer管理，如果要访问MBean，可以通过MBeanServer对外提供的访问接口，例如通过RMI或HTTP访问。\n注意到使用JMX不需要安装任何额外组件，也不需要第三方库，因为MBeanServer已经内置在JavaSE标准库中了。JavaSE还提供了一个jconsole程序，用于通过RMI连接到MBeanServer，这样就可以管理整个Java进程。\n除了JVM会把自身的各种资源以MBean注册到JMX中，我们自己的配置、监控信息也可以作为MBean注册到JMX，这样，管理程序就可以直接控制我们暴露的MBean。因此，应用程序使用JMX，只需要两步：\n\n编写MBean提供管理接口和监控数据；\n注册MBean。\n\n在Spring应用程序中，使用JMX只需要一步：\n\n编写MBean提供管理接口和监控数据。\n\n第二步注册的过程由Spring自动完成。我们以实际工程为例，首先在AppConfig中加上@EnableMBeanExport注解，告诉Spring自动注册MBean：\n123456789@Configuration@ComponentScan@EnableWebMvc@EnableMBeanExport // 自动注册MBean@EnableTransactionManagement@PropertySource(&#123; &quot;classpath:/jdbc.properties&quot; &#125;)public class AppConfig &#123;    ...&#125;\n剩下的全部工作就是编写MBean。我们以实际问题为例，假设我们希望给应用程序添加一个IP黑名单功能，凡是在黑名单中的IP禁止访问，传统的做法是定义一个配置文件，启动的时候读取：\n12345# blacklist.txt1.2.3.45.6.7.82.2.3.4...\n如果要修改黑名单怎么办？修改配置文件，然后重启应用程序。\n但是每次都重启应用程序实在是太麻烦了，能不能不重启应用程序？可以自己写一个定时读取配置文件的功能，检测到文件改动时自动重新读取。\n上述需求本质上是在应用程序运行期间对参数、配置等进行热更新并要求尽快生效。如果以JMX的方式实现，我们不必自己编写自动重新读取等任何代码，只需要提供一个符合JMX标准的MBean来存储配置即可。\n还是以IP黑名单为例，JMX的MBean通常以MBean结尾，因此我们遵循标准命名规范，首先编写一个BlacklistMBean：\n12345678910111213141516171819public class BlacklistMBean &#123;    private Set&lt;String&gt; ips = new HashSet&lt;&gt;();    public String[] getBlacklist() &#123;        return ips.toArray(String[]::new);    &#125;    public void addBlacklist(String ip) &#123;        ips.add(ip);    &#125;    public void removeBlacklist(String ip) &#123;        ips.remove(ip);    &#125;    public boolean shouldBlock(String ip) &#123;        return ips.contains(ip);    &#125;&#125;\n这个MBean没什么特殊的，它的逻辑和普通Java类没有任何区别。\n下一步，我们要使用JMX的客户端来实时热更新这个MBean，所以要给它加上一些注解，让Spring能根据注解自动把相关方法注册到MBeanServer中：\n1234567891011121314151617181920212223242526@Component@ManagedResource(objectName = &quot;sample:name=blacklist&quot;, description = &quot;Blacklist of IP addresses&quot;)public class BlacklistMBean &#123;    private Set&lt;String&gt; ips = new HashSet&lt;&gt;();    @ManagedAttribute(description = &quot;Get IP addresses in blacklist&quot;)    public String[] getBlacklist() &#123;        return ips.toArray(String[]::new);    &#125;    @ManagedOperation    @ManagedOperationParameter(name = &quot;ip&quot;, description = &quot;Target IP address that will be added to blacklist&quot;)    public void addBlacklist(String ip) &#123;        ips.add(ip);    &#125;    @ManagedOperation    @ManagedOperationParameter(name = &quot;ip&quot;, description = &quot;Target IP address that will be removed from blacklist&quot;)    public void removeBlacklist(String ip) &#123;        ips.remove(ip);    &#125;    public boolean shouldBlock(String ip) &#123;        return ips.contains(ip);    &#125;&#125;\n观察上述代码，BlacklistMBean首先是一个标准的Spring管理的Bean，其次，添加了@ManagedResource表示这是一个MBean，将要被注册到JMX。objectName指定了这个MBean的名字，通常以company:name=Xxx来分类MBean。\n对于属性，使用@ManagedAttribute注解标注。上述MBean只有get属性，没有set属性，说明这是一个只读属性。\n对于操作，使用@ManagedOperation注解标准。上述MBean定义了两个操作：addBlacklist()和removeBlacklist()，其他方法如shouldBlock()不会被暴露给JMX。\n使用MBean和普通Bean是完全一样的。例如，我们在BlacklistInterceptor对IP进行黑名单拦截：\n1234567891011121314151617181920212223@Order(1)@Componentpublic class BlacklistInterceptor implements HandlerInterceptor &#123;    final Logger logger = LoggerFactory.getLogger(getClass());    @Autowired    BlacklistMBean blacklistMBean;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)            throws Exception &#123;        String ip = request.getRemoteAddr();        logger.info(&quot;check ip address &#123;&#125;...&quot;, ip);        // 是否在黑名单中:        if (blacklistMBean.shouldBlock(ip)) &#123;            logger.warn(&quot;will block ip &#123;&#125; for it is in blacklist.&quot;, ip);            // 发送403错误响应:            response.sendError(403);            return false;        &#125;        return true;    &#125;&#125;\n下一步就是正常启动Web应用程序，不要关闭它，我们打开另一个命令行窗口，输入jconsole启动JavaSE自带的一个JMX客户端程序：\n\n通过jconsole连接到一个Java进程最简单的方法是直接在Local Process中找到正在运行的AppConfig，点击Connect即可连接到我们当前正在运行的Web应用，在jconsole中可直接看到内存、CPU等资源的监控。\n我们点击MBean，左侧按分类列出所有MBean，可以在java.lang查看内存等信息：\n\n细心的童鞋可以看到HikariCP连接池也是通过JMX监控的。\n在sample中可以看到我们自己的MBean，点击可查看属性blacklist：\n\n点击Operations-addBlacklist，可以填入127.0.0.1并点击addBlacklist按钮，相当于jconsole通过JMX接口，调用了我们自己的BlacklistMBean的addBlacklist()方法，传入的参数就是填入的127.0.0.1：\n\n再次查看属性blacklist，可以看到结果已经更新了：\n\n我们可以在浏览器中测试一下黑名单功能是否已生效：\n\n可见，127.0.0.1确实被添加到了黑名单，后台日志打印如下：\n122020-06-06 20:22:12 INFO  c.i.l.web.BlacklistInterceptor - check ip address 127.0.0.1...2020-06-06 20:22:12 WARN  c.i.l.web.BlacklistInterceptor - will block ip 127.0.0.1 for it is in blacklist.\n注意：如果使用IPv6，那么需要把0:0:0:0:0:0:0:1这个本机地址加到黑名单。\n如果从jconsole中调用removeBlacklist移除127.0.0.1，刷新浏览器可以看到又允许访问了。\n使用jconsole直接通过Local Process连接JVM有个限制，就是jconsole和正在运行的JVM必须在同一台机器。如果要远程连接，首先要打开JMX端口。我们在启动AppConfig时，需要传入以下JVM启动参数：\n\n-Dcom.sun.management.jmxremote.port=19999\n-Dcom.sun.management.jmxremote.authenticate=false\n-Dcom.sun.management.jmxremote.ssl=false\n\n第一个参数表示在19999端口监听JMX连接，第二个和第三个参数表示无需验证，不使用SSL连接，在开发测试阶段比较方便，生产环境必须指定验证方式并启用SSL。详细参数可参考Oracle官方文档。这样jconsole可以用ip:19999的远程方式连接JMX。连接后的操作是完全一样的。\n许多JavaEE服务器如JBoss的管理后台都是通过JMX提供管理接口，并由Web方式访问，对用户更加友好。\n在实际项目中，通过JMX实现配置的实时更新其实并不常用，JMX更多地用于收集JVM的运行状态和应用程序的性能数据，然后通过监控服务器汇总数据后实现监控与报警。一个典型的监控系统架构如下：\n1234567891011121314┌───────────────┐   ┌───────────────┐│  Web Console  │◀──│Metrics Server │└───────────────┘   └───────────────┘                            │                            │   ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─│─ ─ ┐     ┌───────────────┐      │   │ │      App      │      │    │     ├─────────┬─────┤   ┌─────┐   │ │         │ JMX │──▶│Agent│ │     │         └─────┤   └─────┘   │ │      JVM      │           │     └───────────────┘   └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘\n其中，App自身和JVM的的统计数据都通过JMX收集并发送给本机的一个Agent，Agent再将数据发送至监控服务器，最后以可视化的形式将监控数据通过Web等形式展示给用户。常用的监控系统有开源的Prometheus和以云服务方式提供的DataDog等。\n练习\n编写一个MBean统计当前注册用户数量，并在jconsole中查看：\n下载练习\n小结\n在Spring中使用JMX需要：\n\n通过@EnableMBeanExport启用自动注册MBean；\n编写MBean并实现管理属性和管理操作。\n\n","dateCreated":"2018-02-26T16:41:16+08:00","dateModified":"2025-06-17T18:13:02+08:00","datePublished":"2018-02-26T16:41:16+08:00","description":"","headline":"JAVA-Spring开发-集成第三方组件","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://chankein.github.io/2018/02/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/"},"publisher":{"@type":"Organization","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg","logo":{"@type":"ImageObject","url":"profile.jpg"}},"url":"https://chankein.github.io/2018/02/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/","keywords":"Java, Spirng"}</script>
    <meta name="description" content="Spring框架不仅提供了标准的IoC容器、AOP支持、数据库访问以及WebMVC等标准功能，还可以非常方便地集成许多常用的第三方组件：  可以集成JavaMail发送邮件； 可以集成JMS消息服务； 可以集成Quartz实现定时任务； 可以集成Redis等服务。  本章我们介绍如何在Spring中简单快捷地集成这些第三方组件。 我们在发送Email和接收Email中已经介绍了如何通过JavaMa">
<meta property="og:type" content="blog">
<meta property="og:title" content="JAVA-Spring开发-集成第三方组件">
<meta property="og:url" content="https://chankein.github.io/2018/02/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:description" content="Spring框架不仅提供了标准的IoC容器、AOP支持、数据库访问以及WebMVC等标准功能，还可以非常方便地集成许多常用的第三方组件：  可以集成JavaMail发送邮件； 可以集成JMS消息服务； 可以集成Quartz实现定时任务； 可以集成Redis等服务。  本章我们介绍如何在Spring中简单快捷地集成这些第三方组件。 我们在发送Email和接收Email中已经介绍了如何通过JavaMa">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/spring/integration/jmx/jconsole.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/spring/integration/jmx/mbeans.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/spring/integration/jmx/my-mbean.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/spring/integration/jmx/mbean-edit.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/spring/integration/jmx/mbean-attr.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/spring/integration/jmx/mbean-enabled.png">
<meta property="article:published_time" content="2018-02-26T08:41:16.000Z">
<meta property="article:modified_time" content="2025-06-17T10:13:02.318Z">
<meta property="article:author" content="Kein Chan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spirng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liaoxuefeng.com/books/java/spring/integration/jmx/jconsole.png">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../../../#about"
            >
        
        
            <img class="header-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            JAVA-Spring开发-集成第三方组件
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-02-26T16:41:16+08:00">
	
		    2018 年 2 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/">Java</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>Spring框架不仅提供了标准的IoC容器、AOP支持、数据库访问以及WebMVC等标准功能，还可以非常方便地集成许多常用的第三方组件：</p>
<ul>
<li>可以集成JavaMail发送邮件；</li>
<li>可以集成JMS消息服务；</li>
<li>可以集成Quartz实现定时任务；</li>
<li>可以集成Redis等服务。</li>
</ul>
<p>本章我们介绍如何在Spring中简单快捷地集成这些第三方组件。</p>
<p>我们在<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/network/send-email/index.html">发送Email</a>和<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/network/receive-email/index.html">接收Email</a>中已经介绍了如何通过JavaMail来收发电子邮件。在Spring中，同样可以集成JavaMail。</p>
<p>因为在服务器端，主要以发送邮件为主，例如在注册成功、登录时、购物付款后通知用户，基本上不会遇到接收用户邮件的情况，所以本节我们只讨论如何在Spring中发送邮件。</p>
<p>在Spring中，发送邮件最终也是需要JavaMail，Spring只对JavaMail做了一点简单的封装，目的是简化代码。为了在Spring中集成JavaMail，我们在<code>pom.xml</code>中添加以下依赖：</p>
<ul>
<li>org.springframework:spring-context-support:6.0.0</li>
<li>jakarta.mail:jakarta.mail-api:2.0.1</li>
<li>com.sun.mail:jakarta.mail:2.0.1</li>
</ul>
<p>以及其他Web相关依赖。</p>
<p>我们希望用户在注册成功后能收到注册邮件，为此，我们先定义一个<code>JavaMailSender</code>的Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">JavaMailSender <span class="title function_">createJavaMailSender</span><span class="params">(</span></span><br><span class="line"><span class="params">        // smtp.properties:</span></span><br><span class="line"><span class="params">        <span class="meta">@Value(&quot;$&#123;smtp.host&#125;&quot;)</span> String host,</span></span><br><span class="line"><span class="params">        <span class="meta">@Value(&quot;$&#123;smtp.port&#125;&quot;)</span> <span class="type">int</span> port,</span></span><br><span class="line"><span class="params">        <span class="meta">@Value(&quot;$&#123;smtp.auth&#125;&quot;)</span> String auth,</span></span><br><span class="line"><span class="params">        <span class="meta">@Value(&quot;$&#123;smtp.username&#125;&quot;)</span> String username,</span></span><br><span class="line"><span class="params">        <span class="meta">@Value(&quot;$&#123;smtp.password&#125;&quot;)</span> String password,</span></span><br><span class="line"><span class="params">        <span class="meta">@Value(&quot;$&#123;smtp.debug:true&#125;&quot;)</span> String debug)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">mailSender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaMailSenderImpl</span>();</span><br><span class="line">    mailSender.setHost(host);</span><br><span class="line">    mailSender.setPort(port);</span><br><span class="line">    mailSender.setUsername(username);</span><br><span class="line">    mailSender.setPassword(password);</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> mailSender.getJavaMailProperties();</span><br><span class="line">    props.put(<span class="string">&quot;mail.transport.protocol&quot;</span>, <span class="string">&quot;smtp&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;mail.smtp.auth&quot;</span>, auth);</span><br><span class="line">    <span class="keyword">if</span> (port == <span class="number">587</span>) &#123;</span><br><span class="line">        props.put(<span class="string">&quot;mail.smtp.starttls.enable&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (port == <span class="number">465</span>) &#123;</span><br><span class="line">        props.put(<span class="string">&quot;mail.smtp.socketFactory.port&quot;</span>, <span class="string">&quot;465&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;mail.smtp.socketFactory.class&quot;</span>, <span class="string">&quot;javax.net.ssl.SSLSocketFactory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    props.put(<span class="string">&quot;mail.debug&quot;</span>, debug);</span><br><span class="line">    <span class="keyword">return</span> mailSender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>JavaMailSender</code>接口的实现类是<code>JavaMailSenderImpl</code>，初始化时，传入的参数与JavaMail是完全一致的。</p>
<p>另外注意到需要注入的属性是从<code>smtp.properties</code>中读取的，因此，<code>AppConfig</code>导入的就不止一个<code>.properties</code>文件，可以导入多个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@PropertySource(&#123; &quot;classpath:/jdbc.properties&quot;, &quot;classpath:/smtp.properties&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步是封装一个<code>MailService</code>，并定义<code>sendRegistrationMail()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;smtp.from&#125;&quot;)</span></span><br><span class="line">    String from;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JavaMailSender mailSender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendRegistrationMail</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MimeMessage</span> <span class="variable">mimeMessage</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line">            <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(mimeMessage, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            helper.setFrom(from);</span><br><span class="line">            helper.setTo(user.getEmail());</span><br><span class="line">            helper.setSubject(<span class="string">&quot;Welcome to Java course!&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> String.format(<span class="string">&quot;&lt;p&gt;Hi, %s,&lt;/p&gt;&lt;p&gt;Welcome to Java course!&lt;/p&gt;&lt;p&gt;Sent at %s&lt;/p&gt;&quot;</span>, user.getName(), LocalDateTime.now());</span><br><span class="line">            helper.setText(html, <span class="literal">true</span>);</span><br><span class="line">            mailSender.send(mimeMessage);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察上述代码，<code>MimeMessage</code>是JavaMail的邮件对象，而<code>MimeMessageHelper</code>是Spring提供的用于简化设置MimeMessage的类，比如我们设置HTML邮件就可以直接调用<code>setText(String text, boolean html)</code>方法，而不必再调用比较繁琐的JavaMail接口方法。</p>
<p>最后一步是调用<code>JavaMailSender.send()</code>方法把邮件发送出去。</p>
<p>在MVC的某个Controller方法中，当用户注册成功后，我们就启动一个新线程来异步发送邮件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.register(email, password, name);</span><br><span class="line">logger.info(<span class="string">&quot;user registered: &#123;&#125;&quot;</span>, user.getEmail());</span><br><span class="line"><span class="comment">// send registration mail:</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    mailService.sendRegistrationMail(user);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>因为发送邮件是一种耗时的任务，从几秒到几分钟不等，因此，异步发送是保证页面能快速显示的必要措施。这里我们直接启动了一个新的线程，但实际上还有更优化的方法，我们在下一节讨论。</p>
<h3 id="练习">练习</h3>
<p>使用Spring发送邮件。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/integration/javamail/spring-integration-mail.zip">下载练习</a></p>
<h3 id="小结">小结</h3>
<p>Spring可以集成JavaMail，通过简单的封装，能简化邮件发送代码。其核心是定义一个<code>JavaMailSender</code>的Bean，然后调用其<code>send()</code>方法。</p>
<p>JMS即Java Message Service，是JavaEE的消息服务接口。JMS主要有两个版本：1.1和2.0。2.0和1.1相比，主要是简化了收发消息的代码。</p>
<p>所谓消息服务，就是两个进程之间，通过消息服务器传递消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌────────┐    ┌──────────────┐    ┌────────┐</span><br><span class="line">│Producer│───▶│Message Server│───▶│Consumer│</span><br><span class="line">└────────┘    └──────────────┘    └────────┘</span><br></pre></td></tr></table></figure>
<p>使用消息服务，而不是直接调用对方的API，它的好处是：</p>
<ul>
<li>双方各自无需知晓对方的存在，消息可以异步处理，因为消息服务器会在Consumer离线的时候自动缓存消息；</li>
<li>如果Producer发送的消息频率高于Consumer的处理能力，消息可以积压在消息服务器，不至于压垮Consumer；</li>
<li>通过一个消息服务器，可以连接多个Producer和多个Consumer。</li>
</ul>
<p>因为消息服务在各类应用程序中非常有用，所以JavaEE专门定义了JMS规范。注意到JMS是一组接口定义，如果我们要使用JMS，还需要选择一个具体的JMS产品。常用的JMS服务器有开源的<a target="_blank" rel="noopener" href="https://activemq.apache.org/">ActiveMQ</a>，商业服务器如WebLogic、WebSphere等也内置了JMS支持。这里我们选择开源的ActiveMQ作为JMS服务器，因此，在开发JMS之前我们必须首先安装ActiveMQ。</p>
<p>现在问题来了：从官网下载ActiveMQ时，蹦出一个页面，让我们选择ActiveMQ Classic或者ActiveMQ Artemis，这两个是什么关系，又有什么区别？</p>
<p>实际上ActiveMQ Classic原来就叫ActiveMQ，是Apache开发的基于JMS 1.1的消息服务器，目前稳定版本号是5.x，而ActiveMQ Artemis是由RedHat捐赠的<a target="_blank" rel="noopener" href="https://hornetq.jboss.org/">HornetQ</a>服务器代码的基础上开发的，目前稳定版本号是2.x。和ActiveMQ Classic相比，Artemis版的代码与Classic完全不同，并且，它支持JMS 2.0，使用基于Netty的异步IO，大大提升了性能。此外，Artemis不仅提供了JMS接口，它还提供了AMQP接口，STOMP接口和物联网使用的MQTT接口。选择Artemis，相当于一鱼四吃。</p>
<p>所以，我们这里直接选择ActiveMQ Artemis。从官网<a target="_blank" rel="noopener" href="https://activemq.apache.org/components/artemis/download/">下载</a>最新的2.x版本，解压后设置环境变量<code>ARTEMIS_HOME</code>，指向Artemis根目录，例如<code>C:\Apps\artemis</code>，然后，把<code>ARTEMIS_HOME/bin</code>加入PATH环境变量：</p>
<ul>
<li>Windows下添加<code>%ARTEMIS_HOME%\bin</code>到Path路径；</li>
<li>Mac和Linux下添加<code>$ARTEMIS_HOME/bin</code>到PATH路径。</li>
</ul>
<p>Artemis有个很好的设计，就是它把程序和数据完全分离了。我们解压后的<code>ARTEMIS_HOME</code>目录是程序目录，要启动一个Artemis服务，还需要创建一个数据目录。我们把数据目录直接设定在项目<code>spring-integration-jms</code>的<code>jms-data</code>目录下。执行命令<code>artemis create jms-data</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">/Users/liaoxuefeng/workspace/spring-integration-jms</span><br><span class="line"></span><br><span class="line">$ artemis create jms-data</span><br><span class="line">Creating ActiveMQ Artemis instance at: /Users/liaoxuefeng/workspace/spring-integration-jms/jms-data</span><br><span class="line"></span><br><span class="line">--user: is a mandatory property!</span><br><span class="line">Please provide the default username:</span><br><span class="line">admin</span><br><span class="line"></span><br><span class="line">--password: is mandatory with this configuration:</span><br><span class="line">Please provide the default password:</span><br><span class="line">********</span><br><span class="line"></span><br><span class="line">--allow-anonymous | --require-login: is a mandatory property!</span><br><span class="line">Allow anonymous access?, valid values are Y,N,True,False</span><br><span class="line">N</span><br><span class="line"></span><br><span class="line">Auto tuning journal ...</span><br><span class="line">done! Your system can make 0.09 writes per millisecond, your journal-buffer-timeout will be 11392000</span><br><span class="line"></span><br><span class="line">You can now start the broker by executing:  </span><br><span class="line"></span><br><span class="line">   &quot;/Users/liaoxuefeng/workspace/spring-integration-jms/jms-data/bin/artemis&quot; run</span><br><span class="line"></span><br><span class="line">Or you can run the broker in the background using:</span><br><span class="line"></span><br><span class="line">   &quot;/Users/liaoxuefeng/workspace/spring-integration-jms/jms-data/bin/artemis-service&quot; start</span><br></pre></td></tr></table></figure>
<p>在创建过程中，会要求输入连接用户和口令，这里我们设定<code>admin</code>和<code>password</code>，以及是否允许匿名访问（这里选择<code>N</code>）。</p>
<p>此数据目录<code>jms-data</code>不仅包含消息数据、日志，还自动创建了两个启动服务的命令<code>bin/artemis</code>和<code>bin/artemis-service</code>，前者在前台启动运行，按Ctrl+C结束，后者会一直在后台运行。</p>
<p>我们把目录切换到<code>jms-data/bin</code>，直接运行<code>artemis run</code>即可启动Artemis服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ./artemis run</span><br><span class="line">     _        _               _</span><br><span class="line">    / \  ____| |_  ___ __  __(_) _____</span><br><span class="line">   / _ \|  _ \ __|/ _ \  \/  | |/  __/</span><br><span class="line">  / ___ \ | \/ |_/  __/ |\/| | |\___ \</span><br><span class="line"> /_/   \_\|   \__\____|_|  |_|_|/___ /</span><br><span class="line"> Apache ActiveMQ Artemis 2.13.0</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">2020-06-02 07:50:21,718 INFO  [org.apache.activemq.artemis] AMQ241001: HTTP Server started at http://localhost:8161</span><br><span class="line">2020-06-02 07:50:21,718 INFO  [org.apache.activemq.artemis] AMQ241002: Artemis Jolokia REST API available at http://localhost:8161/console/jolokia</span><br><span class="line">2020-06-02 07:50:21,719 INFO  [org.apache.activemq.artemis] AMQ241004: Artemis Console available at http://localhost:8161/console</span><br></pre></td></tr></table></figure>
<p>启动成功后，Artemis提示可以通过URL<code>http://localhost:8161/console</code>访问管理后台。注意<em>不要关闭命令行窗口</em>。</p>
<p>注意</p>
<p>如果Artemis启动时显示警告：AMQ222212: Disk Full! … Clients will report blocked.这是因为磁盘空间不够，可以在etc/broker.xml配置中找到并改为99。</p>
<p>在编写JMS代码之前，我们首先得理解JMS的消息模型。JMS把生产消息的一方称为Producer，处理消息的一方称为Consumer。有两种类型的消息通道，一种是Queue：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌────────┐    ┌────────┐    ┌────────┐</span><br><span class="line">│Producer│───▶│ Queue  │───▶│Consumer│</span><br><span class="line">└────────┘    └────────┘    └────────┘</span><br></pre></td></tr></table></figure>
<p>一种是Topic：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                            ┌────────┐</span><br><span class="line">                         ┌─▶│Consumer│</span><br><span class="line">                         │  └────────┘</span><br><span class="line">┌────────┐    ┌────────┐ │  ┌────────┐</span><br><span class="line">│Producer│───▶│ Topic  │─┼─▶│Consumer│</span><br><span class="line">└────────┘    └────────┘ │  └────────┘</span><br><span class="line">                         │  ┌────────┐</span><br><span class="line">                         └─▶│Consumer│</span><br><span class="line">                            └────────┘</span><br></pre></td></tr></table></figure>
<p>它们的区别在于，Queue是一种一对一的通道，如果Consumer离线无法处理消息时，Queue会把消息存起来，等Consumer再次连接的时候发给它。设定了持久化机制的Queue不会丢失消息。如果有多个Consumer接入同一个Queue，那么它们等效于以集群方式处理消息，例如，发送方发送的消息是A，B，C，D，E，F，两个Consumer可能分别收到A，C，E和B，D，F，即每个消息只会交给其中一个Consumer处理。</p>
<p>Topic则是一种一对多通道。一个Producer发出的消息，会被多个Consumer同时收到，即每个Consumer都会收到一份完整的消息流。那么问题来了：如果某个Consumer暂时离线，过一段时间后又上线了，那么在它离线期间产生的消息还能不能收到呢？</p>
<p>这取决于消息服务器对Topic类型消息的持久化机制。如果消息服务器不存储Topic消息，那么离线的Consumer会丢失部分离线时期的消息，如果消息服务器存储了Topic消息，那么离线的Consumer可以收到自上次离线时刻开始后产生的所有消息。JMS规范通过Consumer指定一个持久化订阅可以在上线后收取所有离线期间的消息，如果指定的是非持久化订阅，那么离线期间的消息会全部丢失。</p>
<p>细心的童鞋可以看出来，如果一个Topic的消息全部都持久化了，并且只有一个Consumer，那么它和Queue其实是一样的。实际上，很多消息服务器内部都只有Topic类型的消息架构，Queue可以通过Topic“模拟”出来。</p>
<p>无论是Queue还是Topic，对Producer没有什么要求。多个Producer也可以写入同一个Queue或者Topic，此时消息服务器内部会自动排序确保消息总是有序的。</p>
<p>以上是消息服务的基本模型。具体到某个消息服务器时，Producer和Consumer通常是通过TCP连接消息服务器，在编写JMS程序时，又会遇到<code>ConnectionFactory</code>、<code>Connection</code>、<code>Session</code>等概念，其实这和JDBC连接是类似的：</p>
<ul>
<li>ConnectionFactory：代表一个到消息服务器的连接池，类似JDBC的DataSource；</li>
<li>Connection：代表一个到消息服务器的连接，类似JDBC的Connection；</li>
<li>Session：代表一个经过认证后的连接会话；</li>
<li>Message：代表一个消息对象。</li>
</ul>
<p>在JMS 1.1中，发送消息的典型代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建连接:</span></span><br><span class="line">        connection = connectionFactory.createConnection();</span><br><span class="line">        <span class="comment">// 创建会话:</span></span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> connection.createSession(<span class="literal">false</span>,Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">// 创建一个Producer并关联到某个Queue:</span></span><br><span class="line">        <span class="type">MessageProducer</span> <span class="variable">messageProducer</span> <span class="operator">=</span> session.createProducer(queue);</span><br><span class="line">        <span class="comment">// 创建一个文本消息:</span></span><br><span class="line">        <span class="type">TextMessage</span> <span class="variable">textMessage</span> <span class="operator">=</span> session.createTextMessage(text);</span><br><span class="line">        <span class="comment">// 发送消息:</span></span><br><span class="line">        messageProducer.send(textMessage);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭连接:</span></span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (JMSException ex) &#123;</span><br><span class="line">    <span class="comment">// 处理JMS异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JMS 2.0改进了一些API接口，发送消息变得更简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">JMSContext</span> <span class="variable">context</span> <span class="operator">=</span> connectionFactory.createContext()) &#123;</span><br><span class="line">    context.createProducer().send(queue, text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>JMSContext</code>实现了<code>AutoCloseable</code>接口，可以使用<code>try(resource)</code>语法，代码更简单。</p>
<p>有了以上预备知识，我们就可以开始开发JMS应用了。</p>
<p>首先，我们在<code>pom.xml</code>中添加如下依赖：</p>
<ul>
<li>org.springframework:spring-jms:6.0.0</li>
<li>org.apache.activemq:artemis-jakarta-client:2.27.0</li>
</ul>
<p>Artemis的Client接口依赖了<code>jakarta.jms:jakarta.jms-api</code>，因此不必再引入JMS API的依赖。</p>
<p>在AppConfig中，通过<code>@EnableJms</code>让Spring自动扫描JMS相关的Bean，并加载JMS配置文件<code>jms.properties</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@EnableJms</span> <span class="comment">// 启用JMS</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@PropertySource(&#123; &quot;classpath:/jdbc.properties&quot;, &quot;classpath:/jms.properties&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先要创建的Bean是<code>ConnectionFactory</code>，即连接消息服务器的连接池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">ConnectionFactory <span class="title function_">createJMSConnectionFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@Value(&quot;$&#123;jms.uri:tcp://localhost:61616&#125;&quot;)</span> String uri,</span></span><br><span class="line"><span class="params">    <span class="meta">@Value(&quot;$&#123;jms.username:admin&#125;&quot;)</span> String username,</span></span><br><span class="line"><span class="params">    <span class="meta">@Value(&quot;$&#123;jms.password:password&#125;&quot;)</span> String password)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ActiveMQJMSConnectionFactory</span>(uri, username, password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们使用的消息服务器是ActiveMQ Artemis，所以<code>ConnectionFactory</code>的实现类就是消息服务器提供的<code>ActiveMQJMSConnectionFactory</code>，它需要的参数均由配置文件读取后传入，并设置了默认值。</p>
<p>我们再创建一个<code>JmsTemplate</code>，它是Spring提供的一个工具类，和<code>JdbcTemplate</code>类似，可以简化发送消息的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">JmsTemplate <span class="title function_">createJmsTemplate</span><span class="params">(<span class="meta">@Autowired</span> ConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JmsTemplate</span>(connectionFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步要创建的是<code>JmsListenerContainerFactory</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;jmsListenerContainerFactory&quot;)</span></span><br><span class="line">DefaultJmsListenerContainerFactory <span class="title function_">createJmsListenerContainerFactory</span><span class="params">(<span class="meta">@Autowired</span> ConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultJmsListenerContainerFactory</span>();</span><br><span class="line">    factory.setConnectionFactory(connectionFactory);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了必须指定Bean的名称为<code>jmsListenerContainerFactory</code>外，这个Bean的作用是处理和Consumer相关的Bean。我们先跳过它的原理，继续编写<code>MessagingService</code>来发送消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessagingService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span> ObjectMapper objectMapper;</span><br><span class="line">    <span class="meta">@Autowired</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMailMessage</span><span class="params">(MailMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> objectMapper.writeValueAsString(msg);</span><br><span class="line">        jmsTemplate.send(<span class="string">&quot;jms/queue/mail&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessageCreator</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> Message <span class="title function_">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException &#123;</span><br><span class="line">                <span class="keyword">return</span> session.createTextMessage(text);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JMS的消息类型支持以下几种：</p>
<ul>
<li>TextMessage：文本消息；</li>
<li>BytesMessage：二进制消息；</li>
<li>MapMessage：包含多个Key-Value对的消息；</li>
<li>ObjectMessage：直接序列化Java对象的消息；</li>
<li>StreamMessage：一个包含基本类型序列的消息。</li>
</ul>
<p>最常用的是发送基于JSON的文本消息，上述代码通过<code>JmsTemplate</code>创建一个<code>TextMessage</code>并发送到名称为<code>jms/queue/mail</code>的Queue。</p>
<p>注意：Artemis消息服务器默认配置下会自动创建Queue，因此不必手动创建一个名为<code>jms/queue/mail</code>的Queue，但不是所有的消息服务器都会自动创建Queue，生产环境的消息服务器通常会关闭自动创建功能，需要手动创建Queue。</p>
<p>再注意到<code>MailMessage</code>是我们自己定义的一个JavaBean，真正的JMS消息是创建的<code>TextMessage</code>，它的内容是JSON。</p>
<p>当用户注册成功后，我们就调用<code>MessagingService.sendMailMessage()</code>发送一条JMS消息，此代码十分简单，这里不再贴出。</p>
<p>下面我们要详细讨论的是如何处理消息，即编写Consumer。从理论上讲，可以创建另一个Java进程来处理消息，但对于我们这个简单的Web程序来说没有必要，直接在同一个Web应用中接收并处理消息即可。</p>
<p>处理消息的核心代码是编写一个Bean，并在处理方法上标注<code>@JmsListener</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailMessageListener</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> ObjectMapper objectMapper;</span><br><span class="line">    <span class="meta">@Autowired</span> MailService mailService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;jms/queue/mail&quot;, concurrency = &quot;10&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMailMessageReceived</span><span class="params">(Message message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;received message: &quot;</span> + message);</span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> TextMessage) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> ((TextMessage) message).getText();</span><br><span class="line">            <span class="type">MailMessage</span> <span class="variable">mm</span> <span class="operator">=</span> objectMapper.readValue(text, MailMessage.class);</span><br><span class="line">            mailService.sendRegistrationMail(mm);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;unable to process non-text message!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>@JmsListener</code>指定了Queue的名称，因此，凡是发到此Queue的消息都会被这个<code>onMailMessageReceived()</code>方法处理，方法参数是JMS的<code>Message</code>接口，我们通过强制转型为<code>TextMessage</code>并提取JSON，反序列化后获得自定义的JavaBean，也就获得了发送邮件所需的所有信息。</p>
<p>下面问题来了：Spring处理JMS消息的流程是什么？</p>
<p>如果我们直接调用JMS的API来处理消息，那么编写的代码大致如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建JMS连接:</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.createConnection();</span><br><span class="line"><span class="comment">// 创建会话:</span></span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"><span class="comment">// 创建一个Consumer:</span></span><br><span class="line"><span class="type">MessageConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> session.createConsumer(queue);</span><br><span class="line"><span class="comment">// 为Consumer指定一个消息处理器:</span></span><br><span class="line">consumer.setMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="comment">// 在此处理消息... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 启动接收消息的循环:</span></span><br><span class="line">connection.start();</span><br></pre></td></tr></table></figure>
<p>我们自己编写的<code>MailMessageListener.onMailMessageReceived()</code>相当于消息处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">consumer.setMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        mailMessageListener.onMailMessageReceived(message); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>所以，Spring根据<code>AppConfig</code>的注解<code>@EnableJms</code>自动扫描带有<code>@JmsListener</code>的Bean方法，并为其创建一个<code>MessageListener</code>把它包装起来。</p>
<p>注意到前面我们还创建了一个<code>JmsListenerContainerFactory</code>的Bean，它的作用就是为每个<code>MessageListener</code>创建<code>MessageConsumer</code>并启动消息接收循环。</p>
<p>再注意到<code>@JmsListener</code>还有一个<code>concurrency</code>参数，10表示可以最多同时并发处理10个消息，<code>5-10</code>表示并发处理的线程可以在5~10之间调整。</p>
<p>因此，Spring在通过<code>MessageListener</code>接收到消息后，并不是直接调用<code>mailMessageListener.onMailMessageReceived()</code>，而是用线程池调用，因此，要时刻牢记，<code>onMailMessageReceived()</code>方法可能被多线程并发执行，一定要保证线程安全。</p>
<p>我们总结一下Spring接收消息的步骤：</p>
<p>通过<code>JmsListenerContainerFactory</code>配合<code>@EnableJms</code>扫描所有<code>@JmsListener</code>方法，自动创建<code>MessageConsumer</code>、<code>MessageListener</code>以及线程池，启动消息循环接收处理消息，最终由我们自己编写的<code>@JmsListener</code>方法处理消息，可能会由多线程同时并发处理。</p>
<p>要验证消息发送和处理，我们注册一个新用户，可以看到如下日志输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">06</span>-<span class="number">02</span> 08:<span class="number">04</span>:<span class="number">27</span> INFO  c.i.learnjava.web.UserController - user registered: bob<span class="meta">@example</span>.com</span><br><span class="line"><span class="number">2020</span>-<span class="number">06</span>-<span class="number">02</span> 08:<span class="number">04</span>:<span class="number">27</span> INFO  c.i.l.service.MailMessageListener - received message: ActiveMQMessage[ID:9fc5...]:PERSISTENT/ClientMessageImpl[messageID=<span class="number">983</span>, durable=<span class="literal">true</span>, address=jms/queue/mail, ...]]</span><br><span class="line"><span class="number">2020</span>-<span class="number">06</span>-<span class="number">02</span> 08:<span class="number">04</span>:<span class="number">27</span> INFO  c.i.learnjava.service.MailService - [send mail] sending registration mail to bob<span class="meta">@example</span>.com...</span><br><span class="line"><span class="number">2020</span>-<span class="number">06</span>-<span class="number">02</span> 08:<span class="number">04</span>:<span class="number">30</span> INFO  c.i.learnjava.service.MailService - [send mail] registration mail was sent to bob<span class="meta">@example</span>.com.</span><br></pre></td></tr></table></figure>
<p>可见，消息被成功发送到Artemis，然后在很短的时间内被接收处理了。</p>
<p>使用消息服务对发送Email进行改造的好处是，发送Email的能力通常是有限的，通过JMS消息服务，如果短时间内需要给大量用户发送Email，可以先把消息堆积在JMS服务器上慢慢发送，对于批量发送邮件、短信等尤其有用。</p>
<h3 id="练习-2">练习</h3>
<p>使用JMS。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/integration/jms/spring-integration-jms.zip">下载练习</a></p>
<h3 id="小结-2">小结</h3>
<p>JMS是Java消息服务，可以通过JMS服务器实现消息的异步处理。</p>
<p>消息服务主要解决Producer和Consumer生产和处理速度不匹配的问题。</p>
<p>在很多应用程序中，经常需要执行定时任务。例如，每天或每月给用户发送账户汇总报表，定期检查并发送系统状态报告，等等。</p>
<p>定时任务我们在<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/threading/pool/index.html">使用线程池</a>一节中已经讲到了，Java标准库本身就提供了定时执行任务的功能。在Spring中，使用定时任务更简单，不需要手写线程池相关代码，只需要两个注解即可。</p>
<p>我们还是以实际代码为例，建立工程<code>spring-integration-schedule</code>，无需额外的依赖，我们可以直接在<code>AppConfig</code>中加上<code>@EnableScheduling</code>就开启了定时任务的支持：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@PropertySource(&#123; &quot;classpath:/jdbc.properties&quot;, &quot;classpath:/task.properties&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们可以直接在一个Bean中编写一个<code>public void</code>无参数方法，然后加上<code>@Scheduled</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskService</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(initialDelay = 60_000, fixedRate = 60_000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkSystemStatusEveryMinute</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Start check system status...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述注解指定了启动延迟60秒，并以60秒的间隔执行任务。现在，我们直接运行应用程序，就可以在控制台看到定时任务打印的日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020-06-03 18:47:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start check system status...</span><br><span class="line">2020-06-03 18:48:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start check system status...</span><br><span class="line">2020-06-03 18:49:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start check system status...</span><br></pre></td></tr></table></figure>
<p>如果没有看到定时任务的日志，需要检查：</p>
<ul>
<li>是否忘记了在<code>AppConfig</code>中标注<code>@EnableScheduling</code>；</li>
<li>是否忘记了在定时任务的方法所在的class标注<code>@Component</code>。</li>
</ul>
<p>除了可以使用<code>fixedRate</code>外，还可以使用<code>fixedDelay</code>，两者的区别我们已经在使用线程池一节中讲过，这里不再重复。</p>
<p>有的童鞋在实际开发中会遇到一个问题，因为Java的注解全部是常量，写死了<code>fixedDelay=30000</code>，如果根据实际情况要改成60秒怎么办，只能重新编译？</p>
<p>我们可以把定时任务的配置放到配置文件中，例如<code>task.properties</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task.checkDiskSpace=30000</span><br></pre></td></tr></table></figure>
<p>这样就可以随时修改配置文件而无需动代码。但是在代码中，我们需要用<code>fixedDelayString</code>取代<code>fixedDelay</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(initialDelay = 30_000, fixedDelayString = &quot;$&#123;task.checkDiskSpace:30000&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkDiskSpaceEveryMinute</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Start check disk space...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到上述代码的注解参数<code>fixedDelayString</code>是一个属性占位符，并配有默认值30000，Spring在处理<code>@Scheduled</code>注解时，如果遇到<code>String</code>，会根据占位符自动用配置项替换，这样就可以灵活地修改定时任务的配置。</p>
<p>此外，<code>fixedDelayString</code>还可以使用更易读的<code>Duration</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(initialDelay = 30_000, fixedDelayString = &quot;$&#123;task.checkDiskSpace:PT2M30S&#125;&quot;)</span></span><br></pre></td></tr></table></figure>
<p>以字符串<code>PT2M30S</code>表示的<code>Duration</code>就是2分30秒，请参考<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/datetime/local-datetime/index.html">LocalDateTime</a>一节的Duration相关部分。</p>
<p>多个<code>@Scheduled</code>方法完全可以放到一个Bean中，这样便于统一管理各类定时任务。</p>
<h3 id="使用Cron任务">使用Cron任务</h3>
<p>还有一类定时任务，它不是简单的重复执行，而是按时间触发，我们把这类任务称为Cron任务，例如：</p>
<ul>
<li>每天凌晨2:15执行报表任务；</li>
<li>每个工作日12:00执行特定任务；</li>
<li>……</li>
</ul>
<p>Cron源自Unix/Linux系统自带的crond守护进程，以一个简洁的表达式定义任务触发时间。在Spring中，也可以使用Cron表达式来执行Cron任务，在Spring中，它的格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">秒 分 小时 天 月份 星期 年</span><br></pre></td></tr></table></figure>
<p>年是可以忽略的，通常不写。每天凌晨2:15执行的Cron表达式就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 15 2 * * *</span><br></pre></td></tr></table></figure>
<p>每个工作日12:00执行的Cron表达式就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 12 * * MON-FRI</span><br></pre></td></tr></table></figure>
<p>每个月1号，2号，3号和10号12:00执行的Cron表达式就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 12 1-3,10 * *</span><br></pre></td></tr></table></figure>
<p>在Spring中，我们定义一个每天凌晨2:15执行的任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;$&#123;task.report:0 15 2 * * *&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cronDailyReport</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Start daily report task...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Cron任务同样可以使用属性占位符，这样修改起来更加方便。</p>
<p>Cron表达式还可以表达每10分钟执行，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 */10 * * * *</span><br></pre></td></tr></table></figure>
<p>这样，在每个小时的0:00，10:00，20:00，30:00，40:00，50:00均会执行任务，实际上它可以取代<code>fixedRate</code>类型的定时任务。</p>
<h3 id="集成Quartz">集成Quartz</h3>
<p>在Spring中使用定时任务和Cron任务都十分简单，但是要注意到，这些任务的调度都是在每个JVM进程中的。如果在本机启动两个进程，或者在多台机器上启动应用，这些进程的定时任务和Cron任务都是独立运行的，互不影响。</p>
<p>如果一些定时任务要以集群的方式运行，例如每天23:00执行检查任务，只需要集群中的一台运行即可，这个时候，可以考虑使用<a target="_blank" rel="noopener" href="https://www.quartz-scheduler.org/">Quartz</a>。</p>
<p>Quartz可以配置一个JDBC数据源，以便存储所有的任务调度计划以及任务执行状态。也可以使用内存来调度任务，但这样配置就和使用Spring的调度没啥区别了，额外集成Quartz的意义就不大。</p>
<p>Quartz的JDBC配置比较复杂，Spring对其也有一定的支持。要详细了解Quartz的集成，请参考<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#scheduling-quartz">Spring的文档</a>。</p>
<p>思考：如果不使用Quartz的JDBC配置，多个Spring应用同时运行时，如何保证某个任务只在某一台机器执行？</p>
<h3 id="练习-3">练习</h3>
<p>使用Scheduler执行定时任务。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/integration/scheduler/spring-integration-schedule.zip">下载练习</a></p>
<h3 id="小结-3">小结</h3>
<p>Spring内置定时任务和Cron任务的支持，编写调度任务十分方便。</p>
<p>在Spring中，可以方便地集成JMX。</p>
<p>那么第一个问题来了：什么是JMX？</p>
<p>JMX是Java Management Extensions，它是一个Java平台的管理和监控接口。为什么要搞JMX呢？因为在所有的应用程序中，对运行中的程序进行监控都是非常重要的，Java应用程序也不例外。我们肯定希望知道Java应用程序当前的状态，例如，占用了多少内存，分配了多少内存，当前有多少活动线程，有多少休眠线程等等。如何获取这些信息呢？</p>
<p>为了标准化管理和监控，Java平台使用JMX作为管理和监控的标准接口，任何程序，只要按JMX规范访问这个接口，就可以获取所有管理与监控信息。</p>
<p>实际上，常用的运维监控如Zabbix、Nagios等工具对JVM本身的监控都是通过JMX获取的信息。</p>
<p>因为JMX是一个标准接口，不但可以用于管理JVM，还可以管理应用程序自身。下图是JMX的架构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    ┌─────────┐  ┌─────────┐</span><br><span class="line">    │jconsole │  │   Web   │</span><br><span class="line">    └─────────┘  └─────────┘</span><br><span class="line">         │            │</span><br><span class="line">┌ ─ ─ ─ ─│─ ─ ─ ─ ─ ─ ┼ ─ ─ ─ ─</span><br><span class="line"> JVM     ▼            ▼        │</span><br><span class="line">│   ┌─────────┐  ┌─────────┐</span><br><span class="line">  ┌─┤Connector├──┤ Adaptor ├─┐ │</span><br><span class="line">│ │ └─────────┘  └─────────┘ │</span><br><span class="line">  │       MBeanServer        │ │</span><br><span class="line">│ │ ┌──────┐┌──────┐┌──────┐ │</span><br><span class="line">  └─┤MBean1├┤MBean2├┤MBean3├─┘ │</span><br><span class="line">│   └──────┘└──────┘└──────┘</span><br><span class="line"> ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>
<p>JMX把所有被管理的资源都称为MBean（Managed Bean），这些MBean全部由MBeanServer管理，如果要访问MBean，可以通过MBeanServer对外提供的访问接口，例如通过RMI或HTTP访问。</p>
<p>注意到使用JMX不需要安装任何额外组件，也不需要第三方库，因为MBeanServer已经内置在JavaSE标准库中了。JavaSE还提供了一个<code>jconsole</code>程序，用于通过RMI连接到MBeanServer，这样就可以管理整个Java进程。</p>
<p>除了JVM会把自身的各种资源以MBean注册到JMX中，我们自己的配置、监控信息也可以作为MBean注册到JMX，这样，管理程序就可以直接控制我们暴露的MBean。因此，应用程序使用JMX，只需要两步：</p>
<ol>
<li>编写MBean提供管理接口和监控数据；</li>
<li>注册MBean。</li>
</ol>
<p>在Spring应用程序中，使用JMX只需要一步：</p>
<ol>
<li>编写MBean提供管理接口和监控数据。</li>
</ol>
<p>第二步注册的过程由Spring自动完成。我们以实际工程为例，首先在<code>AppConfig</code>中加上<code>@EnableMBeanExport</code>注解，告诉Spring自动注册MBean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@EnableMBeanExport</span> <span class="comment">// 自动注册MBean</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@PropertySource(&#123; &quot;classpath:/jdbc.properties&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩下的全部工作就是编写MBean。我们以实际问题为例，假设我们希望给应用程序添加一个IP黑名单功能，凡是在黑名单中的IP禁止访问，传统的做法是定义一个配置文件，启动的时候读取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># blacklist.txt</span><br><span class="line">1.2.3.4</span><br><span class="line">5.6.7.8</span><br><span class="line">2.2.3.4</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果要修改黑名单怎么办？修改配置文件，然后重启应用程序。</p>
<p>但是每次都重启应用程序实在是太麻烦了，能不能不重启应用程序？可以自己写一个定时读取配置文件的功能，检测到文件改动时自动重新读取。</p>
<p>上述需求本质上是在应用程序运行期间对参数、配置等进行热更新并要求尽快生效。如果以JMX的方式实现，我们不必自己编写自动重新读取等任何代码，只需要提供一个符合JMX标准的MBean来存储配置即可。</p>
<p>还是以IP黑名单为例，JMX的MBean通常以MBean结尾，因此我们遵循标准命名规范，首先编写一个<code>BlacklistMBean</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlacklistMBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; ips = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getBlacklist() &#123;</span><br><span class="line">        <span class="keyword">return</span> ips.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBlacklist</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        ips.add(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeBlacklist</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        ips.remove(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldBlock</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ips.contains(ip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个MBean没什么特殊的，它的逻辑和普通Java类没有任何区别。</p>
<p>下一步，我们要使用JMX的客户端来实时热更新这个MBean，所以要给它加上一些注解，让Spring能根据注解自动把相关方法注册到MBeanServer中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ManagedResource(objectName = &quot;sample:name=blacklist&quot;, description = &quot;Blacklist of IP addresses&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlacklistMBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; ips = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManagedAttribute(description = &quot;Get IP addresses in blacklist&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBlacklist() &#123;</span><br><span class="line">        <span class="keyword">return</span> ips.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManagedOperation</span></span><br><span class="line">    <span class="meta">@ManagedOperationParameter(name = &quot;ip&quot;, description = &quot;Target IP address that will be added to blacklist&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBlacklist</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        ips.add(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManagedOperation</span></span><br><span class="line">    <span class="meta">@ManagedOperationParameter(name = &quot;ip&quot;, description = &quot;Target IP address that will be removed from blacklist&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeBlacklist</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        ips.remove(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldBlock</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ips.contains(ip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察上述代码，<code>BlacklistMBean</code>首先是一个标准的Spring管理的Bean，其次，添加了<code>@ManagedResource</code>表示这是一个MBean，将要被注册到JMX。objectName指定了这个MBean的名字，通常以<code>company:name=Xxx</code>来分类MBean。</p>
<p>对于属性，使用<code>@ManagedAttribute</code>注解标注。上述MBean只有get属性，没有set属性，说明这是一个只读属性。</p>
<p>对于操作，使用<code>@ManagedOperation</code>注解标准。上述MBean定义了两个操作：<code>addBlacklist()</code>和<code>removeBlacklist()</code>，其他方法如<code>shouldBlock()</code>不会被暴露给JMX。</p>
<p>使用MBean和普通Bean是完全一样的。例如，我们在<code>BlacklistInterceptor</code>对IP进行黑名单拦截：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlacklistInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    BlacklistMBean blacklistMBean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> request.getRemoteAddr();</span><br><span class="line">        logger.info(<span class="string">&quot;check ip address &#123;&#125;...&quot;</span>, ip);</span><br><span class="line">        <span class="comment">// 是否在黑名单中:</span></span><br><span class="line">        <span class="keyword">if</span> (blacklistMBean.shouldBlock(ip)) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;will block ip &#123;&#125; for it is in blacklist.&quot;</span>, ip);</span><br><span class="line">            <span class="comment">// 发送403错误响应:</span></span><br><span class="line">            response.sendError(<span class="number">403</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步就是正常启动Web应用程序，不要关闭它，我们打开另一个命令行窗口，输入<code>jconsole</code>启动JavaSE自带的一个JMX客户端程序：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/integration/jmx/jconsole.png" alt="jconsole"></p>
<p>通过jconsole连接到一个Java进程最简单的方法是直接在Local Process中找到正在运行的<code>AppConfig</code>，点击Connect即可连接到我们当前正在运行的Web应用，在jconsole中可直接看到内存、CPU等资源的监控。</p>
<p>我们点击MBean，左侧按分类列出所有MBean，可以在<code>java.lang</code>查看内存等信息：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/integration/jmx/mbeans.png" alt="mbean"></p>
<p>细心的童鞋可以看到HikariCP连接池也是通过JMX监控的。</p>
<p>在<code>sample</code>中可以看到我们自己的MBean，点击可查看属性<code>blacklist</code>：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/integration/jmx/my-mbean.png" alt="mbean-value"></p>
<p>点击<code>Operations</code>-<code>addBlacklist</code>，可以填入<code>127.0.0.1</code>并点击<code>addBlacklist</code>按钮，相当于jconsole通过JMX接口，调用了我们自己的<code>BlacklistMBean</code>的<code>addBlacklist()</code>方法，传入的参数就是填入的<code>127.0.0.1</code>：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/integration/jmx/mbean-edit.png" alt="mbean-invoke-ok"></p>
<p>再次查看属性<code>blacklist</code>，可以看到结果已经更新了：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/integration/jmx/mbean-attr.png" alt="mbean-modified"></p>
<p>我们可以在浏览器中测试一下黑名单功能是否已生效：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/integration/jmx/mbean-enabled.png" alt="403"></p>
<p>可见，<code>127.0.0.1</code>确实被添加到了黑名单，后台日志打印如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-06-06 20:22:12 INFO  c.i.l.web.BlacklistInterceptor - check ip address 127.0.0.1...</span><br><span class="line">2020-06-06 20:22:12 WARN  c.i.l.web.BlacklistInterceptor - will block ip 127.0.0.1 for it is in blacklist.</span><br></pre></td></tr></table></figure>
<p>注意：如果使用IPv6，那么需要把<code>0:0:0:0:0:0:0:1</code>这个本机地址加到黑名单。</p>
<p>如果从jconsole中调用<code>removeBlacklist</code>移除<code>127.0.0.1</code>，刷新浏览器可以看到又允许访问了。</p>
<p>使用jconsole直接通过Local Process连接JVM有个限制，就是jconsole和正在运行的JVM必须在同一台机器。如果要远程连接，首先要打开JMX端口。我们在启动<code>AppConfig</code>时，需要传入以下JVM启动参数：</p>
<ul>
<li>-Dcom.sun.management.jmxremote.port=19999</li>
<li>-Dcom.sun.management.jmxremote.authenticate=false</li>
<li>-Dcom.sun.management.jmxremote.ssl=false</li>
</ul>
<p>第一个参数表示在19999端口监听JMX连接，第二个和第三个参数表示无需验证，不使用SSL连接，在开发测试阶段比较方便，生产环境必须指定验证方式并启用SSL。详细参数可参考Oracle<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html#gdeum">官方文档</a>。这样jconsole可以用<code>ip:19999</code>的远程方式连接JMX。连接后的操作是完全一样的。</p>
<p>许多JavaEE服务器如JBoss的管理后台都是通过JMX提供管理接口，并由Web方式访问，对用户更加友好。</p>
<p>在实际项目中，通过JMX实现配置的实时更新其实并不常用，JMX更多地用于收集JVM的运行状态和应用程序的性能数据，然后通过监控服务器汇总数据后实现监控与报警。一个典型的监控系统架构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────┐   ┌───────────────┐</span><br><span class="line">│  Web Console  │◀──│Metrics Server │</span><br><span class="line">└───────────────┘   └───────────────┘</span><br><span class="line">                            │</span><br><span class="line">                            │</span><br><span class="line">   ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─│─ ─ ┐</span><br><span class="line">     ┌───────────────┐      │</span><br><span class="line">   │ │      App      │      │    │</span><br><span class="line">     ├─────────┬─────┤   ┌─────┐</span><br><span class="line">   │ │         │ JMX │──▶│Agent│ │</span><br><span class="line">     │         └─────┤   └─────┘</span><br><span class="line">   │ │      JVM      │           │</span><br><span class="line">     └───────────────┘</span><br><span class="line">   └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>
<p>其中，App自身和JVM的的统计数据都通过JMX收集并发送给本机的一个Agent，Agent再将数据发送至监控服务器，最后以可视化的形式将监控数据通过Web等形式展示给用户。常用的监控系统有开源的<a target="_blank" rel="noopener" href="https://prometheus.io/">Prometheus</a>和以云服务方式提供的<a target="_blank" rel="noopener" href="https://www.datadoghq.com/">DataDog</a>等。</p>
<h3 id="练习-4">练习</h3>
<p>编写一个MBean统计当前注册用户数量，并在jconsole中查看：</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/integration/jmx/spring-integration-jmx.zip">下载练习</a></p>
<h3 id="小结-4">小结</h3>
<p>在Spring中使用JMX需要：</p>
<ul>
<li>通过<code>@EnableMBeanExport</code>启用自动注册MBean；</li>
<li>编写MBean并实现管理属性和管理操作。</li>
</ul>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">標籤</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/Java/" rel="tag">Java</a> <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/Spirng/" rel="tag">Spirng</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../27/java/JAVA-Spring-Boot%E5%BC%80%E5%8F%91/"
                    data-tooltip="JAVA-Spring Boot开发"
                    aria-label="上一篇: JAVA-Spring Boot开发"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../25/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/"
                    data-tooltip="JAVA-Spring开发-开发Web应用"
                    aria-label="下一篇: JAVA-Spring开发-开发Web应用"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2018/02/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2018/02/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2018/02/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2018/02/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../27/java/JAVA-Spring-Boot%E5%BC%80%E5%8F%91/"
                    data-tooltip="JAVA-Spring Boot开发"
                    aria-label="上一篇: JAVA-Spring Boot开发"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../25/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/"
                    data-tooltip="JAVA-Spring开发-开发Web应用"
                    aria-label="下一篇: JAVA-Spring开发-开发Web应用"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2018/02/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2018/02/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2018/02/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2018/02/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2018/02/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/"
                        aria-label="分享到 Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2018/02/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/"
                        aria-label="分享到 Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2018/02/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/"
                        aria-label="global.share_on_linkedin"
                    >
                        <i class="fab fa-linkedin" aria-hidden="true"></i><span>global.share_on_linkedin</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2018/02/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/"
                        aria-label="分享到 Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 199 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
