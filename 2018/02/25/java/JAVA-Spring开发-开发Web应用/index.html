
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>JAVA-Spring开发-开发Web应用 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg"},"articleBody":"在Web开发一章中，我们已经详细介绍了JavaEE中Web开发的基础：Servlet。具体地说，有以下几点：\n\nServlet规范定义了几种标准组件：Servlet、JSP、Filter和Listener；\nServlet的标准组件总是运行在Servlet容器中，如Tomcat、Jetty、WebLogic等。\n\n直接使用Servlet进行Web开发好比直接在JDBC上操作数据库，比较繁琐，更好的方法是在Servlet基础上封装MVC框架，基于MVC开发Web应用，大部分时候，不需要接触Servlet API，开发省时省力。\n我们在MVC开发和MVC高级开发已经由浅入深地介绍了如何编写MVC框架。当然，自己写的MVC主要是理解原理，要实现一个功能全面的MVC需要大量的工作以及广泛的测试。\n因此，开发Web应用，首先要选择一个优秀的MVC框架。常用的MVC框架有：\n\nStruts：最古老的一个MVC框架，目前版本是2，和1.x有很大的区别；\nWebWork：一个比Struts设计更优秀的MVC框架，但不知道出于什么原因，从2.0开始把自己的代码全部塞给Struts 2了；\nTurbine：一个重度使用Velocity，强调布局的MVC框架；\n其他100+MVC框架……（略）\n\nSpring虽然都可以集成任何Web框架，但是，Spring本身也开发了一个MVC框架，就叫Spring MVC。这个MVC框架设计得足够优秀以至于我们已经不想再费劲去集成类似Struts这样的框架了。\n本章我们会详细介绍如何基于Spring MVC开发Web应用。\n我们已经介绍了Java Web的基础：Servlet容器，以及标准的Servlet组件：\n\nServlet：能处理HTTP请求并将HTTP响应返回；\nJSP：一种嵌套Java代码的HTML，将被编译为Servlet；\nFilter：能过滤指定的URL以实现拦截功能；\nListener：监听指定的事件，如ServletContext、HttpSession的创建和销毁。\n\n此外，Servlet容器为每个Web应用程序自动创建一个唯一的ServletContext实例，这个实例就代表了Web应用程序本身。\n在MVC高级开发中，我们手撸了一个MVC框架，接口和Spring MVC类似。如果直接使用Spring MVC，我们写出来的代码类似：\n12345678910111213@Controllerpublic class UserController &#123;    @GetMapping(&quot;/register&quot;)    public ModelAndView register() &#123;        ...    &#125;    @PostMapping(&quot;/signin&quot;)    public ModelAndView signin(@RequestParam(&quot;email&quot;) String email, @RequestParam(&quot;password&quot;) String password) &#123;        ...    &#125;    ...&#125;\n但是，Spring提供的是一个IoC容器，所有的Bean，包括Controller，都在Spring IoC容器中被初始化，而Servlet容器由JavaEE服务器提供（如Tomcat），Servlet容器对Spring一无所知，他们之间到底依靠什么进行联系，又是以何种顺序初始化的？\n在理解上述问题之前，我们先把基于Spring MVC开发的项目结构搭建起来。首先创建基于Web的Maven工程，引入如下依赖：\n\norg.springframework:spring-context:6.0.0\norg.springframework:spring-webmvc:6.0.0\norg.springframework:spring-jdbc:6.0.0\njakarta.annotation:jakarta.annotation-api:2.1.1\nio.pebbletemplates:pebble-spring6:3.2.0\nch.qos.logback:logback-core:1.4.4\nch.qos.logback:logback-classic:1.4.4\ncom.zaxxer:HikariCP:5.0.1\norg.hsqldb:hsqldb:2.7.0\n\n以及provided依赖：\n\norg.apache.tomcat.embed:tomcat-embed-core:10.1.1\norg.apache.tomcat.embed:tomcat-embed-jasper:10.1.1\n\n这个标准的Maven Web工程目录结构如下：\n123456789101112131415161718192021222324252627282930313233spring-web-mvc├── pom.xml└── src    └── main        ├── java        │   └── com        │       └── itranswarp        │           └── learnjava        │               ├── AppConfig.java        │               ├── DatabaseInitializer.java        │               ├── entity        │               │   └── User.java        │               ├── service        │               │   └── UserService.java        │               └── web        │                   └── UserController.java        ├── resources        │   ├── jdbc.properties        │   └── logback.xml        └── webapp            ├── WEB-INF            │   ├── templates            │   │   ├── _base.html            │   │   ├── index.html            │   │   ├── profile.html            │   │   ├── register.html            │   │   └── signin.html            │   └── web.xml            └── static                ├── css                │   └── bootstrap.css                └── js                    └── jquery.js\n其中，src/main/webapp是标准web目录，WEB-INF存放web.xml，编译的class，第三方jar，以及不允许浏览器直接访问的View模版，static目录存放所有静态文件。\n在src/main/resources目录中存放的是Java程序读取的classpath资源文件，除了JDBC的配置文件jdbc.properties外，我们又新增了一个logback.xml，这是Logback的默认查找的配置文件：\n1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt;\t&lt;appender name=&quot;STDOUT&quot;\t\tclass=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;\t\t&lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;\t\t\t&lt;Pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5level %logger&#123;36&#125; - %msg%n&lt;/Pattern&gt;\t\t&lt;/layout&gt;\t&lt;/appender&gt;\t&lt;logger name=&quot;com.itranswarp.learnjava&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;\t\t&lt;appender-ref ref=&quot;STDOUT&quot; /&gt;\t&lt;/logger&gt;\t&lt;root level=&quot;info&quot;&gt;\t\t&lt;appender-ref ref=&quot;STDOUT&quot; /&gt;\t&lt;/root&gt;&lt;/configuration&gt;\n上面给出了一个写入到标准输出的Logback配置，可以基于上述配置添加写入到文件的配置。\n在src/main/java中就是我们编写的Java代码了。\n配置Spring MVC\n和普通Spring配置一样，我们编写正常的AppConfig后，只需加上@EnableWebMvc注解，就“激活”了Spring MVC：\n12345678@Configuration@ComponentScan@EnableWebMvc // 启用Spring MVC@EnableTransactionManagement@PropertySource(&quot;classpath:/jdbc.properties&quot;)public class AppConfig &#123;    ...&#125;\n除了创建DataSource、JdbcTemplate、PlatformTransactionManager外，AppConfig需要额外创建几个用于Spring MVC的Bean：\n123456789@BeanWebMvcConfigurer createWebMvcConfigurer() &#123;    return new WebMvcConfigurer() &#123;        @Override        public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;            registry.addResourceHandler(&quot;/static/**&quot;).addResourceLocations(&quot;/static/&quot;);        &#125;    &#125;;&#125;\nWebMvcConfigurer并不是必须的，但我们在这里创建一个默认的WebMvcConfigurer，只覆写addResourceHandlers()，目的是让Spring MVC自动处理静态文件，并且映射路径为/static/**。\n另一个必须要创建的Bean是ViewResolver，因为Spring MVC允许集成任何模板引擎，使用哪个模板引擎，就实例化一个对应的ViewResolver：\n12345678910111213@BeanViewResolver createViewResolver(@Autowired ServletContext servletContext) &#123;    var engine = new PebbleEngine.Builder().autoEscaping(true)            // cache:            .cacheActive(false)            // loader:            .loader(new Servlet5Loader(servletContext))            .build();    var viewResolver = new PebbleViewResolver(engine);    viewResolver.setPrefix(&quot;/WEB-INF/templates/&quot;);    viewResolver.setSuffix(&quot;&quot;);    return viewResolver;&#125;\nViewResolver通过指定prefix和suffix来确定如何查找View。上述配置使用Pebble引擎，指定模板文件存放在/WEB-INF/templates/目录下。\n剩下的Bean都是普通的@Component，但Controller必须标记为@Controller，例如：\n1234567891011121314// Controller使用@Controller标记而不是@Component:@Controllerpublic class UserController &#123;    // 正常使用@Autowired注入:    @Autowired    UserService userService;    // 处理一个URL映射:    @GetMapping(&quot;/&quot;)    public ModelAndView index() &#123;        ...    &#125;    ...&#125;\n如果是普通的Java应用程序，我们通过main()方法可以很简单地创建一个Spring容器的实例：\n123public static void main(String[] args) &#123;    var context = new AnnotationConfigApplicationContext(AppConfig.class);&#125;\n但是问题来了，现在是Web应用程序，而Web应用程序总是由Servlet容器创建，那么，Spring容器应该由谁创建？在什么时候创建？Spring容器中的Controller又是如何通过Servlet调用的？\n在Web应用中启动Spring容器有很多种方法，可以通过Listener启动，也可以通过Servlet启动，可以使用XML配置，也可以使用注解配置。这里，我们只介绍一种最简单的启动Spring容器的方式。\n第一步，我们在web.xml中配置Spring MVC提供的DispatcherServlet：\n123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot;?&gt;&lt;web-app&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextClass&lt;/param-name&gt;            &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;com.itranswarp.learnjava.AppConfig&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n初始化参数contextClass指定使用注解配置的AnnotationConfigWebApplicationContext，配置文件的位置参数contextConfigLocation指向AppConfig的完整类名，最后，把这个Servlet映射到/*，即处理所有URL。\n上述配置可以看作一个样板配置，有了这个配置，Servlet容器会首先初始化Spring MVC的DispatcherServlet，在DispatcherServlet启动时，它根据配置AppConfig创建了一个类型是WebApplicationContext的IoC容器，完成所有Bean的初始化，并将容器绑到ServletContext上。\n因为DispatcherServlet持有IoC容器，能从IoC容器中获取所有@Controller的Bean，因此，DispatcherServlet接收到所有HTTP请求后，根据Controller方法配置的路径，就可以正确地把请求转发到指定方法，并根据返回的ModelAndView决定如何渲染页面。\n最后，我们在AppConfig中通过main()方法启动嵌入式Tomcat：\n123456789101112public static void main(String[] args) throws Exception &#123;    Tomcat tomcat = new Tomcat();    tomcat.setPort(Integer.getInteger(&quot;port&quot;, 8080));    tomcat.getConnector();    Context ctx = tomcat.addWebapp(&quot;&quot;, new File(&quot;src/main/webapp&quot;).getAbsolutePath());    WebResourceRoot resources = new StandardRoot(ctx);    resources.addPreResources(            new DirResourceSet(resources, &quot;/WEB-INF/classes&quot;, new File(&quot;target/classes&quot;).getAbsolutePath(), &quot;/&quot;));    ctx.setResources(resources);    tomcat.start();    tomcat.getServer().await();&#125;\n上述Web应用程序就是我们使用Spring MVC时的一个最小启动功能集。由于使用了JDBC和数据库，用户的注册、登录信息会被持久化：\n\n编写Controller\n有了Web应用程序的最基本的结构，我们的重点就可以放在如何编写Controller上。Spring MVC对Controller没有固定的要求，也不需要实现特定的接口。以UserController为例，编写Controller只需要遵循以下要点：\n总是标记@Controller而不是@Component：\n1234@Controllerpublic class UserController &#123;    ...&#125;\n一个方法对应一个HTTP请求路径，用@GetMapping或@PostMapping表示GET或POST请求：\n1234567@PostMapping(&quot;/signin&quot;)public ModelAndView doSignin(        @RequestParam(&quot;email&quot;) String email,        @RequestParam(&quot;password&quot;) String password,        HttpSession session) &#123;    ...&#125;\n需要接收的HTTP参数以@RequestParam()标注，可以设置默认值。如果方法参数需要传入HttpServletRequest、HttpServletResponse或者HttpSession，直接添加这个类型的参数即可，Spring MVC会自动按类型传入。\n返回的ModelAndView通常包含View的路径和一个Map作为Model，但也可以没有Model，例如：\n1return new ModelAndView(&quot;signin.html&quot;); // 仅View，没有Model\n返回重定向时既可以写new ModelAndView(&quot;redirect:/signin&quot;)，也可以直接返回String：\n1234567public String index() &#123;    if (...) &#123;        return &quot;redirect:/signin&quot;;    &#125; else &#123;        return &quot;redirect:/profile&quot;;    &#125;&#125;\n如果在方法内部直接操作HttpServletResponse发送响应，返回null表示无需进一步处理：\n12345678public ModelAndView download(HttpServletResponse response) &#123;    byte[] data = ...    response.setContentType(&quot;application/octet-stream&quot;);    OutputStream output = response.getOutputStream();    output.write(data);    output.flush();    return null;&#125;\n对URL进行分组，每组对应一个Controller是一种很好的组织形式，并可以在Controller的class定义出添加URL前缀，例如：\n123456789101112131415@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123;    // 注意实际URL映射是/user/profile    @GetMapping(&quot;/profile&quot;)    public ModelAndView profile() &#123;        ...    &#125;    // 注意实际URL映射是/user/changePassword    @GetMapping(&quot;/changePassword&quot;)    public ModelAndView changePassword() &#123;        ...    &#125;&#125;\n实际方法的URL映射总是前缀+路径，这种形式还可以有效避免不小心导致的重复的URL映射。\n可见，Spring MVC允许我们编写既简单又灵活的Controller实现。\n练习\n使用Spring MVC，在注册、登录等功能的基础上增加一个修改口令的页面。\n下载练习\n小结\n使用Spring MVC时，整个Web应用程序按如下顺序启动：\n\n启动Tomcat服务器；\nTomcat读取web.xml并初始化DispatcherServlet；\nDispatcherServlet创建IoC容器并自动注册到ServletContext中。\n\n启动后，浏览器发出的HTTP请求全部由DispatcherServlet接收，并根据配置转发到指定Controller的指定方法处理。\n使用Spring MVC开发Web应用程序的主要工作就是编写Controller逻辑。在Web应用中，除了需要使用MVC给用户显示页面外，还有一类API接口，我们称之为REST，通常输入输出都是JSON，便于第三方调用或者使用页面JavaScript与之交互。\n直接在Controller中处理JSON是可以的，因为Spring MVC的@GetMapping和@PostMapping都支持指定输入和输出的格式。如果我们想接收JSON，输出JSON，那么可以这样写：\n1234567@PostMapping(value = &quot;/rest&quot;,             consumes = &quot;application/json;charset=UTF-8&quot;,             produces = &quot;application/json;charset=UTF-8&quot;)@ResponseBodypublic String rest(@RequestBody User user) &#123;    return &quot;&#123;\\&quot;restSupport\\&quot;:true&#125;&quot;;&#125;\n对应的Maven工程需要加入Jackson这个依赖：com.fasterxml.jackson.core:jackson-databind:2.14.0\n注意到@PostMapping使用consumes声明能接收的类型，使用produces声明输出的类型，并且额外加了@ResponseBody表示返回的String无需额外处理，直接作为输出内容写入HttpServletResponse。输入的JSON则根据注解@RequestBody直接被Spring反序列化为User这个JavaBean。\n使用curl命令测试一下：\n1234567891011121314$ curl -v -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;email&quot;:&quot;bob@example.com&quot;&#125;&#x27; http://localhost:8080/rest      &gt; POST /rest HTTP/1.1&gt; Host: localhost:8080&gt; User-Agent: curl/7.64.1&gt; Accept: */*&gt; Content-Type: application/json&gt; Content-Length: 27&gt; &lt; HTTP/1.1 200 &lt; Content-Type: application/json;charset=utf-8&lt; Content-Length: 20&lt; Date: Sun, 10 May 2020 09:56:01 GMT&lt; &#123;&quot;restSupport&quot;:true&#125;\n输出正是我们写入的字符串。\n直接用Spring的Controller配合一大堆注解写REST太麻烦了，因此，Spring还额外提供了一个@RestController注解，使用@RestController替代@Controller后，每个方法自动变成API接口方法。我们还是以实际代码举例，编写ApiController如下：\n12345678910111213141516171819202122232425262728293031@RestController@RequestMapping(&quot;/api&quot;)public class ApiController &#123;    @Autowired    UserService userService;    @GetMapping(&quot;/users&quot;)    public List&lt;User&gt; users() &#123;        return userService.getUsers();    &#125;    @GetMapping(&quot;/users/&#123;id&#125;&quot;)    public User user(@PathVariable(&quot;id&quot;) long id) &#123;        return userService.getUserById(id);    &#125;    @PostMapping(&quot;/signin&quot;)    public Map&lt;String, Object&gt; signin(@RequestBody SignInRequest signinRequest) &#123;        try &#123;            User user = userService.signin(signinRequest.email, signinRequest.password);            return Map.of(&quot;user&quot;, user);        &#125; catch (Exception e) &#123;            return Map.of(&quot;error&quot;, &quot;SIGNIN_FAILED&quot;, &quot;message&quot;, e.getMessage());        &#125;    &#125;    public static class SignInRequest &#123;        public String email;        public String password;    &#125;&#125;\n编写REST接口只需要定义@RestController，然后，每个方法都是一个API接口，输入和输出只要能被Jackson序列化或反序列化为JSON就没有问题。我们用浏览器测试GET请求，可直接显示JSON响应：\n\n要测试POST请求，可以用curl命令：\n1234567891011121314$ curl -v -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;email&quot;:&quot;bob@example.com&quot;,&quot;password&quot;:&quot;bob123&quot;&#125;&#x27; http://localhost:8080/api/signin&gt; POST /api/signin HTTP/1.1&gt; Host: localhost:8080&gt; User-Agent: curl/7.64.1&gt; Accept: */*&gt; Content-Type: application/json&gt; Content-Length: 47&gt; &lt; HTTP/1.1 200 &lt; Content-Type: application/json&lt; Transfer-Encoding: chunked&lt; Date: Sun, 10 May 2020 08:14:13 GMT&lt; &#123;&quot;user&quot;:&#123;&quot;id&quot;:1,&quot;email&quot;:&quot;bob@example.com&quot;,&quot;password&quot;:&quot;bob123&quot;,&quot;name&quot;:&quot;Bob&quot;,...\n注意观察上述JSON的输出，User能被正确地序列化为JSON，但暴露了password属性，这是我们不期望的。要避免输出password属性，可以把User复制到另一个UserBean对象，该对象只持有必要的属性，但这样做比较繁琐。另一种简单的方法是直接在User的password属性定义处加上@JsonIgnore表示完全忽略该属性：\n12345678910public class User &#123;    ...    @JsonIgnore    public String getPassword() &#123;        return password;    &#125;    ...&#125;\n但是这样一来，如果写一个register(User user)方法，那么该方法的User对象也拿不到注册时用户传入的密码了。如果要允许输入password，但不允许输出password，即在JSON序列化和反序列化时，允许写属性，禁用读属性，可以更精细地控制如下：\n12345678910public class User &#123;    ...    @JsonProperty(access = Access.WRITE_ONLY)    public String getPassword() &#123;        return password;    &#125;    ...&#125;\n同样的，可以使用@JsonProperty(access = Access.READ_ONLY)允许输出，不允许输入。\n练习\n使用REST实现API。\n下载练习\n小结\n使用@RestController可以方便地编写REST服务，Spring默认使用JSON作为输入和输出。\n要控制序列化和反序列化，可以使用Jackson提供的@JsonIgnore和@JsonProperty注解。\n在Spring MVC中，DispatcherServlet只需要固定配置到web.xml中，剩下的工作主要是专注于编写Controller。\n但是，在Servlet规范中，我们还可以使用Filter。如果要在Spring MVC中使用Filter，应该怎么做？\n有的童鞋在上一节的Web应用中可能发现了，如果注册时输入中文会导致乱码，因为Servlet默认按非UTF-8编码读取参数。为了修复这一问题，我们可以简单地使用一个EncodingFilter，在全局范围类给HttpServletRequest和HttpServletResponse强制设置为UTF-8编码。\n可以自己编写一个EncodingFilter，也可以直接使用Spring MVC自带的一个CharacterEncodingFilter。配置Filter时，只需在web.xml中声明即可：\n1234567891011121314151617181920&lt;web-app&gt;    &lt;filter&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;UTF-8&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;forceEncoding&lt;/param-name&gt;            &lt;param-value&gt;true&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    ...&lt;/web-app&gt;\n因为这种Filter和我们业务关系不大，注意到CharacterEncodingFilter其实和Spring的IoC容器没有任何关系，两者均互不知晓对方的存在，因此，配置这种Filter十分简单。\n我们再考虑这样一个问题：如果允许用户使用Basic模式进行用户验证，即在HTTP请求中添加头Authorization: Basic email:password，这个需求如何实现？\n编写一个AuthFilter是最简单的实现方式：\n1234567891011121314151617181920212223@Componentpublic class AuthFilter implements Filter &#123;    @Autowired    UserService userService;    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)            throws IOException, ServletException &#123;        HttpServletRequest req = (HttpServletRequest) request;        // 获取Authorization头:        String authHeader = req.getHeader(&quot;Authorization&quot;);        if (authHeader != null &amp;&amp; authHeader.startsWith(&quot;Basic &quot;)) &#123;            // 从Header中提取email和password:            String email = prefixFrom(authHeader);            String password = suffixFrom(authHeader);            // 登录:            User user = userService.signin(email, password);            // 放入Session:            req.getSession().setAttribute(UserController.KEY_USER, user);        &#125;        // 继续处理请求:        chain.doFilter(request, response);    &#125;&#125;\n现在问题来了：在Spring中创建的这个AuthFilter是一个普通Bean，Servlet容器并不知道，所以它不会起作用。\n如果我们直接在web.xml中声明这个AuthFilter，注意到AuthFilter的实例将由Servlet容器而不是Spring容器初始化，因此，@Autowire根本不生效，用于登录的UserService成员变量永远是null。\n所以，得通过一种方式，让Servlet容器实例化的Filter，间接引用Spring容器实例化的AuthFilter。Spring MVC提供了一个DelegatingFilterProxy，专门来干这个事情：\n123456789101112&lt;web-app&gt;    &lt;filter&gt;        &lt;filter-name&gt;authFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;authFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    ...&lt;/web-app&gt;\n我们来看实现原理：\n\nServlet容器从web.xml中读取配置，实例化DelegatingFilterProxy，注意命名是authFilter；\nSpring容器通过扫描@Component实例化AuthFilter。\n\n当DelegatingFilterProxy生效后，它会自动查找注册在ServletContext上的Spring容器，再试图从容器中查找名为authFilter的Bean，也就是我们用@Component声明的AuthFilter。\nDelegatingFilterProxy将请求代理给AuthFilter，核心代码如下：\n123456789public class DelegatingFilterProxy implements Filter &#123;    private Filter delegate;    public void doFilter(...) throws ... &#123;        if (delegate == null) &#123;            delegate = findBeanFromSpringContainer();        &#125;        delegate.doFilter(req, resp, chain);    &#125;&#125;\n这就是一个代理模式的简单应用。我们画个图表示它们之间的引用关系如下：\n12345678910┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐ ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─  ┌─────────────────────┐        ┌───────────┐   ││ │DelegatingFilterProxy│─│─│─ ─▶│AuthFilter │  └─────────────────────┘        └───────────┘   ││ ┌─────────────────────┐ │ │    ┌───────────┐  │  DispatcherServlet  │─ ─ ─ ─▶│Controllers│   ││ └─────────────────────┘ │ │    └───────────┘                                                 ││    Servlet Container    │ │  Spring Container ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘\n如果在web.xml中配置的Filter名字和Spring容器的Bean的名字不一致，那么需要指定Bean的名字：\n123456789&lt;filter&gt;    &lt;filter-name&gt;basicAuthFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;    &lt;!-- 指定Bean的名字 --&gt;    &lt;init-param&gt;        &lt;param-name&gt;targetBeanName&lt;/param-name&gt;        &lt;param-value&gt;authFilter&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;\n实际应用时，尽量保持名字一致，以减少不必要的配置。\n要使用Basic模式的用户认证，我们可以使用curl命令测试。例如，用户登录名是tom@example.com，口令是tomcat，那么先构造一个使用URL编码的用户名:口令的字符串：\n1tom%40example.com:tomcat\n对其进行Base64编码，最终构造出的Header如下：\n1Authorization: Basic dG9tJTQwZXhhbXBsZS5jb206dG9tY2F0\n使用如下的curl命令并获得响应如下：\n12345678910111213141516$ curl -v -H &#x27;Authorization: Basic dG9tJTQwZXhhbXBsZS5jb206dG9tY2F0&#x27; http://localhost:8080/profile&gt; GET /profile HTTP/1.1&gt; Host: localhost:8080&gt; User-Agent: curl/7.64.1&gt; Accept: */*&gt; Authorization: Basic dG9tJTQwZXhhbXBsZS5jb206dG9tY2F0&gt; &lt; HTTP/1.1 200 &lt; Set-Cookie: JSESSIONID=CE0F4BFC394816F717443397D4FEABBE; Path=/; HttpOnly&lt; Content-Type: text/html;charset=UTF-8&lt; Content-Language: en-CN&lt; Transfer-Encoding: chunked&lt; Date: Wed, 29 Apr 2020 00:15:50 GMT&lt; &lt;!doctype html&gt;...HTML输出...\n上述响应说明AuthFilter已生效。\n注意\nBasic认证模式并不安全，本节只用来作为使用Filter的示例。\n练习\n使用DelegatingFilterProxy实现AuthFilter。\n下载练习\n小结\n当一个Filter作为Spring容器管理的Bean存在时，可以通过DelegatingFilterProxy间接地引用它并使其生效。\n在Web程序中，注意到使用Filter的时候，Filter由Servlet容器管理，它在Spring MVC的Web应用程序中作用范围如下：\n123456789101112131415161718192021222324252627         │   ▲         ▼   │       ┌───────┐       │Filter1│       └───────┘         │   ▲         ▼   │       ┌───────┐┌ ─ ─ ─│Filter2│─ ─ ─ ─ ─ ─ ─ ─ ┐       └───────┘│        │   ▲                  │         ▼   ││ ┌─────────────────┐           │  │DispatcherServlet│◀───┐│ └─────────────────┘    │      │   │              ┌────────────┐│  │              │ModelAndView││   │              └────────────┘│  │                     ▲      │   │    ┌───────────┐    ││  ├───▶│Controller1│────┤      │   │    └───────────┘    ││  │                     │      │   │    ┌───────────┐    ││  └───▶│Controller2│────┘      │        └───────────┘└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘\n上图虚线框就是Filter2的拦截范围，Filter组件实际上并不知道后续内部处理是通过Spring MVC提供的DispatcherServlet还是其他Servlet组件，因为Filter是Servlet规范定义的标准组件，它可以应用在任何基于Servlet的程序中。\n如果只基于Spring MVC开发应用程序，还可以使用Spring MVC提供的一种功能类似Filter的拦截器：Interceptor。和Filter相比，Interceptor拦截范围不是后续整个处理流程，而是仅针对Controller拦截：\n12345678910111213141516171819202122232425262728293031323334       │   ▲       ▼   │     ┌───────┐     │Filter1│     └───────┘       │   ▲       ▼   │     ┌───────┐     │Filter2│     └───────┘       │   ▲       ▼   │┌─────────────────┐│DispatcherServlet│◀───┐└─────────────────┘    │ │ ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┼ ─ ─ ─ ┐ │                     │ │ │            ┌────────────┐ │ │              │   Render   │ │ │            └────────────┘ │ │                     ▲ │ │                   │       │ │              ┌────────────┐ │ │            │ModelAndView│ │ │              └────────────┘ │ │                   ▲       │ │    ┌───────────┐    │ ├─┼─▶│Controller1│────┤       │ │    └───────────┘    │ │ │                   │       │ │    ┌───────────┐    │ └─┼─▶│Controller2│────┘       │      └───────────┘   └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘\n上图虚线框就是Interceptor的拦截范围，注意到Controller的处理方法一般都类似这样：\n1234567@Controllerpublic class Controller1 &#123;    @GetMapping(&quot;/path/to/hello&quot;)    ModelAndView hello() &#123;        ...    &#125;&#125;\n所以，Interceptor的拦截范围其实就是Controller方法，它实际上就相当于基于AOP的方法拦截。因为Interceptor只拦截Controller方法，所以要注意，返回ModelAndView并渲染后，后续处理就脱离了Interceptor的拦截范围。\n使用Interceptor的好处是Interceptor本身是Spring管理的Bean，因此注入任意Bean都非常简单。此外，可以应用多个Interceptor，并通过简单的@Order指定顺序。我们先写一个LoggerInterceptor：\n12345678910111213141516171819202122232425262728293031@Order(1)@Componentpublic class LoggerInterceptor implements HandlerInterceptor &#123;    final Logger logger = LoggerFactory.getLogger(getClass());    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        logger.info(&quot;preHandle &#123;&#125;...&quot;, request.getRequestURI());        if (request.getParameter(&quot;debug&quot;) != null) &#123;            PrintWriter pw = response.getWriter();            pw.write(&quot;&lt;p&gt;DEBUG MODE&lt;/p&gt;&quot;);            pw.flush();            return false;        &#125;        return true;    &#125;    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        logger.info(&quot;postHandle &#123;&#125;.&quot;, request.getRequestURI());        if (modelAndView != null) &#123;            modelAndView.addObject(&quot;__time__&quot;, LocalDateTime.now());        &#125;    &#125;    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        logger.info(&quot;afterCompletion &#123;&#125;: exception = &#123;&#125;&quot;, request.getRequestURI(), ex);    &#125;&#125;\n一个Interceptor必须实现HandlerInterceptor接口，可以选择实现preHandle()、postHandle()和afterCompletion()方法。preHandle()是Controller方法调用前执行，postHandle()是Controller方法正常返回后执行，而afterCompletion()无论Controller方法是否抛异常都会执行，参数ex就是Controller方法抛出的异常（未抛出异常是null）。\n在preHandle()中，也可以直接处理响应，然后返回false表示无需调用Controller方法继续处理了，通常在认证或者安全检查失败时直接返回错误响应。在postHandle()中，因为捕获了Controller方法返回的ModelAndView，所以可以继续往ModelAndView里添加一些通用数据，很多页面需要的全局数据如Copyright信息等都可以放到这里，无需在每个Controller方法中重复添加。\n我们再继续添加一个AuthInterceptor，用于替代上一节使用AuthFilter进行Basic认证的功能：\n12345678910111213141516171819202122232425262728293031323334353637@Order(2)@Componentpublic class AuthInterceptor implements HandlerInterceptor &#123;    final Logger logger = LoggerFactory.getLogger(getClass());    @Autowired    UserService userService;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)            throws Exception &#123;        logger.info(&quot;pre authenticate &#123;&#125;...&quot;, request.getRequestURI());        try &#123;            authenticateByHeader(request);        &#125; catch (RuntimeException e) &#123;            logger.warn(&quot;login by authorization header failed.&quot;, e);        &#125;        return true;    &#125;    private void authenticateByHeader(HttpServletRequest req) &#123;        String authHeader = req.getHeader(&quot;Authorization&quot;);        if (authHeader != null &amp;&amp; authHeader.startsWith(&quot;Basic &quot;)) &#123;            logger.info(&quot;try authenticate by authorization header...&quot;);            String up = new String(Base64.getDecoder().decode(authHeader.substring(6)), StandardCharsets.UTF_8);            int pos = up.indexOf(&#x27;:&#x27;);            if (pos &gt; 0) &#123;                String email = URLDecoder.decode(up.substring(0, pos), StandardCharsets.UTF_8);                String password = URLDecoder.decode(up.substring(pos + 1), StandardCharsets.UTF_8);                User user = userService.signin(email, password);                req.getSession().setAttribute(UserController.KEY_USER, user);                logger.info(&quot;user &#123;&#125; login by authorization header ok.&quot;, email);            &#125;        &#125;    &#125;&#125;\n这个AuthInterceptor是由Spring容器直接管理的，因此注入UserService非常方便。\n最后，要让拦截器生效，我们在WebMvcConfigurer中注册所有的Interceptor：\n1234567891011@BeanWebMvcConfigurer createWebMvcConfigurer(@Autowired HandlerInterceptor[] interceptors) &#123;    return new WebMvcConfigurer() &#123;        public void addInterceptors(InterceptorRegistry registry) &#123;            for (var interceptor : interceptors) &#123;                registry.addInterceptor(interceptor);            &#125;        &#125;        ...    &#125;;&#125;\n注意\n如果拦截器没有生效，请检查是否忘了在WebMvcConfigurer中注册。\n处理异常\n在Controller中，Spring MVC还允许定义基于@ExceptionHandler注解的异常处理方法。我们来看具体的示例代码：\n12345678@Controllerpublic class UserController &#123;    @ExceptionHandler(RuntimeException.class)    public ModelAndView handleUnknowException(Exception ex) &#123;        return new ModelAndView(&quot;500.html&quot;, Map.of(&quot;error&quot;, ex.getClass().getSimpleName(), &quot;message&quot;, ex.getMessage()));    &#125;    ...&#125;\n异常处理方法没有固定的方法签名，可以传入Exception、HttpServletRequest等，返回值可以是void，也可以是ModelAndView，上述代码通过@ExceptionHandler(RuntimeException.class)表示当发生RuntimeException的时候，就自动调用此方法处理。\n注意到我们返回了一个新的ModelAndView，这样在应用程序内部如果发生了预料之外的异常，可以给用户显示一个出错页面，而不是简单的500 Internal Server Error或404 Not Found。例如B站的错误页：\n\n可以编写多个错误处理方法，每个方法针对特定的异常。例如，处理LoginException使得页面可以自动跳转到登录页。\n使用ExceptionHandler时，要注意它仅作用于当前的Controller，即ControllerA中定义的一个ExceptionHandler方法对ControllerB不起作用。如果我们有很多Controller，每个Controller都需要处理一些通用的异常，例如LoginException，思考一下应该怎么避免重复代码？\n练习\n使用Interceptor。\n下载练习\n小结\nSpring MVC提供了Interceptor组件来拦截Controller方法，使用时要注意Interceptor的作用范围。\n在开发REST应用时，很多时候，是通过页面的JavaScript和后端的REST API交互。\n在JavaScript与REST交互的时候，有很多安全限制。默认情况下，浏览器按同源策略放行JavaScript调用API，即：\n\n如果A站在域名a.com页面的JavaScript调用A站自己的API时，没有问题；\n如果A站在域名a.com页面的JavaScript调用B站b.com的API时，将被浏览器拒绝访问，因为不满足同源策略。\n\n同源要求域名要完全相同（a.com和www.a.com不同），协议要相同（http和https不同），端口要相同 。\n那么，在域名a.com页面的JavaScript要调用B站b.com的API时，还有没有办法？\n办法是有的，那就是CORS，全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。如果A站的JavaScript访问B站API的时候，B站能够返回响应头Access-Control-Allow-Origin: http://a.com，那么，浏览器就允许A站的JavaScript访问B站的API。\n注意到跨域访问能否成功，取决于B站是否愿意给A站返回一个正确的Access-Control-Allow-Origin响应头，所以决定权永远在提供API的服务方手中。\n关于CORS的详细信息可以参考MDN文档，这里不再详述。\n使用Spring的@RestController开发REST应用时，同样会面对跨域问题。如果我们允许指定的网站通过页面JavaScript访问这些REST API，就必须正确地设置CORS。\n有好几种方法设置CORS，我们来一一介绍。\n使用@CrossOrigin\n第一种方法是使用@CrossOrigin注解，可以在@RestController的class级别或方法级别定义一个@CrossOrigin，例如：\n123456@CrossOrigin(origins = &quot;http://local.liaoxuefeng.com:8080&quot;)@RestController@RequestMapping(&quot;/api&quot;)public class ApiController &#123;    ...&#125;\n上述定义在ApiController处的@CrossOrigin指定了只允许来自local.liaoxuefeng.com跨域访问，允许多个域访问需要写成数组形式，例如origins = &#123;&quot;http://a.com&quot;, &quot;https://www.b.com&quot;&#125;)。如果要允许任何域访问，写成origins = &quot;*&quot;即可。\n如果有多个REST Controller都需要使用CORS，那么，每个Controller都必须标注@CrossOrigin注解。\n使用CorsRegistry\n第二种方法是在WebMvcConfigurer中定义一个全局CORS配置，下面是一个示例：\n1234567891011121314@BeanWebMvcConfigurer createWebMvcConfigurer() &#123;    return new WebMvcConfigurer() &#123;        @Override        public void addCorsMappings(CorsRegistry registry) &#123;            registry.addMapping(&quot;/api/**&quot;)                    .allowedOrigins(&quot;http://local.liaoxuefeng.com:8080&quot;)                    .allowedMethods(&quot;GET&quot;, &quot;POST&quot;)                    .maxAge(3600);            // 可以继续添加其他URL规则:            // registry.addMapping(&quot;/rest/v2/**&quot;)...        &#125;    &#125;;&#125;\n这种方式可以创建一个全局CORS配置，如果仔细地设计URL结构，那么可以一目了然地看到各个URL的CORS规则，推荐使用这种方式配置CORS。\n使用CorsFilter\n第三种方法是使用Spring提供的CorsFilter，我们在集成Filter中详细介绍了将Spring容器内置的Bean暴露为Servlet容器的Filter的方法，由于这种配置方式需要修改web.xml，也比较繁琐，所以推荐使用第二种方式。\n测试\n当我们配置好CORS后，可以在浏览器中测试一下规则是否生效。\n我们先用http://localhost:8080在Chrome浏览器中打开首页，然后打开Chrome的开发者工具，切换到Console，输入一个JavaScript语句来跨域访问API：\n1$.getJSON(&quot;http://local.liaoxuefeng.com:8080/api/users&quot;, (data) =&gt; console.log(JSON.stringify(data)));\n上述源站的域是http://localhost:8080，跨域访问的是http://local.liaoxuefeng.com:8080，因为配置的CORS不允许localhost访问，所以不出意外地得到一个错误：\n\n浏览题打印了错误原因就是been blocked by CORS policy。\n我们再用http://local.liaoxuefeng.com:8080在Chrome浏览器中打开首页，在Console中执行JavaScript访问localhost：\n1$.getJSON(&quot;http://localhost:8080/api/users&quot;, (data) =&gt; console.log(JSON.stringify(data)));\n因为CORS规则允许来自http://local.liaoxuefeng.com:8080的访问，因此访问成功，打印出API的返回值：\n\n练习\n使用CORS控制跨域。\n下载练习\n小结\nCORS可以控制指定域的页面JavaScript能否访问API。\n在开发应用程序的时候，经常会遇到支持多语言的需求，这种支持多语言的功能称之为国际化，英文是internationalization，缩写为i18n（因为首字母i和末字母n中间有18个字母）。\n还有针对特定地区的本地化功能，英文是localization，缩写为L10n，本地化是指根据地区调整类似姓名、日期的显示等。\n也有把上面两者合称为全球化，英文是globalization，缩写为g11n。\n在Java中，支持多语言和本地化是通过MessageFormat配合Locale实现的：\n123456789101112131415// MessageFormatimport java.text.MessageFormat;import java.util.Locale;public class Time &#123;    public static void main(String[] args) &#123;        double price = 123.5;        int number = 10;        Object[] arguments = &#123; price, number &#125;;        MessageFormat mfUS = new MessageFormat(&quot;Pay &#123;0,number,currency&#125; for &#123;1&#125; books.&quot;, Locale.US);        System.out.println(mfUS.format(arguments));        MessageFormat mfZH = new MessageFormat(&quot;&#123;1&#125;本书一共&#123;0,number,currency&#125;。&quot;, Locale.CHINA);        System.out.println(mfZH.format(arguments));    &#125;&#125;\n对于Web应用程序，要实现国际化功能，主要是渲染View的时候，要把各种语言的资源文件提出来，这样，不同的用户访问同一个页面时，显示的语言就是不同的。\n我们来看看在Spring MVC应用程序中如何实现国际化。\n获取Locale\n实现国际化的第一步是获取到用户的Locale。在Web应用程序中，HTTP规范规定了浏览器会在请求中携带Accept-Language头，用来指示用户浏览器设定的语言顺序，如：\n1Accept-Language: zh-CN,zh;q=0.8,en;q=0.2\n上述HTTP请求头表示优先选择简体中文，其次选择中文，最后选择英文。q表示权重，解析后我们可获得一个根据优先级排序的语言列表，把它转换为Java的Locale，即获得了用户的Locale。大多数框架通常只返回权重最高的Locale。\nSpring MVC通过LocaleResolver来自动从HttpServletRequest中获取Locale。有多种LocaleResolver的实现类，其中最常用的是CookieLocaleResolver：\n12345678@Primary@BeanLocaleResolver createLocaleResolver() &#123;    var clr = new CookieLocaleResolver();    clr.setDefaultLocale(Locale.ENGLISH);    clr.setDefaultTimeZone(TimeZone.getDefault());    return clr;&#125;\nCookieLocaleResolver从HttpServletRequest中获取Locale时，首先根据一个特定的Cookie判断是否指定了Locale，如果没有，就从HTTP头获取，如果还没有，就返回默认的Locale。\n当用户第一次访问网站时，CookieLocaleResolver只能从HTTP头获取Locale，即使用浏览器的默认语言。通常网站也允许用户自己选择语言，此时，CookieLocaleResolver就会把用户选择的语言存放到Cookie中，下一次访问时，就会返回用户上次选择的语言而不是浏览器默认语言。\n提取资源文件\n第二步是把写死在模板中的字符串以资源文件的方式存储在外部。对于多语言，主文件名如果命名为messages，那么资源文件必须按如下方式命名并放入classpath中：\n\n默认语言，文件名必须为messages.properties；\n简体中文，Locale是zh_CN，文件名必须为messages_zh_CN.properties；\n日文，Locale是ja_JP，文件名必须为messages_ja_JP.properties；\n其它更多语言……\n\n每个资源文件都有相同的key，例如，默认语言是英文，文件messages.properties内容如下：\n1234language.select=Languagehome=Homesignin=Sign Incopyright=Copyright©&#123;0,number,#&#125;\n文件messages_zh_CN.properties内容如下：\n1234language.select=语言home=首页signin=登录copyright=版权所有©&#123;0,number,#&#125;\n创建MessageSource\n第三步是创建一个Spring提供的MessageSource实例，它自动读取所有的.properties文件，并提供一个统一接口来实现“翻译”：\n12// code, arguments, locale:String text = messageSource.getMessage(&quot;signin&quot;, null, locale);\n其中，signin是我们在.properties文件中定义的key，第二个参数是Object[]数组作为格式化时传入的参数，最后一个参数就是获取的用户Locale实例。\n创建MessageSource如下：\n123456789@Bean(&quot;i18n&quot;)MessageSource createMessageSource() &#123;    var messageSource = new ResourceBundleMessageSource();    // 指定文件是UTF-8编码:    messageSource.setDefaultEncoding(&quot;UTF-8&quot;);    // 指定主文件名:    messageSource.setBasename(&quot;messages&quot;);    return messageSource;&#125;\n注意到ResourceBundleMessageSource会自动根据主文件名自动把所有相关语言的资源文件都读进来。\n再注意到Spring容器会创建不只一个MessageSource实例，我们自己创建的这个MessageSource是专门给页面国际化使用的，因此命名为i18n，不会与其它MessageSource实例冲突。\n实现多语言\n要在View中使用MessageSource加上Locale输出多语言，我们通过编写一个MvcInterceptor，把相关资源注入到ModelAndView中：\n1234567891011121314151617181920212223@Componentpublic class MvcInterceptor implements HandlerInterceptor &#123;    @Autowired    LocaleResolver localeResolver;    // 注意注入的MessageSource名称是i18n:    @Autowired    @Qualifier(&quot;i18n&quot;)    MessageSource messageSource;    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        if (modelAndView != null // 返回了ModelAndView            &amp;&amp; modelAndView.getViewName() != null // 设置了View            &amp;&amp; !modelAndView.getViewName().startsWith(&quot;redirect:&quot;) // 不是重定向        ) &#123;            // 解析用户的Locale:            Locale locale = localeResolver.resolveLocale(request);            // 放入Model:            modelAndView.addObject(&quot;__messageSource__&quot;, messageSource);            modelAndView.addObject(&quot;__locale__&quot;, locale);        &#125;    &#125;&#125;\n不要忘了在WebMvcConfigurer中注册MvcInterceptor。现在，就可以在View中调用MessageSource.getMessage()方法来实现多语言：\n1&lt;a href=&quot;/signin&quot;&gt;&#123;&#123; __messageSource__.getMessage(&#x27;signin&#x27;, null, __locale__) &#125;&#125;&lt;/a&gt;\n上述这种写法虽然可行，但格式太复杂了。使用View时，要根据每个特定的View引擎定制国际化函数。在Pebble中，我们可以封装一个国际化函数，名称就是下划线_，改造一下创建ViewResolver的代码：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344@BeanViewResolver createViewResolver(@Autowired ServletContext servletContext, @Autowired @Qualifier(&quot;i18n&quot;) MessageSource messageSource) &#123;    var engine = new PebbleEngine.Builder()            .autoEscaping(true)            .cacheActive(false)            .loader(new Servlet5Loader(servletContext))            // 添加扩展:            .extension(createExtension(messageSource))            .build();    var viewResolver = new PebbleViewResolver();    viewResolver.setPrefix(&quot;/WEB-INF/templates/&quot;);    viewResolver.setSuffix(&quot;&quot;);    viewResolver.setPebbleEngine(engine);    return viewResolver;&#125;private Extension createExtension(MessageSource messageSource) &#123;    return new AbstractExtension() &#123;        @Override        public Map&lt;String, Function&gt; getFunctions() &#123;            return Map.of(&quot;_&quot;, new Function() &#123;                public Object execute(Map&lt;String, Object&gt; args, PebbleTemplate self, EvaluationContext context, int lineNumber) &#123;                    String key = (String) args.get(&quot;0&quot;);                    List&lt;Object&gt; arguments = this.extractArguments(args);                    Locale locale = (Locale) context.getVariable(&quot;__locale__&quot;);                    return messageSource.getMessage(key, arguments.toArray(), &quot;???&quot; + key + &quot;???&quot;, locale);                &#125;                private List&lt;Object&gt; extractArguments(Map&lt;String, Object&gt; args) &#123;                    int i = 1;                    List&lt;Object&gt; arguments = new ArrayList&lt;&gt;();                    while (args.containsKey(String.valueOf(i))) &#123;                        Object param = args.get(String.valueOf(i));                        arguments.add(param);                        i++;                    &#125;                    return arguments;                &#125;                public List&lt;String&gt; getArgumentNames() &#123;                    return null;                &#125;            &#125;);        &#125;    &#125;;&#125;\n这样，我们可以把多语言页面改写为：\n1&lt;a href=&quot;/signin&quot;&gt;&#123;&#123; _(&#x27;signin&#x27;) &#125;&#125;&lt;/a&gt;\n如果是带参数的多语言，需要把参数传进去：\n1&lt;h5&gt;&#123;&#123; _(&#x27;copyright&#x27;, 2020) &#125;&#125;&lt;/h5&gt;\n使用其它View引擎时，也应当根据引擎接口实现更方便的语法。\n切换Locale\n最后，我们需要允许用户手动切换Locale，编写一个LocaleController来实现该功能：\n123456789101112131415161718192021222324252627@Controllerpublic class LocaleController &#123;    final Logger logger = LoggerFactory.getLogger(getClass());    @Autowired    LocaleResolver localeResolver;    @GetMapping(&quot;/locale/&#123;lo&#125;&quot;)    public String setLocale(@PathVariable(&quot;lo&quot;) String lo, HttpServletRequest request, HttpServletResponse response) &#123;        // 根据传入的lo创建Locale实例:        Locale locale = null;        int pos = lo.indexOf(&#x27;_&#x27;);        if (pos &gt; 0) &#123;            String lang = lo.substring(0, pos);            String country = lo.substring(pos + 1);            locale = new Locale(lang, country);        &#125; else &#123;            locale = new Locale(lo);        &#125;        // 设定此Locale:        localeResolver.setLocale(request, response, locale);        logger.info(&quot;locale is set to &#123;&#125;.&quot;, locale);        // 刷新页面:        String referer = request.getHeader(&quot;Referer&quot;);        return &quot;redirect:&quot; + (referer == null ? &quot;/&quot; : referer);    &#125;&#125;\n在页面设计中，通常在右上角给用户提供一个语言选择列表，来看看效果：\n\n切换到中文：\n\n练习\n在Spring MVC程序中实现国际化。\n下载练习\n小结\n多语言支持需要从HTTP请求中解析用户的Locale，然后针对不同Locale显示不同的语言；\nSpring MVC应用程序通过MessageSource和LocaleResolver，配合View实现国际化。\n在Servlet模型中，每个请求都是由某个线程处理，然后，将响应写入IO流，发送给客户端。从开始处理请求，到写入响应完成，都是在同一个线程中处理的。\n实现Servlet容器的时候，只要每处理一个请求，就创建一个新线程处理它，就能保证正确实现了Servlet线程模型。在实际产品中，例如Tomcat，总是通过线程池来处理请求，它仍然符合一个请求从头到尾都由某一个线程处理。\n这种线程模型非常重要，因为Spring的JDBC事务是基于ThreadLocal实现的，如果在处理过程中，一会由线程A处理，一会又由线程B处理，那事务就全乱套了。此外，很多安全认证，也是基于ThreadLocal实现的，可以保证在处理请求的过程中，各个线程互不影响。\n但是，如果一个请求处理的时间较长，例如几秒钟甚至更长，那么，这种基于线程池的同步模型很快就会把所有线程耗尽，导致服务器无法响应新的请求。如果把长时间处理的请求改为异步处理，那么线程池的利用率就会大大提高。Servlet从3.0规范开始添加了异步支持，允许对一个请求进行异步处理。\n我们先来看看在Spring MVC中如何实现对请求进行异步处理的逻辑。首先建立一个Web工程，然后编辑web.xml文件如下：\n1234567891011121314151617181920212223&lt;web-app&gt;    &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextClass&lt;/param-name&gt;            &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;com.itranswarp.learnjava.AppConfig&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;        &lt;async-supported&gt;true&lt;/async-supported&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n和前面普通的MVC程序相比，这个web.xml主要对DispatcherServlet的配置多了一个&lt;async-supported&gt;，默认值是false，必须明确写成true，这样Servlet容器才会支持async处理。\n下一步就是在Controller中编写async处理逻辑。我们以ApiController为例，演示如何异步处理请求。\n第一种async处理方式是返回一个Callable，Spring MVC自动把返回的Callable放入线程池执行，等待结果返回后再写入响应：\n1234567891011@GetMapping(&quot;/users&quot;)public Callable&lt;List&lt;User&gt;&gt; users() &#123;    return () -&gt; &#123;        // 模拟3秒耗时:        try &#123;            Thread.sleep(3000);        &#125; catch (InterruptedException e) &#123;        &#125;        return userService.getUsers();    &#125;;&#125;\n第二种async处理方式是返回一个DeferredResult对象，然后在另一个线程中，设置此对象的值并写入响应：\n1234567891011121314151617181920@GetMapping(&quot;/users/&#123;id&#125;&quot;)public DeferredResult&lt;User&gt; user(@PathVariable(&quot;id&quot;) long id) &#123;    DeferredResult&lt;User&gt; result = new DeferredResult&lt;&gt;(3000L); // 3秒超时    new Thread(() -&gt; &#123;        // 等待1秒:        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;        &#125;        try &#123;            User user = userService.getUserById(id);            // 设置正常结果并由Spring MVC写入Response:            result.setResult(user);        &#125; catch (Exception e) &#123;            // 设置错误结果并由Spring MVC写入Response:            result.setErrorResult(Map.of(&quot;error&quot;, e.getClass().getSimpleName(), &quot;message&quot;, e.getMessage()));        &#125;    &#125;).start();    return result;&#125;\n使用DeferredResult时，可以设置超时，超时会自动返回超时错误响应。在另一个线程中，可以调用setResult()写入结果，也可以调用setErrorResult()写入一个错误结果。\n运行程序，当我们访问http://localhost:8080/api/users/1时，假定用户存在，则浏览器在1秒后返回结果：\n\n访问一个不存在的User ID，则等待1秒后返回错误结果：\n\n使用Filter\n当我们使用async模式处理请求时，原有的Filter也可以工作，但我们必须在web.xml中添加&lt;async-supported&gt;并设置为true。我们用两个Filter：SyncFilter和AsyncFilter分别测试：\n123456789101112131415161718192021222324&lt;web-app ...&gt;    ...    &lt;filter&gt;        &lt;filter-name&gt;sync-filter&lt;/filter-name&gt;        &lt;filter-class&gt;com.itranswarp.learnjava.web.SyncFilter&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter&gt;        &lt;filter-name&gt;async-filter&lt;/filter-name&gt;        &lt;filter-class&gt;com.itranswarp.learnjava.web.AsyncFilter&lt;/filter-class&gt;        &lt;async-supported&gt;true&lt;/async-supported&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;sync-filter&lt;/filter-name&gt;        &lt;url-pattern&gt;/api/version&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;async-filter&lt;/filter-name&gt;        &lt;url-pattern&gt;/api/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    ...&lt;/web-app&gt;\n一个声明为支持&lt;async-supported&gt;的Filter既可以过滤async处理请求，也可以过滤正常的同步处理请求，而未声明&lt;async-supported&gt;的Filter无法支持async请求，如果一个普通的Filter遇到async请求时，会直接报错，因此，务必注意普通Filter的&lt;url-pattern&gt;不要匹配async请求路径。\n在logback.xml配置文件中，我们把输出格式加上[%thread]，可以输出当前线程的名称：\n123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt;    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;            &lt;Pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/Pattern&gt;        &lt;/layout&gt;    &lt;/appender&gt;    ...&lt;/configuration&gt;\n对于同步请求，例如/api/version，我们可以看到如下输出：\n123452020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.SyncFilter - start SyncFilter...2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.AsyncFilter - start AsyncFilter...2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.ApiController - get version...2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.AsyncFilter - end AsyncFilter.2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.SyncFilter - end SyncFilter.\n可见，每个Filter和ApiController都是由同一个线程执行。\n对于异步请求，例如/api/users，我们可以看到如下输出：\n12342020-05-16 11:23:49 [http-nio-8080-exec-4] INFO  c.i.learnjava.web.AsyncFilter - start AsyncFilter...2020-05-16 11:23:49 [http-nio-8080-exec-4] INFO  c.i.learnjava.web.ApiController - get users...2020-05-16 11:23:49 [http-nio-8080-exec-4] INFO  c.i.learnjava.web.AsyncFilter - end AsyncFilter.2020-05-16 11:23:52 [MvcAsync1] INFO  c.i.learnjava.web.ApiController - return users...\n可见，AsyncFilter和ApiController是由同一个线程执行的，但是，返回响应的是另一个线程。\n对DeferredResult测试，可以看到如下输出：\n1232020-05-16 11:25:24 [http-nio-8080-exec-8] INFO  c.i.learnjava.web.AsyncFilter - start AsyncFilter...2020-05-16 11:25:24 [http-nio-8080-exec-8] INFO  c.i.learnjava.web.AsyncFilter - end AsyncFilter.2020-05-16 11:25:25 [Thread-2] INFO  c.i.learnjava.web.ApiController - deferred result is set.\n同样，返回响应的是另一个线程。\n在实际使用时，经常用到的就是DeferredResult，因为返回DeferredResult时，可以设置超时、正常结果和错误结果，易于编写比较灵活的逻辑。\n使用async异步处理响应时，要时刻牢记，在另一个异步线程中的事务和Controller方法中执行的事务不是同一个事务，在Controller中绑定的ThreadLocal信息也无法在异步线程中获取。\n此外，Servlet 3.0规范添加的异步支持是针对同步模型打了一个“补丁”，虽然可以异步处理请求，但高并发异步请求时，它的处理效率并不高，因为这种异步模型并没有用到真正的“原生”异步。Java标准库提供了封装操作系统的异步IO包java.nio，是真正的多路复用IO模型，可以用少量线程支持大量并发。使用NIO编程复杂度比同步IO高很多，因此我们很少直接使用NIO。相反，大部分需要高性能异步IO的应用程序会选择Netty这样的框架，它基于NIO提供了更易于使用的API，方便开发异步应用程序。\n练习\n使用Spring MVC实现异步处理请求。\n下载练习\n小结\n在Spring MVC中异步处理请求需要正确配置web.xml，并返回Callable或DeferredResult对象。\nWebSocket是一种基于HTTP的长链接技术。传统的HTTP协议是一种请求-响应模型，如果浏览器不发送请求，那么服务器无法主动给浏览器推送数据。如果需要定期给浏览器推送数据，例如股票行情，或者不定期给浏览器推送数据，例如在线聊天，基于HTTP协议实现这类需求，只能依靠浏览器的JavaScript定时轮询，效率很低且实时性不高。\n因为HTTP本身是基于TCP连接的，所以，WebSocket在HTTP协议的基础上做了一个简单的升级，即建立TCP连接后，浏览器发送请求时，附带几个头：\n1234GET /chat HTTP/1.1Host: www.example.comUpgrade: websocketConnection: Upgrade\n就表示客户端希望升级连接，变成长连接的WebSocket，服务器返回升级成功的响应：\n123HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: Upgrade\n收到成功响应后表示WebSocket“握手”成功，这样，代表WebSocket的这个TCP连接将不会被服务器关闭，而是一直保持，服务器可随时向浏览器推送消息，浏览器也可随时向服务器推送消息。双方推送的消息既可以是文本消息，也可以是二进制消息，一般来说，绝大部分应用程序会推送基于JSON的文本消息。\n现代浏览器都已经支持WebSocket协议，服务器则需要底层框架支持。Java的Servlet规范从3.1开始支持WebSocket，所以，必须选择支持Servlet 3.1或更高规范的Servlet容器，才能支持WebSocket。最新版本的Tomcat、Jetty等开源服务器均支持WebSocket。\n我们以实际代码演示如何在Spring MVC中实现对WebSocket的支持。首先，我们需要在pom.xml中加入以下依赖：\n\norg.apache.tomcat.embed:tomcat-embed-websocket:10.1.1\norg.springframework:spring-websocket:6.0.0\n\n第一项是嵌入式Tomcat支持WebSocket的组件，第二项是Spring封装的支持WebSocket的接口。\n接下来，我们需要在AppConfig中加入Spring Web对WebSocket的配置，先增加一个@EnableWebSocket注解，然后创建一个WebSocketConfigurer实例：\n12345678910111213141516171819@Configuration@ComponentScan@EnableWebMvc@EnableWebSocket // 启用WebSocket支持public class AppConfig &#123;    @Bean    WebSocketConfigurer createWebSocketConfigurer(            @Autowired ChatHandler chatHandler,            @Autowired ChatHandshakeInterceptor chatInterceptor)    &#123;        return new WebSocketConfigurer() &#123;            public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123;                // 把URL与指定的WebSocketHandler关联，可关联多个:                registry.addHandler(chatHandler, &quot;/chat&quot;).addInterceptors(chatInterceptor);            &#125;        &#125;;    &#125;    ...&#125;\n此实例在内部通过WebSocketHandlerRegistry注册能处理WebSocket的WebSocketHandler，以及可选的WebSocket拦截器HandshakeInterceptor。我们注入的这两个类都是自己编写的业务逻辑，后面我们详细讨论如何编写它们，这里只需关注浏览器连接到WebSocket的URL是/chat。\n处理WebSocket连接\n和处理普通HTTP请求不同，没法用一个方法处理一个URL。Spring提供了TextWebSocketHandler和BinaryWebSocketHandler分别处理文本消息和二进制消息，这里我们选择文本消息作为聊天室的协议，因此，ChatHandler需要继承自TextWebSocketHandler：\n1234@Componentpublic class ChatHandler extends TextWebSocketHandler &#123;    ...&#125;\n当浏览器请求一个WebSocket连接后，如果成功建立连接，Spring会自动调用afterConnectionEstablished()方法，任何原因导致WebSocket连接中断时，Spring会自动调用afterConnectionClosed方法，因此，覆写这两个方法即可处理连接成功和结束后的业务逻辑：\n1234567891011121314151617@Componentpublic class ChatHandler extends TextWebSocketHandler &#123;    // 保存所有Client的WebSocket会话实例:    private Map&lt;String, WebSocketSession&gt; clients = new ConcurrentHashMap&lt;&gt;();    @Override    public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123;        // 新会话根据ID放入Map:        clients.put(session.getId(), session);        session.getAttributes().put(&quot;name&quot;, &quot;Guest1&quot;);    &#125;    @Override    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception &#123;        clients.remove(session.getId());    &#125;&#125;\n每个WebSocket会话以WebSocketSession表示，且已分配唯一ID。和WebSocket相关的数据，例如用户名称等，均可放入关联的getAttributes()中。\n用实例变量clients持有当前所有的WebSocketSession是为了广播，即向所有用户推送同一消息时，可以这么写：\n123456String json = ...TextMessage message = new TextMessage(json);for (String id : clients.keySet()) &#123;    WebSocketSession session = clients.get(id);    session.sendMessage(message);&#125;\n我们发送的消息是序列化后的JSON，可以用ChatMessage表示：\n12345public class ChatMessage &#123;\tpublic long timestamp;\tpublic String name;    public String text;&#125;\n每收到一个用户的消息后，我们就需要广播给所有用户：\n12345678910@Componentpublic class ChatHandler extends TextWebSocketHandler &#123;    ...    @Override    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception &#123;        String s = message.getPayload();        String r = ... // 根据输入消息构造待发送消息        broadcastMessage(r); // 推送给所有用户    &#125;&#125;\n如果要推送给指定的几个用户，那就需要在clients中根据条件查找出某些WebSocketSession，然后发送消息。\n注意到我们在注册WebSocket时还传入了一个ChatHandshakeInterceptor，这个类实际上可以从HttpSessionHandshakeInterceptor继承，它的主要作用是在WebSocket建立连接后，把HttpSession的一些属性复制到WebSocketSession，例如，用户的登录信息等：\n1234567@Componentpublic class ChatHandshakeInterceptor extends HttpSessionHandshakeInterceptor &#123;    public ChatHandshakeInterceptor() &#123;        // 指定从HttpSession复制属性到WebSocketSession:        super(List.of(UserController.KEY_USER));    &#125;&#125;\n这样，在ChatHandler中，可以从WebSocketSession.getAttributes()中获取到复制过来的属性。\n客户端开发\n在完成了服务器端的开发后，我们还需要在页面编写一点JavaScript逻辑：\n123456789101112131415161718// 创建WebSocket连接:var ws = new WebSocket(&#x27;ws://&#x27; + location.host + &#x27;/chat&#x27;);// 连接成功时:ws.addEventListener(&#x27;open&#x27;, function (event) &#123;    console.log(&#x27;websocket connected.&#x27;);&#125;);// 收到消息时:ws.addEventListener(&#x27;message&#x27;, function (event) &#123;    console.log(&#x27;message: &#x27; + event.data);    var msgs = JSON.parse(event.data);    // TODO:&#125;);// 连接关闭时:ws.addEventListener(&#x27;close&#x27;, function () &#123;    console.log(&#x27;websocket closed.&#x27;);&#125;);// 绑定到全局变量:window.chatWs = ws;\n用户可以在连接成功后任何时候给服务器发送消息：\n12var inputText = &#x27;Hello, WebSocket.&#x27;;window.chatWs.send(JSON.stringify(&#123;text: inputText&#125;));\n最后，连调浏览器和服务器端，如果一切无误，可以开多个不同的浏览器测试WebSocket的推送和广播。\n和上一节我们介绍的异步处理类似，Servlet的线程模型并不适合大规模的长链接。基于NIO的Netty等框架更适合处理WebSocket长链接，我们将在后面介绍。\n练习\n使用WebSocket编写一个聊天室。\n下载练习\n小结\n在Servlet中使用WebSocket需要3.1及以上版本；\n通过spring-websocket可以简化WebSocket的开发。\n","dateCreated":"2018-02-25T16:40:47+08:00","dateModified":"2025-06-17T18:12:36+08:00","datePublished":"2018-02-25T16:40:47+08:00","description":"","headline":"JAVA-Spring开发-开发Web应用","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://chankein.github.io/2018/02/25/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/"},"publisher":{"@type":"Organization","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg","logo":{"@type":"ImageObject","url":"profile.jpg"}},"url":"https://chankein.github.io/2018/02/25/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/","keywords":"Java, Spirng"}</script>
    <meta name="description" content="在Web开发一章中，我们已经详细介绍了JavaEE中Web开发的基础：Servlet。具体地说，有以下几点：  Servlet规范定义了几种标准组件：Servlet、JSP、Filter和Listener； Servlet的标准组件总是运行在Servlet容器中，如Tomcat、Jetty、WebLogic等。  直接使用Servlet进行Web开发好比直接在JDBC上操作数据库，比较繁琐，更好的">
<meta property="og:type" content="blog">
<meta property="og:title" content="JAVA-Spring开发-开发Web应用">
<meta property="og:url" content="https://chankein.github.io/2018/02/25/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:description" content="在Web开发一章中，我们已经详细介绍了JavaEE中Web开发的基础：Servlet。具体地说，有以下几点：  Servlet规范定义了几种标准组件：Servlet、JSP、Filter和Listener； Servlet的标准组件总是运行在Servlet容器中，如Tomcat、Jetty、WebLogic等。  直接使用Servlet进行Web开发好比直接在JDBC上操作数据库，比较繁琐，更好的">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/spring/web/mvc/spring-mvc.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/spring/web/rest/spring-rest.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/spring/web/interceptor/404.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/spring/web/cors/cors-error.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/spring/web/cors/cors-ok.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/spring/web/i18n/en.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/spring/web/i18n/zh.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/spring/web/async/deferred.png">
<meta property="og:image" content="https://liaoxuefeng.com/books/java/spring/web/async/deferred2.png">
<meta property="article:published_time" content="2018-02-25T08:40:47.000Z">
<meta property="article:modified_time" content="2025-06-17T10:12:36.469Z">
<meta property="article:author" content="Kein Chan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spirng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liaoxuefeng.com/books/java/spring/web/mvc/spring-mvc.png">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../../../#about"
            >
        
        
            <img class="header-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            JAVA-Spring开发-开发Web应用
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-02-25T16:40:47+08:00">
	
		    2018 年 2 月 25 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/">Java</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>在<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/index.html">Web开发</a>一章中，我们已经详细介绍了JavaEE中Web开发的基础：Servlet。具体地说，有以下几点：</p>
<ol>
<li>Servlet规范定义了几种标准组件：Servlet、JSP、Filter和Listener；</li>
<li>Servlet的标准组件总是运行在Servlet容器中，如Tomcat、Jetty、WebLogic等。</li>
</ol>
<p>直接使用Servlet进行Web开发好比直接在JDBC上操作数据库，比较繁琐，更好的方法是在Servlet基础上封装MVC框架，基于MVC开发Web应用，大部分时候，不需要接触Servlet API，开发省时省力。</p>
<p>我们在<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/mvc/index.html">MVC开发</a>和<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/mvc-adv/index.html">MVC高级开发</a>已经由浅入深地介绍了如何编写MVC框架。当然，自己写的MVC主要是理解原理，要实现一个功能全面的MVC需要大量的工作以及广泛的测试。</p>
<p>因此，开发Web应用，首先要选择一个优秀的MVC框架。常用的MVC框架有：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://struts.apache.org/">Struts</a>：最古老的一个MVC框架，目前版本是2，和1.x有很大的区别；</li>
<li>WebWork：一个比Struts设计更优秀的MVC框架，但不知道出于什么原因，从2.0开始把自己的代码全部塞给Struts 2了；</li>
<li><a target="_blank" rel="noopener" href="https://turbine.apache.org/">Turbine</a>：一个重度使用Velocity，强调布局的MVC框架；</li>
<li>其他100+MVC框架……（略）</li>
</ul>
<p>Spring虽然都可以集成任何Web框架，但是，Spring本身也开发了一个MVC框架，就叫<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html">Spring MVC</a>。这个MVC框架设计得足够优秀以至于我们已经不想再费劲去集成类似Struts这样的框架了。</p>
<p>本章我们会详细介绍如何基于Spring MVC开发Web应用。</p>
<p>我们已经介绍了Java Web的基础：Servlet容器，以及标准的Servlet组件：</p>
<ul>
<li>Servlet：能处理HTTP请求并将HTTP响应返回；</li>
<li>JSP：一种嵌套Java代码的HTML，将被编译为Servlet；</li>
<li>Filter：能过滤指定的URL以实现拦截功能；</li>
<li>Listener：监听指定的事件，如ServletContext、HttpSession的创建和销毁。</li>
</ul>
<p>此外，Servlet容器为每个Web应用程序自动创建一个唯一的<code>ServletContext</code>实例，这个实例就代表了Web应用程序本身。</p>
<p>在<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/mvc-adv/index.html">MVC高级开发</a>中，我们手撸了一个MVC框架，接口和Spring MVC类似。如果直接使用Spring MVC，我们写出来的代码类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">register</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/signin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">signin</span><span class="params">(<span class="meta">@RequestParam(&quot;email&quot;)</span> String email, <span class="meta">@RequestParam(&quot;password&quot;)</span> String password)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，Spring提供的是一个IoC容器，所有的Bean，包括Controller，都在Spring IoC容器中被初始化，而Servlet容器由JavaEE服务器提供（如Tomcat），Servlet容器对Spring一无所知，他们之间到底依靠什么进行联系，又是以何种顺序初始化的？</p>
<p>在理解上述问题之前，我们先把基于Spring MVC开发的项目结构搭建起来。首先创建基于Web的Maven工程，引入如下依赖：</p>
<ul>
<li>org.springframework:spring-context:6.0.0</li>
<li>org.springframework:spring-webmvc:6.0.0</li>
<li>org.springframework:spring-jdbc:6.0.0</li>
<li>jakarta.annotation:jakarta.annotation-api:2.1.1</li>
<li>io.pebbletemplates:pebble-spring6:3.2.0</li>
<li>ch.qos.logback:logback-core:1.4.4</li>
<li>ch.qos.logback:logback-classic:1.4.4</li>
<li>com.zaxxer:HikariCP:5.0.1</li>
<li>org.hsqldb:hsqldb:2.7.0</li>
</ul>
<p>以及<code>provided</code>依赖：</p>
<ul>
<li>org.apache.tomcat.embed:tomcat-embed-core:10.1.1</li>
<li>org.apache.tomcat.embed:tomcat-embed-jasper:10.1.1</li>
</ul>
<p>这个标准的Maven Web工程目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">spring-web-mvc</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── itranswarp</span><br><span class="line">        │           └── learnjava</span><br><span class="line">        │               ├── AppConfig.java</span><br><span class="line">        │               ├── DatabaseInitializer.java</span><br><span class="line">        │               ├── entity</span><br><span class="line">        │               │   └── User.java</span><br><span class="line">        │               ├── service</span><br><span class="line">        │               │   └── UserService.java</span><br><span class="line">        │               └── web</span><br><span class="line">        │                   └── UserController.java</span><br><span class="line">        ├── resources</span><br><span class="line">        │   ├── jdbc.properties</span><br><span class="line">        │   └── logback.xml</span><br><span class="line">        └── webapp</span><br><span class="line">            ├── WEB-INF</span><br><span class="line">            │   ├── templates</span><br><span class="line">            │   │   ├── _base.html</span><br><span class="line">            │   │   ├── index.html</span><br><span class="line">            │   │   ├── profile.html</span><br><span class="line">            │   │   ├── register.html</span><br><span class="line">            │   │   └── signin.html</span><br><span class="line">            │   └── web.xml</span><br><span class="line">            └── static</span><br><span class="line">                ├── css</span><br><span class="line">                │   └── bootstrap.css</span><br><span class="line">                └── js</span><br><span class="line">                    └── jquery.js</span><br></pre></td></tr></table></figure>
<p>其中，<code>src/main/webapp</code>是标准web目录，<code>WEB-INF</code>存放<code>web.xml</code>，编译的class，第三方jar，以及不允许浏览器直接访问的View模版，<code>static</code>目录存放所有静态文件。</p>
<p>在<code>src/main/resources</code>目录中存放的是Java程序读取的classpath资源文件，除了JDBC的配置文件<code>jdbc.properties</code>外，我们又新增了一个<code>logback.xml</code>，这是Logback的默认查找的配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.itranswarp.learnjava&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面给出了一个写入到标准输出的Logback配置，可以基于上述配置添加写入到文件的配置。</p>
<p>在<code>src/main/java</code>中就是我们编写的Java代码了。</p>
<h3 id="配置Spring-MVC">配置Spring MVC</h3>
<p>和普通Spring配置一样，我们编写正常的<code>AppConfig</code>后，只需加上<code>@EnableWebMvc</code>注解，就“激活”了Spring MVC：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span> <span class="comment">// 启用Spring MVC</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了创建<code>DataSource</code>、<code>JdbcTemplate</code>、<code>PlatformTransactionManager</code>外，<code>AppConfig</code>需要额外创建几个用于Spring MVC的Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">WebMvcConfigurer <span class="title function_">createWebMvcConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">            registry.addResourceHandler(<span class="string">&quot;/static/**&quot;</span>).addResourceLocations(<span class="string">&quot;/static/&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WebMvcConfigurer</code>并不是必须的，但我们在这里创建一个默认的<code>WebMvcConfigurer</code>，只覆写<code>addResourceHandlers()</code>，目的是让Spring MVC自动处理静态文件，并且映射路径为<code>/static/**</code>。</p>
<p>另一个必须要创建的Bean是<code>ViewResolver</code>，因为Spring MVC允许集成任何模板引擎，使用哪个模板引擎，就实例化一个对应的<code>ViewResolver</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">ViewResolver <span class="title function_">createViewResolver</span><span class="params">(<span class="meta">@Autowired</span> ServletContext servletContext)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PebbleEngine</span>.Builder().autoEscaping(<span class="literal">true</span>)</span><br><span class="line">            <span class="comment">// cache:</span></span><br><span class="line">            .cacheActive(<span class="literal">false</span>)</span><br><span class="line">            <span class="comment">// loader:</span></span><br><span class="line">            .loader(<span class="keyword">new</span> <span class="title class_">Servlet5Loader</span>(servletContext))</span><br><span class="line">            .build();</span><br><span class="line">    <span class="type">var</span> <span class="variable">viewResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PebbleViewResolver</span>(engine);</span><br><span class="line">    viewResolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">    viewResolver.setSuffix(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> viewResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ViewResolver</code>通过指定<code>prefix</code>和<code>suffix</code>来确定如何查找View。上述配置使用Pebble引擎，指定模板文件存放在<code>/WEB-INF/templates/</code>目录下。</p>
<p>剩下的Bean都是普通的<code>@Component</code>，但Controller必须标记为<code>@Controller</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Controller使用@Controller标记而不是@Component:</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">// 正常使用@Autowired注入:</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理一个URL映射:</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是普通的Java应用程序，我们通过<code>main()</code>方法可以很简单地创建一个Spring容器的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是问题来了，现在是Web应用程序，而Web应用程序总是由Servlet容器创建，那么，Spring容器应该由谁创建？在什么时候创建？Spring容器中的Controller又是如何通过Servlet调用的？</p>
<p>在Web应用中启动Spring容器有很多种方法，可以通过Listener启动，也可以通过Servlet启动，可以使用XML配置，也可以使用注解配置。这里，我们只介绍一种<em>最简单</em>的启动Spring容器的方式。</p>
<p>第一步，我们在<code>web.xml</code>中配置Spring MVC提供的<code>DispatcherServlet</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>org.springframework.web.context.support.AnnotationConfigWebApplicationContext<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.itranswarp.learnjava.AppConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>初始化参数<code>contextClass</code>指定使用注解配置的<code>AnnotationConfigWebApplicationContext</code>，配置文件的位置参数<code>contextConfigLocation</code>指向<code>AppConfig</code>的完整类名，最后，把这个Servlet映射到<code>/*</code>，即处理所有URL。</p>
<p>上述配置可以看作一个样板配置，有了这个配置，Servlet容器会首先初始化Spring MVC的<code>DispatcherServlet</code>，在<code>DispatcherServlet</code>启动时，它根据配置<code>AppConfig</code>创建了一个类型是<code>WebApplicationContext</code>的IoC容器，完成所有Bean的初始化，并将容器绑到<code>ServletContext</code>上。</p>
<p>因为<code>DispatcherServlet</code>持有IoC容器，能从IoC容器中获取所有<code>@Controller</code>的Bean，因此，<code>DispatcherServlet</code>接收到所有HTTP请求后，根据Controller方法配置的路径，就可以正确地把请求转发到指定方法，并根据返回的<code>ModelAndView</code>决定如何渲染页面。</p>
<p>最后，我们在<code>AppConfig</code>中通过<code>main()</code>方法启动嵌入式Tomcat：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line">    tomcat.setPort(Integer.getInteger(<span class="string">&quot;port&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">    tomcat.getConnector();</span><br><span class="line">    <span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> tomcat.addWebapp(<span class="string">&quot;&quot;</span>, <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/main/webapp&quot;</span>).getAbsolutePath());</span><br><span class="line">    <span class="type">WebResourceRoot</span> <span class="variable">resources</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardRoot</span>(ctx);</span><br><span class="line">    resources.addPreResources(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DirResourceSet</span>(resources, <span class="string">&quot;/WEB-INF/classes&quot;</span>, <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;target/classes&quot;</span>).getAbsolutePath(), <span class="string">&quot;/&quot;</span>));</span><br><span class="line">    ctx.setResources(resources);</span><br><span class="line">    tomcat.start();</span><br><span class="line">    tomcat.getServer().await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述Web应用程序就是我们使用Spring MVC时的一个最小启动功能集。由于使用了JDBC和数据库，用户的注册、登录信息会被持久化：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/web/mvc/spring-mvc.png" alt="spring-mvc"></p>
<h3 id="编写Controller">编写Controller</h3>
<p>有了Web应用程序的最基本的结构，我们的重点就可以放在如何编写Controller上。Spring MVC对Controller没有固定的要求，也不需要实现特定的接口。以<code>UserController</code>为例，编写Controller只需要遵循以下要点：</p>
<p>总是标记<code>@Controller</code>而不是<code>@Component</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个方法对应一个HTTP请求路径，用<code>@GetMapping</code>或<code>@PostMapping</code>表示GET或POST请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/signin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">doSignin</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;email&quot;)</span> String email,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;password&quot;)</span> String password,</span></span><br><span class="line"><span class="params">        HttpSession session)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要接收的HTTP参数以<code>@RequestParam()</code>标注，可以设置默认值。如果方法参数需要传入<code>HttpServletRequest</code>、<code>HttpServletResponse</code>或者<code>HttpSession</code>，直接添加这个类型的参数即可，Spring MVC会自动按类型传入。</p>
<p>返回的ModelAndView通常包含View的路径和一个Map作为Model，但也可以没有Model，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;signin.html&quot;</span>); <span class="comment">// 仅View，没有Model</span></span><br></pre></td></tr></table></figure>
<p>返回重定向时既可以写<code>new ModelAndView(&quot;redirect:/signin&quot;)</code>，也可以直接返回String：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/signin&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/profile&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在方法内部直接操作<code>HttpServletResponse</code>发送响应，返回<code>null</code>表示无需进一步处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">download</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] data = ...</span><br><span class="line">    response.setContentType(<span class="string">&quot;application/octet-stream&quot;</span>);</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">    output.write(data);</span><br><span class="line">    output.flush();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对URL进行分组，每组对应一个Controller是一种很好的组织形式，并可以在Controller的class定义出添加URL前缀，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">// 注意实际URL映射是/user/profile</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/profile&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">profile</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意实际URL映射是/user/changePassword</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/changePassword&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">changePassword</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际方法的URL映射总是前缀+路径，这种形式还可以有效避免不小心导致的重复的URL映射。</p>
<p>可见，Spring MVC允许我们编写既简单又灵活的Controller实现。</p>
<h3 id="练习">练习</h3>
<p>使用Spring MVC，在注册、登录等功能的基础上增加一个修改口令的页面。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/web/mvc/spring-web-mvc.zip">下载练习</a></p>
<h3 id="小结">小结</h3>
<p>使用Spring MVC时，整个Web应用程序按如下顺序启动：</p>
<ol>
<li>启动Tomcat服务器；</li>
<li>Tomcat读取<code>web.xml</code>并初始化<code>DispatcherServlet</code>；</li>
<li><code>DispatcherServlet</code>创建IoC容器并自动注册到<code>ServletContext</code>中。</li>
</ol>
<p>启动后，浏览器发出的HTTP请求全部由<code>DispatcherServlet</code>接收，并根据配置转发到指定Controller的指定方法处理。</p>
<p>使用Spring MVC开发Web应用程序的主要工作就是编写Controller逻辑。在Web应用中，除了需要使用MVC给用户显示页面外，还有一类API接口，我们称之为REST，通常输入输出都是JSON，便于第三方调用或者使用页面JavaScript与之交互。</p>
<p>直接在Controller中处理JSON是可以的，因为Spring MVC的<code>@GetMapping</code>和<code>@PostMapping</code>都支持指定输入和输出的格式。如果我们想接收JSON，输出JSON，那么可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(value = &quot;/rest&quot;,</span></span><br><span class="line"><span class="meta">             consumes = &quot;application/json;charset=UTF-8&quot;,</span></span><br><span class="line"><span class="meta">             produces = &quot;application/json;charset=UTF-8&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">rest</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;restSupport\&quot;:true&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的Maven工程需要加入Jackson这个依赖：<code>com.fasterxml.jackson.core:jackson-databind:2.14.0</code></p>
<p>注意到<code>@PostMapping</code>使用<code>consumes</code>声明能接收的类型，使用<code>produces</code>声明输出的类型，并且额外加了<code>@ResponseBody</code>表示返回的<code>String</code>无需额外处理，直接作为输出内容写入<code>HttpServletResponse</code>。输入的JSON则根据注解<code>@RequestBody</code>直接被Spring反序列化为<code>User</code>这个JavaBean。</p>
<p>使用curl命令测试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;email&quot;:&quot;bob@example.com&quot;&#125;&#x27; http://localhost:8080/rest      </span><br><span class="line">&gt; POST /rest HTTP/1.1</span><br><span class="line">&gt; Host: localhost:8080</span><br><span class="line">&gt; User-Agent: curl/7.64.1</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; Content-Type: application/json</span><br><span class="line">&gt; Content-Length: 27</span><br><span class="line">&gt; </span><br><span class="line">&lt; HTTP/1.1 200 </span><br><span class="line">&lt; Content-Type: application/json;charset=utf-8</span><br><span class="line">&lt; Content-Length: 20</span><br><span class="line">&lt; Date: Sun, 10 May 2020 09:56:01 GMT</span><br><span class="line">&lt; </span><br><span class="line">&#123;&quot;restSupport&quot;:true&#125;</span><br></pre></td></tr></table></figure>
<p>输出正是我们写入的字符串。</p>
<p>直接用Spring的Controller配合一大堆注解写REST太麻烦了，因此，Spring还额外提供了一个<code>@RestController</code>注解，使用<code>@RestController</code>替代<code>@Controller</code>后，每个方法自动变成API接口方法。我们还是以实际代码举例，编写<code>ApiController</code>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">users</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUsers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/signin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">signin</span><span class="params">(<span class="meta">@RequestBody</span> SignInRequest signinRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.signin(signinRequest.email, signinRequest.password);</span><br><span class="line">            <span class="keyword">return</span> Map.of(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Map.of(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;SIGNIN_FAILED&quot;</span>, <span class="string">&quot;message&quot;</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SignInRequest</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String email;</span><br><span class="line">        <span class="keyword">public</span> String password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写REST接口只需要定义<code>@RestController</code>，然后，每个方法都是一个API接口，输入和输出只要能被Jackson序列化或反序列化为JSON就没有问题。我们用浏览器测试GET请求，可直接显示JSON响应：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/web/rest/spring-rest.png" alt="user-api"></p>
<p>要测试POST请求，可以用curl命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;email&quot;:&quot;bob@example.com&quot;,&quot;password&quot;:&quot;bob123&quot;&#125;&#x27; http://localhost:8080/api/signin</span><br><span class="line">&gt; POST /api/signin HTTP/1.1</span><br><span class="line">&gt; Host: localhost:8080</span><br><span class="line">&gt; User-Agent: curl/7.64.1</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; Content-Type: application/json</span><br><span class="line">&gt; Content-Length: 47</span><br><span class="line">&gt; </span><br><span class="line">&lt; HTTP/1.1 200 </span><br><span class="line">&lt; Content-Type: application/json</span><br><span class="line">&lt; Transfer-Encoding: chunked</span><br><span class="line">&lt; Date: Sun, 10 May 2020 08:14:13 GMT</span><br><span class="line">&lt; </span><br><span class="line">&#123;&quot;user&quot;:&#123;&quot;id&quot;:1,&quot;email&quot;:&quot;bob@example.com&quot;,&quot;password&quot;:&quot;bob123&quot;,&quot;name&quot;:&quot;Bob&quot;,...</span><br></pre></td></tr></table></figure>
<p>注意观察上述JSON的输出，<code>User</code>能被正确地序列化为JSON，但暴露了<code>password</code>属性，这是我们不期望的。要避免输出<code>password</code>属性，可以把<code>User</code>复制到另一个<code>UserBean</code>对象，该对象只持有必要的属性，但这样做比较繁琐。另一种简单的方法是直接在<code>User</code>的<code>password</code>属性定义处加上<code>@JsonIgnore</code>表示完全忽略该属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样一来，如果写一个<code>register(User user)</code>方法，那么该方法的User对象也拿不到注册时用户传入的密码了。如果要允许输入<code>password</code>，但不允许输出<code>password</code>，即在JSON序列化和反序列化时，允许写属性，禁用读属性，可以更精细地控制如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty(access = Access.WRITE_ONLY)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，可以使用<code>@JsonProperty(access = Access.READ_ONLY)</code>允许输出，不允许输入。</p>
<h3 id="练习-2">练习</h3>
<p>使用REST实现API。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/web/rest/spring-web-mvc-rest.zip">下载练习</a></p>
<h3 id="小结-2">小结</h3>
<p>使用<code>@RestController</code>可以方便地编写REST服务，Spring默认使用JSON作为输入和输出。</p>
<p>要控制序列化和反序列化，可以使用Jackson提供的<code>@JsonIgnore</code>和<code>@JsonProperty</code>注解。</p>
<p>在Spring MVC中，<code>DispatcherServlet</code>只需要固定配置到<code>web.xml</code>中，剩下的工作主要是专注于编写Controller。</p>
<p>但是，在Servlet规范中，我们还可以<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/filter/index.html">使用Filter</a>。如果要在Spring MVC中使用<code>Filter</code>，应该怎么做？</p>
<p>有的童鞋在上一节的Web应用中可能发现了，如果注册时输入中文会导致乱码，因为Servlet默认按非UTF-8编码读取参数。为了修复这一问题，我们可以简单地使用一个EncodingFilter，在全局范围类给<code>HttpServletRequest</code>和<code>HttpServletResponse</code>强制设置为UTF-8编码。</p>
<p>可以自己编写一个EncodingFilter，也可以直接使用Spring MVC自带的一个<code>CharacterEncodingFilter</code>。配置Filter时，只需在<code>web.xml</code>中声明即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为这种Filter和我们业务关系不大，注意到<code>CharacterEncodingFilter</code>其实和Spring的IoC容器没有任何关系，两者均互不知晓对方的存在，因此，配置这种Filter十分简单。</p>
<p>我们再考虑这样一个问题：如果允许用户使用Basic模式进行用户验证，即在HTTP请求中添加头<code>Authorization: Basic email:password</code>，这个需求如何实现？</p>
<p>编写一个<code>AuthFilter</code>是最简单的实现方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="comment">// 获取Authorization头:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authHeader</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (authHeader != <span class="literal">null</span> &amp;&amp; authHeader.startsWith(<span class="string">&quot;Basic &quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 从Header中提取email和password:</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> prefixFrom(authHeader);</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> suffixFrom(authHeader);</span><br><span class="line">            <span class="comment">// 登录:</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.signin(email, password);</span><br><span class="line">            <span class="comment">// 放入Session:</span></span><br><span class="line">            req.getSession().setAttribute(UserController.KEY_USER, user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续处理请求:</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在问题来了：在Spring中创建的这个<code>AuthFilter</code>是一个普通Bean，Servlet容器并不知道，所以它不会起作用。</p>
<p>如果我们直接在<code>web.xml</code>中声明这个<code>AuthFilter</code>，注意到<code>AuthFilter</code>的实例将由Servlet容器而不是Spring容器初始化，因此，<code>@Autowire</code>根本不生效，用于登录的<code>UserService</code>成员变量永远是<code>null</code>。</p>
<p>所以，得通过一种方式，让Servlet容器实例化的Filter，间接引用Spring容器实例化的<code>AuthFilter</code>。Spring MVC提供了一个<code>DelegatingFilterProxy</code>，专门来干这个事情：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>authFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>authFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们来看实现原理：</p>
<ol>
<li>Servlet容器从<code>web.xml</code>中读取配置，实例化<code>DelegatingFilterProxy</code>，注意命名是<code>authFilter</code>；</li>
<li>Spring容器通过扫描<code>@Component</code>实例化<code>AuthFilter</code>。</li>
</ol>
<p>当<code>DelegatingFilterProxy</code>生效后，它会自动查找注册在<code>ServletContext</code>上的Spring容器，再试图从容器中查找名为<code>authFilter</code>的Bean，也就是我们用<code>@Component</code>声明的<code>AuthFilter</code>。</p>
<p><code>DelegatingFilterProxy</code>将请求代理给<code>AuthFilter</code>，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelegatingFilterProxy</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Filter delegate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(...)</span> <span class="keyword">throws</span> ... &#123;</span><br><span class="line">        <span class="keyword">if</span> (delegate == <span class="literal">null</span>) &#123;</span><br><span class="line">            delegate = findBeanFromSpringContainer();</span><br><span class="line">        &#125;</span><br><span class="line">        delegate.doFilter(req, resp, chain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是一个<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/structural/proxy/index.html">代理模式</a>的简单应用。我们画个图表示它们之间的引用关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐ ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─</span><br><span class="line">  ┌─────────────────────┐        ┌───────────┐   │</span><br><span class="line">│ │DelegatingFilterProxy│─│─│─ ─▶│AuthFilter │</span><br><span class="line">  └─────────────────────┘        └───────────┘   │</span><br><span class="line">│ ┌─────────────────────┐ │ │    ┌───────────┐</span><br><span class="line">  │  DispatcherServlet  │─ ─ ─ ─▶│Controllers│   │</span><br><span class="line">│ └─────────────────────┘ │ │    └───────────┘</span><br><span class="line">                                                 │</span><br><span class="line">│    Servlet Container    │ │  Spring Container</span><br><span class="line"> ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>
<p>如果在<code>web.xml</code>中配置的Filter名字和Spring容器的Bean的名字不一致，那么需要指定Bean的名字：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>basicAuthFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定Bean的名字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>targetBeanName<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>authFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实际应用时，尽量保持名字一致，以减少不必要的配置。</p>
<p>要使用Basic模式的用户认证，我们可以使用curl命令测试。例如，用户登录名是<code>tom@example.com</code>，口令是<code>tomcat</code>，那么先构造一个使用URL编码的<code>用户名:口令</code>的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tom%40example.com:tomcat</span><br></pre></td></tr></table></figure>
<p>对其进行Base64编码，最终构造出的Header如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Basic dG9tJTQwZXhhbXBsZS5jb206dG9tY2F0</span><br></pre></td></tr></table></figure>
<p>使用如下的<code>curl</code>命令并获得响应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v -H &#x27;Authorization: Basic dG9tJTQwZXhhbXBsZS5jb206dG9tY2F0&#x27; http://localhost:8080/profile</span><br><span class="line">&gt; GET /profile HTTP/1.1</span><br><span class="line">&gt; Host: localhost:8080</span><br><span class="line">&gt; User-Agent: curl/7.64.1</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; Authorization: Basic dG9tJTQwZXhhbXBsZS5jb206dG9tY2F0</span><br><span class="line">&gt; </span><br><span class="line">&lt; HTTP/1.1 200 </span><br><span class="line">&lt; Set-Cookie: JSESSIONID=CE0F4BFC394816F717443397D4FEABBE; Path=/; HttpOnly</span><br><span class="line">&lt; Content-Type: text/html;charset=UTF-8</span><br><span class="line">&lt; Content-Language: en-CN</span><br><span class="line">&lt; Transfer-Encoding: chunked</span><br><span class="line">&lt; Date: Wed, 29 Apr 2020 00:15:50 GMT</span><br><span class="line">&lt; </span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">...HTML输出...</span><br></pre></td></tr></table></figure>
<p>上述响应说明<code>AuthFilter</code>已生效。</p>
<p>注意</p>
<p>Basic认证模式并不安全，本节只用来作为使用Filter的示例。</p>
<h3 id="练习-3">练习</h3>
<p>使用DelegatingFilterProxy实现AuthFilter。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/web/filter/spring-web-mvc-filter.zip">下载练习</a></p>
<h3 id="小结-3">小结</h3>
<p>当一个Filter作为Spring容器管理的Bean存在时，可以通过<code>DelegatingFilterProxy</code>间接地引用它并使其生效。</p>
<p>在Web程序中，注意到使用Filter的时候，Filter由Servlet容器管理，它在Spring MVC的Web应用程序中作用范围如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">         │   ▲</span><br><span class="line">         ▼   │</span><br><span class="line">       ┌───────┐</span><br><span class="line">       │Filter1│</span><br><span class="line">       └───────┘</span><br><span class="line">         │   ▲</span><br><span class="line">         ▼   │</span><br><span class="line">       ┌───────┐</span><br><span class="line">┌ ─ ─ ─│Filter2│─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line">       └───────┘</span><br><span class="line">│        │   ▲                  │</span><br><span class="line">         ▼   │</span><br><span class="line">│ ┌─────────────────┐           │</span><br><span class="line">  │DispatcherServlet│◀───┐</span><br><span class="line">│ └─────────────────┘    │      │</span><br><span class="line">   │              ┌────────────┐</span><br><span class="line">│  │              │ModelAndView││</span><br><span class="line">   │              └────────────┘</span><br><span class="line">│  │                     ▲      │</span><br><span class="line">   │    ┌───────────┐    │</span><br><span class="line">│  ├───▶│Controller1│────┤      │</span><br><span class="line">   │    └───────────┘    │</span><br><span class="line">│  │                     │      │</span><br><span class="line">   │    ┌───────────┐    │</span><br><span class="line">│  └───▶│Controller2│────┘      │</span><br><span class="line">        └───────────┘</span><br><span class="line">└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>
<p>上图虚线框就是Filter2的拦截范围，Filter组件实际上并不知道后续内部处理是通过Spring MVC提供的<code>DispatcherServlet</code>还是其他Servlet组件，因为Filter是Servlet规范定义的标准组件，它可以应用在任何基于Servlet的程序中。</p>
<p>如果只基于Spring MVC开发应用程序，还可以使用Spring MVC提供的一种功能类似Filter的拦截器：Interceptor。和Filter相比，Interceptor拦截范围不是后续整个处理流程，而是仅针对Controller拦截：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">       │   ▲</span><br><span class="line">       ▼   │</span><br><span class="line">     ┌───────┐</span><br><span class="line">     │Filter1│</span><br><span class="line">     └───────┘</span><br><span class="line">       │   ▲</span><br><span class="line">       ▼   │</span><br><span class="line">     ┌───────┐</span><br><span class="line">     │Filter2│</span><br><span class="line">     └───────┘</span><br><span class="line">       │   ▲</span><br><span class="line">       ▼   │</span><br><span class="line">┌─────────────────┐</span><br><span class="line">│DispatcherServlet│◀───┐</span><br><span class="line">└─────────────────┘    │</span><br><span class="line"> │ ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┼ ─ ─ ─ ┐</span><br><span class="line"> │                     │</span><br><span class="line"> │ │            ┌────────────┐ │</span><br><span class="line"> │              │   Render   │</span><br><span class="line"> │ │            └────────────┘ │</span><br><span class="line"> │                     ▲</span><br><span class="line"> │ │                   │       │</span><br><span class="line"> │              ┌────────────┐</span><br><span class="line"> │ │            │ModelAndView│ │</span><br><span class="line"> │              └────────────┘</span><br><span class="line"> │ │                   ▲       │</span><br><span class="line"> │    ┌───────────┐    │</span><br><span class="line"> ├─┼─▶│Controller1│────┤       │</span><br><span class="line"> │    └───────────┘    │</span><br><span class="line"> │ │                   │       │</span><br><span class="line"> │    ┌───────────┐    │</span><br><span class="line"> └─┼─▶│Controller2│────┘       │</span><br><span class="line">      └───────────┘</span><br><span class="line">   └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>
<p>上图虚线框就是Interceptor的拦截范围，注意到Controller的处理方法一般都类似这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Controller1</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/path/to/hello&quot;)</span></span><br><span class="line">    ModelAndView <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，Interceptor的拦截范围其实就是Controller方法，它实际上就相当于基于AOP的方法拦截。因为Interceptor只拦截Controller方法，所以要注意，返回<code>ModelAndView</code>并渲染后，后续处理就脱离了Interceptor的拦截范围。</p>
<p>使用Interceptor的好处是Interceptor本身是Spring管理的Bean，因此注入任意Bean都非常简单。此外，可以应用多个Interceptor，并通过简单的<code>@Order</code>指定顺序。我们先写一个<code>LoggerInterceptor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;preHandle &#123;&#125;...&quot;</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">if</span> (request.getParameter(<span class="string">&quot;debug&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">            pw.write(<span class="string">&quot;&lt;p&gt;DEBUG MODE&lt;/p&gt;&quot;</span>);</span><br><span class="line">            pw.flush();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;postHandle &#123;&#125;.&quot;</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">if</span> (modelAndView != <span class="literal">null</span>) &#123;</span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;__time__&quot;</span>, LocalDateTime.now());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;afterCompletion &#123;&#125;: exception = &#123;&#125;&quot;</span>, request.getRequestURI(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个Interceptor必须实现<code>HandlerInterceptor</code>接口，可以选择实现<code>preHandle()</code>、<code>postHandle()</code>和<code>afterCompletion()</code>方法。<code>preHandle()</code>是Controller方法调用前执行，<code>postHandle()</code>是Controller方法正常返回后执行，而<code>afterCompletion()</code>无论Controller方法是否抛异常都会执行，参数<code>ex</code>就是Controller方法抛出的异常（未抛出异常是<code>null</code>）。</p>
<p>在<code>preHandle()</code>中，也可以直接处理响应，然后返回<code>false</code>表示无需调用Controller方法继续处理了，通常在认证或者安全检查失败时直接返回错误响应。在<code>postHandle()</code>中，因为捕获了Controller方法返回的<code>ModelAndView</code>，所以可以继续往<code>ModelAndView</code>里添加一些通用数据，很多页面需要的全局数据如Copyright信息等都可以放到这里，无需在每个Controller方法中重复添加。</p>
<p>我们再继续添加一个<code>AuthInterceptor</code>，用于替代上一节使用<code>AuthFilter</code>进行Basic认证的功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(2)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;pre authenticate &#123;&#125;...&quot;</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            authenticateByHeader(request);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;login by authorization header failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">authenticateByHeader</span><span class="params">(HttpServletRequest req)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">authHeader</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (authHeader != <span class="literal">null</span> &amp;&amp; authHeader.startsWith(<span class="string">&quot;Basic &quot;</span>)) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;try authenticate by authorization header...&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">up</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(Base64.getDecoder().decode(authHeader.substring(<span class="number">6</span>)), StandardCharsets.UTF_8);</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> up.indexOf(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> URLDecoder.decode(up.substring(<span class="number">0</span>, pos), StandardCharsets.UTF_8);</span><br><span class="line">                <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> URLDecoder.decode(up.substring(pos + <span class="number">1</span>), StandardCharsets.UTF_8);</span><br><span class="line">                <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.signin(email, password);</span><br><span class="line">                req.getSession().setAttribute(UserController.KEY_USER, user);</span><br><span class="line">                logger.info(<span class="string">&quot;user &#123;&#125; login by authorization header ok.&quot;</span>, email);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>AuthInterceptor</code>是由Spring容器直接管理的，因此注入<code>UserService</code>非常方便。</p>
<p>最后，要让拦截器生效，我们在<code>WebMvcConfigurer</code>中注册所有的Interceptor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">WebMvcConfigurer <span class="title function_">createWebMvcConfigurer</span><span class="params">(<span class="meta">@Autowired</span> HandlerInterceptor[] interceptors)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> interceptor : interceptors) &#123;</span><br><span class="line">                registry.addInterceptor(interceptor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意</p>
<p>如果拦截器没有生效，请检查是否忘了在WebMvcConfigurer中注册。</p>
<h3 id="处理异常">处理异常</h3>
<p>在Controller中，Spring MVC还允许定义基于<code>@ExceptionHandler</code>注解的异常处理方法。我们来看具体的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(RuntimeException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handleUnknowException</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;500.html&quot;</span>, Map.of(<span class="string">&quot;error&quot;</span>, ex.getClass().getSimpleName(), <span class="string">&quot;message&quot;</span>, ex.getMessage()));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异常处理方法没有固定的方法签名，可以传入<code>Exception</code>、<code>HttpServletRequest</code>等，返回值可以是<code>void</code>，也可以是<code>ModelAndView</code>，上述代码通过<code>@ExceptionHandler(RuntimeException.class)</code>表示当发生<code>RuntimeException</code>的时候，就自动调用此方法处理。</p>
<p>注意到我们返回了一个新的<code>ModelAndView</code>，这样在应用程序内部如果发生了预料之外的异常，可以给用户显示一个出错页面，而不是简单的500 Internal Server Error或404 Not Found。例如B站的错误页：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/web/interceptor/404.png" alt="ERROR"></p>
<p>可以编写多个错误处理方法，每个方法针对特定的异常。例如，处理<code>LoginException</code>使得页面可以自动跳转到登录页。</p>
<p>使用<code>ExceptionHandler</code>时，要注意它仅作用于当前的Controller，即ControllerA中定义的一个<code>ExceptionHandler</code>方法对ControllerB不起作用。如果我们有很多Controller，每个Controller都需要处理一些通用的异常，例如<code>LoginException</code>，思考一下应该怎么避免重复代码？</p>
<h3 id="练习-4">练习</h3>
<p>使用Interceptor。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/web/interceptor/spring-web-mvc-interceptor.zip">下载练习</a></p>
<h3 id="小结-4">小结</h3>
<p>Spring MVC提供了Interceptor组件来拦截Controller方法，使用时要注意Interceptor的作用范围。</p>
<p>在开发REST应用时，很多时候，是通过页面的JavaScript和后端的REST API交互。</p>
<p>在JavaScript与REST交互的时候，有很多安全限制。默认情况下，浏览器按同源策略放行JavaScript调用API，即：</p>
<ul>
<li>如果A站在域名<code>a.com</code>页面的JavaScript调用A站自己的API时，没有问题；</li>
<li>如果A站在域名<code>a.com</code>页面的JavaScript调用B站<code>b.com</code>的API时，将被浏览器拒绝访问，因为不满足同源策略。</li>
</ul>
<p>同源要求域名要完全相同（<code>a.com</code>和<code>www.a.com</code>不同），协议要相同（<code>http</code>和<code>https</code>不同），端口要相同 。</p>
<p>那么，在域名<code>a.com</code>页面的JavaScript要调用B站<code>b.com</code>的API时，还有没有办法？</p>
<p>办法是有的，那就是CORS，全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。如果A站的JavaScript访问B站API的时候，B站能够返回响应头<code>Access-Control-Allow-Origin: http://a.com</code>，那么，浏览器就允许A站的JavaScript访问B站的API。</p>
<p>注意到跨域访问能否成功，取决于B站是否愿意给A站返回一个正确的<code>Access-Control-Allow-Origin</code>响应头，所以决定权永远在提供API的服务方手中。</p>
<p>关于CORS的详细信息可以参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">MDN文档</a>，这里不再详述。</p>
<p>使用Spring的<code>@RestController</code>开发REST应用时，同样会面对跨域问题。如果我们允许指定的网站通过页面JavaScript访问这些REST API，就必须正确地设置CORS。</p>
<p>有好几种方法设置CORS，我们来一一介绍。</p>
<h3 id="使用-CrossOrigin">使用@CrossOrigin</h3>
<p>第一种方法是使用<code>@CrossOrigin</code>注解，可以在<code>@RestController</code>的class级别或方法级别定义一个<code>@CrossOrigin</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &quot;http://local.liaoxuefeng.com:8080&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiController</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述定义在<code>ApiController</code>处的<code>@CrossOrigin</code>指定了只允许来自<code>local.liaoxuefeng.com</code>跨域访问，允许多个域访问需要写成数组形式，例如<code>origins = &#123;&quot;http://a.com&quot;, &quot;https://www.b.com&quot;&#125;)</code>。如果要允许任何域访问，写成<code>origins = &quot;*&quot;</code>即可。</p>
<p>如果有多个REST Controller都需要使用CORS，那么，每个Controller都必须标注<code>@CrossOrigin</code>注解。</p>
<h3 id="使用CorsRegistry">使用CorsRegistry</h3>
<p>第二种方法是在<code>WebMvcConfigurer</code>中定义一个全局CORS配置，下面是一个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">WebMvcConfigurer <span class="title function_">createWebMvcConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">            registry.addMapping(<span class="string">&quot;/api/**&quot;</span>)</span><br><span class="line">                    .allowedOrigins(<span class="string">&quot;http://local.liaoxuefeng.com:8080&quot;</span>)</span><br><span class="line">                    .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>)</span><br><span class="line">                    .maxAge(<span class="number">3600</span>);</span><br><span class="line">            <span class="comment">// 可以继续添加其他URL规则:</span></span><br><span class="line">            <span class="comment">// registry.addMapping(&quot;/rest/v2/**&quot;)...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式可以创建一个全局CORS配置，如果仔细地设计URL结构，那么可以一目了然地看到各个URL的CORS规则，推荐使用这种方式配置CORS。</p>
<h3 id="使用CorsFilter">使用CorsFilter</h3>
<p>第三种方法是使用Spring提供的<code>CorsFilter</code>，我们在<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/web/filter/index.html">集成Filter</a>中详细介绍了将Spring容器内置的Bean暴露为Servlet容器的Filter的方法，由于这种配置方式需要修改<code>web.xml</code>，也比较繁琐，所以推荐使用第二种方式。</p>
<h3 id="测试">测试</h3>
<p>当我们配置好CORS后，可以在浏览器中测试一下规则是否生效。</p>
<p>我们先用<code>http://localhost:8080</code>在Chrome浏览器中打开首页，然后打开Chrome的开发者工具，切换到Console，输入一个JavaScript语句来跨域访问API：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">getJSON</span>(<span class="string">&quot;http://local.liaoxuefeng.com:8080/api/users&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)));</span><br></pre></td></tr></table></figure>
<p>上述源站的域是<code>http://localhost:8080</code>，跨域访问的是<code>http://local.liaoxuefeng.com:8080</code>，因为配置的CORS不允许<code>localhost</code>访问，所以不出意外地得到一个错误：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/web/cors/cors-error.png" alt="cors-deny"></p>
<p>浏览题打印了错误原因就是<code>been blocked by CORS policy</code>。</p>
<p>我们再用<code>http://local.liaoxuefeng.com:8080</code>在Chrome浏览器中打开首页，在Console中执行JavaScript访问<code>localhost</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">getJSON</span>(<span class="string">&quot;http://localhost:8080/api/users&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)));</span><br></pre></td></tr></table></figure>
<p>因为CORS规则允许来自<code>http://local.liaoxuefeng.com:8080</code>的访问，因此访问成功，打印出API的返回值：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/web/cors/cors-ok.png" alt="cors-ok"></p>
<h3 id="练习-5">练习</h3>
<p>使用CORS控制跨域。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/web/cors/spring-web-mvc-cors.zip">下载练习</a></p>
<h3 id="小结-5">小结</h3>
<p>CORS可以控制指定域的页面JavaScript能否访问API。</p>
<p>在开发应用程序的时候，经常会遇到支持多语言的需求，这种支持多语言的功能称之为国际化，英文是internationalization，缩写为i18n（因为首字母i和末字母n中间有18个字母）。</p>
<p>还有针对特定地区的本地化功能，英文是localization，缩写为L10n，本地化是指根据地区调整类似姓名、日期的显示等。</p>
<p>也有把上面两者合称为全球化，英文是globalization，缩写为g11n。</p>
<p>在Java中，支持多语言和本地化是通过<code>MessageFormat</code>配合<code>Locale</code>实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MessageFormat</span></span><br><span class="line"><span class="keyword">import</span> java.text.MessageFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Time</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">123.5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        Object[] arguments = &#123; price, number &#125;;</span><br><span class="line">        <span class="type">MessageFormat</span> <span class="variable">mfUS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageFormat</span>(<span class="string">&quot;Pay &#123;0,number,currency&#125; for &#123;1&#125; books.&quot;</span>, Locale.US);</span><br><span class="line">        System.out.println(mfUS.format(arguments));</span><br><span class="line">        <span class="type">MessageFormat</span> <span class="variable">mfZH</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageFormat</span>(<span class="string">&quot;&#123;1&#125;本书一共&#123;0,number,currency&#125;。&quot;</span>, Locale.CHINA);</span><br><span class="line">        System.out.println(mfZH.format(arguments));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于Web应用程序，要实现国际化功能，主要是渲染View的时候，要把各种语言的资源文件提出来，这样，不同的用户访问同一个页面时，显示的语言就是不同的。</p>
<p>我们来看看在Spring MVC应用程序中如何实现国际化。</p>
<h3 id="获取Locale">获取Locale</h3>
<p>实现国际化的第一步是获取到用户的<code>Locale</code>。在Web应用程序中，HTTP规范规定了浏览器会在请求中携带<code>Accept-Language</code>头，用来指示用户浏览器设定的语言顺序，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Language: zh-CN,zh;q=0.8,en;q=0.2</span><br></pre></td></tr></table></figure>
<p>上述HTTP请求头表示优先选择简体中文，其次选择中文，最后选择英文。<code>q</code>表示权重，解析后我们可获得一个根据优先级排序的语言列表，把它转换为Java的<code>Locale</code>，即获得了用户的<code>Locale</code>。大多数框架通常只返回权重最高的<code>Locale</code>。</p>
<p>Spring MVC通过<code>LocaleResolver</code>来自动从<code>HttpServletRequest</code>中获取<code>Locale</code>。有多种<code>LocaleResolver</code>的实现类，其中最常用的是<code>CookieLocaleResolver</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">LocaleResolver <span class="title function_">createLocaleResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">clr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CookieLocaleResolver</span>();</span><br><span class="line">    clr.setDefaultLocale(Locale.ENGLISH);</span><br><span class="line">    clr.setDefaultTimeZone(TimeZone.getDefault());</span><br><span class="line">    <span class="keyword">return</span> clr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CookieLocaleResolver</code>从<code>HttpServletRequest</code>中获取<code>Locale</code>时，首先根据一个特定的Cookie判断是否指定了<code>Locale</code>，如果没有，就从HTTP头获取，如果还没有，就返回默认的<code>Locale</code>。</p>
<p>当用户第一次访问网站时，<code>CookieLocaleResolver</code>只能从HTTP头获取<code>Locale</code>，即使用浏览器的默认语言。通常网站也允许用户自己选择语言，此时，<code>CookieLocaleResolver</code>就会把用户选择的语言存放到Cookie中，下一次访问时，就会返回用户上次选择的语言而不是浏览器默认语言。</p>
<h3 id="提取资源文件">提取资源文件</h3>
<p>第二步是把写死在模板中的字符串以资源文件的方式存储在外部。对于多语言，主文件名如果命名为<code>messages</code>，那么资源文件必须按如下方式命名并放入classpath中：</p>
<ul>
<li>默认语言，文件名必须为<code>messages.properties</code>；</li>
<li>简体中文，Locale是<code>zh_CN</code>，文件名必须为<code>messages_zh_CN.properties</code>；</li>
<li>日文，Locale是<code>ja_JP</code>，文件名必须为<code>messages_ja_JP.properties</code>；</li>
<li>其它更多语言……</li>
</ul>
<p>每个资源文件都有相同的key，例如，默认语言是英文，文件<code>messages.properties</code>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">language.select=Language</span><br><span class="line">home=Home</span><br><span class="line">signin=Sign In</span><br><span class="line">copyright=Copyright©&#123;0,number,#&#125;</span><br></pre></td></tr></table></figure>
<p>文件<code>messages_zh_CN.properties</code>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">language.select=语言</span><br><span class="line">home=首页</span><br><span class="line">signin=登录</span><br><span class="line">copyright=版权所有©&#123;0,number,#&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建MessageSource">创建MessageSource</h3>
<p>第三步是创建一个Spring提供的<code>MessageSource</code>实例，它自动读取所有的<code>.properties</code>文件，并提供一个统一接口来实现“翻译”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code, arguments, locale:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> messageSource.getMessage(<span class="string">&quot;signin&quot;</span>, <span class="literal">null</span>, locale);</span><br></pre></td></tr></table></figure>
<p>其中，<code>signin</code>是我们在<code>.properties</code>文件中定义的key，第二个参数是<code>Object[]</code>数组作为格式化时传入的参数，最后一个参数就是获取的用户<code>Locale</code>实例。</p>
<p>创建<code>MessageSource</code>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;i18n&quot;)</span></span><br><span class="line">MessageSource <span class="title function_">createMessageSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">messageSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceBundleMessageSource</span>();</span><br><span class="line">    <span class="comment">// 指定文件是UTF-8编码:</span></span><br><span class="line">    messageSource.setDefaultEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="comment">// 指定主文件名:</span></span><br><span class="line">    messageSource.setBasename(<span class="string">&quot;messages&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> messageSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>ResourceBundleMessageSource</code>会自动根据主文件名自动把所有相关语言的资源文件都读进来。</p>
<p>再注意到Spring容器会创建不只一个<code>MessageSource</code>实例，我们自己创建的这个<code>MessageSource</code>是专门给页面国际化使用的，因此命名为<code>i18n</code>，不会与其它<code>MessageSource</code>实例冲突。</p>
<h3 id="实现多语言">实现多语言</h3>
<p>要在View中使用<code>MessageSource</code>加上<code>Locale</code>输出多语言，我们通过编写一个<code>MvcInterceptor</code>，把相关资源注入到<code>ModelAndView</code>中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    LocaleResolver localeResolver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意注入的MessageSource名称是i18n:</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;i18n&quot;)</span></span><br><span class="line">    MessageSource messageSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (modelAndView != <span class="literal">null</span> <span class="comment">// 返回了ModelAndView</span></span><br><span class="line">            &amp;&amp; modelAndView.getViewName() != <span class="literal">null</span> <span class="comment">// 设置了View</span></span><br><span class="line">            &amp;&amp; !modelAndView.getViewName().startsWith(<span class="string">&quot;redirect:&quot;</span>) <span class="comment">// 不是重定向</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 解析用户的Locale:</span></span><br><span class="line">            <span class="type">Locale</span> <span class="variable">locale</span> <span class="operator">=</span> localeResolver.resolveLocale(request);</span><br><span class="line">            <span class="comment">// 放入Model:</span></span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;__messageSource__&quot;</span>, messageSource);</span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;__locale__&quot;</span>, locale);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要忘了在<code>WebMvcConfigurer</code>中注册<code>MvcInterceptor</code>。现在，就可以在View中调用<code>MessageSource.getMessage()</code>方法来实现多语言：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/signin&quot;</span>&gt;</span>&#123;&#123; __messageSource__.getMessage(&#x27;signin&#x27;, null, __locale__) &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述这种写法虽然可行，但格式太复杂了。使用View时，要根据每个特定的View引擎定制国际化函数。在Pebble中，我们可以封装一个国际化函数，名称就是下划线<code>_</code>，改造一下创建<code>ViewResolver</code>的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">ViewResolver <span class="title function_">createViewResolver</span><span class="params">(<span class="meta">@Autowired</span> ServletContext servletContext, <span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;i18n&quot;)</span> MessageSource messageSource)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PebbleEngine</span>.Builder()</span><br><span class="line">            .autoEscaping(<span class="literal">true</span>)</span><br><span class="line">            .cacheActive(<span class="literal">false</span>)</span><br><span class="line">            .loader(<span class="keyword">new</span> <span class="title class_">Servlet5Loader</span>(servletContext))</span><br><span class="line">            <span class="comment">// 添加扩展:</span></span><br><span class="line">            .extension(createExtension(messageSource))</span><br><span class="line">            .build();</span><br><span class="line">    <span class="type">var</span> <span class="variable">viewResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PebbleViewResolver</span>();</span><br><span class="line">    viewResolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">    viewResolver.setSuffix(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    viewResolver.setPebbleEngine(engine);</span><br><span class="line">    <span class="keyword">return</span> viewResolver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Extension <span class="title function_">createExtension</span><span class="params">(MessageSource messageSource)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AbstractExtension</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Map&lt;String, Function&gt; <span class="title function_">getFunctions</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Map.of(<span class="string">&quot;_&quot;</span>, <span class="keyword">new</span> <span class="title class_">Function</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(Map&lt;String, Object&gt; args, PebbleTemplate self, EvaluationContext context, <span class="type">int</span> lineNumber)</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> (String) args.get(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">                    List&lt;Object&gt; arguments = <span class="built_in">this</span>.extractArguments(args);</span><br><span class="line">                    <span class="type">Locale</span> <span class="variable">locale</span> <span class="operator">=</span> (Locale) context.getVariable(<span class="string">&quot;__locale__&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> messageSource.getMessage(key, arguments.toArray(), <span class="string">&quot;???&quot;</span> + key + <span class="string">&quot;???&quot;</span>, locale);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">private</span> List&lt;Object&gt; <span class="title function_">extractArguments</span><span class="params">(Map&lt;String, Object&gt; args)</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                    List&lt;Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    <span class="keyword">while</span> (args.containsKey(String.valueOf(i))) &#123;</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> args.get(String.valueOf(i));</span><br><span class="line">                        arguments.add(param);</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> arguments;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getArgumentNames</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们可以把多语言页面改写为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/signin&quot;</span>&gt;</span>&#123;&#123; _(&#x27;signin&#x27;) &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果是带参数的多语言，需要把参数传进去：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>&#123;&#123; _(&#x27;copyright&#x27;, 2020) &#125;&#125;<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用其它View引擎时，也应当根据引擎接口实现更方便的语法。</p>
<h3 id="切换Locale">切换Locale</h3>
<p>最后，我们需要允许用户手动切换<code>Locale</code>，编写一个<code>LocaleController</code>来实现该功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocaleController</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    LocaleResolver localeResolver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/locale/&#123;lo&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">setLocale</span><span class="params">(<span class="meta">@PathVariable(&quot;lo&quot;)</span> String lo, HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据传入的lo创建Locale实例:</span></span><br><span class="line">        <span class="type">Locale</span> <span class="variable">locale</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> lo.indexOf(<span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">lang</span> <span class="operator">=</span> lo.substring(<span class="number">0</span>, pos);</span><br><span class="line">            <span class="type">String</span> <span class="variable">country</span> <span class="operator">=</span> lo.substring(pos + <span class="number">1</span>);</span><br><span class="line">            locale = <span class="keyword">new</span> <span class="title class_">Locale</span>(lang, country);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            locale = <span class="keyword">new</span> <span class="title class_">Locale</span>(lo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设定此Locale:</span></span><br><span class="line">        localeResolver.setLocale(request, response, locale);</span><br><span class="line">        logger.info(<span class="string">&quot;locale is set to &#123;&#125;.&quot;</span>, locale);</span><br><span class="line">        <span class="comment">// 刷新页面:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">referer</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Referer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:&quot;</span> + (referer == <span class="literal">null</span> ? <span class="string">&quot;/&quot;</span> : referer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在页面设计中，通常在右上角给用户提供一个语言选择列表，来看看效果：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/web/i18n/en.png" alt="i18n-en"></p>
<p>切换到中文：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/web/i18n/zh.png" alt="i18n-zh-cn"></p>
<h3 id="练习-6">练习</h3>
<p>在Spring MVC程序中实现国际化。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/web/i18n/spring-web-mvc-i18n.zip">下载练习</a></p>
<h3 id="小结-6">小结</h3>
<p>多语言支持需要从HTTP请求中解析用户的Locale，然后针对不同Locale显示不同的语言；</p>
<p>Spring MVC应用程序通过<code>MessageSource</code>和<code>LocaleResolver</code>，配合View实现国际化。</p>
<p>在Servlet模型中，每个请求都是由某个线程处理，然后，将响应写入IO流，发送给客户端。从开始处理请求，到写入响应完成，都是在同一个线程中处理的。</p>
<p>实现Servlet容器的时候，只要每处理一个请求，就创建一个新线程处理它，就能保证正确实现了Servlet线程模型。在实际产品中，例如Tomcat，总是通过线程池来处理请求，它仍然符合一个请求从头到尾都由某一个线程处理。</p>
<p>这种线程模型非常重要，因为Spring的JDBC事务是基于<code>ThreadLocal</code>实现的，如果在处理过程中，一会由线程A处理，一会又由线程B处理，那事务就全乱套了。此外，很多安全认证，也是基于<code>ThreadLocal</code>实现的，可以保证在处理请求的过程中，各个线程互不影响。</p>
<p>但是，如果一个请求处理的时间较长，例如几秒钟甚至更长，那么，这种基于线程池的同步模型很快就会把所有线程耗尽，导致服务器无法响应新的请求。如果把长时间处理的请求改为异步处理，那么线程池的利用率就会大大提高。Servlet从3.0规范开始添加了异步支持，允许对一个请求进行异步处理。</p>
<p>我们先来看看在Spring MVC中如何实现对请求进行异步处理的逻辑。首先建立一个Web工程，然后编辑<code>web.xml</code>文件如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>org.springframework.web.context.support.AnnotationConfigWebApplicationContext<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.itranswarp.learnjava.AppConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>和前面普通的MVC程序相比，这个<code>web.xml</code>主要对<code>DispatcherServlet</code>的配置多了一个<code>&lt;async-supported&gt;</code>，默认值是<code>false</code>，必须明确写成<code>true</code>，这样Servlet容器才会支持async处理。</p>
<p>下一步就是在Controller中编写async处理逻辑。我们以<code>ApiController</code>为例，演示如何异步处理请求。</p>
<p>第一种async处理方式是返回一个<code>Callable</code>，Spring MVC自动把返回的<code>Callable</code>放入线程池执行，等待结果返回后再写入响应：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Callable&lt;List&lt;User&gt;&gt; <span class="title function_">users</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">        <span class="comment">// 模拟3秒耗时:</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userService.getUsers();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种async处理方式是返回一个<code>DeferredResult</code>对象，然后在另一个线程中，设置此对象的值并写入响应：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DeferredResult&lt;User&gt; <span class="title function_">user</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span> &#123;</span><br><span class="line">    DeferredResult&lt;User&gt; result = <span class="keyword">new</span> <span class="title class_">DeferredResult</span>&lt;&gt;(<span class="number">3000L</span>); <span class="comment">// 3秒超时</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 等待1秒:</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getUserById(id);</span><br><span class="line">            <span class="comment">// 设置正常结果并由Spring MVC写入Response:</span></span><br><span class="line">            result.setResult(user);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 设置错误结果并由Spring MVC写入Response:</span></span><br><span class="line">            result.setErrorResult(Map.of(<span class="string">&quot;error&quot;</span>, e.getClass().getSimpleName(), <span class="string">&quot;message&quot;</span>, e.getMessage()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>DeferredResult</code>时，可以设置超时，超时会自动返回超时错误响应。在另一个线程中，可以调用<code>setResult()</code>写入结果，也可以调用<code>setErrorResult()</code>写入一个错误结果。</p>
<p>运行程序，当我们访问<code>http://localhost:8080/api/users/1</code>时，假定用户存在，则浏览器在1秒后返回结果：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/web/async/deferred.png" alt="deferred-result-ok"></p>
<p>访问一个不存在的User ID，则等待1秒后返回错误结果：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/web/async/deferred2.png" alt="deferred-result-error"></p>
<h3 id="使用Filter">使用Filter</h3>
<p>当我们使用async模式处理请求时，原有的Filter也可以工作，但我们必须在<code>web.xml</code>中添加<code>&lt;async-supported&gt;</code>并设置为<code>true</code>。我们用两个Filter：SyncFilter和AsyncFilter分别测试：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>sync-filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.itranswarp.learnjava.web.SyncFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>async-filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.itranswarp.learnjava.web.AsyncFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>sync-filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/api/version<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>async-filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/api/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个声明为支持<code>&lt;async-supported&gt;</code>的Filter既可以过滤async处理请求，也可以过滤正常的同步处理请求，而未声明<code>&lt;async-supported&gt;</code>的Filter无法支持async请求，如果一个普通的Filter遇到async请求时，会直接报错，因此，务必注意普通Filter的<code>&lt;url-pattern&gt;</code>不要匹配async请求路径。</p>
<p>在<code>logback.xml</code>配置文件中，我们把输出格式加上<code>[%thread]</code>，可以输出当前线程的名称：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于同步请求，例如<code>/api/version</code>，我们可以看到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.SyncFilter - start SyncFilter...</span><br><span class="line">2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.AsyncFilter - start AsyncFilter...</span><br><span class="line">2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.ApiController - get version...</span><br><span class="line">2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.AsyncFilter - end AsyncFilter.</span><br><span class="line">2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.SyncFilter - end SyncFilter.</span><br></pre></td></tr></table></figure>
<p>可见，每个Filter和<code>ApiController</code>都是由同一个线程执行。</p>
<p>对于异步请求，例如<code>/api/users</code>，我们可以看到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2020-05-16 11:23:49 [http-nio-8080-exec-4] INFO  c.i.learnjava.web.AsyncFilter - start AsyncFilter...</span><br><span class="line">2020-05-16 11:23:49 [http-nio-8080-exec-4] INFO  c.i.learnjava.web.ApiController - get users...</span><br><span class="line">2020-05-16 11:23:49 [http-nio-8080-exec-4] INFO  c.i.learnjava.web.AsyncFilter - end AsyncFilter.</span><br><span class="line">2020-05-16 11:23:52 [MvcAsync1] INFO  c.i.learnjava.web.ApiController - return users...</span><br></pre></td></tr></table></figure>
<p>可见，<code>AsyncFilter</code>和<code>ApiController</code>是由同一个线程执行的，但是，返回响应的是另一个线程。</p>
<p>对<code>DeferredResult</code>测试，可以看到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020-05-16 11:25:24 [http-nio-8080-exec-8] INFO  c.i.learnjava.web.AsyncFilter - start AsyncFilter...</span><br><span class="line">2020-05-16 11:25:24 [http-nio-8080-exec-8] INFO  c.i.learnjava.web.AsyncFilter - end AsyncFilter.</span><br><span class="line">2020-05-16 11:25:25 [Thread-2] INFO  c.i.learnjava.web.ApiController - deferred result is set.</span><br></pre></td></tr></table></figure>
<p>同样，返回响应的是另一个线程。</p>
<p>在实际使用时，经常用到的就是<code>DeferredResult</code>，因为返回<code>DeferredResult</code>时，可以设置超时、正常结果和错误结果，易于编写比较灵活的逻辑。</p>
<p>使用async异步处理响应时，要时刻牢记，在另一个异步线程中的事务和Controller方法中执行的事务不是同一个事务，在Controller中绑定的<code>ThreadLocal</code>信息也无法在异步线程中获取。</p>
<p>此外，Servlet 3.0规范添加的异步支持是针对同步模型打了一个“补丁”，虽然可以异步处理请求，但高并发异步请求时，它的处理效率并不高，因为这种异步模型并没有用到真正的“原生”异步。Java标准库提供了封装操作系统的异步IO包<code>java.nio</code>，是真正的多路复用IO模型，可以用少量线程支持大量并发。使用NIO编程复杂度比同步IO高很多，因此我们很少直接使用NIO。相反，大部分需要高性能异步IO的应用程序会选择<a target="_blank" rel="noopener" href="https://netty.io/">Netty</a>这样的框架，它基于NIO提供了更易于使用的API，方便开发异步应用程序。</p>
<h3 id="练习-7">练习</h3>
<p>使用Spring MVC实现异步处理请求。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/web/async/spring-web-mvc-async.zip">下载练习</a></p>
<h3 id="小结-7">小结</h3>
<p>在Spring MVC中异步处理请求需要正确配置<code>web.xml</code>，并返回<code>Callable</code>或<code>DeferredResult</code>对象。</p>
<p>WebSocket是一种基于HTTP的长链接技术。传统的HTTP协议是一种请求-响应模型，如果浏览器不发送请求，那么服务器无法主动给浏览器推送数据。如果需要定期给浏览器推送数据，例如股票行情，或者不定期给浏览器推送数据，例如在线聊天，基于HTTP协议实现这类需求，只能依靠浏览器的JavaScript定时轮询，效率很低且实时性不高。</p>
<p>因为HTTP本身是基于TCP连接的，所以，WebSocket在HTTP协议的基础上做了一个简单的升级，即建立TCP连接后，浏览器发送请求时，附带几个头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure>
<p>就表示客户端希望升级连接，变成长连接的WebSocket，服务器返回升级成功的响应：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure>
<p>收到成功响应后表示WebSocket“握手”成功，这样，代表WebSocket的这个TCP连接将不会被服务器关闭，而是一直保持，服务器可随时向浏览器推送消息，浏览器也可随时向服务器推送消息。双方推送的消息既可以是文本消息，也可以是二进制消息，一般来说，绝大部分应用程序会推送基于JSON的文本消息。</p>
<p>现代浏览器都已经支持WebSocket协议，服务器则需要底层框架支持。Java的Servlet规范从3.1开始支持WebSocket，所以，必须选择支持Servlet 3.1或更高规范的Servlet容器，才能支持WebSocket。最新版本的Tomcat、Jetty等开源服务器均支持WebSocket。</p>
<p>我们以实际代码演示如何在Spring MVC中实现对WebSocket的支持。首先，我们需要在<code>pom.xml</code>中加入以下依赖：</p>
<ul>
<li>org.apache.tomcat.embed:tomcat-embed-websocket:10.1.1</li>
<li>org.springframework:spring-websocket:6.0.0</li>
</ul>
<p>第一项是嵌入式Tomcat支持WebSocket的组件，第二项是Spring封装的支持WebSocket的接口。</p>
<p>接下来，我们需要在<code>AppConfig</code>中加入Spring Web对WebSocket的配置，先增加一个<code>@EnableWebSocket</code>注解，然后创建一个<code>WebSocketConfigurer</code>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span> <span class="comment">// 启用WebSocket支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    WebSocketConfigurer <span class="title function_">createWebSocketConfigurer</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Autowired</span> ChatHandler chatHandler,</span></span><br><span class="line"><span class="params">            <span class="meta">@Autowired</span> ChatHandshakeInterceptor chatInterceptor)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebSocketConfigurer</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> &#123;</span><br><span class="line">                <span class="comment">// 把URL与指定的WebSocketHandler关联，可关联多个:</span></span><br><span class="line">                registry.addHandler(chatHandler, <span class="string">&quot;/chat&quot;</span>).addInterceptors(chatInterceptor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此实例在内部通过<code>WebSocketHandlerRegistry</code>注册能处理WebSocket的<code>WebSocketHandler</code>，以及可选的WebSocket拦截器<code>HandshakeInterceptor</code>。我们注入的这两个类都是自己编写的业务逻辑，后面我们详细讨论如何编写它们，这里只需关注浏览器连接到WebSocket的URL是<code>/chat</code>。</p>
<h3 id="处理WebSocket连接">处理WebSocket连接</h3>
<p>和处理普通HTTP请求不同，没法用一个方法处理一个URL。Spring提供了<code>TextWebSocketHandler</code>和<code>BinaryWebSocketHandler</code>分别处理文本消息和二进制消息，这里我们选择文本消息作为聊天室的协议，因此，<code>ChatHandler</code>需要继承自<code>TextWebSocketHandler</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatHandler</span> <span class="keyword">extends</span> <span class="title class_">TextWebSocketHandler</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当浏览器请求一个WebSocket连接后，如果成功建立连接，Spring会自动调用<code>afterConnectionEstablished()</code>方法，任何原因导致WebSocket连接中断时，Spring会自动调用<code>afterConnectionClosed</code>方法，因此，覆写这两个方法即可处理连接成功和结束后的业务逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatHandler</span> <span class="keyword">extends</span> <span class="title class_">TextWebSocketHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 保存所有Client的WebSocket会话实例:</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, WebSocketSession&gt; clients = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 新会话根据ID放入Map:</span></span><br><span class="line">        clients.put(session.getId(), session);</span><br><span class="line">        session.getAttributes().put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Guest1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus status)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        clients.remove(session.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个WebSocket会话以<code>WebSocketSession</code>表示，且已分配唯一ID。和WebSocket相关的数据，例如用户名称等，均可放入关联的<code>getAttributes()</code>中。</p>
<p>用实例变量<code>clients</code>持有当前所有的<code>WebSocketSession</code>是为了广播，即向所有用户推送同一消息时，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="type">TextMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextMessage</span>(json);</span><br><span class="line"><span class="keyword">for</span> (String id : clients.keySet()) &#123;</span><br><span class="line">    <span class="type">WebSocketSession</span> <span class="variable">session</span> <span class="operator">=</span> clients.get(id);</span><br><span class="line">    session.sendMessage(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发送的消息是序列化后的JSON，可以用<code>ChatMessage</code>表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatMessage</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">long</span> timestamp;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每收到一个用户的消息后，我们就需要广播给所有用户：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatHandler</span> <span class="keyword">extends</span> <span class="title class_">TextWebSocketHandler</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> message.getPayload();</span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> ... <span class="comment">// 根据输入消息构造待发送消息</span></span><br><span class="line">        broadcastMessage(r); <span class="comment">// 推送给所有用户</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要推送给指定的几个用户，那就需要在<code>clients</code>中根据条件查找出某些<code>WebSocketSession</code>，然后发送消息。</p>
<p>注意到我们在注册WebSocket时还传入了一个<code>ChatHandshakeInterceptor</code>，这个类实际上可以从<code>HttpSessionHandshakeInterceptor</code>继承，它的主要作用是在WebSocket建立连接后，把HttpSession的一些属性复制到WebSocketSession，例如，用户的登录信息等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatHandshakeInterceptor</span> <span class="keyword">extends</span> <span class="title class_">HttpSessionHandshakeInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChatHandshakeInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 指定从HttpSession复制属性到WebSocketSession:</span></span><br><span class="line">        <span class="built_in">super</span>(List.of(UserController.KEY_USER));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在<code>ChatHandler</code>中，可以从<code>WebSocketSession.getAttributes()</code>中获取到复制过来的属性。</p>
<h3 id="客户端开发">客户端开发</h3>
<p>在完成了服务器端的开发后，我们还需要在页面编写一点JavaScript逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建WebSocket连接:</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://&#x27;</span> + location.<span class="property">host</span> + <span class="string">&#x27;/chat&#x27;</span>);</span><br><span class="line"><span class="comment">// 连接成功时:</span></span><br><span class="line">ws.<span class="title function_">addEventListener</span>(<span class="string">&#x27;open&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;websocket connected.&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 收到消息时:</span></span><br><span class="line">ws.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;message: &#x27;</span> + event.<span class="property">data</span>);</span><br><span class="line">    <span class="keyword">var</span> msgs = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(event.<span class="property">data</span>);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 连接关闭时:</span></span><br><span class="line">ws.<span class="title function_">addEventListener</span>(<span class="string">&#x27;close&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;websocket closed.&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 绑定到全局变量:</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">chatWs</span> = ws;</span><br></pre></td></tr></table></figure>
<p>用户可以在连接成功后任何时候给服务器发送消息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inputText = <span class="string">&#x27;Hello, WebSocket.&#x27;</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">chatWs</span>.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">text</span>: inputText&#125;));</span><br></pre></td></tr></table></figure>
<p>最后，连调浏览器和服务器端，如果一切无误，可以开多个不同的浏览器测试WebSocket的推送和广播。</p>
<p>和上一节我们介绍的异步处理类似，Servlet的线程模型并不适合大规模的长链接。基于NIO的Netty等框架更适合处理WebSocket长链接，我们将在后面介绍。</p>
<h3 id="练习-8">练习</h3>
<p>使用WebSocket编写一个聊天室。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/web/websocket/spring-web-mvc-websocket.zip">下载练习</a></p>
<h3 id="小结-8">小结</h3>
<p>在Servlet中使用WebSocket需要3.1及以上版本；</p>
<p>通过<code>spring-websocket</code>可以简化WebSocket的开发。</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">標籤</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/Java/" rel="tag">Java</a> <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/Spirng/" rel="tag">Spirng</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/"
                    data-tooltip="JAVA-Spring开发-集成第三方组件"
                    aria-label="上一篇: JAVA-Spring开发-集成第三方组件"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../24/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"
                    data-tooltip="JAVA-Spring开发-访问数据库"
                    aria-label="下一篇: JAVA-Spring开发-访问数据库"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2018/02/25/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2018/02/25/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2018/02/25/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2018/02/25/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/"
                    data-tooltip="JAVA-Spring开发-集成第三方组件"
                    aria-label="上一篇: JAVA-Spring开发-集成第三方组件"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../24/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"
                    data-tooltip="JAVA-Spring开发-访问数据库"
                    aria-label="下一篇: JAVA-Spring开发-访问数据库"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2018/02/25/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2018/02/25/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2018/02/25/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2018/02/25/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2018/02/25/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/"
                        aria-label="分享到 Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2018/02/25/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/"
                        aria-label="分享到 Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2018/02/25/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/"
                        aria-label="global.share_on_linkedin"
                    >
                        <i class="fab fa-linkedin" aria-hidden="true"></i><span>global.share_on_linkedin</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2018/02/25/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/"
                        aria-label="分享到 Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 210 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
