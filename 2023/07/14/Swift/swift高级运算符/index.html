
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>swift高级运算符 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg"},"articleBody":"高级运算符\n除了之前介绍过的 基本运算符，Swift 还提供了数种可以对数值进行复杂运算的高级运算符。它们包含了在 C 和 Objective-C 中已经被大家所熟知的位运算符和移位运算符。\n与 C 语言中的算术运算符不同，Swift 中的算术运算符默认是不会溢出的。所有溢出行为都会被捕获并报告为错误。如果想让系统允许溢出行为，可以选择使用 Swift 中另一套默认支持溢出的运算符，比如溢出加法运算符（&amp;+）。所有的这些溢出运算符都是以 &amp; 开头的。\n自定义结构体、类和枚举时，如果也为它们提供标准 Swift 运算符的实现，将会非常有用。在 Swift 中为这些运算符提供自定义的实现非常简单，运算符也会针对不同类型使用对应实现。\n我们不用被预定义的运算符所限制。在 Swift 中可以自由地定义中缀、前缀、后缀和赋值运算符，它们具有自定义的优先级与关联值。这些运算符在代码中可以像预定义的运算符一样使用，你甚至可以扩展已有的类型以支持自定义运算符。\n位运算符\n位运算符可以操作数据结构中每个独立的比特位。它们通常被用在底层开发中，比如图形编程和创建设备驱动。位运算符在处理外部资源的原始数据时也十分有用，比如对自定义通信协议传输的数据进行编码和解码。\nSwift 支持 C 语言中的全部位运算符，接下来会一一介绍。\nBitwise NOT Operator（按位取反运算符）\n*按位取反运算符（~）*对一个数值的全部比特位进行取反：\n\n按位取反运算符是一个前缀运算符，直接放在运算数之前，并且它们之间不能添加任何空格：\n12let initialBits: UInt8 = 0b00001111let invertedBits = ~initialBits // 等于 0b11110000\nUInt8 类型的整数有 8 个比特位，可以存储 0 ~ 255 之间的任意整数。这个例子初始化了一个 UInt8 类型的整数，并赋值为二进制的 00001111，它的前 4 位为 0，后 4 位为 1。这个值等价于十进制的 15。\n接着使用按位取反运算符创建了一个名为 invertedBits 的常量，这个常量的值与全部位取反后的 initialBits 相等。即所有的 0 都变成了 1，同时所有的 1 都变成 0。invertedBits 的二进制值为 11110000，等价于无符号十进制数的 240。\nBitwise AND Operator（按位与运算符）\n按位与运算符（&amp;） 对两个数的比特位进行合并。它返回一个新的数，只有当两个数的对应位都为 1 的时候，新数的对应位才为 1：\n\n在下面的示例当中，firstSixBits 和 lastSixBits 中间 4 个位的值都为 1。使用按位与运算符之后，得到二进制数值 00111100，等价于无符号十进制数的 60：\n123let firstSixBits: UInt8 = 0b11111100let lastSixBits: UInt8  = 0b00111111let middleFourBits = firstSixBits &amp; lastSixBits // 等于 00111100\nBitwise OR Operator（按位或运算符）\n按位或运算符（|）可以对两个数的比特位进行比较。它返回一个新的数，只要两个数的对应位中有任意一个为 1 时，新数的对应位就为 1：\n\n在下面的示例中，someBits 和 moreBits 存在不同的位被设置为 1。使用按位或运算符之后，得到二进制数值 11111110，等价于无符号十进制数的 254：\n123let someBits: UInt8 = 0b10110010let moreBits: UInt8 = 0b01011110let combinedbits = someBits | moreBits // 等于 11111110\nBitwise XOR Operator（按位异或运算符）\n按位异或运算符，或称“排外的或运算符”（^），可以对两个数的比特位进行比较。它返回一个新的数，当两个数的对应位不相同时，新数的对应位就为 1，并且对应位相同时则为 0：\n\n在下面的示例当中，firstBits 和 otherBits 都有一个自己为 1，而对方为 0 的位。按位异或运算符将新数的这两个位都设置为 1。在其余的位上 firstBits 和 otherBits 是相同的，所以设置为 0：\n123let firstBits: UInt8 = 0b00010100let otherBits: UInt8 = 0b00000101let outputBits = firstBits ^ otherBits // 等于 00010001\nBitwise Left and Right Shift Operators（按位左移、右移运算符）\n按位左移运算符（&lt;&lt;） 和 *按位右移运算符（&gt;&gt;）*可以对一个数的所有位进行指定位数的左移和右移，但是需要遵守下面定义的规则。\n对一个数进行按位左移或按位右移，相当于对这个数进行乘以 2 或除以 2 的运算。将一个整数左移一位，等价于将这个数乘以 2，同样地，将一个整数右移一位，等价于将这个数除以 2。\n无符号整数的移位运算\n对无符号整数进行移位的规则如下：\n\n已存在的位按指定的位数进行左移和右移。\n任何因移动而超出整型存储范围的位都会被丢弃。\n用 0 来填充移位后产生的空白位。\n\n这种方法称为逻辑移位。\n以下这张图展示了 11111111 &lt;&lt; 1（即把 11111111 向左移动 1 位），和 11111111 &gt;&gt; 1（即把 11111111 向右移动 1 位）的结果。蓝色的数字是被移位的，灰色的数字是被抛弃的，橙色的 0 则是被填充进来的：\n\n下面的代码演示了 Swift 中的移位运算：\n123456let shiftBits: UInt8 = 4 // 即二进制的 00000100shiftBits &lt;&lt; 1           // 00001000shiftBits &lt;&lt; 2           // 00010000shiftBits &lt;&lt; 5           // 10000000shiftBits &lt;&lt; 6           // 00000000shiftBits &gt;&gt; 2           // 00000001\n可以使用移位运算对其他的数据类型进行编码和解码：\n1234let pink: UInt32 = 0xCC6699let redComponent = (pink &amp; 0xFF0000) &gt;&gt; 16  // redComponent 是 0xCC，即 204let greenComponent = (pink &amp; 0x00FF00) &gt;&gt; 8 // greenComponent 是 0x66， 即 102let blueComponent = pink &amp; 0x0000FF         // blueComponent 是 0x99，即 153\n这个示例使用了一个命名为 pink 的 UInt32 型常量来存储 Cascading Style Sheets（CSS）中粉色的颜色值。该 CSS 的颜色值 #CC6699，在 Swift 中表示为十六进制的 0xCC6699。然后利用按位与运算符（&amp;）和按位右移运算符（&gt;&gt;）从这个颜色值中分解出红（CC）、绿（66）以及蓝（99）三个部分。\n红色部分是通过对 0xCC6699 和 0xFF0000 进行按位与运算后得到的。0xFF0000 中的 0 部分“掩盖”了 OxCC6699 中的第二、第三个字节，使得数值中的 6699 被忽略，只留下 0xCC0000。\n然后，将这个数向右移动 16 位（&gt;&gt; 16）。十六进制中每两个字符占用 8 个比特位，所以移动 16 位后 0xCC0000 就变为 0x0000CC。这个数和 0xCC 是等同的，也就是十进制数值的 204。\n同样的，绿色部分通过对 0xCC6699 和 0x00FF00 进行按位与运算得到 0x006600。然后将这个数向右移动 8 位，得到 0x66，也就是十进制数值的 102。\n最后，蓝色部分通过对 0xCC6699 和 0x0000FF 进行按位与运算得到 0x000099。这里不需要再向右移位，而 0x000099 也就是 0x99 ，也就是十进制数值的 153。\n有符号整数的移位运算\n对比无符号整数，有符号整数的移位运算相对复杂得多，这种复杂性源于有符号整数的二进制表现形式。（为了简单起见，以下的示例都是基于 8 比特的有符号整数，但是其中的原理对任何位数的有符号整数都是通用的。）\n有符号整数使用第 1 个比特位（通常被称为符号位）来表示这个数的正负。符号位为 0 代表正数，为 1 代表负数。\n其余的比特位（通常被称为数值位）存储了实际的值。有符号正整数和无符号数的存储方式是一样的，都是从 0 开始算起。这是值为 4 的 Int8 型整数的二进制位表现形式：\n\n符号位为 0（代表这是一个“正数”），另外 7 位则代表了十进制数值 4 的二进制表示。\n负数的存储方式略有不同。它存储 2 的 n 次方减去其实际值的绝对值，这里的 n 是数值位的位数。一个 8 比特位的数有 7 个比特位是数值位，所以是 2 的 7 次方，即 128。\n这是值为 -4 的 Int8 型整数的二进制表现形式：\n\n这次的符号位为 1，说明这是一个负数，另外 7 个位则代表了数值 124（即 128 - 4）的二进制表示：\n\n负数的表示通常被称为二进制补码。用这种方法来表示负数乍看起来有点奇怪，但它有几个优点。\n首先，如果想对 -1 和 -4 进行加法运算，我们只需要对这两个数的全部 8 个比特位执行标准的二进制相加（包括符号位），并且将计算结果中超出 8 位的数值丢弃：\n\n其次，使用二进制补码可以使负数的按位左移和右移运算得到跟正数同样的效果，即每向左移一位就将自身的数值乘以 2，每向右一位就将自身的数值除以 2。要达到此目的，对有符号整数的右移有一个额外的规则：当对有符号整数进行按位右移运算时，遵循与无符号整数相同的规则，但是对于移位产生的空白位使用符号位进行填充，而不是用 0。\n\n这个行为可以确保有符号整数的符号位不会因为右移运算而改变，这通常被称为算术移位。\n由于正数和负数的特殊存储方式，在对它们进行右移的时候，会使它们越来越接近 0。在移位的过程中保持符号位不变，意味着负整数在接近 0 的过程中会一直保持为负。\n溢出运算符\n当向一个整数类型的常量或者变量赋予超过它容量的值时，Swift 默认会报错，而不是允许生成一个无效的数。这个行为为我们在运算过大或者过小的数时提供了额外的安全性。\n例如，Int16 型整数能容纳的有符号整数范围是 -32768 到 32767。当为一个 Int16 类型的变量或常量赋予的值超过这个范围时，系统就会报错：\n1234var potentialOverflow = Int16.max// potentialOverflow 的值是 32767，这是 Int16 能容纳的最大整数potentialOverflow += 1// 这里会报错\n在赋值时为过大或者过小的情况提供错误处理，能让我们在处理边界值时更加灵活。\n然而，当你希望的时候也可以选择让系统在数值溢出的时候采取截断处理，而非报错。Swift 提供的三个溢出运算符来让系统支持整数溢出运算。这些运算符都是以 &amp; 开头的：\n\n溢出加法 &amp;+\n溢出减法 &amp;-\n溢出乘法 &amp;*\n\n数值溢出\n数值有可能出现上溢或者下溢。\n这个示例演示了当我们对一个无符号整数使用溢出加法（&amp;+）进行上溢运算时会发生什么：\n1234var unsignedOverflow = UInt8.max// unsignedOverflow 等于 UInt8 所能容纳的最大整数 255unsignedOverflow = unsignedOverflow &amp;+ 1// 此时 unsignedOverflow 等于 0\nunsignedOverflow 被初始化为 UInt8 所能容纳的最大整数（255，以二进制表示即 11111111）。然后使用溢出加法运算符（&amp;+）对其进行加 1 运算。这使得它的二进制表示正好超出 UInt8 所能容纳的位数，也就导致了数值的溢出，如下图所示。数值溢出后，仍然留在 UInt8 边界内的值是 00000000，也就是十进制数值的 0。\n\n当允许对一个无符号整数进行下溢运算时也会产生类似的情况。这里有一个使用溢出减法运算符（&amp;-）的例子：\n1234var unsignedOverflow = UInt8.min// unsignedOverflow 等于 UInt8 所能容纳的最小整数 0unsignedOverflow = unsignedOverflow &amp;- 1// 此时 unsignedOverflow 等于 255\nUInt8 型整数能容纳的最小值是 0，以二进制表示即 00000000。当使用溢出减法运算符对其进行减 1 运算时，数值会产生下溢并被截断为 11111111， 也就是十进制数值的 255。\n\n溢出也会发生在有符号整型上。针对有符号整型的所有溢出加法或者减法运算都是按位运算的方式执行的，符号位也需要参与计算，正如 按位左移、右移运算符 所描述的。\n1234var signedOverflow = Int8.min// signedOverflow 等于 Int8 所能容纳的最小整数 -128signedOverflow = signedOverflow &amp;- 1// 此时 signedOverflow 等于 127\nInt8 型整数能容纳的最小值是 -128，以二进制表示即 10000000。当使用溢出减法运算符对其进行减 1 运算时，符号位被翻转，得到二进制数值 01111111，也就是十进制数值的 127，这个值也是 Int8 型整所能容纳的最大值。\n\n对于无符号与有符号整型数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小数。同样地，当发生下溢时，它们会从所能容纳的最小数变成最大数。\n优先级和结合性\n运算符的优先级使得一些运算符优先于其他运算符；它们会先被执行。\n结合性定义了相同优先级的运算符是如何结合的，也就是说，是与左边结合为一组，还是与右边结合为一组。可以将其理解为“它们是与左边的表达式结合的”，或者“它们是与右边的表达式结合的”。\n当考虑一个复合表达式的计算顺序时，运算符的优先级和结合性是非常重要的。举例来说，运算符优先级解释了为什么下面这个表达式的运算结果会是 17。\n122 + 3 % 4 * 5// 结果是 17\n如果你直接从左到右进行运算，你可能认为运算的过程是这样的：\n\n2 + 3 = 5\n5 % 4 = 1\n1 * 5 = 5\n\n但是正确答案是 17 而不是 5。优先级高的运算符要先于优先级低的运算符进行计算。与 C 语言类似，在 Swift 中，乘法运算符（*）与取余运算符（%）的优先级高于加法运算符（+）。因此，它们的计算顺序要先于加法运算。\n而乘法运算与取余运算的优先级相同。这时为了得到正确的运算顺序，还需要考虑结合性。乘法运算与取余运算都是左结合的。可以将这考虑成，从它们的左边开始为这两部分表达式都隐式地加上括号：\n12 + ((3 % 4) * 5)\n(3 % 4) 等于 3，所以表达式相当于：\n12 + (3 * 5)\n3 * 5 等于 15，所以表达式相当于：\n12 + 15\n因此计算结果为 17。\n有关 Swift 标准库提供的操作符信息，包括操作符优先级组和结核性设置的完整列表，请参见 操作符声明。\n\n注意\n相对 C 语言和 Objective-C 来说，Swift 的运算符优先级和结合性规则更加简洁和可预测。但是，这也意味着它们相较于 C 语言及其衍生语言并不是完全一致。在对现有的代码进行移植的时候，要注意确保运算符的行为仍然符合你的预期。\n\n运算符函数\n类和结构体可以为现有的运算符提供自定义的实现。这通常被称为运算符重载。\n下面的例子展示了如何让自定义的结构体支持加法运算符（+）。算术加法运算符是一个二元运算符，因为它是对两个值进行运算，同时它还可以称为中缀运算符，因为它出现在两个值中间。\n例子中定义了一个名为 Vector2D 的结构体用来表示二维坐标向量 (x, y)，紧接着定义了一个可以将两个 Vector2D 结构体实例进行相加的运算符函数：\n123456789struct Vector2D &#123;    var x = 0.0, y = 0.0&#125;extension Vector2D &#123;    static func + (left: Vector2D, right: Vector2D) -&gt; Vector2D &#123;        return Vector2D(x: left.x + right.x, y: left.y + right.y)    &#125;&#125;\n该运算符函数被定义为 Vector2D 上的一个类方法，并且函数的名字与它要进行重载的 + 名字一致。因为加法运算并不是一个向量必需的功能，所以这个类方法被定义在 Vector2D 的一个扩展中，而不是 Vector2D 结构体声明内。而算术加法运算符是二元运算符，所以这个运算符函数接收两个类型为 Vector2D 的参数，同时有一个 Vector2D 类型的返回值。\n在这个实现中，输入参数分别被命名为 left 和 right，代表在 + 运算符左边和右边的两个 Vector2D 实例。函数返回了一个新的 Vector2D 实例，这个实例的 x 和 y 分别等于作为参数的两个实例的 x 和 y 的值之和。\n这个类方法可以在任意两个 Vector2D 实例中间作为中缀运算符来使用：\n1234let vector = Vector2D(x: 3.0, y: 1.0)let anotherVector = Vector2D(x: 2.0, y: 4.0)let combinedVector = vector + anotherVector// combinedVector 是一个新的 Vector2D 实例，值为 (5.0, 5.0)\n这个例子实现两个向量 (3.0，1.0) 和 (2.0，4.0) 的相加，并得到新的向量 (5.0，5.0)。这个过程如下图示：\n\n前缀和后缀运算符\n上个例子演示了一个二元中缀运算符的自定义实现。类与结构体也能提供标准一元运算符的实现。一元运算符只运算一个值。当运算符出现在值之前时，它就是前缀的（例如 -a），而当它出现在值之后时，它就是后缀的（例如 b!）。\n要实现前缀或者后缀运算符，需要在声明运算符函数的时候在 func 关键字之前指定 prefix 或者 postfix 修饰符：\n12345extension Vector2D &#123;    static prefix func - (vector: Vector2D) -&gt; Vector2D &#123;        return Vector2D(x: -vector.x, y: -vector.y)    &#125;&#125;\n这段代码为 Vector2D 类型实现了一元运算符（-a）。由于该运算符是前缀运算符，所以这个函数需要加上 prefix 修饰符。\n对于简单数值，一元负号运算符可以对它们的正负性进行改变。对于 Vector2D 来说，该运算将其 x 和 y 属性的正负性都进行了改变：\n12345let positive = Vector2D(x: 3.0, y: 4.0)let negative = -positive// negative 是一个值为 (-3.0, -4.0) 的 Vector2D 实例let alsoPositive = -negative// alsoPositive 是一个值为 (3.0, 4.0) 的 Vector2D 实例\n复合赋值运算符\n复合赋值运算符将赋值运算符（=）与其它运算符进行结合。例如，将加法与赋值结合成加法赋值运算符（+=）。在实现的时候，需要把运算符的左参数设置成 inout 类型，因为这个参数的值会在运算符函数内直接被修改。\n在下面的例子中，对 Vector2D 实例实现了一个加法赋值运算符函数：\n12345extension Vector2D &#123;    static func += (left: inout Vector2D, right: Vector2D) &#123;        left = left + right    &#125;&#125;\n因为加法运算在之前已经定义过了，所以在这里无需重新定义。在这里可以直接利用现有的加法运算符函数，用它来对左值和右值进行相加，并再次赋值给左值：\n1234var original = Vector2D(x: 1.0, y: 2.0)let vectorToAdd = Vector2D(x: 3.0, y: 4.0)original += vectorToAdd// original 的值现在为 (4.0, 6.0)\n\n注意\n不能对默认的赋值运算符（=）进行重载。只有复合赋值运算符可以被重载。同样地，也无法对三元条件运算符 （a ? b : c） 进行重载。\n\n等价运算符\n通常情况下，自定义的类和结构体没有对等价运算符进行默认实现，等价运算符通常被称为相等运算符（==）与不等运算符（!=）。\n为了使用等价运算符对自定义的类型进行判等运算，需要为“相等”运算符提供自定义实现，实现的方法与其它中缀运算符一样, 并且增加对标准库 Equatable 协议的遵循：\n12345extension Vector2D: Equatable &#123;    static func == (left: Vector2D, right: Vector2D) -&gt; Bool &#123;        return (left.x == right.x) &amp;&amp; (left.y == right.y)    &#125;&#125;\n上述代码实现了“相等”运算符（==）来判断两个 Vector2D 实例是否相等。对于 Vector2D 来说，“相等”意味着“两个实例的 x 和 y 都相等”，这也是代码中用来进行判等的逻辑。如果你已经实现了“相等”运算符，通常情况下你并不需要自己再去实现“不等”运算符（!=）。标准库对于“不等”运算符提供了默认的实现，它简单地将“相等”运算符的结果进行取反后返回。\n现在我们可以使用这两个运算符来判断两个 Vector2D 实例是否相等：\n123456let twoThree = Vector2D(x: 2.0, y: 3.0)let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)if twoThree == anotherTwoThree &#123;    print(&quot;These two vectors are equivalent.&quot;)&#125;// 打印“These two vectors are equivalent.”\n多数简单情况下，您可以使用 Swift 为您提供的等价运算符默认实现。Swift 为以下数种自定义类型提供等价运算符的默认实现：\n\n只拥有存储属性，并且它们全都遵循 Equatable 协议的结构体\n只拥有关联类型，并且它们全都遵循 Equatable 协议的枚举\n没有关联类型的枚举\n\n在类型原始的声明中声明遵循 Equatable 来接收这些默认实现。\n下面为三维位置向量 (x, y, z) 定义的 Vector3D 结构体，与 Vector2D 类似。由于 x，y 和 z 属性都是 Equatable 类型，Vector3D 获得了默认的等价运算符实现。\n12345678910struct Vector3D: Equatable &#123;    var x = 0.0, y = 0.0, z = 0.0&#125;let twoThreeFour = Vector3D(x: 2.0, y: 3.0, z: 4.0)let anotherTwoThreeFour = Vector3D(x: 2.0, y: 3.0, z: 4.0)if twoThreeFour == anotherTwoThreeFour &#123;    print(&quot;These two vectors are also equivalent.&quot;)&#125;// 打印“These two vectors are also equivalent.”\n自定义运算符\n除了实现标准运算符，在 Swift 中还可以声明和实现自定义运算符。可以用来自定义运算符的字符列表请参考 运算符。\n新的运算符要使用 operator 关键字在全局作用域内进行定义，同时还要指定 prefix、infix 或者 postfix 修饰符：\n1prefix operator +++\n上面的代码定义了一个新的名为 +++ 的前缀运算符。对于这个运算符，在 Swift 中并没有已知的意义，因此在针对 Vector2D 实例的特定上下文中，给予了它自定义的意义。对这个示例来讲，+++ 被实现为“前缀双自增”运算符。它使用了前面定义的复合加法运算符来让矩阵与自身进行相加，从而让 Vector2D 实例的 x 属性和 y 属性值翻倍。你可以像下面这样通过对 Vector2D 添加一个 +++ 类方法，来实现 +++ 运算符：\n1234567891011extension Vector2D &#123;    static prefix func +++ (vector: inout Vector2D) -&gt; Vector2D &#123;        vector += vector        return vector    &#125;&#125;var toBeDoubled = Vector2D(x: 1.0, y: 4.0)let afterDoubling = +++toBeDoubled// toBeDoubled 现在的值为 (2.0, 8.0)// afterDoubling 现在的值也为 (2.0, 8.0)\n自定义中缀运算符的优先级\n每个自定义中缀运算符都属于某个优先级组。优先级组指定了这个运算符相对于其他中缀运算符的优先级和结合性。优先级和结合性 中详细阐述了这两个特性是如何对中缀运算符的运算产生影响的。\n而没有明确放入某个优先级组的自定义中缀运算符将会被放到一个默认的优先级组内，其优先级高于三元运算符。\n以下例子定义了一个新的自定义中缀运算符 +-，此运算符属于 AdditionPrecedence 优先组：\n12345678910infix operator +-: AdditionPrecedenceextension Vector2D &#123;    static func +- (left: Vector2D, right: Vector2D) -&gt; Vector2D &#123;        return Vector2D(x: left.x + right.x, y: left.y - right.y)    &#125;&#125;let firstVector = Vector2D(x: 1.0, y: 2.0)let secondVector = Vector2D(x: 3.0, y: 4.0)let plusMinusVector = firstVector +- secondVector// plusMinusVector 是一个 Vector2D 实例，并且它的值为 (4.0, -2.0)\n这个运算符把两个向量的 x 值相加，同时从第一个向量的 y 中减去第二个向量的 y 。因为它本质上是属于“相加型”运算符，所以将它放置在 + 和 - 等默认中缀“相加型”运算符相同的优先级组中。关于 Swift 标准库提供的运算符，以及完整的运算符优先级组和结合性设置，请参考 运算符声明。而更多关于优先级组以及自定义操作符和优先级组的语法，请参考 运算符声明。\n\n注意\n当定义前缀与后缀运算符的时候，我们并没有指定优先级。然而，如果对同一个值同时使用前缀与后缀运算符，则后缀运算符会先参与运算。\n\n","dateCreated":"2023-07-14T10:13:17+08:00","dateModified":"2025-06-18T12:33:45+08:00","datePublished":"2023-07-14T10:13:17+08:00","description":"","headline":"swift高级运算符","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://keinchan.com/2023/07/14/Swift/swift%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/"},"publisher":{"@type":"Organization","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg","logo":{"@type":"ImageObject","url":"profile.jpg"}},"url":"https://keinchan.com/2023/07/14/Swift/swift%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/","keywords":"swift"}</script>
    <meta name="description" content="高级运算符 除了之前介绍过的 基本运算符，Swift 还提供了数种可以对数值进行复杂运算的高级运算符。它们包含了在 C 和 Objective-C 中已经被大家所熟知的位运算符和移位运算符。 与 C 语言中的算术运算符不同，Swift 中的算术运算符默认是不会溢出的。所有溢出行为都会被捕获并报告为错误。如果想让系统允许溢出行为，可以选择使用 Swift 中另一套默认支持溢出的运算符，比如溢出加法运">
<meta property="og:type" content="blog">
<meta property="og:title" content="swift高级运算符">
<meta property="og:url" content="https://keinchan.com/2023/07/14/Swift/swift%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:description" content="高级运算符 除了之前介绍过的 基本运算符，Swift 还提供了数种可以对数值进行复杂运算的高级运算符。它们包含了在 C 和 Objective-C 中已经被大家所熟知的位运算符和移位运算符。 与 C 语言中的算术运算符不同，Swift 中的算术运算符默认是不会溢出的。所有溢出行为都会被捕获并报告为错误。如果想让系统允许溢出行为，可以选择使用 Swift 中另一套默认支持溢出的运算符，比如溢出加法运">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://docs.swift.org/swift-book/_images/bitwiseNOT_2x.png">
<meta property="og:image" content="https://docs.swift.org/swift-book/_images/bitwiseAND_2x.png">
<meta property="og:image" content="https://docs.swift.org/swift-book/_images/bitwiseOR_2x.png">
<meta property="og:image" content="https://docs.swift.org/swift-book/_images/bitwiseXOR_2x.png">
<meta property="og:image" content="https://docs.swift.org/swift-book/_images/bitshiftUnsigned_2x.png">
<meta property="og:image" content="https://docs.swift.org/swift-book/_images/bitshiftSignedFour_2x.png">
<meta property="og:image" content="https://docs.swift.org/swift-book/_images/bitshiftSignedMinusFour_2x.png">
<meta property="og:image" content="https://docs.swift.org/swift-book/_images/bitshiftSignedMinusFourValue_2x.png">
<meta property="og:image" content="https://docs.swift.org/swift-book/_images/bitshiftSignedAddition_2x.png">
<meta property="og:image" content="https://docs.swift.org/swift-book/_images/bitshiftSigned_2x.png">
<meta property="og:image" content="https://docs.swift.org/swift-book/_images/overflowAddition_2x.png">
<meta property="og:image" content="https://docs.swift.org/swift-book/_images/overflowUnsignedSubtraction_2x.png">
<meta property="og:image" content="https://docs.swift.org/swift-book/_images/overflowSignedSubtraction_2x.png">
<meta property="og:image" content="https://docs.swift.org/swift-book/_images/vectorAddition_2x.png">
<meta property="article:published_time" content="2023-07-14T02:13:17.000Z">
<meta property="article:modified_time" content="2025-06-18T04:33:45.396Z">
<meta property="article:author" content="Kein Chan">
<meta property="article:tag" content="swift">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://docs.swift.org/swift-book/_images/bitwiseNOT_2x.png">
    
    
        
    
    
        <meta property="og:image" content="https://keinchan.com../../../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../../../#about"
            >
        
        
            <img class="header-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            swift高级运算符
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2023-07-14T10:13:17+08:00">
	
		    2023 年 7 月 14 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/swift/">swift</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h2 id="高级运算符">高级运算符</h2>
<p>除了之前介绍过的 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/02_Basic_Operators.html">基本运算符</a>，Swift 还提供了数种可以对数值进行复杂运算的高级运算符。它们包含了在 C 和 Objective-C 中已经被大家所熟知的位运算符和移位运算符。</p>
<p>与 C 语言中的算术运算符不同，Swift 中的算术运算符默认是不会溢出的。所有溢出行为都会被捕获并报告为错误。如果想让系统允许溢出行为，可以选择使用 Swift 中另一套默认支持溢出的运算符，比如溢出加法运算符（<code>&amp;+</code>）。所有的这些溢出运算符都是以 <code>&amp;</code> 开头的。</p>
<p>自定义结构体、类和枚举时，如果也为它们提供标准 Swift 运算符的实现，将会非常有用。在 Swift 中为这些运算符提供自定义的实现非常简单，运算符也会针对不同类型使用对应实现。</p>
<p>我们不用被预定义的运算符所限制。在 Swift 中可以自由地定义中缀、前缀、后缀和赋值运算符，它们具有自定义的优先级与关联值。这些运算符在代码中可以像预定义的运算符一样使用，你甚至可以扩展已有的类型以支持自定义运算符。</p>
<h2 id="位运算符">位运算符</h2>
<p><em>位运算符</em>可以操作数据结构中每个独立的比特位。它们通常被用在底层开发中，比如图形编程和创建设备驱动。位运算符在处理外部资源的原始数据时也十分有用，比如对自定义通信协议传输的数据进行编码和解码。</p>
<p>Swift 支持 C 语言中的全部位运算符，接下来会一一介绍。</p>
<h3 id="Bitwise-NOT-Operator（按位取反运算符）">Bitwise NOT Operator（按位取反运算符）</h3>
<p>*按位取反运算符（<code>~</code>）*对一个数值的全部比特位进行取反：</p>
<p><img src="https://docs.swift.org/swift-book/_images/bitwiseNOT_2x.png" alt="Art/bitwiseNOT_2x.png"></p>
<p>按位取反运算符是一个前缀运算符，直接放在运算数之前，并且它们之间不能添加任何空格：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> initialBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b00001111</span></span><br><span class="line"><span class="keyword">let</span> invertedBits <span class="operator">=</span> <span class="operator">~</span>initialBits <span class="comment">// 等于 0b11110000</span></span><br></pre></td></tr></table></figure>
<p><code>UInt8</code> 类型的整数有 8 个比特位，可以存储 <code>0 ~ 255</code> 之间的任意整数。这个例子初始化了一个 <code>UInt8</code> 类型的整数，并赋值为二进制的 <code>00001111</code>，它的前 4 位为 <code>0</code>，后 4 位为 <code>1</code>。这个值等价于十进制的 <code>15</code>。</p>
<p>接着使用按位取反运算符创建了一个名为 <code>invertedBits</code> 的常量，这个常量的值与全部位取反后的 <code>initialBits</code> 相等。即所有的 <code>0</code> 都变成了 <code>1</code>，同时所有的 <code>1</code> 都变成 <code>0</code>。<code>invertedBits</code> 的二进制值为 <code>11110000</code>，等价于无符号十进制数的 <code>240</code>。</p>
<h3 id="Bitwise-AND-Operator（按位与运算符）">Bitwise AND Operator（按位与运算符）</h3>
<p><em>按位与运算符（<code>&amp;</code>）</em> 对两个数的比特位进行合并。它返回一个新的数，只有当两个数的对应位<em>都</em>为 <code>1</code> 的时候，新数的对应位才为 <code>1</code>：</p>
<p><img src="https://docs.swift.org/swift-book/_images/bitwiseAND_2x.png" alt="Art/bitwiseAND_2x.png"></p>
<p>在下面的示例当中，<code>firstSixBits</code> 和 <code>lastSixBits</code> 中间 4 个位的值都为 <code>1</code>。使用按位与运算符之后，得到二进制数值 <code>00111100</code>，等价于无符号十进制数的 <code>60</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstSixBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b11111100</span></span><br><span class="line"><span class="keyword">let</span> lastSixBits: <span class="type">UInt8</span>  <span class="operator">=</span> <span class="number">0b00111111</span></span><br><span class="line"><span class="keyword">let</span> middleFourBits <span class="operator">=</span> firstSixBits <span class="operator">&amp;</span> lastSixBits <span class="comment">// 等于 00111100</span></span><br></pre></td></tr></table></figure>
<h3 id="Bitwise-OR-Operator（按位或运算符）">Bitwise OR Operator（按位或运算符）</h3>
<p><em>按位或运算符（<code>|</code>）<em>可以对两个数的比特位进行比较。它返回一个新的数，只要两个数的对应位中有</em>任意一个</em>为 <code>1</code> 时，新数的对应位就为 <code>1</code>：</p>
<p><img src="https://docs.swift.org/swift-book/_images/bitwiseOR_2x.png" alt="Art/bitwiseOR_2x.png"></p>
<p>在下面的示例中，<code>someBits</code> 和 <code>moreBits</code> 存在不同的位被设置为 <code>1</code>。使用按位或运算符之后，得到二进制数值 <code>11111110</code>，等价于无符号十进制数的 <code>254</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b10110010</span></span><br><span class="line"><span class="keyword">let</span> moreBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b01011110</span></span><br><span class="line"><span class="keyword">let</span> combinedbits <span class="operator">=</span> someBits <span class="operator">|</span> moreBits <span class="comment">// 等于 11111110</span></span><br></pre></td></tr></table></figure>
<h3 id="Bitwise-XOR-Operator（按位异或运算符）">Bitwise XOR Operator（按位异或运算符）</h3>
<p><em>按位异或运算符</em>，或称“排外的或运算符”（<code>^</code>），可以对两个数的比特位进行比较。它返回一个新的数，当两个数的对应位不相同时，新数的对应位就为 <code>1</code>，并且对应位相同时则为 <code>0</code>：</p>
<p><img src="https://docs.swift.org/swift-book/_images/bitwiseXOR_2x.png" alt="Art/bitwiseXOR_2x.png"></p>
<p>在下面的示例当中，<code>firstBits</code> 和 <code>otherBits</code> 都有一个自己为 <code>1</code>，而对方为 <code>0</code> 的位。按位异或运算符将新数的这两个位都设置为 <code>1</code>。在其余的位上 <code>firstBits</code> 和 <code>otherBits</code> 是相同的，所以设置为 <code>0</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b00010100</span></span><br><span class="line"><span class="keyword">let</span> otherBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b00000101</span></span><br><span class="line"><span class="keyword">let</span> outputBits <span class="operator">=</span> firstBits <span class="operator">^</span> otherBits <span class="comment">// 等于 00010001</span></span><br></pre></td></tr></table></figure>
<h3 id="Bitwise-Left-and-Right-Shift-Operators（按位左移、右移运算符）">Bitwise Left and Right Shift Operators（按位左移、右移运算符）</h3>
<p><em>按位左移运算符（<code>&lt;&lt;</code>）</em> 和 *按位右移运算符（<code>&gt;&gt;</code>）*可以对一个数的所有位进行指定位数的左移和右移，但是需要遵守下面定义的规则。</p>
<p>对一个数进行按位左移或按位右移，相当于对这个数进行乘以 2 或除以 2 的运算。将一个整数左移一位，等价于将这个数乘以 2，同样地，将一个整数右移一位，等价于将这个数除以 2。</p>
<h4 id="无符号整数的移位运算">无符号整数的移位运算</h4>
<p>对无符号整数进行移位的规则如下：</p>
<ol>
<li>已存在的位按指定的位数进行左移和右移。</li>
<li>任何因移动而超出整型存储范围的位都会被丢弃。</li>
<li>用 <code>0</code> 来填充移位后产生的空白位。</li>
</ol>
<p>这种方法称为<em>逻辑移位</em>。</p>
<p>以下这张图展示了 <code>11111111 &lt;&lt; 1</code>（即把 <code>11111111</code> 向左移动 <code>1</code> 位），和 <code>11111111 &gt;&gt; 1</code>（即把 <code>11111111</code> 向右移动 <code>1</code> 位）的结果。蓝色的数字是被移位的，灰色的数字是被抛弃的，橙色的 <code>0</code> 则是被填充进来的：</p>
<p><img src="https://docs.swift.org/swift-book/_images/bitshiftUnsigned_2x.png" alt="Art/bitshiftUnsigned_2x.png"></p>
<p>下面的代码演示了 Swift 中的移位运算：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shiftBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">4</span> <span class="comment">// 即二进制的 00000100</span></span><br><span class="line">shiftBits <span class="operator">&lt;&lt;</span> <span class="number">1</span>           <span class="comment">// 00001000</span></span><br><span class="line">shiftBits <span class="operator">&lt;&lt;</span> <span class="number">2</span>           <span class="comment">// 00010000</span></span><br><span class="line">shiftBits <span class="operator">&lt;&lt;</span> <span class="number">5</span>           <span class="comment">// 10000000</span></span><br><span class="line">shiftBits <span class="operator">&lt;&lt;</span> <span class="number">6</span>           <span class="comment">// 00000000</span></span><br><span class="line">shiftBits <span class="operator">&gt;&gt;</span> <span class="number">2</span>           <span class="comment">// 00000001</span></span><br></pre></td></tr></table></figure>
<p>可以使用移位运算对其他的数据类型进行编码和解码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pink: <span class="type">UInt32</span> <span class="operator">=</span> <span class="number">0xCC6699</span></span><br><span class="line"><span class="keyword">let</span> redComponent <span class="operator">=</span> (pink <span class="operator">&amp;</span> <span class="number">0xFF0000</span>) <span class="operator">&gt;&gt;</span> <span class="number">16</span>  <span class="comment">// redComponent 是 0xCC，即 204</span></span><br><span class="line"><span class="keyword">let</span> greenComponent <span class="operator">=</span> (pink <span class="operator">&amp;</span> <span class="number">0x00FF00</span>) <span class="operator">&gt;&gt;</span> <span class="number">8</span> <span class="comment">// greenComponent 是 0x66， 即 102</span></span><br><span class="line"><span class="keyword">let</span> blueComponent <span class="operator">=</span> pink <span class="operator">&amp;</span> <span class="number">0x0000FF</span>         <span class="comment">// blueComponent 是 0x99，即 153</span></span><br></pre></td></tr></table></figure>
<p>这个示例使用了一个命名为 <code>pink</code> 的 <code>UInt32</code> 型常量来存储 Cascading Style Sheets（CSS）中粉色的颜色值。该 CSS 的颜色值 <code>#CC6699</code>，在 Swift 中表示为十六进制的 <code>0xCC6699</code>。然后利用按位与运算符（<code>&amp;</code>）和按位右移运算符（<code>&gt;&gt;</code>）从这个颜色值中分解出红（<code>CC</code>）、绿（<code>66</code>）以及蓝（<code>99</code>）三个部分。</p>
<p>红色部分是通过对 <code>0xCC6699</code> 和 <code>0xFF0000</code> 进行按位与运算后得到的。<code>0xFF0000</code> 中的 <code>0</code> 部分“掩盖”了 <code>OxCC6699</code> 中的第二、第三个字节，使得数值中的 <code>6699</code> 被忽略，只留下 <code>0xCC0000</code>。</p>
<p>然后，将这个数向右移动 16 位（<code>&gt;&gt; 16</code>）。十六进制中每两个字符占用 8 个比特位，所以移动 16 位后 <code>0xCC0000</code> 就变为 <code>0x0000CC</code>。这个数和 <code>0xCC</code> 是等同的，也就是十进制数值的 <code>204</code>。</p>
<p>同样的，绿色部分通过对 <code>0xCC6699</code> 和 <code>0x00FF00</code> 进行按位与运算得到 <code>0x006600</code>。然后将这个数向右移动 8 位，得到 <code>0x66</code>，也就是十进制数值的 <code>102</code>。</p>
<p>最后，蓝色部分通过对 <code>0xCC6699</code> 和 <code>0x0000FF</code> 进行按位与运算得到 <code>0x000099</code>。这里不需要再向右移位，而 <code>0x000099</code> 也就是 <code>0x99</code> ，也就是十进制数值的 <code>153</code>。</p>
<h4 id="有符号整数的移位运算">有符号整数的移位运算</h4>
<p>对比无符号整数，有符号整数的移位运算相对复杂得多，这种复杂性源于有符号整数的二进制表现形式。（为了简单起见，以下的示例都是基于 8 比特的有符号整数，但是其中的原理对任何位数的有符号整数都是通用的。）</p>
<p>有符号整数使用第 1 个比特位（通常被称为<em>符号位</em>）来表示这个数的正负。符号位为 <code>0</code> 代表正数，为 <code>1</code> 代表负数。</p>
<p>其余的比特位（通常被称为<em>数值位</em>）存储了实际的值。有符号正整数和无符号数的存储方式是一样的，都是从 <code>0</code> 开始算起。这是值为 <code>4</code> 的 <code>Int8</code> 型整数的二进制位表现形式：</p>
<p><img src="https://docs.swift.org/swift-book/_images/bitshiftSignedFour_2x.png" alt="Art/bitshiftSignedFour_2x.png"></p>
<p>符号位为 <code>0</code>（代表这是一个“正数”），另外 7 位则代表了十进制数值 <code>4</code> 的二进制表示。</p>
<p>负数的存储方式略有不同。它存储 <code>2</code> 的 <code>n</code> 次方减去其实际值的绝对值，这里的 <code>n</code> 是数值位的位数。一个 8 比特位的数有 7 个比特位是数值位，所以是 <code>2</code> 的 <code>7</code> 次方，即 <code>128</code>。</p>
<p>这是值为 <code>-4</code> 的 <code>Int8</code> 型整数的二进制表现形式：</p>
<p><img src="https://docs.swift.org/swift-book/_images/bitshiftSignedMinusFour_2x.png" alt="Art/bitshiftSignedMinusFour_2x.png"></p>
<p>这次的符号位为 <code>1</code>，说明这是一个负数，另外 7 个位则代表了数值 <code>124</code>（即 <code>128 - 4</code>）的二进制表示：</p>
<p><img src="https://docs.swift.org/swift-book/_images/bitshiftSignedMinusFourValue_2x.png" alt="Art/bitshiftSignedMinusFourValue_2x.png"></p>
<p>负数的表示通常被称为<em>二进制补码</em>。用这种方法来表示负数乍看起来有点奇怪，但它有几个优点。</p>
<p>首先，如果想对 <code>-1</code> 和 <code>-4</code> 进行加法运算，我们只需要对这两个数的全部 8 个比特位执行标准的二进制相加（包括符号位），并且将计算结果中超出 8 位的数值丢弃：</p>
<p><img src="https://docs.swift.org/swift-book/_images/bitshiftSignedAddition_2x.png" alt="Art/bitshiftSignedAddition_2x.png"></p>
<p>其次，使用二进制补码可以使负数的按位左移和右移运算得到跟正数同样的效果，即每向左移一位就将自身的数值乘以 2，每向右一位就将自身的数值除以 2。要达到此目的，对有符号整数的右移有一个额外的规则：当对有符号整数进行按位右移运算时，遵循与无符号整数相同的规则，但是对于移位产生的空白位使用<em>符号位</em>进行填充，而不是用 <code>0</code>。</p>
<p><img src="https://docs.swift.org/swift-book/_images/bitshiftSigned_2x.png" alt="Art/bitshiftSigned_2x.png"></p>
<p>这个行为可以确保有符号整数的符号位不会因为右移运算而改变，这通常被称为<em>算术移位</em>。</p>
<p>由于正数和负数的特殊存储方式，在对它们进行右移的时候，会使它们越来越接近 <code>0</code>。在移位的过程中保持符号位不变，意味着负整数在接近 <code>0</code> 的过程中会一直保持为负。</p>
<h2 id="溢出运算符">溢出运算符</h2>
<p>当向一个整数类型的常量或者变量赋予超过它容量的值时，Swift 默认会报错，而不是允许生成一个无效的数。这个行为为我们在运算过大或者过小的数时提供了额外的安全性。</p>
<p>例如，<code>Int16</code> 型整数能容纳的有符号整数范围是 <code>-32768</code> 到 <code>32767</code>。当为一个 <code>Int16</code> 类型的变量或常量赋予的值超过这个范围时，系统就会报错：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> potentialOverflow <span class="operator">=</span> <span class="type">Int16</span>.max</span><br><span class="line"><span class="comment">// potentialOverflow 的值是 32767，这是 Int16 能容纳的最大整数</span></span><br><span class="line">potentialOverflow <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// 这里会报错</span></span><br></pre></td></tr></table></figure>
<p>在赋值时为过大或者过小的情况提供错误处理，能让我们在处理边界值时更加灵活。</p>
<p>然而，当你希望的时候也可以选择让系统在数值溢出的时候采取截断处理，而非报错。Swift 提供的三个<em>溢出运算符</em>来让系统支持整数溢出运算。这些运算符都是以 <code>&amp;</code> 开头的：</p>
<ul>
<li>溢出加法 <code>&amp;+</code></li>
<li>溢出减法 <code>&amp;-</code></li>
<li>溢出乘法 <code>&amp;*</code></li>
</ul>
<h3 id="数值溢出">数值溢出</h3>
<p>数值有可能出现上溢或者下溢。</p>
<p>这个示例演示了当我们对一个无符号整数使用溢出加法（<code>&amp;+</code>）进行上溢运算时会发生什么：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unsignedOverflow <span class="operator">=</span> <span class="type">UInt8</span>.max</span><br><span class="line"><span class="comment">// unsignedOverflow 等于 UInt8 所能容纳的最大整数 255</span></span><br><span class="line">unsignedOverflow <span class="operator">=</span> unsignedOverflow <span class="operator">&amp;+</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// 此时 unsignedOverflow 等于 0</span></span><br></pre></td></tr></table></figure>
<p><code>unsignedOverflow</code> 被初始化为 <code>UInt8</code> 所能容纳的最大整数（<code>255</code>，以二进制表示即 <code>11111111</code>）。然后使用溢出加法运算符（<code>&amp;+</code>）对其进行加 <code>1</code> 运算。这使得它的二进制表示正好超出 <code>UInt8</code> 所能容纳的位数，也就导致了数值的溢出，如下图所示。数值溢出后，仍然留在 <code>UInt8</code> 边界内的值是 <code>00000000</code>，也就是十进制数值的 <code>0</code>。</p>
<p><img src="https://docs.swift.org/swift-book/_images/overflowAddition_2x.png" alt="Art/overflowAddition_2x.png"></p>
<p>当允许对一个无符号整数进行下溢运算时也会产生类似的情况。这里有一个使用溢出减法运算符（<code>&amp;-</code>）的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unsignedOverflow <span class="operator">=</span> <span class="type">UInt8</span>.min</span><br><span class="line"><span class="comment">// unsignedOverflow 等于 UInt8 所能容纳的最小整数 0</span></span><br><span class="line">unsignedOverflow <span class="operator">=</span> unsignedOverflow <span class="operator">&amp;-</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// 此时 unsignedOverflow 等于 255</span></span><br></pre></td></tr></table></figure>
<p><code>UInt8</code> 型整数能容纳的最小值是 <code>0</code>，以二进制表示即 <code>00000000</code>。当使用溢出减法运算符对其进行减 <code>1</code> 运算时，数值会产生下溢并被截断为 <code>11111111</code>， 也就是十进制数值的 <code>255</code>。</p>
<p><img src="https://docs.swift.org/swift-book/_images/overflowUnsignedSubtraction_2x.png" alt="Art/overflowUnsignedSubtraction_2x.png"></p>
<p>溢出也会发生在有符号整型上。针对有符号整型的所有溢出加法或者减法运算都是按位运算的方式执行的，符号位也需要参与计算，正如 <a href="#bitwise_left_and_right_shift_operators">按位左移、右移运算符</a> 所描述的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> signedOverflow <span class="operator">=</span> <span class="type">Int8</span>.min</span><br><span class="line"><span class="comment">// signedOverflow 等于 Int8 所能容纳的最小整数 -128</span></span><br><span class="line">signedOverflow <span class="operator">=</span> signedOverflow <span class="operator">&amp;-</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// 此时 signedOverflow 等于 127</span></span><br></pre></td></tr></table></figure>
<p><code>Int8</code> 型整数能容纳的最小值是 <code>-128</code>，以二进制表示即 <code>10000000</code>。当使用溢出减法运算符对其进行减 <code>1</code> 运算时，符号位被翻转，得到二进制数值 <code>01111111</code>，也就是十进制数值的 <code>127</code>，这个值也是 <code>Int8</code> 型整所能容纳的最大值。</p>
<p><img src="https://docs.swift.org/swift-book/_images/overflowSignedSubtraction_2x.png" alt="Art/overflowSignedSubtraction_2x.png"></p>
<p>对于无符号与有符号整型数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小数。同样地，当发生下溢时，它们会从所能容纳的最小数变成最大数。</p>
<h2 id="优先级和结合性">优先级和结合性</h2>
<p>运算符的<em>优先级</em>使得一些运算符优先于其他运算符；它们会先被执行。</p>
<p><em>结合性</em>定义了相同优先级的运算符是如何结合的，也就是说，是与左边结合为一组，还是与右边结合为一组。可以将其理解为“它们是与左边的表达式结合的”，或者“它们是与右边的表达式结合的”。</p>
<p>当考虑一个复合表达式的计算顺序时，运算符的优先级和结合性是非常重要的。举例来说，运算符优先级解释了为什么下面这个表达式的运算结果会是 <code>17</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="operator">+</span> <span class="number">3</span> <span class="operator">%</span> <span class="number">4</span> <span class="operator">*</span> <span class="number">5</span></span><br><span class="line"><span class="comment">// 结果是 17</span></span><br></pre></td></tr></table></figure>
<p>如果你直接从左到右进行运算，你可能认为运算的过程是这样的：</p>
<ul>
<li>2 + 3 = 5</li>
<li>5 % 4 = 1</li>
<li>1 * 5 = 5</li>
</ul>
<p>但是正确答案是 <code>17</code> 而不是 <code>5</code>。优先级高的运算符要先于优先级低的运算符进行计算。与 C 语言类似，在 Swift 中，乘法运算符（<code>*</code>）与取余运算符（<code>%</code>）的优先级高于加法运算符（<code>+</code>）。因此，它们的计算顺序要先于加法运算。</p>
<p>而乘法运算与取余运算的优先级<em>相同</em>。这时为了得到正确的运算顺序，还需要考虑结合性。乘法运算与取余运算都是左结合的。可以将这考虑成，从它们的左边开始为这两部分表达式都隐式地加上括号：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="operator">+</span> ((<span class="number">3</span> <span class="operator">%</span> <span class="number">4</span>) <span class="operator">*</span> <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><code>(3 % 4)</code> 等于 <code>3</code>，所以表达式相当于：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="operator">+</span> (<span class="number">3</span> <span class="operator">*</span> <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><code>3 * 5</code> 等于 <code>15</code>，所以表达式相当于：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="operator">+</span> <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>因此计算结果为 <code>17</code>。</p>
<p>有关 Swift 标准库提供的操作符信息，包括操作符优先级组和结核性设置的完整列表，请参见 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/operator_declarations">操作符声明</a>。</p>
<blockquote>
<p>注意</p>
<p>相对 C 语言和 Objective-C 来说，Swift 的运算符优先级和结合性规则更加简洁和可预测。但是，这也意味着它们相较于 C 语言及其衍生语言并不是完全一致。在对现有的代码进行移植的时候，要注意确保运算符的行为仍然符合你的预期。</p>
</blockquote>
<h2 id="运算符函数">运算符函数</h2>
<p>类和结构体可以为现有的运算符提供自定义的实现。这通常被称为运算符<em>重载</em>。</p>
<p>下面的例子展示了如何让自定义的结构体支持加法运算符（<code>+</code>）。算术加法运算符是一个<em>二元运算符</em>，因为它是对两个值进行运算，同时它还可以称为<em>中缀</em>运算符，因为它出现在两个值中间。</p>
<p>例子中定义了一个名为 <code>Vector2D</code> 的结构体用来表示二维坐标向量 <code>(x, y)</code>，紧接着定义了一个可以将两个 <code>Vector2D</code> 结构体实例进行相加的<em>运算符函数</em>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">+</span> (<span class="params">left</span>: <span class="type">Vector2D</span>, <span class="params">right</span>: <span class="type">Vector2D</span>) -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Vector2D</span>(x: left.x <span class="operator">+</span> right.x, y: left.y <span class="operator">+</span> right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该运算符函数被定义为 <code>Vector2D</code> 上的一个类方法，并且函数的名字与它要进行重载的 <code>+</code> 名字一致。因为加法运算并不是一个向量必需的功能，所以这个类方法被定义在 <code>Vector2D</code> 的一个扩展中，而不是 <code>Vector2D</code> 结构体声明内。而算术加法运算符是二元运算符，所以这个运算符函数接收两个类型为 <code>Vector2D</code> 的参数，同时有一个 <code>Vector2D</code> 类型的返回值。</p>
<p>在这个实现中，输入参数分别被命名为 <code>left</code> 和 <code>right</code>，代表在 <code>+</code> 运算符左边和右边的两个 <code>Vector2D</code> 实例。函数返回了一个新的 <code>Vector2D</code> 实例，这个实例的 <code>x</code> 和 <code>y</code> 分别等于作为参数的两个实例的 <code>x</code> 和 <code>y</code> 的值之和。</p>
<p>这个类方法可以在任意两个 <code>Vector2D</code> 实例中间作为中缀运算符来使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vector <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">let</span> anotherVector <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> combinedVector <span class="operator">=</span> vector <span class="operator">+</span> anotherVector</span><br><span class="line"><span class="comment">// combinedVector 是一个新的 Vector2D 实例，值为 (5.0, 5.0)</span></span><br></pre></td></tr></table></figure>
<p>这个例子实现两个向量 <code>(3.0，1.0)</code> 和 <code>(2.0，4.0)</code> 的相加，并得到新的向量 <code>(5.0，5.0)</code>。这个过程如下图示：</p>
<p><img src="https://docs.swift.org/swift-book/_images/vectorAddition_2x.png" alt="Art/vectorAddition_2x.png"></p>
<h3 id="前缀和后缀运算符">前缀和后缀运算符</h3>
<p>上个例子演示了一个二元中缀运算符的自定义实现。类与结构体也能提供标准<em>一元运算符</em>的实现。一元运算符只运算一个值。当运算符出现在值之前时，它就是<em>前缀</em>的（例如 <code>-a</code>），而当它出现在值之后时，它就是<em>后缀</em>的（例如 <code>b!</code>）。</p>
<p>要实现前缀或者后缀运算符，需要在声明运算符函数的时候在 <code>func</code> 关键字之前指定 <code>prefix</code> 或者 <code>postfix</code> 修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">prefix</span> <span class="keyword">func</span> <span class="title function_">-</span> (<span class="params">vector</span>: <span class="type">Vector2D</span>) -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Vector2D</span>(x: <span class="operator">-</span>vector.x, y: <span class="operator">-</span>vector.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码为 <code>Vector2D</code> 类型实现了一元运算符（<code>-a</code>）。由于该运算符是前缀运算符，所以这个函数需要加上 <code>prefix</code> 修饰符。</p>
<p>对于简单数值，一元负号运算符可以对它们的正负性进行改变。对于 <code>Vector2D</code> 来说，该运算将其 <code>x</code> 和 <code>y</code> 属性的正负性都进行了改变：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> positive <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> negative <span class="operator">=</span> <span class="operator">-</span>positive</span><br><span class="line"><span class="comment">// negative 是一个值为 (-3.0, -4.0) 的 Vector2D 实例</span></span><br><span class="line"><span class="keyword">let</span> alsoPositive <span class="operator">=</span> <span class="operator">-</span>negative</span><br><span class="line"><span class="comment">// alsoPositive 是一个值为 (3.0, 4.0) 的 Vector2D 实例</span></span><br></pre></td></tr></table></figure>
<h3 id="复合赋值运算符">复合赋值运算符</h3>
<p><em>复合赋值运算符</em>将赋值运算符（<code>=</code>）与其它运算符进行结合。例如，将加法与赋值结合成加法赋值运算符（<code>+=</code>）。在实现的时候，需要把运算符的左参数设置成 <code>inout</code> 类型，因为这个参数的值会在运算符函数内直接被修改。</p>
<p>在下面的例子中，对 <code>Vector2D</code> 实例实现了一个加法赋值运算符函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">+=</span> (<span class="params">left</span>: <span class="keyword">inout</span> <span class="type">Vector2D</span>, <span class="params">right</span>: <span class="type">Vector2D</span>) &#123;</span><br><span class="line">        left <span class="operator">=</span> left <span class="operator">+</span> right</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为加法运算在之前已经定义过了，所以在这里无需重新定义。在这里可以直接利用现有的加法运算符函数，用它来对左值和右值进行相加，并再次赋值给左值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> original <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">let</span> vectorToAdd <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line">original <span class="operator">+=</span> vectorToAdd</span><br><span class="line"><span class="comment">// original 的值现在为 (4.0, 6.0)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>不能对默认的赋值运算符（<code>=</code>）进行重载。只有复合赋值运算符可以被重载。同样地，也无法对三元条件运算符 （<code>a ? b : c</code>） 进行重载。</p>
</blockquote>
<h3 id="等价运算符">等价运算符</h3>
<p>通常情况下，自定义的类和结构体没有对<em>等价运算符</em>进行默认实现，等价运算符通常被称为<em>相等</em>运算符（<code>==</code>）与<em>不等</em>运算符（<code>!=</code>）。</p>
<p>为了使用等价运算符对自定义的类型进行判等运算，需要为“相等”运算符提供自定义实现，实现的方法与其它中缀运算符一样, 并且增加对标准库 <code>Equatable</code> 协议的遵循：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Vector2D</span>: <span class="title class_ inherited__">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">==</span> (<span class="params">left</span>: <span class="type">Vector2D</span>, <span class="params">right</span>: <span class="type">Vector2D</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (left.x <span class="operator">==</span> right.x) <span class="operator">&amp;&amp;</span> (left.y <span class="operator">==</span> right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码实现了“相等”运算符（<code>==</code>）来判断两个 <code>Vector2D</code> 实例是否相等。对于 <code>Vector2D</code> 来说，“相等”意味着“两个实例的 <code>x</code> 和 <code>y</code> 都相等”，这也是代码中用来进行判等的逻辑。如果你已经实现了“相等”运算符，通常情况下你并不需要自己再去实现“不等”运算符（<code>!=</code>）。标准库对于“不等”运算符提供了默认的实现，它简单地将“相等”运算符的结果进行取反后返回。</p>
<p>现在我们可以使用这两个运算符来判断两个 <code>Vector2D</code> 实例是否相等：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> twoThree <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">let</span> anotherTwoThree <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">if</span> twoThree <span class="operator">==</span> anotherTwoThree &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;These two vectors are equivalent.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“These two vectors are equivalent.”</span></span><br></pre></td></tr></table></figure>
<p>多数简单情况下，您可以使用 Swift 为您提供的等价运算符默认实现。Swift 为以下数种自定义类型提供等价运算符的默认实现：</p>
<ul>
<li>只拥有存储属性，并且它们全都遵循 <code>Equatable</code> 协议的结构体</li>
<li>只拥有关联类型，并且它们全都遵循 <code>Equatable</code> 协议的枚举</li>
<li>没有关联类型的枚举</li>
</ul>
<p>在类型原始的声明中声明遵循 <code>Equatable</code> 来接收这些默认实现。</p>
<p>下面为三维位置向量 <code>(x, y, z)</code> 定义的 <code>Vector3D</code> 结构体，与 <code>Vector2D</code> 类似。由于 <code>x</code>，<code>y</code> 和 <code>z</code> 属性都是 <code>Equatable</code> 类型，<code>Vector3D</code> 获得了默认的等价运算符实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector3D</span>: <span class="title class_ inherited__">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span>, z <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> twoThreeFour <span class="operator">=</span> <span class="type">Vector3D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>, z: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> anotherTwoThreeFour <span class="operator">=</span> <span class="type">Vector3D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>, z: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">if</span> twoThreeFour <span class="operator">==</span> anotherTwoThreeFour &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;These two vectors are also equivalent.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“These two vectors are also equivalent.”</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义运算符">自定义运算符</h2>
<p>除了实现标准运算符，在 Swift 中还可以声明和实现<em>自定义运算符</em>。可以用来自定义运算符的字符列表请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter3/02_Lexical_Structure.html#operators">运算符</a>。</p>
<p>新的运算符要使用 <code>operator</code> 关键字在全局作用域内进行定义，同时还要指定 <code>prefix</code>、<code>infix</code> 或者 <code>postfix</code> 修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> <span class="title">+++</span></span><br></pre></td></tr></table></figure>
<p>上面的代码定义了一个新的名为 <code>+++</code> 的前缀运算符。对于这个运算符，在 Swift 中并没有已知的意义，因此在针对 <code>Vector2D</code> 实例的特定上下文中，给予了它自定义的意义。对这个示例来讲，<code>+++</code> 被实现为“前缀双自增”运算符。它使用了前面定义的复合加法运算符来让矩阵与自身进行相加，从而让 <code>Vector2D</code> 实例的 <code>x</code> 属性和 <code>y</code> 属性值翻倍。你可以像下面这样通过对 <code>Vector2D</code> 添加一个 <code>+++</code> 类方法，来实现 <code>+++</code> 运算符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">prefix</span> <span class="keyword">func</span> <span class="title function_">+++</span> (<span class="params">vector</span>: <span class="keyword">inout</span> <span class="type">Vector2D</span>) -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">        vector <span class="operator">+=</span> vector</span><br><span class="line">        <span class="keyword">return</span> vector</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> toBeDoubled <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> afterDoubling <span class="operator">=</span> <span class="operator">+++</span>toBeDoubled</span><br><span class="line"><span class="comment">// toBeDoubled 现在的值为 (2.0, 8.0)</span></span><br><span class="line"><span class="comment">// afterDoubling 现在的值也为 (2.0, 8.0)</span></span><br></pre></td></tr></table></figure>
<h3 id="自定义中缀运算符的优先级">自定义中缀运算符的优先级</h3>
<p>每个自定义中缀运算符都属于某个优先级组。优先级组指定了这个运算符相对于其他中缀运算符的优先级和结合性。<a href="#precedence_and_associativity">优先级和结合性</a> 中详细阐述了这两个特性是如何对中缀运算符的运算产生影响的。</p>
<p>而没有明确放入某个优先级组的自定义中缀运算符将会被放到一个默认的优先级组内，其优先级高于三元运算符。</p>
<p>以下例子定义了一个新的自定义中缀运算符 <code>+-</code>，此运算符属于 <code>AdditionPrecedence</code> 优先组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">+-</span>: <span class="type">AdditionPrecedence</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">+-</span> (<span class="params">left</span>: <span class="type">Vector2D</span>, <span class="params">right</span>: <span class="type">Vector2D</span>) -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Vector2D</span>(x: left.x <span class="operator">+</span> right.x, y: left.y <span class="operator">-</span> right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> firstVector <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">let</span> secondVector <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> plusMinusVector <span class="operator">=</span> firstVector <span class="operator">+-</span> secondVector</span><br><span class="line"><span class="comment">// plusMinusVector 是一个 Vector2D 实例，并且它的值为 (4.0, -2.0)</span></span><br></pre></td></tr></table></figure>
<p>这个运算符把两个向量的 <code>x</code> 值相加，同时从第一个向量的 <code>y</code> 中减去第二个向量的 <code>y</code> 。因为它本质上是属于“相加型”运算符，所以将它放置在 <code>+</code> 和 <code>-</code> 等默认中缀“相加型”运算符相同的优先级组中。关于 Swift 标准库提供的运算符，以及完整的运算符优先级组和结合性设置，请参考 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/operator_declarations">运算符声明</a>。而更多关于优先级组以及自定义操作符和优先级组的语法，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/06_Declarations.md#operator_declaration">运算符声明</a>。</p>
<blockquote>
<p>注意</p>
<p>当定义前缀与后缀运算符的时候，我们并没有指定优先级。然而，如果对同一个值同时使用前缀与后缀运算符，则后缀运算符会先参与运算。</p>
</blockquote>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">標籤</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/swift/" rel="tag">swift</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../../08/27/%E6%95%B0%E5%AD%A6/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/"
                    data-tooltip="一文搞懂贝叶斯定理（原理篇）"
                    aria-label="上一篇: 一文搞懂贝叶斯定理（原理篇）"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../13/Swift/swift%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"
                    data-tooltip="swift访问控制"
                    aria-label="下一篇: swift访问控制"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://keinchan.com/2023/07/14/Swift/swift%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://keinchan.com/2023/07/14/Swift/swift%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://keinchan.com/2023/07/14/Swift/swift%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://keinchan.com/2023/07/14/Swift/swift%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../../08/27/%E6%95%B0%E5%AD%A6/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/"
                    data-tooltip="一文搞懂贝叶斯定理（原理篇）"
                    aria-label="上一篇: 一文搞懂贝叶斯定理（原理篇）"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../13/Swift/swift%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"
                    data-tooltip="swift访问控制"
                    aria-label="下一篇: swift访问控制"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://keinchan.com/2023/07/14/Swift/swift%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://keinchan.com/2023/07/14/Swift/swift%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://keinchan.com/2023/07/14/Swift/swift%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://keinchan.com/2023/07/14/Swift/swift%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://keinchan.com/2023/07/14/Swift/swift%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/"
                        aria-label="分享到 Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://keinchan.com/2023/07/14/Swift/swift%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/"
                        aria-label="分享到 Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://keinchan.com/2023/07/14/Swift/swift%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/"
                        aria-label="global.share_on_linkedin"
                    >
                        <i class="fab fa-linkedin" aria-hidden="true"></i><span>global.share_on_linkedin</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=https://keinchan.com/2023/07/14/Swift/swift%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/"
                        aria-label="分享到 Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 235 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
