
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>swift泛型 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg"},"articleBody":"泛型\n泛型代码让你能根据自定义的需求，编写出适用于任意类型的、灵活可复用的函数及类型。你可避免编写重复的代码，而是用一种清晰抽象的方式来表达代码的意图。\n泛型是 Swift 最强大的特性之一，很多 Swift 标准库是基于泛型代码构建的。实际上，即使你没有意识到，你也一直在语言指南中使用泛型。例如，Swift 的 Array 和 Dictionary 都是泛型集合。你可以创建一个 Int 类型数组，也可创建一个 String 类型数组，甚至可以是任意其他 Swift 类型的数组。同样，你也可以创建一个存储任意指定类型的字典，并对该类型没有限制。\n泛型解决的问题\n下面是一个标准的非泛型函数 swapTwoInts(_:_:)，用来交换两个 Int 值：\n12345func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123;    let temporaryA = a    a = b    b = temporaryA&#125;\n这个函数使用输入输出参数（inout）来交换 a 和 b 的值，具体请参考 输入输出参数。\nswapTwoInts(_:_:) 函数将 b 的原始值换成了 a，将 a 的原始值换成了 b，你可以调用这个函数来交换两个 Int 类型变量：\n12345var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)print(&quot;someInt is now \\(someInt), and anotherInt is now \\(anotherInt)&quot;)// 打印“someInt is now 107, and anotherInt is now 3”\nswapTwoInts(_:_:) 函数很实用，但它只能作用于 Int 类型。如果你想交换两个 String 类型值，或者 Double 类型值，你必须编写对应的函数，类似下面 swapTwoStrings(_:_:) 和 swapTwoDoubles(_:_:) 函数：\n1234567891011func swapTwoStrings(_ a: inout String, _ b: inout String) &#123;    let temporaryA = a    a = b    b = temporaryA&#125;func swapTwoDoubles(_ a: inout Double, _ b: inout Double) &#123;    let temporaryA = a    a = b    b = temporaryA&#125;\n你可能注意到了，swapTwoInts(_:_:‘)、swapTwoStrings(_:_:) 和 swapTwoDoubles(_:_:) 函数体是一样的，唯一的区别是它们接受的参数类型（Int、String 和 Double）。\n在实际应用中，通常需要一个更实用更灵活的函数来交换两个任意类型的值，幸运的是，泛型代码帮你解决了这种问题。（这些函数的泛型版本已经在下面定义好了。）\n\n注意\n在上面三个函数中，a 和 b 类型必须相同。如果 a 和 b 类型不同，那它们俩就不能互换值。Swift 是类型安全的语言，所以它不允许一个 String 类型的变量和一个 Double 类型的变量互换值。试图这样做将导致编译错误。\n\n泛型函数\n泛型函数可适用于任意类型，下面是函数 swapTwoInts(_:_:) 的泛型版本，命名为 swapTwoValues(_:_:)：\n12345func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123;    let temporaryA = a    a = b    b = temporaryA&#125;\nswapTwoValues(_:_:) 和 swapTwoInts(_:_:) 函数体内容相同，它们只在第一行不同，如下所示：\n12func swapTwoInts(_ a: inout Int, _ b: inout Int)func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T)\n泛型版本的函数使用占位符类型名（这里叫做 T ），而不是 实际类型名（例如 Int、String 或 Double），占位符类型名并不关心 T 具体的类型，但它要求 a 和b 必须是相同的类型，T 的实际类型由每次调用 swapTwoValues(_:_:) 来决定。\n泛型函数和非泛型函数的另外一个不同之处在于这个泛型函数名（swapTwoValues(_:_:)）后面跟着占位类型名（T），并用尖括号括起来（&lt;T&gt;）。这个尖括号告诉 Swift 那个 T 是 swapTwoValues(_:_:) 函数定义内的一个占位类型名，因此 Swift 不会去查找名为 T的实际类型。\nswapTwoValues(_:_:) 函数现在可以像 swapTwoInts(_:_:) 那样调用，不同的是它能接受两个任意类型的值，条件是这两个值有着相同的类型。swapTwoValues(_:_:) 函数被调用时，T 所代表的类型都会由传入的值的类型推断出来。\n在下面的两个例子中，T 分别代表 Int 和 String：\n123456789var someInt = 3var anotherInt = 107swapTwoValues(&amp;someInt, &amp;anotherInt)// someInt 现在是 107，anotherInt 现在是 3var someString = &quot;hello&quot;var anotherString = &quot;world&quot;swapTwoValues(&amp;someString, &amp;anotherString)// someString 现在是“world”，anotherString 现在是“hello”\n\n注意\n上面定义的 swapTwoValues(_:_:) 函数是受 swap(_:_:) 函数启发而实现的。后者存在于 Swift 标准库，你可以在你的应用程序中使用它。如果你在代码中需要类似 swapTwoValues(_:_:) 函数的功能，你可以使用已存在的 swap(_:_:) 函数。\n\n类型参数\n上面 swapTwoValues(_:_:) 例子中，占位类型 T 是一个类型参数的例子，类型参数指定并命名一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（例如 &lt;T&gt;）。\n一旦一个类型参数被指定，你可以用它来定义一个函数的参数类型（例如 swapTwoValues(_:_:) 函数中的参数 a 和 b），或者作为函数的返回类型，还可以用作函数主体中的注释类型。在这些情况下，类型参数会在函数调用时被实际类型所替换。（在上面的 swapTwoValues(_:_:) 例子中，当函数第一次被调用时，T 被 Int 替换，第二次调用时，被 String 替换。）\n你可提供多个类型参数，将它们都写在尖括号中，用逗号分开。\n命名类型参数\n大多情况下，类型参数具有描述下的名称，例如字典 Dictionary&lt;Key, Value&gt; 中的 Key 和 Value 及数组 Array&lt;Element&gt; 中的 Element，这能告诉阅读代码的人这些参数类型与泛型类型或函数之间的关系。然而，当它们之间没有有意义的关系时，通常使用单个字符来表示，例如 T、U、V，例如上面演示函数 swapTwoValues(_:_:) 中的 T。\n\n注意\n请始终使用大写字母开头的驼峰命名法（例如 T 和 MyTypeParameter）来为类型参数命名，以表明它们是占位类型，而不是一个值。\n\n泛型类型\n除了泛型函数，Swift 还允许自定义泛型类型。这些自定义类、结构体和枚举可以适用于任意类型，类似于 Array 和 Dictionary。\n本节将向你展示如何编写一个名为 Stack（栈）的泛型集合类型。栈是值的有序集合，和数组类似，但比数组有更严格的操作限制。数组允许在其中任意位置插入或是删除元素。而栈只允许在集合的末端添加新的元素（称之为入栈）。类似的，栈也只能从末端移除元素（称之为出栈）。\n\n注意\n栈的概念已被 UINavigationController 类用来构造视图控制器的导航结构。你通过调用 UINavigationController 的 pushViewController(_:animated:) 方法来添加新的视图控制器到导航栈，通过 popViewControllerAnimated(_:) 方法来从导航栈中移除视图控制器。每当你需要一个严格的“后进先出”方式来管理集合，栈都是最实用的模型。\n\n下图展示了入栈（push）和出栈（pop）的行为：\n\n\n现在有三个值在栈中。\n第四个值被压入到栈的顶部。\n现在栈中有四个值，最近入栈的那个值在顶部。\n栈中最顶部的那个值被移除出栈。\n一个值移除出栈后，现在栈又只有三个值了。\n\n下面展示如何编写一个非泛型版本的栈，以 Int 型的栈为例：\n123456789struct IntStack &#123;    var items = [Int]()    mutating func push(_ item: Int) &#123;        items.append(item)    &#125;    mutating func pop() -&gt; Int &#123;        return items.removeLast()    &#125;&#125;\n这个结构体在栈中使用一个名为 items 的数组属性来存储值。栈提供了两个方法：push(_:) 和 pop()，用来向栈中压入值以及从栈中移除值。这些方法被标记为 mutating，因为它们需要修改结构体的 items 数组。\n上面的 IntStack 结构体只能用于 Int 类型。不过，可以定义一个泛型 Stack 结构体，从而能够处理任意类型的值。\n下面是相同代码的泛型版本：\n123456789struct Stack&lt;Element&gt; &#123;    var items = [Element]()    mutating func push(_ item: Element) &#123;        items.append(item)    &#125;    mutating func pop() -&gt; Element &#123;        return items.removeLast()    &#125;&#125;\n注意，Stack 基本上和 IntStack 相同，只是用占位类型参数 Element 代替了实际的 Int 类型。这个类型参数包裹在紧随结构体名的一对尖括号里（&lt;Element&gt;）。\nElement 为待提供的类型定义了一个占位名。这种待提供的类型可以在结构体的定义中通过 Element 来引用。在这个例子中，Element 在如下三个地方被用作占位符：\n\n创建 items 属性，使用 Element 类型的空数组对其进行初始化。\n指定 push(_:) 方法的唯一参数 item 的类型必须是 Element 类型。\n指定 pop() 方法的返回值类型必须是 Element 类型。\n\n由于 Stack 是泛型类型，因此可以用来创建适用于 Swift 中任意有效类型的栈，就像 Array 和 Dictionary 那样。\n你可以通过在尖括号中写出栈中需要存储的数据类型来创建并初始化一个 Stack 实例。例如，要创建一个 String 类型的栈，可以写成 Stack&lt;String&gt;()：\n123456var stackOfStrings = Stack&lt;String&gt;()stackOfStrings.push(&quot;uno&quot;)stackOfStrings.push(&quot;dos&quot;)stackOfStrings.push(&quot;tres&quot;)stackOfStrings.push(&quot;cuatro&quot;)// 栈中现在有 4 个字符串\n下图展示了 stackOfStrings 如何将这四个值压栈：\n\n移除并返回栈顶部的值“cuatro”，即出栈：\n12let fromTheTop = stackOfStrings.pop()// fromTheTop 的值为“cuatro”，现在栈中还有 3 个字符串\n下图展示了如何将顶部的值出栈：\n\n泛型扩展\n当对泛型类型进行扩展时，你并不需要提供类型参数列表作为定义的一部分。原始类型定义中声明的类型参数列表在扩展中可以直接使用，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。\n下面的例子扩展了泛型类型 Stack，为其添加了一个名为 topItem 的只读计算型属性，它将会返回当前栈顶元素且不会将其从栈中移除：\n12345extension Stack &#123;    var topItem: Element? &#123;        return items.isEmpty ? nil : items[items.count - 1]    &#125;&#125;\ntopItem 属性会返回 Element 类型的可选值。当栈为空的时候，topItem 会返回 nil；当栈不为空的时候，topItem 会返回 items 数组中的最后一个元素。\n注意：这个扩展并没有定义类型参数列表。相反的，Stack 类型已有的类型参数名称 Element，被用在扩展中来表示计算型属性 topItem 的可选类型。\n计算型属性 topItem 现在可以用来访问任意 Stack 实例的顶端元素且不移除它：\n1234if let topItem = stackOfStrings.topItem &#123;    print(&quot;The top item on the stack is \\(topItem).&quot;)&#125;// 打印“The top item on the stack is tres.”\n泛型类型的扩展，还可以包括类型扩展需要额外满足的条件，从而对类型添加新功能，这一部分将在具有泛型 Where 子句的扩展中进行讨论。\n类型约束\nswapTwoValues(_:_:) 函数和 Stack 适用于任意类型。不过，如果能对泛型函数或泛型类型中添加特定的类型约束，这将在某些情况下非常有用。类型约束指定类型参数必须继承自指定类、遵循特定的协议或协议组合。\n例如，Swift 的 Dictionary 类型对字典的键的类型做了些限制。在 字典的描述 中，字典键的类型必须是可哈希（hashable）的。也就是说，必须有一种方法能够唯一地表示它。字典键之所以要是可哈希的，是为了便于检查字典中是否已经包含某个特定键的值。若没有这个要求，字典将无法判断是否可以插入或替换某个指定键的值，也不能查找到已经存储在字典中的指定键的值。\n这个要求通过 Dictionary 键类型上的类型约束实现，它指明了键必须遵循 Swift 标准库中定义的 Hashable 协议。所有 Swift 的基本类型（例如 String、Int、Double 和 Bool）默认都是可哈希的。\n当自定义泛型类型时，你可以定义你自己的类型约束，这些约束将提供更为强大的泛型编程能力。像 可哈希（hashable） 这种抽象概念根据它们的概念特征来描述类型，而不是它们的具体类型。\n类型约束语法\n在一个类型参数名后面放置一个类名或者协议名，并用冒号进行分隔，来定义类型约束。下面将展示泛型函数约束的基本语法（与泛型类型的语法相同）：\n123func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) &#123;    // 这里是泛型函数的函数体部分&#125;\n上面这个函数有两个类型参数。第一个类型参数 T 必须是 SomeClass 子类；第二个类型参数 U 必须符合 SomeProtocol 协议。\n类型约束实践\n这里有个名为 findIndex(ofString:in:) 的非泛型函数，该函数的功能是在一个 String 数组中查找给定 String 值的索引。若查找到匹配的字符串，findIndex(ofString:in:) 函数返回该字符串在数组中的索引值，否则返回 nil：\n12345678func findIndex(ofString valueToFind: String, in array: [String]) -&gt; Int? &#123;    for (index, value) in array.enumerated() &#123;        if value == valueToFind &#123;            return index        &#125;    &#125;    return nil&#125;\nfindIndex(ofString:in:) 函数可以用于查找字符串数组中的某个字符串值：\n12345let strings = [&quot;cat&quot;, &quot;dog&quot;, &quot;llama&quot;, &quot;parakeet&quot;, &quot;terrapin&quot;]if let foundIndex = findIndex(ofString: &quot;llama&quot;, in: strings) &#123;    print(&quot;The index of llama is \\(foundIndex)&quot;)&#125;// 打印“The index of llama is 2”\n如果只能查找字符串在数组中的索引，用处不是很大。不过，你可以用占位类型 T 替换 String 类型来写出具有相同功能的泛型函数 findIndex(_:_:)。\n下面展示了 findIndex(ofString:in:) 函数的泛型版本 findIndex(of:in:)。请注意这个函数返回值的类型仍然是 Int?，这是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数无法通过编译，原因将在后面说明：\n12345678func findIndex&lt;T&gt;(of valueToFind: T, in array:[T]) -&gt; Int? &#123;    for (index, value) in array.enumerated() &#123;        if value == valueToFind &#123;            return index        &#125;    &#125;    return nil&#125;\n上面所写的函数无法通过编译。问题出在相等性检查上，即 “if value == valueToFind”。不是所有的 Swift 类型都可以用等式符（==）进行比较。例如，如果你自定义类或结构体来描述复杂的数据模型，对于这个类或结构体而言，Swift 无法明确知道“相等”意味着什么。正因如此，这部分代码无法保证适用于任意类型 T，当你试图编译这部分代码时就会出现相应的错误。\n不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个 Equatable 协议，该协议要求任何遵循该协议的类型必须实现等式符（==）及不等符（!=），从而能对该类型的任意两个值进行比较。所有的 Swift 标准类型自动支持 Equatable 协议。\n遵循 Equatable 协议的类型都可以安全地用于 findIndex(of:in:) 函数，因为其保证支持等式操作符。为了说明这个事情，当定义一个函数时，你可以定义一个 Equatable 类型约束作为类型参数定义的一部分：\n12345678func findIndex&lt;T: Equatable&gt;(of valueToFind: T, in array:[T]) -&gt; Int? &#123;    for (index, value) in array.enumerated() &#123;        if value == valueToFind &#123;            return index        &#125;    &#125;    return nil&#125;\nfindIndex(of:in:) 类型参数写做 T: Equatable，也就意味着“任何符合 Equatable 协议的类型 T”。\nfindIndex(of:in:) 函数现在可以成功编译了，并且适用于任何符合 Equatable 的类型，如 Double 或 String：\n1234let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25])// doubleIndex 类型为 Int?，其值为 nil，因为 9.3 不在数组中let stringIndex = findIndex(of: &quot;Andrea&quot;, in: [&quot;Mike&quot;, &quot;Malcolm&quot;, &quot;Andrea&quot;])// stringIndex 类型为 Int?，其值为 2\n关联类型\n定义一个协议时，声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型为协议中的某个类型提供了一个占位符名称，其代表的实际类型在协议被遵循时才会被指定。关联类型通过 associatedtype 关键字来指定。\n关联类型实践\n下面例子定义了一个 Container 协议，该协议定义了一个关联类型 Item：\n123456protocol Container &#123;    associatedtype Item    mutating func append(_ item: Item)    var count: Int &#123; get &#125;    subscript(i: Int) -&gt; Item &#123; get &#125;&#125;\nContainer 协议定义了三个任何遵循该协议的类型（即容器）必须提供的功能：\n\n必须可以通过 append(_:) 方法添加一个新元素到容器里。\n必须可以通过 count 属性获取容器中元素的数量，并返回一个 Int 值。\n必须可以通过索引值类型为 Int 的下标检索到容器中的每一个元素。\n\n该协议没有指定容器中元素该如何存储以及元素类型。该协议只指定了任何遵从 Container 协议的类型必须提供的三个功能。遵从协议的类型在满足这三个条件的情况下，也可以提供其他额外的功能。\n任何遵从 Container 协议的类型必须能够指定其存储的元素的类型。具体来说，它必须确保添加到容器内的元素以及下标返回的元素类型是正确的。\n为了定义这些条件，Container 协议需要在不知道容器中元素的具体类型的情况下引用这种类型。Container 协议需要指定任何通过 append(_:) 方法添加到容器中的元素和容器内的元素是相同类型，并且通过容器下标返回的元素的类型也是这种类型。\n为此，Container 协议声明了一个关联类型 Item，写作 associatedtype Item。协议没有定义 Item 是什么，这个信息留给遵从协议的类型来提供。尽管如此，Item 别名提供了一种方式来引用 Container 中元素的类型，并将之用于 append(_:) 方法和下标，从而保证任何 Container 的行为都能如预期。\n这是前面非泛型版本 IntStack 类型，使其遵循 Container 协议：\n123456789101112131415161718192021struct IntStack: Container &#123;    // IntStack 的原始实现部分    var items = [Int]()    mutating func push(_ item: Int) &#123;        items.append(item)    &#125;    mutating func pop() -&gt; Int &#123;        return items.removeLast()    &#125;    // Container 协议的实现部分    typealias Item = Int    mutating func append(_ item: Int) &#123;        self.push(item)    &#125;    var count: Int &#123;        return items.count    &#125;    subscript(i: Int) -&gt; Int &#123;        return items[i]    &#125;&#125;\nIntStack 结构体实现了 Container 协议的三个要求，其原有功能也不会和这些要求相冲突。\n此外，IntStack 在实现 Container 的要求时，指定 Item 为 Int 类型，即 typealias Item = Int，从而将 Container 协议中抽象的 Item 类型转换为具体的 Int 类型。\n由于 Swift 的类型推断，实际上在 IntStack 的定义中不需要声明 Item 为 Int。因为 IntStack 符合 Container 协议的所有要求，Swift 只需通过 append(_:) 方法的 item 参数类型和下标返回值的类型，就可以推断出 Item 的具体类型。事实上，如果你在上面的代码中删除了 typealias Item = Int 这一行，一切也可正常工作，因为 Swift 清楚地知道 Item 应该是哪种类型。\n你也可以让泛型 Stack 结构体遵循 Container 协议：\n1234567891011121314151617181920struct Stack&lt;Element&gt;: Container &#123;    // Stack&lt;Element&gt; 的原始实现部分    var items = [Element]()    mutating func push(_ item: Element) &#123;        items.append(item)    &#125;    mutating func pop() -&gt; Element &#123;        return items.removeLast()    &#125;    // Container 协议的实现部分    mutating func append(_ item: Element) &#123;        self.push(item)    &#125;    var count: Int &#123;        return items.count    &#125;    subscript(i: Int) -&gt; Element &#123;        return items[i]    &#125;&#125;\n这一次，占位类型参数 Element 被用作 append(_:) 方法的 item 参数和下标的返回类型。Swift 可以据此推断出 Element 的类型即是 Item 的类型。\n扩展现有类型来指定关联类型\n在扩展添加协议一致性 中描述了如何利用扩展让一个已存在的类型遵循一个协议，这包括使用了关联类型协议。\nSwift 的 Array 类型已经提供 append(_:) 方法，count 属性，以及带有 Int 索引的下标来检索其元素。这三个功能都符合 Container 协议的要求，也就意味着你只需声明 Array 遵循Container 协议，就可以扩展 Array，使其遵从 Container 协议。你可以通过一个空扩展来实现这点，正如通过扩展采纳协议中的描述：\n1extension Array: Container &#123;&#125;\nArray 的 append(_:) 方法和下标确保了 Swift 可以推断出 Item 具体类型。定义了这个扩展后，你可以将任意 Array 当作 Container 来使用。\n给关联类型添加约束\n你可以在协议里给关联类型添加约束来要求遵循的类型满足约束。例如，下面的代码定义了 Container 协议， 要求关联类型 Item 必须遵循 Equatable 协议：\n123456protocol Container &#123;    associatedtype Item: Equatable    mutating func append(_ item: Item)    var count: Int &#123; get &#125;    subscript(i: Int) -&gt; Item &#123; get &#125;&#125;\n要遵守 Container 协议，Item 类型也必须遵守 Equatable 协议。\n在关联类型约束里使用协议\n协议可以作为它自身的要求出现。例如，有一个协议细化了 Container 协议，添加了一个suffix(_:) 方法。suffix(_:) 方法返回容器中从后往前给定数量的元素，并把它们存储在一个 Suffix 类型的实例里。\n1234protocol SuffixableContainer: Container &#123;    associatedtype Suffix: SuffixableContainer where Suffix.Item == Item    func suffix(_ size: Int) -&gt; Suffix&#125;\n在这个协议里，Suffix 是一个关联类型，就像上边例子中 Container 的 Item 类型一样。Suffix 拥有两个约束：它必须遵循 SuffixableContainer 协议（就是当前定义的协议），以及它的 Item 类型必须是和容器里的 Item 类型相同。Item 的约束是一个 where 分句，它在下面具有泛型 Where 子句的扩展中有讨论。\n这是上面 泛型类型 中 Stack 类型的扩展，它遵循了 SuffixableContainer 协议：\n12345678910111213141516extension Stack: SuffixableContainer &#123;    func suffix(_ size: Int) -&gt; Stack &#123;        var result = Stack()        for index in (count-size)..&lt;count &#123;            result.append(self[index])        &#125;        return result    &#125;    // 推断 suffix 结果是Stack。&#125;var stackOfInts = Stack&lt;Int&gt;()stackOfInts.append(10)stackOfInts.append(20)stackOfInts.append(30)let suffix = stackOfInts.suffix(2)// suffix 包含 20 和 30\n在上面的例子中，Suffix 是 Stack 的关联类型，也是 Stack ，所以 Stack 的后缀运算返回另一个 Stack 。另外，遵循 SuffixableContainer 的类型可以拥有一个与它自己不同的 Suffix 类型——也就是说后缀运算可以返回不同的类型。比如说，这里有一个非泛型 IntStack 类型的扩展，它遵循了 SuffixableContainer 协议，使用 Stack&lt;Int&gt; 作为它的后缀类型而不是 IntStack：\n12345678910extension IntStack: SuffixableContainer &#123;    func suffix(_ size: Int) -&gt; Stack&lt;Int&gt; &#123;        var result = Stack&lt;Int&gt;()        for index in (count-size)..&lt;count &#123;            result.append(self[index])        &#125;        return result    &#125;    // 推断 suffix 结果是 Stack&lt;Int&gt;。&#125;\n泛型 Where 语句\n类型约束 让你能够为泛型函数、下标、类型的类型参数定义一些强制要求。\n对关联类型添加约束通常是非常有用的。你可以通过定义一个泛型 where 子句来实现。通过泛型 where 子句让关联类型遵从某个特定的协议，以及某个特定的类型参数和关联类型必须类型相同。你可以通过将 where 关键字紧跟在类型参数列表后面来定义 where 子句，where 子句后跟一个或者多个针对关联类型的约束，以及一个或多个类型参数和关联类型间的相等关系。你可以在函数体或者类型的大括号之前添加 where 子句。\n下面的例子定义了一个名为 allItemsMatch 的泛型函数，用来检查两个 Container 实例是否包含相同顺序的相同元素。如果所有的元素能够匹配，那么返回 true，否则返回 false。\n被检查的两个 Container 可以不是相同类型的容器（虽然它们可以相同），但它们必须拥有相同类型的元素。这个要求通过一个类型约束以及一个 where 子句来表示：\n12345678910111213141516171819func allItemsMatch&lt;C1: Container, C2: Container&gt;    (_ someContainer: C1, _ anotherContainer: C2) -&gt; Bool    where C1.Item == C2.Item, C1.Item: Equatable &#123;        // 检查两个容器含有相同数量的元素        if someContainer.count != anotherContainer.count &#123;            return false        &#125;        // 检查每一对元素是否相等        for i in 0..&lt;someContainer.count &#123;            if someContainer[i] != anotherContainer[i] &#123;                return false            &#125;        &#125;        // 所有元素都匹配，返回 true        return true&#125;\n这个函数接受 someContainer 和 anotherContainer 两个参数。参数 someContainer 的类型为 C1，参数 anotherContainer 的类型为 C2。C1 和 C2 是容器的两个占位类型参数，函数被调用时才能确定它们的具体类型。\n这个函数的类型参数列表还定义了对两个类型参数的要求：\n\nC1 必须符合 Container 协议（写作 C1: Container）。\nC2 必须符合 Container 协议（写作 C2: Container）。\nC1 的 Item 必须和 C2 的 Item 类型相同（写作 C1.Item == C2.Item）。\nC1 的 Item 必须符合 Equatable 协议（写作 C1.Item: Equatable）。\n\n前两个要求定义在函数的类型形式参数列表里，后两个要求定义在了函数的泛型 where 分句中。\n这些要求意味着：\n\nsomeContainer 是一个 C1 类型的容器。\nanotherContainer 是一个 C2 类型的容器。\nsomeContainer 和 anotherContainer 包含相同类型的元素。\nsomeContainer 中的元素可以通过不等于操作符（!=）来检查它们是否相同。\n\n第三个和第四个要求结合起来意味着 anotherContainer 中的元素也可以通过 != 操作符来比较，因为它们和 someContainer 中的元素类型相同。\n这些要求让 allItemsMatch(_:_:) 函数能够比较两个容器，即使它们的容器类型不同。\nallItemsMatch(_:_:) 函数首先检查两个容器元素个数是否相同，如果元素个数不同，那么一定不匹配，函数就会返回 false。\n进行这项检查之后，通过 for-in 循环和半闭区间操作符（..&lt;）来迭代每个元素，检查 someContainer 中的元素是否不等于 anotherContainer 中的对应元素。如果两个元素不相等，那么两个容器不匹配，函数返回 false。\n如果循环体结束后未发现任何不匹配的情况，表明两个容器匹配，函数返回 true。\n下面是 allItemsMatch(_:_:) 函数的示例：\n12345678910111213var stackOfStrings = Stack&lt;String&gt;()stackOfStrings.push(&quot;uno&quot;)stackOfStrings.push(&quot;dos&quot;)stackOfStrings.push(&quot;tres&quot;)var arrayOfStrings = [&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;]if allItemsMatch(stackOfStrings, arrayOfStrings) &#123;    print(&quot;All items match.&quot;)&#125; else &#123;    print(&quot;Not all items match.&quot;)&#125;// 打印“All items match.”\n上面的例子创建 Stack 实例来存储 String 值，然后将三个字符串压栈。这个例子还通过数组字面量创建了一个 Array 实例，数组中包含同栈中一样的三个字符串。即使栈和数组是不同的类型，但它们都遵从 Container 协议，而且它们都包含相同类型的值。因此你可以用这两个容器作为参数来调用 allItemsMatch(_:_:) 函数。在上面的例子中，allItemsMatch(_:_:) 函数正确地显示了这两个容器中的所有元素都是相互匹配的。\n具有泛型 Where 子句的扩展\n你也可以使用泛型 where 子句作为扩展的一部分。基于以前的例子，下面的示例扩展了泛型 Stack 结构体，添加一个 isTop(_:) 方法。\n12345678extension Stack where Element: Equatable &#123;    func isTop(_ item: Element) -&gt; Bool &#123;        guard let topItem = items.last else &#123;            return false        &#125;        return topItem == item    &#125;&#125;\n这个新的 isTop(_:) 方法首先检查这个栈是不是空的，然后比较给定的元素与栈顶部的元素。如果你尝试不用泛型 where 子句，会有一个问题：在 isTop(_:) 里面使用了 == 运算符，但是 Stack 的定义没有要求它的元素是符合 Equatable 协议的，所以使用 == 运算符导致编译时错误。使用泛型 where 子句可以为扩展添加新的条件，因此只有当栈中的元素符合 Equatable 协议时，扩展才会添加 isTop(_:) 方法。\n以下是 isTop(_:) 方法的调用方式：\n123456if stackOfStrings.isTop(&quot;tres&quot;) &#123;    print(&quot;Top element is tres.&quot;)&#125; else &#123;    print(&quot;Top element is something else.&quot;)&#125;// 打印“Top element is tres.”\n如果尝试在其元素不符合 Equatable 协议的栈上调用 isTop(_:) 方法，则会收到编译时错误。\n12345struct NotEquatable &#123; &#125;var notEquatableStack = Stack&lt;NotEquatable&gt;()let notEquatableValue = NotEquatable()notEquatableStack.push(notEquatableValue)notEquatableStack.isTop(notEquatableValue)  // 报错\n你可以使用泛型 where 子句去扩展一个协议。基于以前的示例，下面的示例扩展了 Container 协议，添加一个 startsWith(_:) 方法。\n12345extension Container where Item: Equatable &#123;    func startsWith(_ item: Item) -&gt; Bool &#123;        return count &gt;= 1 &amp;&amp; self[0] == item    &#125;&#125;\n这个 startsWith(_:) 方法首先确保容器至少有一个元素，然后检查容器中的第一个元素是否与给定的元素相等。任何符合 Container 协议的类型都可以使用这个新的 startsWith(_:) 方法，包括上面使用的栈和数组，只要容器的元素是符合 Equatable 协议的。\n123456if [9, 9, 9].startsWith(42) &#123;    print(&quot;Starts with 42.&quot;)&#125; else &#123;    print(&quot;Starts with something else.&quot;)&#125;// 打印“Starts with something else.”\n上述示例中的泛型 where 子句要求 Item 遵循协议，但也可以编写一个泛型 where 子句去要求 Item 为特定类型。例如：\n1234567891011extension Container where Item == Double &#123;    func average() -&gt; Double &#123;        var sum = 0.0        for index in 0..&lt;count &#123;            sum += self[index]        &#125;        return sum / Double(count)    &#125;&#125;print([1260.0, 1200.0, 98.6, 37.0].average())// 打印“648.9”\n此示例将一个 average() 方法添加到 Item 类型为 Double 的容器中。此方法遍历容器中的元素将其累加，并除以容器的数量计算平均值。它将数量从 Int 转换为 Double 确保能够进行浮点除法。\n就像可以在其他地方写泛型 where 子句一样，你可以在一个泛型 where 子句中包含多个条件作为扩展的一部分。用逗号分隔列表中的每个条件。\n具有泛型 Where 子句的关联类型\n你可以在关联类型后面加上具有泛型 where 的字句。例如，建立一个包含迭代器（Iterator）的容器，就像是标准库中使用的 Sequence 协议那样。你应该这么写：\n123456789protocol Container &#123;    associatedtype Item    mutating func append(_ item: Item)    var count: Int &#123; get &#125;    subscript(i: Int) -&gt; Item &#123; get &#125;    associatedtype Iterator: IteratorProtocol where Iterator.Element == Item    func makeIterator() -&gt; Iterator&#125;\n迭代器（Iterator）的泛型 where 子句要求：无论迭代器是什么类型，迭代器中的元素类型，必须和容器项目的类型保持一致。makeIterator() 则提供了容器的迭代器的访问接口。\n一个协议继承了另一个协议，你通过在协议声明的时候，包含泛型 where 子句，来添加了一个约束到被继承协议的关联类型。例如，下面的代码声明了一个 ComparableContainer 协议，它要求所有的 Item 必须是 Comparable 的。\n1protocol ComparableContainer: Container where Item: Comparable &#123; &#125;\n泛型下标\n下标可以是泛型，它们能够包含泛型 where 子句。你可以在 subscript 后用尖括号来写占位符类型，你还可以在下标代码块花括号前写 where 子句。例如：\n12345678910extension Container &#123;    subscript&lt;Indices: Sequence&gt;(indices: Indices) -&gt; [Item]        where Indices.Iterator.Element == Int &#123;            var result = [Item]()            for index in indices &#123;                result.append(self[index])            &#125;            return result    &#125;&#125;\n这个 Container 协议的扩展添加了一个下标方法，接收一个索引的集合，返回每一个索引所在的值的数组。这个泛型下标的约束如下：\n\n在尖括号中的泛型参数 Indices，必须是符合标准库中的 Sequence 协议的类型。\n下标使用的单一的参数，indices，必须是 Indices 的实例。\n泛型 where 子句要求 Sequence（Indices）的迭代器，其所有的元素都是 Int 类型。这样就能确保在序列（Sequence）中的索引和容器（Container）里面的索引类型是一致的。\n\n综合一下，这些约束意味着，传入到 indices 下标，是一个整型的序列。\n","dateCreated":"2023-07-10T10:13:17+08:00","dateModified":"2025-06-18T12:32:45+08:00","datePublished":"2023-07-10T10:13:17+08:00","description":"","headline":"swift泛型","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://keinchan.com/2023/07/10/Swift/swift%E6%B3%9B%E5%9E%8B/"},"publisher":{"@type":"Organization","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg","logo":{"@type":"ImageObject","url":"profile.jpg"}},"url":"https://keinchan.com/2023/07/10/Swift/swift%E6%B3%9B%E5%9E%8B/","keywords":"swift"}</script>
    <meta name="description" content="泛型 泛型代码让你能根据自定义的需求，编写出适用于任意类型的、灵活可复用的函数及类型。你可避免编写重复的代码，而是用一种清晰抽象的方式来表达代码的意图。 泛型是 Swift 最强大的特性之一，很多 Swift 标准库是基于泛型代码构建的。实际上，即使你没有意识到，你也一直在语言指南中使用泛型。例如，Swift 的 Array 和 Dictionary 都是泛型集合。你可以创建一个 Int 类型数组">
<meta property="og:type" content="blog">
<meta property="og:title" content="swift泛型">
<meta property="og:url" content="https://keinchan.com/2023/07/10/Swift/swift%E6%B3%9B%E5%9E%8B/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:description" content="泛型 泛型代码让你能根据自定义的需求，编写出适用于任意类型的、灵活可复用的函数及类型。你可避免编写重复的代码，而是用一种清晰抽象的方式来表达代码的意图。 泛型是 Swift 最强大的特性之一，很多 Swift 标准库是基于泛型代码构建的。实际上，即使你没有意识到，你也一直在语言指南中使用泛型。例如，Swift 的 Array 和 Dictionary 都是泛型集合。你可以创建一个 Int 类型数组">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://docs.swift.org/swift-book/_images/stackPushPop_2x.png">
<meta property="og:image" content="https://docs.swift.org/swift-book/_images/stackPushedFourStrings_2x.png">
<meta property="og:image" content="https://docs.swift.org/swift-book/_images/stackPoppedOneString_2x.png">
<meta property="article:published_time" content="2023-07-10T02:13:17.000Z">
<meta property="article:modified_time" content="2025-06-18T04:32:45.223Z">
<meta property="article:author" content="Kein Chan">
<meta property="article:tag" content="swift">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://docs.swift.org/swift-book/_images/stackPushPop_2x.png">
    
    
        
    
    
        <meta property="og:image" content="https://keinchan.com../../../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../../../#about"
            >
        
        
            <img class="header-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            swift泛型
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2023-07-10T10:13:17+08:00">
	
		    2023 年 7 月 10 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/swift/">swift</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h2 id="泛型">泛型</h2>
<p><em>泛型代码</em>让你能根据自定义的需求，编写出适用于任意类型的、灵活可复用的函数及类型。你可避免编写重复的代码，而是用一种清晰抽象的方式来表达代码的意图。</p>
<p>泛型是 Swift 最强大的特性之一，很多 Swift 标准库是基于泛型代码构建的。实际上，即使你没有意识到，你也一直在<em>语言指南</em>中使用泛型。例如，Swift 的 <code>Array</code> 和 <code>Dictionary</code> 都是泛型集合。你可以创建一个 <code>Int</code> 类型数组，也可创建一个 <code>String</code> 类型数组，甚至可以是任意其他 Swift 类型的数组。同样，你也可以创建一个存储任意指定类型的字典，并对该类型没有限制。</p>
<h2 id="泛型解决的问题">泛型解决的问题</h2>
<p>下面是一个标准的非泛型函数 <code>swapTwoInts(_:_:)</code>，用来交换两个 <code>Int</code> 值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数使用输入输出参数（<code>inout</code>）来交换 <code>a</code> 和 <code>b</code> 的值，具体请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/06_Functions.html#in_out_parameters">输入输出参数</a>。</p>
<p><code>swapTwoInts(_:_:)</code> 函数将 <code>b</code> 的原始值换成了 <code>a</code>，将 <code>a</code> 的原始值换成了 <code>b</code>，你可以调用这个函数来交换两个 <code>Int</code> 类型变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt <span class="operator">=</span> <span class="number">107</span></span><br><span class="line">swapTwoInts(<span class="operator">&amp;</span>someInt, <span class="operator">&amp;</span>anotherInt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;someInt is now <span class="subst">\(someInt)</span>, and anotherInt is now <span class="subst">\(anotherInt)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“someInt is now 107, and anotherInt is now 3”</span></span><br></pre></td></tr></table></figure>
<p><code>swapTwoInts(_:_:)</code> 函数很实用，但它只能作用于 <code>Int</code> 类型。如果你想交换两个 <code>String</code> 类型值，或者 <code>Double</code> 类型值，你必须编写对应的函数，类似下面 <code>swapTwoStrings(_:_:)</code> 和 <code>swapTwoDoubles(_:_:)</code> 函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoStrings</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">String</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoDoubles</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Double</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">Double</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能注意到了，<code>swapTwoInts(_:_:‘)</code>、<code>swapTwoStrings(_:_:)</code> 和 <code>swapTwoDoubles(_:_:)</code> 函数体是一样的，唯一的区别是它们接受的参数类型（<code>Int</code>、<code>String</code> 和 <code>Double</code>）。</p>
<p>在实际应用中，通常需要一个更实用更灵活的函数来交换两个任意类型的值，幸运的是，泛型代码帮你解决了这种问题。（这些函数的泛型版本已经在下面定义好了。）</p>
<blockquote>
<p>注意</p>
<p>在上面三个函数中，<code>a</code> 和 <code>b</code> 类型必须相同。如果 <code>a</code> 和 <code>b</code> 类型不同，那它们俩就不能互换值。Swift 是类型安全的语言，所以它不允许一个 <code>String</code> 类型的变量和一个 <code>Double</code> 类型的变量互换值。试图这样做将导致编译错误。</p>
</blockquote>
<h2 id="泛型函数">泛型函数</h2>
<p>泛型函数可适用于任意类型，下面是函数 <code>swapTwoInts(_:_:)</code> 的泛型版本，命名为 <code>swapTwoValues(_:_:)</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoValues</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">T</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">T</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>swapTwoValues(_:_:)</code> 和 <code>swapTwoInts(_:_:)</code> 函数体内容相同，它们只在第一行不同，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">Int</span>)</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoValues</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">T</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">T</span>)</span><br></pre></td></tr></table></figure>
<p>泛型版本的函数使用<code>占位符</code>类型名（这里叫做 <code>T</code> ），而不是 <em>实际</em>类型名（例如 <code>Int</code>、<code>String</code> 或 <code>Double</code>），<code>占位符</code>类型名并不关心 <code>T</code> 具体的类型，但它要求 <code>a</code> 和<code>b</code> 必须是相同的类型，<code>T</code> 的实际类型由每次调用 <code>swapTwoValues(_:_:)</code> 来决定。</p>
<p>泛型函数和非泛型函数的另外一个不同之处在于这个泛型函数名（<code>swapTwoValues(_:_:)</code>）后面跟着占位类型名（<code>T</code>），并用尖括号括起来（<code>&lt;T&gt;</code>）。这个尖括号告诉 Swift 那个 <code>T</code> 是 <code>swapTwoValues(_:_:)</code> 函数定义内的一个占位类型名，因此 Swift 不会去查找名为 <code>T</code>的实际类型。</p>
<p><code>swapTwoValues(_:_:)</code> 函数现在可以像 <code>swapTwoInts(_:_:)</code> 那样调用，不同的是它能接受两个任意类型的值，条件是这两个值有着相同的类型。<code>swapTwoValues(_:_:)</code> 函数被调用时，<code>T</code> 所代表的类型都会由传入的值的类型推断出来。</p>
<p>在下面的两个例子中，<code>T</code> 分别代表 <code>Int</code> 和 <code>String</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt <span class="operator">=</span> <span class="number">107</span></span><br><span class="line">swapTwoValues(<span class="operator">&amp;</span>someInt, <span class="operator">&amp;</span>anotherInt)</span><br><span class="line"><span class="comment">// someInt 现在是 107，anotherInt 现在是 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someString <span class="operator">=</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">var</span> anotherString <span class="operator">=</span> <span class="string">&quot;world&quot;</span></span><br><span class="line">swapTwoValues(<span class="operator">&amp;</span>someString, <span class="operator">&amp;</span>anotherString)</span><br><span class="line"><span class="comment">// someString 现在是“world”，anotherString 现在是“hello”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>上面定义的 <code>swapTwoValues(_:_:)</code> 函数是受 <code>swap(_:_:)</code> 函数启发而实现的。后者存在于 Swift 标准库，你可以在你的应用程序中使用它。如果你在代码中需要类似 <code>swapTwoValues(_:_:)</code> 函数的功能，你可以使用已存在的 <code>swap(_:_:)</code> 函数。</p>
</blockquote>
<h2 id="类型参数">类型参数</h2>
<p>上面 <code>swapTwoValues(_:_:)</code> 例子中，占位类型 <code>T</code> 是一个类型参数的例子，类型参数指定并命名一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（例如 <code>&lt;T&gt;</code>）。</p>
<p>一旦一个类型参数被指定，你可以用它来定义一个函数的参数类型（例如 <code>swapTwoValues(_:_:)</code> 函数中的参数 <code>a</code> 和 <code>b</code>），或者作为函数的返回类型，还可以用作函数主体中的注释类型。在这些情况下，类型参数会在函数调用时被实际类型所替换。（在上面的 <code>swapTwoValues(_:_:)</code> 例子中，当函数第一次被调用时，<code>T</code> 被 <code>Int</code> 替换，第二次调用时，被 <code>String</code> 替换。）</p>
<p>你可提供多个类型参数，将它们都写在尖括号中，用逗号分开。</p>
<h2 id="命名类型参数">命名类型参数</h2>
<p>大多情况下，类型参数具有描述下的名称，例如字典 <code>Dictionary&lt;Key, Value&gt;</code> 中的 <code>Key</code> 和 <code>Value</code> 及数组 <code>Array&lt;Element&gt;</code> 中的 <code>Element</code>，这能告诉阅读代码的人这些参数类型与泛型类型或函数之间的关系。然而，当它们之间没有有意义的关系时，通常使用单个字符来表示，例如 <code>T</code>、<code>U</code>、<code>V</code>，例如上面演示函数 <code>swapTwoValues(_:_:)</code> 中的 <code>T</code>。</p>
<blockquote>
<p>注意</p>
<p>请始终使用大写字母开头的驼峰命名法（例如 <code>T</code> 和 <code>MyTypeParameter</code>）来为类型参数命名，以表明它们是占位类型，而不是一个值。</p>
</blockquote>
<h2 id="泛型类型">泛型类型</h2>
<p>除了泛型函数，Swift 还允许自定义<em>泛型类型</em>。这些自定义类、结构体和枚举可以适用于<em>任意类型</em>，类似于 <code>Array</code> 和 <code>Dictionary</code>。</p>
<p>本节将向你展示如何编写一个名为 <code>Stack</code>（栈）的泛型集合类型。栈是值的有序集合，和数组类似，但比数组有更严格的操作限制。数组允许在其中任意位置插入或是删除元素。而栈只允许在集合的末端添加新的元素（称之为入栈）。类似的，栈也只能从末端移除元素（称之为出栈）。</p>
<blockquote>
<p>注意</p>
<p>栈的概念已被 <code>UINavigationController</code> 类用来构造视图控制器的导航结构。你通过调用 <code>UINavigationController</code> 的 <code>pushViewController(_:animated:)</code> 方法来添加新的视图控制器到导航栈，通过 <code>popViewControllerAnimated(_:)</code> 方法来从导航栈中移除视图控制器。每当你需要一个严格的“后进先出”方式来管理集合，栈都是最实用的模型。</p>
</blockquote>
<p>下图展示了入栈（push）和出栈（pop）的行为：</p>
<p><img src="https://docs.swift.org/swift-book/_images/stackPushPop_2x.png" alt=""></p>
<ol>
<li>现在有三个值在栈中。</li>
<li>第四个值被压入到栈的顶部。</li>
<li>现在栈中有四个值，最近入栈的那个值在顶部。</li>
<li>栈中最顶部的那个值被移除出栈。</li>
<li>一个值移除出栈后，现在栈又只有三个值了。</li>
</ol>
<p>下面展示如何编写一个非泛型版本的栈，以 <code>Int</code> 型的栈为例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IntStack</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> items <span class="operator">=</span> [<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体在栈中使用一个名为 <code>items</code> 的数组属性来存储值。栈提供了两个方法：<code>push(_:)</code> 和 <code>pop()</code>，用来向栈中压入值以及从栈中移除值。这些方法被标记为 <code>mutating</code>，因为它们需要修改结构体的 <code>items</code> 数组。</p>
<p>上面的 <code>IntStack</code> 结构体只能用于 <code>Int</code> 类型。不过，可以定义一个泛型 <code>Stack</code> 结构体，从而能够处理任意类型的值。</p>
<p>下面是相同代码的泛型版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> items <span class="operator">=</span> [<span class="type">Element</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>Stack</code> 基本上和 <code>IntStack</code> 相同，只是用占位类型参数 <code>Element</code> 代替了实际的 <code>Int</code> 类型。这个类型参数包裹在紧随结构体名的一对尖括号里（&lt;<code>Element</code>&gt;）。</p>
<p><code>Element</code> 为待提供的类型定义了一个占位名。这种待提供的类型可以在结构体的定义中通过 <code>Element</code> 来引用。在这个例子中，<code>Element</code> 在如下三个地方被用作占位符：</p>
<ul>
<li>创建 <code>items</code> 属性，使用 <code>Element</code> 类型的空数组对其进行初始化。</li>
<li>指定 <code>push(_:)</code> 方法的唯一参数 <code>item</code> 的类型必须是 <code>Element</code> 类型。</li>
<li>指定 <code>pop()</code> 方法的返回值类型必须是 <code>Element</code> 类型。</li>
</ul>
<p>由于 <code>Stack</code> 是泛型类型，因此可以用来创建适用于 Swift 中任意有效类型的栈，就像 <code>Array</code> 和 <code>Dictionary</code> 那样。</p>
<p>你可以通过在尖括号中写出栈中需要存储的数据类型来创建并初始化一个 <code>Stack</code> 实例。例如，要创建一个 <code>String</code> 类型的栈，可以写成 <code>Stack&lt;String&gt;()</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stackOfStrings <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;uno&quot;</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;dos&quot;</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;tres&quot;</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;cuatro&quot;</span>)</span><br><span class="line"><span class="comment">// 栈中现在有 4 个字符串</span></span><br></pre></td></tr></table></figure>
<p>下图展示了 <code>stackOfStrings</code> 如何将这四个值压栈：</p>
<p><img src="https://docs.swift.org/swift-book/_images/stackPushedFourStrings_2x.png" alt=""></p>
<p>移除并返回栈顶部的值“cuatro”，即出栈：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fromTheTop <span class="operator">=</span> stackOfStrings.pop()</span><br><span class="line"><span class="comment">// fromTheTop 的值为“cuatro”，现在栈中还有 3 个字符串</span></span><br></pre></td></tr></table></figure>
<p>下图展示了如何将顶部的值出栈：</p>
<p><img src="https://docs.swift.org/swift-book/_images/stackPoppedOneString_2x.png" alt=""></p>
<h2 id="泛型扩展">泛型扩展</h2>
<p>当对泛型类型进行扩展时，你并不需要提供类型参数列表作为定义的一部分。原始类型定义中声明的类型参数列表在扩展中可以直接使用，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。</p>
<p>下面的例子扩展了泛型类型 <code>Stack</code>，为其添加了一个名为 <code>topItem</code> 的只读计算型属性，它将会返回当前栈顶元素且不会将其从栈中移除：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> topItem: <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> items.isEmpty <span class="operator">?</span> <span class="literal">nil</span> : items[items.count <span class="operator">-</span> <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>topItem</code> 属性会返回 <code>Element</code> 类型的可选值。当栈为空的时候，<code>topItem</code> 会返回 <code>nil</code>；当栈不为空的时候，<code>topItem</code> 会返回 <code>items</code> 数组中的最后一个元素。</p>
<p>注意：这个扩展并没有定义类型参数列表。相反的，<code>Stack</code> 类型已有的类型参数名称 <code>Element</code>，被用在扩展中来表示计算型属性 <code>topItem</code> 的可选类型。</p>
<p>计算型属性 <code>topItem</code> 现在可以用来访问任意 <code>Stack</code> 实例的顶端元素且不移除它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> topItem <span class="operator">=</span> stackOfStrings.topItem &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The top item on the stack is <span class="subst">\(topItem)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“The top item on the stack is tres.”</span></span><br></pre></td></tr></table></figure>
<p>泛型类型的扩展，还可以包括类型扩展需要额外满足的条件，从而对类型添加新功能，这一部分将在<a href="#extensions-with-a-generic-where-clause">具有泛型 Where 子句的扩展</a>中进行讨论。</p>
<h2 id="类型约束">类型约束</h2>
<p><code>swapTwoValues(_:_:)</code> 函数和 <code>Stack</code> 适用于任意类型。不过，如果能对泛型函数或泛型类型中添加特定的<em>类型约束</em>，这将在某些情况下非常有用。类型约束指定类型参数必须继承自指定类、遵循特定的协议或协议组合。</p>
<p>例如，Swift 的 <code>Dictionary</code> 类型对字典的键的类型做了些限制。在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/04_Collection_Types.html#dictionaries">字典的描述</a> 中，字典键的类型必须是可哈希（hashable）的。也就是说，必须有一种方法能够唯一地表示它。字典键之所以要是可哈希的，是为了便于检查字典中是否已经包含某个特定键的值。若没有这个要求，字典将无法判断是否可以插入或替换某个指定键的值，也不能查找到已经存储在字典中的指定键的值。</p>
<p>这个要求通过 <code>Dictionary</code> 键类型上的类型约束实现，它指明了键必须遵循 Swift 标准库中定义的 <code>Hashable</code> 协议。所有 Swift 的基本类型（例如 <code>String</code>、<code>Int</code>、<code>Double</code> 和 <code>Bool</code>）默认都是可哈希的。</p>
<p>当自定义泛型类型时，你可以定义你自己的类型约束，这些约束将提供更为强大的泛型编程能力。像 <code>可哈希（hashable）</code> 这种抽象概念根据它们的概念特征来描述类型，而不是它们的具体类型。</p>
<h3 id="类型约束语法">类型约束语法</h3>
<p>在一个类型参数名后面放置一个类名或者协议名，并用冒号进行分隔，来定义类型约束。下面将展示泛型函数约束的基本语法（与泛型类型的语法相同）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>&lt;<span class="type">T</span>: <span class="type">SomeClass</span>, <span class="type">U</span>: <span class="type">SomeProtocol</span>&gt;(<span class="params">someT</span>: <span class="type">T</span>, <span class="params">someU</span>: <span class="type">U</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里是泛型函数的函数体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数有两个类型参数。第一个类型参数 <code>T</code> 必须是 <code>SomeClass</code> 子类；第二个类型参数 <code>U</code> 必须符合 <code>SomeProtocol</code> 协议。</p>
<h3 id="类型约束实践">类型约束实践</h3>
<p>这里有个名为 <code>findIndex(ofString:in:)</code> 的非泛型函数，该函数的功能是在一个 <code>String</code> 数组中查找给定 <code>String</code> 值的索引。若查找到匹配的字符串，<code>findIndex(ofString:in:)</code> 函数返回该字符串在数组中的索引值，否则返回 <code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findIndex</span>(<span class="params">ofString</span> <span class="params">valueToFind</span>: <span class="type">String</span>, <span class="params">in</span> <span class="params">array</span>: [<span class="type">String</span>]) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerated() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findIndex(ofString:in:)</code> 函数可以用于查找字符串数组中的某个字符串值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> strings <span class="operator">=</span> [<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;llama&quot;</span>, <span class="string">&quot;parakeet&quot;</span>, <span class="string">&quot;terrapin&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> foundIndex <span class="operator">=</span> findIndex(ofString: <span class="string">&quot;llama&quot;</span>, in: strings) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The index of llama is <span class="subst">\(foundIndex)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“The index of llama is 2”</span></span><br></pre></td></tr></table></figure>
<p>如果只能查找字符串在数组中的索引，用处不是很大。不过，你可以用占位类型 <code>T</code> 替换 <code>String</code> 类型来写出具有相同功能的泛型函数 <code>findIndex(_:_:)</code>。</p>
<p>下面展示了 <code>findIndex(ofString:in:)</code> 函数的泛型版本 <code>findIndex(of:in:)</code>。请注意这个函数返回值的类型仍然是 <code>Int?</code>，这是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数无法通过编译，原因将在后面说明：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findIndex</span>&lt;<span class="type">T</span>&gt;(<span class="params">of</span> <span class="params">valueToFind</span>: <span class="type">T</span>, <span class="params">in</span> <span class="params">array</span>:[<span class="type">T</span>]) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerated() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面所写的函数无法通过编译。问题出在相等性检查上，即 “<code>if value == valueToFind</code>”。不是所有的 Swift 类型都可以用等式符（<code>==</code>）进行比较。例如，如果你自定义类或结构体来描述复杂的数据模型，对于这个类或结构体而言，Swift 无法明确知道“相等”意味着什么。正因如此，这部分代码无法保证适用于任意类型 <code>T</code>，当你试图编译这部分代码时就会出现相应的错误。</p>
<p>不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个 <code>Equatable</code> 协议，该协议要求任何遵循该协议的类型必须实现等式符（<code>==</code>）及不等符（<code>!=</code>），从而能对该类型的任意两个值进行比较。所有的 Swift 标准类型自动支持 <code>Equatable</code> 协议。</p>
<p>遵循 <code>Equatable</code> 协议的类型都可以安全地用于 <code>findIndex(of:in:)</code> 函数，因为其保证支持等式操作符。为了说明这个事情，当定义一个函数时，你可以定义一个 <code>Equatable</code> 类型约束作为类型参数定义的一部分：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findIndex</span>&lt;<span class="type">T</span>: <span class="type">Equatable</span>&gt;(<span class="params">of</span> <span class="params">valueToFind</span>: <span class="type">T</span>, <span class="params">in</span> <span class="params">array</span>:[<span class="type">T</span>]) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerated() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findIndex(of:in:)</code> 类型参数写做 <code>T: Equatable</code>，也就意味着“任何符合 <code>Equatable</code> 协议的类型 <code>T</code>”。</p>
<p><code>findIndex(of:in:)</code> 函数现在可以成功编译了，并且适用于任何符合 <code>Equatable</code> 的类型，如 <code>Double</code> 或 <code>String</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> doubleIndex <span class="operator">=</span> findIndex(of: <span class="number">9.3</span>, in: [<span class="number">3.14159</span>, <span class="number">0.1</span>, <span class="number">0.25</span>])</span><br><span class="line"><span class="comment">// doubleIndex 类型为 Int?，其值为 nil，因为 9.3 不在数组中</span></span><br><span class="line"><span class="keyword">let</span> stringIndex <span class="operator">=</span> findIndex(of: <span class="string">&quot;Andrea&quot;</span>, in: [<span class="string">&quot;Mike&quot;</span>, <span class="string">&quot;Malcolm&quot;</span>, <span class="string">&quot;Andrea&quot;</span>])</span><br><span class="line"><span class="comment">// stringIndex 类型为 Int?，其值为 2</span></span><br></pre></td></tr></table></figure>
<h2 id="关联类型">关联类型</h2>
<p>定义一个协议时，声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型为协议中的某个类型提供了一个占位符名称，其代表的实际类型在协议被遵循时才会被指定。关联类型通过 <code>associatedtype</code> 关键字来指定。</p>
<h3 id="关联类型实践">关联类型实践</h3>
<p>下面例子定义了一个 <code>Container</code> 协议，该协议定义了一个关联类型 <code>Item</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Container</code> 协议定义了三个任何遵循该协议的类型（即容器）必须提供的功能：</p>
<ul>
<li>必须可以通过 <code>append(_:)</code> 方法添加一个新元素到容器里。</li>
<li>必须可以通过 <code>count</code> 属性获取容器中元素的数量，并返回一个 Int 值。</li>
<li>必须可以通过索引值类型为 <code>Int</code> 的下标检索到容器中的每一个元素。</li>
</ul>
<p>该协议没有指定容器中元素该如何存储以及元素类型。该协议只指定了任何遵从 <code>Container</code> 协议的类型必须提供的三个功能。遵从协议的类型在满足这三个条件的情况下，也可以提供其他额外的功能。</p>
<p>任何遵从 <code>Container</code> 协议的类型必须能够指定其存储的元素的类型。具体来说，它必须确保添加到容器内的元素以及下标返回的元素类型是正确的。</p>
<p>为了定义这些条件，<code>Container</code> 协议需要在不知道容器中元素的具体类型的情况下引用这种类型。<code>Container</code> 协议需要指定任何通过 <code>append(_:)</code> 方法添加到容器中的元素和容器内的元素是相同类型，并且通过容器下标返回的元素的类型也是这种类型。</p>
<p>为此，<code>Container</code> 协议声明了一个关联类型 <code>Item</code>，写作 <code>associatedtype Item</code>。协议没有定义 <code>Item</code> 是什么，这个信息留给遵从协议的类型来提供。尽管如此，<code>Item</code> 别名提供了一种方式来引用 <code>Container</code> 中元素的类型，并将之用于 <code>append(_:)</code> 方法和下标，从而保证任何 <code>Container</code> 的行为都能如预期。</p>
<p>这是前面非泛型版本 <code>IntStack</code> 类型，使其遵循 <code>Container</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IntStack</span>: <span class="title class_ inherited__">Container</span> &#123;</span><br><span class="line">    <span class="comment">// IntStack 的原始实现部分</span></span><br><span class="line">    <span class="keyword">var</span> items <span class="operator">=</span> [<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Container 协议的实现部分</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Item</span> <span class="operator">=</span> <span class="type">Int</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>IntStack</code> 结构体实现了 <code>Container</code> 协议的三个要求，其原有功能也不会和这些要求相冲突。</p>
<p>此外，<code>IntStack</code> 在实现 <code>Container</code> 的要求时，指定 <code>Item</code> 为 <code>Int</code> 类型，即 <code>typealias Item = Int</code>，从而将 <code>Container</code> 协议中抽象的 <code>Item</code> 类型转换为具体的 <code>Int</code> 类型。</p>
<p>由于 Swift 的类型推断，实际上在 <code>IntStack</code> 的定义中不需要声明 <code>Item</code> 为 <code>Int</code>。因为 <code>IntStack</code> 符合 <code>Container</code> 协议的所有要求，Swift 只需通过 <code>append(_:)</code> 方法的 <code>item</code> 参数类型和下标返回值的类型，就可以推断出 <code>Item</code> 的具体类型。事实上，如果你在上面的代码中删除了 <code>typealias Item = Int</code> 这一行，一切也可正常工作，因为 Swift 清楚地知道 <code>Item</code> 应该是哪种类型。</p>
<p>你也可以让泛型 <code>Stack</code> 结构体遵循 <code>Container</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&lt;<span class="type">Element</span>&gt;: <span class="title class_ inherited__">Container</span> &#123;</span><br><span class="line">    <span class="comment">// Stack&lt;Element&gt; 的原始实现部分</span></span><br><span class="line">    <span class="keyword">var</span> items <span class="operator">=</span> [<span class="type">Element</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Container 协议的实现部分</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一次，占位类型参数 <code>Element</code> 被用作 <code>append(_:)</code> 方法的 <code>item</code> 参数和下标的返回类型。Swift 可以据此推断出 <code>Element</code> 的类型即是 <code>Item</code> 的类型。</p>
<h3 id="扩展现有类型来指定关联类型">扩展现有类型来指定关联类型</h3>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/21_Protocols.html#adding_protocol_conformance_with_an_extension">在扩展添加协议一致性</a> 中描述了如何利用扩展让一个已存在的类型遵循一个协议，这包括使用了关联类型协议。</p>
<p>Swift 的 <code>Array</code> 类型已经提供 <code>append(_:)</code> 方法，<code>count</code> 属性，以及带有 <code>Int</code> 索引的下标来检索其元素。这三个功能都符合 <code>Container</code> 协议的要求，也就意味着你只需声明 <code>Array</code> 遵循<code>Container</code> 协议，就可以扩展 Array，使其遵从 Container 协议。你可以通过一个空扩展来实现这点，正如通过扩展采纳协议中的描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span>: <span class="title class_ inherited__">Container</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>Array</code> 的 <code>append(_:)</code> 方法和下标确保了 Swift 可以推断出 <code>Item</code> 具体类型。定义了这个扩展后，你可以将任意 <code>Array</code> 当作 Container 来使用。</p>
<h3 id="给关联类型添加约束">给关联类型添加约束</h3>
<p>你可以在协议里给关联类型添加约束来要求遵循的类型满足约束。例如，下面的代码定义了 <code>Container</code> 协议， 要求关联类型 <code>Item</code> 必须遵循 <code>Equatable</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span>: <span class="type">Equatable</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要遵守 <code>Container</code> 协议，<code>Item</code> 类型也必须遵守 <code>Equatable</code> 协议。</p>
<h3 id="在关联类型约束里使用协议">在关联类型约束里使用协议</h3>
<p>协议可以作为它自身的要求出现。例如，有一个协议细化了 <code>Container</code> 协议，添加了一个<code>suffix(_:)</code> 方法。<code>suffix(_:)</code> 方法返回容器中从后往前给定数量的元素，并把它们存储在一个 <code>Suffix</code> 类型的实例里。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SuffixableContainer</span>: <span class="title class_ inherited__">Container</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Suffix</span>: <span class="type">SuffixableContainer</span> <span class="keyword">where</span> <span class="type">Suffix</span>.<span class="type">Item</span> <span class="operator">==</span> <span class="type">Item</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">suffix</span>(<span class="keyword">_</span> <span class="params">size</span>: <span class="type">Int</span>) -&gt; <span class="type">Suffix</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个协议里，<code>Suffix</code> 是一个关联类型，就像上边例子中 <code>Container</code> 的 <code>Item</code> 类型一样。<code>Suffix</code> 拥有两个约束：它必须遵循 <code>SuffixableContainer</code> 协议（就是当前定义的协议），以及它的 <code>Item</code> 类型必须是和容器里的 <code>Item</code> 类型相同。<code>Item</code> 的约束是一个 <code>where</code> 分句，它在下面<a href="#extensions-with-a-generic-where-clause">具有泛型 Where 子句的扩展</a>中有讨论。</p>
<p>这是上面 <a href="#generic-types">泛型类型</a> 中 <code>Stack</code> 类型的扩展，它遵循了 SuffixableContainer 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Stack</span>: <span class="title class_ inherited__">SuffixableContainer</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">suffix</span>(<span class="keyword">_</span> <span class="params">size</span>: <span class="type">Int</span>) -&gt; <span class="type">Stack</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result <span class="operator">=</span> <span class="type">Stack</span>()</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> (count<span class="operator">-</span>size)<span class="operator">..&lt;</span>count &#123;</span><br><span class="line">            result.append(<span class="keyword">self</span>[index])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 推断 suffix 结果是Stack。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stackOfInts <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">stackOfInts.append(<span class="number">10</span>)</span><br><span class="line">stackOfInts.append(<span class="number">20</span>)</span><br><span class="line">stackOfInts.append(<span class="number">30</span>)</span><br><span class="line"><span class="keyword">let</span> suffix <span class="operator">=</span> stackOfInts.suffix(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// suffix 包含 20 和 30</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>Suffix</code> 是 <code>Stack</code> 的关联类型，也是 <code>Stack</code> ，所以 <code>Stack</code> 的后缀运算返回另一个 <code>Stack</code> 。另外，遵循 <code>SuffixableContainer</code> 的类型可以拥有一个与它自己不同的 <code>Suffix</code> 类型——也就是说后缀运算可以返回不同的类型。比如说，这里有一个非泛型 <code>IntStack</code> 类型的扩展，它遵循了 <code>SuffixableContainer</code> 协议，使用 <code>Stack&lt;Int&gt;</code> 作为它的后缀类型而不是 <code>IntStack</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">IntStack</span>: <span class="title class_ inherited__">SuffixableContainer</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">suffix</span>(<span class="keyword">_</span> <span class="params">size</span>: <span class="type">Int</span>) -&gt; <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> result <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> (count<span class="operator">-</span>size)<span class="operator">..&lt;</span>count &#123;</span><br><span class="line">            result.append(<span class="keyword">self</span>[index])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 推断 suffix 结果是 Stack&lt;Int&gt;。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型-Where-语句">泛型 Where 语句</h2>
<p><a href="#type_constraints">类型约束</a> 让你能够为泛型函数、下标、类型的类型参数定义一些强制要求。</p>
<p>对关联类型添加约束通常是非常有用的。你可以通过定义一个泛型 <code>where</code> 子句来实现。通过泛型 <code>where</code> 子句让关联类型遵从某个特定的协议，以及某个特定的类型参数和关联类型必须类型相同。你可以通过将 <code>where</code> 关键字紧跟在类型参数列表后面来定义 <code>where</code> 子句，<code>where</code> 子句后跟一个或者多个针对关联类型的约束，以及一个或多个类型参数和关联类型间的相等关系。你可以在函数体或者类型的大括号之前添加 <code>where</code> 子句。</p>
<p>下面的例子定义了一个名为 <code>allItemsMatch</code> 的泛型函数，用来检查两个 <code>Container</code> 实例是否包含相同顺序的相同元素。如果所有的元素能够匹配，那么返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>被检查的两个 <code>Container</code> 可以不是相同类型的容器（虽然它们可以相同），但它们必须拥有相同类型的元素。这个要求通过一个类型约束以及一个 <code>where</code> 子句来表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">allItemsMatch</span>&lt;<span class="type">C1</span>: <span class="type">Container</span>, <span class="type">C2</span>: <span class="type">Container</span>&gt;</span><br><span class="line">    (<span class="keyword">_</span> <span class="params">someContainer</span>: <span class="type">C1</span>, <span class="keyword">_</span> <span class="params">anotherContainer</span>: <span class="type">C2</span>) -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">where</span> <span class="type">C1</span>.<span class="type">Item</span> <span class="operator">==</span> <span class="type">C2</span>.<span class="type">Item</span>, <span class="type">C1</span>.<span class="type">Item</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查两个容器含有相同数量的元素</span></span><br><span class="line">        <span class="keyword">if</span> someContainer.count <span class="operator">!=</span> anotherContainer.count &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查每一对元素是否相等</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>someContainer.count &#123;</span><br><span class="line">            <span class="keyword">if</span> someContainer[i] <span class="operator">!=</span> anotherContainer[i] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有元素都匹配，返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数接受 <code>someContainer</code> 和 <code>anotherContainer</code> 两个参数。参数 <code>someContainer</code> 的类型为 <code>C1</code>，参数 <code>anotherContainer</code> 的类型为 <code>C2</code>。<code>C1</code> 和 <code>C2</code> 是容器的两个占位类型参数，函数被调用时才能确定它们的具体类型。</p>
<p>这个函数的类型参数列表还定义了对两个类型参数的要求：</p>
<ul>
<li><code>C1</code> 必须符合 <code>Container</code> 协议（写作 <code>C1: Container</code>）。</li>
<li><code>C2</code> 必须符合 <code>Container</code> 协议（写作 <code>C2: Container</code>）。</li>
<li><code>C1</code> 的 <code>Item</code> 必须和 <code>C2</code> 的 <code>Item</code> 类型相同（写作 <code>C1.Item == C2.Item</code>）。</li>
<li><code>C1</code> 的 <code>Item</code> 必须符合 <code>Equatable</code> 协议（写作 <code>C1.Item: Equatable</code>）。</li>
</ul>
<p>前两个要求定义在函数的类型形式参数列表里，后两个要求定义在了函数的泛型 <code>where</code> 分句中。</p>
<p>这些要求意味着：</p>
<ul>
<li><code>someContainer</code> 是一个 <code>C1</code> 类型的容器。</li>
<li><code>anotherContainer</code> 是一个 <code>C2</code> 类型的容器。</li>
<li><code>someContainer</code> 和 <code>anotherContainer</code> 包含相同类型的元素。</li>
<li><code>someContainer</code> 中的元素可以通过不等于操作符（!=）来检查它们是否相同。</li>
</ul>
<p>第三个和第四个要求结合起来意味着 <code>anotherContainer</code> 中的元素也可以通过 <code>!=</code> 操作符来比较，因为它们和 <code>someContainer</code> 中的元素类型相同。</p>
<p>这些要求让 <code>allItemsMatch(_:_:)</code> 函数能够比较两个容器，即使它们的容器类型不同。</p>
<p><code>allItemsMatch(_:_:)</code> 函数首先检查两个容器元素个数是否相同，如果元素个数不同，那么一定不匹配，函数就会返回 <code>false</code>。</p>
<p>进行这项检查之后，通过 <code>for-in</code> 循环和半闭区间操作符（<code>..&lt;</code>）来迭代每个元素，检查 <code>someContainer</code> 中的元素是否不等于 <code>anotherContainer</code> 中的对应元素。如果两个元素不相等，那么两个容器不匹配，函数返回 false。</p>
<p>如果循环体结束后未发现任何不匹配的情况，表明两个容器匹配，函数返回 <code>true</code>。</p>
<p>下面是 <code>allItemsMatch(_:_:)</code> 函数的示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stackOfStrings <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;uno&quot;</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;dos&quot;</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;tres&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrayOfStrings <span class="operator">=</span> [<span class="string">&quot;uno&quot;</span>, <span class="string">&quot;dos&quot;</span>, <span class="string">&quot;tres&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> allItemsMatch(stackOfStrings, arrayOfStrings) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;All items match.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Not all items match.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“All items match.”</span></span><br></pre></td></tr></table></figure>
<p>上面的例子创建 <code>Stack</code> 实例来存储 <code>String</code> 值，然后将三个字符串压栈。这个例子还通过数组字面量创建了一个 <code>Array</code> 实例，数组中包含同栈中一样的三个字符串。即使栈和数组是不同的类型，但它们都遵从 <code>Container</code> 协议，而且它们都包含相同类型的值。因此你可以用这两个容器作为参数来调用 <code>allItemsMatch(_:_:)</code> 函数。在上面的例子中，<code>allItemsMatch(_:_:)</code> 函数正确地显示了这两个容器中的所有元素都是相互匹配的。</p>
<h2 id="具有泛型-Where-子句的扩展">具有泛型 Where 子句的扩展</h2>
<p>你也可以使用泛型 <code>where</code> 子句作为扩展的一部分。基于以前的例子，下面的示例扩展了泛型 <code>Stack</code> 结构体，添加一个 <code>isTop(_:)</code> 方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Stack</span> <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isTop</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Element</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> topItem <span class="operator">=</span> items.last <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> topItem <span class="operator">==</span> item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个新的 <code>isTop(_:)</code> 方法首先检查这个栈是不是空的，然后比较给定的元素与栈顶部的元素。如果你尝试不用泛型 <code>where</code> 子句，会有一个问题：在 <code>isTop(_:)</code> 里面使用了 <code>==</code> 运算符，但是 <code>Stack</code> 的定义没有要求它的元素是符合 <code>Equatable</code> 协议的，所以使用 <code>==</code> 运算符导致编译时错误。使用泛型 <code>where</code> 子句可以为扩展添加新的条件，因此只有当栈中的元素符合 <code>Equatable</code> 协议时，扩展才会添加 <code>isTop(_:)</code> 方法。</p>
<p>以下是 <code>isTop(_:)</code> 方法的调用方式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> stackOfStrings.isTop(<span class="string">&quot;tres&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Top element is tres.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Top element is something else.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Top element is tres.”</span></span><br></pre></td></tr></table></figure>
<p>如果尝试在其元素不符合 <code>Equatable</code> 协议的栈上调用 <code>isTop(_:)</code> 方法，则会收到编译时错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NotEquatable</span> &#123; &#125;</span><br><span class="line"><span class="keyword">var</span> notEquatableStack <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">NotEquatable</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> notEquatableValue <span class="operator">=</span> <span class="type">NotEquatable</span>()</span><br><span class="line">notEquatableStack.push(notEquatableValue)</span><br><span class="line">notEquatableStack.isTop(notEquatableValue)  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>你可以使用泛型 <code>where</code> 子句去扩展一个协议。基于以前的示例，下面的示例扩展了 <code>Container</code> 协议，添加一个 <code>startsWith(_:)</code> 方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Container</span> <span class="keyword">where</span> <span class="type">Item</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">startsWith</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count <span class="operator">&gt;=</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> <span class="keyword">self</span>[<span class="number">0</span>] <span class="operator">==</span> item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>startsWith(_:)</code> 方法首先确保容器至少有一个元素，然后检查容器中的第一个元素是否与给定的元素相等。任何符合 <code>Container</code> 协议的类型都可以使用这个新的 <code>startsWith(_:)</code> 方法，包括上面使用的栈和数组，只要容器的元素是符合 <code>Equatable</code> 协议的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>].startsWith(<span class="number">42</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Starts with 42.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Starts with something else.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Starts with something else.”</span></span><br></pre></td></tr></table></figure>
<p>上述示例中的泛型 <code>where</code> 子句要求 <code>Item</code> 遵循协议，但也可以编写一个泛型 <code>where</code> 子句去要求 <code>Item</code> 为特定类型。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Container</span> <span class="keyword">where</span> <span class="type">Item</span> <span class="operator">==</span> <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">average</span>() -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> sum <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>count &#123;</span><br><span class="line">            sum <span class="operator">+=</span> <span class="keyword">self</span>[index]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum <span class="operator">/</span> <span class="type">Double</span>(count)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>([<span class="number">1260.0</span>, <span class="number">1200.0</span>, <span class="number">98.6</span>, <span class="number">37.0</span>].average())</span><br><span class="line"><span class="comment">// 打印“648.9”</span></span><br></pre></td></tr></table></figure>
<p>此示例将一个 <code>average()</code> 方法添加到 <code>Item</code> 类型为 <code>Double</code> 的容器中。此方法遍历容器中的元素将其累加，并除以容器的数量计算平均值。它将数量从 <code>Int</code> 转换为 <code>Double</code> 确保能够进行浮点除法。</p>
<p>就像可以在其他地方写泛型 <code>where</code> 子句一样，你可以在一个泛型 <code>where</code> 子句中包含多个条件作为扩展的一部分。用逗号分隔列表中的每个条件。</p>
<h2 id="具有泛型-Where-子句的关联类型">具有泛型 Where 子句的关联类型</h2>
<p>你可以在关联类型后面加上具有泛型 <code>where</code> 的字句。例如，建立一个包含迭代器（<code>Iterator</code>）的容器，就像是标准库中使用的 <code>Sequence</code> 协议那样。你应该这么写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Iterator</span>: <span class="type">IteratorProtocol</span> <span class="keyword">where</span> <span class="type">Iterator</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">Item</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeIterator</span>() -&gt; <span class="type">Iterator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代器（<code>Iterator</code>）的泛型 <code>where</code> 子句要求：无论迭代器是什么类型，迭代器中的元素类型，必须和容器项目的类型保持一致。<code>makeIterator()</code> 则提供了容器的迭代器的访问接口。</p>
<p>一个协议继承了另一个协议，你通过在协议声明的时候，包含泛型 <code>where</code> 子句，来添加了一个约束到被继承协议的关联类型。例如，下面的代码声明了一个 <code>ComparableContainer</code> 协议，它要求所有的 <code>Item</code> 必须是 <code>Comparable</code> 的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">ComparableContainer</span>: <span class="title class_ inherited__">Container</span> <span class="keyword">where</span> <span class="title class_ inherited__">Item</span>: <span class="title class_ inherited__">Comparable</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型下标">泛型下标</h2>
<p>下标可以是泛型，它们能够包含泛型 <code>where</code> 子句。你可以在 <code>subscript</code> 后用尖括号来写占位符类型，你还可以在下标代码块花括号前写 <code>where</code> 子句。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">subscript</span>&lt;<span class="type">Indices</span>: <span class="type">Sequence</span>&gt;(<span class="params">indices</span>: <span class="type">Indices</span>) -&gt; [<span class="type">Item</span>]</span><br><span class="line">        <span class="keyword">where</span> <span class="type">Indices</span>.<span class="type">Iterator</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">Int</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> result <span class="operator">=</span> [<span class="type">Item</span>]()</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> indices &#123;</span><br><span class="line">                result.append(<span class="keyword">self</span>[index])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>Container</code> 协议的扩展添加了一个下标方法，接收一个索引的集合，返回每一个索引所在的值的数组。这个泛型下标的约束如下：</p>
<ul>
<li>在尖括号中的泛型参数 <code>Indices</code>，必须是符合标准库中的 <code>Sequence</code> 协议的类型。</li>
<li>下标使用的单一的参数，<code>indices</code>，必须是 <code>Indices</code> 的实例。</li>
<li>泛型 <code>where</code> 子句要求 <code>Sequence（Indices）</code>的迭代器，其所有的元素都是 <code>Int</code> 类型。这样就能确保在序列（<code>Sequence</code>）中的索引和容器（<code>Container</code>）里面的索引类型是一致的。</li>
</ul>
<p>综合一下，这些约束意味着，传入到 <code>indices</code> 下标，是一个整型的序列。</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">標籤</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/swift/" rel="tag">swift</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../11/Swift/swift%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"
                    data-tooltip="swift自动引用计数"
                    aria-label="上一篇: swift自动引用计数"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../09/Swift/swift%E5%8D%8F%E8%AE%AE/"
                    data-tooltip="swift协议"
                    aria-label="下一篇: swift协议"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://keinchan.com/2023/07/10/Swift/swift%E6%B3%9B%E5%9E%8B/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://keinchan.com/2023/07/10/Swift/swift%E6%B3%9B%E5%9E%8B/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://keinchan.com/2023/07/10/Swift/swift%E6%B3%9B%E5%9E%8B/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://keinchan.com/2023/07/10/Swift/swift%E6%B3%9B%E5%9E%8B/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../11/Swift/swift%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"
                    data-tooltip="swift自动引用计数"
                    aria-label="上一篇: swift自动引用计数"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../09/Swift/swift%E5%8D%8F%E8%AE%AE/"
                    data-tooltip="swift协议"
                    aria-label="下一篇: swift协议"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://keinchan.com/2023/07/10/Swift/swift%E6%B3%9B%E5%9E%8B/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://keinchan.com/2023/07/10/Swift/swift%E6%B3%9B%E5%9E%8B/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://keinchan.com/2023/07/10/Swift/swift%E6%B3%9B%E5%9E%8B/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://keinchan.com/2023/07/10/Swift/swift%E6%B3%9B%E5%9E%8B/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://keinchan.com/2023/07/10/Swift/swift%E6%B3%9B%E5%9E%8B/"
                        aria-label="分享到 Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://keinchan.com/2023/07/10/Swift/swift%E6%B3%9B%E5%9E%8B/"
                        aria-label="分享到 Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://keinchan.com/2023/07/10/Swift/swift%E6%B3%9B%E5%9E%8B/"
                        aria-label="global.share_on_linkedin"
                    >
                        <i class="fab fa-linkedin" aria-hidden="true"></i><span>global.share_on_linkedin</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=https://keinchan.com/2023/07/10/Swift/swift%E6%B3%9B%E5%9E%8B/"
                        aria-label="分享到 Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 235 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
