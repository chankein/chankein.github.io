
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>Astar搜索算法简介及保姆级代码解读 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg"},"articleBody":"A*搜索算法简介及保姆级代码解读\n\n1. A*算法简单介绍\n\n\n1.1 A*算法理论基础\n\n\n1.1.1 节点计算\n1.1.2 由计算得出的小结论\n\n\n1.2 算法逻辑结构\n\n\n2. 代码解析\n\n\n2.1 引入地图\n2.2 预处理\n2.3 定义父节点`parent`\n2.4 主循环\n\n\n2.4.1\n2.4.2\n2.4.3\n2.4.4\n2.4.5\n\n\n2.5 画图\n\n\n3. 结果\n\n1. A*算法简单介绍\nA*算法是一种路径规划算法，和传统的Dijkstra算法有所不同，该算法有选择地进行节点搜索，因此比Dijkstra算法更快、搜索的点更少。\n阅读本文，不需要掌握Dijkstra算法的知识，请放心食用。\n注意：本文只介绍二维A*算法及相关示例。\nPS：本文代码编写参考B站up主\n小黎的Ally的路径规划与轨迹跟踪系列算法学习_第4讲_A*算法，讲解详细，本文代码部分是将其代码进行了些许改动并加以解释，在此对up主的辛苦表达感谢！！\nPPS：本文所使用的把地图栅格化的函数来自于博客\nMatlab中将一幅图片做成栅格地图，本文进行了些许改动，再次一并感谢博主的辛苦！\n1.1 A*算法理论基础\nA*算法首先将要搜索的区域划分为若干栅格（grid），并有选择地标识出障碍物（Obstacle）与空白区域。一般地，栅格划分越细密，搜索点数越多，搜索过程越慢，计算量也越大；栅格划分越稀疏，搜索点数越少，相应地搜索精确性就越低。\n\n如上图，引入地图信息后画出栅格，该图片采用 100 × 100 100 \\times 100 100×100的栅格划分，图中黑色区域为障碍物区域。图中绿点为起始点，红点为终点。\n对每个节点，在计算时同时考虑两项代价指标：当前节点与起始点的距离，以及当前节点与目标点的距离：\nf = g + h f = g + h f=g+h其中 f f f为总代价， g g g为当前节点距离起始点的距离， h h h为当前节点距离目标点的距离。\n而在计算距离时，又可以采用两种方式：\n欧氏距离：\nL = ( x 1 − x 2 ) 2 + ( y 1 − y 2 ) 2 L = \\sqrt{\\left( x_1 - x_2 \\right) ^2 + \\left( y_1 - y_2 \\right) ^2} L=(x1​−x2​)2+(y1​−y2​)2 ​曼哈顿距离：\nL = ∣ x 1 − x 2 ∣ + ∣ y 1 − y 2 ∣ L = \\lvert x_1 - x_2 \\rvert + \\lvert y_1 - y_2 \\rvert L=∣x1​−x2​∣+∣y1​−y2​∣为了计算方便，本文计算 h h h时采用曼哈顿距离，这也是A*算法中的一贯做法。\n为了方便计数，在计算每一个节点时，在栅格左上角写 f f f值，左下角写 g g g值，右下角写 h h h值。\n1.1.1 节点计算\n这里举一个例子。\n\n如图所示，A点为起始点，M点为终点。对于A点来说，对其周边的8个节点进行寻找，A点本身为父节点，周边8个点为子节点。\n假设：\n\n格子边长为10，这样水平和竖直位移一格为10，而对角位移一格为14；\n从父节点到子节点可以水平、竖直、对角线位移计算 g g g值，而从子节点到目标点只能使用水平、竖直位移计算曼哈顿距离 h h h值。\n\n对于点B：从A到B只需右移一格，因此B的 g = 10 g=10 g=10；从B到M需要先右移四格，再上移三格，因此B的 h = 40 + 30 = 70 h = 40+30=70 h=40+30=70。这样B的 f = g + h = 10 + 70 = 80 f=g+h=10+70=80 f=g+h=10+70=80。将三者都记在B格中。\n对于点C：从A到C只需向右上方平移一格，因此C的 g = 14 g=14 g=14；从C到M需要先右移四格，再上移两格，因此C的 h = 40 + 20 = 60 h=40+20=60 h=40+20=60，继而C的 f = g + h = 74 f=g+h=74 f=g+h=74。\n同理可以计算出D的 g = 14 , h = 80 , f = 94 g=14, h=80,f=94 g=14,h=80,f=94，以及其他几个子节点的值。\n将这8个子节点进行对比，可以发现，C点的 f f f值最小，因此选取C点为下一步搜寻的父节点， A C ‾ \\overline{AC} AC即为路径迈出的第一步。\n\n如图所示，现在将C作为新的父节点。\n对于J点：\n从C到J只需右移一格，因此J的 g = 10 + g C = 10 + 14 = 24 g=10+g_C =10+14=24 g=10+gC​=10+14=24。需要注意的是，J点的 g g g值是从C到J的 g g g加上从A到C的 g g g，即当前子节点的 g g g值是从起点到该点的所有 g g g累和。\n从J到M需要先右移三格，再上移两格，因此J的 h = 30 + 20 = 50 h = 30+20=50 h=30+20=50。这样J的 f = g + h = 24 + 50 = 74 f=g+h=24+50=74 f=g+h=24+50=74。将三者都记在J格中。\n对于I点：\n从C到I只需向右上方平移一格，同样地，I点的 g g g值是从C到I的 g g g加上从A到C的 g g g，即当前子节点的 g g g值是从起点到该点的所有 g g g累和，因此I的 g = 14 + g C = 14 + 14 = 28 g=14+g_C =14+14=28 g=14+gC​=14+14=28。\n从I到M需要先右移三格，再上移一格，因此I的 h = 30 + 10 = 40 h = 30+10=40 h=30+10=40。这样I的 f = g + h = 28 + 40 = 68 f=g+h=28+40=68 f=g+h=28+40=68。将三者都记在I格中。\n同样计算出其他点的值。\n可以看出，I点的 f f f值最小，因此选择I点作为路径上的下一个点，此时路径变为 A C I ‾ \\overline{ACI} ACI。\n如此一步步进行迭代，最后找到最优轨迹。\n1.1.2 由计算得出的小结论\n\n每个节点中需要存储至少3个值： g , h , f g,h,f g,h,f。\n当子节点迭代到目标点本身时， h = 0 h=0 h=0，即当前节点到目标点的距离为0.\n在算法实施时， g g g的计算可以取10或14，即从父节点到子节点可以水平/竖直位移，也可以沿对角线位移；而 h h h的计算只能取10的倍数，即从当前子节点到目标点只能水平/竖直位移。前者可以采用欧氏距离，后者只能采用曼哈顿距离。\n当某个子节点被选中后，就作为下一次搜索的父节点；并且为了避免节点的重复计算和筛选，在下一次搜索时，需要将上一步选中的节点从“可搜索”列表中删除。如上图中，当C为父节点时，选中I作为下一次的父节点；那么当第二步I为父节点时，由于C已经在已选轨迹上了，所以I的子节点实际上并不包括C，只计算7个子节点即可。\n鉴于上一点，可以预想，算法的具体实施过程中，需要有两个数组保存“待计算子节点”和“已被选中的节点”。当“待计算子节点”中某个点符合 f f f最小时，就将其加入“已选中的节点”，并在“待计算子节点”中删除该点，防止后续重复计算。\n当算法结束时，保存在“已选中的节点”中的所有点，按照顺序即为找出的路径。\n算法结束时，最后一个点的 f f f值，即为从起点到终点所用的距离。\n算法的停止条件：1)当“待计算子节点”中没有点时，即已经没有点可供寻找了；2)当当前父节点恰为目标节点时，即 h = 0 h=0 h=0。\n\n1.2 算法逻辑结构\nA*算法的逻辑结构如下：\n1）初始化。导入地图信息，设置障碍物区域，设置起点start、终点target、栅格数量 m × n m \\times n m×n等。\n2）数据预处理。建立“待计算子节点”的数组openlist，“已选中的节点”的数组closelist，保存路径的数组closelist_path。除此之外，还需建立一个当前子节点集合children，用来保存当前父节点周围8个子节点的坐标，以及父节点本身parent；还有保存代价值 g , h , f g, h,f g,h,f的数组openlist_cost和closelist_cost。\n3）对子节点们children中的每个节点child：\n若该子节点不在“待计算子节点”节点openlist中，则追加进去；\n若在，则计算出该child的 g g g值，该 g g g值是从起点到父节点parent的距离加上父节点到该子节点的距离。若该 g g g值小于之前openlist_cost中的 g g g最小值，那么就将openlist_cost中的最小 g g g值更新；\n4）由于该代价最小点已经加入了轨迹，因此将该点加入clost_list和closelist_path，并从openlist中剔除；\n5）更新openlist中的最小代价值，并以其为父节点开始新一轮搜索。\n2. 代码解析\n2.1 引入地图\n代码块：\n12345678910111213141516171819202122232425262728293031323334353637383940%% 画地图% 栅格地图的行数、列数定义m = 150;n = 150;% 地图m行n列start = [10, 20];        % 起始节点target = [130, 80];       % 终止节点obs = TrunToGridMap(m, n);% 画格子for i = 0 : 5 : m    plot([0, n], [i, i], &#x27;k&#x27;, &#x27;handlevisibility&#x27;, &#x27;off&#x27;);    hold on;endfor j = 0 : 5 : n    plot([j, j], [0, m], &#x27;k&#x27;, &#x27;handlevisibility&#x27;, &#x27;off&#x27;);endaxis equal;xlim([0, n]);ylim([0, m]);% 绘制障碍物、起止点颜色块scatter(start(1), start(2), 700, &#x27;pg&#x27;, &#x27;filled&#x27;);scatter(target(1), target(2), 700, &#x27;pr&#x27;, &#x27;filled&#x27;);for i = 1 : size(obs, 1) - 1    temp = obs(i, :);    fill([temp(1)-1, temp(1), temp(1), temp(1)-1],...        [temp(2)-1, temp(2)-1, temp(2), temp(2)], &#x27;k&#x27;, &#x27;handlevisibility&#x27;, &#x27;off&#x27;);endtemp = obs(size(obs, 1), :);fill([temp(1)-1, temp(1), temp(1), temp(1)-1],...    [temp(2)-1, temp(2)-1, temp(2), temp(2)], &#x27;k&#x27;);\n绘制一个 150 × 150 150 \\times 150 150×150的地图，起点设置为 ( 10 , 20 ) (10,20) (10,20)，终点设置为 ( 130 , 80 ) (130,80) (130,80)。\n障碍物的坐标通过函数TrunToGridMap(m, n)获得：\n12345678910111213141516171819202122232425262728function obs = TrunToGridMap(a, b)    I=imread(&#x27;此处放地图图片的文件名&#x27;);   %读入图片    I = rgb2gray(I);     %将图片转为灰度图    I = imrotate(I, -90);    l=1;    %网格边长    B = imresize(I,[a/l b/l]);    J=floor(B/255);     axes(&#x27;GridLineStyle&#x27;, &#x27;-&#x27;);    axis equal;    hold on    grid on    axis([0,a,0,b]);    set(gca,&#x27;xtick&#x27;,0:10:a,&#x27;ytick&#x27;,0:10:b);    obs = [];    %障碍物填充为黑色    for i=1:a/l-1        for j=1:b/l-1            if(J(i,j)==0)                obs(end+1, :) = [i, j];            end        end    endend\n该函数读取一个图片文件，将其转化为灰度图像，并将灰度图中黑色色块所在的坐标返回为障碍物坐标。\n2.2 预处理\n1234567891011121314151617181920212223%% 预处理% 初始化closelistcloselist = start;closelist_path = &#123;start, start&#125;;      % 路径，从自身到自身closelist_cost = 0;children = child_nodes_cal(start, m, n, obs, closelist);% 初始化openlistopenlist = children;for i = 1 : size(openlist, 1)   % i为第i个节点    openlist_path&#123;i, 1&#125; = openlist(i, :);   % openlist_path的第i行第1列为第i个节点child    openlist_path&#123;i, 2&#125; = [start; openlist(i, :)]; % openlist_path的第i行第2列为一个列向量，分别是起始节点和当前childendfor i = 1 : size(openlist, 1)    g = norm(start - openlist(i, 1:2));    h = abs(target(1) - openlist(i, 1)) + abs(target(2) - openlist(i, 2));    f = g + h;    openlist_cost(i, :) = [g, h, f];end\n这一部分主要做了以下几步：\n\n把起点start设为轨迹的第一个点：closelist = start；\n路径初始化，即从起点到起点：closelist_path = &#123;start, start&#125;；\n代价首先置为0：closelist_cost = 0；\n利用child_nodes_cal函数计算当前父节点（即起点）周围的子节点们；\n这些子节点们children即为待计算的子节点，也就是openlist；\n随后进入一个循环，对每一个子节点i，openlist_path中第i行第1个元素储存第i个节点child，第2个元素为一个列向量，分别是第i个child的起点和它本身；\n第二个循环则是计算代价的循环，对每一个子节点i，计算 g g g（这里使用范数norm）， h h h（曼哈顿距离）和 f f f；之后，在代价数组openlist_cost中储存这三个代价值，因此openlist_cost第i行的元素为一个行向量；\n\n其中用到的子节点计算函数如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889function child_nodes = child_nodes_cal(parent_node, m, n, obs, closelist)    child_nodes = [];    field = [1, 1;        n, 1;        n, m;        1, m];        % 左上子节点    child_node = [parent_node(1) - 1, parent_node(2) + 1];    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))        % [in, on] = inpolygon, 返回 in，以指明 xq 和 yq 所指定的查询点是在 xv 和         % yv 定义的多边形区% 域的边缘内部还是在边缘上,in为内部，on为边缘上        if ~ismember(child_node, obs, &#x27;rows&#x27;)            child_nodes = [child_nodes; child_node];        end    end            % 上子节点    child_node = [parent_node(1), parent_node(2) + 1];    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))        if ~ismember(child_node, obs, &#x27;rows&#x27;)            child_nodes = [child_nodes; child_node];        end    end            % 右上子节点    child_node = [parent_node(1) + 1, parent_node(2) + 1];    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))        if ~ismember(child_node, obs, &#x27;rows&#x27;)            child_nodes = [child_nodes; child_node];        end    end        % 左子节点    child_node = [parent_node(1) - 1, parent_node(2)];    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))        if ~ismember(child_node, obs, &#x27;rows&#x27;)            child_nodes = [child_nodes; child_node];        end    end        %右子节点    child_node = [parent_node(1) + 1, parent_node(2)];    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))        if ~ismember(child_node, obs, &#x27;rows&#x27;)            child_nodes = [child_nodes; child_node];        end    end            %左下子节点    child_node = [parent_node(1) - 1, parent_node(2) - 1];    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))        if ~ismember(child_node, obs, &#x27;rows&#x27;)            child_nodes = [child_nodes; child_node];        end    end            % 下子节点    child_node = [parent_node(1), parent_node(2) - 1];    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))        if ~ismember(child_node, obs, &#x27;rows&#x27;)            child_nodes = [child_nodes; child_node];        end    end            % 右下子节点    child_node = [parent_node(1) + 1, parent_node(2) - 1];    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))        if ~ismember(child_node, obs, &#x27;rows&#x27;)            child_nodes = [child_nodes; child_node];        end    end            %% 排除已经存在于closelist的节点    delete_idx = [];    for i = 1 : size(child_nodes, 1)        if ismember(child_nodes(i, :), closelist, &#x27;rows&#x27;)            delete_idx(end+1, :) = i;        end    end        child_nodes(delete_idx, :) = [];end\n2.3 定义父节点parent\n1234%% 定义父节点% 从openlist开始搜索移动代价最小的节点[~, min_idx] = min(openlist_cost(:, 3));    % 看f值最小，min_idx为f最小的那一行parent = openlist(min_idx, :);% 以min_idx该行的子节点child_node为新的父节点\n这一步搜索openlist_cost代价数组中 f f f最小的元素，记下其索引min_idx；\n随后该索引对应的openlist中的元素即为“ f f f值最小的待计算子节点”，作为下一步计算的父节点parent。\n2.4 主循环\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859%% 进入循环flag = 1;while flag    % 找出父节点的忽略closelist的子节点    children = child_nodes_cal(parent ,m, n, obs, closelist);        % 判断这些子节点是否在openlist中，若在，则更新；没在，则追加到openlist中    for i = 1 : size(children, 1)        child = children(i, :);        [in_flag, openlist_idx] = ismember(child, openlist, &#x27;rows&#x27;);        % in_flag表示该child_node是否在openlist中        % openlist_idx表示该child_node在openlist中的行数                g = openlist_cost(min_idx, 1) + norm(parent - child);        % 原来的g加上新的g        h = abs(child(1) - target(1)) + abs(child(2) - target(2));        f = g + h;                if in_flag  % 若在，则比较更新g, f            if g &lt; openlist_cost(openlist_idx, 1)                   % openlist_cost(openlist_idx,1)指的是openlist_cost中idx这一行（即child_node所在的一行）的第一个坐标，即g                openlist_cost(openlist_idx, 1) = g;                openlist_cost(openlist_idx, 3) = f;                openlist_path&#123;openlist_idx, 2&#125; = [openlist_path&#123;min_idx, 2&#125;; child];                % openlist_path的第i行第2列为一个列向量，分别是起始节点和当前child，此处定义新的起始节点为openlist_path(min_idx,2)， 而openlist_path(min_idx,2)指第min_idx行所对应的 child在openlist_path中对应的路径，相当于把新的child附加到了路径上，延长了路径            end        else            openlist(end+1, :) = child;            openlist_cost(end+1, :) = [g, h, f];            openlist_path&#123;end+1, 1&#125; = child;            openlist_path&#123;end, 2&#125; = [openlist_path&#123;min_idx, 2&#125;; child];        end    end            % 从openlist移除代价最小的节点到closelist    closelist(end+1, :) = openlist(min_idx, :);    closelist_cost(end+1, :) = openlist_cost(min_idx, 3);    closelist_path(end+1, :) = openlist_path(min_idx, :);        % 同样地，openlist中少了该节点    openlist(min_idx, :) = [];    openlist_cost(min_idx, :) = [];    openlist_path(min_idx, :) = [];            % 重新搜索：从openlist搜索移动代价最小的节点，作为新的父节点    [~, min_idx] = min(openlist_cost(:, 3));    parent = openlist(min_idx, :);        % 判断是否搜索到终点    if parent == target        closelist(end+1, :) = openlist(min_idx, :);        closelist_cost(end+1, 1) = openlist_cost(min_idx, 1);        closelist_path(end+1, :) = openlist_path(min_idx, :);        flag = 0;    endend\n2.4.1\n对这一部分循环来说，首先利用child_nodes_cal函数得出当前父节点parent周围的子节点们children；\n对每一个子节点child，判断其是否在“待计算子节点”openlist列表中——in_flag=1表示在列表中，同时openlist_idx为该子节点在openlist中的索引号。\n判断完成后，首先计算该子节点的 g , h , f g,h,f g,h,f值，注意： g g g值为父节点parent的 g g g加上该child子节点的 g g g值。\n2.4.2\n计算 g , h , f g,h,f g,h,f之后，再来看子节点在openlist中的情况。由于循环中查看了parent周围所有子节点的情况，所以一定会存在某个子节点的 g g g比其他子节点的 g g g都小。如果找到了这样的子节点，那么就更新该子节点在openlist_cost中对应位置的 g , h , f g,h,f g,h,f值。\n同时，还要将该子节点加入到路径openlist_path中，即这一句代码\n1openlist_path&#123;openlist_idx, 2&#125; = [openlist_path&#123;min_idx, 2&#125;; child];\n这行代码的含义是：\nopenlist_idx表示当前子节点child在openlist中的索引，min_idx表示之前所有子节点中代价最小的子节点的索引。之前在预处理一节中提到，openlist_path的第i行第2列为一个列向量，分别是父节点和当前child，相当于第2列储存了路径。\n而min_idx表示“代价最小的节点”，也就是父节点parent。因此这里openlist_path&#123;min_idx, 2&#125;表示父节点的路径。而[openlist_path&#123;min_idx, 2&#125;; child]则是把新的child附加到这一个列向量上，相当于把新的child附加到路径尾端，把向量长度延长了一个child，延长了路径。\n这样，[openlist_path&#123;min_idx, 2&#125;; child]构成了一个“父节点路径-当前child”的新路径。\n把这个新路径赋值给openlist_idx索引所对应的openlist_path上，即为该openlist_idx索引对应的子节点的路径。\n2.4.3\n另一方面，如果该child不在openlist中，那么就把该child添加到“待计算子节点”列表中，其 g , h , f g,h,f g,h,f值添加到openlist_cost代价列表中，其路径[openlist_path&#123;min_idx, 2&#125;; child]添加到路径openlist_path中。\n2.4.4\n由于移动代价最小的节点已经是路径上的一点了，所以为了避免重复计算，应当把她从“待计算子节点”列表中删除，加入“已计算节点”中，即\n1234567closelist(end+1, :) = openlist(min_idx, :);closelist_cost(end+1, :) = openlist_cost(min_idx, 3);closelist_path(end+1, :) = openlist_path(min_idx, :);% openlist中少了该节点openlist(min_idx, :) = [];openlist_cost(min_idx, :) = [];openlist_path(min_idx, :) = [];\n仔细观察不难发现，min_idx对应的正是这一步的parent节点，直到这里，我们才把它加入到“已计算节点”列表中，在之前它一直呆在openlist中。\n2.4.5\n父节点加入到了“已计算节点”中了，那么下一步就没有父节点了，所以需要找出新的父节点：\n12 [~, min_idx] = min(openlist_cost(:, 3));parent = openlist(min_idx, :);\n同时还需要判断一下，是否已经进行到了程序结束：\n1234567% 判断是否搜索到终点if parent == target    closelist(end+1, :) = openlist(min_idx, :);    closelist_cost(end+1, 1) = openlist_cost(min_idx, 1);    closelist_path(end+1, :) = openlist_path(min_idx, :);    flag = 0;end\n需要注意，即使当当前父节点已经是目标点了，也不要忘了把这个父节点加入到“已计算节点”中，相当于把目标点添加入路径中，形成路径上最后一个点。\n2.5 画图\n这一步就是将结果绘制出来了：\n123456789path_opt = closelist_path&#123;end, 2&#125;;% closelist_path中第二列存放路径，所以path_opt存放的是路径的(x,y)值path_opt(:, 1) = path_opt(:, 1) - 0.5;path_opt(:, 2) = path_opt(:, 2) - 0.5;plot(path_opt(:, 1), path_opt(:, 2), &#x27;m&#x27;, &#x27;linewidth&#x27;, 1.5);title([&#x27;Total length of path: &#x27; num2str(closelist_cost(end, 1))]);legend(&#x27;Start node&#x27;, &#x27;Target node&#x27;, &#x27;Obstacle&#x27;, &#x27;Path&#x27;, &#x27;location&#x27;, &#x27;northwest&#x27;);set(gca, &#x27;fontsize&#x27;, 35, &#x27;fontname&#x27;, &#x27;times new roman&#x27;);\n3. 结果\n这里导入稻妻地图作为路径规划的示例，该地图多为岛屿，路径复杂，障碍物分散且数量多，十分适合作为示例使用。\n\n将其灰度化得到\n\n把地图划分为 m × n = 150 × 150 m \\times n = 150 \\times 150 m×n=150×150的栅格，并设置起点为 ( 10 , 20 ) (10,20) (10,20)，终点为 ( 130 , 80 ) (130,80) (130,80)：\n\n图中绿色为起点，红色为终点。\n路径规划结果：\n\n可以看出，A* 算法可以找到期望路径。\n文件所有代码在笔者的资源二维A*算法路径规划matlab代码中可以下载得到。\n","dateCreated":"2023-04-14T15:43:00+08:00","dateModified":"2025-06-03T16:26:19+08:00","datePublished":"2023-04-14T15:43:00+08:00","description":"","headline":"Astar搜索算法简介及保姆级代码解读","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://chankein.github.io/2023/04/14/Algorithms/Astar%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BF%9D%E5%A7%86%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"},"publisher":{"@type":"Organization","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg","logo":{"@type":"ImageObject","url":"profile.jpg"}},"url":"https://chankein.github.io/2023/04/14/Algorithms/Astar%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BF%9D%E5%A7%86%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/","keywords":"算法"}</script>
    <meta name="description" content="A*搜索算法简介及保姆级代码解读  1. A*算法简单介绍   1.1 A*算法理论基础   1.1.1 节点计算 1.1.2 由计算得出的小结论   1.2 算法逻辑结构   2. 代码解析   2.1 引入地图 2.2 预处理 2.3 定义父节点&#96;parent&#96; 2.4 主循环   2.4.1 2.4.2 2.4.3 2.4.4 2.4.5   2.5 画图   3. 结果  1. A*算法简">
<meta property="og:type" content="blog">
<meta property="og:title" content="Astar搜索算法简介及保姆级代码解读">
<meta property="og:url" content="https://chankein.github.io/2023/04/14/Algorithms/Astar%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BF%9D%E5%A7%86%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:description" content="A*搜索算法简介及保姆级代码解读  1. A*算法简单介绍   1.1 A*算法理论基础   1.1.1 节点计算 1.1.2 由计算得出的小结论   1.2 算法逻辑结构   2. 代码解析   2.1 引入地图 2.2 预处理 2.3 定义父节点&#96;parent&#96; 2.4 主循环   2.4.1 2.4.2 2.4.3 2.4.4 2.4.5   2.5 画图   3. 结果  1. A*算法简">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/e5a5e9d6d0f36afb2bf3f1cd9ef378ac.png#pic_center">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/86fca2663892fb458c7cdef9e81facdf.jpeg#pic_center">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/61d8dbfe6ffe8e4eb0d95eb32b2a6032.jpeg#pic_center">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/fcf59433821c1051a8f8714547d79018.png#pic_center">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/124b144e99366faa9e582a913fc277e3.jpeg#pic_center">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/50113f38beb35b89434c28535c12ba1b.png#pic_center">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/8a875e6b8ffc0c48064351488be0d262.png#pic_center">
<meta property="article:published_time" content="2023-04-14T07:43:00.000Z">
<meta property="article:modified_time" content="2025-06-03T08:26:19.677Z">
<meta property="article:author" content="Kein Chan">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i-blog.csdnimg.cn/blog_migrate/e5a5e9d6d0f36afb2bf3f1cd9ef378ac.png#pic_center">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../../../#about"
            >
        
        
            <img class="header-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Astar搜索算法简介及保姆级代码解读
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2023-04-14T15:43:00+08:00">
	
		    2023 年 4 月 14 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../../categories/%E7%AE%97%E6%B3%95/">算法</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h4 id="A-搜索算法简介及保姆级代码解读">A*搜索算法简介及保姆级代码解读</h4>
<ul>
<li><a href="#1_A_1">1. A*算法简单介绍</a></li>
<li>
<ul>
<li><a href="#11_A_12">1.1 A*算法理论基础</a></li>
<li>
<ul>
<li><a href="#111__31">1.1.1 节点计算</a></li>
<li><a href="#112__60">1.1.2 由计算得出的小结论</a></li>
</ul>
</li>
<li><a href="#12__70">1.2 算法逻辑结构</a></li>
</ul>
</li>
<li><a href="#2__80">2. 代码解析</a></li>
<li>
<ul>
<li><a href="#21__81">2.1 引入地图</a></li>
<li><a href="#22__159">2.2 预处理</a></li>
<li><a href="#23_parent_286">2.3 定义父节点`parent`</a></li>
<li><a href="#24__296">2.4 主循环</a></li>
<li>
<ul>
<li><a href="#241_359">2.4.1</a></li>
<li><a href="#242_364">2.4.2</a></li>
<li><a href="#243_380">2.4.3</a></li>
<li><a href="#244_383">2.4.4</a></li>
<li><a href="#245_396">2.4.5</a></li>
</ul>
</li>
<li><a href="#25__414">2.5 画图</a></li>
</ul>
</li>
<li><a href="#3__427">3. 结果</a></li>
</ul>
<h2 id="1-A-算法简单介绍">1. A*算法简单介绍</h2>
<p>A*算法是一种路径规划算法，和传统的Dijkstra算法有所不同，该算法<strong>有选择</strong>地进行节点搜索，因此比Dijkstra算法更快、搜索的点更少。<br>
阅读本文，不需要掌握Dijkstra算法的知识，请放心食用。<br>
注意：<strong>本文只介绍二维A*算法及相关示例</strong>。</p>
<p><strong>PS</strong>：本文代码编写参考B站up主<br>
<code>小黎的Ally</code>的<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Jt4y1z7Ry?from=search&amp;seid=14748520462847442393&amp;spm_id_from=333.337.0.0">路径规划与轨迹跟踪系列算法学习_第4讲_A*算法</a>，讲解详细，本文代码部分是将其代码进行了些许改动并加以解释，在此对up主的辛苦表达感谢！！</p>
<p><strong>PPS</strong>：本文所使用的把地图栅格化的函数来自于博客<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42667352/article/details/98523370">Matlab中将一幅图片做成栅格地图</a>，本文进行了些许改动，再次一并感谢博主的辛苦！</p>
<h3 id="1-1-A-算法理论基础">1.1 A*算法理论基础</h3>
<p>A*算法首先将要搜索的区域划分为若干栅格（grid），并有选择地标识出障碍物（Obstacle）与空白区域。一般地，<strong>栅格划分越细密，搜索点数越多，搜索过程越慢，计算量也越大；栅格划分越稀疏，搜索点数越少，相应地搜索精确性就越低</strong>。<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/e5a5e9d6d0f36afb2bf3f1cd9ef378ac.png#pic_center" alt="地图栅格"></p>
<p>如上图，引入地图信息后画出栅格，该图片采用 100 × 100 100 \times 100 100×100的栅格划分，图中黑色区域为障碍物区域。图中绿点为起始点，红点为终点。</p>
<p>对每个节点，在计算时同时考虑两项<strong>代价</strong>指标：<strong>当前节点与起始点的距离</strong>，以及<strong>当前节点与目标点的距离</strong>：<br>
f = g + h f = g + h f=g+h其中 f f f为总代价， g g g为当前节点距离起始点的距离， h h h为当前节点距离目标点的距离。<br>
而在计算距离时，又可以采用两种方式：<br>
<strong>欧氏距离</strong>：<br>
L = ( x 1 − x 2 ) 2 + ( y 1 − y 2 ) 2 L = \sqrt{\left( x_1 - x_2 \right) ^2 + \left( y_1 - y_2 \right) ^2} L=(x1​−x2​)2+(y1​−y2​)2 ​<strong>曼哈顿距离</strong>：<br>
L = ∣ x 1 − x 2 ∣ + ∣ y 1 − y 2 ∣ L = \lvert x_1 - x_2 \rvert + \lvert y_1 - y_2 \rvert L=∣x1​−x2​∣+∣y1​−y2​∣为了计算方便，本文计算 h h h时采用<strong>曼哈顿距离</strong>，这也是A*算法中的一贯做法。<br>
为了方便计数，在计算每一个节点时，在栅格左上角写 f f f值，左下角写 g g g值，右下角写 h h h值。</p>
<h4 id="1-1-1-节点计算">1.1.1 节点计算</h4>
<p>这里举一个例子。<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/86fca2663892fb458c7cdef9e81facdf.jpeg#pic_center" alt="节点计算例1"><br>
如图所示，A点为起始点，M点为终点。对于A点来说，对其周边的8个节点进行寻找，A点本身为<strong>父节点</strong>，周边8个点为<strong>子节点</strong>。</p>
<p>假设：</p>
<ul>
<li>格子边长为10，这样水平和竖直位移一格为10，而对角位移一格为14；</li>
<li>从父节点到子节点可以水平、竖直、对角线位移计算 g g g值，而从子节点到目标点只能使用水平、竖直位移计算曼哈顿距离 h h h值。</li>
</ul>
<p>对于点B：从A到B只需右移一格，因此B的 g = 10 g=10 g=10；从B到M需要先右移四格，再上移三格，因此B的 h = 40 + 30 = 70 h = 40+30=70 h=40+30=70。这样B的 f = g + h = 10 + 70 = 80 f=g+h=10+70=80 f=g+h=10+70=80。将三者都记在B格中。<br>
对于点C：从A到C只需向右上方平移一格，因此C的 g = 14 g=14 g=14；从C到M需要先右移四格，再上移两格，因此C的 h = 40 + 20 = 60 h=40+20=60 h=40+20=60，继而C的 f = g + h = 74 f=g+h=74 f=g+h=74。<br>
同理可以计算出D的 g = 14 , h = 80 , f = 94 g=14, h=80,f=94 g=14,h=80,f=94，以及其他几个子节点的值。</p>
<p>将这8个子节点进行对比，可以发现，C点的 f f f值最小，因此选取C点为下一步搜寻的父节点， A C ‾ \overline{AC} AC即为路径迈出的第一步。<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/61d8dbfe6ffe8e4eb0d95eb32b2a6032.jpeg#pic_center" alt="节点计算例2"><br>
如图所示，现在将C作为新的父节点。</p>
<p>对于J点：<br>
从C到J只需右移一格，因此J的 g = 10 + g C = 10 + 14 = 24 g=10+g_C =10+14=24 g=10+gC​=10+14=24。需要注意的是，<strong>J点的 g g g值是从C到J的 g g g加上从A到C的 g g g，即当前子节点的 g g g值是从起点到该点的所有 g g g累和</strong>。<br>
从J到M需要先右移三格，再上移两格，因此J的 h = 30 + 20 = 50 h = 30+20=50 h=30+20=50。这样J的 f = g + h = 24 + 50 = 74 f=g+h=24+50=74 f=g+h=24+50=74。将三者都记在J格中。</p>
<p>对于I点：<br>
从C到I只需向右上方平移一格，同样地，<strong>I点的 g g g值是从C到I的 g g g加上从A到C的 g g g，即当前子节点的 g g g值是从起点到该点的所有 g g g累和</strong>，因此I的 g = 14 + g C = 14 + 14 = 28 g=14+g_C =14+14=28 g=14+gC​=14+14=28。<br>
从I到M需要先右移三格，再上移一格，因此I的 h = 30 + 10 = 40 h = 30+10=40 h=30+10=40。这样I的 f = g + h = 28 + 40 = 68 f=g+h=28+40=68 f=g+h=28+40=68。将三者都记在I格中。<br>
同样计算出其他点的值。<br>
可以看出，I点的 f f f值最小，因此选择I点作为路径上的下一个点，此时路径变为 A C I ‾ \overline{ACI} ACI。</p>
<p>如此一步步进行迭代，最后找到最优轨迹。</p>
<h4 id="1-1-2-由计算得出的小结论">1.1.2 由计算得出的小结论</h4>
<ul>
<li>每个节点中需要存储至少3个值： g , h , f g,h,f g,h,f。</li>
<li>当子节点迭代到目标点本身时， h = 0 h=0 h=0，即当前节点到目标点的距离为0.</li>
<li>在算法实施时， g g g的计算可以取10或14，即从父节点到子节点可以水平/竖直位移，也可以沿对角线位移；而 h h h的计算只能取10的倍数，即从当前子节点到目标点只能水平/竖直位移。前者可以采用<strong>欧氏距离</strong>，后者只能采用<strong>曼哈顿距离</strong>。</li>
<li><strong>当某个子节点被选中后，就作为下一次搜索的父节点；并且为了避免节点的重复计算和筛选，在下一次搜索时，需要将上一步选中的节点从“可搜索”列表中删除</strong>。如上图中，当C为父节点时，选中I作为下一次的父节点；那么当第二步I为父节点时，由于C已经在已选轨迹上了，所以I的子节点实际上并不包括C，只计算7个子节点即可。</li>
<li>鉴于上一点，可以预想，算法的具体实施过程中，<strong>需要有两个数组保存“待计算子节点”和“已被选中的节点”。当“待计算子节点”中某个点符合 f f f最小时，就将其加入“已选中的节点”，并在“待计算子节点”中删除该点，防止后续重复计算</strong>。</li>
<li>当算法结束时，<strong>保存在“已选中的节点”中的所有点，按照顺序即为找出的路径</strong>。</li>
<li>算法结束时，<strong>最后一个点的 f f f值，即为从起点到终点所用的距离</strong>。</li>
<li>算法的停止条件：1)当“待计算子节点”中没有点时，即已经没有点可供寻找了；2)当当前父节点恰为目标节点时，即 h = 0 h=0 h=0。</li>
</ul>
<h3 id="1-2-算法逻辑结构">1.2 算法逻辑结构</h3>
<p>A*算法的逻辑结构如下：<br>
1）初始化。导入地图信息，设置障碍物区域，设置起点<code>start</code>、终点<code>target</code>、栅格数量 m × n m \times n m×n等。<br>
2）数据预处理。建立“待计算子节点”的数组<code>openlist</code>，“已选中的节点”的数组<code>closelist</code>，保存路径的数组<code>closelist_path</code>。除此之外，还需建立一个当前子节点集合<code>children</code>，用来保存当前父节点周围8个子节点的坐标，以及父节点本身<code>parent</code>；还有保存代价值 g , h , f g, h,f g,h,f的数组<code>openlist_cost</code>和<code>closelist_cost</code>。<br>
3）对子节点们<code>children</code>中的每个节点<code>child</code>：<br>
若该子节点不在“待计算子节点”节点<code>openlist</code>中，则追加进去；<br>
若在，则计算出该<code>child</code>的 g g g值，该 g g g值是从起点到父节点<code>parent</code>的距离加上父节点到该子节点的距离。若该 g g g值小于之前<code>openlist_cost</code>中的 g g g最小值，那么就将<code>openlist_cost</code>中的最小 g g g值更新；<br>
4）由于该代价最小点已经加入了轨迹，因此将该点加入<code>clost_list</code>和<code>closelist_path</code>，并从<code>openlist</code>中剔除；<br>
5）更新<code>openlist</code>中的最小代价值，并以其为父节点开始新一轮搜索。</p>
<h2 id="2-代码解析">2. 代码解析</h2>
<h3 id="2-1-引入地图">2.1 引入地图</h3>
<p>代码块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">%% 画地图</span><br><span class="line"></span><br><span class="line">% 栅格地图的行数、列数定义</span><br><span class="line">m = 150;</span><br><span class="line">n = 150;</span><br><span class="line">% 地图m行n列</span><br><span class="line"></span><br><span class="line">start = [10, 20];        % 起始节点</span><br><span class="line">target = [130, 80];       % 终止节点</span><br><span class="line"></span><br><span class="line">obs = TrunToGridMap(m, n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% 画格子</span><br><span class="line">for i = 0 : 5 : m</span><br><span class="line">    plot([0, n], [i, i], &#x27;k&#x27;, &#x27;handlevisibility&#x27;, &#x27;off&#x27;);</span><br><span class="line">    hold on;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for j = 0 : 5 : n</span><br><span class="line">    plot([j, j], [0, m], &#x27;k&#x27;, &#x27;handlevisibility&#x27;, &#x27;off&#x27;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">axis equal;</span><br><span class="line">xlim([0, n]);</span><br><span class="line">ylim([0, m]);</span><br><span class="line"></span><br><span class="line">% 绘制障碍物、起止点颜色块</span><br><span class="line">scatter(start(1), start(2), 700, &#x27;pg&#x27;, &#x27;filled&#x27;);</span><br><span class="line">scatter(target(1), target(2), 700, &#x27;pr&#x27;, &#x27;filled&#x27;);</span><br><span class="line"></span><br><span class="line">for i = 1 : size(obs, 1) - 1</span><br><span class="line">    temp = obs(i, :);</span><br><span class="line">    fill([temp(1)-1, temp(1), temp(1), temp(1)-1],...</span><br><span class="line">        [temp(2)-1, temp(2)-1, temp(2), temp(2)], &#x27;k&#x27;, &#x27;handlevisibility&#x27;, &#x27;off&#x27;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">temp = obs(size(obs, 1), :);</span><br><span class="line">fill([temp(1)-1, temp(1), temp(1), temp(1)-1],...</span><br><span class="line">    [temp(2)-1, temp(2)-1, temp(2), temp(2)], &#x27;k&#x27;);</span><br></pre></td></tr></table></figure>
<p>绘制一个 150 × 150 150 \times 150 150×150的地图，起点设置为 ( 10 , 20 ) (10,20) (10,20)，终点设置为 ( 130 , 80 ) (130,80) (130,80)。<br>
障碍物的坐标通过函数<code>TrunToGridMap(m, n)</code>获得：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function obs = TrunToGridMap(a, b)</span><br><span class="line">    I=imread(&#x27;此处放地图图片的文件名&#x27;);   %读入图片</span><br><span class="line">    I = rgb2gray(I);     %将图片转为灰度图</span><br><span class="line">    I = imrotate(I, -90);</span><br><span class="line"></span><br><span class="line">    l=1;    %网格边长</span><br><span class="line">    B = imresize(I,[a/l b/l]);</span><br><span class="line">    J=floor(B/255); </span><br><span class="line"></span><br><span class="line">    axes(&#x27;GridLineStyle&#x27;, &#x27;-&#x27;);</span><br><span class="line">    axis equal;</span><br><span class="line"></span><br><span class="line">    hold on</span><br><span class="line">    grid on</span><br><span class="line">    axis([0,a,0,b]);</span><br><span class="line">    set(gca,&#x27;xtick&#x27;,0:10:a,&#x27;ytick&#x27;,0:10:b);</span><br><span class="line"></span><br><span class="line">    obs = [];</span><br><span class="line"></span><br><span class="line">    %障碍物填充为黑色</span><br><span class="line">    for i=1:a/l-1</span><br><span class="line">        for j=1:b/l-1</span><br><span class="line">            if(J(i,j)==0)</span><br><span class="line">                obs(end+1, :) = [i, j];</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>该函数读取一个图片文件，将其转化为灰度图像，并将灰度图中黑色色块所在的坐标返回为障碍物坐标。</p>
<h3 id="2-2-预处理">2.2 预处理</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">%% 预处理</span><br><span class="line"></span><br><span class="line">% 初始化closelist</span><br><span class="line">closelist = start;</span><br><span class="line">closelist_path = &#123;start, start&#125;;      % 路径，从自身到自身</span><br><span class="line">closelist_cost = 0;</span><br><span class="line">children = child_nodes_cal(start, m, n, obs, closelist);</span><br><span class="line"></span><br><span class="line">% 初始化openlist</span><br><span class="line">openlist = children;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i = 1 : size(openlist, 1)   % i为第i个节点</span><br><span class="line">    openlist_path&#123;i, 1&#125; = openlist(i, :);   % openlist_path的第i行第1列为第i个节点child</span><br><span class="line">    openlist_path&#123;i, 2&#125; = [start; openlist(i, :)]; % openlist_path的第i行第2列为一个列向量，分别是起始节点和当前child</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i = 1 : size(openlist, 1)</span><br><span class="line">    g = norm(start - openlist(i, 1:2));</span><br><span class="line">    h = abs(target(1) - openlist(i, 1)) + abs(target(2) - openlist(i, 2));</span><br><span class="line">    f = g + h;</span><br><span class="line">    openlist_cost(i, :) = [g, h, f];</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>这一部分主要做了以下几步：</p>
<ul>
<li>把起点<code>start</code>设为轨迹的第一个点：<code>closelist = start</code>；</li>
<li>路径初始化，即从起点到起点：<code>closelist_path = &#123;start, start&#125;</code>；</li>
<li>代价首先置为0：<code>closelist_cost = 0</code>；</li>
<li>利用<code>child_nodes_cal</code>函数计算当前父节点（即起点）周围的子节点们；</li>
<li>这些子节点们<code>children</code>即为待计算的子节点，也就是<code>openlist</code>；</li>
<li>随后进入一个循环，对每一个子节点i，<code>openlist_path</code>中第i行第1个元素储存第i个节点<code>child</code>，第2个元素为一个<strong>列向量</strong>，分别是第i个<code>child</code>的起点和它本身；</li>
<li>第二个循环则是计算代价的循环，对每一个子节点i，计算 g g g（这里使用<strong>范数</strong><code>norm</code>）， h h h（曼哈顿距离）和 f f f；之后，在代价数组<code>openlist_cost</code>中储存这三个代价值，因此<code>openlist_cost</code>第i行的元素为一个<strong>行向量</strong>；</li>
</ul>
<p>其中用到的子节点计算函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">function child_nodes = child_nodes_cal(parent_node, m, n, obs, closelist)</span><br><span class="line">    child_nodes = [];</span><br><span class="line">    field = [1, 1;</span><br><span class="line">        n, 1;</span><br><span class="line">        n, m;</span><br><span class="line">        1, m];</span><br><span class="line">    </span><br><span class="line">    % 左上子节点</span><br><span class="line">    child_node = [parent_node(1) - 1, parent_node(2) + 1];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        % [in, on] = inpolygon, 返回 in，以指明 xq 和 yq 所指定的查询点是在 xv 和 </span><br><span class="line">        % yv 定义的多边形区% 域的边缘内部还是在边缘上,in为内部，on为边缘上</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    % 上子节点</span><br><span class="line">    child_node = [parent_node(1), parent_node(2) + 1];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    % 右上子节点</span><br><span class="line">    child_node = [parent_node(1) + 1, parent_node(2) + 1];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    % 左子节点</span><br><span class="line">    child_node = [parent_node(1) - 1, parent_node(2)];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    %右子节点</span><br><span class="line">    child_node = [parent_node(1) + 1, parent_node(2)];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    %左下子节点</span><br><span class="line">    child_node = [parent_node(1) - 1, parent_node(2) - 1];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    % 下子节点</span><br><span class="line">    child_node = [parent_node(1), parent_node(2) - 1];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    % 右下子节点</span><br><span class="line">    child_node = [parent_node(1) + 1, parent_node(2) - 1];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    %% 排除已经存在于closelist的节点</span><br><span class="line">    delete_idx = [];</span><br><span class="line">    for i = 1 : size(child_nodes, 1)</span><br><span class="line">        if ismember(child_nodes(i, :), closelist, &#x27;rows&#x27;)</span><br><span class="line">            delete_idx(end+1, :) = i;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    child_nodes(delete_idx, :) = [];</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="2-3-定义父节点parent">2.3 定义父节点<code>parent</code></h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%% 定义父节点</span><br><span class="line">% 从openlist开始搜索移动代价最小的节点</span><br><span class="line">[~, min_idx] = min(openlist_cost(:, 3));    % 看f值最小，min_idx为f最小的那一行</span><br><span class="line">parent = openlist(min_idx, :);% 以min_idx该行的子节点child_node为新的父节点</span><br></pre></td></tr></table></figure>
<p>这一步搜索<code>openlist_cost</code>代价数组中 f f f最小的元素，记下其索引<code>min_idx</code>；<br>
随后该索引对应的<code>openlist</code>中的元素即为“ f f f值最小的待计算子节点”，作为下一步计算的父节点<code>parent</code>。</p>
<h3 id="2-4-主循环">2.4 主循环</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">%% 进入循环</span><br><span class="line">flag = 1;</span><br><span class="line">while flag</span><br><span class="line">    % 找出父节点的忽略closelist的子节点</span><br><span class="line">    children = child_nodes_cal(parent ,m, n, obs, closelist);</span><br><span class="line">    </span><br><span class="line">    % 判断这些子节点是否在openlist中，若在，则更新；没在，则追加到openlist中</span><br><span class="line">    for i = 1 : size(children, 1)</span><br><span class="line">        child = children(i, :);</span><br><span class="line">        [in_flag, openlist_idx] = ismember(child, openlist, &#x27;rows&#x27;);</span><br><span class="line">        % in_flag表示该child_node是否在openlist中</span><br><span class="line">        % openlist_idx表示该child_node在openlist中的行数</span><br><span class="line">        </span><br><span class="line">        g = openlist_cost(min_idx, 1) + norm(parent - child);</span><br><span class="line">        % 原来的g加上新的g</span><br><span class="line">        h = abs(child(1) - target(1)) + abs(child(2) - target(2));</span><br><span class="line">        f = g + h;</span><br><span class="line">        </span><br><span class="line">        if in_flag  % 若在，则比较更新g, f</span><br><span class="line">            if g &lt; openlist_cost(openlist_idx, 1)   </span><br><span class="line">                % openlist_cost(openlist_idx,1)指的是openlist_cost中idx这一行（即child_node所在的一行）的第一个坐标，即g</span><br><span class="line">                openlist_cost(openlist_idx, 1) = g;</span><br><span class="line">                openlist_cost(openlist_idx, 3) = f;</span><br><span class="line">                openlist_path&#123;openlist_idx, 2&#125; = [openlist_path&#123;min_idx, 2&#125;; child];</span><br><span class="line">                % openlist_path的第i行第2列为一个列向量，分别是起始节点和当前child，此处定义新的起始节点为openlist_path(min_idx,2)， 而openlist_path(min_idx,2)指第min_idx行所对应的 child在openlist_path中对应的路径，相当于把新的child附加到了路径上，延长了路径</span><br><span class="line">            end</span><br><span class="line">        else</span><br><span class="line">            openlist(end+1, :) = child;</span><br><span class="line">            openlist_cost(end+1, :) = [g, h, f];</span><br><span class="line">            openlist_path&#123;end+1, 1&#125; = child;</span><br><span class="line">            openlist_path&#123;end, 2&#125; = [openlist_path&#123;min_idx, 2&#125;; child];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    % 从openlist移除代价最小的节点到closelist</span><br><span class="line">    closelist(end+1, :) = openlist(min_idx, :);</span><br><span class="line">    closelist_cost(end+1, :) = openlist_cost(min_idx, 3);</span><br><span class="line">    closelist_path(end+1, :) = openlist_path(min_idx, :);</span><br><span class="line">    </span><br><span class="line">    % 同样地，openlist中少了该节点</span><br><span class="line">    openlist(min_idx, :) = [];</span><br><span class="line">    openlist_cost(min_idx, :) = [];</span><br><span class="line">    openlist_path(min_idx, :) = [];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    % 重新搜索：从openlist搜索移动代价最小的节点，作为新的父节点</span><br><span class="line">    [~, min_idx] = min(openlist_cost(:, 3));</span><br><span class="line">    parent = openlist(min_idx, :);</span><br><span class="line">    </span><br><span class="line">    % 判断是否搜索到终点</span><br><span class="line">    if parent == target</span><br><span class="line">        closelist(end+1, :) = openlist(min_idx, :);</span><br><span class="line">        closelist_cost(end+1, 1) = openlist_cost(min_idx, 1);</span><br><span class="line">        closelist_path(end+1, :) = openlist_path(min_idx, :);</span><br><span class="line">        flag = 0;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="2-4-1">2.4.1</h4>
<p>对这一部分循环来说，首先利用<code>child_nodes_cal</code>函数得出当前父节点<code>parent</code>周围的子节点们<code>children</code>；<br>
对每一个子节点<code>child</code>，判断其是否在“待计算子节点”<code>openlist</code>列表中——<code>in_flag</code>=1表示在列表中，同时<code>openlist_idx</code>为该子节点在<code>openlist</code>中的索引号。<br>
判断完成后，首先计算该子节点的 g , h , f g,h,f g,h,f值，注意： g g g值为父节点<code>parent</code>的 g g g加上该<code>child</code>子节点的 g g g值。</p>
<h4 id="2-4-2">2.4.2</h4>
<p>计算 g , h , f g,h,f g,h,f之后，再来看子节点在<code>openlist</code>中的情况。<strong>由于循环中查看了<code>parent</code>周围所有子节点的情况，所以一定会存在某个子节点的 g g g比其他子节点的 g g g都小</strong>。如果找到了这样的子节点，那么就更新该子节点在<code>openlist_cost</code>中对应位置的 g , h , f g,h,f g,h,f值。</p>
<p>同时，还要将该子节点加入到路径<code>openlist_path</code>中，即这一句代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openlist_path&#123;openlist_idx, 2&#125; = [openlist_path&#123;min_idx, 2&#125;; child];</span><br></pre></td></tr></table></figure>
<p>这行代码的含义是：<br>
<code>openlist_idx</code>表示当前子节点<code>child</code>在<code>openlist</code>中的索引，<code>min_idx</code>表示之前所有子节点中代价最小的子节点的索引。之前在<strong>预处理</strong>一节中提到，<code>openlist_path</code>的第i行第2列为一个列向量，分别是父节点和当前child，相当于第2列储存了路径。</p>
<p>而<code>min_idx</code>表示“代价最小的节点”，也就是父节点<code>parent</code>。因此这里<code>openlist_path&#123;min_idx, 2&#125;</code>表示父节点的路径。而<code>[openlist_path&#123;min_idx, 2&#125;; child]</code>则是把新的<code>child</code>附加到这一个列向量上，相当于把新的<code>child</code>附加到路径尾端，把向量长度延长了一个<code>child</code>，延长了路径。</p>
<p>这样，<strong><code>[openlist_path&#123;min_idx, 2&#125;; child]</code>构成了一个“父节点路径-当前child”的新路径</strong>。</p>
<p>把这个新路径赋值给<code>openlist_idx</code>索引所对应的<code>openlist_path</code>上，即为该<code>openlist_idx</code>索引对应的子节点的路径。</p>
<h4 id="2-4-3">2.4.3</h4>
<p>另一方面，如果该<code>child</code>不在<code>openlist</code>中，那么就把该<code>child</code>添加到“待计算子节点”列表中，其 g , h , f g,h,f g,h,f值添加到<code>openlist_cost</code>代价列表中，其路径<code>[openlist_path&#123;min_idx, 2&#125;; child]</code>添加到路径<code>openlist_path</code>中。</p>
<h4 id="2-4-4">2.4.4</h4>
<p>由于移动代价最小的节点已经是路径上的一点了，所以为了避免重复计算，应当把她从“待计算子节点”列表中删除，加入“已计算节点”中，即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">closelist(end+1, :) = openlist(min_idx, :);</span><br><span class="line">closelist_cost(end+1, :) = openlist_cost(min_idx, 3);</span><br><span class="line">closelist_path(end+1, :) = openlist_path(min_idx, :);</span><br><span class="line">% openlist中少了该节点</span><br><span class="line">openlist(min_idx, :) = [];</span><br><span class="line">openlist_cost(min_idx, :) = [];</span><br><span class="line">openlist_path(min_idx, :) = [];</span><br></pre></td></tr></table></figure>
<p>仔细观察不难发现，<code>min_idx</code>对应的正是这一步的<code>parent</code>节点，直到这里，我们才把它加入到“已计算节点”列表中，在之前它一直呆在<code>openlist</code>中。</p>
<h4 id="2-4-5">2.4.5</h4>
<p>父节点加入到了“已计算节点”中了，那么下一步就没有父节点了，所以需要找出新的父节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> [~, min_idx] = min(openlist_cost(:, 3));</span><br><span class="line">parent = openlist(min_idx, :);</span><br></pre></td></tr></table></figure>
<p>同时还需要判断一下，是否已经进行到了程序结束：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% 判断是否搜索到终点</span><br><span class="line">if parent == target</span><br><span class="line">    closelist(end+1, :) = openlist(min_idx, :);</span><br><span class="line">    closelist_cost(end+1, 1) = openlist_cost(min_idx, 1);</span><br><span class="line">    closelist_path(end+1, :) = openlist_path(min_idx, :);</span><br><span class="line">    flag = 0;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>需要注意，即使当当前父节点已经是目标点了，也不要忘了把这个父节点加入到“已计算节点”中，相当于把目标点添加入路径中，形成路径上最后一个点。</p>
<h3 id="2-5-画图">2.5 画图</h3>
<p>这一步就是将结果绘制出来了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">path_opt = closelist_path&#123;end, 2&#125;;</span><br><span class="line">% closelist_path中第二列存放路径，所以path_opt存放的是路径的(x,y)值</span><br><span class="line">path_opt(:, 1) = path_opt(:, 1) - 0.5;</span><br><span class="line">path_opt(:, 2) = path_opt(:, 2) - 0.5;</span><br><span class="line">plot(path_opt(:, 1), path_opt(:, 2), &#x27;m&#x27;, &#x27;linewidth&#x27;, 1.5);</span><br><span class="line"></span><br><span class="line">title([&#x27;Total length of path: &#x27; num2str(closelist_cost(end, 1))]);</span><br><span class="line">legend(&#x27;Start node&#x27;, &#x27;Target node&#x27;, &#x27;Obstacle&#x27;, &#x27;Path&#x27;, &#x27;location&#x27;, &#x27;northwest&#x27;);</span><br><span class="line">set(gca, &#x27;fontsize&#x27;, 35, &#x27;fontname&#x27;, &#x27;times new roman&#x27;);</span><br></pre></td></tr></table></figure>
<h2 id="3-结果">3. 结果</h2>
<p>这里导入稻妻地图作为路径规划的示例，该地图多为岛屿，路径复杂，障碍物分散且数量多，十分适合作为示例使用。<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/fcf59433821c1051a8f8714547d79018.png#pic_center" alt="稻妻地图"><br>
将其灰度化得到<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/124b144e99366faa9e582a913fc277e3.jpeg#pic_center" alt="灰度稻妻"><br>
把地图划分为 m × n = 150 × 150 m \times n = 150 \times 150 m×n=150×150的栅格，并设置起点为 ( 10 , 20 ) (10,20) (10,20)，终点为 ( 130 , 80 ) (130,80) (130,80)：<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/50113f38beb35b89434c28535c12ba1b.png#pic_center" alt="稻妻地图栅格"><br>
图中绿色为起点，红色为终点。</p>
<p>路径规划结果：<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/8a875e6b8ffc0c48064351488be0d262.png#pic_center" alt="稻妻路径规划"><br>
可以看出，A* 算法可以找到期望路径。</p>
<p>文件所有代码在笔者的资源<a target="_blank" rel="noopener" href="https://download.csdn.net/download/weixin_58399148/43085850">二维A*算法路径规划matlab代码</a>中可以下载得到。</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">標籤</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../../08/27/%E6%95%B0%E5%AD%A6/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/"
                    data-tooltip="一文搞懂贝叶斯定理（原理篇）"
                    aria-label="上一篇: 一文搞懂贝叶斯定理（原理篇）"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../12/Algorithms/Dijkstra%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"
                    data-tooltip="Dijkstra简单介绍"
                    aria-label="下一篇: Dijkstra简单介绍"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2023/04/14/Algorithms/Astar%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BF%9D%E5%A7%86%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2023/04/14/Algorithms/Astar%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BF%9D%E5%A7%86%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2023/04/14/Algorithms/Astar%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BF%9D%E5%A7%86%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2023/04/14/Algorithms/Astar%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BF%9D%E5%A7%86%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../../08/27/%E6%95%B0%E5%AD%A6/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/"
                    data-tooltip="一文搞懂贝叶斯定理（原理篇）"
                    aria-label="上一篇: 一文搞懂贝叶斯定理（原理篇）"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../12/Algorithms/Dijkstra%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"
                    data-tooltip="Dijkstra简单介绍"
                    aria-label="下一篇: Dijkstra简单介绍"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2023/04/14/Algorithms/Astar%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BF%9D%E5%A7%86%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2023/04/14/Algorithms/Astar%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BF%9D%E5%A7%86%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2023/04/14/Algorithms/Astar%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BF%9D%E5%A7%86%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2023/04/14/Algorithms/Astar%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BF%9D%E5%A7%86%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2023/04/14/Algorithms/Astar%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BF%9D%E5%A7%86%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"
                        aria-label="分享到 Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2023/04/14/Algorithms/Astar%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BF%9D%E5%A7%86%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"
                        aria-label="分享到 Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2023/04/14/Algorithms/Astar%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BF%9D%E5%A7%86%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"
                        aria-label="global.share_on_linkedin"
                    >
                        <i class="fab fa-linkedin" aria-hidden="true"></i><span>global.share_on_linkedin</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2023/04/14/Algorithms/Astar%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BF%9D%E5%A7%86%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"
                        aria-label="分享到 Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 210 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
