
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>Terraform-命令行2 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg"},"articleBody":"\n\n1.7.16.1. refresh\n\n\n1.7.16.1.1. 用法\n\n\n\n1.7.16.1. refresh\nterraform refresh 命令将实际存在的基础设施对象的状态同步到状态文件中记录的对象状态。它可以用来检测真实状态与记录状态之间的漂移并更新状态文件。\n\n警告！！！该命令已在最新版本 Terraform 中被废弃，因为该命令的默认行为在当前用户错误配置了使用的云平台令牌时会引发对状态文件错误的变更。\n\n该命令并不会修改基础设施对象，只修改状态文件。\n我们一般不需要使用该命令，因为 Terraform 会自动执行相同的刷新操作，作为在 terraform plan 和 terraform apply 命令中创建计划的一部分。本命令在这里主要是为了向后兼容，但我们不建议使用它，因为它没有提供在更新状态之前检查操作效果的机会。\n1.7.16.1.1. 用法\nterraform refresh [options]\n该命令本质上是以下命令的别名，具有完全相同的效果：\n1terraform apply -refresh-only -auto-approve\n因此，该命令支持所有 terraform apply 所支持的参数，除了它不接受一个现存的变更计划文件，不允许选择 “refresh only” 之外的模式，并且始终应用 -auto-approve 选项。\n自动执行 refresh 是很危险的，因为如果当前用户错误配置了使用的 Provider 的令牌，那么 Terraform 会错误地以为当前状态文件中记录的所有资源都被删除了，随即从状态文件中无预警地删除所有相关记录。\n我们推荐运行如下命令来取得相同的效果，同时可以在修改状态文件之前预览即将对其作出的修改：\n1terraform apply -refresh-only\n该命令将会在交互界面中提示用户检测到的变更，并提示用户确认执行。\nterraform apply 和 terraform plan 命令的 -refresh-only 选项是从 Terraform v0.15.4 版本开始被引入的。对更早的版本，用户只能直接使用 terraform refresh 命令，同时要小心本篇警告过的危险副作用。尽可能避免显式使用 terraform refresh 命令，Terraform 在执行 terraform plan 和 terraform apply 命令时都会自动执行刷新状态的操作以生成变更计划，尽可能依赖该机制来维持状态文件的同步。\nshow\n\n\n1.7.17.1. show\n\n\n1.7.17.1.1. JSON 输出\n\n\n1.7.17.1.2. 用法\n\n\n\n1.7.17.1. show\nterraform show 命令从状态文件或是变更计划文件中打印人类可读的输出信息。这可以用来检查变更计划以确定所有操作都是符合预期的，或是审查当前的状态文件。\n可以通过添加 -json 参数输出机器可读的 JSON 格式输出。\n需要注意的是，使用 -json 输出时所有标记为 sensitive 的敏感数据都会以明文形式被输出。\n1.7.17.1.1. JSON 输出\n可以使用 terraform show -json 命令打印 JSON 格式的状态信息。\n如果指定了一个变更计划文件，terraform show -json 会以 JSON 格式记录变更计划、配置以及当前状态。\n如果在写入状态文件后更新了包含新架构版本的 Provider 程序，则需要先升级状态，然后才能使用 show -json 显示状态。如果要查看计划，必须先在不使用 -refresh=false 的情况下创建计划文件。如果要查看当前状态，请先运行 terraform refresh。\n1.7.17.1.2. 用法\nterraform show [options] [file]\n您可以将为 file 指定状态文件或计划文件的路径。如果不指定文件路径，Terraform 将显示最新的状态快照。\n该命令支持以下参数：\n\n-json：以 JSON 格式输出\n-no-color：与 apply 类似，不再赘述\n\nstate\n\n\n1.7.18.1. state\n\n\n1.7.18.1.1. 用法\n\n\n1.7.18.1.2. 远程状态\n\n\n1.7.18.1.3. 备份\n\n\n1.7.18.1.4. 命令行友好\n\n\n1.7.18.1.5. 资源地址\n\n\n\n1.7.18.1. state\nterraform state 命令可以用来进行复杂的状态管理操作。随着你对 Terraform 的使用越来越深入，有时候你需要对状态文件进行一些修改。由于我们在状态管理章节中提到过的，状态文件的格式属于 HashiCorp 未公开的私有格式，所以直接修改状态文件是不适合的，我们可以使用 terraform state 命令来执行修改。\n该命令含有数个子命令，我们会一一介绍。\n1.7.18.1.1. 用法\nterraform state &lt;subcommand&gt; [options] [args]\n1.7.18.1.2. 远程状态\n所有的 state 子命令都可以搭配本地状态文件以及远程状态使用。使用远程状态时读写操作可能用时稍长，因为读写都要通过网络完成。备份文件仍然会被写入本地磁盘。\n1.7.18.1.3. 备份\n所有会修改状态文件的 terraform state 子命令都会生成备份文件。可以通过 -backup 参数指定备份文件的位置。\n只读子命令(例如 list )由于不会修改状态，所以不会生成备份文件。\n注意修改状态的 state 子命令无法禁用备份。由于状态文件的敏感性，Terraform 强制所有修改状态的子命令都必须生成备份文件。如果你不想保存备份，可以手动删除。\n1.7.18.1.4. 命令行友好\nstate 子命令的输出以及命令结构都被设计得易于同 Unix 下其他命令行工具搭配使用，例如 grep、awk 等等。同样的，输出结果也可以在 Windows 上轻松使用 PowerShell 处理。\n对于复杂场景，我们建议使用管道组合 state 子命令与其他命令行工具一同使用。\n1.7.18.1.5. 资源地址\nstate 子命令中大量使用了资源地址，我们在资源地址章节中做了相关的介绍。\nlist\n\n\n1.7.18.1.1. list\n\n\n1.7.18.1.1.1. 用法\n\n\n1.7.18.1.1.2. 例子：列出所有资源\n\n\n1.7.18.1.1.3. 例子：根据资源地址过滤\n\n\n1.7.18.1.1.4. 例子：根据模块过滤\n\n\n1.7.18.1.1.5. 例子：根据ID过滤\n\n\n\n1.7.18.1.1. list\nterraform state list 命令可以列出状态文件中记录的资源对象。\n1.7.18.1.1.1. 用法\nterraform state list [options] [address...]\n该命令会根据 address 列出状态文件中相关资源的信息(如果给定了 address 的话)。如果没有给定 address，那么所有资源都会被列出。\n列出的资源根据模块深度以及字典序进行排序，这意味着根模块的资源在前，越深的子模块定义的资源越在后。\n对于复杂的基础设施，状态文件可能包含成千上万到的资源对象。可以指定一个或多个资源地址来进行过滤。\n可以使用的可选参数有：\n\n-state=path：指定使用的状态文件地址。默认为 terraform.tfstate。使用远程 Backend 时该参数设置无效\n-id=id：要显示的资源 ID\n\n1.7.18.1.1.2. 例子：列出所有资源\n12345$ terraform state listaws_instance.fooaws_instance.bar[0]aws_instance.bar[1]module.elb.aws_elb.main\n1.7.18.1.1.3. 例子：根据资源地址过滤\n123$ terraform state list aws_instance.baraws_instance.bar[0]aws_instance.bar[1]\n1.7.18.1.1.4. 例子：根据模块过滤\n该例子列出给定模块及其子模块的所有资源：\n123$ terraform state list module.elbmodule.elb.aws_elb.mainmodule.elb.module.secgroups.aws_security_group.sg\n1.7.18.1.1.5. 例子：根据ID过滤\n此示例将仅列出在命令行中指定 ID 的资源，查找特定资源在代码中的位置时非常有用：\n12$ terraform state list -id=sg-1234abcdmodule.elb.aws_security_group.sg\n\n\n1.7.18.2.1. mv\n\n\n1.7.18.2.1.1. 用法\n\n\n1.7.18.2.1.2. 例子：重命名一个资源\n\n\n1.7.18.2.1.3. 例子：将一个资源移动进一个模块\n\n\n1.7.18.2.1.4. 例子：移动一个模块进入另一个模块\n\n\n1.7.18.2.1.5. 例子：移动一个模块到另一个状态文件\n\n\n1.7.18.2.1.6. 移动一个带有 count 参数的资源\n\n\n1.7.18.2.1.7. 移动一个带有 for_each 参数的资源\n\n\n\n1.7.18.2.1. mv\nTerraform 状态的主要功能是记录下代码中的资源实例地址与其代表的远程对象之间的绑定。通常，Terraform 会自动更新状态以响应应用计划时采取的操作，例如删除已被删除的远程对象的绑定。\n在修改了 resource 块名称，或是将资源移动到代码中的不同模块时，如果想保留现有的远程对象，可以使用 terraform state mv 命令。\n1.7.18.2.1.1. 用法\nterraform state mv [options] SOURCE DESTINATION\nTerraform 将在当前状态中查找与给定地址匹配的资源实例、资源或模块，如果找到，则将原本由源地址跟踪的远程对象移动到目标地址下。\n源地址和目标地址都必须使用资源地址语法，并且它们引用对象的类型必须相同：我们只能将一个资源实例移动到另一个资源实例，将整个模块实例移动到另一个整个模块实例，等等。此外，如果我们要移动资源或资源实例，则只能将其移动到具有相同资源类型的新地址。\nterraform state mv 最常见的用途是当我们在代码中重命名 resource 块，或是将 resource 块移动到子模块中时，这两种情况都是为了保留现有对象但以新地址跟踪它。默认情况下，Terraform 会将移动或重命名资源配置理解为删除旧对象并在新地址创建新对象的请求，因此 terraform state mv 允许我们已经存在的对象附加到Terraform 中的新地址上。\n警告：如果我们在多人协作环境中使用 Terraform，则必须确保当我们使用 terraform state mv 进行代码重构时，我们与同事进行了仔细沟通，以确保没有人在我们的配置更改和 terraform 状态之间进行任何其他更改mv 命令，因为否则他们可能会无意中创建一个计划，该计划将销毁旧对象并在新地址创建新对象。\n该命令提供以下可选参数：\n\n-dry-run：报告与给定地址匹配的所有资源实例。\n-lock=false：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。\n-lock-timeout=DURATION：除非使用 -lock=false 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。\n\n以下是使用 local Backend 时可用的遗留参数：\n\n-backup=FILENAME：指定源状态文件的备份地址，默认为源状态文件加上&quot;.backup&quot;后缀\n-bakcup-out=FILENAME：指定目标状态文件的备份地址，默认为目标状态文件加上&quot;.backup&quot;后缀\n-state=FILENAME：源状态文件地址，默认为当前 Backend 或是&quot;terraform.tfstate&quot;\n-state-out=FILENAME：目标状态文件地址。如果不指定则使用源状态文件。可以是一个已经存在的文件或新建一个文件\n\n1.7.18.2.1.2. 例子：重命名一个资源\n123456$ terraform state mv &#x27;packet_device.worker&#x27; &#x27;packet_device.helper&#x27;...-resource &quot;packet_device&quot; &quot;worker&quot; &#123;+resource &quot;packet_device&quot; &quot;helper&quot; &#123;   # ...&#125;\n1.7.18.2.1.3. 例子：将一个资源移动进一个模块\n如果我们最初在根模块中编写了资源，但现在希望将其重构进子模块，则可以将 resource 块移动到子模块代码中，删除根模块中的原始资源，然后运行以下命令告诉 Terraform 将其视为一次移动：\n1$ terraform state mv &#x27;packet_device.worker&#x27; &#x27;module.app.packet_device.worker&#x27;\n在上面的示例中，新资源具有相同的名称，但模块地址不同。如果新的模块组织建议不同的命名方案，您还可以同时更改资源名称：\n1$ terraform state mv packet_device.worker module.worker.packet_device.main\n1.7.18.2.1.4. 例子：移动一个模块进入另一个模块\n我们还可以将整个模块重构为子模块。在配置中，将代表模块的 module 块移动到不同的模块中，然后使用如下命令将更改配对：\n1$ terraform state mv &#x27;module.app&#x27; &#x27;module.parent.module.app&#x27;\n1.7.18.2.1.5. 例子：移动一个模块到另一个状态文件\n1$ terraform state mv -state-out=other.tfstate &#x27;module.app&#x27; &#x27;module.app&#x27;\n1.7.18.2.1.6. 移动一个带有 count 参数的资源\n使用 count 元参数定义的资源具有多个实例，每个实例都由一个整数标识。我们可以通过在给定地址中包含显式索引来选择特定实例：\n1$ terraform state mv &#x27;packet_device.worker[0]&#x27; &#x27;packet_device.helper[0]&#x27;\n不使用 count 或 for_each 的资源只有一个资源实例，其地址与资源本身相同，因此我们可以从不包含索引的地址移动到包含索引的地址，或相反：\n1$ terraform state mv &#x27;packet_device.main&#x27; &#x27;packet_device.all[0]&#x27;\n方括号 ([, ]) 在某些 shell 中具有特殊含义，因此您可能需要引用或转义地址，以便将其逐字传递给 Terraform。上面的示例显示了 Unix 风格 shell 的典型引用语法。\n1.7.18.2.1.7. 移动一个带有 for_each 参数的资源\n使用 for_each 元参数定义的资源具有多个实例，每个实例都由一个字符串标识。我们可以通过在给定地址中包含显式的键来选择特定实例。\n但是，字符串的语法包含引号，并且引号符号通常在命令 shell 中具有特殊含义，因此我们需要为正在使用的 shell 使用适当的引用和/或转义语法。例如：\nLinux、MacOS 以及 Unix：\n1$ terraform state mv &#x27;packet_device.worker[&quot;example123&quot;]&#x27; &#x27;packet_device.helper[&quot;example456&quot;]&#x27;\nPowerShell：\n1$ terraform state mv &#x27;packet_device.worker[\\&quot;example123\\&quot;]&#x27; &#x27;packet_device.helper[\\&quot;example456\\&quot;]&#x27;\nWindows 命令行（cmd.exe）：\n1$ terraform state mv packet_device.worker[\\&quot;example123\\&quot;] packet_device.helper[\\&quot;example456\\&quot;]\n除了使用字符串而不是整数作为实例键之外，for_each 资源的处理与 count 资源类似，因此具有和不具有索引组件的相同地址组合都是有效的，如上一节所述。\n\n\n1.7.18.3.1. pull\n\n\n1.7.18.3.1.1. 用法\n\n\n\n1.7.18.3.1. pull\nterraform state pull 命令可以从远程 Backend 中人工下载状态并输出。该命令也可搭配本地状态文件使用。\n1.7.18.3.1.1. 用法\nterraform state pull\n该命令下载当前位置对应的状态文件，并以原始格式打印到标准输出流。\n由于状态文件使用 JSON 格式，该功能可以搭配例如 jq 这样的命令行工具使用，也可以用来人工修改状态文件。\n注意：Terraform 状态文件必须采用 UTF-8 格式，不带字节顺序标记 (BOM)。对于 Windows 上的 PowerShell，使用 Set-Content 自动以 UTF-8 格式对文件进行编码。例如，运行 terraform state pull | sc terraform.tfstate\npush\n\n\n1.7.18.4.1. push\n\n\n1.7.18.4.1.1. 用法\n\n\n\n1.7.18.4.1. push\nterraform push 命令被用来手动上传本地状态文件到远程 Backend。该命令也可以被用在当前使用的本地状态文件上。\n该命令应该很少使用。它时一种需要对远程状态进行手动干预的情况下使用的工具。\n1.7.18.4.1.1. 用法\nterraform state push [options] PATH\n该命令会把 PATH 位置的状态文件推送到当前使用的 Backend 上(可以是当前使用的 terraform.tfstate 文件)。\n如果 PATH 为 -，则从标准输入流读取要推送的状态数据。该数据在写入目标状态之前被完全加载到内存中并进行验证。\n注意：Terraform 状态文件必须采用 UTF-8 格式，不带字节顺序标记 (BOM)。对于 Windows 上的 PowerShell，使用 Set-Content 自动以 UTF-8 格式对文件进行编码。例如，运行 terraform state push | sc terraform.tfstate。\nTerraform 会进行一系列检查以防止你进行一些不安全的变更：\n\n检查 lineage：如果两个状态文件的 lineage 值不同，Terraform 会禁止推送。一个不同的 lineage 说明两个状态文件描述的是完全不同的基础设而你可能会因此丢失重要数据\n序列号检查：如果目标状态文件的 serial 值大于你要推送的状态的 serial 值，Terraform 会禁止推送。一个更高的 serial 值说明目标状态文件已经无法与要推送的状态文件对应上了\n\n这两种检查都可以通过添加 -force 参数禁用，但不推荐这样做。如果禁用安全检查直接推送，那么目标状态文件将被覆盖。\nreplace-provider\n\n\n1.7.18.5.1. replace-provider\n\n\n1.7.18.5.1.1. 用法\n\n\n1.7.18.5.1.2. 样例\n\n\n\n1.7.18.5.1. replace-provider\nterraform state replace-provider 命令可以替换状态文件中资源对象所使用的 Provider.\n1.7.18.5.1.1. 用法\nterraform state replace-provider [options] FROM_PROVIDER_FQN TO_PROVIDER_FQN\n该命令会更新所有使用 from 的 Provider 的资源，将它们使用的 Provider 更新为 to Provider。这让我们可以更新状态文件中资源所使用的 Provider 的源。\n该命令在进行任意修改之前会先生成一个备份文件。备份机制不可关闭。\n支持以下可选参数：\n\n-auto-approve：跳过交互式提示确认环节\n-lock=false：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。\n-lock-timeout=0s：除非使用 -lock=false 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。\n\n以下是使用 local Backend 时可用的遗留参数：\n\n-backup=FILENAME：指定源状态文件的备份地址，默认为源状态文件加上&quot;.backup&quot;后缀\n-bakcup-out=FILENAME：指定目标状态文件的备份地址，默认为目标状态文件加上&quot;.backup&quot;后缀\n-state=FILENAME：源状态文件地址，默认为当前 Backend 或是&quot;terraform.tfstate&quot;\n-state-out=FILENAME：目标状态文件地址。如果不指定则使用源状态文件。可以是一个已经存在的文件或新建一个文件\n\n1.7.18.5.1.2. 样例\n下面的示例将 hashicorp/aws Provider 程序替换为 acme 的复刻版本，该 Provider 托管在 registry.acme.corp 的私有注册表中：\n1$ terraform state replace-provider hashicorp/aws registry.acme.corp/acme/aws\n\n\n1.7.18.6.1. rm\n\n\n1.7.18.6.1.1. 用法\n\n\n1.7.18.6.1.1.1. 删除一个资源\n\n\n1.7.18.6.1.1.2. 删除一个模块\n\n\n1.7.18.6.1.1.3. 删除一个模块内资源\n\n\n1.7.18.6.1.1.4. 删除一个声明count的资源\n\n\n1.7.18.6.1.1.5. 删除一个声明for_each的资源\n\n\n\n1.7.18.6.1. rm\nTerraform 状态的主要功能是记录下代码中的资源实例地址与其代表的远程对象之间的绑定。通常，Terraform 会自动更新状态以响应应用计划时采取的操作，例如删除已被删除的远程对象的绑定。\nterraform state rm 命令可以用来从状态文件中删除对象和实际远程对象的绑定，该命令只是删除绑定，不会删除实际存在的远程对象，删除后 Terraform 会“忘记”这个对象的存在。\n注意：从 Terraform v1.7.0 开始支持 removed 块。与 terraform state rm 命令不同，您可以使用 removed 块一次删除多个资源，并且您可以将删除操作作为正常计划和执行工作流程的一部分进行审查。了解有关将 removed 块与资源一起使用以及将 removed 块与模块一起使用的更多信息。\n1.7.18.6.1.1. 用法\nterraform state rm [options] ADDRESS...\nTerraform 将在状态中搜索与给定资源地址匹配的任何实例，并删除所有实例对应的记录，以便 Terraform 将不再跟踪相应的远程对象。\n这意味着尽管这些对象仍将继续存在于远程系统中，但后续的 terraform plan 会尝试新建这些被“遗忘”的实例。根据远程系统施加的约束，如果这些对象的名称或其他标识符与仍然存在的旧对象发生冲突，创建这些对象可能会失败。\n可以使用如下可选参数：\n\n-dry-run：报告与给定地址匹配的所有资源实例（由于此时并未执行删除，所以 Terraform 这时还不会“遗忘”任何资源）。\n-lock=false：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。\n-lock-timeout=DURATION：除非使用 -lock=false 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。\n\n以下是使用 local Backend 时可用的遗留参数：\n\n-backup=FILENAME：指定源状态文件的备份地址，默认为源状态文件加上&quot;.backup&quot;后缀\n-bakcup-out=FILENAME：指定目标状态文件的备份地址，默认为目标状态文件加上&quot;.backup&quot;后缀\n-state=FILENAME：源状态文件地址，默认为当前 Backend 或是&quot;terraform.tfstate&quot;\n-state-out=FILENAME：目标状态文件地址。如果不指定则使用源状态文件。可以是一个已经存在的文件或新建一个文件\n\n1.7.18.6.1.1.1. 删除一个资源\n下面的例子演示了如何让 Terraform “遗忘”所有类型为 packet_device，并且名为 worker 的资源实例：\n1$ terraform state rm &#x27;packet_device.worker&#x27;\n不使用 count 或 for_each 的资源只有一个实例，因此该示例也是选择该单个实例的正确语法。\n1.7.18.6.1.1.2. 删除一个模块\n1$ terraform state rm &#x27;module.foo&#x27;\n1.7.18.6.1.1.3. 删除一个模块内资源\n要选择在子模块中定义的资源，我们必须指定该模块的路径作为资源地址的一部分：\n1$ terraform state rm &#x27;module.foo.packet_device.worker&#x27;\n1.7.18.6.1.1.4. 删除一个声明count的资源\n使用 count 元参数定义的资源具有多个实例，每个实例都由一个整数标识。我们可以通过在给定地址中包含显式索引来选择特定实例：\n1$ terraform state rm &#x27;packet_device.worker[0]&#x27;\n方括号 ([, ]) 在某些 shell 中具有特殊含义，因此我们可能需要引用或转义地址，以便将其逐字传递给 Terraform。上面的例子使用了 Unix 风格 shell 的典型引用语法。\n1.7.18.6.1.1.5. 删除一个声明for_each的资源\n使用 for_each 元参数定义的资源具有多个实例，每个实例都由一个字符串标识。我们可以通过在给定地址中包含显式密钥来选择特定实例。\n但是，字符串的语法包含引号，并且引号符号通常在命令 shell 中具有特殊含义，因此我们需要为我们正在使用的 shell 使用适当的引用和/或转义语法。例如：\nLinux, MacOS, and Unix：\n1$ terraform state rm &#x27;packet_device.worker[&quot;example&quot;]&#x27;\nPowerShell：\n1$ terraform state rm &#x27;packet_device.worker[\\&quot;example\\&quot;]&#x27;\nWindows命令行（cmd.exe）：\n1$ terraform state rm packet_device.worker[\\&quot;example\\&quot;]\nshow\n\n\n1.7.18.7.1. show\n\n\n1.7.18.7.1.1.1. 用法\n\n\n1.7.18.7.1.1.2. 展示单个资源\n\n\n1.7.18.7.1.1.3. 展示单个模块资源\n\n\n1.7.18.7.1.1.4. 展示声明count资源中特定实例\n\n\n1.7.18.7.1.1.5. 展示声明for_each资源中特定实例\n\n\n\n1.7.18.7.1. show\nterraform state show 命令可以展示状态文件中单个资源的属性。\n1.7.18.7.1.1.1. 用法\nterraform state show [options] ADDRESS\n该命令需要指定一个资源地址。资源地址需要遵循资源地址格式。\n该命令支持以下可选参数：\n\n-state=path：指向状态文件的路径。默认情况下是 terraform.tfstate。如果启用了远程 Backend 则该参数设置无效\n\nterraform state show 的输出被设计成人类可读而非机器可读。如果想要从输出中提取数据，请使用 terraform show -json。\n1.7.18.7.1.1.2. 展示单个资源\n12345678910$ terraform state show &#x27;packet_device.worker&#x27;# packet_device.worker:resource &quot;packet_device&quot; &quot;worker&quot; &#123;    billing_cycle = &quot;hourly&quot;    created       = &quot;2015-12-17T00:06:56Z&quot;    facility      = &quot;ewr1&quot;    hostname      = &quot;prod-xyz01&quot;    id            = &quot;6015bg2b-b8c4-4925-aad2-f0671d5d3b13&quot;    locked        = false&#125;\n1.7.18.7.1.1.3. 展示单个模块资源\n1$ terraform state show &#x27;module.foo.packet_device.worker&#x27;\n1.7.18.7.1.1.4. 展示声明count资源中特定实例\n1$ terraform state show &#x27;packet_device.worker[0]&#x27;\n1.7.18.7.1.1.5. 展示声明for_each资源中特定实例\nLinux, MacOS, and Unix：\n1$ terraform state show &#x27;packet_device.worker[&quot;example&quot;]&#x27;\nPowerShell：\n1$ terraform state show &#x27;packet_device.worker[\\&quot;example\\&quot;]&#x27;\nWindows命令行：\n1$ terraform state show packet_device.worker[\\&quot;example\\&quot;]\n\n\n1.7.19.1. taint\n\n\n1.7.19.1.1. 推荐的替代方法\n\n\n1.7.19.1.2. 用法\n\n\n1.7.19.1.3. 标记单个资源\n\n\n1.7.19.1.4. 标记使用for_each创建的资源的特定实例\n\n\n1.7.19.1.5. 标记模块中的资源\n\n\n\n1.7.19.1. taint\nterrform taint 命令可以手动标记某个Terraform管理的资源有&quot;污点&quot;，强迫在下一次执行apply时删除并重建之。\n该命令并不会修改基础设施，而是在状态文件中的某个资源对象上标记污点。当一个资源对象被标记了污点，在下一次 plan 操作时会计划将之删除并且重建，apply 操作会执行这个变更。\n强迫重建某个资源可以使你能够触发某种副作用。举例来说，你想重新执行某个预置器操作，或是某些人绕过 Terraform 修改了虚拟机状态，而你想将虚拟机重置。\n注意为某个资源标记污点并重建之会影响到所有依赖该资源的对象。举例来说，一条 DNS 记录使用了服务器的 IP 地址，我们在服务器上标记污点会导致 IP 发生变化从而影响到 DNS 记录。这种情况下可以使用 plan 命令查看变更计划。\n警告：此命令已被弃用。从 Terraform v0.15.2 开始，我们建议使用 -replace 选项和 terraform apply 代替（详细信息如下）。\n1.7.19.1.1. 推荐的替代方法\n从 Terraform v0.15.2 开始，我们建议使用 terraform apply 的 -replace 选项来强制 Terraform 替换对象，即使没有发生需要变更的配置更改。\n1terraform apply -replace=&quot;aws_instance.example[0]&quot;\n我们推荐使用 -replace 参数，因为这可以在 Terraform 计划中显示将要发生的变更，让我们在采取任何会影响系统的操作之前了解计划将如何影响我们的基础设施。当我们使用 terraform taint 时，其他用户有可能可以在我们审查变更之前针对标记的对象创建新的变更计划。\n1.7.19.1.2. 用法\n1terraform taint [options] &lt;address&gt;\naddress 参数是要标记污点的资源地址。该地址格式遵循资源地址语法，例如：\n\naws_instance.foo\naws_instance.bar[1]\naws_instance.baz[\\&quot;key\\&quot;] （资源地址中的引号必须在命令行中转义，这样它们就不会被 shell 解释）\nmodule.foo.module.bar.aws_instance.qux\n\n该命令可以使用如下可选参数：\n\n-allow-missing：如果声明该参数，那么即使资源不存在，命令也会返回成功(状态码0)。对于其他异常情况，该命令可能仍会返回错误，例如读取或写入状态时出现问题。\n-lock=false：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。\n-lock-timeout=DURATION：除非使用 -lock=false 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。\n\n以下是使用 local Backend 时可用的遗留参数：\n\n-backup=FILENAME：指定源状态文件的备份地址，默认为源状态文件加上&quot;.backup&quot;后缀\n-bakcup-out=FILENAME：指定目标状态文件的备份地址，默认为目标状态文件加上&quot;.backup&quot;后缀\n-state=FILENAME：源状态文件地址，默认为当前 Backend 或是&quot;terraform.tfstate&quot;\n-state-out=FILENAME：目标状态文件地址。如果不指定则使用源状态文件。可以是一个已经存在的文件或新建一个文件\n\n1.7.19.1.3. 标记单个资源\n12$ terraform taint aws_security_group.allow_allThe resource aws_security_group.allow_all in the module root has been marked as tainted.\n1.7.19.1.4. 标记使用for_each创建的资源的特定实例\n12$ terraform taint &quot;module.route_tables.azurerm_route_table.rt[\\&quot;DefaultSubnet\\&quot;]&quot;The resource module.route_tables.azurerm_route_table.rt[&quot;DefaultSubnet&quot;] in the module root has been marked as tainted.\n1.7.19.1.5. 标记模块中的资源\n12$ terraform taint &quot;module.couchbase.aws_instance.cb_node[9]&quot;Resource instance module.couchbase.aws_instance.cb_node[9] has been marked as tainted.\n虽然我们推荐模块深度不要超过1，但是我们仍然可以标记多层模块中的资源：\n12$ terraform taint &quot;module.child.module.grandchild.aws_instance.example[2]&quot;Resource instance module.child.module.grandchild.aws_instance.example[2] has been marked as tainted.\n\n\n1.7.20.1. validate\n\n\n1.7.20.1.1. 用法\n\n\n1.7.20.1.2. JSON 输出格式\n\n\n1.7.20.1.2.1. 源位置（Source Position）\n\n\n1.7.20.1.2.2. 表达式值\n\n\n\n1.7.20.1. validate\nterraform validate 命令可以检查目录下 Terraform 代码，只检查语法文件，不会访问诸如远程 Backend、Provider 的 API 等远程资源。\nvalidate 检查代码的语法是否合法以及一致，不管输入变量以及现存状态。\n自动运行此命令是安全的，例如作为文本编辑器中的保存后检查或作为 CI 系统中可复用的测试步骤。\nvalidate 命令需要已初始化的工作目录，所有引用的插件与模块都被安装完毕。如果只想检查语法而不想与 Backend 交互，可以这样初始化工作目录：\n1$ terraform init -backend=false\n要验证特定运行上下文中的配置（特定目标工作空间、输入变量值等），请改用 terraform plan 命令，其中包括隐式验证检查。\n1.7.20.1.1. 用法\nterraform validate [options]\n默认情况下 validate 命令不需要任何参数就可以在当前工作目录下进行检查。\n可以使用如下可选参数：\n\n-json：使用 JSON 格式输出机器可读的结果\n-no-color：禁止使用彩色输出\n\n1.7.20.1.2. JSON 输出格式\n当您使用 -json 选项时，Terraform 将生成 JSON 格式的验证结果，使得我们可以将之与验证结果的工具进行集成，例如在文本编辑器中突出显示错误。\n与所有 JSON 输出选项一样，Terraform 在开始验证任务之前就可能会遇到错误，因此输出的错误可能不会是 JSON 格式的。因此，使用 Terraform 输出的外部软件应该准备好在 stdout 上读取到非有效 JSON 的数据，然后将其视为一般错误情况。\n输出包含一个 format_version 键，从 Terraform 1.1.0 开始，其值为“1.0”。该版本的语义是：\n\n对于向后兼容的变更或新增字段，我们将增加 minor 版本号，例如 &quot;1.1&quot;。这种变更会忽略所有不认识的对象属性，以保持与未来其他 minor 版本的前向兼容。\n对于不向后兼容的变更，我们将增加 major 版本，例如 &quot;2.0&quot;。不同的 major 版本之间的数据无法直接传递。\n\n我们只会在 Terraform 1.0 兼容性承诺的范围内更新 major 版本。\n在正常情况下，Terraform 会将 JSON 对象打印到标准输出流。顶级 JSON 对象将具有以下属性：\n\nvalid（bool）：总体验证结果结论，如果 Terraform 认为当前配置有效，则为 true；如果检测到任何错误，则为 false。\nerror_count（number）：零或正整数，给出 Terraform 检测到的错误计数。如果 valid 为 true，则 error_count 将始终为零，因为错误的存在表明配置无效。\nwarning_count（number）：零或正整数，给出 Terraform 检测到的警告计数。警告不会导致 Terraform 认为配置无效，但用户应考虑并尝试解决它们。\ndiagnostics（对象数组）：嵌套对象的 JSON 数组，每个对象描述来自 Terraform 的错误或警告。\n\ndiagnostics 中的对象拥有如下属性：\n\nseverity（string）：字符串关键字，可以是 &quot;error&quot; 或 &quot;warning&quot;，指示诊断严重性。 error 的存在会导致 Terraform 认为配置无效，而 warning 只是对用户的建议或警告，不会阻止代码运行。Terraform 的后续版本可能会引入新的严重性等级，因此解析错误信息时应该准备好接受并忽略他们不了解的 severity 值。\nsummary（string）：诊断报告的问题性质的简短描述。\n\n在 Terraform 易于阅读的的诊断消息中，summary 充当诊断的一种“标题”，打印在 “Error:” 或 “Warning:” 指示符之后。\n摘要通常是简短的单个句子，但如果返回错误的子系统并没有设计成返回全面的诊断信息时，就只能把整个错误信息作为摘要返回，导致较长的摘要。这种情况下，摘要可能包含换行符，渲染摘要信息时需要注意。\n\ndetail（string）：可选的附加消息，提供有关问题的更多详细信息。\n\n在 Terraform 易于阅读的的诊断消息中，详细信息提供了标题和源位置引用之后出现的文本段落。\n详细消息通常是多个段落，并且可能散布有非段落行，因此旨在向用户呈现详细消息的工具应该区分没有前导空格的行，将它们视为段落，以及有前导空格的行，将它们视为预格式化文本。然后，渲染器应该对段落进行软换行以适合渲染容器的宽度，但保留预格式化的行不换行。\n一些 Terraform 详细消息包含使用 ASCII 字符来标记项目符号的近似项目符号列表。这不是官方承诺，因此渲染器应避免依赖它，而应将这些行视为段落或预格式化文本。此格式的未来版本可能会为其他文本约定定义附加规则，但将保持向后兼容性。\n\nrange（对象）：引用与诊断消息相关的配置源代码的一部分的可选对象。对于错误，这通常指示被检测为无效的特定块头、属性或表达式的边界。\n\n源范围是一个具有 filename 属性的对象，该 filename 为当前工作目录的相对路径，然后两个属性 start 和 end 本身都是描述源位置的对象，如下所述。\n并非所有诊断消息都与配置的特定部分相关，因此对于不相关的诊断消息，range 将被省略或为 null。\nsnippet（对象）：可选对象，包括与诊断消息相关的配置源代码的摘录。\nsnippet 信息包括了：\n\ncontext（string）：诊断的根上下文的可选摘要。例如，这可能是包含触发诊断的表达式的 resource 块。对于某些诊断，此信息不可用，并且此属性将为空。\ncode（string）：Terraform 配置的片段，包括诊断源。可能包含多行，并且可能包括触发诊断的表达式周围的附加配置源代码。\nstart_line（number）：从一开始的行计数，表示源文件中代码摘录开始的位置。该值不一定与 range.start.line 相同，因为 code 可能在诊断源之前包含一行或多行上下文。\nhighlight_start_offset（number）：代码字符串中从零开始的字符偏移量，指向触发诊断的表达式的开头。\nhighlight_end_offset（number）：代码字符串中从零开始的字符偏移量，指向触发诊断的表达式的末尾。\nvalues（对象数组）：包含零个或多个表达式值，帮助我们理解复杂表达式中的诊断来源。这些表达式值对象如下所述。\n\n1.7.20.1.2.1. 源位置（Source Position）\n在诊断对象的 range 属性中源位置对象具有以下属性：\n\nbyte（number）：指定文件中从零开始的字节偏移量。\nline（number）：从一开始的行计数，指向文件中相关位置的行。\ncolumn（number）：从一开始的列计数，指向 line 对应的行开头开始的 Unicode 字符计数位置。 start 位置是包含的（数学的 []），而 end 位置是不包含的（数学的 ()）。用于特定错误消息的确切位置仅供人类解读。\n\n1.7.20.1.2.2. 表达式值\n表达式值对象提供有关触发诊断的表达式一部分的值的附加信息。当使用 for_each 或类似结构时，这特别有用，以便准确识别哪些值导致错误。该对象有两个属性：\n\n\ntraversal (string)：类似 HCL 的可遍历表达式字符串，例如 var.instance_count。复杂的索引键值可能会被省略，因此该属性并非总是合法、可解析的 HCL。该字符串的内容旨在便于人类阅读。\n\n\nstatement（string）：一个简短的英语片段，描述触发诊断时表达式的值。该字符串的内容旨在便于人类阅读，并且在 Terraform 的未来版本中可能会发生变化。\n\n\n1.7.21.1. untaint\n\n\n1.7.21.1.1. 用法\n\n\n\n1.7.21.1. untaint\nTerraform 有一个名为“tainted”的标记，用于跟踪可能损坏的对象，该命令已被废弃，应使用 terraform apply -replace 代替。\n如果创建一个资源的操作由多个步骤组成，操作期间其中之一的操作发生错误，Terraform 会自动将对象标记为“受污染”，因为 Terraform 无法确定该对象是否处于完整功能状态。\nterraform untaint 命令可以手动清除一个 Terraform 管理的资源对象上的污点，恢复它在状态文件中的状态。它是 terraform taint 的逆向操作。\n该命令不会修改实际的基础设施资源，只会在资源文件中清除资源对象上的污点标记。\n如果我们从对象中删除污点标记，但后来发现它还是损坏了，则可以使用如下命令创建并应用一个计划来替换受损的资源对象，而无需首先重新在该对象上标记污点：\n1terraform apply -replace=&quot;aws_instance.example[0]&quot;\n1.7.21.1.1. 用法\nterraform untaint [options] address\nname参数是要清除污点的资源的资源名称。该参数的格式为TYPE.NAME，比如aws_instance.foo。\n可以使用如下可选参数：\n\n-allow-missing：如果声明该参数，那么即使资源不存在，命令也会返回成功(状态码0)。对于其他异常情况，该命令可能仍会返回错误，例如读取或写入状态时出现问题。\n-lock=false：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。\n-lock-timeout=DURATION：除非使用 -lock=false 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。\n-no-color：关闭彩色输出。在无法解释输出色彩的终端中运行 Terraform 时请使用此参数。\n\n以下是使用 local Backend 时可用的遗留参数：\n\n\n-backup=FILENAME：指定源状态文件的备份地址，默认为源状态文件加上&quot;.backup&quot;后缀\n\n\n-bakcup-out=FILENAME：指定目标状态文件的备份地址，默认为目标状态文件加上&quot;.backup&quot;后缀\n\n\n-state=FILENAME：源状态文件地址，默认为当前 Backend 或是&quot;terraform.tfstate&quot;\n\n\n-state-out=FILENAME：目标状态文件地址。如果不指定则使用源状态文件。可以是一个已经存在的文件或新建一个文件\n\n\n1.7.22.1. workspace\n\n\n1.7.22.1.1. 用法\n\n\n\n1.7.22.1. workspace\nterraform workspace 命令可以用来管理当前使用的工作区。我们在状态管理章节中介绍过工作区的概念。\n该命令包含一系列子命令，我们将会一一介绍。\n1.7.22.1.1. 用法\nterraform workspace &lt;subcommand&gt; [options] [args]\n\n\n1.7.22.1.1. list\n\n\n1.7.22.1.1.1. 用法\n\n\n\n1.7.22.1.1. list\nterraform workspace list 命令列出当前存在的工作区。\n1.7.22.1.1.1. 用法\nterraform workspace list [DIR]\n该命令会打印出存在的工作区。当前工作会使用 * 号标记：\n1234$ terraform workspace list  default* development  jsmith-test\n\n\n1.7.22.2.1. select\n\n\n1.7.22.2.1.1. 用法\n\n\n\n1.7.22.2.1. select\nterraform workspace select 命令用来选择使用的工作区。\n1.7.22.2.1.1. 用法\nterraform workspace select NAME [DIR]\nNAME 指定的工作区必须已经存在：\n该命令支持以下参数\n\n-or-create：如果指定的工作区不存在，则创建之。默认为 false。\n\n1234567$ terraform workspace list  default* development  jsmith-test$ terraform workspace select defaultSwitched to workspace &quot;default&quot;.\nnew\n\n\n1.7.22.3.1. new\n\n\n1.7.22.3.1.1. 用法\n\n\n\n1.7.22.3.1. new\nterraform workspace new 命令用来创建新的工作区。\n1.7.22.3.1.1. 用法\nterraform workspace new [OPTIONS] NAME [DIR]\n该命令使用给定名字创建一个新的工作区。不可存在同名工作区。\n如果使用了 -state 参数，那么给定路径的状态文件会被拷贝到新工作区。\n该命令支持以下可选参数：\n\n-lock=false：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。\n-lock-timeout=DURATION：除非使用 -lock=false 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。默认为 0s。\n-state=path：用来初始化新环境所使用的状态文件路径\n\n创建新工作区：\n123456$ terraform workspace new exampleCreated and switched to workspace &quot;example&quot;!You&#x27;re now on a new, empty workspace. Workspaces isolate their state,so if you run &quot;terraform plan&quot; Terraform will not see any existing statefor this configuration.\n使用状态文件创建新工作区：\n123456$ terraform workspace new -state=old.terraform.tfstate exampleCreated and switched to workspace &quot;example&quot;.You&#x27;re now on a new, empty workspace. Workspaces isolate their state,so if you run &quot;terraform plan&quot; Terraform will not see any existing statefor this configuration.\ndelete\n\n\n1.7.22.4.1. delete\n\n\n1.7.22.4.1.1. 用法\n\n\n\n1.7.22.4.1. delete\nterraform workspace delete 命令被用以删除已经存在的工作区。\n1.7.22.4.1.1. 用法\nterraform workspace delete [OPTIONS] NAME [DIR]\n该命令被用以删除已经存在的工作区。\n被删除的工作区必须已经存在，并且不可以删除当前正在使用的工作区。如果工作区状态不是空的（存在跟踪中的远程对象），Terraform 会禁止删除，除非声明 -force 参数。\n另外，不同的 Backend 在没有 -force 参数时可能会有不同的限制，以实现对工作区的安全删除，例如检查工作区是否已上锁。\n如果使用 -force 删除非空工作区，那么原本跟踪的资源的状态就将处于&quot;dangling&quot;，也就是实际基础设施资源仍然存在，但脱离了 Terraform的 管理。有时我们希望这样，只是希望当前 Terraform 项目不再管理这些资源，交由其他项目管理。但大多数情况下并非这样，所以 Terraform 默认会禁止删除非空工作区。\n该命令可以使用如下可选参数：\n\n-force：删除含有非空状态文件的工作区。默认为 false。\n-lock=false：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。\n-lock-timeout=DURATION：除非使用 -lock=false 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。默认为 0s。\n\n例子：\n12$ terraform workspace delete exampleDeleted workspace &quot;example&quot;.\n\n\n1.7.22.5.1. show\n\n\n1.7.22.5.1.1. 用法\n\n\n\n1.7.22.5.1. show\nterraform workspace show 命令被用以输出当前使用的工作区。\n1.7.22.5.1.1. 用法\nterraform workspace show\n例子：\n12$ terraform workspace showdevelopment\n\n\n1.7.23.1. test\n\n\n1.7.23.1.1. 用法\n\n\n1.7.23.1.2. 一般参数\n\n\n1.7.23.1.3. 状态管理\n\n\n1.7.23.1.3.1. Terraform 测试清理\n\n\n1.7.23.1.4. 在 HCP Terraform 上运行测试\n\n\n1.7.23.1.5. 例子：测试的目录结构与命令\n\n\n1.7.23.1.5.1. 另一种测试目录结构\n\n\n\n1.7.23.1. test\nterraform test 命令读取 Terraform 测试文件并执行其中的测试。\ntest 命令和测试文件对于想要验证和测试其旨在被复用的模块的作者特别有用。我们也可以使用 test 命令来验证根模块。\n1.7.23.1.1. 用法\nterraform test [options]\n该命令在当前目录和指定的测试目录（默认情况下是 test 目录）中搜索所有 Terraform 测试文件，并执行指定的测试。有关测试文件的更多详细信息，请参阅测试。\nTerraform 然后会根据测试文件的规范执行一系列 Terraform 的 plan 或 apply 命令，并根据测试文件的规范验证相关计划和状态文件。\n警告：Terraform 测试命令可以创建真正的基础设施，但可能会产生成本。请参阅 Terraform 测试清理部分，了解确保创建的基础设施被清理的最佳实践。\n1.7.23.1.2. 一般参数\nTerraform test 命令支持以下参数：\n\n-cloud-run=&lt;module source&gt; - 通过 HCP Terraform 远程运行针对指定的 Terraform 私有注册表模块的测试。\n-filter=testfile - 将 terraform test 操作限制为指定的测试文件。\n-json - 显示测试结果的机器可读 JSON 输出。\n-test-directory=&lt;relative directory&gt; - 指定 Terraform 查找测试文件的目录。请注意，Terraform 始终在主代码目录中加载测试文件。默认的测试目录是 tests。\n-verbose - 根据每个运行块的 command 属性打印出测试文件中每个 run 块的计划或状态。\n\n1.7.23.1.3. 状态管理\n每个 Terraform 测试文件在执行时都会在内存中从无到有地维护所需的所有 Terraform 状态。该状态完全独立于被测代码的任何现有状态，因此您可以安全地执行 Terraform 测试命令，而不会影响任何已存在的基础设施。\n1.7.23.1.3.1. Terraform 测试清理\nTerraform test 命令可以创建真实的基础设施。一旦 Terraform 完全执行了所有测试文件，Terraform 就会尝试销毁所有遗留的基础设施。如果无法销毁，Terraform 会报告由它创建但无法销毁的资源列表。\n我们应该密切监视测试命令的输出，以确保 Terraform 清理了它创建的基础设施，否则需要执行手动清理。我们建议为目标 Provider 创建专用的测试帐户，这样可以定期安全地清除该帐户内的资源，确保不会意外地留下昂贵的资源。\nTerraform 还提供诊断，解释为什么它无法自动清理。我们应该检查这些诊断，以确保未来的清理操作成功。\n1.7.23.1.4. 在 HCP Terraform 上运行测试\n我们可以使用 -cloud-run 参数在 HCP Terraform 上远程执行测试。\n-cloud-run 参数接受私有注册表模块地址。此参数针对 HCP Terraform 用户界面中指定的私有模块运行测试。\n我们必须提供来自私有注册表的模块，而不是公共 Terraform 注册表。\n在使用该参数之前，您必须执行 terraform login，并确保您的 host 参数与目标模块的私有注册表主机名匹配。\n1.7.23.1.5. 例子：测试的目录结构与命令\n以下目录结构表示包含测试和配置（setup）模块的 Terraform 模块的示例目录树：\n1234567891011121314project/|-- main.tf|-- outputs.tf|-- terraform.tf|-- variables.tf|-- tests/|   |-- validations.tftest.hcl|   |-- outputs.tftest.hcl|-- testing/    |-- setup/        |-- main.tf        |-- outputs.tf        |-- terraform.tf        |-- variables.tf\n在项目的根目录下，有一些典型的 Terraform 配置文件：main.tf、outputs.tf、terraform.tf 和 variables.tf。测试文件 validations.tftest.hcl 和 outputs.tftest.hcl 位于默认测试目录 tests 中。\n另外 testing 目录下有一个为测试而存在的设置(setup)模块\n要执行测试，我们应该从代码根目录运行 terraform test，如同运行 terraform plan 或 terraform apply 一样。尽管实际的测试文件位于内嵌的 tests 目录中，但 Terraform 仍从主代码目录执行。\n可以使用 -filter 参数指定执行特定的测试文件。\nLinux、Mac 操作系统和 UNIX 下：\n1terraform test -filter=tests/validations.tftest.hcl\nPowerShell：\n1terraform test -filter=&#x27;tests\\validations.tftest.hcl&#x27;\nWindows cmd.exe：\n1terraform test -filter=tests\\validations.tftest.hcl\n1.7.23.1.5.1. 另一种测试目录结构\n在上面的示例中，测试文件位于默认的 tests 目录中。测试文件也可以直接包含在主代码目录中：\n12345678910111213project/|-- main.tf|-- outputs.tf|-- terraform.tf|-- variables.tf|-- validations.tftest.hcl|-- outputs.tftest.hcl|-- testing/    |-- setup/        |-- main.tf        |-- outputs.tf        |-- terraform.tf        |-- variables.tf\n测试文件的位置不会影响 terraform test 的运行。测试文件的所有引用以及其中的绝对文件路径都应相对于主代码目录。\n我们还可以使用 -test-directory 参数来更改测试文件的位置。例如， terraform test -test-directory=testing 将命令 Terraform 从 testing 目录加载测试，而不是 tests。\n测试目录必须位于主代码目录下，但可以多层嵌套。\n\n注意：无论 -test-directory 的值为何，根代码目录中的测试文件始终会被加载。\n\n我们不建议更改默认测试目录。这些自定义选项是为那些在 terraform test 功能发布之前可能已在其代码中包含了 tests 子模块的代码作者准备的。一般来说，应始终使用默认的 tests 目录。\n","dateCreated":"2023-01-28T17:43:45+08:00","dateModified":"2025-06-17T23:02:42+08:00","datePublished":"2023-01-28T17:43:45+08:00","description":"","headline":"Terraform-命令行2","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://chankein.github.io/2023/01/28/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C2/"},"publisher":{"@type":"Organization","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg","logo":{"@type":"ImageObject","url":"profile.jpg"}},"url":"https://chankein.github.io/2023/01/28/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C2/","keywords":"Terraform"}</script>
    <meta name="description" content="1.7.16.1. refresh   1.7.16.1.1. 用法    1.7.16.1. refresh terraform refresh 命令将实际存在的基础设施对象的状态同步到状态文件中记录的对象状态。它可以用来检测真实状态与记录状态之间的漂移并更新状态文件。  警告！！！该命令已在最新版本 Terraform 中被废弃，因为该命令的默认行为在当前用户错误配置了使用的云平台令牌时会">
<meta property="og:type" content="blog">
<meta property="og:title" content="Terraform-命令行2">
<meta property="og:url" content="https://chankein.github.io/2023/01/28/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C2/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:description" content="1.7.16.1. refresh   1.7.16.1.1. 用法    1.7.16.1. refresh terraform refresh 命令将实际存在的基础设施对象的状态同步到状态文件中记录的对象状态。它可以用来检测真实状态与记录状态之间的漂移并更新状态文件。  警告！！！该命令已在最新版本 Terraform 中被废弃，因为该命令的默认行为在当前用户错误配置了使用的云平台令牌时会">
<meta property="og:locale" content="zh_TW">
<meta property="article:published_time" content="2023-01-28T09:43:45.000Z">
<meta property="article:modified_time" content="2025-06-17T15:02:42.580Z">
<meta property="article:author" content="Kein Chan">
<meta property="article:tag" content="Terraform">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../../../#about"
            >
        
        
            <img class="header-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Terraform-命令行2
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2023-01-28T17:43:45+08:00">
	
		    2023 年 1 月 28 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../../categories/devops/">devops</a>, <a class="category-link" href="../../../../../categories/devops/Terraform/">Terraform</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <ul>
<li>
<p><a href="#refresh"><strong>1.7.16.1.</strong> refresh</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.16.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#refresh"></a></p>
<h2 id="1-7-16-1-refresh"><a href="#refresh"></a>1.7.16.1. refresh</h2>
<p><code>terraform refresh</code> 命令将实际存在的基础设施对象的状态同步到状态文件中记录的对象状态。它可以用来检测真实状态与记录状态之间的漂移并更新状态文件。</p>
<blockquote>
<p>警告！！！该命令已在最新版本 Terraform 中被废弃，因为该命令的默认行为在当前用户错误配置了使用的云平台令牌时会引发对状态文件错误的变更。</p>
</blockquote>
<p>该命令并不会修改基础设施对象，只修改<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/2.%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html">状态文件</a>。</p>
<p>我们一般不需要使用该命令，因为 Terraform 会自动执行相同的刷新操作，作为在 <code>terraform plan</code> 和 <code>terraform apply</code> 命令中创建计划的一部分。本命令在这里主要是为了向后兼容，但我们不建议使用它，因为它没有提供在更新状态之前检查操作效果的机会。</p>
<h2 id="1-7-16-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.16.1.1. 用法</h2>
<p><code>terraform refresh [options]</code></p>
<p>该命令本质上是以下命令的别名，具有完全相同的效果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply -refresh-only -auto-approve</span><br></pre></td></tr></table></figure>
<p>因此，该命令支持所有 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/4.apply.html"><code>terraform apply</code></a> 所支持的参数，除了它不接受一个现存的变更计划文件，不允许选择 “refresh only” 之外的模式，并且始终应用 <code>-auto-approve</code> 选项。</p>
<p>自动执行 <code>refresh</code> 是很危险的，因为如果当前用户错误配置了使用的 Provider 的令牌，那么 Terraform 会错误地以为当前状态文件中记录的所有资源都被删除了，随即从状态文件中无预警地删除所有相关记录。</p>
<p>我们推荐运行如下命令来取得相同的效果，同时可以在修改状态文件之前预览即将对其作出的修改：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply -refresh-only</span><br></pre></td></tr></table></figure>
<p>该命令将会在交互界面中提示用户检测到的变更，并提示用户确认执行。</p>
<p><code>terraform apply</code> 和 <code>terraform plan</code> 命令的 <code>-refresh-only</code> 选项是从 Terraform v0.15.4 版本开始被引入的。对更早的版本，用户只能直接使用 <code>terraform refresh</code> 命令，同时要小心本篇警告过的危险副作用。尽可能避免显式使用 <code>terraform refresh</code> 命令，Terraform 在执行 <code>terraform plan</code> 和 <code>terraform apply</code> 命令时都会自动执行刷新状态的操作以生成变更计划，尽可能依赖该机制来维持状态文件的同步。</p>
<h2 id="show"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">show</a></h2>
<ul>
<li>
<p><a href="#show"><strong>1.7.17.1.</strong> show</a></p>
</li>
<li>
<p><a href="#json-%E8%BE%93%E5%87%BA"><strong>1.7.17.1.1.</strong> JSON 输出</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.17.1.2.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#show"></a></p>
<h2 id="1-7-17-1-show"><a href="#show"></a>1.7.17.1. show</h2>
<p><code>terraform show</code> 命令从状态文件或是变更计划文件中打印人类可读的输出信息。这可以用来检查变更计划以确定所有操作都是符合预期的，或是审查当前的状态文件。</p>
<p>可以通过添加 <code>-json</code> 参数输出机器可读的 JSON 格式输出。</p>
<p>需要注意的是，使用 <code>-json</code> 输出时所有标记为 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/3.%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F.html#%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E4%B8%AD%E9%9A%90%E8%97%8F%E5%80%BC-sensitive"><code>sensitive</code></a> 的敏感数据都会以明文形式被输出。</p>
<h2 id="1-7-17-1-1-JSON-输出"><a href="#json-%E8%BE%93%E5%87%BA"></a>1.7.17.1.1. JSON 输出</h2>
<p>可以使用 <code>terraform show -json</code> 命令打印 JSON 格式的状态信息。</p>
<p>如果指定了一个变更计划文件，<code>terraform show -json</code> 会以 JSON 格式记录变更计划、配置以及当前状态。</p>
<p>如果在写入状态文件后更新了包含新架构版本的 Provider 程序，则需要先升级状态，然后才能使用 <code>show -json</code> 显示状态。如果要查看计划，必须先在不使用 <code>-refresh=false</code> 的情况下创建计划文件。如果要查看当前状态，请先运行 <code>terraform refresh</code>。</p>
<h2 id="1-7-17-1-2-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.17.1.2. 用法</h2>
<p><code>terraform show [options] [file]</code></p>
<p>您可以将为 <code>file</code> 指定状态文件或计划文件的路径。如果不指定文件路径，Terraform 将显示最新的状态快照。</p>
<p>该命令支持以下参数：</p>
<ul>
<li><code>-json</code>：以 JSON 格式输出</li>
<li><code>-no-color</code>：与 <code>apply</code> 类似，不再赘述</li>
</ul>
<h2 id="state"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">state</a></h2>
<ul>
<li>
<p><a href="#state"><strong>1.7.18.1.</strong> state</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.18.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E8%BF%9C%E7%A8%8B%E7%8A%B6%E6%80%81"><strong>1.7.18.1.2.</strong> 远程状态</a></p>
</li>
<li>
<p><a href="#%E5%A4%87%E4%BB%BD"><strong>1.7.18.1.3.</strong> 备份</a></p>
</li>
<li>
<p><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%8B%E5%A5%BD"><strong>1.7.18.1.4.</strong> 命令行友好</a></p>
</li>
<li>
<p><a href="#%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80"><strong>1.7.18.1.5.</strong> 资源地址</a></p>
</li>
</ul>
<p><a href="#state"></a></p>
<h2 id="1-7-18-1-state"><a href="#state"></a>1.7.18.1. state</h2>
<p><code>terraform state</code> 命令可以用来进行复杂的状态管理操作。随着你对 Terraform 的使用越来越深入，有时候你需要对状态文件进行一些修改。由于我们在状态管理章节中提到过的，状态文件的格式属于 HashiCorp 未公开的私有格式，所以直接修改状态文件是不适合的，我们可以使用 <code>terraform state</code> 命令来执行修改。</p>
<p>该命令含有数个子命令，我们会一一介绍。</p>
<h2 id="1-7-18-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.18.1.1. 用法</h2>
<p><code>terraform state &lt;subcommand&gt; [options] [args]</code></p>
<h2 id="1-7-18-1-2-远程状态"><a href="#%E8%BF%9C%E7%A8%8B%E7%8A%B6%E6%80%81"></a>1.7.18.1.2. 远程状态</h2>
<p>所有的 <code>state</code> 子命令都可以搭配本地状态文件以及远程状态使用。使用远程状态时读写操作可能用时稍长，因为读写都要通过网络完成。备份文件仍然会被写入本地磁盘。</p>
<h2 id="1-7-18-1-3-备份"><a href="#%E5%A4%87%E4%BB%BD"></a>1.7.18.1.3. 备份</h2>
<p>所有会修改状态文件的 <code>terraform state</code> 子命令都会生成备份文件。可以通过 <code>-backup</code> 参数指定备份文件的位置。</p>
<p>只读子命令(例如 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/18.state/1.list.html"><code>list</code></a> )由于不会修改状态，所以不会生成备份文件。</p>
<p>注意修改状态的 <code>state</code> 子命令无法禁用备份。由于状态文件的敏感性，Terraform 强制所有修改状态的子命令都必须生成备份文件。如果你不想保存备份，可以手动删除。</p>
<h2 id="1-7-18-1-4-命令行友好"><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%8B%E5%A5%BD"></a>1.7.18.1.4. 命令行友好</h2>
<p><code>state</code> 子命令的输出以及命令结构都被设计得易于同 Unix 下其他命令行工具搭配使用，例如 grep、awk 等等。同样的，输出结果也可以在 Windows 上轻松使用 PowerShell 处理。</p>
<p>对于复杂场景，我们建议使用管道组合 <code>state</code> 子命令与其他命令行工具一同使用。</p>
<h2 id="1-7-18-1-5-资源地址"><a href="#%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80"></a>1.7.18.1.5. 资源地址</h2>
<p><code>state</code> 子命令中大量使用了资源地址，我们在<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/3.%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80.html">资源地址</a>章节中做了相关的介绍。</p>
<h2 id="list"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">list</a></h2>
<ul>
<li>
<p><a href="#list"><strong>1.7.18.1.1.</strong> list</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.18.1.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E8%B5%84%E6%BA%90"><strong>1.7.18.1.1.2.</strong> 例子：列出所有资源</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%A0%B9%E6%8D%AE%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80%E8%BF%87%E6%BB%A4"><strong>1.7.18.1.1.3.</strong> 例子：根据资源地址过滤</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%A0%B9%E6%8D%AE%E6%A8%A1%E5%9D%97%E8%BF%87%E6%BB%A4"><strong>1.7.18.1.1.4.</strong> 例子：根据模块过滤</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%A0%B9%E6%8D%AEid%E8%BF%87%E6%BB%A4"><strong>1.7.18.1.1.5.</strong> 例子：根据ID过滤</a></p>
</li>
</ul>
<p><a href="#list"></a></p>
<h2 id="1-7-18-1-1-list"><a href="#list"></a>1.7.18.1.1. list</h2>
<p><code>terraform state list</code> 命令可以列出<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/2.%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html">状态文件</a>中记录的资源对象。</p>
<h2 id="1-7-18-1-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.18.1.1.1. 用法</h2>
<p><code>terraform state list [options] [address...]</code></p>
<p>该命令会根据 address 列出状态文件中相关资源的信息(如果给定了 address 的话)。如果没有给定 address，那么所有资源都会被列出。</p>
<p>列出的资源根据模块深度以及字典序进行排序，这意味着根模块的资源在前，越深的子模块定义的资源越在后。</p>
<p>对于复杂的基础设施，状态文件可能包含成千上万到的资源对象。可以指定一个或多个资源地址来进行过滤。</p>
<p>可以使用的可选参数有：</p>
<ul>
<li><code>-state=path</code>：指定使用的状态文件地址。默认为 <code>terraform.tfstate</code>。使用远程 Backend 时该参数设置无效</li>
<li><code>-id=id</code>：要显示的资源 ID</li>
</ul>
<h2 id="1-7-18-1-1-2-例子：列出所有资源"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E8%B5%84%E6%BA%90"></a>1.7.18.1.1.2. 例子：列出所有资源</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state list</span><br><span class="line">aws_instance.foo</span><br><span class="line">aws_instance.bar[0]</span><br><span class="line">aws_instance.bar[1]</span><br><span class="line">module.elb.aws_elb.main</span><br></pre></td></tr></table></figure>
<h2 id="1-7-18-1-1-3-例子：根据资源地址过滤"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%A0%B9%E6%8D%AE%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80%E8%BF%87%E6%BB%A4"></a>1.7.18.1.1.3. 例子：根据资源地址过滤</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state list aws_instance.bar</span><br><span class="line">aws_instance.bar[0]</span><br><span class="line">aws_instance.bar[1]</span><br></pre></td></tr></table></figure>
<h2 id="1-7-18-1-1-4-例子：根据模块过滤"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%A0%B9%E6%8D%AE%E6%A8%A1%E5%9D%97%E8%BF%87%E6%BB%A4"></a>1.7.18.1.1.4. 例子：根据模块过滤</h2>
<p>该例子列出给定模块及其子模块的所有资源：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state list module.elb</span><br><span class="line">module.elb.aws_elb.main</span><br><span class="line">module.elb.module.secgroups.aws_security_group.sg</span><br></pre></td></tr></table></figure>
<h2 id="1-7-18-1-1-5-例子：根据ID过滤"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%A0%B9%E6%8D%AEid%E8%BF%87%E6%BB%A4"></a>1.7.18.1.1.5. 例子：根据ID过滤</h2>
<p>此示例将仅列出在命令行中指定 ID 的资源，查找特定资源在代码中的位置时非常有用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state list -<span class="built_in">id</span>=sg-1234abcd</span><br><span class="line">module.elb.aws_security_group.sg</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a href="#mv"><strong>1.7.18.2.1.</strong> mv</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.18.2.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E9%87%8D%E5%91%BD%E5%90%8D%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90"><strong>1.7.18.2.1.2.</strong> 例子：重命名一个资源</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%B0%86%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90%E7%A7%BB%E5%8A%A8%E8%BF%9B%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97"><strong>1.7.18.2.1.3.</strong> 例子：将一个资源移动进一个模块</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E7%A7%BB%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E8%BF%9B%E5%85%A5%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97"><strong>1.7.18.2.1.4.</strong> 例子：移动一个模块进入另一个模块</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E7%A7%BB%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%8A%B6%E6%80%81%E6%96%87%E4%BB%B6"><strong>1.7.18.2.1.5.</strong> 例子：移动一个模块到另一个状态文件</a></p>
</li>
<li>
<p><a href="#%E7%A7%BB%E5%8A%A8%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89-count-%E5%8F%82%E6%95%B0%E7%9A%84%E8%B5%84%E6%BA%90"><strong>1.7.18.2.1.6.</strong> 移动一个带有 count 参数的资源</a></p>
</li>
<li>
<p><a href="#%E7%A7%BB%E5%8A%A8%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89-foreach-%E5%8F%82%E6%95%B0%E7%9A%84%E8%B5%84%E6%BA%90"><strong>1.7.18.2.1.7.</strong> 移动一个带有 for_each 参数的资源</a></p>
</li>
</ul>
<p><a href="#mv"></a></p>
<h2 id="1-7-18-2-1-mv"><a href="#mv"></a>1.7.18.2.1. mv</h2>
<p><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/2.%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html">Terraform 状态</a>的主要功能是记录下代码中的资源实例地址与其代表的远程对象之间的绑定。通常，Terraform 会自动更新状态以响应应用计划时采取的操作，例如删除已被删除的远程对象的绑定。</p>
<p>在修改了 <code>resource</code> 块名称，或是将资源移动到代码中的不同模块时，如果想保留现有的远程对象，可以使用 <code>terraform state mv</code> 命令。</p>
<h2 id="1-7-18-2-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.18.2.1.1. 用法</h2>
<p><code>terraform state mv [options] SOURCE DESTINATION</code></p>
<p>Terraform 将在当前状态中查找与给定地址匹配的资源实例、资源或模块，如果找到，则将原本由源地址跟踪的远程对象移动到目标地址下。</p>
<p>源地址和目标地址都必须使用<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/3.%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80.html">资源地址语法</a>，并且它们引用对象的类型必须相同：我们只能将一个资源实例移动到另一个资源实例，将整个模块实例移动到另一个整个模块实例，等等。此外，如果我们要移动资源或资源实例，则只能将其移动到具有相同资源类型的新地址。</p>
<p><code>terraform state mv</code> 最常见的用途是当我们在代码中重命名 <code>resource</code> 块，或是将 <code>resource</code> 块移动到子模块中时，这两种情况都是为了保留现有对象但以新地址跟踪它。默认情况下，Terraform 会将移动或重命名资源配置理解为删除旧对象并在新地址创建新对象的请求，因此 <code>terraform state mv</code> 允许我们已经存在的对象附加到Terraform 中的新地址上。</p>
<p>警告：如果我们在多人协作环境中使用 Terraform，则必须确保当我们使用 <code>terraform state mv</code> 进行代码重构时，我们与同事进行了仔细沟通，以确保没有人在我们的配置更改和 terraform 状态之间进行任何其他更改mv 命令，因为否则他们可能会无意中创建一个计划，该计划将销毁旧对象并在新地址创建新对象。</p>
<p>该命令提供以下可选参数：</p>
<ul>
<li><code>-dry-run</code>：报告与给定地址匹配的所有资源实例。</li>
<li><code>-lock=false</code>：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。</li>
<li><code>-lock-timeout=DURATION</code>：除非使用 <code>-lock=false</code> 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。</li>
</ul>
<p>以下是使用 <code>local</code> Backend 时可用的遗留参数：</p>
<ul>
<li><code>-backup=FILENAME</code>：指定源状态文件的备份地址，默认为源状态文件加上&quot;.backup&quot;后缀</li>
<li><code>-bakcup-out=FILENAME</code>：指定目标状态文件的备份地址，默认为目标状态文件加上&quot;.backup&quot;后缀</li>
<li><code>-state=FILENAME</code>：源状态文件地址，默认为当前 Backend 或是&quot;terraform.tfstate&quot;</li>
<li><code>-state-out=FILENAME</code>：目标状态文件地址。如果不指定则使用源状态文件。可以是一个已经存在的文件或新建一个文件</li>
</ul>
<h2 id="1-7-18-2-1-2-例子：重命名一个资源"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E9%87%8D%E5%91%BD%E5%90%8D%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90"></a>1.7.18.2.1.2. 例子：重命名一个资源</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">mv</span> <span class="string">&#x27;packet_device.worker&#x27;</span> <span class="string">&#x27;packet_device.helper&#x27;</span></span><br><span class="line">...</span><br><span class="line">-resource <span class="string">&quot;packet_device&quot;</span> <span class="string">&quot;worker&quot;</span> &#123;</span><br><span class="line">+resource <span class="string">&quot;packet_device&quot;</span> <span class="string">&quot;helper&quot;</span> &#123;</span><br><span class="line">   <span class="comment"># ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-7-18-2-1-3-例子：将一个资源移动进一个模块"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%B0%86%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90%E7%A7%BB%E5%8A%A8%E8%BF%9B%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97"></a>1.7.18.2.1.3. 例子：将一个资源移动进一个模块</h2>
<p>如果我们最初在根模块中编写了资源，但现在希望将其重构进子模块，则可以将 <code>resource</code> 块移动到子模块代码中，删除根模块中的原始资源，然后运行以下命令告诉 Terraform 将其视为一次移动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">mv</span> <span class="string">&#x27;packet_device.worker&#x27;</span> <span class="string">&#x27;module.app.packet_device.worker&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，新资源具有相同的名称，但模块地址不同。如果新的模块组织建议不同的命名方案，您还可以同时更改资源名称：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">mv</span> packet_device.worker module.worker.packet_device.main</span><br></pre></td></tr></table></figure>
<h2 id="1-7-18-2-1-4-例子：移动一个模块进入另一个模块"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E7%A7%BB%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E8%BF%9B%E5%85%A5%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97"></a>1.7.18.2.1.4. 例子：移动一个模块进入另一个模块</h2>
<p>我们还可以将整个模块重构为子模块。在配置中，将代表模块的 <code>module</code> 块移动到不同的模块中，然后使用如下命令将更改配对：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">mv</span> <span class="string">&#x27;module.app&#x27;</span> <span class="string">&#x27;module.parent.module.app&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-7-18-2-1-5-例子：移动一个模块到另一个状态文件"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E7%A7%BB%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%8A%B6%E6%80%81%E6%96%87%E4%BB%B6"></a>1.7.18.2.1.5. 例子：移动一个模块到另一个状态文件</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">mv</span> -state-out=other.tfstate <span class="string">&#x27;module.app&#x27;</span> <span class="string">&#x27;module.app&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-7-18-2-1-6-移动一个带有-count-参数的资源"><a href="#%E7%A7%BB%E5%8A%A8%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89-count-%E5%8F%82%E6%95%B0%E7%9A%84%E8%B5%84%E6%BA%90"></a>1.7.18.2.1.6. 移动一个带有 count 参数的资源</h2>
<p>使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#count"><code>count</code> 元参数</a>定义的资源具有多个实例，每个实例都由一个整数标识。我们可以通过在给定地址中包含显式索引来选择特定实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">mv</span> <span class="string">&#x27;packet_device.worker[0]&#x27;</span> <span class="string">&#x27;packet_device.helper[0]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>不使用 <code>count</code> 或 <code>for_each</code> 的资源只有一个资源实例，其地址与资源本身相同，因此我们可以从不包含索引的地址移动到包含索引的地址，或相反：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">mv</span> <span class="string">&#x27;packet_device.main&#x27;</span> <span class="string">&#x27;packet_device.all[0]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>方括号 (<code>[</code>, <code>]</code>) 在某些 shell 中具有特殊含义，因此您可能需要引用或转义地址，以便将其逐字传递给 Terraform。上面的示例显示了 Unix 风格 shell 的典型引用语法。</p>
<h2 id="1-7-18-2-1-7-移动一个带有-for-each-参数的资源"><a href="#%E7%A7%BB%E5%8A%A8%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89-foreach-%E5%8F%82%E6%95%B0%E7%9A%84%E8%B5%84%E6%BA%90"></a>1.7.18.2.1.7. 移动一个带有 for_each 参数的资源</h2>
<p>使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#for_each"><code>for_each</code> 元参数</a>定义的资源具有多个实例，每个实例都由一个字符串标识。我们可以通过在给定地址中包含显式的键来选择特定实例。</p>
<p>但是，字符串的语法包含引号，并且引号符号通常在命令 shell 中具有特殊含义，因此我们需要为正在使用的 shell 使用适当的引用和/或转义语法。例如：</p>
<p>Linux、MacOS 以及 Unix：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">mv</span> <span class="string">&#x27;packet_device.worker[&quot;example123&quot;]&#x27;</span> <span class="string">&#x27;packet_device.helper[&quot;example456&quot;]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>PowerShell：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> terraform state <span class="built_in">mv</span> <span class="string">&#x27;packet_device.worker[\&quot;example123\&quot;]&#x27;</span> <span class="string">&#x27;packet_device.helper[\&quot;example456\&quot;]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Windows 命令行（<code>cmd.exe</code>）：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state mv packet_device.worker[\&quot;example123\&quot;] packet_device.helper[\&quot;example456\&quot;]</span><br></pre></td></tr></table></figure>
<p>除了使用字符串而不是整数作为实例键之外，<code>for_each</code> 资源的处理与 <code>count</code> 资源类似，因此具有和不具有索引组件的相同地址组合都是有效的，如上一节所述。</p>
<ul>
<li>
<p><a href="#pull"><strong>1.7.18.3.1.</strong> pull</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.18.3.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#pull"></a></p>
<h2 id="1-7-18-3-1-pull"><a href="#pull"></a>1.7.18.3.1. pull</h2>
<p><code>terraform state pull</code> 命令可以从远程 Backend 中人工下载状态并输出。该命令也可搭配本地状态文件使用。</p>
<h2 id="1-7-18-3-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.18.3.1.1. 用法</h2>
<p><code>terraform state pull</code></p>
<p>该命令下载当前位置对应的状态文件，并以原始格式打印到标准输出流。</p>
<p>由于状态文件使用 JSON 格式，该功能可以搭配例如 <a target="_blank" rel="noopener" href="https://stedolan.github.io/jq/">jq</a> 这样的命令行工具使用，也可以用来人工修改状态文件。</p>
<p>注意：Terraform 状态文件必须采用 UTF-8 格式，不带字节顺序标记 (BOM)。对于 Windows 上的 PowerShell，使用 Set-Content 自动以 UTF-8 格式对文件进行编码。例如，运行 <code>terraform state pull</code> | <code>sc terraform.tfstate</code></p>
<h2 id="push"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">push</a></h2>
<ul>
<li>
<p><a href="#push"><strong>1.7.18.4.1.</strong> push</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.18.4.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#push"></a></p>
<h2 id="1-7-18-4-1-push"><a href="#push"></a>1.7.18.4.1. push</h2>
<p><code>terraform push</code> 命令被用来手动上传本地状态文件到远程 Backend。该命令也可以被用在当前使用的本地状态文件上。</p>
<p>该命令应该很少使用。它时一种需要对远程状态进行手动干预的情况下使用的工具。</p>
<h2 id="1-7-18-4-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.18.4.1.1. 用法</h2>
<p><code>terraform state push [options] PATH</code></p>
<p>该命令会把 PATH 位置的状态文件推送到当前使用的 Backend 上(可以是当前使用的 terraform.tfstate 文件)。</p>
<p>如果 PATH 为 <code>-</code>，则从标准输入流读取要推送的状态数据。该数据在写入目标状态之前被完全加载到内存中并进行验证。</p>
<p>注意：Terraform 状态文件必须采用 UTF-8 格式，不带字节顺序标记 (BOM)。对于 Windows 上的 PowerShell，使用 Set-Content 自动以 UTF-8 格式对文件进行编码。例如，运行 <code>terraform state push | sc terraform.tfstate</code>。</p>
<p>Terraform 会进行一系列检查以防止你进行一些不安全的变更：</p>
<ul>
<li>检查 lineage：如果两个状态文件的 lineage 值不同，Terraform 会禁止推送。一个不同的 lineage 说明两个状态文件描述的是完全不同的基础设而你可能会因此丢失重要数据</li>
<li>序列号检查：如果目标状态文件的 serial 值大于你要推送的状态的 serial 值，Terraform 会禁止推送。一个更高的 serial 值说明目标状态文件已经无法与要推送的状态文件对应上了</li>
</ul>
<p>这两种检查都可以通过添加 <code>-force</code> 参数禁用，但<strong>不推荐这样做</strong>。如果禁用安全检查直接推送，那么目标状态文件将被覆盖。</p>
<h2 id="replace-provider"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">replace-provider</a></h2>
<ul>
<li>
<p><a href="#replace-provider"><strong>1.7.18.5.1.</strong> replace-provider</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.18.5.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E6%A0%B7%E4%BE%8B"><strong>1.7.18.5.1.2.</strong> 样例</a></p>
</li>
</ul>
<p><a href="#replace-provider"></a></p>
<h2 id="1-7-18-5-1-replace-provider"><a href="#replace-provider"></a>1.7.18.5.1. replace-provider</h2>
<p><code>terraform state replace-provider</code> 命令可以替换<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/2.%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html">状态文件</a>中资源对象所使用的 Provider.</p>
<h2 id="1-7-18-5-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.18.5.1.1. 用法</h2>
<p><code>terraform state replace-provider [options] FROM_PROVIDER_FQN TO_PROVIDER_FQN</code></p>
<p>该命令会更新所有使用 from 的 Provider 的资源，将它们使用的 Provider 更新为 to Provider。这让我们可以更新状态文件中资源所使用的 Provider 的源。</p>
<p>该命令在进行任意修改之前会先生成一个备份文件。备份机制不可关闭。</p>
<p>支持以下可选参数：</p>
<ul>
<li><code>-auto-approve</code>：跳过交互式提示确认环节</li>
<li><code>-lock=false</code>：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。</li>
<li><code>-lock-timeout=0s</code>：除非使用 <code>-lock=false</code> 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。</li>
</ul>
<p>以下是使用 <code>local</code> Backend 时可用的遗留参数：</p>
<ul>
<li><code>-backup=FILENAME</code>：指定源状态文件的备份地址，默认为源状态文件加上&quot;.backup&quot;后缀</li>
<li><code>-bakcup-out=FILENAME</code>：指定目标状态文件的备份地址，默认为目标状态文件加上&quot;.backup&quot;后缀</li>
<li><code>-state=FILENAME</code>：源状态文件地址，默认为当前 Backend 或是&quot;terraform.tfstate&quot;</li>
<li><code>-state-out=FILENAME</code>：目标状态文件地址。如果不指定则使用源状态文件。可以是一个已经存在的文件或新建一个文件</li>
</ul>
<h2 id="1-7-18-5-1-2-样例"><a href="#%E6%A0%B7%E4%BE%8B"></a>1.7.18.5.1.2. 样例</h2>
<p>下面的示例将 <code>hashicorp/aws</code> Provider 程序替换为 <code>acme</code> 的复刻版本，该 Provider 托管在 <code>registry.acme.corp</code> 的私有注册表中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state replace-provider hashicorp/aws registry.acme.corp/acme/aws</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a href="#rm"><strong>1.7.18.6.1.</strong> rm</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.18.6.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90"><strong>1.7.18.6.1.1.1.</strong> 删除一个资源</a></p>
</li>
<li>
<p><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97"><strong>1.7.18.6.1.1.2.</strong> 删除一个模块</a></p>
</li>
<li>
<p><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%86%85%E8%B5%84%E6%BA%90"><strong>1.7.18.6.1.1.3.</strong> 删除一个模块内资源</a></p>
</li>
<li>
<p><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%A3%B0%E6%98%8Ecount%E7%9A%84%E8%B5%84%E6%BA%90"><strong>1.7.18.6.1.1.4.</strong> 删除一个声明count的资源</a></p>
</li>
<li>
<p><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%A3%B0%E6%98%8Eforeach%E7%9A%84%E8%B5%84%E6%BA%90"><strong>1.7.18.6.1.1.5.</strong> 删除一个声明for_each的资源</a></p>
</li>
</ul>
<p><a href="#rm"></a></p>
<h2 id="1-7-18-6-1-rm"><a href="#rm"></a>1.7.18.6.1. rm</h2>
<p><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/2.%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html">Terraform 状态</a>的主要功能是记录下代码中的资源实例地址与其代表的远程对象之间的绑定。通常，Terraform 会自动更新状态以响应应用计划时采取的操作，例如删除已被删除的远程对象的绑定。</p>
<p><code>terraform state rm</code> 命令可以用来从状态文件中删除对象和实际远程对象的绑定，该命令只是删除绑定，不会删除实际存在的远程对象，删除后 Terraform 会“忘记”这个对象的存在。</p>
<p>注意：从 Terraform v1.7.0 开始支持 <code>removed</code> 块。与 <code>terraform state rm</code> 命令不同，您可以使用 <code>removed</code> 块一次删除多个资源，并且您可以将删除操作作为正常计划和执行工作流程的一部分进行审查。了解有关将 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#%E5%88%A0%E9%99%A4%E8%B5%84%E6%BA%90"><code>removed</code> 块与资源一起使用</a>以及将 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/4.%E9%87%8D%E6%9E%84.html#%E5%88%A0%E9%99%A4%E6%A8%A1%E5%9D%97"><code>removed</code> 块与模块一起使用</a>的更多信息。</p>
<h2 id="1-7-18-6-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.18.6.1.1. 用法</h2>
<p><code>terraform state rm [options] ADDRESS...</code></p>
<p>Terraform 将在状态中搜索与给定<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/3.%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80.html">资源地址</a>匹配的任何实例，并删除所有实例对应的记录，以便 Terraform 将不再跟踪相应的远程对象。</p>
<p>这意味着尽管这些对象仍将继续存在于远程系统中，但后续的 <code>terraform plan</code> 会尝试新建这些被“遗忘”的实例。根据远程系统施加的约束，如果这些对象的名称或其他标识符与仍然存在的旧对象发生冲突，创建这些对象可能会失败。</p>
<p>可以使用如下可选参数：</p>
<ul>
<li><code>-dry-run</code>：报告与给定地址匹配的所有资源实例（由于此时并未执行删除，所以 Terraform 这时还不会“遗忘”任何资源）。</li>
<li><code>-lock=false</code>：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。</li>
<li><code>-lock-timeout=DURATION</code>：除非使用 <code>-lock=false</code> 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。</li>
</ul>
<p>以下是使用 <code>local</code> Backend 时可用的遗留参数：</p>
<ul>
<li><code>-backup=FILENAME</code>：指定源状态文件的备份地址，默认为源状态文件加上&quot;.backup&quot;后缀</li>
<li><code>-bakcup-out=FILENAME</code>：指定目标状态文件的备份地址，默认为目标状态文件加上&quot;.backup&quot;后缀</li>
<li><code>-state=FILENAME</code>：源状态文件地址，默认为当前 Backend 或是&quot;terraform.tfstate&quot;</li>
<li><code>-state-out=FILENAME</code>：目标状态文件地址。如果不指定则使用源状态文件。可以是一个已经存在的文件或新建一个文件</li>
</ul>
<h3 id="1-7-18-6-1-1-1-删除一个资源"><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90"></a>1.7.18.6.1.1.1. 删除一个资源</h3>
<p>下面的例子演示了如何让 Terraform “遗忘”所有类型为 <code>packet_device</code>，并且名为 <code>worker</code> 的资源实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">rm</span> <span class="string">&#x27;packet_device.worker&#x27;</span></span><br></pre></td></tr></table></figure>
<p>不使用 <code>count</code> 或 <code>for_each</code> 的资源只有一个实例，因此该示例也是选择该单个实例的正确语法。</p>
<h3 id="1-7-18-6-1-1-2-删除一个模块"><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97"></a>1.7.18.6.1.1.2. 删除一个模块</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">rm</span> <span class="string">&#x27;module.foo&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-7-18-6-1-1-3-删除一个模块内资源"><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%86%85%E8%B5%84%E6%BA%90"></a>1.7.18.6.1.1.3. 删除一个模块内资源</h3>
<p>要选择在子模块中定义的资源，我们必须指定该模块的路径作为资源地址的一部分：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">rm</span> <span class="string">&#x27;module.foo.packet_device.worker&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-7-18-6-1-1-4-删除一个声明count的资源"><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%A3%B0%E6%98%8Ecount%E7%9A%84%E8%B5%84%E6%BA%90"></a>1.7.18.6.1.1.4. 删除一个声明count的资源</h3>
<p>使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#count"><code>count</code> 元参数</a>定义的资源具有多个实例，每个实例都由一个整数标识。我们可以通过在给定地址中包含显式索引来选择特定实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">rm</span> <span class="string">&#x27;packet_device.worker[0]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>方括号 (<code>[</code>, <code>]</code>) 在某些 shell 中具有特殊含义，因此我们可能需要引用或转义地址，以便将其逐字传递给 Terraform。上面的例子使用了 Unix 风格 shell 的典型引用语法。</p>
<h3 id="1-7-18-6-1-1-5-删除一个声明for-each的资源"><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%A3%B0%E6%98%8Eforeach%E7%9A%84%E8%B5%84%E6%BA%90"></a>1.7.18.6.1.1.5. 删除一个声明for_each的资源</h3>
<p>使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#for_each"><code>for_each</code> 元参数</a>定义的资源具有多个实例，每个实例都由一个字符串标识。我们可以通过在给定地址中包含显式密钥来选择特定实例。</p>
<p>但是，字符串的语法包含引号，并且引号符号通常在命令 shell 中具有特殊含义，因此我们需要为我们正在使用的 shell 使用适当的引用和/或转义语法。例如：</p>
<p>Linux, MacOS, and Unix：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">rm</span> <span class="string">&#x27;packet_device.worker[&quot;example&quot;]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>PowerShell：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> terraform state <span class="built_in">rm</span> <span class="string">&#x27;packet_device.worker[\&quot;example\&quot;]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Windows命令行（<code>cmd.exe</code>）：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state rm packet_device.worker[\&quot;example\&quot;]</span><br></pre></td></tr></table></figure>
<h2 id="show-2"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">show</a></h2>
<ul>
<li>
<p><a href="#show"><strong>1.7.18.7.1.</strong> show</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.18.7.1.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E5%B1%95%E7%A4%BA%E5%8D%95%E4%B8%AA%E8%B5%84%E6%BA%90"><strong>1.7.18.7.1.1.2.</strong> 展示单个资源</a></p>
</li>
<li>
<p><a href="#%E5%B1%95%E7%A4%BA%E5%8D%95%E4%B8%AA%E6%A8%A1%E5%9D%97%E8%B5%84%E6%BA%90"><strong>1.7.18.7.1.1.3.</strong> 展示单个模块资源</a></p>
</li>
<li>
<p><a href="#%E5%B1%95%E7%A4%BA%E5%A3%B0%E6%98%8Ecount%E8%B5%84%E6%BA%90%E4%B8%AD%E7%89%B9%E5%AE%9A%E5%AE%9E%E4%BE%8B"><strong>1.7.18.7.1.1.4.</strong> 展示声明count资源中特定实例</a></p>
</li>
<li>
<p><a href="#%E5%B1%95%E7%A4%BA%E5%A3%B0%E6%98%8Eforeach%E8%B5%84%E6%BA%90%E4%B8%AD%E7%89%B9%E5%AE%9A%E5%AE%9E%E4%BE%8B"><strong>1.7.18.7.1.1.5.</strong> 展示声明for_each资源中特定实例</a></p>
</li>
</ul>
<p><a href="#show"></a></p>
<h2 id="1-7-18-7-1-show"><a href="#show"></a>1.7.18.7.1. show</h2>
<p><code>terraform state show</code> 命令可以展示状态文件中单个资源的属性。</p>
<h3 id="1-7-18-7-1-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.18.7.1.1.1. 用法</h3>
<p><code>terraform state show [options] ADDRESS</code></p>
<p>该命令需要指定一个资源地址。资源地址需要遵循<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/3.%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80.html">资源地址格式</a>。</p>
<p>该命令支持以下可选参数：</p>
<ul>
<li><code>-state=path</code>：指向状态文件的路径。默认情况下是 <code>terraform.tfstate</code>。如果启用了远程 Backend 则该参数设置无效</li>
</ul>
<p><code>terraform state show</code> 的输出被设计成人类可读而非机器可读。如果想要从输出中提取数据，请使用 <code>terraform show -json</code>。</p>
<h3 id="1-7-18-7-1-1-2-展示单个资源"><a href="#%E5%B1%95%E7%A4%BA%E5%8D%95%E4%B8%AA%E8%B5%84%E6%BA%90"></a>1.7.18.7.1.1.2. 展示单个资源</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state show <span class="string">&#x27;packet_device.worker&#x27;</span></span><br><span class="line"><span class="comment"># packet_device.worker:</span></span><br><span class="line">resource <span class="string">&quot;packet_device&quot;</span> <span class="string">&quot;worker&quot;</span> &#123;</span><br><span class="line">    billing_cycle = <span class="string">&quot;hourly&quot;</span></span><br><span class="line">    created       = <span class="string">&quot;2015-12-17T00:06:56Z&quot;</span></span><br><span class="line">    facility      = <span class="string">&quot;ewr1&quot;</span></span><br><span class="line">    hostname      = <span class="string">&quot;prod-xyz01&quot;</span></span><br><span class="line">    <span class="built_in">id</span>            = <span class="string">&quot;6015bg2b-b8c4-4925-aad2-f0671d5d3b13&quot;</span></span><br><span class="line">    locked        = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-7-18-7-1-1-3-展示单个模块资源"><a href="#%E5%B1%95%E7%A4%BA%E5%8D%95%E4%B8%AA%E6%A8%A1%E5%9D%97%E8%B5%84%E6%BA%90"></a>1.7.18.7.1.1.3. 展示单个模块资源</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state show <span class="string">&#x27;module.foo.packet_device.worker&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-7-18-7-1-1-4-展示声明count资源中特定实例"><a href="#%E5%B1%95%E7%A4%BA%E5%A3%B0%E6%98%8Ecount%E8%B5%84%E6%BA%90%E4%B8%AD%E7%89%B9%E5%AE%9A%E5%AE%9E%E4%BE%8B"></a>1.7.18.7.1.1.4. 展示声明count资源中特定实例</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state show <span class="string">&#x27;packet_device.worker[0]&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-7-18-7-1-1-5-展示声明for-each资源中特定实例"><a href="#%E5%B1%95%E7%A4%BA%E5%A3%B0%E6%98%8Eforeach%E8%B5%84%E6%BA%90%E4%B8%AD%E7%89%B9%E5%AE%9A%E5%AE%9E%E4%BE%8B"></a>1.7.18.7.1.1.5. 展示声明for_each资源中特定实例</h3>
<p>Linux, MacOS, and Unix：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state show <span class="string">&#x27;packet_device.worker[&quot;example&quot;]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>PowerShell：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> terraform state show <span class="string">&#x27;packet_device.worker[\&quot;example\&quot;]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Windows命令行：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state show packet_device.worker[\&quot;example\&quot;]</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a href="#taint"><strong>1.7.19.1.</strong> taint</a></p>
</li>
<li>
<p><a href="#%E6%8E%A8%E8%8D%90%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%B3%95"><strong>1.7.19.1.1.</strong> 推荐的替代方法</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.19.1.2.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E6%A0%87%E8%AE%B0%E5%8D%95%E4%B8%AA%E8%B5%84%E6%BA%90"><strong>1.7.19.1.3.</strong> 标记单个资源</a></p>
</li>
<li>
<p><a href="#%E6%A0%87%E8%AE%B0%E4%BD%BF%E7%94%A8foreach%E5%88%9B%E5%BB%BA%E7%9A%84%E8%B5%84%E6%BA%90%E7%9A%84%E7%89%B9%E5%AE%9A%E5%AE%9E%E4%BE%8B"><strong>1.7.19.1.4.</strong> 标记使用for_each创建的资源的特定实例</a></p>
</li>
<li>
<p><a href="#%E6%A0%87%E8%AE%B0%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90"><strong>1.7.19.1.5.</strong> 标记模块中的资源</a></p>
</li>
</ul>
<p><a href="#taint"></a></p>
<h2 id="1-7-19-1-taint"><a href="#taint"></a>1.7.19.1. taint</h2>
<p><code>terrform taint</code> 命令可以手动标记某个Terraform管理的资源有&quot;污点&quot;，强迫在下一次执行apply时删除并重建之。</p>
<p>该命令并不会修改基础设施，而是在状态文件中的某个资源对象上标记污点。当一个资源对象被标记了污点，在下一次 <code>plan</code> 操作时会计划将之删除并且重建，<code>apply</code> 操作会执行这个变更。</p>
<p>强迫重建某个资源可以使你能够触发某种副作用。举例来说，你想重新执行某个预置器操作，或是某些人绕过 Terraform 修改了虚拟机状态，而你想将虚拟机重置。</p>
<p>注意为某个资源标记污点并重建之会影响到所有依赖该资源的对象。举例来说，一条 DNS 记录使用了服务器的 IP 地址，我们在服务器上标记污点会导致 IP 发生变化从而影响到 DNS 记录。这种情况下可以使用 <code>plan</code> 命令查看变更计划。</p>
<p>警告：此命令已被弃用。从 Terraform v0.15.2 开始，我们建议使用 <code>-replace</code> 选项和 <code>terraform apply</code> 代替（详细信息如下）。</p>
<h2 id="1-7-19-1-1-推荐的替代方法"><a href="#%E6%8E%A8%E8%8D%90%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%B3%95"></a>1.7.19.1.1. 推荐的替代方法</h2>
<p>从 Terraform v0.15.2 开始，我们建议使用 <code>terraform apply</code> 的 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/14.plan.html#plan-%E9%80%89%E9%A1%B9"><code>-replace</code> 选项</a>来强制 Terraform 替换对象，即使没有发生需要变更的配置更改。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply -replace=<span class="string">&quot;aws_instance.example[0]&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们推荐使用 <code>-replace</code> 参数，因为这可以在 Terraform 计划中显示将要发生的变更，让我们在采取任何会影响系统的操作之前了解计划将如何影响我们的基础设施。当我们使用 <code>terraform taint</code> 时，其他用户有可能可以在我们审查变更之前针对标记的对象创建新的变更计划。</p>
<h2 id="1-7-19-1-2-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.19.1.2. 用法</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform taint [options] &lt;address&gt;</span><br></pre></td></tr></table></figure>
<p><code>address</code> 参数是要标记污点的资源地址。该地址格式遵循<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/3.%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80.html">资源地址语法</a>，例如：</p>
<ul>
<li><code>aws_instance.foo</code></li>
<li><code>aws_instance.bar[1]</code></li>
<li><code>aws_instance.baz[\&quot;key\&quot;]</code> （资源地址中的引号必须在命令行中转义，这样它们就不会被 shell 解释）</li>
<li><code>module.foo.module.bar.aws_instance.qux</code></li>
</ul>
<p>该命令可以使用如下可选参数：</p>
<ul>
<li><code>-allow-missing</code>：如果声明该参数，那么即使资源不存在，命令也会返回成功(状态码0)。对于其他异常情况，该命令可能仍会返回错误，例如读取或写入状态时出现问题。</li>
<li><code>-lock=false</code>：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。</li>
<li><code>-lock-timeout=DURATION</code>：除非使用 <code>-lock=false</code> 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。</li>
</ul>
<p>以下是使用 <code>local</code> Backend 时可用的遗留参数：</p>
<ul>
<li><code>-backup=FILENAME</code>：指定源状态文件的备份地址，默认为源状态文件加上&quot;.backup&quot;后缀</li>
<li><code>-bakcup-out=FILENAME</code>：指定目标状态文件的备份地址，默认为目标状态文件加上&quot;.backup&quot;后缀</li>
<li><code>-state=FILENAME</code>：源状态文件地址，默认为当前 Backend 或是&quot;terraform.tfstate&quot;</li>
<li><code>-state-out=FILENAME</code>：目标状态文件地址。如果不指定则使用源状态文件。可以是一个已经存在的文件或新建一个文件</li>
</ul>
<h2 id="1-7-19-1-3-标记单个资源"><a href="#%E6%A0%87%E8%AE%B0%E5%8D%95%E4%B8%AA%E8%B5%84%E6%BA%90"></a>1.7.19.1.3. 标记单个资源</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform taint aws_security_group.allow_all</span><br><span class="line">The resource aws_security_group.allow_all <span class="keyword">in</span> the module root has been marked as tainted.</span><br></pre></td></tr></table></figure>
<h2 id="1-7-19-1-4-标记使用for-each创建的资源的特定实例"><a href="#%E6%A0%87%E8%AE%B0%E4%BD%BF%E7%94%A8foreach%E5%88%9B%E5%BB%BA%E7%9A%84%E8%B5%84%E6%BA%90%E7%9A%84%E7%89%B9%E5%AE%9A%E5%AE%9E%E4%BE%8B"></a>1.7.19.1.4. 标记使用for_each创建的资源的特定实例</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform taint <span class="string">&quot;module.route_tables.azurerm_route_table.rt[\&quot;DefaultSubnet\&quot;]&quot;</span></span><br><span class="line">The resource module.route_tables.azurerm_route_table.rt[<span class="string">&quot;DefaultSubnet&quot;</span>] <span class="keyword">in</span> the module root has been marked as tainted.</span><br></pre></td></tr></table></figure>
<h2 id="1-7-19-1-5-标记模块中的资源"><a href="#%E6%A0%87%E8%AE%B0%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90"></a>1.7.19.1.5. 标记模块中的资源</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform taint <span class="string">&quot;module.couchbase.aws_instance.cb_node[9]&quot;</span></span><br><span class="line">Resource instance module.couchbase.aws_instance.cb_node[9] has been marked as tainted.</span><br></pre></td></tr></table></figure>
<p>虽然我们推荐模块深度不要超过1，但是我们仍然可以标记多层模块中的资源：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform taint <span class="string">&quot;module.child.module.grandchild.aws_instance.example[2]&quot;</span></span><br><span class="line">Resource instance module.child.module.grandchild.aws_instance.example[2] has been marked as tainted.</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a href="#validate"><strong>1.7.20.1.</strong> validate</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.20.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#json-%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><strong>1.7.20.1.2.</strong> JSON 输出格式</a></p>
</li>
<li>
<p><a href="#%E6%BA%90%E4%BD%8D%E7%BD%AE%EF%BC%88source-position%EF%BC%89"><strong>1.7.20.1.2.1.</strong> 源位置（Source Position）</a></p>
</li>
<li>
<p><a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%80%BC"><strong>1.7.20.1.2.2.</strong> 表达式值</a></p>
</li>
</ul>
<p><a href="#validate"></a></p>
<h2 id="1-7-20-1-validate"><a href="#validate"></a>1.7.20.1. validate</h2>
<p><code>terraform validate</code> 命令可以检查目录下 Terraform 代码，只检查语法文件，不会访问诸如远程 Backend、Provider 的 API 等远程资源。</p>
<p><code>validate</code> 检查代码的语法是否合法以及一致，不管输入变量以及现存状态。</p>
<p>自动运行此命令是安全的，例如作为文本编辑器中的保存后检查或作为 CI 系统中可复用的测试步骤。</p>
<p><code>validate</code> 命令需要已初始化的工作目录，所有引用的插件与模块都被安装完毕。如果只想检查语法而不想与 Backend 交互，可以这样初始化工作目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform init -backend=<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>要验证特定运行上下文中的配置（特定目标工作空间、输入变量值等），请改用 <code>terraform plan</code> 命令，其中包括隐式验证检查。</p>
<h2 id="1-7-20-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.20.1.1. 用法</h2>
<p><code>terraform validate [options]</code></p>
<p>默认情况下 <code>validate</code> 命令不需要任何参数就可以在当前工作目录下进行检查。</p>
<p>可以使用如下可选参数：</p>
<ul>
<li>-json：使用 JSON 格式输出机器可读的结果</li>
<li>-no-color：禁止使用彩色输出</li>
</ul>
<h2 id="1-7-20-1-2-JSON-输出格式"><a href="#json-%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"></a>1.7.20.1.2. JSON 输出格式</h2>
<p>当您使用 <code>-json</code> 选项时，Terraform 将生成 JSON 格式的验证结果，使得我们可以将之与验证结果的工具进行集成，例如在文本编辑器中突出显示错误。</p>
<p>与所有 JSON 输出选项一样，Terraform 在开始验证任务之前就可能会遇到错误，因此输出的错误可能不会是 JSON 格式的。因此，使用 Terraform 输出的外部软件应该准备好在 stdout 上读取到非有效 JSON 的数据，然后将其视为一般错误情况。</p>
<p>输出包含一个 <code>format_version</code> 键，从 Terraform 1.1.0 开始，其值为“1.0”。该版本的语义是：</p>
<ul>
<li>对于向后兼容的变更或新增字段，我们将增加 minor 版本号，例如 <code>&quot;1.1&quot;</code>。这种变更会忽略所有不认识的对象属性，以保持与未来其他 minor 版本的前向兼容。</li>
<li>对于不向后兼容的变更，我们将增加 major 版本，例如 <code>&quot;2.0&quot;</code>。不同的 major 版本之间的数据无法直接传递。</li>
</ul>
<p>我们只会在 <a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/v1-compatibility-promises">Terraform 1.0 兼容性承诺</a>的范围内更新 major 版本。</p>
<p>在正常情况下，Terraform 会将 JSON 对象打印到标准输出流。顶级 JSON 对象将具有以下属性：</p>
<ul>
<li><code>valid</code>（bool）：总体验证结果结论，如果 Terraform 认为当前配置有效，则为 <code>true</code>；如果检测到任何错误，则为 <code>false</code>。</li>
<li><code>error_count</code>（number）：零或正整数，给出 Terraform 检测到的错误计数。如果 <code>valid</code> 为 <code>true</code>，则 <code>error_count</code> 将始终为零，因为错误的存在表明配置无效。</li>
<li><code>warning_count</code>（number）：零或正整数，给出 Terraform 检测到的警告计数。警告不会导致 Terraform 认为配置无效，但用户应考虑并尝试解决它们。</li>
<li><code>diagnostics</code>（对象数组）：嵌套对象的 JSON 数组，每个对象描述来自 Terraform 的错误或警告。</li>
</ul>
<p><code>diagnostics</code> 中的对象拥有如下属性：</p>
<ul>
<li><code>severity</code>（string）：字符串关键字，可以是 <code>&quot;error&quot;</code> 或 <code>&quot;warning&quot;</code>，指示诊断严重性。 <code>error</code> 的存在会导致 Terraform 认为配置无效，而 <code>warning</code> 只是对用户的建议或警告，不会阻止代码运行。Terraform 的后续版本可能会引入新的严重性等级，因此解析错误信息时应该准备好接受并忽略他们不了解的 <code>severity</code> 值。</li>
<li><code>summary</code>（string）：诊断报告的问题性质的简短描述。</li>
</ul>
<p>在 Terraform 易于阅读的的诊断消息中，<code>summary</code> 充当诊断的一种“标题”，打印在 “Error:” 或 “Warning:” 指示符之后。</p>
<p>摘要通常是简短的单个句子，但如果返回错误的子系统并没有设计成返回全面的诊断信息时，就只能把整个错误信息作为摘要返回，导致较长的摘要。这种情况下，摘要可能包含换行符，渲染摘要信息时需要注意。</p>
<ul>
<li><code>detail</code>（string）：可选的附加消息，提供有关问题的更多详细信息。</li>
</ul>
<p>在 Terraform 易于阅读的的诊断消息中，详细信息提供了标题和源位置引用之后出现的文本段落。</p>
<p>详细消息通常是多个段落，并且可能散布有非段落行，因此旨在向用户呈现详细消息的工具应该区分没有前导空格的行，将它们视为段落，以及有前导空格的行，将它们视为预格式化文本。然后，渲染器应该对段落进行软换行以适合渲染容器的宽度，但保留预格式化的行不换行。</p>
<p>一些 Terraform 详细消息包含使用 ASCII 字符来标记项目符号的近似项目符号列表。这不是官方承诺，因此渲染器应避免依赖它，而应将这些行视为段落或预格式化文本。此格式的未来版本可能会为其他文本约定定义附加规则，但将保持向后兼容性。</p>
<ul>
<li><code>range</code>（对象）：引用与诊断消息相关的配置源代码的一部分的可选对象。对于错误，这通常指示被检测为无效的特定块头、属性或表达式的边界。</li>
</ul>
<p>源范围是一个具有 <code>filename</code> 属性的对象，该 <code>filename</code> 为当前工作目录的相对路径，然后两个属性 <code>start</code> 和 <code>end</code> 本身都是描述源位置的对象，如下所述。</p>
<p>并非所有诊断消息都与配置的特定部分相关，因此对于不相关的诊断消息，<code>range</code> 将被省略或为 <code>null</code>。</p>
<p><code>snippet</code>（对象）：可选对象，包括与诊断消息相关的配置源代码的摘录。</p>
<p><code>snippet</code> 信息包括了：</p>
<ul>
<li><code>context</code>（string）：诊断的根上下文的可选摘要。例如，这可能是包含触发诊断的表达式的 <code>resource</code> 块。对于某些诊断，此信息不可用，并且此属性将为空。</li>
<li><code>code</code>（string）：Terraform 配置的片段，包括诊断源。可能包含多行，并且可能包括触发诊断的表达式周围的附加配置源代码。</li>
<li><code>start_line</code>（number）：从一开始的行计数，表示源文件中代码摘录开始的位置。该值不一定与 <code>range.start.line</code> 相同，因为 <code>code</code> 可能在诊断源之前包含一行或多行上下文。</li>
<li><code>highlight_start_offset</code>（number）：代码字符串中从零开始的字符偏移量，指向触发诊断的表达式的开头。</li>
<li><code>highlight_end_offset</code>（number）：代码字符串中从零开始的字符偏移量，指向触发诊断的表达式的末尾。</li>
<li><code>values</code>（对象数组）：包含零个或多个表达式值，帮助我们理解复杂表达式中的诊断来源。这些表达式值对象如下所述。</li>
</ul>
<h3 id="1-7-20-1-2-1-源位置（Source-Position）"><a href="#%E6%BA%90%E4%BD%8D%E7%BD%AE%EF%BC%88source-position%EF%BC%89"></a>1.7.20.1.2.1. 源位置（Source Position）</h3>
<p>在诊断对象的 <code>range</code> 属性中源位置对象具有以下属性：</p>
<ul>
<li><code>byte</code>（number）：指定文件中从零开始的字节偏移量。</li>
<li><code>line</code>（number）：从一开始的行计数，指向文件中相关位置的行。</li>
<li><code>column</code>（number）：从一开始的列计数，指向 <code>line</code> 对应的行开头开始的 Unicode 字符计数位置。 <code>start</code> 位置是包含的（数学的 <code>[]</code>），而 <code>end</code> 位置是不包含的（数学的 <code>()</code>）。用于特定错误消息的确切位置仅供人类解读。</li>
</ul>
<h3 id="1-7-20-1-2-2-表达式值"><a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%80%BC"></a>1.7.20.1.2.2. 表达式值</h3>
<p>表达式值对象提供有关触发诊断的表达式一部分的值的附加信息。当使用 <code>for_each</code> 或类似结构时，这特别有用，以便准确识别哪些值导致错误。该对象有两个属性：</p>
<ul>
<li>
<p><code>traversal</code> (string)：类似 HCL 的可遍历表达式字符串，例如 <code>var.instance_count</code>。复杂的索引键值可能会被省略，因此该属性并非总是合法、可解析的 HCL。该字符串的内容旨在便于人类阅读。</p>
</li>
<li>
<p><code>statement</code>（string）：一个简短的英语片段，描述触发诊断时表达式的值。该字符串的内容旨在便于人类阅读，并且在 Terraform 的未来版本中可能会发生变化。</p>
</li>
<li>
<p><a href="#untaint"><strong>1.7.21.1.</strong> untaint</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.21.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#untaint"></a></p>
<h2 id="1-7-21-1-untaint"><a href="#untaint"></a>1.7.21.1. untaint</h2>
<p>Terraform 有一个名为“tainted”的标记，用于跟踪可能损坏的对象，该命令已被废弃，应使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/19.taint.html#%E6%8E%A8%E8%8D%90%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%B3%95"><code>terraform apply -replace</code> 代替</a>。</p>
<p>如果创建一个资源的操作由多个步骤组成，操作期间其中之一的操作发生错误，Terraform 会自动将对象标记为“受污染”，因为 Terraform 无法确定该对象是否处于完整功能状态。</p>
<p><code>terraform untaint</code> 命令可以手动清除一个 Terraform 管理的资源对象上的污点，恢复它在状态文件中的状态。它是 <code>terraform taint</code> 的逆向操作。</p>
<p>该命令不会修改实际的基础设施资源，只会在资源文件中清除资源对象上的污点标记。</p>
<p>如果我们从对象中删除污点标记，但后来发现它还是损坏了，则可以使用如下命令创建并应用一个计划来替换受损的资源对象，而无需首先重新在该对象上标记污点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply -replace=<span class="string">&quot;aws_instance.example[0]&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-7-21-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.21.1.1. 用法</h2>
<p><code>terraform untaint [options] address</code></p>
<p>name参数是要清除污点的资源的资源名称。<a target="_blank" rel="noopener" href="http://xn--TYPE-uh5f160avsuivle8ft43b9e3c.NAME">该参数的格式为TYPE.NAME</a>，比如aws_instance.foo。</p>
<p>可以使用如下可选参数：</p>
<ul>
<li><code>-allow-missing</code>：如果声明该参数，那么即使资源不存在，命令也会返回成功(状态码0)。对于其他异常情况，该命令可能仍会返回错误，例如读取或写入状态时出现问题。</li>
<li><code>-lock=false</code>：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。</li>
<li><code>-lock-timeout=DURATION</code>：除非使用 <code>-lock=false</code> 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。</li>
<li><code>-no-color</code>：关闭彩色输出。在无法解释输出色彩的终端中运行 Terraform 时请使用此参数。</li>
</ul>
<p>以下是使用 <code>local</code> Backend 时可用的遗留参数：</p>
<ul>
<li>
<p><code>-backup=FILENAME</code>：指定源状态文件的备份地址，默认为源状态文件加上&quot;.backup&quot;后缀</p>
</li>
<li>
<p><code>-bakcup-out=FILENAME</code>：指定目标状态文件的备份地址，默认为目标状态文件加上&quot;.backup&quot;后缀</p>
</li>
<li>
<p><code>-state=FILENAME</code>：源状态文件地址，默认为当前 Backend 或是&quot;terraform.tfstate&quot;</p>
</li>
<li>
<p><code>-state-out=FILENAME</code>：目标状态文件地址。如果不指定则使用源状态文件。可以是一个已经存在的文件或新建一个文件</p>
</li>
<li>
<p><a href="#workspace"><strong>1.7.22.1.</strong> workspace</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.22.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#workspace"></a></p>
<h2 id="1-7-22-1-workspace"><a href="#workspace"></a>1.7.22.1. workspace</h2>
<p><code>terraform workspace</code> 命令可以用来管理当前使用的工作区。我们在状态管理章节中介绍过<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/2.%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html#%E7%8A%B6%E6%80%81%E7%9A%84%E9%9A%94%E7%A6%BB%E5%AD%98%E5%82%A8">工作区</a>的概念。</p>
<p>该命令包含一系列子命令，我们将会一一介绍。</p>
<h2 id="1-7-22-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.22.1.1. 用法</h2>
<p><code>terraform workspace &lt;subcommand&gt; [options] [args]</code></p>
<ul>
<li>
<p><a href="#list"><strong>1.7.22.1.1.</strong> list</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.22.1.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#list"></a></p>
<h2 id="1-7-22-1-1-list"><a href="#list"></a>1.7.22.1.1. list</h2>
<p><code>terraform workspace list</code> 命令列出当前存在的工作区。</p>
<h2 id="1-7-22-1-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.22.1.1.1. 用法</h2>
<p><code>terraform workspace list [DIR]</code></p>
<p>该命令会打印出存在的工作区。当前工作会使用 <code>*</code> 号标记：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace list</span><br><span class="line">  default</span><br><span class="line">* development</span><br><span class="line">  jsmith-test</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a href="#select"><strong>1.7.22.2.1.</strong> select</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.22.2.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#select"></a></p>
<h2 id="1-7-22-2-1-select"><a href="#select"></a>1.7.22.2.1. select</h2>
<p><code>terraform workspace select</code> 命令用来选择使用的工作区。</p>
<h2 id="1-7-22-2-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.22.2.1.1. 用法</h2>
<p><code>terraform workspace select NAME [DIR]</code></p>
<p>NAME 指定的工作区必须已经存在：</p>
<p>该命令支持以下参数</p>
<ul>
<li><code>-or-create</code>：如果指定的工作区不存在，则创建之。默认为 <code>false</code>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace list</span><br><span class="line">  default</span><br><span class="line">* development</span><br><span class="line">  jsmith-test</span><br><span class="line"></span><br><span class="line">$ terraform workspace <span class="keyword">select</span> default</span><br><span class="line">Switched to workspace <span class="string">&quot;default&quot;</span>.</span><br></pre></td></tr></table></figure>
<h2 id="new"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">new</a></h2>
<ul>
<li>
<p><a href="#new"><strong>1.7.22.3.1.</strong> new</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.22.3.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#new"></a></p>
<h2 id="1-7-22-3-1-new"><a href="#new"></a>1.7.22.3.1. new</h2>
<p><code>terraform workspace new</code> 命令用来创建新的工作区。</p>
<h2 id="1-7-22-3-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.22.3.1.1. 用法</h2>
<p><code>terraform workspace new [OPTIONS] NAME [DIR]</code></p>
<p>该命令使用给定名字创建一个新的工作区。不可存在同名工作区。</p>
<p>如果使用了 <code>-state</code> 参数，那么给定路径的状态文件会被拷贝到新工作区。</p>
<p>该命令支持以下可选参数：</p>
<ul>
<li><code>-lock=false</code>：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。</li>
<li><code>-lock-timeout=DURATION</code>：除非使用 <code>-lock=false</code> 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。默认为 <code>0s</code>。</li>
<li><code>-state=path</code>：用来初始化新环境所使用的状态文件路径</li>
</ul>
<p>创建新工作区：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace new example</span><br><span class="line">Created and switched to workspace <span class="string">&quot;example&quot;</span>!</span><br><span class="line"></span><br><span class="line">You<span class="string">&#x27;re now on a new, empty workspace. Workspaces isolate their state,</span></span><br><span class="line"><span class="string">so if you run &quot;terraform plan&quot; Terraform will not see any existing state</span></span><br><span class="line"><span class="string">for this configuration.</span></span><br></pre></td></tr></table></figure>
<p>使用状态文件创建新工作区：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace new -state=old.terraform.tfstate example</span><br><span class="line">Created and switched to workspace <span class="string">&quot;example&quot;</span>.</span><br><span class="line"></span><br><span class="line">You<span class="string">&#x27;re now on a new, empty workspace. Workspaces isolate their state,</span></span><br><span class="line"><span class="string">so if you run &quot;terraform plan&quot; Terraform will not see any existing state</span></span><br><span class="line"><span class="string">for this configuration.</span></span><br></pre></td></tr></table></figure>
<h2 id="delete"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">delete</a></h2>
<ul>
<li>
<p><a href="#delete"><strong>1.7.22.4.1.</strong> delete</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.22.4.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#delete"></a></p>
<h2 id="1-7-22-4-1-delete"><a href="#delete"></a>1.7.22.4.1. delete</h2>
<p><code>terraform workspace delete</code> 命令被用以删除已经存在的工作区。</p>
<h2 id="1-7-22-4-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.22.4.1.1. 用法</h2>
<p><code>terraform workspace delete [OPTIONS] NAME [DIR]</code></p>
<p>该命令被用以删除已经存在的工作区。</p>
<p>被删除的工作区必须已经存在，并且<strong>不可以删除当前正在使用的工作区</strong>。如果工作区状态不是空的（存在跟踪中的远程对象），Terraform 会禁止删除，除非声明 <code>-force</code> 参数。</p>
<p>另外，不同的 Backend 在没有 <code>-force</code> 参数时可能会有不同的限制，以实现对工作区的安全删除，例如检查工作区是否已上锁。</p>
<p>如果使用 <code>-force</code> 删除非空工作区，那么原本跟踪的资源的状态就将处于&quot;dangling&quot;，也就是实际基础设施资源仍然存在，但脱离了 Terraform的 管理。有时我们希望这样，只是希望当前 Terraform 项目不再管理这些资源，交由其他项目管理。但大多数情况下并非这样，所以 Terraform 默认会禁止删除非空工作区。</p>
<p>该命令可以使用如下可选参数：</p>
<ul>
<li><code>-force</code>：删除含有非空状态文件的工作区。默认为 <code>false</code>。</li>
<li><code>-lock=false</code>：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。</li>
<li><code>-lock-timeout=DURATION</code>：除非使用 <code>-lock=false</code> 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。默认为 <code>0s</code>。</li>
</ul>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace delete example</span><br><span class="line">Deleted workspace <span class="string">&quot;example&quot;</span>.</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a href="#show"><strong>1.7.22.5.1.</strong> show</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.22.5.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#show"></a></p>
<h2 id="1-7-22-5-1-show"><a href="#show"></a>1.7.22.5.1. show</h2>
<p><code>terraform workspace show</code> 命令被用以输出当前使用的工作区。</p>
<h2 id="1-7-22-5-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.22.5.1.1. 用法</h2>
<p><code>terraform workspace show</code></p>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace show</span><br><span class="line">development</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a href="#test"><strong>1.7.23.1.</strong> test</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.23.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E4%B8%80%E8%88%AC%E5%8F%82%E6%95%B0"><strong>1.7.23.1.2.</strong> 一般参数</a></p>
</li>
<li>
<p><a href="#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><strong>1.7.23.1.3.</strong> 状态管理</a></p>
</li>
<li>
<p><a href="#terraform-%E6%B5%8B%E8%AF%95%E6%B8%85%E7%90%86"><strong>1.7.23.1.3.1.</strong> Terraform 测试清理</a></p>
</li>
<li>
<p><a href="#%E5%9C%A8-hcp-terraform-%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95"><strong>1.7.23.1.4.</strong> 在 HCP Terraform 上运行测试</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%B5%8B%E8%AF%95%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E4%B8%8E%E5%91%BD%E4%BB%A4"><strong>1.7.23.1.5.</strong> 例子：测试的目录结构与命令</a></p>
</li>
<li>
<p><a href="#%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%B5%8B%E8%AF%95%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><strong>1.7.23.1.5.1.</strong> 另一种测试目录结构</a></p>
</li>
</ul>
<p><a href="#test"></a></p>
<h2 id="1-7-23-1-test"><a href="#test"></a>1.7.23.1. test</h2>
<p><code>terraform test</code> 命令读取 Terraform 测试文件并执行其中的测试。</p>
<p><code>test</code> 命令和测试文件对于想要验证和测试其旨在被复用的模块的作者特别有用。我们也可以使用 <code>test</code> 命令来验证根模块。</p>
<h2 id="1-7-23-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.23.1.1. 用法</h2>
<p><code>terraform test [options]</code></p>
<p>该命令在当前目录和指定的测试目录（默认情况下是 <code>test</code> 目录）中搜索所有 Terraform 测试文件，并执行指定的测试。有关测试文件的更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/7.test/">测试</a>。</p>
<p>Terraform 然后会根据测试文件的规范执行一系列 Terraform 的 <code>plan</code> 或 <code>apply</code> 命令，并根据测试文件的规范验证相关计划和状态文件。</p>
<p>警告：Terraform 测试命令可以创建真正的基础设施，但可能会产生成本。请参阅 <a href="#terraform-%E6%B5%8B%E8%AF%95%E6%B8%85%E7%90%86">Terraform 测试清理</a>部分，了解确保创建的基础设施被清理的最佳实践。</p>
<h2 id="1-7-23-1-2-一般参数"><a href="#%E4%B8%80%E8%88%AC%E5%8F%82%E6%95%B0"></a>1.7.23.1.2. 一般参数</h2>
<p>Terraform <code>test</code> 命令支持以下参数：</p>
<ul>
<li><code>-cloud-run=&lt;module source&gt;</code> - 通过 HCP Terraform 远程运行针对指定的 Terraform 私有注册表模块的测试。</li>
<li><code>-filter=testfile</code> - 将 <code>terraform test</code> 操作限制为指定的测试文件。</li>
<li><code>-json</code> - 显示测试结果的机器可读 JSON 输出。</li>
<li><code>-test-directory=&lt;relative directory&gt;</code> - 指定 Terraform 查找测试文件的目录。请注意，Terraform 始终在主代码目录中加载测试文件。默认的测试目录是 <code>tests</code>。</li>
<li><code>-verbose</code> - 根据每个运行块的 <code>command</code> 属性打印出测试文件中每个 <code>run</code> 块的计划或状态。</li>
</ul>
<h2 id="1-7-23-1-3-状态管理"><a href="#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"></a>1.7.23.1.3. 状态管理</h2>
<p>每个 Terraform 测试文件在执行时都会在内存中从无到有地维护所需的所有 Terraform 状态。该状态完全独立于被测代码的任何现有状态，因此您可以安全地执行 Terraform 测试命令，而不会影响任何已存在的基础设施。</p>
<h3 id="1-7-23-1-3-1-Terraform-测试清理"><a href="#terraform-%E6%B5%8B%E8%AF%95%E6%B8%85%E7%90%86"></a>1.7.23.1.3.1. Terraform 测试清理</h3>
<p>Terraform <code>test</code> 命令可以创建真实的基础设施。一旦 Terraform 完全执行了所有测试文件，Terraform 就会尝试销毁所有遗留的基础设施。如果无法销毁，Terraform 会报告由它创建但无法销毁的资源列表。</p>
<p>我们应该密切监视测试命令的输出，以确保 Terraform 清理了它创建的基础设施，否则需要执行手动清理。我们建议为目标 Provider 创建专用的测试帐户，这样可以定期安全地清除该帐户内的资源，确保不会意外地留下昂贵的资源。</p>
<p>Terraform 还提供诊断，解释为什么它无法自动清理。我们应该检查这些诊断，以确保未来的清理操作成功。</p>
<h2 id="1-7-23-1-4-在-HCP-Terraform-上运行测试"><a href="#%E5%9C%A8-hcp-terraform-%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95"></a>1.7.23.1.4. 在 HCP Terraform 上运行测试</h2>
<p>我们可以使用 <code>-cloud-run</code> 参数在 HCP Terraform 上远程执行测试。</p>
<p><code>-cloud-run</code> 参数接受私有注册表模块地址。此参数针对 HCP Terraform 用户界面中指定的私有模块运行测试。</p>
<p>我们必须提供来自私有注册表的模块，而不是公共 Terraform 注册表。</p>
<p>在使用该参数之前，您必须执行 <a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/cli/commands/login"><code>terraform login</code></a>，并确保您的 <code>host</code> 参数与目标模块的私有注册表主机名匹配。</p>
<h2 id="1-7-23-1-5-例子：测试的目录结构与命令"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%B5%8B%E8%AF%95%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E4%B8%8E%E5%91%BD%E4%BB%A4"></a>1.7.23.1.5. 例子：测试的目录结构与命令</h2>
<p>以下目录结构表示包含测试和配置（setup）模块的 Terraform 模块的示例目录树：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">|-- main.tf</span><br><span class="line">|-- outputs.tf</span><br><span class="line">|-- terraform.tf</span><br><span class="line">|-- variables.tf</span><br><span class="line">|-- tests/</span><br><span class="line">|   |-- validations.tftest.hcl</span><br><span class="line">|   |-- outputs.tftest.hcl</span><br><span class="line">|-- testing/</span><br><span class="line">    |-- setup/</span><br><span class="line">        |-- main.tf</span><br><span class="line">        |-- outputs.tf</span><br><span class="line">        |-- terraform.tf</span><br><span class="line">        |-- variables.tf</span><br></pre></td></tr></table></figure>
<p>在项目的根目录下，有一些典型的 Terraform 配置文件：<code>main.tf</code>、<code>outputs.tf</code>、<code>terraform.tf</code> 和 <code>variables.tf</code>。测试文件 <code>validations.tftest.hcl</code> 和 <code>outputs.tftest.hcl</code> 位于默认测试目录 <code>tests</code> 中。</p>
<p>另外 <code>testing</code> 目录下有一个为测试而存在的<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/7.test/#module-%E5%9D%97">设置(setup)模块</a></p>
<p>要执行测试，我们应该从代码根目录运行 <code>terraform test</code>，如同运行 <code>terraform plan</code> 或 <code>terraform apply</code> 一样。尽管实际的测试文件位于内嵌的 <code>tests</code> 目录中，但 Terraform 仍从主代码目录执行。</p>
<p>可以使用 <code>-filter</code> 参数指定执行特定的测试文件。</p>
<p>Linux、Mac 操作系统和 UNIX 下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform <span class="built_in">test</span> -filter=tests/validations.tftest.hcl</span><br></pre></td></tr></table></figure>
<p>PowerShell：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform <span class="built_in">test</span> -filter=<span class="string">&#x27;tests\validations.tftest.hcl&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Windows <code>cmd.exe</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform <span class="built_in">test</span> -filter=tests\validations.tftest.hcl</span><br></pre></td></tr></table></figure>
<h3 id="1-7-23-1-5-1-另一种测试目录结构"><a href="#%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%B5%8B%E8%AF%95%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"></a>1.7.23.1.5.1. 另一种测试目录结构</h3>
<p>在上面的示例中，测试文件位于默认的 <code>tests</code> 目录中。测试文件也可以直接包含在主代码目录中：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">|-- main.tf</span><br><span class="line">|-- outputs.tf</span><br><span class="line">|-- terraform.tf</span><br><span class="line">|-- variables.tf</span><br><span class="line">|-- validations.tftest.hcl</span><br><span class="line">|-- outputs.tftest.hcl</span><br><span class="line">|-- testing/</span><br><span class="line">    |-- setup/</span><br><span class="line">        |-- main.tf</span><br><span class="line">        |-- outputs.tf</span><br><span class="line">        |-- terraform.tf</span><br><span class="line">        |-- variables.tf</span><br></pre></td></tr></table></figure>
<p>测试文件的位置不会影响 <code>terraform test</code> 的运行。测试文件的所有引用以及其中的绝对文件路径都应相对于主代码目录。</p>
<p>我们还可以使用 <code>-test-directory</code> 参数来更改测试文件的位置。例如， <code>terraform test -test-directory=testing</code> 将命令 Terraform 从 <code>testing</code> 目录加载测试，而不是 <code>tests</code>。</p>
<p>测试目录必须位于主代码目录下，但可以多层嵌套。</p>
<blockquote>
<p>注意：无论 <code>-test-directory</code> 的值为何，根代码目录中的测试文件始终会被加载。</p>
</blockquote>
<p>我们不建议更改默认测试目录。这些自定义选项是为那些在 <code>terraform test</code> 功能发布之前可能已在其代码中包含了 <code>tests</code> 子模块的代码作者准备的。一般来说，应始终使用默认的 <code>tests</code> 目录。</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">標籤</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/Terraform/" rel="tag">Terraform</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../29/Teraform/Terraform-%E6%B5%8B%E8%AF%95/"
                    data-tooltip="Terraform-测试"
                    aria-label="上一篇: Terraform-测试"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../26/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C1/"
                    data-tooltip="Terraform-命令行1"
                    aria-label="下一篇: Terraform-命令行1"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2023/01/28/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C2/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2023/01/28/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C2/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2023/01/28/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C2/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2023/01/28/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C2/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../29/Teraform/Terraform-%E6%B5%8B%E8%AF%95/"
                    data-tooltip="Terraform-测试"
                    aria-label="上一篇: Terraform-测试"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../26/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C1/"
                    data-tooltip="Terraform-命令行1"
                    aria-label="下一篇: Terraform-命令行1"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2023/01/28/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C2/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2023/01/28/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C2/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2023/01/28/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C2/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2023/01/28/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C2/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2023/01/28/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C2/"
                        aria-label="分享到 Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2023/01/28/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C2/"
                        aria-label="分享到 Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2023/01/28/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C2/"
                        aria-label="global.share_on_linkedin"
                    >
                        <i class="fab fa-linkedin" aria-hidden="true"></i><span>global.share_on_linkedin</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2023/01/28/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C2/"
                        aria-label="分享到 Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 210 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
