
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>Terraform-模块 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg"},"articleBody":"\n1.6.1. Terraform模块\n\n\n1.6.1. Terraform模块\n到目前为止我们介绍了一些代码书写的知识，但我们创建的所有资源和数据源的代码都是我们在代码文件中编写出来的。我们有没有办法不通过复制粘贴代码从而直接使用别人编写好的 Terraform 代码来创建一组资源呢？\nTerraform 对此给出的答案就是模块 (Module)。简单来讲模块就是包含一组 Terraform 代码的文件夹，我们之前篇章中编写的代码实际上也是在模块中。要想真正理解模块的功能，我们需要去体验一下模块的使用。\nTerraform 模块是编写高质量 Terraform 代码，提升代码复用性的重要手段，可以说，一个成熟的生产环境应该是由数个可信成熟的模块组装而成的。我们将在本章介绍关于模块的知识。\n\n\n1.6.1.1. 创建模块\n\n\n1.6.1.1.1. 模块结构\n\n\n1.6.1.1.2. 避免过深的模块结构\n\n\n\n1.6.1.1. 创建模块\n实际上所有包含 Terraform 代码文件的文件夹都是一个 Terraform 模块。我们如果直接在一个文件夹内执行 terraform apply 或者 terraform plan 命令，那么当前所在的文件夹就被称为根模块(root module)。我们也可以在执行 Terraform 命令时通过命令行参数指定根模块的路径。\n1.6.1.1.1. 模块结构\n旨在被重用的模块与我们编写的根模块使用的是相同的 Terraform 代码和代码风格规范。一般来讲，在一个模块中，会有：\n\n一个 README 文件，用来描述模块的用途。文件名可以是 README 或者 README.md，后者应采用 Markdown 语法编写。可以考虑在 README 中用可视化的图形来描绘创建的基础设施资源以及它们之间的关系。README 中不需要描述模块的输入输出，因为工具会自动收集相关信息。如果在 README 中引用了外部文件或图片，请确保使用的是带有特定版本号的绝对 URL 路径以防止未来指向错误的版本\n一个 LICENSE 描述模块使用的许可协议。如果你想要公开发布一个模块，最好考虑包含一个明确的许可证协议文件，许多组织不会使用没有明确许可证协议的模块\n一个 examples 文件夹用来给出一个调用样例(可选)\n一个 variables.tf 文件，包含模块所有的输入变量。输入变量应该有明确的描述说明用途\n一个 outputs.tf 文件，包含模块所有的输出值。输出值应该有明确的描述说明用途\n嵌入模块文件夹，出于封装复杂性或是复用代码的目的，我们可以在 modules 子目录下建立一些嵌入模块。所有包含 README 文件的嵌入模块都可以被外部用户使用；不含 README 文件的模块被认为是仅在当前模块内使用的(可选)\n一个 main.tf，它是模块主要的入口点。对于一个简单的模块来说，可以把所有资源都定义在里面；如果是一个比较复杂的模块，我们可以把创建的资源分布到不同的代码文件中，但引用嵌入模块的代码还是应保留在 main.tf 里\n其他定义了各种基础设施对象的代码文件(可选)\n\n如果模块含有多个嵌入模块，那么应避免它们彼此之间的引用，由根模块负责组合它们。\n由于 examples/ 的代码经常会被拷贝到其他项目中进行修改，所有在 examples/ 代码中引用本模块时使用的引用路径应使用外部调用者可以使用的路径，而非相对路径。\n一个最小化模块推荐的结构是这样的：\n123456$ tree minimal-module/.├── README.md├── main.tf├── variables.tf├── outputs.tf\n一个更完整一些的模块结构可以是这样的：\n1234567891011121314151617181920$ tree complete-module/.├── README.md├── main.tf├── variables.tf├── outputs.tf├── ...├── modules/│   ├── nestedA/│   │   ├── README.md│   │   ├── variables.tf│   │   ├── main.tf│   │   ├── outputs.tf│   ├── nestedB/│   ├── .../├── examples/│   ├── exampleA/│   │   ├── main.tf│   ├── exampleB/│   ├── .../\n1.6.1.1.2. 避免过深的模块结构\n我们刚才提到可以在 modules/ 子目录下创建嵌入模块。Terraform 倡导&quot;扁平&quot;的模块结构，只应保持一层嵌入模块，防止在嵌入模块中继续创建嵌入模块。应将嵌入模块设计成易于组合的结构，使得在根模块中可以通过组合各个嵌入模块创建复杂的基础设施。\n\n\n1.6.2.1. 引用模块\n\n\n1.6.2.1.1. 模块源\n\n\n1.6.2.1.1.1. 本地路径\n\n\n1.6.2.1.1.2. Terraform Registry\n\n\n1.6.2.1.1.3. GitHub\n\n\n1.6.2.1.1.4. Bitbucket\n\n\n1.6.2.1.1.5. 通用 Git 仓库\n\n\n1.6.2.1.1.6. 通用 Mercurial 仓库\n\n\n1.6.2.1.1.7. HTTP 地址\n\n\n1.6.2.1.1.8. S3 Bucket\n\n\n1.6.2.1.1.9. GCS Bucket\n\n\n1.6.2.1.2. 直接引用子文件夹中的模块\n\n\n1.6.2.1.3. 使用模块\n\n\n1.6.2.1.4. 访问模块输出值\n\n\n1.6.2.1.5. 其他的模块元参数\n\n\n1.6.2.1.6. 模块版本约束\n\n\n1.6.2.1.7. 多实例模块\n\n\n1.6.2.1.8. 模块内的 Provider\n\n\n1.6.2.1.9. 模块内的 Provider 版本限制\n\n\n1.6.2.1.10. 隐式 Provider 继承\n\n\n1.6.2.1.11. 显式传递 Provider\n\n\n1.6.2.1.12. Provider 代理配置块\n\n\n\n1.6.2.1. 引用模块\n在 Terraform 代码中引用一个模块，使用的是 module 块。\n每当在代码中新增、删除或者修改一个 module 块之后，都要执行 terraform init 或是 terraform get 命令来获取模块代码并安装到本地磁盘上。\n1.6.2.1.1. 模块源\nmodule 块定义了一个 source 参数，指定了模块的源；Terraform 目前支持如下模块源：\n\n本地路径\nTerraform Registry\nGitHub\nBitbucket\n通用Git、Mercurial仓库\nHTTP地址\nS3 buckets\nGCS buckets\n\n我们后面会一一讲解这些模块源的使用。source 使用的是 URL 风格的参数，但某些源支持在 source 参数中通过额外参数指定模块版本。\n出于消除重复代码的目的我们可以重构我们的根模块代码，将一些拥有重复模式的代码重构为可反复调用的嵌入模块，通过本地路径来引用。\n许多的模块源类型都支持从当前系统环境中读取认证信息，例如环境变量或系统配置文件。我们在介绍模块源的时候会介绍到这方面的信息。\n我们建议每个模块把期待被重用的基础设施声明在各自的根模块位置上，但是直接引用其他模块的嵌入模块也是可行的。\n1.6.2.1.1.1. 本地路径\n使用本地路径可以使我们引用同一项目内定义的子模块：\n123module &quot;consul&quot; &#123;  source = &quot;./consul&quot;&#125;\n一个本地路径必须以 ./ 或者 ../ 为前缀来标明要使用的本地路径，以区别于使用 Terraform Registry 路径。\n本地路径引用模块和其他源类型有一个区别，本地路径引用的模块不需要下载相关源代码，代码已经存在于本地相关路径的磁盘上了。\n1.6.2.1.1.2. Terraform Registry\nRegistry 目前是 Terraform 官方力推的模块仓库方案，采用了 Terraform 定制的协议，支持版本化管理和使用模块。\n官方提供的公共仓库保存和索引了大量公共模块，在这里可以很容易地搜索到各种官方和社区提供的高质量模块。\n读者也可以通过 Terraform Cloud 服务维护一个私有模块仓库，或是通过实现 Terraform 模块注册协议来实现一个私有仓库。\n公共仓库的的模块可以用 &lt;NAMESPACE&gt;/&lt;NAME&gt;/&lt;PROVIDER&gt; 形式的源地址来引用，在公共仓库上的模块介绍页面上都包含了确切的源地址，例如：\n1234module &quot;consul&quot; &#123;  source = &quot;hashicorp/consul/aws&quot;  version = &quot;0.1.0&quot;&#125;\n对于那些托管在其他仓库的模块，在源地址头部添加 &lt;HOSTNAME&gt;/ 部分，指定私有仓库的主机名：\n1234module &quot;consul&quot; &#123;  source = &quot;app.terraform.io/example-corp/k8s-cluster/azurerm&quot;  version = &quot;1.1.0&quot;&#125;\n如果你使用的是 SaaS 版本的 Terraform Cloud，那么托管在上面的私有仓库的主机名是 app.terraform.io。如果使用的是私有部署的 Terraform 企业版，那么托管在上面的私有仓库的主机名就是 Terraform 企业版服务的主机名。\n模块仓库支持版本化。你可以在 module 块中指定模块的版本约束。\n如果要引用私有仓库的模块，你需要首先通过配置命令行工具配置文件来设置访问凭证。\n1.6.2.1.1.3. GitHub\nTerraform 发现 source 参数的值如果是以 github.com 为前缀时，会将其自动识别为一个 GitHub 源：\n123module &quot;consul&quot; &#123;  source = &quot;github.com/hashicorp/example&quot;&#125;\n上面的例子里会自动使用 HTTPS 协议克隆仓库。如果要使用 SSH 协议，那么请使用如下的地址：\n123module &quot;consul&quot; &#123;  source = &quot;git@github.com:hashicorp/example.git&quot;&#125;\nGitHub 源的处理与后面要介绍的通用 Git 仓库是一样的，所以他们获取 git 凭证和通过 ref 参数引用特定版本的方式都是一样的。如果要访问私有仓库，你需要额外配置 git 凭证。\n1.6.2.1.1.4. Bitbucket\nTerraform 发现 source 参数的值如果是以 bitbucket.org 为前缀时，会将其自动识别为一个 Bitbucket 源：\n123module &quot;consul&quot; &#123;  source = &quot;bitbucket.org/hashicorp/terraform-consul-aws&quot;&#125;\n这种捷径方法只针对公共仓库有效，因为 Terraform 必须访问 ButBucket API 来了解仓库使用的是 Git 还是 Mercurial 协议。\nTerraform 根据仓库的类型来决定将它作为一个 Git 仓库还是 Mercurial 仓库来处理。后面的章节会介绍如何为访问仓库配置访问凭证以及指定要使用的版本号。\n1.6.2.1.1.5. 通用 Git 仓库\n可以通过在地址开头加上特殊的 git:: 前缀来指定使用任意的 Git 仓库。在前缀后跟随的是一个合法的 Git URL。\n使用 HTTPS 和 SSH 协议的例子：\n1234567module &quot;vpc&quot; &#123;  source = &quot;git::https://example.com/vpc.git&quot;&#125;module &quot;storage&quot; &#123;  source = &quot;git::ssh://username@example.com/storage.git&quot;&#125;\nTerraform 使用 git clone 命令安装模块代码，所以 Terraform 会使用本地 Git 系统配置，包括访问凭证。要访问私有 Git 仓库，必须先配置相应的凭证。\n如果使用了 SSH 协议，那么会自动使用系统配置的 SSH 证书。通常情况下我们通过这种方法访问私有仓库，因为这样可以不需要交互式提示就可以访问私有仓库。\n如果使用 HTTP/HTTPS 协议，或是其他需要用户名、密码作为凭据，你需要配置 Git 凭据存储来选择一个合适的凭据源。\n默认情况下，Terraform 会克隆默认分支。可以通过 ref 参数来指定版本：\n123module &quot;vpc&quot; &#123;  source = &quot;git::https://example.com/vpc.git?ref=v1.2.0&quot;&#125;\nref 参数会被用作 git checkout 命令的参数，可以是分支名或是 tag 名。\n使用 SSH 协议时，我们更推荐 ssh:// 的地址。你也可以选择 scp 风格的语法，故意忽略 ssh:// 的部分，只留 git::，例如：\n123module &quot;storage&quot; &#123;  source = &quot;git::username@example.com:storage.git&quot;&#125;\n1.6.2.1.1.6. 通用 Mercurial 仓库\n可以通过在地址开头加上特殊的 hg:: 前缀来指定使用任意的 Mercurial 仓库。在前缀后跟随的是一个合法的 Mercurial URL：\n123module &quot;vpc&quot; &#123;  source = &quot;hg::http://example.com/vpc.hg&quot;&#125;\nTerraform 会通过运行 hg clone 命令从 Mercurial 仓库安装模块代码，所以 Terraform 会使用本地 Mercurial 系统配置，包括访问凭证。要访问私有 Mercurial 仓库，必须先配置相应的凭证。\n如果使用了 SSH 协议，那么会自动使用系统配置的 SSH 证书。通常情况下我们通过这种方法访问私有仓库，因为这样可以不需要交互式提示就可以访问私有仓库。\n类似 Git 源，我们可以通过 ref 参数指定非默认的分支或者标签来选择特定版本：\n123module &quot;vpc&quot; &#123;  source = &quot;hg::http://example.com/vpc.hg?ref=v1.2.0&quot;&#125;\n1.6.2.1.1.7. HTTP 地址\n当我们使用 HTTP 或 HTTPS 地址时，Terraform 会向指定 URL 发送一个 GET 请求，期待返回另一个源地址。这种间接的方法使得 HTTP 可以成为一个更复杂的模块源地址的指示器。\n然后 Terraform 会再发送一个 GET 请求到之前响应的地址上，并附加一个查询参数 terraform-get=1，这样服务器可以选择当 Terraform 来查询时可以返回一个不一样的地址。\n如果相应的状态码是成功的(200 范围的成功状态码)，Terraform 就会通过以下位置来获取下一个访问地址：\n\n响应头部的 X-Terraform-Get 值\n如果响应内容是一个 HTML 页面，那么会检查名为 terraform-get 的 html meta 元素：\n\n12&lt;meta name=&quot;terraform-get&quot;        content=&quot;github.com/hashicorp/example&quot; /&gt;\n不管用哪种方式返回的地址，Terraform 都会像本章提到的其他的源地址那样处理它。\n如果 HTTP/HTTPS 地址需要认证凭证，可以在 HOME 文件夹下配置一个 .netrc 文件，详见相关文档\n也有一种特殊情况，如果 Terraform 发现地址有着一个常见的存档文件的后缀名，那么 Terraform 会跳过 terraform-get=1 重定向的步骤，直接将响应内容作为模块代码使用。\n123module &quot;vpc&quot; &#123;  source = &quot;https://example.com/vpc-module.zip&quot;&#125;\n目前支持的后缀名有：\n\nzip\ntar.bz2和tbz2\ntar.gz和tgz\ntar.xz和txz\n\n如果 HTTP 地址不以这些文件名结尾，但又的确指向模块存档文件，那么可以使用 archive 参数来强制按照这种行为处理地址：\n123module &quot;vpc&quot; &#123;  source = &quot;https://example.com/vpc-module?archive=zip&quot;&#125;\n1.6.2.1.1.8. S3 Bucket\n你可以把模块存档保存在 AWS S3 桶里，使用 s3:: 作为地址前缀，后面跟随一个 S3 对象访问地址\n123module &quot;consul&quot; &#123;  source = &quot;s3::https://s3-eu-west-1.amazonaws.com/examplecorp-terraform-modules/vpc.zip&quot;&#125;\nTerraform 识别到 s3:: 前缀后会使用 AWS 风格的认证机制访问给定地址。这使得这种源地址也可以搭配其他提供了 S3 协议兼容的对象存储服务使用，只要他们的认证方式与 AWS 相同即可。\n保存在 S3 桶内的模块存档文件格式必须与上面 HTTP 源提到的支持的格式相同，Terraform 会下载并解压缩模块代码。\n模块安装器会从以下位置寻找AWS凭证，按照优先级顺序排列：\n\nAWS_ACCESS_KEY_ID 和 AWS_SECRET_ACCESS_KEY 环境变量\nHOME 目录下 .aws/credentials 文件内的默认 profile\n如果是在 AWS EC2 主机内运行的，那么会尝试使用搭载的 IAM 主机实例配置。\n\n1.6.2.1.1.9. GCS Bucket\n你可以把模块存档保存在谷歌云 GCS 储桶里，使用 gcs:: 作为地址前缀，后面跟随一个 GCS 对象访问地址：\n123module &quot;consul&quot; &#123;  source = &quot;gcs::https://www.googleapis.com/storage/v1/modules/foomodule.zip&quot;&#125;\n模块安装器会使用谷歌云 SDK 的凭据来访问 GCS。要设置凭据，你可以：\n\n通过 GOOGLE_APPLICATION_CREDENTIALS 环境变量配置服务账号的密钥文件\n如果是在谷歌云主机上运行的 Terraform，可以使用默认凭据。访问相关文档获取完整信息\n可以使用命令行 gcloud auth application-default login 设置\n\n1.6.2.1.2. 直接引用子文件夹中的模块\n引用版本控制系统或是对象存储服务中的模块时，模块本身可能存在于存档文件的一个子文件夹内。我们可以使用特殊的 // 语法来指定 Terraform 使用存档内特定路径作为模块代码所在位置，例如：\n\nhashicorp/consul/aws//modules/consul-cluster\ngit::https://example.com/network.git//modules/vpc\nhttps://example.com/network-module.zip//modules/vpc\ns3::https://s3-eu-west-1.amazonaws.com/examplecorp-terraform-modules/network.zip//modules/vpc\n\n如果源地址中包含又参数，例如指定特定版本号的 ref 参数，那么把子文件夹路径放在参数之前：\n\ngit::https://example.com/network.git//modules/vpc?ref=v1.2.0\n\nTerraform 会解压缩整个存档文件后，读取特定子文件夹。所以，对于一个存在于子文件夹中的模块来说，通过本地路径引用同一个存档内的另一个模块是安全的。\n1.6.2.1.3. 使用模块\n我们刚才介绍了如何用 source 指定模块源，下面我们继续讲解如何在代码中使用一个模块。\n我们可以把模块理解成类似函数，如同函数有输入参数表和输出值一样，我们之前介绍过 Terraform 代码有输入变量和输出值。我们在 module 块的块体内除了 source 参数，还可以对该模块的输入变量赋值：\n12345module &quot;servers&quot; &#123;  source = &quot;./app-cluster&quot;  servers = 5&#125;\n在这个例子里，我们将会创建 ./app-cluster 文件夹下 Terraform 声明的一系列资源，该模块的 servers 输入变量的值被我们设定成了5。\n在代码中新增、删除或是修改一个某块的 source，都需要重新运行 terraform init 命令。默认情况下，该命令不会升级已安装的模块(例如 source 未指定版本，过去安装了旧版本模块代码，那么执行 terraform init 不会自动更新到新版本)；可以执行 terraform init -upgrade 来强制更新到最新版本模块。\n1.6.2.1.4. 访问模块输出值\n在模块中定义的资源和数据源都是被封装的，所以模块调用者无法直接访问它们的输出属性。然而，模块可以声明一系列输出值，来选择性地输出特定的数据供模块调用者使用。\n举例来说，如果 ./app-cluster 模块定义了名为 instance_ids 的输出值，那么模块的调用者可以像这样引用它：\n12345resource &quot;aws_elb&quot; &quot;example&quot; &#123;  # ...  instances = module.servers.instance_ids&#125;\n1.6.2.1.5. 其他的模块元参数\n除了 source 以外，目前 Terraform 还支持在 module 块上声明其他一些可选元参数：\n\nversion：指定引用的模块版本，在后面的部分会详细介绍\ncount 和 for_each：这是 Terraform 0.13 开始支持的特性，类似 resource 与 data，我们可以创建多个 module 实例\nproviders：通过传入一个 map 我们可以指定模块中的 Provider 配置，我们将在后面详细介绍\ndepends_on：创建整个模块和其他资源之间的显式依赖。直到依赖项创建完毕，否则声明了依赖的模块内部所有的资源及内嵌的模块资源都会被推迟处理。模块的依赖行为与资源的依赖行为相同\n\n除了上述元参数以外，lifecycle 参数目前还不能被用于模块，但关键字被保留以便将来实现。\n1.6.2.1.6. 模块版本约束\n使用 registry 作为模块源时，可以使用 version 元参数约束使用的模块版本：\n123456module &quot;consul&quot; &#123;  source  = &quot;hashicorp/consul/aws&quot;  version = &quot;0.0.5&quot;  servers = 3&#125;\nversion 元参数的格式与 Provider 版本约束的格式一致。在满足版本约束的前提下，Terraform 会使用当前已安装的最新版本的模块实例。如果当前没有满足约束的版本被安装过，那么会下载符合约束的最新的版本。\nversion 元参数只能配合 registry 使用，公共的或者私有的模块仓库都可以。其他类型的模块源可能支持版本化，也可能不支持。本地路径模块不支持版本化。\n1.6.2.1.7. 多实例模块\n可以通过在 module 块上声明 for_each 或者 count 来创造多实例模块。在使用上 module 上的 for_each 和 count 与资源、数据源块上的使用是一样的。\n123456# my_buckets.tfmodule &quot;bucket&quot; &#123;  for_each = toset([&quot;assets&quot;, &quot;media&quot;])  source   = &quot;./publish_bucket&quot;  name     = &quot;$&#123;each.key&#125;_bucket&quot;&#125;\n123456789101112131415# publish_bucket/bucket-and-cloudfront.tfvariable &quot;name&quot; &#123;&#125; # this is the input parameter of the moduleresource &quot;aws_s3_bucket&quot; &quot;example&quot; &#123;  # Because var.name includes each.key in the calling  # module block, its value will be different for  # each instance of this module.  bucket = var.name  # ...&#125;resource &quot;aws_iam_user&quot; &quot;deploy_user&quot; &#123;  # ...&#125;\n这个例子定义了一个位于 ./publish_bucket 目录下的本地子模块，模块创建了一个 S3 存储桶，封装了桶的信息以及其他实现细节。\n我们通过 for_each 参数声明了模块的多个实例，传入一个 map 或是 set 作为参数值。另外，因为我们使用了 for_each，所以在 module 块里可以使用 each 对象，例子里我们使用了 each.key。如果我们使用的是 count 参数，那么我们可以使用 count.index。\n子模块里创建的资源在执行计划或UI中的名称会以 module.module_name[module index] 作为前缀。如果一个模块没有声明 count 或者 for_each，那么资源地址将不包含 module index。\n在上面的例子里，./publish_bucket 模块包含了 aws_s3_bucket.example 资源，所以两个 S3 桶实例的名字分别是module.bucket[&quot;assets&quot;].aws_s3_bucket.example 以及 module.bucket[&quot;media&quot;].aws_s3_bucket.example。\n1.6.2.1.8. 模块内的 Provider\n当代码中声明了多个模块时，资源如何与 Provider 实例关联就需要特殊考虑。\n每一个资源都必须关联一个 Provider 配置。不像 Terraform 其他的概念，Provider 配置在 Terraform 项目中是全局的，可以跨模块共享。Provider 配置声明只能放在根模块中。\nProvider 有两种方式传递给子模块：隐式继承，或是显式通过 module 块的 providers 参数传递。\n一个旨在被复用的模块不允许声明任何 provider 块，只有使用&quot;代理 Provider&quot;模式的情况除外，我们后面会介绍这种模式。\n出于向前兼容 Terraform 0.10 及更早版本的考虑，Terraform 目前在模块代码中只用到了 Terraform 0.10 及更早版本的功能时，不会针对模块代码中声明 provider 块报错，但这是一个不被推荐的遗留模式。一个含有自己的 provider 块定义的遗留模块与 for_each、count 和 depends_on 等 0.13 引入的新特性是不兼容的。\nProvider 配置被用于相关资源的所有操作，包括销毁远程资源对象以及更新状态信息等。Terraform 会在状态文件中保存针对最近用来执行所有资源变更的 Provider 配置的引用。当一个 resource 块被删除时，状态文件中的相关记录会被用来定位到相应的配置，因为原来包含 provider 参数(如果声明了的话)的 resource 块已经不存在了。\n这导致了，你必须确保删除所有相关的资源配置定义以后才能删除一个 Provider 配置。如果 Terraform 发现状态文件中记录的某个资源对应的 Provider 配置已经不存在了会报错，要求你重新给出相关的 Provider 配置。\n1.6.2.1.9. 模块内的 Provider 版本限制\n虽然 Provider 配置信息在模块间共享，每个模块还是得声明各自的模块需求，这样 Terraform 才能决定一个适用于所有模块配置的 Provider 版本。\n为了定义这样的版本约束要求，可以在 terraform 块中使用 required_providers 块：\n12345678terraform &#123;  required_providers &#123;    aws = &#123;      source  = &quot;hashicorp/aws&quot;      version = &quot;&gt;= 2.7.0&quot;    &#125;  &#125;&#125;\n有关 Provider 的 source 和版本约束的信息我们已经在前文中有所记述，在此不再赘述。\n1.6.2.1.10. 隐式 Provider 继承\n为了方便，在一些简单的代码中，一个子模块会从调用者那里自动地继承默认的 Provider 配置。这意味着显式 provider 块声明仅位于根模块中，并且下游子模块可以简单地声明使用该类型 Provider 的资源，这些资源会自动关联到根模块的 Provider 配置上。\n例如，根模块可能只含有一个 provider 块和一个 module 块：\n1234567provider &quot;aws&quot; &#123;  region = &quot;us-west-1&quot;&#125;module &quot;child&quot; &#123;  source = &quot;./child&quot;&#125;\n子模块可以声明任意关联 aws 类型 Provider 的资源而无需额外声明 Provider 配置：\n123resource &quot;aws_s3_bucket&quot; &quot;example&quot; &#123;  bucket = &quot;provider-inherit-example&quot;&#125;\n当每种类型的 Provider 都只有一个实例时我们推荐使用这种方式。\n要注意的是，只有 Provider 配置会被子模块继承，Provider 的 source 或是版本约束条件则不会被继承。每一个模块都必须声明各自的 Provider 需求条件，这在使用非 HashiCorp 的 Provider 时尤其重要。\n1.6.2.1.11. 显式传递 Provider\n当不同的子模块需要不同的 Provider 实例，或者子模块需要的 Provider 实例与调用者自己使用的不同时，我们需要在 module 块上声明 providers 参数来传递子模块要使用的 Provider 实例。例如：\n123456789101112131415161718192021# The default &quot;aws&quot; configuration is used for AWS resources in the root# module where no explicit provider instance is selected.provider &quot;aws&quot; &#123;  region = &quot;us-west-1&quot;&#125;# An alternate configuration is also defined for a different# region, using the alias &quot;usw2&quot;.provider &quot;aws&quot; &#123;  alias  = &quot;usw2&quot;  region = &quot;us-west-2&quot;&#125;# An example child module is instantiated with the alternate configuration,# so any AWS resources it defines will use the us-west-2 region.module &quot;example&quot; &#123;  source    = &quot;./example&quot;  providers = &#123;    aws = aws.usw2  &#125;&#125;\nmodule 块里的 providers 参数类似 resource 块里的 provider 参数，区别是前者接收的是一个 map 而不是单个 string，因为一个模块可能含有多个不同的 Provider。\nproviders 的 map 的键就是子模块中声明的 Provider 需求中的名字，值就是在当前模块中对应的 Provider 配置的名字。\n如果 module 块内声明了 providers 参数，那么它将重载所有默认的继承行为，所以你需要确保给定的 map 覆盖了子模块所需要的所有 Provider。这避免了显式赋值与隐式继承混用时带来的混乱和意外。\n额外的 Provider 配置(使用 alias 参数的)将永远不会被子模块隐式继承，所以必须显式通过 providers 传递。比如，一个模块配置了两个 AWS 区域之间的网络打通，所以需要配置一个源区域 Provider 和目标区域 Provider。这种情况下，根模块代码看起来是这样的：\n1234567891011121314151617provider &quot;aws&quot; &#123;  alias  = &quot;usw1&quot;  region = &quot;us-west-1&quot;&#125;provider &quot;aws&quot; &#123;  alias  = &quot;usw2&quot;  region = &quot;us-west-2&quot;&#125;module &quot;tunnel&quot; &#123;  source    = &quot;./tunnel&quot;  providers = &#123;    aws.src = aws.usw1    aws.dst = aws.usw2  &#125;&#125;\n子目录 ./tunnel 必须包含像下面的例子那样声明&quot;Provider 代理&quot;，声明模块调用者必须用这些名字传递的 Provider 配置：\n1234567provider &quot;aws&quot; &#123;  alias = &quot;src&quot;&#125;provider &quot;aws&quot; &#123;  alias = &quot;dst&quot;&#125;\n./tunnel 模块中的每一种资源都应该通过 provider 参数声明它使用的是 aws.src 还是 aws.dst。\n1.6.2.1.12. Provider 代理配置块\n一个 Provider 代理配置只包含 alias 参数，它就是一个模块间传递 Provider 配置的占位符，声明了模块期待显式传递的额外(带有 alias 的)Provider 配置。\n需要注意的是，一个完全为空的 Provider 配置块也是合法的，但没有必要。只有在模块内需要带 alias 的 Provider 时才需要代理配置块。如果模块中只是用默认 Provider 时请不要声明代理配置块，也不要仅为了声明 Provider 版本约束而使用代理配置块。\n模块元参数\n\n1.6.3.1. 模块元参数\n\n\n1.6.3.1. 模块元参数\n在 Terraform 0.13 之前，模块在使用上存在一些限制。例如我们通过模块来创建 EC2 主机，可以这样：\n123456789101112131415161718module &quot;ec2_instance&quot; &#123;  source  = &quot;terraform-aws-modules/ec2-instance/aws&quot;  version = &quot;~&gt; 3.0&quot;  name = &quot;single-instance&quot;  ami                    = &quot;ami-ebd02392&quot;  instance_type          = &quot;t2.micro&quot;  key_name               = &quot;user1&quot;  monitoring             = true  vpc_security_group_ids = [&quot;sg-12345678&quot;]  subnet_id              = &quot;subnet-eddcdzz4&quot;  tags = &#123;    Terraform   = &quot;true&quot;    Environment = &quot;dev&quot;  &#125;&#125;\n如果我们要创建两台这样的主机怎么办？在 Terraform 0.13 之前的版本中，由于 Module 不支持元参数，所以我们只能手动拷贝模块代码：\n12345678910111213141516171819202122232425262728293031323334353637module &quot;ec2_instance_0&quot; &#123;  source  = &quot;terraform-aws-modules/ec2-instance/aws&quot;  version = &quot;~&gt; 3.0&quot;  name = &quot;single-instance-0&quot;  ami                    = &quot;ami-ebd02392&quot;  instance_type          = &quot;t2.micro&quot;  key_name               = &quot;user1&quot;  monitoring             = true  vpc_security_group_ids = [&quot;sg-12345678&quot;]  subnet_id              = &quot;subnet-eddcdzz4&quot;  tags = &#123;    Terraform   = &quot;true&quot;    Environment = &quot;dev&quot;  &#125;&#125;module &quot;ec2_instance_1&quot; &#123;  source  = &quot;terraform-aws-modules/ec2-instance/aws&quot;  version = &quot;~&gt; 3.0&quot;  name = &quot;single-instance-1&quot;  ami                    = &quot;ami-ebd02392&quot;  instance_type          = &quot;t2.micro&quot;  key_name               = &quot;user1&quot;  monitoring             = true  vpc_security_group_ids = [&quot;sg-12345678&quot;]  subnet_id              = &quot;subnet-eddcdzz4&quot;  tags = &#123;    Terraform   = &quot;true&quot;    Environment = &quot;dev&quot;  &#125;&#125;\n自从 Terraform 0.13 开始，模块也像资源一样，支持count、for_each、depends_on三种元参数。比如我们可以这样：\n12345678910111213141516171819module &quot;ec2_instance&quot; &#123;  count = 2  source  = &quot;terraform-aws-modules/ec2-instance/aws&quot;  version = &quot;~&gt; 3.0&quot;  name = &quot;single-instance-$&#123;count.index&#125;&quot;  ami                    = &quot;ami-ebd02392&quot;  instance_type          = &quot;t2.micro&quot;  key_name               = &quot;user1&quot;  monitoring             = true  vpc_security_group_ids = [&quot;sg-12345678&quot;]  subnet_id              = &quot;subnet-eddcdzz4&quot;  tags = &#123;    Terraform   = &quot;true&quot;    Environment = &quot;dev&quot;  &#125;&#125;\n要注意的是 Terraform 0.13 之后在模块上声明depends_on，列表中也可以传入另一个模块。声明depends_on的模块中的所有资源的创建都会发生在被依赖的模块中所有资源创建完成之后。\n\n\n1.6.4.1. 重构\n\n\n1.6.4.1.1. moved 块语法\n\n\n1.6.4.1.2. 重命名一个资源\n\n\n1.6.4.1.3. 为资源添加 count 或 for_each 声明\n\n\n1.6.4.1.4. 重命名对模块的调用\n\n\n1.6.4.1.5. 为模块调用添加 count 或 for_each 声明\n\n\n1.6.4.1.6. 将一个模块分割成多个模块\n\n\n1.6.4.1.7. 删除 moved 块\n\n\n1.6.4.1.8. 删除模块\n\n\n\n1.6.4.1. 重构\n请注意，本节介绍的通过 moved 块进行模块重构的功能是从 Terraform v1.1 开始被引入的。如果要在之前的版本进行这样的操作，必须通过 terraform state mv 命令来完成。\n对于一些旨在被人复用的老模块来说，最初的模块结构和资源名称可能会逐渐变得不再合适。例如，我们可能发现将以前的一个子模块分割成两个单独的模块会更合理，这需要将现有资源的一个子集移动到新的模块中。\nTerraform 将以前的状态与新代码进行比较，资源与每个模块或资源的唯一地址相关联。因此，默认情况下，移动或重命名对象会被 Terraform 理解为销毁旧地址的对象并在新地址创建新的对象。\n当我们在代码中添加 moved 块以记录我们移动或重命名对象过去的地址时，Terraform 会将旧地址的现有对象视为现在属于新地址。\n1.6.4.1.1. moved 块语法\nmoved 块只包含 from 和 to 参数，没有名称：\n1234moved &#123;  from = aws_instance.a  to   = aws_instance.b&#125;\n上面的例子演示了模块先前版本中的 aws_instance.a 如今以 aws_instance.b 的名字存在。\n在为 aws_instance.b 创建新的变更计划之前，Terraform 会首先检查当前状态中是否存在地址为 aws_instance.a 的记录。如果存在该记录，Terraform 会将之重命名为 aws_instance.b 然后继续创建变更计划。最终生成的变更计划中该对象就好像一开始就是以 aws_instance.b 的名字被创建的，防止它在执行变更时被删除。\nfrom 和 to 的地址使用一种特殊的地址语法，该语法允许选定模块、资源以及子模块中的资源。下面是几种不同的重构场景中所需要的地址语法：\n1.6.4.1.2. 重命名一个资源\n考虑模块代码中这样一个资源：\n12345resource &quot;aws_instance&quot; &quot;a&quot; &#123;  count = 2  # (resource-type-specific configuration)&#125;\n第一次应用该代码时 Terraform 会创建 aws_instance.a[0] 以及 aws_instance.a[1]。\n如果随后我们修改了该资源的名称，并且把旧名字记录在一个 moved 块里：\n12345678910resource &quot;aws_instance&quot; &quot;b&quot; &#123;  count = 2  # (resource-type-specific configuration)&#125;moved &#123;  from = aws_instance.a  to   = aws_instance.b&#125;\n当下一次应用使用了该模块的代码时，Terraform 会把所有地址为 aws_instance.a 的对象看作是一开始就以 aws_instance.b 的名字创建的：aws_instance.a[0] 会被看作是 aws_instance.b[0]，aws_instance.a[1] 会被看作是 aws_instance.b[1]。\n新创建的模块实例中，因为从来就不存在 aws_instance.a，于是会忽略 moved 块而像通常那样直接创建 aws_instance.b[0] 以及 aws_instance.b[1]。\n1.6.4.1.3. 为资源添加 count 或 for_each 声明\n一开始代码中有这样一个单实例资源：\n123resource &quot;aws_instance&quot; &quot;a&quot; &#123;  # (resource-type-specific configuration)&#125;\n应用该代码会使得 Terraform 创建了一个地址为 aws_instance.a 的资源对象。\n随后我们想要在该资源上添加 for_each 来创建多个实例。为了保持先前关联到 aws_instance.a 的资源对象不受影响，我们必须添加一个 moved 块来指定新代码中原先的对象实例所关联的键是什么：\n12345678910111213141516171819202122locals &#123;  instances = tomap(&#123;    big = &#123;      instance_type = &quot;m3.large&quot;    &#125;    small = &#123;      instance_type = &quot;t2.medium&quot;    &#125;  &#125;)&#125;resource &quot;aws_instance&quot; &quot;a&quot; &#123;  for_each = local.instances  instance_type = each.value.instance_type  # (other resource-type-specific configuration)&#125;moved &#123;  from = aws_instance.a  to   = aws_instance.a[&quot;small&quot;]&#125;\n上面的代码会防止 Terraform 在变更计划中销毁已经存在的 aws_instance.a 对象，并且将其看作是以 aws_instance.a[&quot;small&quot;] 的地址创建的。\n当 moved 块的两个地址中的至少一个包含实例键时，如上例中的 [&quot;small&quot;]，Terraform 将这两个地址理解为引用资源的特定实例而不是整个资源。这意味着您可以使用 moved 在键之间切换以及在 count、for_each 之间切换时添加和删除键。\n下面的例子演示了几种其他类似的记录了资源实例键变更的合法 moved 块：\n1234567891011121314151617181920212223242526# Both old and new configuration used &quot;for_each&quot;, but the# &quot;small&quot; element was renamed to &quot;tiny&quot;.moved &#123;  from = aws_instance.b[&quot;small&quot;]  to   = aws_instance.b[&quot;tiny&quot;]&#125;# The old configuration used &quot;count&quot; and the new configuration# uses &quot;for_each&quot;, with the following mappings from# index to key:moved &#123;  from = aws_instance.c[0]  to   = aws_instance.c[&quot;small&quot;]&#125;moved &#123;  from = aws_instance.c[1]  to   = aws_instance.c[&quot;tiny&quot;]&#125;# The old configuration used &quot;count&quot;, and the new configuration# uses neither &quot;count&quot; nor &quot;for_each&quot;, and you want to keep# only the object at index 2.moved &#123;  from = aws_instance.d[2]  to   = aws_instance.d&#125;\n注意：当我们在原先没有声明 count 的资源上添加 count 时，Terraform 会自动将原先的对象移动到第 0 个位置，除非我们通过一个 moved 块显式声明该资源。然而，我们建议使用 moved 块显式声明资源的移动，使得读者在未来阅读模块的代码时能够更清楚地了解到这些变更。\n1.6.4.1.4. 重命名对模块的调用\n我们可以用类似重命名资源的方式来重命名对模块的调用。假设我们开始用以下代码调用一个模块：\n12345module &quot;a&quot; &#123;  source = &quot;../modules/example&quot;  # (module arguments)&#125;\n当应用该代码时，Terraform 会在模块内声明的资源路径前面加上一个模块路径前缀 module.a。比方说，模块内的 aws_instance.example 的完整地址为 module.a.aws_instance.example。\n如果我们随后打算修改模块名称，我们可以直接修改 module 块的标签，并且在一个 moved 块内部记录该变更：\n12345678910module &quot;b&quot; &#123;  source = &quot;../modules/example&quot;  # (module arguments)&#125;moved &#123;  from = module.a  to   = module.b&#125;\n当下一次应用包含该模块调用的代码时，Terraform 会将所有路径前缀为 module.a 的对象看作从一开始就是以 module.b 为前缀创建的。module.a.aws_instance.example 会被看作是 module.b.aws_instance.example。\n该例子中的 moved 块中的两个地址都代表对模块的调用，而 Terraform 识别出将原模块地址中所有的资源移动到新的模块地址中。如果该模块声明时使用了 count 或是 for_each，那么该移动也将被应用于所有的实例上，不需要逐个指定。\n1.6.4.1.5. 为模块调用添加 count 或 for_each 声明\n考虑一下单实例的模块：\n12345module &quot;a&quot; &#123;  source = &quot;../modules/example&quot;q  # (module arguments)&#125;\n应用该段代码会导致 Terraform 创建的资源地址都拥有 module.a 的前缀。\n随后如果我们可能需要再通过添加 count 来创建多个资源实例。为了保留先前的 aws_instance.a 实例不受影响，我们可以添加一个 moved 块来设置在新代码中该实例的对应的键。\n1234567891011module &quot;a&quot; &#123;  source = &quot;../modules/example&quot;  count  = 3  # (module arguments)&#125;moved &#123;  from = module.a  to   = module.a[2]&#125;\n上面的代码引导 Terraform 将所有 module.a 中的资源看作是从一开始就是以 module.a[2] 的前缀被创建的。结果就就是，Terraform 生成的变更计划中只会创建 module.a[0] 以及 module.a[1]。\n当 moved 块的两个地址中的至少一个包含实例键时，例如上面例子中的 [2]那样，Terraform 会理解将这两个地址理解为对模块的特定实例的调用而非对模块所有实例的调用。这意味着我们可以使用 moved 块在不同键之间切换来添加或是删除键，该机制可用于 count 和 for_each，或删除模块上的这种声明。\n1.6.4.1.6. 将一个模块分割成多个模块\n随着模块提供的功能越来越多，最终模块可能变得过大而不得不将之拆分成两个独立的模块。\n我们看一下下面的这个例子：\n1234567891011resource &quot;aws_instance&quot; &quot;a&quot; &#123;  # (other resource-type-specific configuration)&#125;resource &quot;aws_instance&quot; &quot;b&quot; &#123;  # (other resource-type-specific configuration)&#125;resource &quot;aws_instance&quot; &quot;c&quot; &#123;  # (other resource-type-specific configuration)&#125;\n我们可以将该模块分割为三个部分：\n\naws_instance.a 现在归属于模块 “x”。\naws_instance.b 也属于模块 “x”。\naws_instance.c 现在归属于模块 “y”。\n\n要在不替换绑定到旧资源地址的现有对象的情况下实现此重构，我们需要：\n\n编写模块 “x”，将属于它的两个资源拷贝过去。\n编写模块 “y”，将属于它的一个资源拷贝过去。\n编辑原有模块代码，删除这些资源，只包含有关迁移现有资源的非常简单的配置代码。\n\n新的模块 “x” 和 “y” 应该只包含 resource 块：\n123456789# module &quot;x&quot;resource &quot;aws_instance&quot; &quot;a&quot; &#123;  # (other resource-type-specific configuration)&#125;resource &quot;aws_instance&quot; &quot;b&quot; &#123;  # (other resource-type-specific configuration)&#125;\n12345# module &quot;y&quot;resource &quot;aws_instance&quot; &quot;c&quot; &#123;  # (other resource-type-specific configuration)&#125;\n而原有模块则被修改成只包含有向下兼容逻辑的垫片，调用两个新模块，并使用 moved 块定义哪些资源被移动到新模块中去了：\n1234567891011121314151617181920212223242526module &quot;x&quot; &#123;  source = &quot;../modules/x&quot;  # ...&#125;module &quot;y&quot; &#123;  source = &quot;../modules/y&quot;  # ...&#125;moved &#123;  from = aws_instance.a  to   = module.x.aws_instance.a&#125;moved &#123;  from = aws_instance.b  to   = module.x.aws_instance.b&#125;moved &#123;  from = aws_instance.c  to   = module.y.aws_instance.c&#125;\n当一个原模块的调用者升级模块版本到这个“垫片”版本时，Terraform 会注意到这些 moved 块，并将那些关联到老地址的资源对象看作是从一开始就是由新模块创建的那样。\n该模块的新用户可以选择使用这个垫片模块，或是独立调用两个新模块。我们需要通知老模块的现有用户老模块已被废弃，他们将来的开发中需要独立使用这两个新模块。\n多模块重构的场景是不多见的，因为它违反了父模块将其子模块视为黑盒的典型规则，不知道在其中声明了哪些资源。这种妥协的前提是假设所有这三个模块都由同一个人维护并分布在一个模块包中。\n为避免独立模块之间的耦合，Terraform 只允许声明在同一个目录下的模块间的移动。换句话讲，Terraform 不允许将资源移动到一个 source 地址不是本地路径的模块中去。\nTerraform 使用定义 moved 块的模块实例的地址的地址来解析 moved 块中的相对地址。例如，如果上面的原模块已经是名为 module.original 的子模块，则原模块中对 module.x.aws_instance.a 的引用在根模块中将被解析为 module.original.module.x.aws_instance.a。一个模块只能针对它自身或是它的子模块中的资源声明 moved 块。\n如果需要引用带有 count 或 for_each 元参数的模块中的资源，则必须指定要使用的特定实例键以匹配资源配置的新位置：\n1234moved &#123;  from = aws_instance.example  to   = module.new[2].aws_instance.example&#125;\n1.6.4.1.7. 删除 moved 块\n随着时间的推移，一些老模块可能会积累大量 moved 块。\n删除 moved 块通常是一种破坏性变更，因为删除后所有使用旧地址引用的对象都将被删除而不是被移动。我们强烈建议保留历史上所有的 moved 块来保存用户从任意版本升级到当前版本的升级路径信息。\n如果我们决定要删除 moved 块，需要谨慎行事。对于组织内部的私有模块来说删除 moved 块可能是安全的，因为我们可以确认所有用户都已经使用新版本模块代码运行过 terraform apply 了。\n如果我们需要多次重命名或是移动一个对象，我们建议使用串联的 moved 块来记录完整的变更信息，新的块引用已有的块：\n123456789moved &#123;  from = aws_instance.a  to   = aws_instance.b&#125;moved &#123;  from = aws_instance.b  to   = aws_instance.c&#125;\n像这样记录下移动的序列可以使 aws_instance.a 以及 aws_instance.b 两种地址的资源都得到成功更新，Terraform 会将他们视作从一开始就是以 aws_instance.c 的地址创建的。\n1.6.4.1.8. 删除模块\n注意：removed 块是在 Terraform v1.7 引入的功能。对于早期的 Terraform 版本，您可以使用 terraform state rm 命令来处理。\n要从 Terraform 中删除模块，只需从 Terraform 代码中删除模块调用即可。\n默认情况下，删除模块块后，Terraform 将计划销毁由该模块中声明的所有资源。这是因为当您删除模块调用时，该模块的代码将不再包含在我们当前的 Terraform 代码中。\n有时我们可能希望从 Terraform 代码中删除模块而不破坏它管理的实际基础设施对象。在这种情况下，资源将从 Terraform 状态中删除，但真正的基础设施对象不会被销毁。\n要声明模块已从 Terraform 配置中删除，但不应销毁其托管对象，请从配置中删除 module 块并将其替换为 removed 块：\n1234567removed &#123;  from = module.example  lifecycle &#123;    destroy = false  &#125;&#125;\nfrom 参数是要删除的模块的地址，不带任何实例键（例如 module.example[1]）。\nlifecycle 块是必需的。 destroy 参数确定 Terraform 是否会尝试销毁模块管理的对象。 false 值表示 Terraform 将从状态中删除资源而不破坏它们。\n\n\n1.6.5.1. 设计新模块的模式\n\n\n1.6.5.1.1. 模块创建的工作流\n\n\n1.6.5.1.1.1. 将需求范围划分成合适的模块\n\n\n1.6.5.1.1.2. 创建模块的最小可行产品\n\n\n1.6.5.1.2. 探索遵循这些原则的一个示例场景\n\n\n1.6.5.1.2.1. 网络模块\n\n\n1.6.5.1.2.2. 应用程序模块\n\n\n1.6.5.1.3. 创建模块的提示\n\n\n1.6.5.1.3.1. 嵌套模块\n\n\n1.6.5.1.4. 模块的协作\n\n\n1.6.5.1.5. 使用源代码控制系统追踪模块\n\n\n1.6.5.1.6. 开发一套模块消费工作流\n\n\n1.6.5.1.6.1. 阐明团队应该如何使用模块\n\n\n\n1.6.5.1. 设计新模块的模式\nTerraform 模块是独立的基础设施即代码片段，抽象了基础设施部署的底层复杂性。Terraform 用户通过使用预置的配置代码加速采用 IaC，并降低了使用门槛。所以，模块的作者应尽量遵循诸如清晰的代码结构以及 DRY(“Dont’t Repeat Yourself”)原则的代码最佳实践。\n本篇指导讨论了模块架构的原则，用以帮助读者编写易于组合、易于分享及重用的基础设施模块。这些架构建议对使用任意版本 Terraform 的企业都有助益，某些诸如“私有模块注册表(Registry)”的模式仅在 Terraform Cloud 以及企业版中才能使用。（本文不对相关内容进行翻译）\n本文是对 Terraform 模块文档的补充和扩展。\n通过阅读文本，读者可以：\n\n学习有关 Terraform 模块创建的典型工作流程和基本原则。\n探索遵循这些原则的示例场景。\n学习如何通过协作改进 Terraform 模块\n了解如何创建一套使用模块的工作流程。\n\n1.6.5.1.1. 模块创建的工作流\n要创建一个新模块，第一步是寻找一个早期采纳者团队，收集他们的需求。\n与这支早期采纳团队一起工作使我们可以通过使用输入变量以及输出值来确保模块足够灵活，从而打磨模块的功能。此外，还可以用最小的代码变更代价吸纳其他有类似需求的团队加入进来。这消除了代码重复，并缩短了交付时间。\n完成以上任务后，需要谨记两点：\n\n将需求范围划分成合适的模块。\n创建模块的最小可行产品(Minimum Viable Product, MVP)\n\n1.6.5.1.1.1. 将需求范围划分成合适的模块\n创建新 Terraform 模块时最具挑战的方面之一是决定要包含哪些基础设施资源。\n模块设计应该是有主见的，并且被设计成能很好地完成一个目标。如果一个模块的功能或目的很难解释，那么这个模块可能太复杂了。在最初确定模块的范围时，目标应当足够小且简单，易于开始编写。\n当构建一个模块时，需要考虑以下三个方面：\n\n封装：一组始终被一起部署的基础设施资源 在模块中包含更多的基础设施资源简化了终端用户部署基础设施的工作，但会使得模块的目的与需求变得更难理解。\n职责：限制模块职责的边界 如果模块中的基础设施资源由多个组来负责，使用该模块可能会意外违反职责分离原则。模块中仅包含职责边界内的一组资源可以提升基础设施资源的隔离性，并保护我们的基础设施。\n变化频率：隔离长短生命周期基础设施资源 举例来说，数据库基础设施资源相对来说较为静态，而团队可能在一天内多次部署更新应用程序服务器。在同一个模块中同时管理数据库与应用程序服务器使得保存状态数据的重要基础设施没有必要地暴露在数据丢失的风险之中。\n\n1.6.5.1.1.2. 创建模块的最小可行产品\n如同所有类型的代码一样，模块的开发永远不会完成，永远会有新的模块需求以及变更。拥抱变化，最初的模块版本应致力于满足最小可行产品（MVP）的标准。以下是在设计最小可行产品时需要谨记的指导清单：\n\n永远致力于交付至少可以满足 80% 场景的模块\n模块中永远不要处理边缘场景。边缘场景是很少见的。一个模块应该是一组可重用的代码。\n在最小可行产品中避免使用条件表达式。最小可行产品应缩小范围，不应该同时完成多种任务。\n模块应该只将最常被修改的参数公开为输入变量。一开始时，模块应该只提供最可能需要的输入变量。\n\n尽可能多输出\n在最小可行产品中输出尽可能多的信息，哪怕目前没有用户需要这些信息。这使得那些通常使用多个模块的终端用户在使用该模块时更加轻松，可以使用一个模块的输出作为下一个模块的输入。\n请记住在模块的 README 文档中记录输出值的文档。\n1.6.5.1.2. 探索遵循这些原则的一个示例场景\n某团队想要通过 Terraform 创建一套包含 Web 层应用、App 层应用的基础设施。\n他们想要使用一个专用的 VPC，并遵循传统的三层架构设计。他们的 Web 层应用需要一个自动伸缩组（AutoScaling Group）。他们的 App 层服务需要一个自动伸缩组，一个 S3 存储桶以及一个数据库。下面的架构图描述了期望的结果：\n\n该场景中，一个负责从零开始撰写 Terraform 代码的团队，负责编写一组用以配置基础设施及应用的模块。负责应用程序的团队成员将使用这些模块来配置他们需要的基础设施。\n请注意，虽然该示例使用了 AWS 命名，但所描述的模式适用于所有云平台。\n经过对应用程序团队的需求进行审核，模块团队将该应用基础设施分割成如下模块：网络、Web、App、数据库、路由，以及安全。\n当 Terraform 模块团队完成模块开发后，他们应该将模块导入到私有模块注册表中，并且向对应的团队成员宣传模块的使用方法。举例来说，负责网络的团队成员将会使用开发的网络模块来部署和配置相应的应用程序网络。\n1.6.5.1.2.1. 网络模块\n网络模块负责网络基础设施。它包含了网络访问控制列表（ACL）以及 NAT 网关。它也可以包含应用程序所需的 VPC、子网、对等连接以及 Direct Connect 等。\n\n该模块包含这些资源是因为它们需要特定权限并且变化频率较低。\n\n只有应用程序团队中有权创建或修改网络资源的成员可以使用该模块。\n该模块的资源不会经常变更。将它们组合在单独的模块中可以保护它们免于暴露在没有必要的数据丢失的风险之中。\n\n网络模块返回一组其他工作区（Workspace）以及模块可以使用的输出值。如果 VPC 的创建过程是由多个方面组成的，我们可能最终会需要将该模块进一步切割成拥有不同功能的不同模块。\n1.6.5.1.2.2. 应用程序模块\n本场景中有两个应用程序模块 —— 一个是 Web 层模块，另一个是 App 层模块。\nTerraform 模块团队完成这两个模块的开发后，它们应被分发给对应的团队成员来部署他们的应用。随着应用程序团队的成员变得越来越熟悉 Terraform 代码，它们可以提出基础设施方面的增强建议，或是通过 Pull Request 配合他们自己的应用代码发布提交对基础设施的变更请求。\nWeb 模块\nWeb 模块创建和管理运行 Web 应用程序所需的基础设施。它包含了负载均衡器和自动伸缩组，同时也可以包含应用程序中使用的 EC2 虚拟机实例、S3 存储桶、安全组，以及日志系统。该模块接收一个通过 Packer 预构建的包含最新 Web 层应用发布版本代码的虚拟机镜像的 AMI ID 作为输入。\n\n该模块包含这些资源是因为它们是高度封装的，并且它们变化频率较高。\n\n此模块中的资源高度内聚，并且与 Web 应用程序紧密相关（例如，此模块需要一个包含最新 Web 层应用程序代码版本的 AMI）。结果就是它们被编制进同一个模块，这样 Web 应用团队的成员们就可以轻松地部署它们。\n该模块的资源变更频率较高（每次发布更新版本都需要更新对应基础设施资源）。通过将它们组合在单独的模块中，我们降低了将其他模块的资源暴露在没有必要的数据丢失的风险中的可能性。\n\nApp 模块\nApp 模块创建和管理运行 App 层应用所需的基础设施。它包含了负载均衡器和自动伸缩组，同时也包含了应用程序中使用的 EC2 虚拟机实例、S3 存储桶、安全组，以及日志系统。该模块接收一个通过 Packer 预构建的包含最新 App 层应用发布版本代码的虚拟机镜像的 AMI ID 作为输入。\n\n该模块包含这些资源是因为它们是高度封装的，并且它们变化频率较高。\n\n此模块中的资源高度内聚，并且与 App 应用程序紧密相关。结果就是它们被编制进同一个模块，这样 App 层应用团队的成员们就可以轻松地部署它们。\n该模块的资源变更频率较高（每次发布更新版本都需要更新对应基础设施资源）。通过将它们组合在单独的模块中，我们降低了将其他模块的资源暴露在没有必要的数据丢失的风险中的可能性。\n\n数据库模块\n数据库模块创建并管理了运行数据库所需的基础设施资源。它包含了应用程序所需的 RDS 实例，也包含了所有关联的存储、备份以及日志资源。\n\n该模块包含这些资源是因为它们需要特定权限并且变化频率较低。\n\n只有应用程序团队中有权创建或修改数据库资源的成员可以使用该模块。\n该模块的资源不会经常变更。将它们组合在单独的模块中可以保护它们免于暴露在没有必要的数据丢失的风险之中。\n\n路由模块\n路由模块创建并管理网络路由所需的基础设施资源。它包含了公共托管区域（Hosted Zone）、Route 53 以及路由表，也可以包含私有托管区域。\n\n该模块包含这些资源是因为它们需要特定权限并且变化频率较低。\n\n只有应用程序团队中有权创建或修改路由资源的成员可以使用该模块。\n该模块的资源不会经常变更。将它们组合在单独的模块中可以保护它们免于暴露在没有必要的数据丢失的风险之中。\n\n安全模块\n安全模块创建并管理所有安全所需的基础设施资源。它包含一组 IAM 资源，也可以包含安全组（Security Group）及多因素认证（MFA）。\n\n该模块包含这些资源是因为它们需要特定权限并且变化频率较低。\n\n只有应用程序团队中有权创建或修改 IAM 或是安全资源的成员可以使用该模块。\n该模块的资源不会经常变更。将它们组合在单独的模块中可以保护它们免于暴露在没有必要的数据丢失的风险之中。\n\n1.6.5.1.3. 创建模块的提示\n除了范围界定之外，我们在创建模块时还应牢记以下几点：\n1.6.5.1.3.1. 嵌套模块\n嵌套模块是指在当前模块中对另一个模块的引用。嵌套模块可以是外部的，也可以是当前工作空间内的。使用嵌套模块是一项强大的功能；然而我们必须谨慎实践以避免引入错误。\n对于所有类型的嵌套模块，请考虑以下事项：\n\n嵌套模块可以加速开发速度，但可能会引发未知以及意料之外的结果。请在文档中清晰地记录输入变量、模块行为以及输出值。\n通常来说，不要让主模块的嵌套深度超过两层。常用且简单的工具模块，例如专门用来定义 Tag 的模块，则不受此限制制约。\n嵌套模块必须包含必要的用来创建指定的资源配置的输入参数以及输出值。\n输入参数以及输出值的命名应遵循一致的命名约定，以使得模块可以更容易地被分享，以及将一个模块的的输出值作为另一个模块的输入参数。\n嵌套模块可能会导致代码冗余。必须同时在父模块与嵌套模块中声明输入参数和输出值。\n\n嵌套的外部模块\n当我们需要使用那些定义了被多个应用程序堆栈、应用程序和团队复用的标准化资源的通用模块时，嵌套的外部模块会很有用。外部模块通被集中管理和版本化控制，以使得消费者在使用新版本之前可以对其进行验证。当我们依赖或希望使用位于外部的子模块时，请注意以下几点：\n\n外部模块必须被独立维护，并可供任何需要调用它的模块使用。使用模块注册表可以确保这一点。\n根据模块注册要求，嵌套模块将拥有自己的版本控制代码仓库，独立于调用模块进行版本控制。\n对嵌套模块的变更可能会影响调用模块，即使调用模块的调用代码及版本没有发生变化，这会破坏调用代码的信任。\n对调用模块如何使用外部模块在文档中进行记录，使得模块行为以及调用关系可以被轻松理解。\n对外部模块的变更应该是向后兼容的。如果向后兼容是不可能的，则应清楚地记录需要对任何调用模块进行的更改，并将之分发给所有模块使用者以避免意外。\n\n嵌套的嵌入模块\n在当前工作空间中嵌入一个模块使得我们能够清晰地分离模块的逻辑组件，或是创建可在调用模块执行期间多次调用的可重用代码块。在下面的例子中，ec2-instance 是一个嵌入模块，根模块的 main.tf 引用了该模块：\n12345root-module-directory├── README.md├── main.tf└── ec2-instances    └── main.tf\n如果我们需要或者倾向于使用嵌入模块，需要考虑以下几点：\n\n在“根模块”中添加嵌入模块意味着子模块与根模块被放在一起进行版本控制。\n任何影响两个模块间兼容性的变更都会被快速发现，因为它们必须被一同测试和发布。\n（嵌入的）子模块不能被代码树之外的其他模块调用，所以可能会增加重复的代码。举例来说，如果嵌入的 ec2-instance 模块是用来创建一台被用在多个地方的标准化的计算实例，该模块无法以这种形式被分享。\n\n标签化模块名并记录在文档中\n为我们的模块创建并遵循一个命名约定将使得模块易于理解与使用。这将促进模块的采用和贡献。以下是一个用以提升模块元素一致性的建议列表：\n\n使用一个对人类来说一致且易于理解的模块命名约定。举例来说：\n\n\n\n\nterraform\ncloud provider\nfunction\nfull name\n\n\n\n\nterraform\naws\nconsul cluster\nterraform-aws-consul_cluser\n\n\nterraform\naws\nsecurity module\nterraform-aws-security\n\n\nterraform\nazure\ndatabase\nterraform-azure-database\n\n\n\n\n使用人类可以理解的输入变量命名约定。模块是编写一次并多次使用的代码，因此请完整命名所有内容以提升可读性，并在编写代码时在文档中进行记录。\n对所有模块进行文档记录。确保文档中包含有：\n\n必填的输入变量：这些输入变量应该是经过深思熟虑后的选择。如果这些输入变量值未定义，模块运行将失败。只在必要时为这些输入变量设置默认值。例如 var.vpc_id 永远不应该有默认值，因为每次使用模块时值都会不同。\n可选的输入变量：这些输入变量应该有一个合理的，适用于大多数场景的默认值，同时又可以根据需求进行调整。公告输入变量的默认值。例如 var.elb_idle_timeout 会有一个合理的默认值，但调用者也可以根据需求修改它的值。\n输出值：列出模块的所有输出值，并将重要的输出和信息性的输出包装在对用户友好的输出模板中。\n\n\n\n定义并使用一个一致的模块结构\n虽然模块结构是一个品味问题，我们应当将模块的结构记录在文档中，并且在我们的所有模块之间保持统一的结构。为了要维持模块结构的一致：\n\n定义一组模块必须包含的 .tf 文件，定义它们应包含哪些内容\n为模块定义一个 .gitignore(或类似作用的)文件\n创建供样例代码所使用的输入变量值的标准方式（例如一个 terraform.tfvars.example 文件）\n使用具有固定子目录的一致的目录结构，即使它们可能是空的\n所有模块目录都必须包含一个 README 文件详细记述目录存在的目的以及如何使用其中的文件\n\n1.6.5.1.4. 模块的协作\n随着团队模块的开发工作，简化我们的协作。\n\n为每个模块创建路线图\n从用户处收集需求信息，并按受欢迎程度进行优先级排序。\n\n不使用模块的最常见原因是“它不符合我的要求”。收集这些需求并将它们添加到路线图或对用户的工作流程提出建议。\n检查每一项需求以确认它引用的用例是否正确。\n公布和维护需求列表。分享该列表并让用户参与列表管理过程。\n不要为边缘用例排期。\n\n\n将每一个决策记录进文档。\n在公司内部采用开源社区原则。一些用户希望尽可能高效地使用这些模块，而另一些用户则希望帮助创建这些模块。\n\n创建一个社区\n维护一份清晰和公开的贡献指引\n最终，我们将允许可信的社区成员获得某些模块的所有权\n\n\n\n1.6.5.1.5. 使用源代码控制系统追踪模块\n一个 Terraform 模块应遵守所有良好的代码实践：\n\n将模块置于源代码控制中以管理版本发布、协作、变更的审计跟踪。\n为所有 main 分支的发布版本建立版本标签，记录文档（最起码在 CHANGELOG 及 README 中记录）。\n对 main 分支的所有变更进行代码审查\n鼓励模块的用户通过版本标签引用模块\n为每一个模块指派一位负责人\n一个代码仓库只负责一个模块\n\n这对于模块的幂等性和作为库的功能至关重要。\n我们应该对模块打上版本标签或是版本化控制。打上版本标签或是版本化的模块应该是不可变的。\n发布到私有模块注册表的模块必须要有版本标签。\n\n\n\n1.6.5.1.6. 开发一套模块消费工作流\n定义和宣传一套消费者团队使用模块时应遵循的可重复工作流程。这个工作流程，就像模块本身一样，应该考虑到用户的需求。\n1.6.5.1.6.1. 阐明团队应该如何使用模块\n\n分散的安全性：如果每个模块都在自己的存储库中进行版本控制，则可以使用存储库 RBAC 来管理谁拥有写访问权限，从而允许相关团队管理相关的基础设施（例如网络团队拥有对网络模块的写访问权限）。\n培育代码社区：鉴于上述建议，模块开发的最佳实践是允许对存储在私有模块存储库中的模块的所有模块存储库提出 Pull Request。这促进了组织内的代码社区，保持模块内容的相关性和最大的灵活性，并有助于保持模块注册表的长期有效性。\n\n","dateCreated":"2023-01-23T17:43:45+08:00","dateModified":"2025-06-17T22:20:00+08:00","datePublished":"2023-01-23T17:43:45+08:00","description":"","headline":"Terraform-模块","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://chankein.github.io/2023/01/23/Teraform/Terraform-%E6%A8%A1%E5%9D%97/"},"publisher":{"@type":"Organization","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg","logo":{"@type":"ImageObject","url":"profile.jpg"}},"url":"https://chankein.github.io/2023/01/23/Teraform/Terraform-%E6%A8%A1%E5%9D%97/","keywords":"Terraform"}</script>
    <meta name="description" content="1.6.1. Terraform模块   1.6.1. Terraform模块 到目前为止我们介绍了一些代码书写的知识，但我们创建的所有资源和数据源的代码都是我们在代码文件中编写出来的。我们有没有办法不通过复制粘贴代码从而直接使用别人编写好的 Terraform 代码来创建一组资源呢？ Terraform 对此给出的答案就是模块 (Module)。简单来讲模块就是包含一组 Terraform 代">
<meta property="og:type" content="blog">
<meta property="og:title" content="Terraform-模块">
<meta property="og:url" content="https://chankein.github.io/2023/01/23/Teraform/Terraform-%E6%A8%A1%E5%9D%97/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:description" content="1.6.1. Terraform模块   1.6.1. Terraform模块 到目前为止我们介绍了一些代码书写的知识，但我们创建的所有资源和数据源的代码都是我们在代码文件中编写出来的。我们有没有办法不通过复制粘贴代码从而直接使用别人编写好的 Terraform 代码来创建一组资源呢？ Terraform 对此给出的答案就是模块 (Module)。简单来讲模块就是包含一组 Terraform 代">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504165650.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170456.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170534.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170602.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170632.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170657.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170717.png">
<meta property="article:published_time" content="2023-01-23T09:43:45.000Z">
<meta property="article:modified_time" content="2025-06-17T14:20:00.084Z">
<meta property="article:author" content="Kein Chan">
<meta property="article:tag" content="Terraform">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504165650.png">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../../../#about"
            >
        
        
            <img class="header-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Terraform-模块
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2023-01-23T17:43:45+08:00">
	
		    2023 年 1 月 23 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../../categories/devops/">devops</a>, <a class="category-link" href="../../../../../categories/devops/Terraform/">Terraform</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <ul>
<li><a href="#terraform%E6%A8%A1%E5%9D%97"><strong>1.6.1.</strong> Terraform模块</a></li>
</ul>
<p><a href="#terraform%E6%A8%A1%E5%9D%97"></a></p>
<h2 id="1-6-1-Terraform模块"><a href="#terraform%E6%A8%A1%E5%9D%97"></a>1.6.1. Terraform模块</h2>
<p>到目前为止我们介绍了一些代码书写的知识，但我们创建的所有资源和数据源的代码都是我们在代码文件中编写出来的。我们有没有办法不通过复制粘贴代码从而直接使用别人编写好的 Terraform 代码来创建一组资源呢？</p>
<p>Terraform 对此给出的答案就是模块 (<a target="_blank" rel="noopener" href="https://www.terraform.io/docs/modules/index.html">Module</a>)。简单来讲模块就是包含一组 Terraform 代码的文件夹，我们之前篇章中编写的代码实际上也是在模块中。要想真正理解模块的功能，我们需要去体验一下模块的使用。</p>
<p>Terraform 模块是编写高质量 Terraform 代码，提升代码复用性的重要手段，可以说，一个成熟的生产环境应该是由数个可信成熟的模块组装而成的。我们将在本章介绍关于模块的知识。</p>
<ul>
<li>
<p><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97"><strong>1.6.1.1.</strong> 创建模块</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84"><strong>1.6.1.1.1.</strong> 模块结构</a></p>
</li>
<li>
<p><a href="#%E9%81%BF%E5%85%8D%E8%BF%87%E6%B7%B1%E7%9A%84%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84"><strong>1.6.1.1.2.</strong> 避免过深的模块结构</a></p>
</li>
</ul>
<p><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97"></a></p>
<h2 id="1-6-1-1-创建模块"><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97"></a>1.6.1.1. 创建模块</h2>
<p>实际上所有包含 Terraform 代码文件的文件夹都是一个 Terraform 模块。我们如果直接在一个文件夹内执行 <code>terraform apply</code> 或者 <code>terraform plan</code> 命令，那么当前所在的文件夹就被称为根模块(root module)。我们也可以在执行 Terraform 命令时通过命令行参数指定根模块的路径。</p>
<h2 id="1-6-1-1-1-模块结构"><a href="#%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84"></a>1.6.1.1.1. 模块结构</h2>
<p>旨在被重用的模块与我们编写的根模块使用的是相同的 Terraform 代码和代码风格规范。一般来讲，在一个模块中，会有：</p>
<ul>
<li>一个 <code>README</code> 文件，用来描述模块的用途。文件名可以是 <code>README</code> 或者 <code>README.md</code>，后者应采用 Markdown 语法编写。可以考虑在 <code>README</code> 中用可视化的图形来描绘创建的基础设施资源以及它们之间的关系。<code>README</code> 中不需要描述模块的输入输出，因为工具会自动收集相关信息。如果在 <code>README</code> 中引用了外部文件或图片，请确保使用的是带有特定版本号的绝对 URL 路径以防止未来指向错误的版本</li>
<li>一个 <code>LICENSE</code> 描述模块使用的许可协议。如果你想要公开发布一个模块，最好考虑包含一个明确的许可证协议文件，许多组织不会使用没有明确许可证协议的模块</li>
<li>一个 <a target="_blank" rel="noopener" href="https://github.com/hashicorp/terraform-aws-consul/tree/master/examples">examples 文件夹</a>用来给出一个调用样例(可选)</li>
<li>一个 <code>variables.tf</code> 文件，包含模块所有的输入变量。输入变量应该有明确的描述说明用途</li>
<li>一个 <code>outputs.tf</code> 文件，包含模块所有的输出值。输出值应该有明确的描述说明用途</li>
<li>嵌入模块文件夹，出于封装复杂性或是复用代码的目的，我们可以在 modules 子目录下建立一些嵌入模块。所有包含 README 文件的嵌入模块都可以被外部用户使用；不含 <code>README</code> 文件的模块被认为是仅在当前模块内使用的(可选)</li>
<li>一个 <code>main.tf</code>，它是模块主要的入口点。对于一个简单的模块来说，可以把所有资源都定义在里面；如果是一个比较复杂的模块，我们可以把创建的资源分布到不同的代码文件中，但引用嵌入模块的代码还是应保留在 <code>main.tf</code> 里</li>
<li>其他定义了各种基础设施对象的代码文件(可选)</li>
</ul>
<p>如果模块含有多个嵌入模块，那么应避免它们彼此之间的引用，由根模块负责组合它们。</p>
<p>由于 <code>examples/</code> 的代码经常会被拷贝到其他项目中进行修改，所有在 <code>examples/</code> 代码中引用本模块时使用的引用路径应使用外部调用者可以使用的路径，而非相对路径。</p>
<p>一个最小化模块推荐的结构是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ tree minimal-module/</span><br><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── main.tf</span><br><span class="line">├── variables.tf</span><br><span class="line">├── outputs.tf</span><br></pre></td></tr></table></figure>
<p>一个更完整一些的模块结构可以是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ tree complete-module/</span><br><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── main.tf</span><br><span class="line">├── variables.tf</span><br><span class="line">├── outputs.tf</span><br><span class="line">├── ...</span><br><span class="line">├── modules/</span><br><span class="line">│   ├── nestedA/</span><br><span class="line">│   │   ├── README.md</span><br><span class="line">│   │   ├── variables.tf</span><br><span class="line">│   │   ├── main.tf</span><br><span class="line">│   │   ├── outputs.tf</span><br><span class="line">│   ├── nestedB/</span><br><span class="line">│   ├── .../</span><br><span class="line">├── examples/</span><br><span class="line">│   ├── exampleA/</span><br><span class="line">│   │   ├── main.tf</span><br><span class="line">│   ├── exampleB/</span><br><span class="line">│   ├── .../</span><br></pre></td></tr></table></figure>
<h2 id="1-6-1-1-2-避免过深的模块结构"><a href="#%E9%81%BF%E5%85%8D%E8%BF%87%E6%B7%B1%E7%9A%84%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84"></a>1.6.1.1.2. 避免过深的模块结构</h2>
<p>我们刚才提到可以在 <code>modules/</code> 子目录下创建嵌入模块。Terraform 倡导&quot;扁平&quot;的模块结构，只应保持一层嵌入模块，防止在嵌入模块中继续创建嵌入模块。应将嵌入模块设计成易于组合的结构，使得在根模块中可以通过组合各个嵌入模块创建复杂的基础设施。</p>
<ul>
<li>
<p><a href="#%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9D%97"><strong>1.6.2.1.</strong> 引用模块</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E6%BA%90"><strong>1.6.2.1.1.</strong> 模块源</a></p>
</li>
<li>
<p><a href="#%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84"><strong>1.6.2.1.1.1.</strong> 本地路径</a></p>
</li>
<li>
<p><a href="#terraform-registry"><strong>1.6.2.1.1.2.</strong> Terraform Registry</a></p>
</li>
<li>
<p><a href="#github"><strong>1.6.2.1.1.3.</strong> GitHub</a></p>
</li>
<li>
<p><a href="#bitbucket"><strong>1.6.2.1.1.4.</strong> Bitbucket</a></p>
</li>
<li>
<p><a href="#%E9%80%9A%E7%94%A8-git-%E4%BB%93%E5%BA%93"><strong>1.6.2.1.1.5.</strong> 通用 Git 仓库</a></p>
</li>
<li>
<p><a href="#%E9%80%9A%E7%94%A8-mercurial-%E4%BB%93%E5%BA%93"><strong>1.6.2.1.1.6.</strong> 通用 Mercurial 仓库</a></p>
</li>
<li>
<p><a href="#http-%E5%9C%B0%E5%9D%80"><strong>1.6.2.1.1.7.</strong> HTTP 地址</a></p>
</li>
<li>
<p><a href="#s3-bucket"><strong>1.6.2.1.1.8.</strong> S3 Bucket</a></p>
</li>
<li>
<p><a href="#gcs-bucket"><strong>1.6.2.1.1.9.</strong> GCS Bucket</a></p>
</li>
<li>
<p><a href="#%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97"><strong>1.6.2.1.2.</strong> 直接引用子文件夹中的模块</a></p>
</li>
<li>
<p><a href="#%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97"><strong>1.6.2.1.3.</strong> 使用模块</a></p>
</li>
<li>
<p><a href="#%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%9D%97%E8%BE%93%E5%87%BA%E5%80%BC"><strong>1.6.2.1.4.</strong> 访问模块输出值</a></p>
</li>
<li>
<p><a href="#%E5%85%B6%E4%BB%96%E7%9A%84%E6%A8%A1%E5%9D%97%E5%85%83%E5%8F%82%E6%95%B0"><strong>1.6.2.1.5.</strong> 其他的模块元参数</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E7%89%88%E6%9C%AC%E7%BA%A6%E6%9D%9F"><strong>1.6.2.1.6.</strong> 模块版本约束</a></p>
</li>
<li>
<p><a href="#%E5%A4%9A%E5%AE%9E%E4%BE%8B%E6%A8%A1%E5%9D%97"><strong>1.6.2.1.7.</strong> 多实例模块</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E5%86%85%E7%9A%84-provider"><strong>1.6.2.1.8.</strong> 模块内的 Provider</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E5%86%85%E7%9A%84-provider-%E7%89%88%E6%9C%AC%E9%99%90%E5%88%B6"><strong>1.6.2.1.9.</strong> 模块内的 Provider 版本限制</a></p>
</li>
<li>
<p><a href="#%E9%9A%90%E5%BC%8F-provider-%E7%BB%A7%E6%89%BF"><strong>1.6.2.1.10.</strong> 隐式 Provider 继承</a></p>
</li>
<li>
<p><a href="#%E6%98%BE%E5%BC%8F%E4%BC%A0%E9%80%92-provider"><strong>1.6.2.1.11.</strong> 显式传递 Provider</a></p>
</li>
<li>
<p><a href="#provider-%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%E5%9D%97"><strong>1.6.2.1.12.</strong> Provider 代理配置块</a></p>
</li>
</ul>
<p><a href="#%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9D%97"></a></p>
<h2 id="1-6-2-1-引用模块"><a href="#%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9D%97"></a>1.6.2.1. 引用模块</h2>
<p>在 Terraform 代码中引用一个模块，使用的是 <code>module</code> 块。</p>
<p>每当在代码中新增、删除或者修改一个 <code>module</code> 块之后，都要执行 <code>terraform init</code> 或是 <code>terraform get</code> 命令来获取模块代码并安装到本地磁盘上。</p>
<h2 id="1-6-2-1-1-模块源"><a href="#%E6%A8%A1%E5%9D%97%E6%BA%90"></a>1.6.2.1.1. 模块源</h2>
<p><code>module</code> 块定义了一个 <code>source</code> 参数，指定了模块的源；Terraform 目前支持如下模块源：</p>
<ul>
<li>本地路径</li>
<li>Terraform Registry</li>
<li>GitHub</li>
<li>Bitbucket</li>
<li>通用Git、Mercurial仓库</li>
<li>HTTP地址</li>
<li>S3 buckets</li>
<li>GCS buckets</li>
</ul>
<p>我们后面会一一讲解这些模块源的使用。<code>source</code> 使用的是 URL 风格的参数，但某些源支持在 <code>source</code> 参数中通过额外参数指定模块版本。</p>
<p>出于消除重复代码的目的我们可以重构我们的根模块代码，将一些拥有重复模式的代码重构为可反复调用的嵌入模块，通过本地路径来引用。</p>
<p>许多的模块源类型都支持从当前系统环境中读取认证信息，例如环境变量或系统配置文件。我们在介绍模块源的时候会介绍到这方面的信息。</p>
<p>我们建议每个模块把期待被重用的基础设施声明在各自的根模块位置上，但是直接引用其他模块的嵌入模块也是可行的。</p>
<h3 id="1-6-2-1-1-1-本地路径"><a href="#%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84"></a>1.6.2.1.1.1. 本地路径</h3>
<p>使用本地路径可以使我们引用同一项目内定义的子模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;./consul&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个本地路径必须以 <code>./</code> 或者 <code>../</code> 为前缀来标明要使用的本地路径，以区别于使用 Terraform Registry 路径。</p>
<p>本地路径引用模块和其他源类型有一个区别，本地路径引用的模块不需要下载相关源代码，代码已经存在于本地相关路径的磁盘上了。</p>
<h3 id="1-6-2-1-1-2-Terraform-Registry"><a href="#terraform-registry"></a>1.6.2.1.1.2. Terraform Registry</h3>
<p>Registry 目前是 Terraform 官方力推的模块仓库方案，采用了 Terraform 定制的协议，支持版本化管理和使用模块。</p>
<p>官方提供的<a target="_blank" rel="noopener" href="https://registry.terraform.io/">公共仓库</a>保存和索引了大量公共模块，在这里可以很容易地搜索到各种官方和社区提供的高质量模块。</p>
<p>读者也可以通过 Terraform Cloud 服务维护一个私有模块仓库，或是通过实现 <a target="_blank" rel="noopener" href="https://www.terraform.io/docs/registry/api.html">Terraform 模块注册协议</a>来实现一个私有仓库。</p>
<p>公共仓库的的模块可以用 <code>&lt;NAMESPACE&gt;/&lt;NAME&gt;/&lt;PROVIDER&gt;</code> 形式的源地址来引用，在公共仓库上的模块介绍页面上都包含了确切的源地址，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;hashicorp/consul/aws&quot;</span><br><span class="line">  version = &quot;0.1.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于那些托管在其他仓库的模块，在源地址头部添加 <code>&lt;HOSTNAME&gt;/</code> 部分，指定私有仓库的主机名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;app.terraform.io/example-corp/k8s-cluster/azurerm&quot;</span><br><span class="line">  version = &quot;1.1.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你使用的是 SaaS 版本的 Terraform Cloud，那么托管在上面的私有仓库的主机名是 <code>app.terraform.io</code>。如果使用的是私有部署的 Terraform 企业版，那么托管在上面的私有仓库的主机名就是 Terraform 企业版服务的主机名。</p>
<p>模块仓库支持版本化。你可以在 <code>module</code> 块中指定模块的版本约束。</p>
<p>如果要引用私有仓库的模块，你需要首先通过配置命令行工具配置文件来设置访问凭证。</p>
<h3 id="1-6-2-1-1-3-GitHub"><a href="#github"></a>1.6.2.1.1.3. GitHub</h3>
<p>Terraform 发现 <code>source</code> 参数的值如果是以 <code>github.com</code> 为前缀时，会将其自动识别为一个 GitHub 源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;github.com/hashicorp/example&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子里会自动使用 HTTPS 协议克隆仓库。如果要使用 SSH 协议，那么请使用如下的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;git@github.com:hashicorp/example.git&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GitHub 源的处理与后面要介绍的通用 Git 仓库是一样的，所以他们获取 git 凭证和通过 <code>ref</code> 参数引用特定版本的方式都是一样的。如果要访问私有仓库，你需要额外配置 git 凭证。</p>
<h3 id="1-6-2-1-1-4-Bitbucket"><a href="#bitbucket"></a>1.6.2.1.1.4. Bitbucket</h3>
<p>Terraform 发现 <code>source</code> 参数的值如果是以 <code>bitbucket.org</code> 为前缀时，会将其自动识别为一个 Bitbucket 源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;bitbucket.org/hashicorp/terraform-consul-aws&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种捷径方法只针对公共仓库有效，因为 Terraform 必须访问 ButBucket API 来了解仓库使用的是 Git 还是 Mercurial 协议。</p>
<p>Terraform 根据仓库的类型来决定将它作为一个 Git 仓库还是 Mercurial 仓库来处理。后面的章节会介绍如何为访问仓库配置访问凭证以及指定要使用的版本号。</p>
<h3 id="1-6-2-1-1-5-通用-Git-仓库"><a href="#%E9%80%9A%E7%94%A8-git-%E4%BB%93%E5%BA%93"></a>1.6.2.1.1.5. 通用 Git 仓库</h3>
<p>可以通过在地址开头加上特殊的 <code>git::</code> 前缀来指定使用任意的 Git 仓库。在前缀后跟随的是一个合法的 <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a">Git URL</a>。</p>
<p>使用 HTTPS 和 SSH 协议的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module &quot;vpc&quot; &#123;</span><br><span class="line">  source = &quot;git::https://example.com/vpc.git&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;storage&quot; &#123;</span><br><span class="line">  source = &quot;git::ssh://username@example.com/storage.git&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Terraform 使用 <code>git clone</code> 命令安装模块代码，所以 Terraform 会使用本地 Git 系统配置，包括访问凭证。要访问私有 Git 仓库，必须先配置相应的凭证。</p>
<p>如果使用了 SSH 协议，那么会自动使用系统配置的 SSH 证书。通常情况下我们通过这种方法访问私有仓库，因为这样可以不需要交互式提示就可以访问私有仓库。</p>
<p>如果使用 HTTP/HTTPS 协议，或是其他需要用户名、密码作为凭据，你需要配置 <a target="_blank" rel="noopener" href="https://git-scm.com/book/en/v2/Git-Tools-Credential-Storage">Git 凭据存储</a>来选择一个合适的凭据源。</p>
<p>默认情况下，Terraform 会克隆默认分支。可以通过 <code>ref</code> 参数来指定版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;vpc&quot; &#123;</span><br><span class="line">  source = &quot;git::https://example.com/vpc.git?ref=v1.2.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ref 参数会被用作 git checkout 命令的参数，可以是分支名或是 tag 名。</p>
<p>使用 SSH 协议时，我们更推荐 <code>ssh://</code> 的地址。你也可以选择 scp 风格的语法，故意忽略 <code>ssh://</code> 的部分，只留 <code>git::</code>，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;storage&quot; &#123;</span><br><span class="line">  source = &quot;git::username@example.com:storage.git&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-2-1-1-6-通用-Mercurial-仓库"><a href="#%E9%80%9A%E7%94%A8-mercurial-%E4%BB%93%E5%BA%93"></a>1.6.2.1.1.6. 通用 Mercurial 仓库</h3>
<p>可以通过在地址开头加上特殊的 <code>hg::</code> 前缀来指定使用任意的 Mercurial 仓库。在前缀后跟随的是一个合法的 <a target="_blank" rel="noopener" href="https://www.mercurial-scm.org/repo/hg/help/urls">Mercurial URL</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;vpc&quot; &#123;</span><br><span class="line">  source = &quot;hg::http://example.com/vpc.hg&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Terraform 会通过运行 <code>hg clone</code> 命令从 Mercurial 仓库安装模块代码，所以 Terraform 会使用本地 Mercurial 系统配置，包括访问凭证。要访问私有 Mercurial 仓库，必须先配置相应的凭证。</p>
<p>如果使用了 SSH 协议，那么会自动使用系统配置的 SSH 证书。通常情况下我们通过这种方法访问私有仓库，因为这样可以不需要交互式提示就可以访问私有仓库。</p>
<p>类似 Git 源，我们可以通过 <code>ref</code> 参数指定非默认的分支或者标签来选择特定版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;vpc&quot; &#123;</span><br><span class="line">  source = &quot;hg::http://example.com/vpc.hg?ref=v1.2.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-2-1-1-7-HTTP-地址"><a href="#http-%E5%9C%B0%E5%9D%80"></a>1.6.2.1.1.7. HTTP 地址</h3>
<p>当我们使用 HTTP 或 HTTPS 地址时，Terraform 会向指定 URL 发送一个 GET 请求，期待返回另一个源地址。这种间接的方法使得 HTTP 可以成为一个更复杂的模块源地址的指示器。</p>
<p>然后 Terraform 会再发送一个 GET 请求到之前响应的地址上，并附加一个查询参数 <code>terraform-get=1</code>，这样服务器可以选择当 Terraform 来查询时可以返回一个不一样的地址。</p>
<p>如果相应的状态码是成功的(200 范围的成功状态码)，Terraform 就会通过以下位置来获取下一个访问地址：</p>
<ul>
<li>响应头部的 <code>X-Terraform-Get</code> 值</li>
<li>如果响应内容是一个 HTML 页面，那么会检查名为 <code>terraform-get</code> 的 html meta 元素：</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;terraform-get&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">content</span>=<span class="string">&quot;github.com/hashicorp/example&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>不管用哪种方式返回的地址，Terraform 都会像本章提到的其他的源地址那样处理它。</p>
<p>如果 HTTP/HTTPS 地址需要认证凭证，可以在 HOME 文件夹下配置一个 <code>.netrc</code> 文件，详见<a target="_blank" rel="noopener" href="https://ec.haxx.se/usingcurl-netrc.html">相关文档</a></p>
<p>也有一种特殊情况，如果 Terraform 发现地址有着一个常见的存档文件的后缀名，那么 Terraform 会跳过 <code>terraform-get=1</code> 重定向的步骤，直接将响应内容作为模块代码使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;vpc&quot; &#123;</span><br><span class="line">  source = &quot;https://example.com/vpc-module.zip&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前支持的后缀名有：</p>
<ul>
<li><code>zip</code></li>
<li><code>tar.bz2</code>和<code>tbz2</code></li>
<li><code>tar.gz</code>和<code>tgz</code></li>
<li><code>tar.xz</code>和<code>txz</code></li>
</ul>
<p>如果 HTTP 地址不以这些文件名结尾，但又的确指向模块存档文件，那么可以使用 <code>archive</code> 参数来强制按照这种行为处理地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;vpc&quot; &#123;</span><br><span class="line">  source = &quot;https://example.com/vpc-module?archive=zip&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-2-1-1-8-S3-Bucket"><a href="#s3-bucket"></a>1.6.2.1.1.8. S3 Bucket</h3>
<p>你可以把模块存档保存在 AWS S3 桶里，使用 <code>s3::</code> 作为地址前缀，后面跟随一个 <a target="_blank" rel="noopener" href="http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingBucket.html#access-bucket-intro">S3 对象访问地址</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;s3::https://s3-eu-west-1.amazonaws.com/examplecorp-terraform-modules/vpc.zip&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Terraform 识别到 <code>s3::</code> 前缀后会使用 AWS 风格的认证机制访问给定地址。这使得这种源地址也可以搭配其他提供了 S3 协议兼容的对象存储服务使用，只要他们的认证方式与 AWS 相同即可。</p>
<p>保存在 S3 桶内的模块存档文件格式必须与上面 HTTP 源提到的支持的格式相同，Terraform 会下载并解压缩模块代码。</p>
<p>模块安装器会从以下位置寻找AWS凭证，按照优先级顺序排列：</p>
<ul>
<li><code>AWS_ACCESS_KEY_ID</code> 和 <code>AWS_SECRET_ACCESS_KEY</code> 环境变量</li>
<li>HOME 目录下 <code>.aws/credentials</code> 文件内的默认 profile</li>
<li>如果是在 AWS EC2 主机内运行的，那么会尝试使用搭载的 IAM 主机实例配置。</li>
</ul>
<h3 id="1-6-2-1-1-9-GCS-Bucket"><a href="#gcs-bucket"></a>1.6.2.1.1.9. GCS Bucket</h3>
<p>你可以把模块存档保存在谷歌云 GCS 储桶里，使用 <code>gcs::</code> 作为地址前缀，后面跟随一个 <a target="_blank" rel="noopener" href="https://cloud.google.com/storage/docs/request-endpoints#typical">GCS 对象访问地址</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;gcs::https://www.googleapis.com/storage/v1/modules/foomodule.zip&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模块安装器会使用谷歌云 SDK 的凭据来访问 GCS。要设置凭据，你可以：</p>
<ul>
<li>通过 <code>GOOGLE_APPLICATION_CREDENTIALS</code> 环境变量配置服务账号的密钥文件</li>
<li>如果是在谷歌云主机上运行的 Terraform，可以使用默认凭据。访问<a target="_blank" rel="noopener" href="https://cloud.google.com/compute/docs/authentication">相关文档</a>获取完整信息</li>
<li>可以使用命令行 <code>gcloud auth application-default login</code> 设置</li>
</ul>
<h2 id="1-6-2-1-2-直接引用子文件夹中的模块"><a href="#%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97"></a>1.6.2.1.2. 直接引用子文件夹中的模块</h2>
<p>引用版本控制系统或是对象存储服务中的模块时，模块本身可能存在于存档文件的一个子文件夹内。我们可以使用特殊的 <code>//</code> 语法来指定 Terraform 使用存档内特定路径作为模块代码所在位置，例如：</p>
<ul>
<li><code>hashicorp/consul/aws//modules/consul-cluster</code></li>
<li><code>git::https://example.com/network.git//modules/vpc</code></li>
<li><code>https://example.com/network-module.zip//modules/vpc</code></li>
<li><code>s3::https://s3-eu-west-1.amazonaws.com/examplecorp-terraform-modules/network.zip//modules/vpc</code></li>
</ul>
<p>如果源地址中包含又参数，例如指定特定版本号的 <code>ref</code> 参数，那么把子文件夹路径放在参数之前：</p>
<ul>
<li><code>git::https://example.com/network.git//modules/vpc?ref=v1.2.0</code></li>
</ul>
<p>Terraform 会解压缩整个存档文件后，读取特定子文件夹。所以，对于一个存在于子文件夹中的模块来说，通过本地路径引用同一个存档内的另一个模块是安全的。</p>
<h2 id="1-6-2-1-3-使用模块"><a href="#%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97"></a>1.6.2.1.3. 使用模块</h2>
<p>我们刚才介绍了如何用 <code>source</code> 指定模块源，下面我们继续讲解如何在代码中使用一个模块。</p>
<p>我们可以把模块理解成类似函数，如同函数有输入参数表和输出值一样，我们之前介绍过 Terraform 代码有输入变量和输出值。我们在 <code>module</code> 块的块体内除了 <code>source</code> 参数，还可以对该模块的输入变量赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module &quot;servers&quot; &#123;</span><br><span class="line">  source = &quot;./app-cluster&quot;</span><br><span class="line"></span><br><span class="line">  servers = 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子里，我们将会创建 <code>./app-cluster</code> 文件夹下 Terraform 声明的一系列资源，该模块的 <code>servers</code> 输入变量的值被我们设定成了5。</p>
<p>在代码中新增、删除或是修改一个某块的 <code>source</code>，都需要重新运行 <code>terraform init</code> 命令。默认情况下，该命令不会升级已安装的模块(例如 <code>source</code> 未指定版本，过去安装了旧版本模块代码，那么执行 <code>terraform init</code> 不会自动更新到新版本)；可以执行 <code>terraform init -upgrade</code> 来强制更新到最新版本模块。</p>
<h2 id="1-6-2-1-4-访问模块输出值"><a href="#%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%9D%97%E8%BE%93%E5%87%BA%E5%80%BC"></a>1.6.2.1.4. 访问模块输出值</h2>
<p>在模块中定义的资源和数据源都是被封装的，所以模块调用者无法直接访问它们的输出属性。然而，模块可以声明一系列输出值，来选择性地输出特定的数据供模块调用者使用。</p>
<p>举例来说，如果 <code>./app-cluster</code> 模块定义了名为 <code>instance_ids</code> 的输出值，那么模块的调用者可以像这样引用它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_elb&quot; &quot;example&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  instances = module.servers.instance_ids</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-6-2-1-5-其他的模块元参数"><a href="#%E5%85%B6%E4%BB%96%E7%9A%84%E6%A8%A1%E5%9D%97%E5%85%83%E5%8F%82%E6%95%B0"></a>1.6.2.1.5. 其他的模块元参数</h2>
<p>除了 <code>source</code> 以外，目前 Terraform 还支持在 <code>module</code> 块上声明其他一些可选元参数：</p>
<ul>
<li><code>version</code>：指定引用的模块版本，在后面的部分会详细介绍</li>
<li><code>count</code> 和 <code>for_each</code>：这是 Terraform 0.13 开始支持的特性，类似 <code>resource</code> 与 <code>data</code>，我们可以创建多个 <code>module</code> 实例</li>
<li><code>providers</code>：通过传入一个 <code>map</code> 我们可以指定模块中的 Provider 配置，我们将在后面详细介绍</li>
<li><code>depends_on</code>：创建整个模块和其他资源之间的显式依赖。直到依赖项创建完毕，否则声明了依赖的模块内部所有的资源及内嵌的模块资源都会被推迟处理。模块的依赖行为与资源的依赖行为相同</li>
</ul>
<p>除了上述元参数以外，<code>lifecycle</code> 参数目前还不能被用于模块，但关键字被保留以便将来实现。</p>
<h2 id="1-6-2-1-6-模块版本约束"><a href="#%E6%A8%A1%E5%9D%97%E7%89%88%E6%9C%AC%E7%BA%A6%E6%9D%9F"></a>1.6.2.1.6. 模块版本约束</h2>
<p>使用 registry 作为模块源时，可以使用 <code>version</code> 元参数约束使用的模块版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source  = &quot;hashicorp/consul/aws&quot;</span><br><span class="line">  version = &quot;0.0.5&quot;</span><br><span class="line"></span><br><span class="line">  servers = 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>version</code> 元参数的格式与 Provider 版本约束的格式一致。在满足版本约束的前提下，Terraform 会使用当前已安装的最新版本的模块实例。如果当前没有满足约束的版本被安装过，那么会下载符合约束的最新的版本。</p>
<p><code>version</code> 元参数只能配合 registry 使用，<a target="_blank" rel="noopener" href="https://registry.terraform.io/">公共</a>的或者<a target="_blank" rel="noopener" href="https://www.terraform.io/docs/cloud/registry/index.html">私有</a>的模块仓库都可以。其他类型的模块源可能支持版本化，也可能不支持。本地路径模块不支持版本化。</p>
<h2 id="1-6-2-1-7-多实例模块"><a href="#%E5%A4%9A%E5%AE%9E%E4%BE%8B%E6%A8%A1%E5%9D%97"></a>1.6.2.1.7. 多实例模块</h2>
<p>可以通过在 <code>module</code> 块上声明 <code>for_each</code> 或者 <code>count</code> 来创造多实例模块。在使用上 <code>module</code> 上的 <code>for_each</code> 和 <code>count</code> 与资源、数据源块上的使用是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># my_buckets.tf</span><br><span class="line">module &quot;bucket&quot; &#123;</span><br><span class="line">  for_each = toset([&quot;assets&quot;, &quot;media&quot;])</span><br><span class="line">  source   = &quot;./publish_bucket&quot;</span><br><span class="line">  name     = &quot;$&#123;each.key&#125;_bucket&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># publish_bucket/bucket-and-cloudfront.tf</span><br><span class="line">variable &quot;name&quot; &#123;&#125; # this is the input parameter of the module</span><br><span class="line"></span><br><span class="line">resource &quot;aws_s3_bucket&quot; &quot;example&quot; &#123;</span><br><span class="line">  # Because var.name includes each.key in the calling</span><br><span class="line">  # module block, its value will be different for</span><br><span class="line">  # each instance of this module.</span><br><span class="line">  bucket = var.name</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_iam_user&quot; &quot;deploy_user&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子定义了一个位于 <code>./publish_bucket</code> 目录下的本地子模块，模块创建了一个 S3 存储桶，封装了桶的信息以及其他实现细节。</p>
<p>我们通过 <code>for_each</code> 参数声明了模块的多个实例，传入一个 <code>map</code> 或是 <code>set</code> 作为参数值。另外，因为我们使用了 <code>for_each</code>，所以在 <code>module</code> 块里可以使用 <code>each</code> 对象，例子里我们使用了 <code>each.key</code>。如果我们使用的是 <code>count</code> 参数，那么我们可以使用 <code>count.index</code>。</p>
<p>子模块里创建的资源在执行计划或UI中的名称会以 <code>module.module_name[module index]</code> 作为前缀。如果一个模块没有声明 <code>count</code> 或者 <code>for_each</code>，那么资源地址将不包含 module index。</p>
<p>在上面的例子里，<code>./publish_bucket</code> 模块包含了 <code>aws_s3_bucket.example</code> 资源，所以两个 S3 桶实例的名字分别是<code>module.bucket[&quot;assets&quot;].aws_s3_bucket.example</code> 以及 <code>module.bucket[&quot;media&quot;].aws_s3_bucket.example</code>。</p>
<h2 id="1-6-2-1-8-模块内的-Provider"><a href="#%E6%A8%A1%E5%9D%97%E5%86%85%E7%9A%84-provider"></a>1.6.2.1.8. 模块内的 Provider</h2>
<p>当代码中声明了多个模块时，资源如何与 Provider 实例关联就需要特殊考虑。</p>
<p>每一个资源都必须关联一个 Provider 配置。不像 Terraform 其他的概念，Provider 配置在 Terraform 项目中是全局的，可以跨模块共享。Provider 配置声明只能放在根模块中。</p>
<p>Provider 有两种方式传递给子模块：隐式继承，或是显式通过 <code>module</code> 块的 <code>providers</code> 参数传递。</p>
<p>一个旨在被复用的模块不允许声明任何 <code>provider</code> 块，只有使用&quot;代理 Provider&quot;模式的情况除外，我们后面会介绍这种模式。</p>
<p>出于向前兼容 Terraform 0.10 及更早版本的考虑，Terraform 目前在模块代码中只用到了 Terraform 0.10 及更早版本的功能时，不会针对模块代码中声明 <code>provider</code> 块报错，但这是一个不被推荐的遗留模式。一个含有自己的 <code>provider</code> 块定义的遗留模块与 <code>for_each</code>、<code>count</code> 和 <code>depends_on</code> 等 0.13 引入的新特性是不兼容的。</p>
<p>Provider 配置被用于相关资源的所有操作，包括销毁远程资源对象以及更新状态信息等。Terraform 会在状态文件中保存针对最近用来执行所有资源变更的 Provider 配置的引用。当一个 <code>resource</code> 块被删除时，状态文件中的相关记录会被用来定位到相应的配置，因为原来包含 <code>provider</code> 参数(如果声明了的话)的 <code>resource</code> 块已经不存在了。</p>
<p>这导致了，你必须确保删除所有相关的资源配置定义以后才能删除一个 Provider 配置。如果 Terraform 发现状态文件中记录的某个资源对应的 Provider 配置已经不存在了会报错，要求你重新给出相关的 Provider 配置。</p>
<h2 id="1-6-2-1-9-模块内的-Provider-版本限制"><a href="#%E6%A8%A1%E5%9D%97%E5%86%85%E7%9A%84-provider-%E7%89%88%E6%9C%AC%E9%99%90%E5%88%B6"></a>1.6.2.1.9. 模块内的 Provider 版本限制</h2>
<p>虽然 Provider 配置信息在模块间共享，每个模块还是得声明各自的模块需求，这样 Terraform 才能决定一个适用于所有模块配置的 Provider 版本。</p>
<p>为了定义这样的版本约束要求，可以在 <code>terraform</code> 块中使用 <code>required_providers</code> 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    aws = &#123;</span><br><span class="line">      source  = &quot;hashicorp/aws&quot;</span><br><span class="line">      version = &quot;&gt;= 2.7.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关 Provider 的 <code>source</code> 和版本约束的信息我们已经在前文中有所记述，在此不再赘述。</p>
<h2 id="1-6-2-1-10-隐式-Provider-继承"><a href="#%E9%9A%90%E5%BC%8F-provider-%E7%BB%A7%E6%89%BF"></a>1.6.2.1.10. 隐式 Provider 继承</h2>
<p>为了方便，在一些简单的代码中，一个子模块会从调用者那里自动地继承默认的 Provider 配置。这意味着显式 <code>provider</code> 块声明仅位于根模块中，并且下游子模块可以简单地声明使用该类型 Provider 的资源，这些资源会自动关联到根模块的 Provider 配置上。</p>
<p>例如，根模块可能只含有一个 <code>provider</code> 块和一个 <code>module</code> 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  region = &quot;us-west-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;child&quot; &#123;</span><br><span class="line">  source = &quot;./child&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子模块可以声明任意关联 <code>aws</code> 类型 Provider 的资源而无需额外声明 Provider 配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_s3_bucket&quot; &quot;example&quot; &#123;</span><br><span class="line">  bucket = &quot;provider-inherit-example&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当每种类型的 Provider 都只有一个实例时我们推荐使用这种方式。</p>
<p>要注意的是，只有 Provider 配置会被子模块继承，Provider 的 <code>source</code> 或是版本约束条件则不会被继承。每一个模块都必须声明各自的 Provider 需求条件，这在使用非 HashiCorp 的 Provider 时尤其重要。</p>
<h2 id="1-6-2-1-11-显式传递-Provider"><a href="#%E6%98%BE%E5%BC%8F%E4%BC%A0%E9%80%92-provider"></a>1.6.2.1.11. 显式传递 Provider</h2>
<p>当不同的子模块需要不同的 Provider 实例，或者子模块需要的 Provider 实例与调用者自己使用的不同时，我们需要在 <code>module</code> 块上声明 <code>providers</code> 参数来传递子模块要使用的 Provider 实例。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># The default &quot;aws&quot; configuration is used for AWS resources in the root</span><br><span class="line"># module where no explicit provider instance is selected.</span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  region = &quot;us-west-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># An alternate configuration is also defined for a different</span><br><span class="line"># region, using the alias &quot;usw2&quot;.</span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias  = &quot;usw2&quot;</span><br><span class="line">  region = &quot;us-west-2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># An example child module is instantiated with the alternate configuration,</span><br><span class="line"># so any AWS resources it defines will use the us-west-2 region.</span><br><span class="line">module &quot;example&quot; &#123;</span><br><span class="line">  source    = &quot;./example&quot;</span><br><span class="line">  providers = &#123;</span><br><span class="line">    aws = aws.usw2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>module</code> 块里的 <code>providers</code> 参数类似 <code>resource</code> 块里的 <code>provider</code> 参数，区别是前者接收的是一个 <code>map</code> 而不是单个 <code>string</code>，因为一个模块可能含有多个不同的 Provider。</p>
<p><code>providers</code> 的 <code>map</code> 的键就是子模块中声明的 Provider 需求中的名字，值就是在当前模块中对应的 Provider 配置的名字。</p>
<p>如果 <code>module</code> 块内声明了 <code>providers</code> 参数，那么它将重载所有默认的继承行为，所以你需要确保给定的 <code>map</code> 覆盖了子模块所需要的所有 Provider。这避免了显式赋值与隐式继承混用时带来的混乱和意外。</p>
<p>额外的 Provider 配置(使用 <code>alias</code> 参数的)将永远不会被子模块隐式继承，所以必须显式通过 <code>providers</code> 传递。比如，一个模块配置了两个 AWS 区域之间的网络打通，所以需要配置一个源区域 Provider 和目标区域 Provider。这种情况下，根模块代码看起来是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias  = &quot;usw1&quot;</span><br><span class="line">  region = &quot;us-west-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias  = &quot;usw2&quot;</span><br><span class="line">  region = &quot;us-west-2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;tunnel&quot; &#123;</span><br><span class="line">  source    = &quot;./tunnel&quot;</span><br><span class="line">  providers = &#123;</span><br><span class="line">    aws.src = aws.usw1</span><br><span class="line">    aws.dst = aws.usw2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子目录 <code>./tunnel</code> 必须包含像下面的例子那样声明&quot;Provider 代理&quot;，声明模块调用者必须用这些名字传递的 Provider 配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias = &quot;src&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias = &quot;dst&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>./tunnel</code> 模块中的每一种资源都应该通过 <code>provider</code> 参数声明它使用的是 <code>aws.src</code> 还是 <code>aws.dst</code>。</p>
<h2 id="1-6-2-1-12-Provider-代理配置块"><a href="#provider-%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%E5%9D%97"></a>1.6.2.1.12. Provider 代理配置块</h2>
<p>一个 Provider 代理配置只包含 <code>alias</code> 参数，它就是一个模块间传递 Provider 配置的占位符，声明了模块期待显式传递的额外(带有 <code>alias</code> 的)Provider 配置。</p>
<p>需要注意的是，一个完全为空的 Provider 配置块也是合法的，但没有必要。只有在模块内需要带 <code>alias</code> 的 Provider 时才需要代理配置块。如果模块中只是用默认 Provider 时请不要声明代理配置块，也不要仅为了声明 Provider 版本约束而使用代理配置块。</p>
<h2 id="模块元参数"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">模块元参数</a></h2>
<ul>
<li><a href="#%E6%A8%A1%E5%9D%97%E5%85%83%E5%8F%82%E6%95%B0"><strong>1.6.3.1.</strong> 模块元参数</a></li>
</ul>
<p><a href="#%E6%A8%A1%E5%9D%97%E5%85%83%E5%8F%82%E6%95%B0"></a></p>
<h2 id="1-6-3-1-模块元参数"><a href="#%E6%A8%A1%E5%9D%97%E5%85%83%E5%8F%82%E6%95%B0"></a>1.6.3.1. 模块元参数</h2>
<p>在 Terraform 0.13 之前，模块在使用上存在一些限制。例如我们通过模块来创建 EC2 主机，可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module &quot;ec2_instance&quot; &#123;</span><br><span class="line">  source  = &quot;terraform-aws-modules/ec2-instance/aws&quot;</span><br><span class="line">  version = &quot;~&gt; 3.0&quot;</span><br><span class="line"></span><br><span class="line">  name = &quot;single-instance&quot;</span><br><span class="line"></span><br><span class="line">  ami                    = &quot;ami-ebd02392&quot;</span><br><span class="line">  instance_type          = &quot;t2.micro&quot;</span><br><span class="line">  key_name               = &quot;user1&quot;</span><br><span class="line">  monitoring             = true</span><br><span class="line">  vpc_security_group_ids = [&quot;sg-12345678&quot;]</span><br><span class="line">  subnet_id              = &quot;subnet-eddcdzz4&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Terraform   = &quot;true&quot;</span><br><span class="line">    Environment = &quot;dev&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们要创建两台这样的主机怎么办？在 Terraform 0.13 之前的版本中，由于 Module 不支持元参数，所以我们只能手动拷贝模块代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">module &quot;ec2_instance_0&quot; &#123;</span><br><span class="line">  source  = &quot;terraform-aws-modules/ec2-instance/aws&quot;</span><br><span class="line">  version = &quot;~&gt; 3.0&quot;</span><br><span class="line"></span><br><span class="line">  name = &quot;single-instance-0&quot;</span><br><span class="line"></span><br><span class="line">  ami                    = &quot;ami-ebd02392&quot;</span><br><span class="line">  instance_type          = &quot;t2.micro&quot;</span><br><span class="line">  key_name               = &quot;user1&quot;</span><br><span class="line">  monitoring             = true</span><br><span class="line">  vpc_security_group_ids = [&quot;sg-12345678&quot;]</span><br><span class="line">  subnet_id              = &quot;subnet-eddcdzz4&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Terraform   = &quot;true&quot;</span><br><span class="line">    Environment = &quot;dev&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;ec2_instance_1&quot; &#123;</span><br><span class="line">  source  = &quot;terraform-aws-modules/ec2-instance/aws&quot;</span><br><span class="line">  version = &quot;~&gt; 3.0&quot;</span><br><span class="line"></span><br><span class="line">  name = &quot;single-instance-1&quot;</span><br><span class="line"></span><br><span class="line">  ami                    = &quot;ami-ebd02392&quot;</span><br><span class="line">  instance_type          = &quot;t2.micro&quot;</span><br><span class="line">  key_name               = &quot;user1&quot;</span><br><span class="line">  monitoring             = true</span><br><span class="line">  vpc_security_group_ids = [&quot;sg-12345678&quot;]</span><br><span class="line">  subnet_id              = &quot;subnet-eddcdzz4&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Terraform   = &quot;true&quot;</span><br><span class="line">    Environment = &quot;dev&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自从 Terraform 0.13 开始，模块也像资源一样，支持<code>count</code>、<code>for_each</code>、<code>depends_on</code>三种元参数。比如我们可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module &quot;ec2_instance&quot; &#123;</span><br><span class="line">  count = 2</span><br><span class="line">  source  = &quot;terraform-aws-modules/ec2-instance/aws&quot;</span><br><span class="line">  version = &quot;~&gt; 3.0&quot;</span><br><span class="line"></span><br><span class="line">  name = &quot;single-instance-$&#123;count.index&#125;&quot;</span><br><span class="line"></span><br><span class="line">  ami                    = &quot;ami-ebd02392&quot;</span><br><span class="line">  instance_type          = &quot;t2.micro&quot;</span><br><span class="line">  key_name               = &quot;user1&quot;</span><br><span class="line">  monitoring             = true</span><br><span class="line">  vpc_security_group_ids = [&quot;sg-12345678&quot;]</span><br><span class="line">  subnet_id              = &quot;subnet-eddcdzz4&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Terraform   = &quot;true&quot;</span><br><span class="line">    Environment = &quot;dev&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的是 Terraform 0.13 之后在模块上声明<code>depends_on</code>，列表中也可以传入另一个模块。声明<code>depends_on</code>的模块中的所有资源的创建都会发生在被依赖的模块中所有资源创建完成之后。</p>
<ul>
<li>
<p><a href="#%E9%87%8D%E6%9E%84"><strong>1.6.4.1.</strong> 重构</a></p>
</li>
<li>
<p><a href="#moved-%E5%9D%97%E8%AF%AD%E6%B3%95"><strong>1.6.4.1.1.</strong> moved 块语法</a></p>
</li>
<li>
<p><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90"><strong>1.6.4.1.2.</strong> 重命名一个资源</a></p>
</li>
<li>
<p><a href="#%E4%B8%BA%E8%B5%84%E6%BA%90%E6%B7%BB%E5%8A%A0-count-%E6%88%96-foreach-%E5%A3%B0%E6%98%8E"><strong>1.6.4.1.3.</strong> 为资源添加 count 或 for_each 声明</a></p>
</li>
<li>
<p><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E5%AF%B9%E6%A8%A1%E5%9D%97%E7%9A%84%E8%B0%83%E7%94%A8"><strong>1.6.4.1.4.</strong> 重命名对模块的调用</a></p>
</li>
<li>
<p><a href="#%E4%B8%BA%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8%E6%B7%BB%E5%8A%A0-count-%E6%88%96-foreach-%E5%A3%B0%E6%98%8E"><strong>1.6.4.1.5.</strong> 为模块调用添加 count 或 for_each 声明</a></p>
</li>
<li>
<p><a href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%88%86%E5%89%B2%E6%88%90%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%9D%97"><strong>1.6.4.1.6.</strong> 将一个模块分割成多个模块</a></p>
</li>
<li>
<p><a href="#%E5%88%A0%E9%99%A4-moved-%E5%9D%97"><strong>1.6.4.1.7.</strong> 删除 moved 块</a></p>
</li>
<li>
<p><a href="#%E5%88%A0%E9%99%A4%E6%A8%A1%E5%9D%97"><strong>1.6.4.1.8.</strong> 删除模块</a></p>
</li>
</ul>
<p><a href="#%E9%87%8D%E6%9E%84"></a></p>
<h2 id="1-6-4-1-重构"><a href="#%E9%87%8D%E6%9E%84"></a>1.6.4.1. 重构</h2>
<p>请注意，本节介绍的通过 <code>moved</code> 块进行模块重构的功能是从 Terraform v1.1 开始被引入的。如果要在之前的版本进行这样的操作，必须通过 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/18.state/2.mv"><code>terraform state mv</code></a> 命令来完成。</p>
<p>对于一些旨在被人复用的老模块来说，最初的模块结构和资源名称可能会逐渐变得不再合适。例如，我们可能发现将以前的一个子模块分割成两个单独的模块会更合理，这需要将现有资源的一个子集移动到新的模块中。</p>
<p>Terraform 将以前的状态与新代码进行比较，资源与每个模块或资源的唯一地址相关联。因此，默认情况下，移动或重命名对象会被 Terraform 理解为销毁旧地址的对象并在新地址创建新的对象。</p>
<p>当我们在代码中添加 <code>moved</code> 块以记录我们移动或重命名对象过去的地址时，Terraform 会将旧地址的现有对象视为现在属于新地址。</p>
<h2 id="1-6-4-1-1-moved-块语法"><a href="#moved-%E5%9D%97%E8%AF%AD%E6%B3%95"></a>1.6.4.1.1. moved 块语法</h2>
<p><code>moved</code> 块只包含 <code>from</code> 和 <code>to</code> 参数，没有名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.a</span><br><span class="line">  to   = aws_instance.b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子演示了模块先前版本中的 <code>aws_instance.a</code> 如今以 <code>aws_instance.b</code> 的名字存在。</p>
<p>在为 <code>aws_instance.b</code> 创建新的变更计划之前，Terraform 会首先检查当前状态中是否存在地址为 <code>aws_instance.a</code> 的记录。如果存在该记录，Terraform 会将之重命名为 <code>aws_instance.b</code> 然后继续创建变更计划。最终生成的变更计划中该对象就好像一开始就是以 <code>aws_instance.b</code> 的名字被创建的，防止它在执行变更时被删除。</p>
<p><code>from</code> 和 <code>to</code> 的地址使用一种特殊的地址语法，该语法允许选定模块、资源以及子模块中的资源。下面是几种不同的重构场景中所需要的地址语法：</p>
<h2 id="1-6-4-1-2-重命名一个资源"><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90"></a>1.6.4.1.2. 重命名一个资源</h2>
<p>考虑模块代码中这样一个资源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;a&quot; &#123;</span><br><span class="line">  count = 2</span><br><span class="line"></span><br><span class="line">  # (resource-type-specific configuration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次应用该代码时 Terraform 会创建 <code>aws_instance.a[0]</code> 以及 <code>aws_instance.a[1]</code>。</p>
<p>如果随后我们修改了该资源的名称，并且把旧名字记录在一个 <code>moved</code> 块里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;b&quot; &#123;</span><br><span class="line">  count = 2</span><br><span class="line"></span><br><span class="line">  # (resource-type-specific configuration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.a</span><br><span class="line">  to   = aws_instance.b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当下一次应用使用了该模块的代码时，Terraform 会把所有地址为 <code>aws_instance.a</code> 的对象看作是一开始就以 <code>aws_instance.b</code> 的名字创建的：<code>aws_instance.a[0]</code> 会被看作是 <code>aws_instance.b[0]</code>，<code>aws_instance.a[1]</code> 会被看作是 <code>aws_instance.b[1]</code>。</p>
<p>新创建的模块实例中，因为从来就不存在 <code>aws_instance.a</code>，于是会忽略 <code>moved</code> 块而像通常那样直接创建 <code>aws_instance.b[0]</code> 以及 <code>aws_instance.b[1]</code>。</p>
<h2 id="1-6-4-1-3-为资源添加-count-或-for-each-声明"><a href="#%E4%B8%BA%E8%B5%84%E6%BA%90%E6%B7%BB%E5%8A%A0-count-%E6%88%96-foreach-%E5%A3%B0%E6%98%8E"></a>1.6.4.1.3. 为资源添加 count 或 for_each 声明</h2>
<p>一开始代码中有这样一个单实例资源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;a&quot; &#123;</span><br><span class="line">  # (resource-type-specific configuration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用该代码会使得 Terraform 创建了一个地址为 <code>aws_instance.a</code> 的资源对象。</p>
<p>随后我们想要在该资源上添加 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90#for_each"><code>for_each</code></a> 来创建多个实例。为了保持先前关联到 <code>aws_instance.a</code> 的资源对象不受影响，我们必须添加一个 <code>moved</code> 块来指定新代码中原先的对象实例所关联的键是什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">locals &#123;</span><br><span class="line">  instances = tomap(&#123;</span><br><span class="line">    big = &#123;</span><br><span class="line">      instance_type = &quot;m3.large&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    small = &#123;</span><br><span class="line">      instance_type = &quot;t2.medium&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;a&quot; &#123;</span><br><span class="line">  for_each = local.instances</span><br><span class="line"></span><br><span class="line">  instance_type = each.value.instance_type</span><br><span class="line">  # (other resource-type-specific configuration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.a</span><br><span class="line">  to   = aws_instance.a[&quot;small&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码会防止 Terraform 在变更计划中销毁已经存在的 <code>aws_instance.a</code> 对象，并且将其看作是以 <code>aws_instance.a[&quot;small&quot;]</code> 的地址创建的。</p>
<p>当 <code>moved</code> 块的两个地址中的至少一个包含实例键时，如上例中的 <code>[&quot;small&quot;]</code>，Terraform 将这两个地址理解为引用资源的特定实例而不是整个资源。这意味着您可以使用 <code>moved</code> 在键之间切换以及在 <code>count</code>、<code>for_each</code> 之间切换时添加和删除键。</p>
<p>下面的例子演示了几种其他类似的记录了资源实例键变更的合法 <code>moved</code> 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Both old and new configuration used &quot;for_each&quot;, but the</span><br><span class="line"># &quot;small&quot; element was renamed to &quot;tiny&quot;.</span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.b[&quot;small&quot;]</span><br><span class="line">  to   = aws_instance.b[&quot;tiny&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># The old configuration used &quot;count&quot; and the new configuration</span><br><span class="line"># uses &quot;for_each&quot;, with the following mappings from</span><br><span class="line"># index to key:</span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.c[0]</span><br><span class="line">  to   = aws_instance.c[&quot;small&quot;]</span><br><span class="line">&#125;</span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.c[1]</span><br><span class="line">  to   = aws_instance.c[&quot;tiny&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># The old configuration used &quot;count&quot;, and the new configuration</span><br><span class="line"># uses neither &quot;count&quot; nor &quot;for_each&quot;, and you want to keep</span><br><span class="line"># only the object at index 2.</span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.d[2]</span><br><span class="line">  to   = aws_instance.d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：当我们在原先没有声明 <code>count</code> 的资源上添加 <code>count</code> 时，Terraform 会自动将原先的对象移动到第 0 个位置，除非我们通过一个 <code>moved</code> 块显式声明该资源。然而，我们建议使用 <code>moved</code> 块显式声明资源的移动，使得读者在未来阅读模块的代码时能够更清楚地了解到这些变更。</p>
<h2 id="1-6-4-1-4-重命名对模块的调用"><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E5%AF%B9%E6%A8%A1%E5%9D%97%E7%9A%84%E8%B0%83%E7%94%A8"></a>1.6.4.1.4. 重命名对模块的调用</h2>
<p>我们可以用类似重命名资源的方式来重命名对模块的调用。假设我们开始用以下代码调用一个模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module &quot;a&quot; &#123;</span><br><span class="line">  source = &quot;../modules/example&quot;</span><br><span class="line"></span><br><span class="line">  # (module arguments)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当应用该代码时，Terraform 会在模块内声明的资源路径前面加上一个模块路径前缀 <code>module.a</code>。比方说，模块内的 <code>aws_instance.example</code> 的完整地址为 <code>module.a.aws_instance.example</code>。</p>
<p>如果我们随后打算修改模块名称，我们可以直接修改 <code>module</code> 块的标签，并且在一个 <code>moved</code> 块内部记录该变更：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module &quot;b&quot; &#123;</span><br><span class="line">  source = &quot;../modules/example&quot;</span><br><span class="line"></span><br><span class="line">  # (module arguments)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = module.a</span><br><span class="line">  to   = module.b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当下一次应用包含该模块调用的代码时，Terraform 会将所有路径前缀为 <code>module.a</code> 的对象看作从一开始就是以 <code>module.b</code> 为前缀创建的。<code>module.a.aws_instance.example</code> 会被看作是 <code>module.b.aws_instance.example</code>。</p>
<p>该例子中的 <code>moved</code> 块中的两个地址都代表对模块的调用，而 Terraform 识别出将原模块地址中所有的资源移动到新的模块地址中。如果该模块声明时使用了 <code>count</code> 或是 <code>for_each</code>，那么该移动也将被应用于所有的实例上，不需要逐个指定。</p>
<h2 id="1-6-4-1-5-为模块调用添加-count-或-for-each-声明"><a href="#%E4%B8%BA%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8%E6%B7%BB%E5%8A%A0-count-%E6%88%96-foreach-%E5%A3%B0%E6%98%8E"></a>1.6.4.1.5. 为模块调用添加 count 或 for_each 声明</h2>
<p>考虑一下单实例的模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module &quot;a&quot; &#123;</span><br><span class="line">  source = &quot;../modules/example&quot;q</span><br><span class="line"></span><br><span class="line">  # (module arguments)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用该段代码会导致 Terraform 创建的资源地址都拥有 <code>module.a</code> 的前缀。</p>
<p>随后如果我们可能需要再通过添加 <code>count</code> 来创建多个资源实例。为了保留先前的 <code>aws_instance.a</code> 实例不受影响，我们可以添加一个 <code>moved</code> 块来设置在新代码中该实例的对应的键。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module &quot;a&quot; &#123;</span><br><span class="line">  source = &quot;../modules/example&quot;</span><br><span class="line">  count  = 3</span><br><span class="line"></span><br><span class="line">  # (module arguments)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = module.a</span><br><span class="line">  to   = module.a[2]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码引导 Terraform 将所有 <code>module.a</code> 中的资源看作是从一开始就是以 <code>module.a[2]</code> 的前缀被创建的。结果就就是，Terraform 生成的变更计划中只会创建 <code>module.a[0]</code> 以及 <code>module.a[1]</code>。</p>
<p>当 <code>moved</code> 块的两个地址中的至少一个包含实例键时，例如上面例子中的 <code>[2]</code>那样，Terraform 会理解将这两个地址理解为对模块的特定实例的调用而非对模块所有实例的调用。这意味着我们可以使用 <code>moved</code> 块在不同键之间切换来添加或是删除键，该机制可用于 <code>count</code> 和 <code>for_each</code>，或删除模块上的这种声明。</p>
<h2 id="1-6-4-1-6-将一个模块分割成多个模块"><a href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%88%86%E5%89%B2%E6%88%90%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%9D%97"></a>1.6.4.1.6. 将一个模块分割成多个模块</h2>
<p>随着模块提供的功能越来越多，最终模块可能变得过大而不得不将之拆分成两个独立的模块。</p>
<p>我们看一下下面的这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;a&quot; &#123;</span><br><span class="line">  # (other resource-type-specific configuration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;b&quot; &#123;</span><br><span class="line">  # (other resource-type-specific configuration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;c&quot; &#123;</span><br><span class="line">  # (other resource-type-specific configuration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以将该模块分割为三个部分：</p>
<ul>
<li><code>aws_instance.a</code> 现在归属于模块 “x”。</li>
<li><code>aws_instance.b</code> 也属于模块 “x”。</li>
<li><code>aws_instance.c</code> 现在归属于模块 “y”。</li>
</ul>
<p>要在不替换绑定到旧资源地址的现有对象的情况下实现此重构，我们需要：</p>
<ol>
<li>编写模块 “x”，将属于它的两个资源拷贝过去。</li>
<li>编写模块 “y”，将属于它的一个资源拷贝过去。</li>
<li>编辑原有模块代码，删除这些资源，只包含有关迁移现有资源的非常简单的配置代码。</li>
</ol>
<p>新的模块 “x” 和 “y” 应该只包含 <code>resource</code> 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># module &quot;x&quot;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;a&quot; &#123;</span><br><span class="line">  # (other resource-type-specific configuration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;b&quot; &#123;</span><br><span class="line">  # (other resource-type-specific configuration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># module &quot;y&quot;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;c&quot; &#123;</span><br><span class="line">  # (other resource-type-specific configuration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而原有模块则被修改成只包含有向下兼容逻辑的垫片，调用两个新模块，并使用 <code>moved</code> 块定义哪些资源被移动到新模块中去了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">module &quot;x&quot; &#123;</span><br><span class="line">  source = &quot;../modules/x&quot;</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;y&quot; &#123;</span><br><span class="line">  source = &quot;../modules/y&quot;</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.a</span><br><span class="line">  to   = module.x.aws_instance.a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.b</span><br><span class="line">  to   = module.x.aws_instance.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.c</span><br><span class="line">  to   = module.y.aws_instance.c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个原模块的调用者升级模块版本到这个“垫片”版本时，Terraform 会注意到这些 <code>moved</code> 块，并将那些关联到老地址的资源对象看作是从一开始就是由新模块创建的那样。</p>
<p>该模块的新用户可以选择使用这个垫片模块，或是独立调用两个新模块。我们需要通知老模块的现有用户老模块已被废弃，他们将来的开发中需要独立使用这两个新模块。</p>
<p>多模块重构的场景是不多见的，因为它违反了父模块将其子模块视为黑盒的典型规则，不知道在其中声明了哪些资源。这种妥协的前提是假设所有这三个模块都由同一个人维护并分布在一个模块包中。</p>
<p>为避免独立模块之间的耦合，Terraform 只允许声明在同一个目录下的模块间的移动。换句话讲，Terraform 不允许将资源移动到一个 <code>source</code> 地址不是<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/2.%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97.html#%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84">本地路径</a>的模块中去。</p>
<p>Terraform 使用定义 <code>moved</code> 块的模块实例的地址的地址来解析 <code>moved</code> 块中的相对地址。例如，如果上面的原模块已经是名为 <code>module.original</code> 的子模块，则原模块中对 <code>module.x.aws_instance.a</code> 的引用在根模块中将被解析为 <code>module.original.module.x.aws_instance.a</code>。一个模块只能针对它自身或是它的子模块中的资源声明 <code>moved</code> 块。</p>
<p>如果需要引用带有 <code>count</code> 或 <code>for_each</code> 元参数的模块中的资源，则必须指定要使用的特定实例键以匹配资源配置的新位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.example</span><br><span class="line">  to   = module.new[2].aws_instance.example</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-6-4-1-7-删除-moved-块"><a href="#%E5%88%A0%E9%99%A4-moved-%E5%9D%97"></a>1.6.4.1.7. 删除 moved 块</h2>
<p>随着时间的推移，一些老模块可能会积累大量 <code>moved</code> 块。</p>
<p>删除 <code>moved</code> 块通常是一种破坏性变更，因为删除后所有使用旧地址引用的对象都将被删除而不是被移动。我们强烈建议保留历史上所有的 <code>moved</code> 块来保存用户从任意版本升级到当前版本的升级路径信息。</p>
<p>如果我们决定要删除 <code>moved</code> 块，需要谨慎行事。对于组织内部的私有模块来说删除 <code>moved</code> 块可能是安全的，因为我们可以确认所有用户都已经使用新版本模块代码运行过 <code>terraform apply</code> 了。</p>
<p>如果我们需要多次重命名或是移动一个对象，我们建议使用<em>串联</em>的 <code>moved</code> 块来记录完整的变更信息，新的块引用已有的块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.a</span><br><span class="line">  to   = aws_instance.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.b</span><br><span class="line">  to   = aws_instance.c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像这样记录下移动的序列可以使 <code>aws_instance.a</code> 以及 <code>aws_instance.b</code> 两种地址的资源都得到成功更新，Terraform 会将他们视作从一开始就是以 <code>aws_instance.c</code> 的地址创建的。</p>
<h2 id="1-6-4-1-8-删除模块"><a href="#%E5%88%A0%E9%99%A4%E6%A8%A1%E5%9D%97"></a>1.6.4.1.8. 删除模块</h2>
<p>注意：<code>removed</code> 块是在 Terraform v1.7 引入的功能。对于早期的 Terraform 版本，您可以使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/18.state/6.rm.html"><code>terraform state rm</code></a> 命令来处理。</p>
<p>要从 Terraform 中删除模块，只需从 Terraform 代码中删除模块调用即可。</p>
<p>默认情况下，删除模块块后，Terraform 将计划销毁由该模块中声明的所有资源。这是因为当您删除模块调用时，该模块的代码将不再包含在我们当前的 Terraform 代码中。</p>
<p>有时我们可能希望从 Terraform 代码中删除模块而不破坏它管理的实际基础设施对象。在这种情况下，资源将从 Terraform 状态中删除，但真正的基础设施对象不会被销毁。</p>
<p>要声明模块已从 Terraform 配置中删除，但不应销毁其托管对象，请从配置中删除 <code>module</code> 块并将其替换为 <code>removed</code> 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">removed &#123;</span><br><span class="line">  from = module.example</span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    destroy = false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>from</code> 参数是要删除的模块的地址，不带任何实例键（例如 <code>module.example[1]</code>）。</p>
<p><code>lifecycle</code> 块是必需的。 <code>destroy</code> 参数确定 Terraform 是否会尝试销毁模块管理的对象。 <code>false</code> 值表示 Terraform 将从状态中删除资源而不破坏它们。</p>
<ul>
<li>
<p><a href="#%E8%AE%BE%E8%AE%A1%E6%96%B0%E6%A8%A1%E5%9D%97%E7%9A%84%E6%A8%A1%E5%BC%8F"><strong>1.6.5.1.</strong> 设计新模块的模式</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E5%88%9B%E5%BB%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81"><strong>1.6.5.1.1.</strong> 模块创建的工作流</a></p>
</li>
<li>
<p><a href="#%E5%B0%86%E9%9C%80%E6%B1%82%E8%8C%83%E5%9B%B4%E5%88%92%E5%88%86%E6%88%90%E5%90%88%E9%80%82%E7%9A%84%E6%A8%A1%E5%9D%97"><strong>1.6.5.1.1.1.</strong> 将需求范围划分成合适的模块</a></p>
</li>
<li>
<p><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8F%AF%E8%A1%8C%E4%BA%A7%E5%93%81"><strong>1.6.5.1.1.2.</strong> 创建模块的最小可行产品</a></p>
</li>
<li>
<p><a href="#%E6%8E%A2%E7%B4%A2%E9%81%B5%E5%BE%AA%E8%BF%99%E4%BA%9B%E5%8E%9F%E5%88%99%E7%9A%84%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B%E5%9C%BA%E6%99%AF"><strong>1.6.5.1.2.</strong> 探索遵循这些原则的一个示例场景</a></p>
</li>
<li>
<p><a href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97"><strong>1.6.5.1.2.1.</strong> 网络模块</a></p>
</li>
<li>
<p><a href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97"><strong>1.6.5.1.2.2.</strong> 应用程序模块</a></p>
</li>
<li>
<p><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97%E7%9A%84%E6%8F%90%E7%A4%BA"><strong>1.6.5.1.3.</strong> 创建模块的提示</a></p>
</li>
<li>
<p><a href="#%E5%B5%8C%E5%A5%97%E6%A8%A1%E5%9D%97"><strong>1.6.5.1.3.1.</strong> 嵌套模块</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8D%8F%E4%BD%9C"><strong>1.6.5.1.4.</strong> 模块的协作</a></p>
</li>
<li>
<p><a href="#%E4%BD%BF%E7%94%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E8%BF%BD%E8%B8%AA%E6%A8%A1%E5%9D%97"><strong>1.6.5.1.5.</strong> 使用源代码控制系统追踪模块</a></p>
</li>
<li>
<p><a href="#%E5%BC%80%E5%8F%91%E4%B8%80%E5%A5%97%E6%A8%A1%E5%9D%97%E6%B6%88%E8%B4%B9%E5%B7%A5%E4%BD%9C%E6%B5%81"><strong>1.6.5.1.6.</strong> 开发一套模块消费工作流</a></p>
</li>
<li>
<p><a href="#%E9%98%90%E6%98%8E%E5%9B%A2%E9%98%9F%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97"><strong>1.6.5.1.6.1.</strong> 阐明团队应该如何使用模块</a></p>
</li>
</ul>
<p><a href="#%E8%AE%BE%E8%AE%A1%E6%96%B0%E6%A8%A1%E5%9D%97%E7%9A%84%E6%A8%A1%E5%BC%8F"></a></p>
<h2 id="1-6-5-1-设计新模块的模式"><a href="#%E8%AE%BE%E8%AE%A1%E6%96%B0%E6%A8%A1%E5%9D%97%E7%9A%84%E6%A8%A1%E5%BC%8F"></a>1.6.5.1. 设计新模块的模式</h2>
<p>Terraform 模块是独立的基础设施即代码片段，抽象了基础设施部署的底层复杂性。Terraform 用户通过使用预置的配置代码加速采用 IaC，并降低了使用门槛。所以，模块的作者应尽量遵循诸如清晰的代码结构以及 DRY(“Dont’t Repeat Yourself”)原则的代码最佳实践。</p>
<p>本篇指导讨论了模块架构的原则，用以帮助读者编写易于组合、易于分享及重用的基础设施模块。这些架构建议对使用任意版本 Terraform 的企业都有助益，某些诸如“私有模块注册表(Registry)”的模式仅在 Terraform Cloud 以及企业版中才能使用。（本文不对相关内容进行翻译）</p>
<p>本文是对 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/1.%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97">Terraform 模块文档</a>的补充和扩展。</p>
<p>通过阅读文本，读者可以：</p>
<ol>
<li>学习有关 Terraform 模块创建的典型工作流程和基本原则。</li>
<li>探索遵循这些原则的示例场景。</li>
<li>学习如何通过协作改进 Terraform 模块</li>
<li>了解如何创建一套使用模块的工作流程。</li>
</ol>
<h2 id="1-6-5-1-1-模块创建的工作流"><a href="#%E6%A8%A1%E5%9D%97%E5%88%9B%E5%BB%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81"></a>1.6.5.1.1. 模块创建的工作流</h2>
<p>要创建一个新模块，第一步是寻找一个早期采纳者团队，收集他们的需求。</p>
<p>与这支早期采纳团队一起工作使我们可以通过使用输入变量以及输出值来确保模块足够灵活，从而打磨模块的功能。此外，还可以用最小的代码变更代价吸纳其他有类似需求的团队加入进来。这消除了代码重复，并缩短了交付时间。</p>
<p>完成以上任务后，需要谨记两点：</p>
<ol>
<li>将需求范围划分成合适的模块。</li>
<li>创建模块的最小可行产品(Minimum Viable Product, MVP)</li>
</ol>
<h3 id="1-6-5-1-1-1-将需求范围划分成合适的模块"><a href="#%E5%B0%86%E9%9C%80%E6%B1%82%E8%8C%83%E5%9B%B4%E5%88%92%E5%88%86%E6%88%90%E5%90%88%E9%80%82%E7%9A%84%E6%A8%A1%E5%9D%97"></a>1.6.5.1.1.1. 将需求范围划分成合适的模块</h3>
<p>创建新 Terraform 模块时最具挑战的方面之一是决定要包含哪些基础设施资源。</p>
<p>模块设计应该是有主见的，并且被设计成能很好地完成一个目标。如果一个模块的功能或目的很难解释，那么这个模块可能太复杂了。在最初确定模块的范围时，目标应当足够小且简单，易于开始编写。</p>
<p>当构建一个模块时，需要考虑以下三个方面：</p>
<ul>
<li><strong>封装</strong>：一组始终被一起部署的基础设施资源 在模块中包含更多的基础设施资源简化了终端用户部署基础设施的工作，但会使得模块的目的与需求变得更难理解。</li>
<li><strong>职责</strong>：限制模块职责的边界 如果模块中的基础设施资源由多个组来负责，使用该模块可能会意外违反职责分离原则。模块中仅包含职责边界内的一组资源可以提升基础设施资源的隔离性，并保护我们的基础设施。</li>
<li><strong>变化频率</strong>：隔离长短生命周期基础设施资源 举例来说，数据库基础设施资源相对来说较为静态，而团队可能在一天内多次部署更新应用程序服务器。在同一个模块中同时管理数据库与应用程序服务器使得保存状态数据的重要基础设施没有必要地暴露在数据丢失的风险之中。</li>
</ul>
<h3 id="1-6-5-1-1-2-创建模块的最小可行产品"><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8F%AF%E8%A1%8C%E4%BA%A7%E5%93%81"></a>1.6.5.1.1.2. 创建模块的最小可行产品</h3>
<p>如同所有类型的代码一样，模块的开发永远不会完成，永远会有新的模块需求以及变更。拥抱变化，最初的模块版本应致力于满足最小可行产品（MVP）的标准。以下是在设计最小可行产品时需要谨记的指导清单：</p>
<ul>
<li>永远致力于交付至少可以满足 80% 场景的模块</li>
<li>模块中永远不要处理边缘场景。边缘场景是很少见的。一个模块应该是一组可重用的代码。</li>
<li>在最小可行产品中避免使用条件表达式。最小可行产品应缩小范围，不应该同时完成多种任务。</li>
<li>模块应该只将最常被修改的参数公开为输入变量。一开始时，模块应该只提供最可能需要的输入变量。</li>
</ul>
<h4 id="尽可能多输出"><a href="#%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%A4%9A%E8%BE%93%E5%87%BA"></a>尽可能多输出</h4>
<p>在最小可行产品中输出尽可能多的信息，哪怕目前没有用户需要这些信息。这使得那些通常使用多个模块的终端用户在使用该模块时更加轻松，可以使用一个模块的输出作为下一个模块的输入。</p>
<p>请记住在模块的 <code>README</code> 文档中记录输出值的文档。</p>
<h2 id="1-6-5-1-2-探索遵循这些原则的一个示例场景"><a href="#%E6%8E%A2%E7%B4%A2%E9%81%B5%E5%BE%AA%E8%BF%99%E4%BA%9B%E5%8E%9F%E5%88%99%E7%9A%84%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B%E5%9C%BA%E6%99%AF"></a>1.6.5.1.2. 探索遵循这些原则的一个示例场景</h2>
<p>某团队想要通过 Terraform 创建一套包含 Web 层应用、App 层应用的基础设施。</p>
<p>他们想要使用一个专用的 VPC，并遵循传统的三层架构设计。他们的 Web 层应用需要一个自动伸缩组（AutoScaling Group）。他们的 App 层服务需要一个自动伸缩组，一个 S3 存储桶以及一个数据库。下面的架构图描述了期望的结果：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504165650.png" alt=""></p>
<p>该场景中，一个负责从零开始撰写 Terraform 代码的团队，负责编写一组用以配置基础设施及应用的模块。负责应用程序的团队成员将使用这些模块来配置他们需要的基础设施。</p>
<p><strong>请注意</strong>，虽然该示例使用了 AWS 命名，但所描述的模式适用于所有云平台。</p>
<p>经过对应用程序团队的需求进行审核，模块团队将该应用基础设施分割成如下模块：网络、Web、App、数据库、路由，以及安全。</p>
<p>当 Terraform 模块团队完成模块开发后，他们应该将模块导入到私有模块注册表中，并且向对应的团队成员宣传模块的使用方法。举例来说，负责网络的团队成员将会使用开发的网络模块来部署和配置相应的应用程序网络。</p>
<h3 id="1-6-5-1-2-1-网络模块"><a href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97"></a>1.6.5.1.2.1. 网络模块</h3>
<p>网络模块负责网络基础设施。它包含了网络访问控制列表（ACL）以及 NAT 网关。它也可以包含应用程序所需的 VPC、子网、对等连接以及 Direct Connect 等。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170456.png" alt=""></p>
<p>该模块包含这些资源是因为它们<strong>需要特定权限</strong>并且<strong>变化频率较低</strong>。</p>
<ol>
<li>只有应用程序团队中有权创建或修改网络资源的成员可以使用该模块。</li>
<li>该模块的资源不会经常变更。将它们组合在单独的模块中可以保护它们免于暴露在没有必要的数据丢失的风险之中。</li>
</ol>
<p>网络模块返回一组其他工作区（Workspace）以及模块可以使用的输出值。如果 VPC 的创建过程是由多个方面组成的，我们可能最终会需要将该模块进一步切割成拥有不同功能的不同模块。</p>
<h3 id="1-6-5-1-2-2-应用程序模块"><a href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97"></a>1.6.5.1.2.2. 应用程序模块</h3>
<p>本场景中有两个应用程序模块 —— 一个是 Web 层模块，另一个是 App 层模块。</p>
<p>Terraform 模块团队完成这两个模块的开发后，它们应被分发给对应的团队成员来部署他们的应用。随着应用程序团队的成员变得越来越熟悉 Terraform 代码，它们可以提出基础设施方面的增强建议，或是通过 Pull Request 配合他们自己的应用代码发布提交对基础设施的变更请求。</p>
<h4 id="Web-模块"><a href="#web-%E6%A8%A1%E5%9D%97"></a>Web 模块</h4>
<p>Web 模块创建和管理运行 Web 应用程序所需的基础设施。它包含了负载均衡器和自动伸缩组，同时也可以包含应用程序中使用的 EC2 虚拟机实例、S3 存储桶、安全组，以及日志系统。该模块接收一个通过 Packer 预构建的包含最新 Web 层应用发布版本代码的虚拟机镜像的 AMI ID 作为输入。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170534.png" alt=""></p>
<p>该模块包含这些资源是因为它们是<strong>高度封装</strong>的，并且它们<strong>变化频率较高</strong>。</p>
<ol>
<li>此模块中的资源高度内聚，并且与 Web 应用程序紧密相关（例如，此模块需要一个包含最新 Web 层应用程序代码版本的 AMI）。结果就是它们被编制进同一个模块，这样 Web 应用团队的成员们就可以轻松地部署它们。</li>
<li>该模块的资源变更频率较高（每次发布更新版本都需要更新对应基础设施资源）。通过将它们组合在单独的模块中，我们降低了将其他模块的资源暴露在没有必要的数据丢失的风险中的可能性。</li>
</ol>
<h4 id="App-模块"><a href="#app-%E6%A8%A1%E5%9D%97"></a>App 模块</h4>
<p>App 模块创建和管理运行 App 层应用所需的基础设施。它包含了负载均衡器和自动伸缩组，同时也包含了应用程序中使用的 EC2 虚拟机实例、S3 存储桶、安全组，以及日志系统。该模块接收一个通过 Packer 预构建的包含最新 App 层应用发布版本代码的虚拟机镜像的 AMI ID 作为输入。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170602.png" alt=""></p>
<p>该模块包含这些资源是因为它们是<strong>高度封装</strong>的，并且它们<strong>变化频率较高</strong>。</p>
<ol>
<li>此模块中的资源高度内聚，并且与 App 应用程序紧密相关。结果就是它们被编制进同一个模块，这样 App 层应用团队的成员们就可以轻松地部署它们。</li>
<li>该模块的资源变更频率较高（每次发布更新版本都需要更新对应基础设施资源）。通过将它们组合在单独的模块中，我们降低了将其他模块的资源暴露在没有必要的数据丢失的风险中的可能性。</li>
</ol>
<h4 id="数据库模块"><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9D%97"></a>数据库模块</h4>
<p>数据库模块创建并管理了运行数据库所需的基础设施资源。它包含了应用程序所需的 RDS 实例，也包含了所有关联的存储、备份以及日志资源。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170632.png" alt=""></p>
<p>该模块包含这些资源是因为它们<strong>需要特定权限</strong>并且<strong>变化频率较低</strong>。</p>
<ol>
<li>只有应用程序团队中有权创建或修改数据库资源的成员可以使用该模块。</li>
<li>该模块的资源不会经常变更。将它们组合在单独的模块中可以保护它们免于暴露在没有必要的数据丢失的风险之中。</li>
</ol>
<h4 id="路由模块"><a href="#%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%9D%97"></a>路由模块</h4>
<p>路由模块创建并管理网络路由所需的基础设施资源。它包含了公共托管区域（Hosted Zone）、Route 53 以及路由表，也可以包含私有托管区域。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170657.png" alt=""></p>
<p>该模块包含这些资源是因为它们<strong>需要特定权限</strong>并且<strong>变化频率较低</strong>。</p>
<ol>
<li>只有应用程序团队中有权创建或修改路由资源的成员可以使用该模块。</li>
<li>该模块的资源不会经常变更。将它们组合在单独的模块中可以保护它们免于暴露在没有必要的数据丢失的风险之中。</li>
</ol>
<h4 id="安全模块"><a href="#%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9D%97"></a>安全模块</h4>
<p>安全模块创建并管理所有安全所需的基础设施资源。它包含一组 IAM 资源，也可以包含安全组（Security Group）及多因素认证（MFA）。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170717.png" alt=""></p>
<p>该模块包含这些资源是因为它们<strong>需要特定权限</strong>并且<strong>变化频率较低</strong>。</p>
<ol>
<li>只有应用程序团队中有权创建或修改 IAM 或是安全资源的成员可以使用该模块。</li>
<li>该模块的资源不会经常变更。将它们组合在单独的模块中可以保护它们免于暴露在没有必要的数据丢失的风险之中。</li>
</ol>
<h2 id="1-6-5-1-3-创建模块的提示"><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97%E7%9A%84%E6%8F%90%E7%A4%BA"></a>1.6.5.1.3. 创建模块的提示</h2>
<p>除了范围界定之外，我们在创建模块时还应牢记以下几点：</p>
<h3 id="1-6-5-1-3-1-嵌套模块"><a href="#%E5%B5%8C%E5%A5%97%E6%A8%A1%E5%9D%97"></a>1.6.5.1.3.1. 嵌套模块</h3>
<p>嵌套模块是指在当前模块中对另一个模块的引用。嵌套模块可以是外部的，也可以是当前工作空间内的。使用嵌套模块是一项强大的功能；然而我们必须谨慎实践以避免引入错误。</p>
<p>对于所有类型的嵌套模块，请考虑以下事项：</p>
<ul>
<li>嵌套模块可以加速开发速度，但可能会引发未知以及意料之外的结果。请在文档中清晰地记录输入变量、模块行为以及输出值。</li>
<li>通常来说，不要让主模块的嵌套深度超过两层。常用且简单的工具模块，例如专门用来定义 Tag 的模块，则不受此限制制约。</li>
<li>嵌套模块必须包含必要的用来创建指定的资源配置的输入参数以及输出值。</li>
<li>输入参数以及输出值的命名应遵循一致的命名约定，以使得模块可以更容易地被分享，以及将一个模块的的输出值作为另一个模块的输入参数。</li>
<li>嵌套模块可能会导致代码冗余。必须同时在父模块与嵌套模块中声明输入参数和输出值。</li>
</ul>
<h4 id="嵌套的外部模块"><a href="#%E5%B5%8C%E5%A5%97%E7%9A%84%E5%A4%96%E9%83%A8%E6%A8%A1%E5%9D%97"></a>嵌套的外部模块</h4>
<p>当我们需要使用那些定义了被多个应用程序堆栈、应用程序和团队复用的标准化资源的通用模块时，嵌套的外部模块会很有用。外部模块通被集中管理和版本化控制，以使得消费者在使用新版本之前可以对其进行验证。当我们依赖或希望使用位于外部的子模块时，请注意以下几点：</p>
<ul>
<li>外部模块必须被独立维护，并可供任何需要调用它的模块使用。使用模块注册表可以确保这一点。</li>
<li>根据模块注册要求，嵌套模块将拥有自己的版本控制代码仓库，独立于调用模块进行版本控制。</li>
<li>对嵌套模块的变更可能会影响调用模块，即使调用模块的调用代码及版本没有发生变化，这会破坏调用代码的信任。</li>
<li>对调用模块如何使用外部模块在文档中进行记录，使得模块行为以及调用关系可以被轻松理解。</li>
<li>对外部模块的变更应该是向后兼容的。如果向后兼容是不可能的，则应清楚地记录需要对任何调用模块进行的更改，并将之分发给所有模块使用者以避免意外。</li>
</ul>
<h4 id="嵌套的嵌入模块"><a href="#%E5%B5%8C%E5%A5%97%E7%9A%84%E5%B5%8C%E5%85%A5%E6%A8%A1%E5%9D%97"></a>嵌套的嵌入模块</h4>
<p>在当前工作空间中嵌入一个模块使得我们能够清晰地分离模块的逻辑组件，或是创建可在调用模块执行期间多次调用的可重用代码块。在下面的例子中，<code>ec2-instance</code> 是一个嵌入模块，根模块的 <code>main.tf</code> 引用了该模块：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root-module-directory</span><br><span class="line">├── README.md</span><br><span class="line">├── main.tf</span><br><span class="line">└── ec2-instances</span><br><span class="line">    └── main.tf</span><br></pre></td></tr></table></figure>
<p>如果我们需要或者倾向于使用嵌入模块，需要考虑以下几点：</p>
<ul>
<li>在“根模块”中添加嵌入模块意味着子模块与根模块被放在一起进行版本控制。</li>
<li>任何影响两个模块间兼容性的变更都会被快速发现，因为它们必须被一同测试和发布。</li>
<li>（嵌入的）子模块不能被代码树之外的其他模块调用，所以可能会增加重复的代码。举例来说，如果嵌入的 <code>ec2-instance</code> 模块是用来创建一台被用在多个地方的标准化的计算实例，该模块<strong>无法</strong>以这种形式被分享。</li>
</ul>
<h4 id="标签化模块名并记录在文档中"><a href="#%E6%A0%87%E7%AD%BE%E5%8C%96%E6%A8%A1%E5%9D%97%E5%90%8D%E5%B9%B6%E8%AE%B0%E5%BD%95%E5%9C%A8%E6%96%87%E6%A1%A3%E4%B8%AD"></a>标签化模块名并记录在文档中</h4>
<p>为我们的模块创建并遵循一个命名约定将使得模块易于理解与使用。这将促进模块的采用和贡献。以下是一个用以提升模块元素一致性的建议列表：</p>
<ul>
<li>使用一个对人类来说一致且易于理解的模块命名约定。举例来说：</li>
</ul>
<table>
<thead>
<tr>
<th>terraform</th>
<th>cloud provider</th>
<th>function</th>
<th>full name</th>
</tr>
</thead>
<tbody>
<tr>
<td>terraform</td>
<td>aws</td>
<td>consul cluster</td>
<td><code>terraform-aws-consul_cluser</code></td>
</tr>
<tr>
<td>terraform</td>
<td>aws</td>
<td>security module</td>
<td><code>terraform-aws-security</code></td>
</tr>
<tr>
<td>terraform</td>
<td>azure</td>
<td>database</td>
<td><code>terraform-azure-database</code></td>
</tr>
</tbody>
</table>
<ul>
<li>使用人类可以理解的输入变量命名约定。模块是编写一次并多次使用的代码，因此请完整命名所有内容以提升可读性，并在编写代码时在文档中进行记录。</li>
<li>对所有模块进行文档记录。确保文档中包含有：
<ul>
<li>必填的输入变量：这些输入变量应该是经过深思熟虑后的选择。如果这些输入变量值未定义，模块运行将失败。只在必要时为这些输入变量设置默认值。例如 <code>var.vpc_id</code> 永远不应该有默认值，因为每次使用模块时值都会不同。</li>
<li>可选的输入变量：这些输入变量应该有一个合理的，适用于大多数场景的默认值，同时又可以根据需求进行调整。公告输入变量的默认值。例如 <code>var.elb_idle_timeout</code> 会有一个合理的默认值，但调用者也可以根据需求修改它的值。</li>
<li>输出值：列出模块的所有输出值，并将重要的输出和信息性的输出包装在对用户友好的输出模板中。</li>
</ul>
</li>
</ul>
<h4 id="定义并使用一个一致的模块结构"><a href="#%E5%AE%9A%E4%B9%89%E5%B9%B6%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E4%B8%80%E8%87%B4%E7%9A%84%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84"></a>定义并使用一个一致的模块结构</h4>
<p>虽然模块结构是一个品味问题，我们应当将模块的结构记录在文档中，并且在我们的所有模块之间保持统一的结构。为了要维持模块结构的一致：</p>
<ul>
<li>定义一组模块必须包含的 <code>.tf</code> 文件，定义它们应包含哪些内容</li>
<li>为模块定义一个 <code>.gitignore</code>(或类似作用的)文件</li>
<li>创建供样例代码所使用的输入变量值的标准方式（例如一个 <code>terraform.tfvars.example</code> 文件）</li>
<li>使用具有固定子目录的一致的目录结构，即使它们可能是空的</li>
<li>所有模块目录都必须包含一个 <code>README</code> 文件详细记述目录存在的目的以及如何使用其中的文件</li>
</ul>
<h2 id="1-6-5-1-4-模块的协作"><a href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8D%8F%E4%BD%9C"></a>1.6.5.1.4. 模块的协作</h2>
<p>随着团队模块的开发工作，简化我们的协作。</p>
<ol>
<li>为每个模块创建路线图</li>
<li>从用户处收集需求信息，并按受欢迎程度进行优先级排序。
<ul>
<li>不使用模块的最常见原因是“它不符合我的要求”。收集这些需求并将它们添加到路线图或对用户的工作流程提出建议。</li>
<li>检查每一项需求以确认它引用的用例是否正确。</li>
<li>公布和维护需求列表。分享该列表并让用户参与列表管理过程。</li>
<li>不要为边缘用例排期。</li>
</ul>
</li>
<li>将每一个决策记录进文档。</li>
<li>在公司内部采用开源社区原则。一些用户希望尽可能高效地使用这些模块，而另一些用户则希望帮助创建这些模块。
<ul>
<li>创建一个社区</li>
<li>维护一份清晰和公开的贡献指引</li>
<li>最终，我们将允许可信的社区成员获得某些模块的所有权</li>
</ul>
</li>
</ol>
<h2 id="1-6-5-1-5-使用源代码控制系统追踪模块"><a href="#%E4%BD%BF%E7%94%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E8%BF%BD%E8%B8%AA%E6%A8%A1%E5%9D%97"></a>1.6.5.1.5. 使用源代码控制系统追踪模块</h2>
<p>一个 Terraform 模块应遵守所有良好的代码实践：</p>
<ul>
<li>将模块置于源代码控制中以管理版本发布、协作、变更的审计跟踪。</li>
<li>为所有 <code>main</code> 分支的发布版本建立版本标签，记录文档（最起码在 <code>CHANGELOG</code> 及 <code>README</code> 中记录）。</li>
<li>对 <code>main</code> 分支的所有变更进行代码审查</li>
<li>鼓励模块的用户通过版本标签引用模块</li>
<li>为每一个模块指派一位负责人</li>
<li>一个代码仓库只负责一个模块
<ul>
<li>这对于模块的幂等性和作为库的功能至关重要。</li>
<li>我们应该对模块打上版本标签或是版本化控制。打上版本标签或是版本化的模块应该是不可变的。</li>
<li>发布到私有模块注册表的模块必须要有版本标签。</li>
</ul>
</li>
</ul>
<h2 id="1-6-5-1-6-开发一套模块消费工作流"><a href="#%E5%BC%80%E5%8F%91%E4%B8%80%E5%A5%97%E6%A8%A1%E5%9D%97%E6%B6%88%E8%B4%B9%E5%B7%A5%E4%BD%9C%E6%B5%81"></a>1.6.5.1.6. 开发一套模块消费工作流</h2>
<p>定义和宣传一套消费者团队使用模块时应遵循的可重复工作流程。这个工作流程，就像模块本身一样，应该考虑到用户的需求。</p>
<h3 id="1-6-5-1-6-1-阐明团队应该如何使用模块"><a href="#%E9%98%90%E6%98%8E%E5%9B%A2%E9%98%9F%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97"></a>1.6.5.1.6.1. 阐明团队应该如何使用模块</h3>
<ul>
<li><strong>分散的安全性</strong>：如果每个模块都在自己的存储库中进行版本控制，则可以使用存储库 RBAC 来管理谁拥有写访问权限，从而允许相关团队管理相关的基础设施（例如网络团队拥有对网络模块的写访问权限）。</li>
<li><strong>培育代码社区</strong>：鉴于上述建议，模块开发的最佳实践是允许对存储在私有模块存储库中的模块的所有模块存储库提出 Pull Request。这促进了组织内的代码社区，保持模块内容的相关性和最大的灵活性，并有助于保持模块注册表的长期有效性。</li>
</ul>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">標籤</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="../../../../../tags/Terraform/" rel="tag">Terraform</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../26/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C1/"
                    data-tooltip="Terraform-命令行1"
                    aria-label="上一篇: Terraform-命令行1"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../21/Teraform/Terraform-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/"
                    data-tooltip="Terraform 文件与目录"
                    aria-label="下一篇: Terraform 文件与目录"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2023/01/23/Teraform/Terraform-%E6%A8%A1%E5%9D%97/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2023/01/23/Teraform/Terraform-%E6%A8%A1%E5%9D%97/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2023/01/23/Teraform/Terraform-%E6%A8%A1%E5%9D%97/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2023/01/23/Teraform/Terraform-%E6%A8%A1%E5%9D%97/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../26/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C1/"
                    data-tooltip="Terraform-命令行1"
                    aria-label="上一篇: Terraform-命令行1"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="../../../21/Teraform/Terraform-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/"
                    data-tooltip="Terraform 文件与目录"
                    aria-label="下一篇: Terraform 文件与目录"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2023/01/23/Teraform/Terraform-%E6%A8%A1%E5%9D%97/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2023/01/23/Teraform/Terraform-%E6%A8%A1%E5%9D%97/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2023/01/23/Teraform/Terraform-%E6%A8%A1%E5%9D%97/"
                    title="global.share_on_linkedin"
                    aria-label="global.share_on_linkedin"
                >
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2023/01/23/Teraform/Terraform-%E6%A8%A1%E5%9D%97/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://chankein.github.io/2023/01/23/Teraform/Terraform-%E6%A8%A1%E5%9D%97/"
                        aria-label="分享到 Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://chankein.github.io/2023/01/23/Teraform/Terraform-%E6%A8%A1%E5%9D%97/"
                        aria-label="分享到 Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://chankein.github.io/2023/01/23/Teraform/Terraform-%E6%A8%A1%E5%9D%97/"
                        aria-label="global.share_on_linkedin"
                    >
                        <i class="fab fa-linkedin" aria-hidden="true"></i><span>global.share_on_linkedin</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=https://chankein.github.io/2023/01/23/Teraform/Terraform-%E6%A8%A1%E5%9D%97/"
                        aria-label="分享到 Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 211 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
