
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"Website","@id":"https://chankein.github.io","author":{"@type":"Person","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg"},"name":"Kein's blog","description":"","url":"https://chankein.github.io"}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Kein&#39;s blog">
<meta property="og:url" content="https://chankein.github.io/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Kein Chan">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.ioassets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: /#about"
            >
        
        
            <img class="header-picture" src="assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="2017/08/12/git/git%E6%95%99%E7%A8%8B/"
                            aria-label=": git教程"
                        >
                            git教程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-08-12T15:38:45+08:00">
	
		    2017 年 8 月 12 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="categories/devops/">devops</a>, <a class="category-link" href="categories/devops/git/">git</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h5 id="初始化仓库">初始化仓库:</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m &#x27;initial project version&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="/assets/images/fileStatusLifecycle.png" alt="image"></p>
<h5 id="忽略某些文件">忽略某些文件</h5>
<p>我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。<br>
文件 .gitignore 的格式规范如下：</p>
<ul>
<li>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式最后跟反斜杠（/）说明要忽略的是目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li>
</ul>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。</p>
<p>我们再看一个 .gitignore 文件的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line"># 忽略所有 .a 结尾的文件</span><br><span class="line">*.a</span><br><span class="line"># 但 lib.a 除外</span><br><span class="line">!lib.a</span><br><span class="line"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"># 忽略 build/ 目录下的所有文件</span><br><span class="line">build/</span><br><span class="line"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"># 忽略 doc/ 目录下所有扩展名为 txt 的文件</span><br><span class="line">doc/**/*.txt</span><br></pre></td></tr></table></figure>
<h5 id="跟踪新文件">跟踪新文件</h5>
<p>使用命令 git add 开始跟踪一个新文件。所以，要跟踪 README 文件，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add README</span><br></pre></td></tr></table></figure>
<h5 id="提交更新">提交更新</h5>
<p>每次准备提交前，先用 git status 看下，是不是都已暂存起来了，然后再运行提交命令 git commit：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></table></figure>
<p>这种方式会启动文本编辑器以便输入本次提交的说明。（默认会启用 shell 的环境变量 $EDITOR 所指定的软件，一般都是 vim 或 emacs。当然也可以按照第一章介绍的方式，使用 ++git config --global core.editor++ 命令设定你喜欢的编辑软件。）</p>
<p>默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。（如果觉得这还不够，可以用 -v 选项将修改差异的每一行都包含到注释中来。）退出编辑器时，Git 会丢掉注释行，将说明内容和本次更新提交到仓库。</p>
<p>另外也可以用 +±m++ 参数后跟提交说明的方式，在一行命令中提交更新：</p>
<p>跳过使用暂存区域<br>
Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 <strong>git commit 加上 -a</strong> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤</p>
<h5 id="移除文件">移除文件</h5>
<p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 <strong>git rm</strong> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p>
<h5 id="移动文件">移动文件</h5>
<p>要在 Git 中对文件改名，可以这么做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mv file_from file_to</span><br></pre></td></tr></table></figure>
<p>运行 git mv 就相当于运行了下面三条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv README.txt README</span><br><span class="line">$ git rm README.txt</span><br><span class="line">$ git add README</span><br></pre></td></tr></table></figure>
<h5 id="查看提交历史">查看提交历史</h5>
<p>默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。看到了吗，每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间，最后缩进一个段落显示提交说明。</p>
<p>git log 有许多选项可以帮助你搜寻感兴趣的提交，接下来我们介绍些最常用的。</p>
<p>我们常用 -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新</p>
<p>某些时候，单词层面的对比，比行层面的对比，更加容易观察。Git 提供了 +±-word-diff++ 选项。我们可以将其添加到 ++git log -p++ 命令的后面，从而获取单词层面上的对比。在程序代码中进行单词层面的对比常常是没什么用的。不过当你需要在书籍、论文这种很大的文本文件上进行对比的时候，这个功能就显出用武之地了。</p>
<p>另外，git log 还提供了许多摘要选项可以用，比如 --stat，仅显示简要的增改行数统计</p>
<p>用 oneline 或 format 时结合 --graph 选项，可以看到开头多出一些 ASCII 字符串表示的简单图形，形象地展示了每个提交所在的分支及其分化衍合情况。</p>
<p>另外还有按照时间作限制的选项，比如 --since 和 --until。</p>
<h5 id="撤消操作">撤消操作</h5>
<p>有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用 --amend 选项重新提交：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%92%A4%E6%B6%88%E6%93%8D%E4%BD%9C">撤消操作</a></p>
<h5 id="远程仓库的使用">远程仓库的使用</h5>
<p>查看当前的远程库<br>
要查看当前配置有哪些远程仓库，可以用 git remote 命令，它会列出每个远程库的简短名字。<br>
也可以加上 -v 选项（译注：此为 --verbose 的简写，取首字母），显示对应的克隆地址</p>
<p>添加远程仓库</p>
<p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add [shortname] [url]：</span><br></pre></td></tr></table></figure>
<p>现在可以用字符串 pb 指代对应的仓库地址了。比如说，要抓取所有 Paul 有的，但本地仓库没有的信息，可以运行 git fetch pb</p>
<p>从远程仓库抓取数据</p>
<p>正如之前所看到的，可以用下面的命令从远程仓库抓取数据到本地：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch [remote-name]</span><br></pre></td></tr></table></figure>
<p>推送数据到远程仓库</p>
<p>目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库中的数据推送到远程仓库。实现这个任务的命令很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [remote-name] [branch-name]。</span><br></pre></td></tr></table></figure>
<p>如果要把本地的 master 分支推送到 origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<p>查看远程仓库信息<br>
我们可以通过命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show [remote-name]</span><br></pre></td></tr></table></figure>
<p>查看某个远程仓库的详细信息</p>
<p>远程仓库的删除和重命名<br>
在新版 Git 中可以用 git remote rename 命令修改某个远程仓库在本地的简称，比如想把 pb 改成 paul，可以这么运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure>
<p>碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
<h5 id="打标签">打标签</h5>
<p><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE/">打标签</a></p>
<h5 id="Git-命令别名">Git 命令别名</h5>
<p>Git 并不会推断你输入的几个字符将会是哪条命令，不过如果想偷懒，少敲几个命令的字符，可以用 git config 为命令设置别名。来看看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure>
<p>取消暂存文件时的输入比较繁琐，可以自己设置一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.unstage &#x27;reset HEAD --&#x27;</span><br></pre></td></tr></table></figure>
<p>这样一来，下面的两条命令完全等同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git unstage fileA</span><br><span class="line">$ git reset HEAD fileA</span><br></pre></td></tr></table></figure>
<p>显然，使用别名的方式看起来更清楚。另外，我们还经常设置 last 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.last &#x27;log -1 HEAD&#x27;</span><br></pre></td></tr></table></figure>
<p>然后要看最后一次的提交信息，就变得简单多了</p>
<h5 id="分支的新建与切换">分支的新建与切换</h5>
<p>要新建并切换到该分支，运行 git checkout 并加上 -b 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b iss53</span><br><span class="line">Switched to a new branch &#x27;iss53&#x27;</span><br></pre></td></tr></table></figure>
<p>回到 master 分支并把它合并进来，然后发布到生产服务器。用 git merge 命令来进行合并：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge hotfix</span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> README | 1 -</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br></pre></td></tr></table></figure>
<p>这相当于执行下面这两条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch iss53</span><br><span class="line">$ git checkout iss53</span><br></pre></td></tr></table></figure>
<p>如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。</p>
<p>合并之后，master 分支和 hotfix 分支指向同一位置。<br>
由于当前 hotfix 分支和 master 都指向相同的提交对象，所以 hotfix 已经完成了历史使命，可以删掉了。使用 git branch 的 -d 选项执行删除操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d hotfix</span><br><span class="line">Deleted branch hotfix (was 3a0874c).</span><br></pre></td></tr></table></figure>
<h5 id="遇到冲突时的分支合并">遇到冲突时的分支合并</h5>
<p>有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）。<br>
Git 作了合并，但没有提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用 <strong>git status</strong> 查阅</p>
<p>任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line">=======</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">  please contact us at support@github.com</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53</span><br></pre></td></tr></table></figure>
<p>可以看到 ======= 隔开的上半部分，是 HEAD（即 master 分支，在运行 merge 命令时所切换到的分支）中的内容，下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">please contact us at email.support@github.com</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>这个解决方案各采纳了两个分支中的一部分内容，而且我还删除了 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，======= 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行。在解决了所有文件里的所有冲突后，运行 git add 将把它们标记为已解决状态（译注：实际上就是来一次快照保存到暂存区域。）。</p>
<p>再运行一次 git status 来确认所有冲突都已解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   index.html</span><br></pre></td></tr></table></figure>
<p>如果觉得满意了，并且确认所有冲突都已解决，也就是进入了暂存区，就可以用 git commit 来完成这次合并提交。提交的记录差不多是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Merge branch &#x27;iss53&#x27;</span><br><span class="line"></span><br><span class="line">Conflicts:</span><br><span class="line">  index.html</span><br><span class="line">#</span><br><span class="line"># It looks like you may be committing a merge.</span><br><span class="line"># If this is not correct, please remove the file</span><br><span class="line">#       .git/MERGE_HEAD</span><br><span class="line"># and try again.</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<h5 id="查看当前的远程库">查看当前的远程库</h5>
<p>要查看当前配置有哪些远程仓库，可以用 git remote 命令，它会列出每个远程库的简短名字。<br>
可以加上 -v 选项（译注：此为 --verbose 的简写，取首字母），显示对应的克隆地址</p>
<h5 id="添加远程仓库">添加远程仓库</h5>
<p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add [shortname] [url]：</span><br></pre></td></tr></table></figure>
<h5 id="从远程仓库抓取数据">从远程仓库抓取数据</h5>
<p>正如之前所看到的，可以用下面的命令从远程仓库抓取数据到本地：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch [remote-name]</span><br></pre></td></tr></table></figure>
<p>推送数据到远程仓库<br>
项目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库中的数据推送到远程仓库。实现这个任务的命令很简单： git push [remote-name] [branch-name]。如果要把本地的 master 分支推送到 origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<p>只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。</p>
<p>查看远程仓库信息<br>
我们可以通过命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show [remote-name]</span><br></pre></td></tr></table></figure>
<p>查看某个远程仓库的详细信息</p>
<h1></h1>
<p>远程仓库的删除和重命名<br>
在新版 Git 中可以用 git remote rename 命令修改某个远程仓库在本地的简称，比如想把 pb 改成 paul，可以这么运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure>
<p>注意，对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 pb/master 分支现在成了 paul/master。</p>
<p>碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
<h5 id="远程分支">远程分支</h5>
<p>我们用 ==(远程仓库名)/(分支名)== 这样的形式表示远程分支。比如我们想看看上次同 origin 仓库通讯时 master 分支的样子，就应该查看 origin/master 分支。如果你和同伴一起修复某个问题，但他们先推送了一个 iss53 分支到远程仓库，虽然你可能也有一个本地的 iss53 分支，但指向服务器上最新更新的却应该是 origin/iss53 分支。</p>
<p>可以运行 git fetch origin 来同步远程服务器上的数据到本地。该命令首先找到 origin 是哪个服务器（本例为 <a target="_blank" rel="noopener" href="http://git.ourcompany.com">git.ourcompany.com</a>），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 origin/master 的指针移到它最新的位置上<br>
<img src="/assets/images/gitfetch.png" alt="image"></p>
<p>为了演示拥有多个远程分支（在不同的远程服务器上）的项目是如何工作的，我们假设你还有另一个仅供你的敏捷开发小组使用的内部服务器 <a target="_blank" rel="noopener" href="http://git.team1.ourcompany.com">git.team1.ourcompany.com</a>。可以用第二章中提到的 git remote add 命令把它加为当前项目的远程分支之一。我们把它命名为 teamone，以便代替完整的 Git URL 以方便使用<br>
<img src="/assets/images/gitaddremote.png" alt="image"><br>
现在你可以用 git fetch teamone 来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你 origin 服务器上的子集，Git 不会下载任何数据，而只是简单地创建一个名为 teamone/master 的远程分支，指向 teamone 服务器上 master 分支所在的提交对象 31b8e（见图 3-26）。</p>
<p><img src="/assets/images/gitfetchremote.png" alt="image"></p>
<h5 id="推送本地分支">推送本地分支</h5>
<p>要想和其他人分享某个本地分支，你需要把它推送到一个你拥有写权限的远程仓库。你创建的本地分支不会因为你的写入操作而被自动同步到你引入的远程服务器上，你需要明确地执行推送分支的操作。</p>
<p>如果你有个叫 serverfix 的分支需要和他人一起开发，可以运行 git push (远程仓库名) (分支名)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin serverfix</span><br><span class="line">Counting objects: 20, done.</span><br><span class="line">Compressing objects: 100% (14/14), done.</span><br><span class="line">Writing objects: 100% (15/15), 1.74 KiB, done.</span><br><span class="line">Total 15 (delta 5), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new branch]      serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure>
<p>这里其实走了一点捷径。Git 自动把 serverfix 分支名扩展为 refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的 serverfix 分支，推送到远程仓库的 serverfix 分支中去”。</p>
<p>也可以运行 ==git push origin serverfix:serverfix== 来实现相同的效果，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作 awesomebranch，可以用 git push origin serverfix:awesomebranch 来推送数据。</p>
<h5 id="跟踪远程分支">跟踪远程分支</h5>
<p>从远程分支 checkout 出来的本地分支，称为 跟踪分支 (tracking branch)。跟踪分支是一种和某个远程分支有直接联系的本地分支。在跟踪分支里输入 git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。同样，在这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来。</p>
<p>在克隆仓库时，Git 通常会自动创建一个名为 master 的分支来跟踪 origin/master。这正是 git push 和 git pull 一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如 origin 上除了 master 之外的其它分支。刚才我们已经看到了这样的一个例子：git checkout -b [分支名] [远程名]/[分支名]。如果你有 1.6.2 以上版本的 Git，还可以用 --track 选项简化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout --track origin/serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;serverfix&#x27;</span><br></pre></td></tr></table></figure>
<p>要为本地分支设定不同于远程分支的名字，只需在第一个版本的命令里换个名字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b sf origin/serverfix</span><br><span class="line">Branch sf set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;sf&#x27;</span><br></pre></td></tr></table></figure>
<p>现在你的本地分支 sf 会自动将推送和抓取数据的位置定位到 origin/serverfix 了</p>
<h5 id="删除远程分支">删除远程分支</h5>
<p>如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的 master 分支（或任何其他存放稳定代码的分支），可以用这个非常无厘头的语法来删除它：git push [远程名] :[分支名]。如果想在服务器上删除 serverfix 分支，运行下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :serverfix</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure>
<p>咚！服务器上的分支没了。你最好特别留心这一页，因为你一定会用到那个命令，而且你很可能会忘掉它的语法。有种方便记忆这条命令的方法：==记住我们不久前见过的 git push [远程名] [本地分支]:[远程分支] 语法，如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]”==。</p>
<h5 id="解决远程分支和本地冲突">解决远程分支和本地冲突</h5>
<p>1.先将本地修改储存起来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
<p>2.pull内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>
<p>3.还原暂存内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>
<p>4.解决冲突</p>
<p>5.提交</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#x27;&#x27;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>打标签</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.1 -m &#x27;&#x27;</span><br></pre></td></tr></table></figure>
<p>7.列标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -l</span><br></pre></td></tr></table></figure>
<p>8.获取标签代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout </span><br></pre></td></tr></table></figure>
<p>9.提交标签到远程端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push tag </span><br></pre></td></tr></table></figure>
<h5 id="拉取本地没有的远程分支">拉取本地没有的远程分支</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 本地分支名 origin/远程分支名</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E5%8F%98%E5%9F%BA/">后续:变基rebase</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="2017/08/12/git/git%E6%95%99%E7%A8%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="2025/06/01/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E4%B9%8B-A-%E7%AE%97%E6%B3%95/"
                            aria-label=": 路径规划之 A* 算法"
                        >
                            路径规划之 A* 算法
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-06-01T15:46:52+08:00">
	
		    2025 年 6 月 1 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="categories/%E7%AE%97%E6%B3%95/">算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>A*（念做：A Star）算法是一种很常用的路径查找和图形遍历算法。它有较好的性能和准确度。本文在讲解算法的同时也会提供Python语言的代码实现，并会借助matplotlib库动态的展示算法的运算过程。</p>
<ul>
<li><a href="#id-%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D">算法介绍</a></li>
<li><a href="#id-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">广度优先搜索</a></li>
<li><a href="#id-dijkstra%E7%AE%97%E6%B3%95">Dijkstra算法</a></li>
<li><a href="#id-%E6%9C%80%E4%BD%B3%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">最佳优先搜索</a></li>
<li><a href="#id-a%E7%AE%97%E6%B3%95">A*算法</a>
<ul>
<li><a href="#id-%E5%90%AF%E5%8F%91%E5%87%BD%E6%95%B0">启发函数</a></li>
<li><a href="#id-%E5%85%B3%E4%BA%8E%E8%B7%9D%E7%A6%BB">关于距离</a>
<ul>
<li><a href="#id-%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB">曼哈顿距离</a></li>
<li><a href="#id-%E5%AF%B9%E8%A7%92%E8%B7%9D%E7%A6%BB">对角距离</a></li>
<li><a href="#id-%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E8%B7%9D%E7%A6%BB">欧几里得距离</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#id-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0">算法实现</a>
<ul>
<li><a href="#id-%E5%9D%90%E6%A0%87%E7%82%B9%E4%B8%8E%E5%9C%B0%E5%9B%BE">坐标点与地图</a></li>
<li><a href="#id-%E7%AE%97%E6%B3%95%E4%B8%BB%E4%BD%93">算法主体</a></li>
<li><a href="#id-%E6%B5%8B%E8%AF%95%E5%85%A5%E5%8F%A3">测试入口</a></li>
</ul>
</li>
<li><a href="#id-%E7%AE%97%E6%B3%95%E5%8F%98%E7%A7%8D">算法变种</a>
<ul>
<li><a href="#id-ara">ARA*</a></li>
<li><a href="#id-d">D*</a></li>
<li><a href="#id-field-d">Field D*</a></li>
<li><a href="#id-block-a">Block A*</a></li>
</ul>
</li>
<li><a href="#id-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E4%B8%8E%E6%8E%A8%E8%8D%90%E8%AF%BB%E7%89%A9">参考资料与推荐读物</a></li>
</ul>
<h2 id="算法介绍">算法介绍</h2>
<p>A*算法最初发表于1968年，由Stanford研究院的Peter Hart, Nils Nilsson以及Bertram Raphael发表。它可以被认为是Dijkstra算法的扩展。</p>
<p>由于借助启发函数的引导，A*算法通常拥有更好的性能。</p>
<h2 id="广度优先搜索">广度优先搜索</h2>
<p>为了更好的理解A*算法，我们首先从广度优先（Breadth First）算法讲起。</p>
<p>正如其名称所示，广度优先搜索以广度做为优先级进行搜索。</p>
<p>从起点开始，首先遍历起点周围邻近的点，然后再遍历已经遍历过的点邻近的点，逐步的向外扩散，直到找到终点。</p>
<p>这种算法就像洪水（Flood fill）一样向外扩张，算法的过程如下图所示：</p>
<p><img src="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/breadth_first.gif" alt=""></p>
<p>在上面这幅动态图中，算法遍历了图中所有的点，这通常没有必要。对于有明确终点的问题来说，一旦到达终点便可以提前终止算法，下面这幅图对比了这种情况：</p>
<p><img src="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/early_exit.png" alt=""></p>
<p>在执行算法的过程中，每个点需要记录达到该点的前一个点的位置 – 可以称之为父节点。这样做之后，一旦到达终点，便可以从终点开始，反过来顺着父节点的顺序找到起点，由此就构成了一条路径。</p>
<h2 id="Dijkstra算法">Dijkstra算法</h2>
<p>Dijkstra算法是由计算机科学家<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra">Edsger W. Dijkstra</a>在1956年提出的。</p>
<p>Dijkstra算法用来寻找图形中节点之间的最短路径。</p>
<p>考虑这样一种场景，在一些情况下，图形中相邻节点之间的移动代价并不相等。例如，游戏中的一幅图，既有平地也有山脉，那么游戏中的角色在平地和山脉中移动的速度通常是不相等的。</p>
<p>在Dijkstra算法中，需要计算每一个节点距离起点的总移动代价。同时，还需要一个优先队列结构。对于所有待遍历的节点，放入优先队列中会按照代价进行排序。</p>
<p>在算法运行的过程中，每次都从优先队列中选出代价最小的作为下一个遍历的节点。直到到达终点为止。</p>
<p>下面对比了不考虑节点移动代价差异的广度优先搜索与考虑移动代价的Dijkstra算法的运算结果：</p>
<p><img src="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/dijkstra.gif" alt=""></p>
<blockquote>
<p>当图形为网格图，并且每个节点之间的移动代价是相等的，那么Dijkstra算法将和广度优先算法变得一样。</p>
</blockquote>
<h2 id="最佳优先搜索">最佳优先搜索</h2>
<p>在一些情况下，如果我们可以预先计算出每个节点到终点的距离，则我们可以利用这个信息更快的到达终点。</p>
<p>其原理也很简单。与Dijkstra算法类似，我们也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级，每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点。这种算法称之为最佳优先（Best First）算法。</p>
<p>这样做可以大大加快路径的搜索速度，如下图所示：</p>
<p><img src="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/best_first.gif" alt=""></p>
<p>但这种算法会不会有什么缺点呢？答案是肯定的。</p>
<p>因为，如果起点和终点之间存在障碍物，则最佳优先算法找到的很可能不是最短路径，下图描述了这种情况。</p>
<p><img src="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/best_first_2.gif" alt=""></p>
<h2 id="A-算法">A*算法</h2>
<p>对比了上面几种算法，最后终于可以讲解本文的重点：A*算法了。</p>
<p>下面的描述我们将看到，A*算法实际上是综合上面这些算法的特点于一身的。</p>
<p>A*算法通过下面这个函数来计算每个节点的优先级。</p>
<p>\[f(n) = g(n) + h(n)\]</p>
<p>其中：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 是节点n的综合优先级。当我们选择下一个要遍历的节点时，我们总会选取综合优先级最高（值最小）的节点。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 是节点n距离起点的代价。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 是节点n距离终点的预计代价，这也就是A*算法的启发函数。关于启发函数我们在下面详细讲解。</li>
</ul>
<p>A*算法在运算过程中，每次从优先队列中选取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>值最小（优先级最高）的节点作为下一个待遍历的节点。</p>
<p>另外，A*算法使用两个集合来表示待遍历的节点，与已经遍历过的节点，这通常称之为<code>open_set</code>和<code>close_set</code>。</p>
<p>完整的A*算法描述如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* 初始化open_set和close_set；</span><br><span class="line">* 将起点加入open_set中，并设置优先级为0（优先级最高）；</span><br><span class="line">* 如果open_set不为空，则从open_set中选取优先级最高的节点n：</span><br><span class="line">    * 如果节点n为终点，则：</span><br><span class="line">        * 从终点开始逐步追踪parent节点，一直达到起点；</span><br><span class="line">        * 返回找到的结果路径，算法结束；</span><br><span class="line">    * 如果节点n不是终点，则：</span><br><span class="line">        * 将节点n从open_set中删除，并加入close_set中；</span><br><span class="line">        * 遍历节点n所有的邻近节点：</span><br><span class="line">            * 如果邻近节点m在close_set中，则：</span><br><span class="line">                * 跳过，选取下一个邻近节点</span><br><span class="line">            * 如果邻近节点m也不在open_set中，则：</span><br><span class="line">                * 设置节点m的parent为节点n</span><br><span class="line">                * 计算节点m的优先级</span><br><span class="line">                * 将节点m加入open_set中</span><br></pre></td></tr></table></figure>
<h2 id="启发函数">启发函数</h2>
<p>上面已经提到，启发函数会影响A*算法的行为。</p>
<ul>
<li>在极端情况下，当启发函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>始终为0，则将由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>决定节点的优先级，此时算法就退化成了Dijkstra算法。</li>
<li>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>始终小于等于节点n到终点的代价，则A*算法保证一定能够找到最短路径。但是当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>的值越小，算法将遍历越多的节点，也就导致算法越慢。</li>
<li>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>完全等于节点n到终点的代价，则A*算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远。</li>
<li>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>的值比节点n到终点的代价要大，则A*算法不能保证找到最短路径，不过此时会很快。</li>
<li>在另外一个极端情况下，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>相较于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>大很多，则此时只有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>产生效果，这也就变成了最佳优先搜索。</li>
</ul>
<p>由上面这些信息我们可以知道，通过调节启发函数我们可以控制算法的速度和精确度。因为在一些情况，我们可能未必需要最短路径，而是希望能够尽快找到一个路径即可。这也是A*算法比较灵活的地方。</p>
<p>对于网格形式的图，有以下这些启发函数可以使用：</p>
<ul>
<li>如果图形中只允许朝上下左右四个方向移动，则可以使用曼哈顿距离（Manhattan distance）。</li>
<li>如果图形中允许朝八个方向移动，则可以使用对角距离。</li>
<li>如果图形中允许朝任何方向移动，则可以使用欧几里得距离（Euclidean distance）。</li>
</ul>
<h2 id="关于距离">关于距离</h2>
<h3 id="曼哈顿距离">曼哈顿距离</h3>
<p>如果图形中只允许朝上下左右四个方向移动，则启发函数可以使用曼哈顿距离，它的计算方法如下图所示：</p>
<p><img src="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/Manhattan_dis.png" alt=""></p>
<p>计算曼哈顿距离的函数如下，这里的D是指两个相邻节点之间的移动代价，通常是一个固定的常数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function heuristic(node) =</span><br><span class="line">    dx = abs(node.x - goal.x)</span><br><span class="line">    dy = abs(node.y - goal.y)</span><br><span class="line">    return D * (dx + dy)</span><br></pre></td></tr></table></figure>
<h3 id="对角距离">对角距离</h3>
<p>如果图形中允许斜着朝邻近的节点移动，则启发函数可以使用对角距离。它的计算方法如下：</p>
<p><img src="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/Diagonal_dis.png" alt=""></p>
<p>计算对角距离的函数如下，这里的D2指的是两个斜着相邻节点之间的移动代价。如果所有节点都正方形，则其值就是\\sqrt{2} \* D。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function heuristic(node) =</span><br><span class="line">    dx = abs(node.x - goal.x)</span><br><span class="line">    dy = abs(node.y - goal.y)</span><br><span class="line">    return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)</span><br></pre></td></tr></table></figure>
<h3 id="欧几里得距离">欧几里得距离</h3>
<p>如果图形中允许朝任意方向移动，则可以使用欧几里得距离。</p>
<p>欧几里得距离是指两个节点之间的直线距离，因此其计算方法也是我们比较熟悉的：\\sqrt{(p2.x-p1.x)^2 + (p2.y-p1.y)^2}。其函数表示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function heuristic(node) =</span><br><span class="line">    dx = abs(node.x - goal.x)</span><br><span class="line">    dy = abs(node.y - goal.y)</span><br><span class="line">    return D * sqrt(dx * dx + dy * dy)</span><br></pre></td></tr></table></figure>
<h2 id="算法实现">算法实现</h2>
<p>虽然前面介绍了很多内容，但实际上A*算法并不复杂，实现起来也比较简单。</p>
<p>下面我们给出一个Python语言的代码示例。</p>
<p>之所以使用Python语言是因为我们可以借助matplotlib库很方便的将结果展示出来。在理解了算法之后，通过其他语言实现也并非难事。</p>
<blockquote>
<p>算法的源码可以到我的github上下载：<a target="_blank" rel="noopener" href="https://github.com/paulQuei/a-star-algorithm">paulQuei/a-star-algorithm</a>。</p>
</blockquote>
<p>我们的算法演示的是在一个二维的网格图形上从起点找寻终点的求解过程。</p>
<h2 id="坐标点与地图">坐标点与地图</h2>
<p>首先，我们创建一个非常简单的类来描述图中的点，相关代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># point.py</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">class Point:</span><br><span class="line">    def __init__(self, x, y):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        self.cost = sys.maxsize</span><br></pre></td></tr></table></figure>
<p>接着，我们实现一个描述地图结构的类。为了简化算法的描述:</p>
<p><strong>我们选定左下角坐标[0, 0]的点是算法起点，右上角坐标[size - 1, size - 1]的点为要找的终点。</strong></p>
<p>为了让算法更有趣，我们在地图的中间设置了一个障碍，并且地图中还会包含一些随机的障碍。该类的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># random_map.py</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">import point</span><br><span class="line"></span><br><span class="line">class RandomMap:</span><br><span class="line">    def __init__(self, size=50): ①</span><br><span class="line">        self.size = size</span><br><span class="line">        self.obstacle = size//8 ②</span><br><span class="line">        self.GenerateObstacle() ③</span><br><span class="line"></span><br><span class="line">    def GenerateObstacle(self):</span><br><span class="line">        self.obstacle_point = []</span><br><span class="line">        self.obstacle_point.append(point.Point(self.size//2, self.size//2))</span><br><span class="line">        self.obstacle_point.append(point.Point(self.size//2, self.size//2-1))</span><br><span class="line"></span><br><span class="line">        # Generate an obstacle in the middle</span><br><span class="line">        for i in range(self.size//2-4, self.size//2): ④</span><br><span class="line">            self.obstacle_point.append(point.Point(i, self.size-i))</span><br><span class="line">            self.obstacle_point.append(point.Point(i, self.size-i-1))</span><br><span class="line">            self.obstacle_point.append(point.Point(self.size-i, i))</span><br><span class="line">            self.obstacle_point.append(point.Point(self.size-i, i-1))</span><br><span class="line"></span><br><span class="line">        for i in range(self.obstacle-1): ⑤</span><br><span class="line">            x = np.random.randint(0, self.size)</span><br><span class="line">            y = np.random.randint(0, self.size)</span><br><span class="line">            self.obstacle_point.append(point.Point(x, y))</span><br><span class="line"></span><br><span class="line">            if (np.random.rand() &gt; 0.5): # Random boolean ⑥</span><br><span class="line">                for l in range(self.size//4):</span><br><span class="line">                    self.obstacle_point.append(point.Point(x, y+l))</span><br><span class="line">                    pass</span><br><span class="line">            else:</span><br><span class="line">                for l in range(self.size//4):</span><br><span class="line">                    self.obstacle_point.append(point.Point(x+l, y))</span><br><span class="line">                    pass</span><br><span class="line"></span><br><span class="line">    def IsObstacle(self, i ,j): ⑦</span><br><span class="line">        for p in self.obstacle_point:</span><br><span class="line">            if i==p.x and j==p.y:</span><br><span class="line">                return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>
<p>这段代码说明如下：</p>
<ol>
<li>构造函数，地图的默认大小是50x50；</li>
<li>设置障碍物的数量为地图大小除以8；</li>
<li>调用<code>GenerateObstacle</code>生成随机障碍物；</li>
<li>在地图的中间生成一个斜着的障碍物；</li>
<li>随机生成其他几个障碍物；</li>
<li>障碍物的方向也是随机的；</li>
<li>定义一个方法来判断某个节点是否是障碍物；</li>
</ol>
<h2 id="算法主体">算法主体</h2>
<p>有了基本的数据结构之后，我们就可以开始实现算法主体了。</p>
<p>这里我们通过一个类来封装我们的算法。</p>
<p>首先实现一些算法需要的基本函数，它们如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># a_star.py</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">from matplotlib.patches import Rectangle</span><br><span class="line"></span><br><span class="line">import point</span><br><span class="line">import random_map</span><br><span class="line"></span><br><span class="line">class AStar:</span><br><span class="line">    def __init__(self, map):</span><br><span class="line">        self.map=map</span><br><span class="line">        self.open_set = []</span><br><span class="line">        self.close_set = []</span><br><span class="line"></span><br><span class="line">    def BaseCost(self, p):</span><br><span class="line">        x_dis = p.x</span><br><span class="line">        y_dis = p.y</span><br><span class="line">        # Distance to start point</span><br><span class="line">        return x_dis + y_dis + (np.sqrt(2) - 2) * min(x_dis, y_dis)</span><br><span class="line"></span><br><span class="line">    def HeuristicCost(self, p):</span><br><span class="line">        x_dis = self.map.size - 1 - p.x</span><br><span class="line">        y_dis = self.map.size - 1 - p.y</span><br><span class="line">        # Distance to end point</span><br><span class="line">        return x_dis + y_dis + (np.sqrt(2) - 2) * min(x_dis, y_dis)</span><br><span class="line"></span><br><span class="line">    def TotalCost(self, p):</span><br><span class="line">        return self.BaseCost(p) + self.HeuristicCost(p)</span><br><span class="line"></span><br><span class="line">    def IsValidPoint(self, x, y):</span><br><span class="line">        if x &lt; 0 or y &lt; 0:</span><br><span class="line">            return False</span><br><span class="line">        if x &gt;= self.map.size or y &gt;= self.map.size:</span><br><span class="line">            return False</span><br><span class="line">        return not self.map.IsObstacle(x, y)</span><br><span class="line"></span><br><span class="line">    def IsInPointList(self, p, point_list):</span><br><span class="line">        for point in point_list:</span><br><span class="line">            if point.x == p.x and point.y == p.y:</span><br><span class="line">                return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    def IsInOpenList(self, p):</span><br><span class="line">        return self.IsInPointList(p, self.open_set)</span><br><span class="line"></span><br><span class="line">    def IsInCloseList(self, p):</span><br><span class="line">        return self.IsInPointList(p, self.close_set)</span><br><span class="line"></span><br><span class="line">    def IsStartPoint(self, p):</span><br><span class="line">        return p.x == 0 and p.y ==0</span><br><span class="line"></span><br><span class="line">    def IsEndPoint(self, p):</span><br><span class="line">        return p.x == self.map.size-1 and p.y == self.map.size-1</span><br></pre></td></tr></table></figure>
<p>这里的函数说明如下：</p>
<ul>
<li><code>__init__</code>：类的构造函数。</li>
<li><code>BaseCost</code>：节点到起点的移动代价，对应了上文的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>。</li>
<li><code>HeuristicCost</code>：节点到终点的启发函数，对应上文的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>。由于我们是基于网格的图形，所以这个函数和上一个函数用的是对角距离。</li>
<li><code>TotalCost</code>：代价总和，即对应上面提到的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>。</li>
<li><code>IsValidPoint</code>：判断点是否有效，不在地图内部或者障碍物所在点都是无效的。</li>
<li><code>IsInPointList</code>：判断点是否在某个集合中。</li>
<li><code>IsInOpenList</code>：判断点是否在open_set中。</li>
<li><code>IsInCloseList</code>：判断点是否在close_set中。</li>
<li><code>IsStartPoint</code>：判断点是否是起点。</li>
<li><code>IsEndPoint</code>：判断点是否是终点。</li>
</ul>
<p>有了上面这些辅助函数，就可以开始实现算法主逻辑了，相关代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># a_star.py</span><br><span class="line">def RunAndSaveImage(self, ax, plt):</span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    start_point = point.Point(0, 0)</span><br><span class="line">    start_point.cost = 0</span><br><span class="line">    self.open_set.append(start_point)</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        index = self.SelectPointInOpenList()</span><br><span class="line">        if index &lt; 0:</span><br><span class="line">            print(&#x27;No path found, algorithm failed!!!&#x27;)</span><br><span class="line">            return</span><br><span class="line">        p = self.open_set[index]</span><br><span class="line">        rec = Rectangle((p.x, p.y), 1, 1, color=&#x27;c&#x27;)</span><br><span class="line">        ax.add_patch(rec)</span><br><span class="line">        self.SaveImage(plt)</span><br><span class="line"></span><br><span class="line">        if self.IsEndPoint(p):</span><br><span class="line">            return self.BuildPath(p, ax, plt, start_time)</span><br><span class="line"></span><br><span class="line">        del self.open_set[index]</span><br><span class="line">        self.close_set.append(p)</span><br><span class="line"></span><br><span class="line">        # Process all neighbors</span><br><span class="line">        x = p.x</span><br><span class="line">        y = p.y</span><br><span class="line">        self.ProcessPoint(x-1, y+1, p)</span><br><span class="line">        self.ProcessPoint(x-1, y, p)</span><br><span class="line">        self.ProcessPoint(x-1, y-1, p)</span><br><span class="line">        self.ProcessPoint(x, y-1, p)</span><br><span class="line">        self.ProcessPoint(x+1, y-1, p)</span><br><span class="line">        self.ProcessPoint(x+1, y, p)</span><br><span class="line">        self.ProcessPoint(x+1, y+1, p)</span><br><span class="line">        self.ProcessPoint(x, y+1, p)</span><br></pre></td></tr></table></figure>
<p>这段代码应该不需要太多解释了，它就是根据前面的算法逻辑进行实现。为了将结果展示出来，我们在算法进行的每一步，都会借助于matplotlib库将状态保存成图片。</p>
<p>上面这个函数调用了其他几个函数代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># a_star.py</span><br><span class="line">def SaveImage(self, plt):</span><br><span class="line">    millis = int(round(time.time() * 1000))</span><br><span class="line">    filename = &#x27;./&#x27; + str(millis) + &#x27;.png&#x27;</span><br><span class="line">    plt.savefig(filename)</span><br><span class="line"></span><br><span class="line">def ProcessPoint(self, x, y, parent):</span><br><span class="line">    if not self.IsValidPoint(x, y):</span><br><span class="line">        return # Do nothing for invalid point</span><br><span class="line">    p = point.Point(x, y)</span><br><span class="line">    if self.IsInCloseList(p):</span><br><span class="line">        return # Do nothing for visited point</span><br><span class="line">    print(&#x27;Process Point [&#x27;, p.x, &#x27;,&#x27;, p.y, &#x27;]&#x27;, &#x27;, cost: &#x27;, p.cost)</span><br><span class="line">    if not self.IsInOpenList(p):</span><br><span class="line">        p.parent = parent</span><br><span class="line">        p.cost = self.TotalCost(p)</span><br><span class="line">        self.open_set.append(p)</span><br><span class="line"></span><br><span class="line">def SelectPointInOpenList(self):</span><br><span class="line">    index = 0</span><br><span class="line">    selected_index = -1</span><br><span class="line">    min_cost = sys.maxsize</span><br><span class="line">    for p in self.open_set:</span><br><span class="line">        cost = self.TotalCost(p)</span><br><span class="line">        if cost &lt; min_cost:</span><br><span class="line">            min_cost = cost</span><br><span class="line">            selected_index = index</span><br><span class="line">        index += 1</span><br><span class="line">    return selected_index</span><br><span class="line"></span><br><span class="line">def BuildPath(self, p, ax, plt, start_time):</span><br><span class="line">    path = []</span><br><span class="line">    while True:</span><br><span class="line">        path.insert(0, p) # Insert first</span><br><span class="line">        if self.IsStartPoint(p):</span><br><span class="line">            break</span><br><span class="line">        else:</span><br><span class="line">            p = p.parent</span><br><span class="line">    for p in path:</span><br><span class="line">        rec = Rectangle((p.x, p.y), 1, 1, color=&#x27;g&#x27;)</span><br><span class="line">        ax.add_patch(rec)</span><br><span class="line">        plt.draw()</span><br><span class="line">        self.SaveImage(plt)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    print(&#x27;===== Algorithm finish in&#x27;, int(end_time-start_time), &#x27; seconds&#x27;)</span><br></pre></td></tr></table></figure>
<p>这三个函数应该是比较容易理解的：</p>
<ul>
<li><code>SaveImage</code>：将当前状态保存到图片中，图片以当前时间命名。</li>
<li><code>ProcessPoint</code>：针对每一个节点进行处理：如果是没有处理过的节点，则计算优先级设置父节点，并且添加到open_set中。</li>
<li><code>SelectPointInOpenList</code>：从open_set中找到优先级最高的节点，返回其索引。</li>
<li><code>BuildPath</code>：从终点往回沿着<code>parent</code>构造结果路径。然后从起点开始绘制结果，结果使用绿色方块，每次绘制一步便保存一个图片。</li>
</ul>
<h2 id="测试入口">测试入口</h2>
<p>最后是程序的入口逻辑，使用上面写的类来查找路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># main.py</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">from matplotlib.patches import Rectangle</span><br><span class="line"></span><br><span class="line">import random_map</span><br><span class="line">import a_star</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(5, 5))</span><br><span class="line"></span><br><span class="line">map = random_map.RandomMap() ①</span><br><span class="line"></span><br><span class="line">ax = plt.gca()</span><br><span class="line">ax.set_xlim([0, map.size]) ②</span><br><span class="line">ax.set_ylim([0, map.size])</span><br><span class="line"></span><br><span class="line">for i in range(map.size): ③</span><br><span class="line">    for j in range(map.size):</span><br><span class="line">        if map.IsObstacle(i,j):</span><br><span class="line">            rec = Rectangle((i, j), width=1, height=1, color=&#x27;gray&#x27;)</span><br><span class="line">            ax.add_patch(rec)</span><br><span class="line">        else:</span><br><span class="line">            rec = Rectangle((i, j), width=1, height=1, edgecolor=&#x27;gray&#x27;, facecolor=&#x27;w&#x27;)</span><br><span class="line">            ax.add_patch(rec)</span><br><span class="line"></span><br><span class="line">rec = Rectangle((0, 0), width = 1, height = 1, facecolor=&#x27;b&#x27;)</span><br><span class="line">ax.add_patch(rec) ④</span><br><span class="line"></span><br><span class="line">rec = Rectangle((map.size-1, map.size-1), width = 1, height = 1, facecolor=&#x27;r&#x27;)</span><br><span class="line">ax.add_patch(rec) ⑤</span><br><span class="line"></span><br><span class="line">plt.axis(&#x27;equal&#x27;) ⑥</span><br><span class="line">plt.axis(&#x27;off&#x27;)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">#plt.show()</span><br><span class="line"></span><br><span class="line">a_star = a_star.AStar(map)</span><br><span class="line">a_star.RunAndSaveImage(ax, plt) ⑦</span><br></pre></td></tr></table></figure>
<p>这段代码说明如下：</p>
<ol>
<li>创建一个随机地图；</li>
<li>设置图像的内容与地图大小一致；</li>
<li>绘制地图：对于障碍物绘制一个灰色的方块，其他区域绘制一个白色的的方块；</li>
<li>绘制起点为蓝色方块；</li>
<li>绘制终点为红色方块；</li>
<li>设置图像的坐标轴比例相等并且隐藏坐标轴；</li>
<li>调用算法来查找路径；</li>
</ol>
<p>由于我们的地图是随机的，所以每次运行的结果可能会不一样，下面是我的电脑上某次运行的结果：</p>
<p><img src="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/a_star.gif" alt=""></p>
<blockquote>
<p>如果感兴趣这篇文章中的动图是如何制作的，请看我的另外一篇文章：<a target="_blank" rel="noopener" href="https://paul.pub/matplotlib-3d-plotting/#id-%E5%88%B6%E4%BD%9C%E5%8A%A8%E5%9B%BE">使用Matplotlib绘制3D图形 - 制作动图</a>。</p>
</blockquote>
<h2 id="算法变种">算法变种</h2>
<p>A*算法有不少的变种，这里我们介绍最主要的几个。</p>
<p>更多的内容请以访问维基百科：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/A*_search_algorithm#Variants">A* Variants</a>。</p>
<h2 id="ARA">ARA*</h2>
<p>ARA* 全称是Anytime Repairing A*，也称为Anytime A*。</p>
<p>与其他Anytime算法一样，它具有灵活的时间成本，即使在它结束之前被中断，也可以返回路径查找或图形遍历问题的有效解决方案。方法是在逐步优化之前生成快速，非最优的结果。</p>
<p>在现实世界的规划问题中，问题的解决时间往往是有限的。与时间相关的规划者对这种情况都会比较熟悉：他们能够快速找到可行的解决方案，然后不断努力改进，直到时间用完为止。</p>
<p>启发式搜索ARA*算法，它根据可用的搜索时间调整其性能边界。它首先使用松散边界快速找到次优解，然后在时间允许的情况下逐渐收紧边界。如果有足够的时间，它会找到可证明的最佳解决方方案。在改进其约束的同时，ARA*重复使用以前的搜索工作，因此，比其他随时搜索方法更有效。</p>
<p>与A*算法不同，Anytime A*算法最重要的功能是，它们可以被停止，然后可以随时重启。该方法使用控制管理器类来处理时间限制以及停止和重新启动A*算法以找到初始的，可能是次优的解决方案，然后继续搜索改进的解决方案，直到达到可证明的最佳解决方案。</p>
<p>关于ARA*的更多内容可以阅读这篇论文：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/ARA%2A-%20Anytime%20A%2A%20with%20Provable%20Bounds%20on%20Sub-Optimality.pdf">ARA* - Anytime A* with Provable Bounds on Sub-Optimality</a>。</li>
</ul>
<h2 id="D">D*</h2>
<p>D*是Dynamic A*的简写，其算法和A*类似，不同的是，其代价的计算在算法运行过程中可能会发生变化。</p>
<p>D*包含了下面三种增量搜索算法：</p>
<ul>
<li>原始的D*由Anthony Stentz发表。</li>
<li>Focussed D*由Anthony Stentz发表，是一个增量启发式搜索算法，结合了A*和原始D*的思想。</li>
<li>D* Lite是由Sven Koenig和Maxim Likhachev基于LPA*构建的算法。</li>
</ul>
<p>所有三种搜索算法都解决了相同的基于假设的路径规划问题，包括使用自由空间假设进行规划。在这些环境中，机器人必须导航到未知地形中的给定目标坐标。它假设地形的未知部分（例如：它不包含障碍物），并在这些假设下找到从当前坐标到目标坐标的最短路径。</p>
<p>然后机器人沿着路径行进。当它观察到新的地图信息（例如以前未知的障碍物）时，它会将信息添加到其地图中，并在必要时将新的最短路径从其当前坐标重新添加到给定的目标坐标。它会重复该过程，直到达到目标坐标或确定无法达到目标坐标。在穿越未知地形时，可能经常发现新的障碍，因此重新计划需要很快。增量（启发式）搜索算法通过使用先前问题的经验来加速搜索当前问题，从而加速搜索类似搜索问题的序列。假设目标坐标没有改变，则所有三种搜索算法都比重复的A*搜索更有效。</p>
<p>D*及其变体已广泛用于移动机器人和自动车辆导航。当前系统通常基于D* Lite而不是原始D*或Focussed D*。</p>
<p>关于D*的更多内容可以阅读这两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://idm-lab.org/project-a.html">Project “Fast Replanning （Incremental Heuristic Search）”</a></li>
<li><a target="_blank" rel="noopener" href="http://www.frc.ri.cmu.edu/~axs/dynamic_plan.html">Real-Time Replanning in Dynamic and Unknown Environments</a></li>
</ul>
<h2 id="Field-D">Field D*</h2>
<p>Field D*扩展了D*和D* Lite，是一种基于插值（ interpolation-based ）的规划算法，它使用线性插值来有效地生成低成本路径，从而消除不必要的转向。</p>
<p>在给定线性插值假设的情况下，路径是最优的，并且在实践中非常有效。该算法目前被各种现场机器人系统使用。</p>
<p>关于Field D*的详细内容可以看下面这篇论文：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/Field%20D%2A-%20An%20Interpolation-based%20Path%20Planner%20and%20Replanner.pdf">Field D*: An Interpolation-based Path Planner and Replanner</a></li>
</ul>
<h2 id="Block-A">Block A*</h2>
<p>Block A*扩展自A*，但它操作是一块（block）单元而不是单个单元。</p>
<p>其open_set中的每个条目都是已到达但尚未扩展的块，或者需要重新扩展的块。</p>
<p>open_set中块的优先级称为其堆值（heap value）。与A*类似，Block A*中的基本循环是删除具有最低堆值的条目并将其展开。在扩展期间使用LDDB来计算正在扩展的块中的边界单元的g值。</p>
<p>LDDB是一种新型数据库，它包含了本地邻域边界点之间的距离。</p>
<p>关于Block A*的更多内容可以看下面这篇论文：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/Block%20A%2A-%20Database-Driven%20Search%20with%20Applications%20in%20Any-angle%20Path-Planning.pdf">Block A*: Database-Driven Search with Applications in Any-angle Path-Planning</a></li>
</ul>
<h2 id="参考资料与推荐读物">参考资料与推荐读物</h2>
<ul>
<li><a target="_blank" rel="noopener" href="http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html">Stanford: Introduction to A*</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/A*_search_algorithm">Wikipedia: A* search algorithm</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/AtsushiSakai/PythonRobotics#a-algorithm">PythonRobotics: A* algorithm</a></li>
<li><a target="_blank" rel="noopener" href="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/ARA%2A-%20Anytime%20A%2A%20with%20Provable%20Bounds%20on%20Sub-Optimality.pdf">ARA* - Anytime A* with Provable Bounds on Sub-Optimality</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="2025/06/01/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E4%B9%8B-A-%E7%AE%97%E6%B3%95/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="2025/05/28/%E5%88%9D%E5%BF%83%E8%80%85%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%83%80%E3%82%A4%E3%82%AF%E3%82%B9%E3%83%88%E3%83%A9%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/"
                            aria-label=": 初心者のためのダイクストラアルゴリズム"
                        >
                            初心者のためのダイクストラアルゴリズム
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-28T14:52:10+08:00">
	
		    2025 年 5 月 28 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="categories/%E7%AE%97%E6%B3%95/">算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>ダイクストラのアルゴリズムってあるじゃないですか？名前も覚えにくいしそもそも重み付きグラフの最短経路問題とか実務で実装することそうそうないのですぐ忘れちゃうんですよね。。。</p>
<h2 id="ダイクストラアルゴリズムとは"><a href="#%E3%83%80%E3%82%A4%E3%82%AF%E3%82%B9%E3%83%88%E3%83%A9%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%81%AF"></a>ダイクストラアルゴリズムとは</h2>
<p>ダイクストラアルゴリズムとはグラフの最短経路を求めるアルゴリズムです。名前だけは聞いたことのある方も多いかと思います。やってることはイージーでシンプルなんですが少しとっつきにくいですが一つ一つ理解していけば割とわかりやすいアルゴリズムです。<br>
重み付き出ない、迷路の探索などは幅優先探索で解けるのですが、各辺に重みがついてる場合は結局全通りを計算しないといけないことになります。全ての頂点を一回だけ通るとして、辺E個あるとすればO(E!)となり計算量は爆発してしまします。<br>
これだと計算するにも少し厳しいです。</p>
<p>そんな問題を効率的にといてくれるアルゴリズムそれがダイクストラアルゴリズムです。</p>
<p>ちなみに各辺のコストは非負の値(0以上)でなければなりません。負の数が含まれてる場合はベルマン-フォード法などを使用することになります。</p>
<h2 id="手順"><a href="#%E6%89%8B%E9%A0%86"></a>手順</h2>
<p>ダイクストラ法の手順はかなり単純です。</p>
<ol>
<li>始点に最短距離0を設定する</li>
<li>まだ辿ってない点の中から最短距離が分かっていて最も距離が短い頂点に移動する</li>
<li>その頂点から繋がっている頂点の最短距離を設定する。この時にその頂点の最短距離を更新できるなら更新する。</li>
<li>これを全ての頂点の最短距離をわかるまで行う</li>
</ol>
<p>さてと言われても少し難しいと思いますので、実例をみていきましょう。</p>
<h2 id="例"><a href="#%E4%BE%8B"></a>例</h2>
<p>なんともアナログな手法ですが一番表現できたので。。。<br>
以下のような図の最短経路を考えていきます。<br>
<a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F90f90a2f-8991-1bc5-adb4-fb4b053a901f.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=b9d055575e737f8a2c459474e25322c7"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F90f90a2f-8991-1bc5-adb4-fb4b053a901f.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=b9d055575e737f8a2c459474e25322c7" alt="image.png"></a></p>
<p>緑が最短経路が確定して移動ずみの頂点となります。赤が起点となる頂点です。各頂点の数字はその時の最短経路となります<br>
<a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2Fae1ddc01-e867-8894-7aee-3940269cfe2e.gif?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=0b8d3bd32321d163185bac4e6ecf4db7"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2Fae1ddc01-e867-8894-7aee-3940269cfe2e.gif?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=0b8d3bd32321d163185bac4e6ecf4db7" alt="dijkstra algo.gif"></a></p>
<p>さてみていただくと分かるようにスタート地点から順番にその時点での最短の頂点に移動してそこからまた隣り合う頂点の最短経路を計算しているのが分かるかと思います。</p>
<h2 id="実装"><a href="#%E5%AE%9F%E8%A3%85"></a>実装</h2>
<p>さて実装に入っていきましょう。<br>
上の手順を愚直に実装してみます。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function main(nodes) &#123;</span><br><span class="line">    const start = nodes[0]</span><br><span class="line">    // 訪問済みの頂点を記録</span><br><span class="line">    const visited = new Set()</span><br><span class="line">    const routesFromStart = new Map()</span><br><span class="line">     // 始点からの距離の記録</span><br><span class="line"></span><br><span class="line">    routesFromStart.set(start, &#123;distance: 0&#125;)</span><br><span class="line">    for(const n of nodes) &#123;</span><br><span class="line">        if(n != start) &#123;</span><br><span class="line">            // スタート以外の全ての頂点に無限大を代入</span><br><span class="line">            routesFromStart.set(n, &#123;distance: Number.MAX_VALUE&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let current = start</span><br><span class="line">    let routes = new Map()</span><br><span class="line">    while(current != null) &#123;</span><br><span class="line">        visited.add(current)</span><br><span class="line">        for(const edge of current.edges) &#123;</span><br><span class="line">             // その頂点から隣り合う頂点の最短距離を計算して、計算済みの値より低ければ更新</span><br><span class="line">            if(edge.cost + routesFromStart.get(current).distance &lt; routesFromStart.get(edge.to).distance) &#123;</span><br><span class="line">                routesFromStart.set(edge.to, &#123;distance: edge.cost + routesFromStart.get(current).distance&#125;)</span><br><span class="line">                routes.set(current, edge.to)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        let cheapestNodeDistance = Number.MAX_VALUE</span><br><span class="line">        current = null</span><br><span class="line">        // 訪問してない最短距離を計算済みの頂点の中から最小の頂点を選ぶ</span><br><span class="line"></span><br><span class="line">        for(const city of routesFromStart.keys()) &#123;</span><br><span class="line">            if(!visited.has(city) &amp;&amp; cheapestNodeDistance &gt; routesFromStart.get(city).distance)&#123;</span><br><span class="line">                cheapestNodeDistance = routesFromStart.get(city).distance</span><br><span class="line">                current = city</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return routesFromStart.get(nodes[nodes.length - 1]).distance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>このコードは各頂点をVとすると最大で各辺の個数を回るループの中で中で最小の頂点を選ぶためのループを回してるので計算量はO(V^2 + E)メモリについては各頂点分の記録を行わないといけないのでO(V)となります。</p>
<h2 id="Priority-Queueを用いた実装について"><a href="#priority-queue%E3%82%92%E7%94%A8%E3%81%84%E3%81%9F%E5%AE%9F%E8%A3%85%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6"></a>Priority Queueを用いた実装について</h2>
<p>さて感のいい人ならお気づきになったかもしれませんが、このコード実は最小の頂点を決めるロジックを最適化することができます。それが優先度付きキューです。<br>
優先度付きキューは挿入、取り出しにO(logN)の計算量が必要となりますが、最小の頂点を決める際の計算量が線形の探索より早くなります。</p>
<p>Priority QueueはJavaScriptには標準で実装はされてないので、Pythonでの実装です。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def dijkstra(nodes):</span><br><span class="line">    start_node = nodes[0]</span><br><span class="line">    routes_from_start = &#123;n: math.inf for n in nodes&#125;</span><br><span class="line"></span><br><span class="line">    # 最初の頂点にゼロを設定</span><br><span class="line">    routes_from_start[start_node] = 0</span><br><span class="line">    </span><br><span class="line">    minHeap = []</span><br><span class="line"></span><br><span class="line">    # 最初の頂点を追加</span><br><span class="line">    heappush(minHeap, (0, start_node))</span><br><span class="line"></span><br><span class="line">    # ヒープがなくなるまで探索</span><br><span class="line">    while minHeap:</span><br><span class="line">        (cost, current_node) = heappop(minHeap)</span><br><span class="line"></span><br><span class="line">        # priority keyは重複するのでここでチェックする</span><br><span class="line">        if cost &gt; routes_from_start[current_node]:</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        for node in current_node.routes:</span><br><span class="line">            price_info = current_node.routes[node]</span><br><span class="line">            if routes_from_start[node] &gt; price_info + routes_from_start[current_node]:</span><br><span class="line">                routes_from_start[node] = price_info + routes_from_start[current_node]</span><br><span class="line">                # 更新されたらpriorityに値を追加</span><br><span class="line">                heappush(minHeap, (price_info + routes_from_start[current_node], node))</span><br><span class="line"></span><br><span class="line">    return routes_from_start[nodes[-1]]</span><br></pre></td></tr></table></figure>
<p>Priority Queueの説明はまたの機会にしましょう。<br>
より計算効率がよく各頂点V, 各辺をVとするとVをmapに設定するO(V)とEの回数分heapを操作するのでO(ElogE)。の合計O(V + ElogE)で求まることがわかります。これは最初のアルゴリズムより効率的です。</p>
<h2 id="経路を記憶する"><a href="#%E7%B5%8C%E8%B7%AF%E3%82%92%E8%A8%98%E6%86%B6%E3%81%99%E3%82%8B"></a>経路を記憶する</h2>
<p>さて最短のコストはわかりました。しかしこの問題は&quot;最短経路&quot;問題です。最短のコストが求まったらその経路も知りたくなるのが普通です。<br>
上のコードを改善してみましょう。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">def dijkstra(nodes):</span><br><span class="line">    start_node = nodes[0]</span><br><span class="line">    routes_from_start = &#123;n: math.inf for n in nodes&#125;</span><br><span class="line"></span><br><span class="line">    # 最初の頂点にゼロを設定</span><br><span class="line">    routes_from_start[start_node] = 0</span><br><span class="line">    </span><br><span class="line">    minHeap = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # 最初の頂点を追加</span><br><span class="line">    heappush(minHeap, (0, start_node))</span><br><span class="line">    path = collections.defaultdict(Node)</span><br><span class="line"></span><br><span class="line">    # ヒープがなくなるまで探索</span><br><span class="line">    while minHeap:</span><br><span class="line">        (cost, current_node) = heappop(minHeap)</span><br><span class="line"></span><br><span class="line">        # priority keyは重複するのでここでチェックする</span><br><span class="line">        if cost &gt; routes_from_start[current_node]:</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        for node in current_node.routes:</span><br><span class="line">            price_info = current_node.routes[node]</span><br><span class="line">            if routes_from_start[node] &gt; price_info + routes_from_start[current_node]:</span><br><span class="line">                routes_from_start[node] = price_info + routes_from_start[current_node]</span><br><span class="line">                # 最短距離を更新するノードを記録する</span><br><span class="line">                path[node.id] = current_node.id</span><br><span class="line">                # 更新されたらpriorityに値を追加</span><br><span class="line">                heappush(minHeap, (price_info + routes_from_start[current_node], node))</span><br><span class="line"></span><br><span class="line">    current_node = nodes[-1].id</span><br><span class="line">    path_array = []</span><br><span class="line"></span><br><span class="line">    #最短距離を記録したノードをゴールからたどる</span><br><span class="line">    while current_node:</span><br><span class="line">        path_array.append(current_node)</span><br><span class="line">        if current_node not in path:</span><br><span class="line">            break</span><br><span class="line">        current_node = path[current_node]</span><br><span class="line"></span><br><span class="line">    return routes_from_start[nodes[-1]], path_array[::-1]</span><br></pre></td></tr></table></figure>
<p>ダイクストラアルゴリズムでは最短距離を更新するノードが分かるのでそれを記録して最後に辿ればよいことになります。<br>
計算量は最短距離のノードの数分増えてしまうことになります。</p>
<h2 id="ところでなんでこれで最短経路が求まるのか"><a href="#%E3%81%A8%E3%81%93%E3%82%8D%E3%81%A7%E3%81%AA%E3%82%93%E3%81%A7%E3%81%93%E3%82%8C%E3%81%A7%E6%9C%80%E7%9F%AD%E7%B5%8C%E8%B7%AF%E3%81%8C%E6%B1%82%E3%81%BE%E3%82%8B%E3%81%AE%E3%81%8B"></a>ところでなんでこれで最短経路が求まるのか</h2>
<p>さてここまでみてきて多くの人はこう思ったのではないでしょうか？確かにアルゴリズムは簡単だしそれを実装するのもそんなに難しくはない。でもなんで最短距離が求まるの？軽く確認していきましょう</p>
<p><a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F8623f00e-2046-445a-f386-6341b4bef518.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=4286b7e1195710b30d6ffb7ab22967c7"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F8623f00e-2046-445a-f386-6341b4bef518.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=4286b7e1195710b30d6ffb7ab22967c7" alt="image.png"></a></p>
<p>Lに入っている頂点はスタートSからの最短距離であると仮定して、そこから繋がる最短の頂点がまたSから最短距離であることを言えたら良さそうですね。</p>
<p><a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F8eb04095-91e7-85e6-93f1-93cd7f927fa0.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=b64897102d0f8dec7ed56385248d0a06"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F8eb04095-91e7-85e6-93f1-93cd7f927fa0.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=b64897102d0f8dec7ed56385248d0a06" alt="image.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2Fa10dcc01-c558-6f52-3b6f-906cb3433456.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=57a5fb3ec3b55e91b33e0184905063aa"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2Fa10dcc01-c558-6f52-3b6f-906cb3433456.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=57a5fb3ec3b55e91b33e0184905063aa" alt="image.png"></a></p>
<p>さてTに含まれるうちの最短の頂点に移動するので、最小の点をiとするとd[i] = min(T)ですよね。<br>
さてここで各頂点をkとすると最短距離d[k] は d[k] &gt;= d[i]であることは確定しますよね。d[i] は最小の点であり、各頂点は非負なので。<br>
と次々やっていくと帰納法的に証明できます。</p>
<p>さてこれってよく考えたら漸化式ですよね。</p>
<p>d[i] = min(k ⊂ T) + iに隣接するLの頂点の最短距離</p>
<p>漸化式の時には動的計画法が</p>
<p>漸化式ときたらDPですよね。DPについてはこの記事がすごく参考になります(<a target="_blank" rel="noopener" href="https://qiita.com/drken/items/a5e6fe22863b7992efdb">https://qiita.com/drken/items/a5e6fe22863b7992efdb</a>)</p>
<p>ではDPならどういう風に値が更新されていくかというと<br>
<a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F800c0d89-06f7-335a-5195-2f47d85cc22c.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=76478692796218d17f0ab00d2f2651b4"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F800c0d89-06f7-335a-5195-2f47d85cc22c.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=76478692796218d17f0ab00d2f2651b4" alt="image.png"></a></p>
<p>このような感じで値が更新されていきます。縦軸は試行の回数。横軸は頂点です。</p>
<p>なんだダイクストラアルゴリズムはDPの一種だったんだ。</p>
<h2 id="まとめ"><a href="#%E3%81%BE%E3%81%A8%E3%82%81"></a>まとめ</h2>
<p>さてみてきましたダイクストラのアルゴリズムですが、一回理解してしまうと結構簡単に理解できます。あとは実装してみてアルゴリズムの問題で類似の問題に当たった時にあこれはあの時の！！という感じで解いていきたいものです。<br>
*余談ですが僕もDPの記事書きたい</p>
<p>解説したyoutubeチャンネルはこちら<br>
<a target="_blank" rel="noopener" href="https://youtu.be/jz8b0q5R1Ss">https://youtu.be/jz8b0q5R1Ss</a></p>
<h2 id="参考"><a href="#%E5%8F%82%E8%80%83"></a>参考</h2>
<p><a target="_blank" rel="noopener" href="http://www.lab2.kuis.kyoto-u.ac.jp/~shuichi/algintro/alg-6s.pdf">http://www.lab2.kuis.kyoto-u.ac.jp/~shuichi/algintro/alg-6s.pdf</a><br>
<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=X1AsMlJdiok">https://www.youtube.com/watch?v=X1AsMlJdiok</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="2025/05/28/%E5%88%9D%E5%BF%83%E8%80%85%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%83%80%E3%82%A4%E3%82%AF%E3%82%B9%E3%83%88%E3%83%A9%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="2025/05/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/"
                            aria-label=": 函数式编程的核心思想"
                        >
                            函数式编程的核心思想
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-23T16:53:02+08:00">
	
		    2025 年 5 月 23 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/">计算机基础理论</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>函数式编程最近几年越炒越热，有函数式编程的语言鄙视没有函数式编程的语言，纯函数式编程的语言鄙视不纯的函数式编程的语言。</p>
<p>那么，到底什么是函数式编程，函数式编程的核心思想又是什么？</p>
<p>函数式编程的第一个特点就是可以把函数作为参数传递给另一个函数，也就是所谓的高阶函数。例如，对数组进行排序，可以传入一个排序函数作为参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123; <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Apple&quot;</span> &#125;;</span><br><span class="line">Arrays.sort(array, String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure>
<p>函数式编程的第二个特点就是可以返回一个函数，这样就可以实现闭包或者惰性计算：</p>
<p>以上两个特点还仅仅是简化了代码。从代码的可维护性上讲，函数式编程最大的好处是引用透明，即函数运行的结果只依赖于输入的参数，而不依赖于外部状态，因此，我们常常说函数式编程没有副作用。</p>
<p>没有副作用有个巨大的好处，就是函数内部无状态，即输入确定，输出就是确定的，容易测试和维护。</p>
<p>很多初学者容易纠结“纯”函数式语言，认为只有Haskell这种消除了变量和副作用的语言才是正宗的函数式编程。还有人甚至认为纯函数不能有任何IO操作，包括打行日志都不行。</p>
<p>其实这种纠结是没有意义的，因为计算机底层就是一个完全可变的内存和不可预测输入的系统，追求完美的无副作用是不现实的，我们只需要理解函数式编程的思想，把业务逻辑做到“无副作用”，至于有变量、打日志、读缓存这些无关紧要的“副作用”，根本不用担心，不需要解决，也几乎没法解决。</p>
<p>我们来举个栗子。</p>
<p>比如一个财务软件，需要一个函数专门计算个人所得税，输入是一个<code>IncomeRecord</code>，输出是个税金额：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">calculateIncomeTax</span><span class="params">(IncomeRecord record)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又假设<code>IncomeRecord</code>长这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncomeRecord</span> &#123;</span><br><span class="line">    String id; <span class="comment">// 身份证号</span></span><br><span class="line">    String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="type">double</span> salary; <span class="comment">// 工资</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先不考虑五险一金这些乱七八糟的东西，我们只关注如何计算个税。为了简化，我们假设直接扣除一个免征额后按20%计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">calculateIncomeTax</span><span class="params">(IncomeRecord record)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">3500</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">tax</span> <span class="operator">=</span> record.salary &lt;= threshold ? <span class="number">0</span> : (record.salary - threshold) * <span class="number">0.2</span>;</span><br><span class="line">    <span class="keyword">return</span> tax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个程序在2018年9月1号前是没问题的，问题是2018年9月1号后起征点调整到了5000，那2018年8月和2018年9月，计算结果应该不一样。怎么改？</p>
<p>普通开发者的改法：那还不简单？直接获取当前日期，返回正确的起征点就行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">calculateIncomeTax</span><span class="params">(IncomeRecord record)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">threshold</span> <span class="operator">=</span> today() &lt; date(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">1</span>) ? <span class="number">3500</span> : <span class="number">5000</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">tax</span> <span class="operator">=</span> record.salary &lt;= threshold ? <span class="number">0</span> : (record.salary - threshold) * <span class="number">0.2</span>;</span><br><span class="line">    <span class="keyword">return</span> tax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序是没错，问题是：</p>
<p>同样的输入，8月31号跑，和9月1号跑，结果不一样，难道会计要在9月1号做8月份的工资条，必须把电脑的时间先调到8月份？</p>
<p>用函数式编程的观点思考一下，就发现问题所在：</p>
<p><code>today()</code>这个函数，返回结果与时间有关，这就造成了<code>calculateIncomeTax()</code>不再是一个纯函数，它与当前时间相关了。</p>
<p>那怎么把<code>calculateIncomeTax()</code>恢复成一个纯函数，同时要支持起征点调整？</p>
<p>方法是把时间相关的变量作为参数传进来，例如，给<code>IncomeRecord</code>增加几个字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncomeRecord</span> &#123;</span><br><span class="line">    String id; <span class="comment">// 身份证号</span></span><br><span class="line">    String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="type">double</span> salary; <span class="comment">// 工资</span></span><br><span class="line">    <span class="type">int</span> year; <span class="comment">// 年</span></span><br><span class="line">    <span class="type">int</span> month; <span class="comment">// 月</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以消除<code>today()</code>的调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">calculateIncomeTax</span><span class="params">(IncomeRecord record)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">threshold</span> <span class="operator">=</span> date(record.year, record.month) &lt; date(<span class="number">2018</span>, <span class="number">9</span>) ? <span class="number">3500</span> : <span class="number">5000</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">tax</span> <span class="operator">=</span> record.salary &lt;= threshold ? <span class="number">0</span> : (record.salary - threshold) * <span class="number">0.2</span>;</span><br><span class="line">    <span class="keyword">return</span> tax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>calculateIncomeTax()</code>又变成了一个纯函数，会计就不用改电脑时间了。</p>
<p>是不是觉得这个例子太简单了？其实简单的函数如果都能写成有状态的，那么复杂的业务逻辑必然写成一锅粥。</p>
<p>举个复杂的栗子：</p>
<p>对于一个股票交易系统，如果我们把输入定义为：开盘前所有股民的现金和持股，以及交易时段的所有订单，那么，输出就是收盘后所有股民的现金和持股：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StockStatus <span class="title function_">process</span><span class="params">(StockStatus old, List&lt;Order&gt; orders)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (Order order : orders) &#123;</span><br><span class="line">        ...</span><br><span class="line">        sendExchangeResult(...); <span class="comment">// 给每一笔成交发送信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然这是一个纯函数，虽然在处理过程中，这个函数会给股民朋友发送各种心跳消息。</p>
<p>如果把交易系统的模型设计成这样一个纯函数，那么理论上我们只需要从股市开市的那一天开始，把所有订单全部处理一遍，就可以正确得到今天收盘后的状态。</p>
<p>或者说，只要取任意一天开盘前的系统状态的备份（就是整个数据库的备份），把当天的订单重新处理一遍，就得到了当天收盘的状态。这个过程可以做任意次，结果不变，因此，非常适合验证代码的修改是否影响了业务流程。</p>
<p>那么问题来了，交易系统中有无数和时间相关的状态，怎么处理成纯函数？这个模型的处理，可比计算个税复杂多了。</p>
<p>这就是函数式编程的精髓：业务系统模型无状态。模型的好坏，直接影响到代码的正确性、可靠性、稳定性，以及是否需要996。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="2025/05/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="2025/05/21/cheat-sheet/pandas-cheat-sheet/"
                            aria-label=": pandas cheat sheet"
                        >
                            pandas cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-21T13:08:04+08:00">
	
		    2025 年 5 月 21 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="categories/%E6%95%B0%E6%8D%AE/">数据</a>, <a class="category-link" href="categories/%E6%95%B0%E6%8D%AE/python/">python</a>, <a class="category-link" href="categories/%E6%95%B0%E6%8D%AE/python/pandas/">pandas</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="pandas">pandas:</h3>


	<div class="row">
    <embed src="/assets/pdf/pandas-cheat-sheet.pdf" width="100%" height="550" type="application/pdf">
	</div>




                    
                        


                    
                    
                        <p>
                            <a
                                href="2025/05/21/cheat-sheet/pandas-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="2025/05/21/cheat-sheet/spring-framework-cheat-sheet/"
                            aria-label=": spring-framework cheat sheet"
                        >
                            spring-framework cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-21T00:02:55+08:00">
	
		    2025 年 5 月 21 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/">Java</a>, <a class="category-link" href="categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring-framework-4/">spring-framework-4</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="java">java:</h3>


	<div class="row">
    <embed src="/assets/pdf/spring-framework-4-cheat-sheet.pdf" width="100%" height="550" type="application/pdf">
	</div>




                    
                        


                    
                    
                        <p>
                            <a
                                href="2025/05/21/cheat-sheet/spring-framework-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="2025/05/21/cheat-sheet/java-fundamentals-cheat-sheet/"
                            aria-label=": java fundamentals cheat sheet"
                        >
                            java fundamentals cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-21T00:01:18+08:00">
	
		    2025 年 5 月 21 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="java">java:</h3>


	<div class="row">
    <embed src="/assets/pdf/java-fundamentals-cheat-sheet.pdf" width="100%" height="550" type="application/pdf">
	</div>




                    
                        


                    
                    
                        <p>
                            <a
                                href="2025/05/21/cheat-sheet/java-fundamentals-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="2025/05/20/cheat-sheet/postgresql-cheat-sheet/"
                            aria-label=": postgresql cheat sheet"
                        >
                            postgresql cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-20T23:49:43+08:00">
	
		    2025 年 5 月 20 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="categories/database/">database</a>, <a class="category-link" href="categories/database/postgresql/">postgresql</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="postgresql">postgresql:</h3>


	<div class="row">
    <embed src="/assets/pdf/postgresql-cheat-sheet.pdf" width="100%" height="550" type="application/pdf">
	</div>





	<div class="row">
    <embed src="/assets/pdf/postgresql-cheat-sheet2.pdf" width="100%" height="550" type="application/pdf">
	</div>



                    
                        


                    
                    
                        <p>
                            <a
                                href="2025/05/20/cheat-sheet/postgresql-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="2025/05/20/cheat-sheet/django-cheat-sheet/"
                            aria-label=": django cheat sheet"
                        >
                            django cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-20T23:48:46+08:00">
	
		    2025 年 5 月 20 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/">服务端</a>, <a class="category-link" href="categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/python/">python</a>, <a class="category-link" href="categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/python/django/">django</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="django">django:</h3>


	<div class="row">
    <embed src="/assets/pdf/django-cheat-sheet.pdf" width="100%" height="550" type="application/pdf">
	</div>




                    
                        


                    
                    
                        <p>
                            <a
                                href="2025/05/20/cheat-sheet/django-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="2025/05/20/cheat-sheet/python-cheat-sheet/"
                            aria-label=": python cheat sheet"
                        >
                            python cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-20T23:48:40+08:00">
	
		    2025 年 5 月 20 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="categories/devops/">devops</a>, <a class="category-link" href="categories/devops/python/">python</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="python">python:</h3>


	<div class="row">
    <embed src="/assets/pdf/python-cheat-sheet.pdf" width="100%" height="550" type="application/pdf">
	</div>



                    
                        


                    
                    
                        <p>
                            <a
                                href="2025/05/20/cheat-sheet/python-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="page/2/"
                aria-label="下一頁"
            >
              <span>下一頁</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">第 1 頁 共 24 頁</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 235 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
