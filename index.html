
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"Website","@id":"https://chankein.github.io","author":{"@type":"Person","name":"Kein Chan","sameAs":["https://github.com/chankein/","https://www.linkedin.com/profile/","mailto:kein.chan85@gmail.com"],"image":"profile.jpg"},"name":"Kein's blog","description":"","url":"https://chankein.github.io"}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Kein&#39;s blog">
<meta property="og:url" content="https://chankein.github.io/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Kein Chan">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.ioassets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: /#about"
            >
        
        
            <img class="header-picture" src="assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="2017/08/12/git/git%E6%95%99%E7%A8%8B/"
                            aria-label=": git教程"
                        >
                            git教程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-08-12T15:38:45+08:00">
	
		    2017 年 8 月 12 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="categories/devops/">devops</a>, <a class="category-link" href="categories/devops/git/">git</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h5 id="初始化仓库">初始化仓库:</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m &#x27;initial project version&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="/assets/images/fileStatusLifecycle.png" alt="image"></p>
<h5 id="忽略某些文件">忽略某些文件</h5>
<p>我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。<br>
文件 .gitignore 的格式规范如下：</p>
<ul>
<li>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式最后跟反斜杠（/）说明要忽略的是目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li>
</ul>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。</p>
<p>我们再看一个 .gitignore 文件的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line"># 忽略所有 .a 结尾的文件</span><br><span class="line">*.a</span><br><span class="line"># 但 lib.a 除外</span><br><span class="line">!lib.a</span><br><span class="line"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"># 忽略 build/ 目录下的所有文件</span><br><span class="line">build/</span><br><span class="line"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"># 忽略 doc/ 目录下所有扩展名为 txt 的文件</span><br><span class="line">doc/**/*.txt</span><br></pre></td></tr></table></figure>
<h5 id="跟踪新文件">跟踪新文件</h5>
<p>使用命令 git add 开始跟踪一个新文件。所以，要跟踪 README 文件，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add README</span><br></pre></td></tr></table></figure>
<h5 id="提交更新">提交更新</h5>
<p>每次准备提交前，先用 git status 看下，是不是都已暂存起来了，然后再运行提交命令 git commit：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></table></figure>
<p>这种方式会启动文本编辑器以便输入本次提交的说明。（默认会启用 shell 的环境变量 $EDITOR 所指定的软件，一般都是 vim 或 emacs。当然也可以按照第一章介绍的方式，使用 ++git config --global core.editor++ 命令设定你喜欢的编辑软件。）</p>
<p>默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。（如果觉得这还不够，可以用 -v 选项将修改差异的每一行都包含到注释中来。）退出编辑器时，Git 会丢掉注释行，将说明内容和本次更新提交到仓库。</p>
<p>另外也可以用 +±m++ 参数后跟提交说明的方式，在一行命令中提交更新：</p>
<p>跳过使用暂存区域<br>
Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 <strong>git commit 加上 -a</strong> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤</p>
<h5 id="移除文件">移除文件</h5>
<p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 <strong>git rm</strong> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p>
<h5 id="移动文件">移动文件</h5>
<p>要在 Git 中对文件改名，可以这么做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mv file_from file_to</span><br></pre></td></tr></table></figure>
<p>运行 git mv 就相当于运行了下面三条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv README.txt README</span><br><span class="line">$ git rm README.txt</span><br><span class="line">$ git add README</span><br></pre></td></tr></table></figure>
<h5 id="查看提交历史">查看提交历史</h5>
<p>默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。看到了吗，每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间，最后缩进一个段落显示提交说明。</p>
<p>git log 有许多选项可以帮助你搜寻感兴趣的提交，接下来我们介绍些最常用的。</p>
<p>我们常用 -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新</p>
<p>某些时候，单词层面的对比，比行层面的对比，更加容易观察。Git 提供了 +±-word-diff++ 选项。我们可以将其添加到 ++git log -p++ 命令的后面，从而获取单词层面上的对比。在程序代码中进行单词层面的对比常常是没什么用的。不过当你需要在书籍、论文这种很大的文本文件上进行对比的时候，这个功能就显出用武之地了。</p>
<p>另外，git log 还提供了许多摘要选项可以用，比如 --stat，仅显示简要的增改行数统计</p>
<p>用 oneline 或 format 时结合 --graph 选项，可以看到开头多出一些 ASCII 字符串表示的简单图形，形象地展示了每个提交所在的分支及其分化衍合情况。</p>
<p>另外还有按照时间作限制的选项，比如 --since 和 --until。</p>
<h5 id="撤消操作">撤消操作</h5>
<p>有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用 --amend 选项重新提交：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%92%A4%E6%B6%88%E6%93%8D%E4%BD%9C">撤消操作</a></p>
<h5 id="远程仓库的使用">远程仓库的使用</h5>
<p>查看当前的远程库<br>
要查看当前配置有哪些远程仓库，可以用 git remote 命令，它会列出每个远程库的简短名字。<br>
也可以加上 -v 选项（译注：此为 --verbose 的简写，取首字母），显示对应的克隆地址</p>
<p>添加远程仓库</p>
<p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add [shortname] [url]：</span><br></pre></td></tr></table></figure>
<p>现在可以用字符串 pb 指代对应的仓库地址了。比如说，要抓取所有 Paul 有的，但本地仓库没有的信息，可以运行 git fetch pb</p>
<p>从远程仓库抓取数据</p>
<p>正如之前所看到的，可以用下面的命令从远程仓库抓取数据到本地：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch [remote-name]</span><br></pre></td></tr></table></figure>
<p>推送数据到远程仓库</p>
<p>目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库中的数据推送到远程仓库。实现这个任务的命令很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [remote-name] [branch-name]。</span><br></pre></td></tr></table></figure>
<p>如果要把本地的 master 分支推送到 origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<p>查看远程仓库信息<br>
我们可以通过命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show [remote-name]</span><br></pre></td></tr></table></figure>
<p>查看某个远程仓库的详细信息</p>
<p>远程仓库的删除和重命名<br>
在新版 Git 中可以用 git remote rename 命令修改某个远程仓库在本地的简称，比如想把 pb 改成 paul，可以这么运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure>
<p>碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
<h5 id="打标签">打标签</h5>
<p><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE/">打标签</a></p>
<h5 id="Git-命令别名">Git 命令别名</h5>
<p>Git 并不会推断你输入的几个字符将会是哪条命令，不过如果想偷懒，少敲几个命令的字符，可以用 git config 为命令设置别名。来看看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure>
<p>取消暂存文件时的输入比较繁琐，可以自己设置一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.unstage &#x27;reset HEAD --&#x27;</span><br></pre></td></tr></table></figure>
<p>这样一来，下面的两条命令完全等同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git unstage fileA</span><br><span class="line">$ git reset HEAD fileA</span><br></pre></td></tr></table></figure>
<p>显然，使用别名的方式看起来更清楚。另外，我们还经常设置 last 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.last &#x27;log -1 HEAD&#x27;</span><br></pre></td></tr></table></figure>
<p>然后要看最后一次的提交信息，就变得简单多了</p>
<h5 id="分支的新建与切换">分支的新建与切换</h5>
<p>要新建并切换到该分支，运行 git checkout 并加上 -b 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b iss53</span><br><span class="line">Switched to a new branch &#x27;iss53&#x27;</span><br></pre></td></tr></table></figure>
<p>回到 master 分支并把它合并进来，然后发布到生产服务器。用 git merge 命令来进行合并：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge hotfix</span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> README | 1 -</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br></pre></td></tr></table></figure>
<p>这相当于执行下面这两条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch iss53</span><br><span class="line">$ git checkout iss53</span><br></pre></td></tr></table></figure>
<p>如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。</p>
<p>合并之后，master 分支和 hotfix 分支指向同一位置。<br>
由于当前 hotfix 分支和 master 都指向相同的提交对象，所以 hotfix 已经完成了历史使命，可以删掉了。使用 git branch 的 -d 选项执行删除操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d hotfix</span><br><span class="line">Deleted branch hotfix (was 3a0874c).</span><br></pre></td></tr></table></figure>
<h5 id="遇到冲突时的分支合并">遇到冲突时的分支合并</h5>
<p>有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）。<br>
Git 作了合并，但没有提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用 <strong>git status</strong> 查阅</p>
<p>任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line">=======</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">  please contact us at support@github.com</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53</span><br></pre></td></tr></table></figure>
<p>可以看到 ======= 隔开的上半部分，是 HEAD（即 master 分支，在运行 merge 命令时所切换到的分支）中的内容，下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">please contact us at email.support@github.com</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>这个解决方案各采纳了两个分支中的一部分内容，而且我还删除了 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，======= 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行。在解决了所有文件里的所有冲突后，运行 git add 将把它们标记为已解决状态（译注：实际上就是来一次快照保存到暂存区域。）。</p>
<p>再运行一次 git status 来确认所有冲突都已解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   index.html</span><br></pre></td></tr></table></figure>
<p>如果觉得满意了，并且确认所有冲突都已解决，也就是进入了暂存区，就可以用 git commit 来完成这次合并提交。提交的记录差不多是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Merge branch &#x27;iss53&#x27;</span><br><span class="line"></span><br><span class="line">Conflicts:</span><br><span class="line">  index.html</span><br><span class="line">#</span><br><span class="line"># It looks like you may be committing a merge.</span><br><span class="line"># If this is not correct, please remove the file</span><br><span class="line">#       .git/MERGE_HEAD</span><br><span class="line"># and try again.</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<h5 id="查看当前的远程库">查看当前的远程库</h5>
<p>要查看当前配置有哪些远程仓库，可以用 git remote 命令，它会列出每个远程库的简短名字。<br>
可以加上 -v 选项（译注：此为 --verbose 的简写，取首字母），显示对应的克隆地址</p>
<h5 id="添加远程仓库">添加远程仓库</h5>
<p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add [shortname] [url]：</span><br></pre></td></tr></table></figure>
<h5 id="从远程仓库抓取数据">从远程仓库抓取数据</h5>
<p>正如之前所看到的，可以用下面的命令从远程仓库抓取数据到本地：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch [remote-name]</span><br></pre></td></tr></table></figure>
<p>推送数据到远程仓库<br>
项目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库中的数据推送到远程仓库。实现这个任务的命令很简单： git push [remote-name] [branch-name]。如果要把本地的 master 分支推送到 origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<p>只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。</p>
<p>查看远程仓库信息<br>
我们可以通过命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show [remote-name]</span><br></pre></td></tr></table></figure>
<p>查看某个远程仓库的详细信息</p>
<h1></h1>
<p>远程仓库的删除和重命名<br>
在新版 Git 中可以用 git remote rename 命令修改某个远程仓库在本地的简称，比如想把 pb 改成 paul，可以这么运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure>
<p>注意，对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 pb/master 分支现在成了 paul/master。</p>
<p>碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
<h5 id="远程分支">远程分支</h5>
<p>我们用 ==(远程仓库名)/(分支名)== 这样的形式表示远程分支。比如我们想看看上次同 origin 仓库通讯时 master 分支的样子，就应该查看 origin/master 分支。如果你和同伴一起修复某个问题，但他们先推送了一个 iss53 分支到远程仓库，虽然你可能也有一个本地的 iss53 分支，但指向服务器上最新更新的却应该是 origin/iss53 分支。</p>
<p>可以运行 git fetch origin 来同步远程服务器上的数据到本地。该命令首先找到 origin 是哪个服务器（本例为 <a target="_blank" rel="noopener" href="http://git.ourcompany.com">git.ourcompany.com</a>），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 origin/master 的指针移到它最新的位置上<br>
<img src="/assets/images/gitfetch.png" alt="image"></p>
<p>为了演示拥有多个远程分支（在不同的远程服务器上）的项目是如何工作的，我们假设你还有另一个仅供你的敏捷开发小组使用的内部服务器 <a target="_blank" rel="noopener" href="http://git.team1.ourcompany.com">git.team1.ourcompany.com</a>。可以用第二章中提到的 git remote add 命令把它加为当前项目的远程分支之一。我们把它命名为 teamone，以便代替完整的 Git URL 以方便使用<br>
<img src="/assets/images/gitaddremote.png" alt="image"><br>
现在你可以用 git fetch teamone 来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你 origin 服务器上的子集，Git 不会下载任何数据，而只是简单地创建一个名为 teamone/master 的远程分支，指向 teamone 服务器上 master 分支所在的提交对象 31b8e（见图 3-26）。</p>
<p><img src="/assets/images/gitfetchremote.png" alt="image"></p>
<h5 id="推送本地分支">推送本地分支</h5>
<p>要想和其他人分享某个本地分支，你需要把它推送到一个你拥有写权限的远程仓库。你创建的本地分支不会因为你的写入操作而被自动同步到你引入的远程服务器上，你需要明确地执行推送分支的操作。</p>
<p>如果你有个叫 serverfix 的分支需要和他人一起开发，可以运行 git push (远程仓库名) (分支名)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin serverfix</span><br><span class="line">Counting objects: 20, done.</span><br><span class="line">Compressing objects: 100% (14/14), done.</span><br><span class="line">Writing objects: 100% (15/15), 1.74 KiB, done.</span><br><span class="line">Total 15 (delta 5), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new branch]      serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure>
<p>这里其实走了一点捷径。Git 自动把 serverfix 分支名扩展为 refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的 serverfix 分支，推送到远程仓库的 serverfix 分支中去”。</p>
<p>也可以运行 ==git push origin serverfix:serverfix== 来实现相同的效果，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作 awesomebranch，可以用 git push origin serverfix:awesomebranch 来推送数据。</p>
<h5 id="跟踪远程分支">跟踪远程分支</h5>
<p>从远程分支 checkout 出来的本地分支，称为 跟踪分支 (tracking branch)。跟踪分支是一种和某个远程分支有直接联系的本地分支。在跟踪分支里输入 git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。同样，在这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来。</p>
<p>在克隆仓库时，Git 通常会自动创建一个名为 master 的分支来跟踪 origin/master。这正是 git push 和 git pull 一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如 origin 上除了 master 之外的其它分支。刚才我们已经看到了这样的一个例子：git checkout -b [分支名] [远程名]/[分支名]。如果你有 1.6.2 以上版本的 Git，还可以用 --track 选项简化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout --track origin/serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;serverfix&#x27;</span><br></pre></td></tr></table></figure>
<p>要为本地分支设定不同于远程分支的名字，只需在第一个版本的命令里换个名字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b sf origin/serverfix</span><br><span class="line">Branch sf set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;sf&#x27;</span><br></pre></td></tr></table></figure>
<p>现在你的本地分支 sf 会自动将推送和抓取数据的位置定位到 origin/serverfix 了</p>
<h5 id="删除远程分支">删除远程分支</h5>
<p>如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的 master 分支（或任何其他存放稳定代码的分支），可以用这个非常无厘头的语法来删除它：git push [远程名] :[分支名]。如果想在服务器上删除 serverfix 分支，运行下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :serverfix</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure>
<p>咚！服务器上的分支没了。你最好特别留心这一页，因为你一定会用到那个命令，而且你很可能会忘掉它的语法。有种方便记忆这条命令的方法：==记住我们不久前见过的 git push [远程名] [本地分支]:[远程分支] 语法，如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]”==。</p>
<h5 id="解决远程分支和本地冲突">解决远程分支和本地冲突</h5>
<p>1.先将本地修改储存起来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
<p>2.pull内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>
<p>3.还原暂存内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>
<p>4.解决冲突</p>
<p>5.提交</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#x27;&#x27;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>打标签</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.1 -m &#x27;&#x27;</span><br></pre></td></tr></table></figure>
<p>7.列标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -l</span><br></pre></td></tr></table></figure>
<p>8.获取标签代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout </span><br></pre></td></tr></table></figure>
<p>9.提交标签到远程端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push tag </span><br></pre></td></tr></table></figure>
<h5 id="拉取本地没有的远程分支">拉取本地没有的远程分支</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 本地分支名 origin/远程分支名</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E5%8F%98%E5%9F%BA/">后续:变基rebase</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="2017/08/12/git/git%E6%95%99%E7%A8%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="2025/06/14/python%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"
                            aria-label=": 3.python高级特性"
                        >
                            3.python高级特性
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-06-14T23:10:34+08:00">
	
		    2025 年 6 月 14 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/">python</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    
                    
                        


                    
                    
                        <p>
                            <a
                                href="2025/06/14/python%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="2025/06/14/python/2.python%E5%87%BD%E6%95%B0/"
                            aria-label=": 2.python函数"
                        >
                            2.python函数
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-06-14T23:05:42+08:00">
	
		    2025 年 6 月 14 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/">python</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="函数">函数</h2>
<p>我们知道圆的面积计算公式为：</p>
<p>当我们知道半径<code>r</code>的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r1 = 12.34</span><br><span class="line">r2 = 9.08</span><br><span class="line">r3 = 73.1</span><br><span class="line">s1 = 3.14 * r1 * r1</span><br><span class="line">s2 = 3.14 * r2 * r2</span><br><span class="line">s3 = 3.14 * r3 * r3</span><br></pre></td></tr></table></figure>
<p>当代码出现有规律的重复的时候，你就需要当心了，每次写<code>3.14 * x * x</code>不仅很麻烦，而且，如果要把<code>3.14</code>改成<code>3.14159265359</code>的时候，得全部替换。</p>
<p>有了函数，我们就不再每次写<code>s = 3.14 * x * x</code>，而是写成更有意义的函数调用<code>s = area_of_circle(x)</code>，而函数<code>area_of_circle</code>本身只需要写一次，就可以多次调用。</p>
<p>基本上所有的高级语言都支持函数，Python也不例外。Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。</p>
<h3 id="抽象">抽象</h3>
<p>抽象是数学中非常常见的概念。举个例子：</p>
<p>计算数列的和，比如：<code>1 + 2 + 3 + ... + 100</code>，写起来十分不方便，于是数学家发明了求和符号∑，可以把<code>1 + 2 + 3 + ... + 100</code>记作：</p>
<p>这种抽象记法非常强大，因为我们看到 ∑ 就可以理解成求和，而不是还原成低级的加法运算。</p>
<p>而且，这种抽象记法是可扩展的，比如：</p>
<p>还原成加法运算就变成了：</p>
<p>(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + … + (100 x 100 + 1)</p>
<p>可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。</p>
<p>写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。</p>
<hr>
<h2 id="调用函数">调用函数</h2>
<p>Python内置了很多有用的函数，我们可以直接调用。</p>
<p>要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数<code>abs</code>，只有一个参数。可以直接从Python的官方网站查看<a target="_blank" rel="noopener" href="http://docs.python.org/3/library/functions.html#abs">文档</a>，也可以在交互式命令行通过<code>help(abs)</code>查看<code>abs</code>函数的帮助信息。</p>
<p>调用<code>abs</code>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(100)</span><br><span class="line">100</span><br><span class="line">&gt;&gt;&gt; abs(-20)</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt; abs(12.34)</span><br><span class="line">12.34</span><br></pre></td></tr></table></figure>
<p>调用函数的时候，如果传入的参数数量不对，会报<code>TypeError</code>的错误，并且Python会明确地告诉你：<code>abs()</code>有且仅有1个参数，但给出了两个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(1, 2)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: abs() takes exactly one argument (2 given)</span><br></pre></td></tr></table></figure>
<p>如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报<code>TypeError</code>的错误，并且给出错误信息：<code>str</code>是错误的参数类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(&#x27;a&#x27;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: bad operand type for abs(): &#x27;str&#x27;</span><br></pre></td></tr></table></figure>
<p>而<code>max</code>函数<code>max()</code>可以接收任意多个参数，并返回最大的那个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; max(1, 2)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; max(2, 3, 1, -5)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="数据类型转换">数据类型转换</h3>
<p>Python内置的常用函数还包括数据类型转换函数，比如<code>int()</code>函数可以把其他数据类型转换为整数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int(&#x27;123&#x27;)</span><br><span class="line">123</span><br><span class="line">&gt;&gt;&gt; int(12.34)</span><br><span class="line">12</span><br><span class="line">&gt;&gt;&gt; float(&#x27;12.34&#x27;)</span><br><span class="line">12.34</span><br><span class="line">&gt;&gt;&gt; str(1.23)</span><br><span class="line">&#x27;1.23&#x27;</span><br><span class="line">&gt;&gt;&gt; str(100)</span><br><span class="line">&#x27;100&#x27;</span><br><span class="line">&gt;&gt;&gt; bool(1)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; bool(&#x27;&#x27;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = abs # 变量a指向abs函数</span><br><span class="line">&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="练习">练习</h3>
<p>请利用Python内置的<code>hex()</code>函数把一个整数转换成十六进制表示的字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n1 = <span class="number">255</span></span><br><span class="line">n2 = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(???)</span><br></pre></td></tr></table></figure>
<h3 id="参考源码">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/function/call-function/call_func.py">call_func.py</a></p>
<h3 id="小结">小结</h3>
<p>调用Python的函数，需要根据函数定义，传入正确的参数。如果函数调用出错，一定要学会看错误信息，所以英文很重要！</p>
<hr>
<p>在Python中，定义一个函数要使用<code>def</code>语句，依次写出函数名、括号、括号中的参数和冒号<code>:</code>，然后，在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回。</p>
<p>我们以自定义一个求绝对值的<code>my_abs</code>函数为例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_abs</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_abs(-<span class="number">99</span>))</span><br></pre></td></tr></table></figure>
<p>请自行测试并调用<code>my_abs</code>看看返回结果是否正确。</p>
<p>请注意，函数体内部的语句在执行时，一旦执行到<code>return</code>时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。</p>
<p>如果没有<code>return</code>语句，函数执行完毕后也会返回结果，只是结果为<code>None</code>。<code>return None</code>可以简写为<code>return</code>。</p>
<p>在Python交互环境中定义函数时，注意Python会出现<code>...</code>的提示。函数定义结束后需要按两次回车重新回到<code>&gt;&gt;&gt;</code>提示符下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────┐</span><br><span class="line">│Windows PowerShell                                 - □ x │</span><br><span class="line">├─────────────────────────────────────────────────────────┤</span><br><span class="line">│&gt;&gt;&gt; def my_abs(x):                                       │</span><br><span class="line">│...     if x &gt;= 0:                                       │</span><br><span class="line">│...         return x                                     │</span><br><span class="line">│...     else:                                            │</span><br><span class="line">│...         return -x                                    │</span><br><span class="line">│...                                                      │</span><br><span class="line">│&gt;&gt;&gt; my_abs(-9)                                           │</span><br><span class="line">│9                                                        │</span><br><span class="line">│&gt;&gt;&gt;                                                      │</span><br><span class="line">│                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>如果你已经把<code>my_abs()</code>的函数定义保存为<code>abstest.py</code>文件了，那么，可以在该文件的当前目录下启动Python解释器，用<code>from abstest import my_abs</code>来导入<code>my_abs()</code>函数，注意<code>abstest</code>是文件名（不含<code>.py</code>扩展名）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────┐</span><br><span class="line">│Windows PowerShell                                 - □ x │</span><br><span class="line">├─────────────────────────────────────────────────────────┤</span><br><span class="line">│&gt;&gt;&gt; from abstest import my_abs                           │</span><br><span class="line">│&gt;&gt;&gt; my_abs(-9)                                           │</span><br><span class="line">│9                                                        │</span><br><span class="line">│&gt;&gt;&gt;                                                      │</span><br><span class="line">│                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<p><code>import</code>的用法在后续<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/module/index.html">模块</a>一节中会详细介绍。</p>
<h3 id="空函数">空函数</h3>
<p>如果想定义一个什么事也不做的空函数，可以用<code>pass</code>语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nop</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><code>pass</code>语句什么都不做，那有什么用？实际上<code>pass</code>可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个<code>pass</code>，让代码能运行起来。</p>
<p><code>pass</code>还可以用在其他语句里，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>缺少了<code>pass</code>，代码运行就会有语法错误。</p>
<h3 id="参数检查">参数检查</h3>
<p>调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出<code>TypeError</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; my_abs(1, 2)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: my_abs() takes 1 positional argument but 2 were given</span><br></pre></td></tr></table></figure>
<p>但是如果参数类型不对，Python解释器就无法帮我们检查。试试<code>my_abs</code>和内置函数<code>abs</code>的差别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; my_abs(&#x27;A&#x27;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 2, in my_abs</span><br><span class="line">TypeError: unorderable types: str() &gt;= int()</span><br><span class="line">&gt;&gt;&gt; abs(&#x27;A&#x27;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: bad operand type for abs(): &#x27;str&#x27;</span><br></pre></td></tr></table></figure>
<p>当传入了不恰当的参数时，内置函数<code>abs</code>会检查出参数错误，而我们定义的<code>my_abs</code>没有参数检查，会导致<code>if</code>语句出错，出错信息和<code>abs</code>不一样。所以，这个函数定义不够完善。</p>
<p>让我们修改一下<code>my_abs</code>的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数<code>isinstance()</code>实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_abs</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x, (<span class="built_in">int</span>, <span class="built_in">float</span>)):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&#x27;bad operand type&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>
<p>添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; my_abs(&#x27;A&#x27;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 3, in my_abs</span><br><span class="line">TypeError: bad operand type</span><br></pre></td></tr></table></figure>
<p>错误和异常处理将在后续讲到。</p>
<h3 id="返回多个值">返回多个值</h3>
<p>函数可以返回多个值吗？答案是肯定的。</p>
<p>比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">x, y, step, angle=<span class="number">0</span></span>):</span><br><span class="line">    nx = x + step * math.cos(angle)</span><br><span class="line">    ny = y - step * math.sin(angle)</span><br><span class="line">    <span class="keyword">return</span> nx, ny</span><br></pre></td></tr></table></figure>
<p><code>import math</code>语句表示导入<code>math</code>包，并允许后续代码引用<code>math</code>包里的<code>sin</code>、<code>cos</code>等函数。</p>
<p>然后，我们就可以同时获得返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)</span><br><span class="line">&gt;&gt;&gt; print(x, y)</span><br><span class="line">151.96152422706632 70.0</span><br></pre></td></tr></table></figure>
<p>但其实这只是一种假象，Python函数返回的仍然是单一值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)</span><br><span class="line">&gt;&gt;&gt; print(r)</span><br><span class="line">(151.96152422706632, 70.0)</span><br></pre></td></tr></table></figure>
<p>原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p>
<h3 id="练习-2">练习</h3>
<p>请定义一个函数<code>quadratic(a, b, c)</code>，接收3个参数，返回一元二次方程 ax2+bx+c=0ax^2+bx+c=0 的两个解。</p>
<p>提示：</p>
<p>一元二次方程的求根公式为：</p>
<p>计算平方根可以调用<code>math.sqrt()</code>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import math</span><br><span class="line">&gt;&gt;&gt; math.sqrt(2)</span><br><span class="line">1.4142135623730951</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quadratic</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;quadratic(2, 3, 1) =&#x27;</span>, quadratic(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;quadratic(1, 3, -4) =&#x27;</span>, quadratic(<span class="number">1</span>, <span class="number">3</span>, -<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> quadratic(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>) != (-<span class="number">0.5</span>, -<span class="number">1.0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> quadratic(<span class="number">1</span>, <span class="number">3</span>, -<span class="number">4</span>) != (<span class="number">1.0</span>, -<span class="number">4.0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试成功&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="参考源码-2">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/function/define-function/def_func.py">def_func.py</a></p>
<h3 id="小结-2">小结</h3>
<p>定义函数时，需要确定函数名和参数个数；</p>
<p>如果有必要，可以先对参数的数据类型做检查；</p>
<p>函数体内部可以用<code>return</code>随时返回函数结果；</p>
<p>函数执行完毕也没有<code>return</code>语句时，自动<code>return None</code>。</p>
<p>函数可以同时返回多个值，但其实就是一个tuple。</p>
<p>定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。</p>
<p>Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p>
<h3 id="位置参数">位置参数</h3>
<p>我们先写一个计算x2的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br></pre></td></tr></table></figure>
<p>对于<code>power(x)</code>函数，参数<code>x</code>就是一个位置参数。</p>
<p>当我们调用<code>power</code>函数时，必须传入有且仅有的一个参数<code>x</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; power(15)</span><br><span class="line">225</span><br></pre></td></tr></table></figure>
<p>现在，如果我们要计算x3怎么办？可以再定义一个<code>power3</code>函数，但是如果要计算x4、x5……怎么办？我们不可能定义无限多个函数。</p>
<p>你也许想到了，可以把<code>power(x)</code>修改为<code>power(x, n)</code>，用来计算xn，说干就干：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x, n</span>):</span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<p>对于这个修改后的<code>power(x, n)</code>函数，可以计算任意n次方：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5, 2)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; power(5, 3)</span><br><span class="line">125</span><br></pre></td></tr></table></figure>
<p>修改后的<code>power(x, n)</code>函数有两个参数：<code>x</code>和<code>n</code>，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数<code>x</code>和<code>n</code>。</p>
<h3 id="默认参数">默认参数</h3>
<p>新的<code>power(x, n)</code>函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: power() missing 1 required positional argument: &#x27;n&#x27;</span><br></pre></td></tr></table></figure>
<p>Python的错误信息很明确：调用函数<code>power()</code>缺少了一个位置参数<code>n</code>。</p>
<p>这个时候，默认参数就排上用场了。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x, n=<span class="number">2</span></span>):</span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<p>这样，当我们调用<code>power(5)</code>时，相当于调用<code>power(5, 2)</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; power(5, 2)</span><br><span class="line">25</span><br></pre></td></tr></table></figure>
<p>而对于<code>n &gt; 2</code>的其他情况，就必须明确地传入n，比如<code>power(5, 3)</code>。</p>
<p>从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意：</p>
<p>一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；</p>
<p>二是如何设置默认参数。</p>
<p>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</p>
<p>使用默认参数有什么好处？最大的好处是能降低调用函数的难度。</p>
<p>举个例子，我们写个一年级小学生注册的函数，需要传入<code>name</code>和<code>gender</code>两个参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">enroll</span>(<span class="params">name, gender</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;name:&#x27;</span>, name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;gender:&#x27;</span>, gender)</span><br></pre></td></tr></table></figure>
<p>这样，调用<code>enroll()</code>函数只需要传入两个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; enroll(&#x27;Sarah&#x27;, &#x27;F&#x27;)</span><br><span class="line">name: Sarah</span><br><span class="line">gender: F</span><br></pre></td></tr></table></figure>
<p>如果要继续传入年龄、城市等信息怎么办？这样会使得调用函数的复杂度大大增加。</p>
<p>我们可以把年龄和城市设为默认参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">enroll</span>(<span class="params">name, gender, age=<span class="number">6</span>, city=<span class="string">&#x27;Beijing&#x27;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;name:&#x27;</span>, name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;gender:&#x27;</span>, gender)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;age:&#x27;</span>, age)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;city:&#x27;</span>, city)</span><br></pre></td></tr></table></figure>
<p>这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; enroll(&#x27;Sarah&#x27;, &#x27;F&#x27;)</span><br><span class="line">name: Sarah</span><br><span class="line">gender: F</span><br><span class="line">age: 6</span><br><span class="line">city: Beijing</span><br></pre></td></tr></table></figure>
<p>只有与默认参数不符的学生才需要提供额外的信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enroll(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">7</span>)</span><br><span class="line">enroll(<span class="string">&#x27;Adam&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, city=<span class="string">&#x27;Tianjin&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>可见，默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。</p>
<p>有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用<code>enroll('Bob', 'M', 7)</code>，意思是，除了<code>name</code>，<code>gender</code>这两个参数外，最后1个参数应用在参数<code>age</code>上，<code>city</code>参数由于没有提供，仍然使用默认值。</p>
<p>也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用<code>enroll('Adam', 'M', city='Tianjin')</code>，意思是，<code>city</code>参数用传进去的值，其他默认参数继续使用默认值。</p>
<p>默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，演示如下：</p>
<p>先定义一个函数，传入一个list，添加一个<code>END</code>再返回：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_end</span>(<span class="params">L=[]</span>):</span><br><span class="line">    L.append(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure>
<p>当你正常调用时，结果似乎不错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; add_end([1, 2, 3])</span><br><span class="line">[1, 2, 3, &#x27;END&#x27;]</span><br><span class="line">&gt;&gt;&gt; add_end([&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;])</span><br><span class="line">[&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;END&#x27;]</span><br></pre></td></tr></table></figure>
<p>当你使用默认参数调用时，一开始结果也是对的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#x27;END&#x27;]</span><br></pre></td></tr></table></figure>
<p>但是，再次调用<code>add_end()</code>时，结果就不对了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#x27;END&#x27;, &#x27;END&#x27;]</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#x27;END&#x27;, &#x27;END&#x27;, &#x27;END&#x27;]</span><br></pre></td></tr></table></figure>
<p>很多初学者很疑惑，默认参数是<code>[]</code>，但是函数似乎每次都“记住了”上次添加了<code>'END'</code>后的list。</p>
<p>原因解释如下：</p>
<p>Python函数在定义的时候，默认参数<code>L</code>的值就被计算出来了，即<code>[]</code>，因为默认参数<code>L</code>也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了<code>L</code>的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。</p>
<p>特别注意</p>
<p>定义默认参数要牢记一点：默认参数必须指向不变对象！</p>
<p>要修改上面的例子，我们可以用<code>None</code>这个不变对象来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_end</span>(<span class="params">L=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure>
<p>现在，无论调用多少次，都不会有问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#x27;END&#x27;]</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#x27;END&#x27;]</span><br></pre></td></tr></table></figure>
<p>为什么要设计<code>str</code>、<code>None</code>这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p>
<h3 id="可变参数">可变参数</h3>
<p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。</p>
<p>我们以数学题为例子，给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……。</p>
<p>要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">numbers</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + n * n</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>
<p>但是调用的时候，需要先组装出一个list或tuple：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; calc([1, 2, 3])</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; calc((1, 3, 5, 7))</span><br><span class="line">84</span><br></pre></td></tr></table></figure>
<p>如果利用可变参数，调用函数的方式可以简化成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; calc(1, 2, 3)</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; calc(1, 3, 5, 7)</span><br><span class="line">84</span><br></pre></td></tr></table></figure>
<p>所以，我们把函数的参数改为可变参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">*numbers</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + n * n</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>
<p>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个<code>*</code>号。在函数内部，参数<code>numbers</code>接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; calc(1, 2)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; calc()</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; calc(nums[0], nums[1], nums[2])</span><br><span class="line">14</span><br></pre></td></tr></table></figure>
<p>这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个<code>*</code>号，把list或tuple的元素变成可变参数传进去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; calc(*nums)</span><br><span class="line">14</span><br></pre></td></tr></table></figure>
<p><code>*nums</code>表示把<code>nums</code>这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。</p>
<h3 id="关键字参数">关键字参数</h3>
<p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, **kw</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;name:&#x27;</span>, name, <span class="string">&#x27;age:&#x27;</span>, age, <span class="string">&#x27;other:&#x27;</span>, kw)</span><br></pre></td></tr></table></figure>
<p>函数<code>person</code>除了必选参数<code>name</code>和<code>age</code>外，还接受关键字参数<code>kw</code>。在调用该函数时，可以只传入必选参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&#x27;Michael&#x27;, 30)</span><br><span class="line">name: Michael age: 30 other: &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>也可以传入任意个数的关键字参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&#x27;Bob&#x27;, 35, city=&#x27;Beijing&#x27;)</span><br><span class="line">name: Bob age: 35 other: &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&#x27;Adam&#x27;, 45, gender=&#x27;M&#x27;, job=&#x27;Engineer&#x27;)</span><br><span class="line">name: Adam age: 45 other: &#123;&#x27;gender&#x27;: &#x27;M&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>关键字参数有什么用？它可以扩展函数的功能。比如，在<code>person</code>函数里，我们保证能接收到<code>name</code>和<code>age</code>这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。</p>
<p>和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; extra = &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&#x27;Jack&#x27;, 24, city=extra[&#x27;city&#x27;], job=extra[&#x27;job&#x27;])</span><br><span class="line">name: Jack age: 24 other: &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>当然，上面复杂的调用可以用简化的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; extra = &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&#x27;Jack&#x27;, 24, **extra)</span><br><span class="line">name: Jack age: 24 other: &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p><code>**extra</code>表示把<code>extra</code>这个dict的所有key-value用关键字参数传入到函数的<code>**kw</code>参数，<code>kw</code>将获得一个dict，注意<code>kw</code>获得的dict是<code>extra</code>的一份拷贝，对<code>kw</code>的改动不会影响到函数外的<code>extra</code>。</p>
<h3 id="命名关键字参数">命名关键字参数</h3>
<p>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过<code>kw</code>检查。</p>
<p>仍以<code>person()</code>函数为例，我们希望检查是否有<code>city</code>和<code>job</code>参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, **kw</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;city&#x27;</span> <span class="keyword">in</span> kw:</span><br><span class="line">        <span class="comment"># 有city参数</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;job&#x27;</span> <span class="keyword">in</span> kw:</span><br><span class="line">        <span class="comment"># 有job参数</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;name:&#x27;</span>, name, <span class="string">&#x27;age:&#x27;</span>, age, <span class="string">&#x27;other:&#x27;</span>, kw)</span><br></pre></td></tr></table></figure>
<p>但是调用者仍可以传入不受限制的关键字参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&#x27;Jack&#x27;, 24, city=&#x27;Beijing&#x27;, addr=&#x27;Chaoyang&#x27;, zipcode=123456)</span><br></pre></td></tr></table></figure>
<p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收<code>city</code>和<code>job</code>作为关键字参数。这种方式定义的函数如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, *, city, job</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, city, job)</span><br></pre></td></tr></table></figure>
<p>和关键字参数<code>**kw</code>不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。</p>
<p>调用方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&#x27;Jack&#x27;, 24, city=&#x27;Beijing&#x27;, job=&#x27;Engineer&#x27;)</span><br><span class="line">Jack 24 Beijing Engineer</span><br></pre></td></tr></table></figure>
<p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, *args, city, job</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, args, city, job)</span><br></pre></td></tr></table></figure>
<p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&#x27;Jack&#x27;, 24, &#x27;Beijing&#x27;, &#x27;Engineer&#x27;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: person() missing 2 required keyword-only arguments: &#x27;city&#x27; and &#x27;job&#x27;</span><br></pre></td></tr></table></figure>
<p>由于调用时缺少参数名<code>city</code>和<code>job</code>，Python解释器把前两个参数视为位置参数，后两个参数传给<code>*args</code>，但缺少命名关键字参数导致报错。</p>
<p>命名关键字参数可以有缺省值，从而简化调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, *, city=<span class="string">&#x27;Beijing&#x27;</span>, job</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, city, job)</span><br></pre></td></tr></table></figure>
<p>由于命名关键字参数<code>city</code>具有默认值，调用时，可不传入<code>city</code>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&#x27;Jack&#x27;, 24, job=&#x27;Engineer&#x27;)</span><br><span class="line">Jack 24 Beijing Engineer</span><br></pre></td></tr></table></figure>
<p>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个<code>*</code>作为特殊分隔符。如果缺少<code>*</code>，Python解释器将无法识别位置参数和命名关键字参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, city, job</span>):</span><br><span class="line">    <span class="comment"># 缺少 *，city和job被视为位置参数</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="参数组合">参数组合</h3>
<p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p>
<p>比如定义一个函数，包含上述若干种参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">a, b, c=<span class="number">0</span>, *args, **kw</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a, <span class="string">&#x27;b =&#x27;</span>, b, <span class="string">&#x27;c =&#x27;</span>, c, <span class="string">&#x27;args =&#x27;</span>, args, <span class="string">&#x27;kw =&#x27;</span>, kw)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">a, b, c=<span class="number">0</span>, *, d, **kw</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a, <span class="string">&#x27;b =&#x27;</span>, b, <span class="string">&#x27;c =&#x27;</span>, c, <span class="string">&#x27;d =&#x27;</span>, d, <span class="string">&#x27;kw =&#x27;</span>, kw)</span><br></pre></td></tr></table></figure>
<p>在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f1(1, 2)</span><br><span class="line">a = 1 b = 2 c = 0 args = () kw = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, c=3)</span><br><span class="line">a = 1 b = 2 c = 3 args = () kw = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, 3, &#x27;a&#x27;, &#x27;b&#x27;)</span><br><span class="line">a = 1 b = 2 c = 3 args = (&#x27;a&#x27;, &#x27;b&#x27;) kw = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, 3, &#x27;a&#x27;, &#x27;b&#x27;, x=99)</span><br><span class="line">a = 1 b = 2 c = 3 args = (&#x27;a&#x27;, &#x27;b&#x27;) kw = &#123;&#x27;x&#x27;: 99&#125;</span><br><span class="line">&gt;&gt;&gt; f2(1, 2, d=99, ext=None)</span><br><span class="line">a = 1 b = 2 c = 0 d = 99 kw = &#123;&#x27;ext&#x27;: None&#125;</span><br></pre></td></tr></table></figure>
<p>最神奇的是通过一个tuple和dict，你也可以调用上述函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; args = (1, 2, 3, 4)</span><br><span class="line">&gt;&gt;&gt; kw = &#123;&#x27;d&#x27;: 99, &#x27;x&#x27;: &#x27;#&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(*args, **kw)</span><br><span class="line">a = 1 b = 2 c = 3 args = (4,) kw = &#123;&#x27;d&#x27;: 99, &#x27;x&#x27;: &#x27;#&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; args = (1, 2, 3)</span><br><span class="line">&gt;&gt;&gt; kw = &#123;&#x27;d&#x27;: 88, &#x27;x&#x27;: &#x27;#&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; f2(*args, **kw)</span><br><span class="line">a = 1 b = 2 c = 3 d = 88 kw = &#123;&#x27;x&#x27;: &#x27;#&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>所以，对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。</p>
<p>提示</p>
<p>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</p>
<h3 id="练习-3">练习</h3>
<p>以下函数允许计算两个数的乘积，请稍加改造，变成可接收一个或多个数并计算乘积：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mul(5) =&#x27;</span>, mul(<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mul(5, 6) =&#x27;</span>, mul(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mul(5, 6, 7) =&#x27;</span>, mul(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mul(5, 6, 7, 9) =&#x27;</span>, mul(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>))</span><br><span class="line"><span class="keyword">if</span> mul(<span class="number">5</span>) != <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;mul(5)测试失败!&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> mul(<span class="number">5</span>, <span class="number">6</span>) != <span class="number">30</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;mul(5, 6)测试失败!&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> mul(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>) != <span class="number">210</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;mul(5, 6, 7)测试失败!&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> mul(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>) != <span class="number">1890</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;mul(5, 6, 7, 9)测试失败!&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        mul()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;mul()测试失败!&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> TypeError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;测试成功!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="参考源码-3">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/function/parameter/var_args.py">var_args.py</a></p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/function/parameter/kw_args.py">kw_args.py</a></p>
<h3 id="小结-3">小结</h3>
<p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。</p>
<p>默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！</p>
<p>要注意定义可变参数和关键字参数的语法：</p>
<p><code>*args</code>是可变参数，args接收的是一个tuple；</p>
<p><code>**kw</code>是关键字参数，kw接收的是一个dict。</p>
<p>以及调用函数时如何传入可变参数和关键字参数的语法：</p>
<p>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；</p>
<p>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**&#123;'a': 1, 'b': 2&#125;)</code>。</p>
<p>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。</p>
<p>命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。</p>
<p>定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符<code>*</code>，否则定义的将是位置参数。</p>
<p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p>
<p>举个例子，我们来计算阶乘<code>n! = 1 x 2 x 3 x ... x n</code>，用函数<code>fact(n)</code>表示，可以看出：</p>
<p>所以，<code>fact(n)</code>可以表示为<code>n x fact(n-1)</code>，只有n=1时需要特殊处理。</p>
<p>于是，<code>fact(n)</code>用递归的方式写出来就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>上面就是一个递归函数。可以试试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fact(1)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; fact(5)</span><br><span class="line">120</span><br><span class="line">&gt;&gt;&gt; fact(100)</span><br><span class="line">93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</span><br></pre></td></tr></table></figure>
<p>如果我们计算<code>fact(5)</code>，可以根据函数定义看到计算过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">=&gt; fact(5)</span><br><span class="line">=&gt; 5 * fact(4)</span><br><span class="line">=&gt; 5 * (4 * fact(3))</span><br><span class="line">=&gt; 5 * (4 * (3 * fact(2)))</span><br><span class="line">=&gt; 5 * (4 * (3 * (2 * fact(1))))</span><br><span class="line">=&gt; 5 * (4 * (3 * (2 * 1)))</span><br><span class="line">=&gt; 5 * (4 * (3 * 2))</span><br><span class="line">=&gt; 5 * (4 * 6)</span><br><span class="line">=&gt; 5 * 24</span><br><span class="line">=&gt; 120</span><br></pre></td></tr></table></figure>
<p>递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</p>
<p>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试<code>fact(1000)</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fact(1000)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 4, in fact</span><br><span class="line">  ...</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 4, in fact</span><br><span class="line">RuntimeError: maximum recursion depth exceeded in comparison</span><br></pre></td></tr></table></figure>
<p>解决递归调用栈溢出的方法是通过<strong>尾递归</strong>优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p>
<p>尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p>
<p>上面的<code>fact(n)</code>函数由于<code>return n * fact(n - 1)</code>引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> fact_iter(n, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fact_iter</span>(<span class="params">num, product</span>):</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line">    <span class="keyword">return</span> fact_iter(num - <span class="number">1</span>, num * product)</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>return fact_iter(num - 1, num * product)</code>仅返回递归函数本身，<code>num - 1</code>和<code>num * product</code>在函数调用前就会被计算，不影响函数调用。</p>
<p><code>fact(5)</code>对应的<code>fact_iter(5, 1)</code>的调用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=&gt; fact_iter(5, 1)</span><br><span class="line">=&gt; fact_iter(4, 5)</span><br><span class="line">=&gt; fact_iter(3, 20)</span><br><span class="line">=&gt; fact_iter(2, 60)</span><br><span class="line">=&gt; fact_iter(1, 120)</span><br><span class="line">=&gt; 120</span><br></pre></td></tr></table></figure>
<p>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</p>
<p>遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的<code>fact(n)</code>函数改成尾递归方式，也会导致栈溢出。</p>
<h3 id="练习-4">练习</h3>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B1%89%E8%AF%BA%E5%A1%94">汉诺塔</a>的移动可以用递归函数非常简单地实现。</p>
<p>请编写<code>move(n, a, b, c)</code>函数，它接收参数<code>n</code>，表示3个柱子A、B、C中第1个柱子A的盘子数量，然后打印出把所有盘子从A借助B移动到C的方法，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">n, a, b, c</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(a, <span class="string">&#x27;--&gt;&#x27;</span>, c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 期待输出:</span></span><br><span class="line"><span class="comment"># A --&gt; C</span></span><br><span class="line"><span class="comment"># A --&gt; B</span></span><br><span class="line"><span class="comment"># C --&gt; B</span></span><br><span class="line"><span class="comment"># A --&gt; C</span></span><br><span class="line"><span class="comment"># B --&gt; A</span></span><br><span class="line"><span class="comment"># B --&gt; C</span></span><br><span class="line"><span class="comment"># A --&gt; C</span></span><br><span class="line">move(<span class="number">3</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="参考源码-4">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/function/recursive-function/recur.py">recur.py</a></p>
<h3 id="小结-4">小结</h3>
<p>使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。</p>
<p>针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。</p>
<p>Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="2025/06/14/python/2.python%E5%87%BD%E6%95%B0/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="2025/06/14/python/1.python%E5%9F%BA%E7%A1%80/"
                            aria-label=": 1.python基础"
                        >
                            1.python基础
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-06-14T17:03:09+08:00">
	
		    2025 年 6 月 14 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/">python</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="Python基础">Python基础</h2>
<p>Python是一种计算机编程语言。计算机编程语言和我们日常使用的自然语言有所不同，最大的区别就是，自然语言在不同的语境下有不同的理解，而计算机要根据编程语言执行任务，就必须保证编程语言写出的程序决不能有歧义，所以，任何一种编程语言都有自己的一套语法，编译器或者解释器就是负责把符合语法的程序代码转换成CPU能够执行的机器码，然后执行。Python也不例外。</p>
<p>Python的语法比较简单，采用缩进方式，写出来的代码就像下面的样子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># print absolute value of an integer:</span></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line"><span class="keyword">if</span> a &gt;= <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(-a)</span><br></pre></td></tr></table></figure>
<p>以<code>#</code>开头的语句是注释，注释是给人看的，可以是任意内容，解释器会忽略掉注释。其他每一行都是一个语句，当语句以冒号<code>:</code>结尾时，缩进的语句视为代码块。</p>
<p>缩进有利有弊。好处是强迫你写出格式化的代码，但没有规定缩进是几个空格还是Tab。按照约定俗成的惯例，应该始终坚持使用<em>4个空格</em>的缩进。</p>
<p>缩进的另一个好处是强迫你写出缩进较少的代码，你会倾向于把一段很长的代码拆分成若干函数，从而得到缩进较少的代码。</p>
<p>缩进的坏处就是“复制－粘贴”功能失效了，这是最坑爹的地方。当你重构代码时，粘贴过去的代码必须重新检查缩进是否正确。此外，IDE很难像格式化Java代码那样格式化Python代码。</p>
<p>最后，请务必注意，Python程序是<em>大小写敏感</em>的，如果写错了大小写，程序会报错。</p>
<h3 id="小结">小结</h3>
<p>Python使用缩进来组织代码块，请务必遵守约定俗成的习惯，坚持使用4个空格的缩进；</p>
<p>在文本编辑器中，需要设置把Tab自动转换为4个空格，确保不混用Tab和空格。</p>
<hr>
<h3 id="数据类型">数据类型</h3>
<p>计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：</p>
<h4 id="整数">整数</h4>
<p>Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：<code>1</code>，<code>100</code>，<code>-8080</code>，<code>0</code>，等等。</p>
<p>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用<code>0x</code>前缀和0-9，a-f表示，例如：<code>0xff00</code>，<code>0xa5b4c3d2</code>，等等。</p>
<p>对于很大的数，例如<code>10000000000</code>，很难数清楚0的个数。Python允许在数字中间以<code>_</code>分隔，因此，写成<code>10_000_000_000</code>和<code>10000000000</code>是完全一样的。十六进制数也可以写成<code>0xa1b2_c3d4</code>。</p>
<h4 id="浮点数">浮点数</h4>
<p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如<code>1.23</code>，<code>3.14</code>，<code>-9.01</code>，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是<code>1.23e9</code>，或者<code>12.3e8</code>，0.000012可以写成<code>1.2e-5</code>，等等。</p>
<p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</p>
<h4 id="字符串">字符串</h4>
<p>字符串是以单引号<code>'</code>或双引号<code>&quot;</code>括起来的任意文本，比如<code>'abc'</code>，<code>&quot;xyz&quot;</code>等等。请注意，<code>''</code>或<code>&quot;&quot;</code>本身只是一种表示方式，不是字符串的一部分，因此，字符串<code>'abc'</code>只有<code>a</code>，<code>b</code>，<code>c</code>这3个字符。如果<code>'</code>本身也是一个字符，那就可以用<code>&quot;&quot;</code>括起来，比如<code>&quot;I'm OK&quot;</code>包含的字符是<code>I</code>，<code>'</code>，<code>m</code>，空格，<code>O</code>，<code>K</code>这6个字符。</p>
<p>如果字符串内部既包含<code>'</code>又包含<code>&quot;</code>怎么办？可以用转义字符<code>\</code>来标识，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;I\&#x27;m \&quot;OK\&quot;!&#x27;</span></span><br></pre></td></tr></table></figure>
<p>表示的字符串内容是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I&#x27;m &quot;OK&quot;!</span><br></pre></td></tr></table></figure>
<p>转义字符<code>\</code>可以转义很多字符，比如<code>\n</code>表示换行，<code>\t</code>表示制表符，字符<code>\</code>本身也要转义，所以<code>\\</code>表示的字符就是<code>\</code>，可以在Python的交互式命令行用<code>print()</code>打印字符串看看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#x27;I\&#x27;m ok.&#x27;)</span><br><span class="line">I&#x27;m ok.</span><br><span class="line">&gt;&gt;&gt; print(&#x27;I\&#x27;m learning\nPython.&#x27;)</span><br><span class="line">I&#x27;m learning</span><br><span class="line">Python.</span><br><span class="line">&gt;&gt;&gt; print(&#x27;\\\n\\&#x27;)</span><br><span class="line">\</span><br><span class="line">\</span><br></pre></td></tr></table></figure>
<p>如果字符串里面有很多字符都需要转义，就需要加很多<code>\</code>，为了简化，Python还允许用<code>r''</code>表示<code>''</code>内部的字符串默认不转义，可以自己试试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#x27;\\\t\\&#x27;)</span><br><span class="line">\       \</span><br><span class="line">&gt;&gt;&gt; print(r&#x27;\\\t\\&#x27;)</span><br><span class="line">\\\t\\</span><br></pre></td></tr></table></figure>
<p>如果字符串内部有很多换行，用<code>\n</code>写在一行里不好阅读，为了简化，Python允许用<code>'''...'''</code>的格式表示多行内容，可以自己试试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#x27;&#x27;&#x27;line1</span><br><span class="line">... line2</span><br><span class="line">... line3&#x27;&#x27;&#x27;)</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br></pre></td></tr></table></figure>
<p>上面是在交互式命令行内输入，注意在输入多行内容时，提示符由<code>&gt;&gt;&gt;</code>变为<code>...</code>，提示你可以接着上一行输入，注意<code>...</code>是提示符，不是代码的一部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────┐</span><br><span class="line">│Windows PowerShell                                 - □ x │</span><br><span class="line">├─────────────────────────────────────────────────────────┤</span><br><span class="line">│&gt;&gt;&gt; print(&#x27;&#x27;&#x27;line1                                       │</span><br><span class="line">│... line2                                                │</span><br><span class="line">│... line3&#x27;&#x27;&#x27;)                                            │</span><br><span class="line">│line1                                                    │</span><br><span class="line">│line2                                                    │</span><br><span class="line">│line3                                                    │</span><br><span class="line">│                                                         │</span><br><span class="line">│&gt;&gt;&gt;                                                      │</span><br><span class="line">│                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>当输入完结束符<code>```</code>和括号<code>)</code>后，执行该语句并打印结果。</p>
<p>如果写成程序并存为<code>.py</code>文件，就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;&#x27;line1</span></span><br><span class="line"><span class="string">line2</span></span><br><span class="line"><span class="string">line3&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>多行字符串<code>'''...'''</code>还可以在前面加上<code>r</code>使用，请自行测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;&#x27;&#x27;hello,\n</span></span><br><span class="line"><span class="string">world&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="布尔值">布尔值</h4>
<p>布尔值和布尔代数的表示完全一致，一个布尔值只有<code>True</code>、<code>False</code>两种值，要么是<code>True</code>，要么是<code>False</code>，在Python中，可以直接用<code>True</code>、<code>False</code>表示布尔值（请注意大小写），也可以通过布尔运算计算出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; True</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; False</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; 3 &gt; 2</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; 3 &gt; 5</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>布尔值可以用<code>and</code>、<code>or</code>和<code>not</code>运算。</p>
<p><code>and</code>运算是与运算，只有所有都为<code>True</code>，<code>and</code>运算结果才是<code>True</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; True and True</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; True and False</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; False and False</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; 5 &gt; 3 and 3 &gt; 1</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p><code>or</code>运算是或运算，只要其中有一个为<code>True</code>，<code>or</code>运算结果就是<code>True</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; True or True</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; True or False</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; False or False</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; 5 &gt; 3 or 1 &gt; 3</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p><code>not</code>运算是非运算，它是一个单目运算符，把<code>True</code>变成<code>False</code>，<code>False</code>变成<code>True</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; not True</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; not False</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; not 1 &gt; 2</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>布尔值经常用在条件判断中，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;adult&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;teenager&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="空值">空值</h4>
<p>空值是Python里一个特殊的值，用<code>None</code>表示。<code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</p>
<p>此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。</p>
<h3 id="变量">变量</h3>
<p>变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p>
<p>变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和<code>_</code>的组合，且不能用数字开头，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>变量<code>a</code>是一个整数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_007 = <span class="string">&#x27;T007&#x27;</span></span><br></pre></td></tr></table></figure>
<p>变量<code>t_007</code>是一个字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Answer = <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>变量<code>Answer</code>是一个布尔值<code>True</code>。</p>
<p>在Python中，等号<code>=</code>是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">123</span> <span class="comment"># a是整数</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a = <span class="string">&#x27;ABC&#x27;</span> <span class="comment"># a变为字符串</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p>这种变量本身类型不固定的语言称之为<em>动态语言</em>，与之对应的是<em>静态语言</em>。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">123</span>; // a是整数类型变量</span><br><span class="line">a = <span class="string">&quot;ABC&quot;</span>; // 错误：不能把字符串赋给整型变量</span><br></pre></td></tr></table></figure>
<p>和静态语言相比，动态语言更灵活，就是这个原因。</p>
<p>请不要把赋值语句的等号等同于数学的等号。比如下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">x = x + <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>如果从数学上理解<code>x = x + 2</code>那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式<code>x + 2</code>，得到结果<code>12</code>，再赋给变量<code>x</code>。由于<code>x</code>之前的值是<code>10</code>，重新赋值后，<code>x</code>的值变成<code>12</code>。</p>
<p>最后，理解变量在计算机内存中的表示也非常重要。当我们写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;ABC&#x27;</span></span><br></pre></td></tr></table></figure>
<p>时，Python解释器干了两件事情：</p>
<ol>
<li>在内存中创建了一个<code>'ABC'</code>的字符串；</li>
<li>在内存中创建了一个名为<code>a</code>的变量，并把它指向<code>'ABC'</code>。</li>
</ol>
<p>也可以把一个变量<code>a</code>赋值给另一个变量<code>b</code>，这个操作实际上是把变量<code>b</code>指向变量<code>a</code>所指向的数据，例如下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;ABC&#x27;</span></span><br><span class="line">b = a</span><br><span class="line">a = <span class="string">&#x27;XYZ&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<p>最后一行打印出变量<code>b</code>的内容到底是<code>'ABC'</code>呢还是<code>'XYZ'</code>？如果从数学意义上理解，就会错误地得出<code>b</code>和<code>a</code>相同，也应该是<code>'XYZ'</code>，但实际上<code>b</code>的值是<code>'ABC'</code>，让我们一行一行地执行代码，就可以看到到底发生了什么事：</p>
<p>执行<code>a = 'ABC'</code>，解释器创建了字符串<code>'ABC'</code>和变量<code>a</code>，并把<code>a</code>指向<code>'ABC'</code>：</p>
<p><img src="https://liaoxuefeng.com/books/python/basic/data-types/step-1.png" alt="py-var-code-1"></p>
<p>执行<code>b = a</code>，解释器创建了变量<code>b</code>，并把<code>b</code>指向<code>a</code>指向的字符串<code>'ABC'</code>：</p>
<p><img src="https://liaoxuefeng.com/books/python/basic/data-types/step-2.png" alt="py-var-code-2"></p>
<p>执行<code>a = 'XYZ'</code>，解释器创建了字符串’XYZ’，并把<code>a</code>的指向改为<code>'XYZ'</code>，但<code>b</code>并没有更改：</p>
<p><img src="https://liaoxuefeng.com/books/python/basic/data-types/step-3.png" alt="py-var-code-3"></p>
<p>所以，最后打印变量<code>b</code>的结果自然是<code>'ABC'</code>了。</p>
<h3 id="常量">常量</h3>
<p>所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PI = <span class="number">3.14159265359</span></span><br></pre></td></tr></table></figure>
<p>但事实上<code>PI</code>仍然是一个变量，Python根本没有任何机制保证<code>PI</code>不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量<code>PI</code>的值，也没人能拦住你。</p>
<p>最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是<code>/</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 / 3</span><br><span class="line">3.3333333333333335</span><br></pre></td></tr></table></figure>
<p><code>/</code>除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 9 / 3</span><br><span class="line">3.0</span><br></pre></td></tr></table></figure>
<p>还有一种除法是<code>//</code>，称为地板除，两个整数的除法仍然是整数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 // 3</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>你没有看错，整数的地板除<code>//</code>永远是整数，即使除不尽。要做精确的除法，使用<code>/</code>就可以。</p>
<p>因为<code>//</code>除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 % 3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>无论整数做<code>//</code>除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。</p>
<h3 id="练习">练习</h3>
<p>请打印出以下变量的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">123</span></span><br><span class="line">f = <span class="number">456.789</span></span><br><span class="line">s1 = <span class="string">&#x27;Hello, world&#x27;</span></span><br><span class="line">s2 = <span class="string">&#x27;Hello, \&#x27;Adam\&#x27;&#x27;</span></span><br><span class="line">s3 = <span class="string">r&#x27;Hello, &quot;Bart&quot;&#x27;</span></span><br><span class="line">s4 = <span class="string">r&#x27;&#x27;&#x27;Hello,</span></span><br><span class="line"><span class="string">Bob!&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(???)</span><br></pre></td></tr></table></figure>
<h3 id="小结-2">小结</h3>
<p>Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。</p>
<p>对变量赋值<code>x = y</code>是把变量<code>x</code>指向真正的对象，该对象是变量<code>y</code>所指向的。随后对变量<code>y</code>的赋值<em>不影响</em>变量<code>x</code>的指向。</p>
<p>注意：Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在<code>-2147483648</code>-<code>2147483647</code>。</p>
<p>Python的浮点数也没有大小限制，但是超出一定范围就直接表示为<code>inf</code>（无限大）。</p>
<h3 id="字符编码">字符编码</h3>
<p>我们已经讲过了，字符串也是一种数据类型，但是，字符串比较特殊的是还有一个编码问题。</p>
<p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是<code>65535</code>，4个字节可以表示的最大整数是<code>4294967295</code>。</p>
<p>由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为<code>ASCII</code>编码，比如大写字母<code>A</code>的编码是<code>65</code>，小写字母<code>z</code>的编码是<code>122</code>。</p>
<p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了<code>GB2312</code>编码，用来把中文编进去。</p>
<p>你可以想得到的是，全世界有上百种语言，日本把日文编到<code>Shift_JIS</code>里，韩国把韩文编到<code>Euc-kr</code>里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</p>
<p>因此，Unicode字符集应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p>
<p>Unicode标准也在不断发展，但最常用的是UCS-16编码，用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p>
<p>现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</p>
<p>字母<code>A</code>用ASCII编码是十进制的<code>65</code>，二进制的<code>01000001</code>；</p>
<p>字符<code>0</code>用ASCII编码是十进制的<code>48</code>，二进制的<code>00110000</code>，注意字符<code>'0'</code>和整数<code>0</code>是不同的；</p>
<p>汉字<code>中</code>已经超出了ASCII编码的范围，用Unicode编码是十进制的<code>20013</code>，二进制的<code>01001110 00101101</code>。</p>
<p>你可以猜测，如果把ASCII编码的<code>A</code>用Unicode编码，只需要在前面补0就可以，因此，<code>A</code>的Unicode编码是<code>00000000 01000001</code>。</p>
<p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p>
<p>所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的<code>UTF-8</code>编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>ASCII</th>
<th>Unicode</th>
<th>UTF-8</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>01000001</td>
<td>00000000 01000001</td>
<td>01000001</td>
</tr>
<tr>
<td>中</td>
<td></td>
<td>01001110 00101101</td>
<td>11100100 10111000 10101101</td>
</tr>
</tbody>
</table>
<p>从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。</p>
<p>搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：</p>
<p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p>
<p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：</p>
<p><img src="https://liaoxuefeng.com/books/python/basic/string-encoding/file.png" alt="rw-file-utf-8"></p>
<p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：</p>
<p><img src="https://liaoxuefeng.com/books/python/basic/string-encoding/webpage.png" alt="web-utf-8"></p>
<p>所以你看到很多网页的源码上会有类似<code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的信息，表示该网页正是用的UTF-8编码。</p>
<h3 id="Python的字符串">Python的字符串</h3>
<p>搞清楚了令人头疼的字符编码问题后，我们再来研究Python的字符串。</p>
<p>在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#x27;包含中文的str&#x27;)</span><br><span class="line">包含中文的str</span><br></pre></td></tr></table></figure>
<p>对于单个字符的编码，Python提供了<code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(&#x27;A&#x27;)</span><br><span class="line">65</span><br><span class="line">&gt;&gt;&gt; ord(&#x27;中&#x27;)</span><br><span class="line">20013</span><br><span class="line">&gt;&gt;&gt; chr(66)</span><br><span class="line">&#x27;B&#x27;</span><br><span class="line">&gt;&gt;&gt; chr(25991)</span><br><span class="line">&#x27;文&#x27;</span><br></pre></td></tr></table></figure>
<p>如果知道字符的整数编码，还可以用十六进制这么写<code>str</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;\u4e2d\u6587&#x27;</span><br><span class="line">&#x27;中文&#x27;</span><br></pre></td></tr></table></figure>
<p>两种写法完全是等价的。</p>
<p>由于Python的字符串类型是<code>str</code>，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把<code>str</code>变为以字节为单位的<code>bytes</code>。</p>
<p>Python对<code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">b&#x27;ABC&#x27;</span></span><br></pre></td></tr></table></figure>
<p>要注意区分<code>'ABC'</code>和<code>b'ABC'</code>，前者是<code>str</code>，后者虽然内容显示得和前者一样，但<code>bytes</code>的每个字符都只占用一个字节。</p>
<p>以Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code>，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;ABC&#x27;.encode(&#x27;ascii&#x27;)</span><br><span class="line">b&#x27;ABC&#x27;</span><br><span class="line">&gt;&gt;&gt; &#x27;中文&#x27;.encode(&#x27;utf-8&#x27;)</span><br><span class="line">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span><br><span class="line">&gt;&gt;&gt; &#x27;中文&#x27;.encode(&#x27;ascii&#x27;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode characters in position 0-1: ordinal not in range(128)</span><br></pre></td></tr></table></figure>
<p>纯英文的<code>str</code>可以用<code>ASCII</code>编码为<code>bytes</code>，内容是一样的，含有中文的<code>str</code>可以用<code>UTF-8</code>编码为<code>bytes</code>。含有中文的<code>str</code>无法用<code>ASCII</code>编码，因为中文编码的范围超过了<code>ASCII</code>编码的范围，Python会报错。</p>
<p>在<code>bytes</code>中，无法显示为ASCII字符的字节，用<code>\x##</code>显示。</p>
<p>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是<code>bytes</code>。要把<code>bytes</code>变为<code>str</code>，就需要用<code>decode()</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&#x27;ABC&#x27;.decode(&#x27;ascii&#x27;)</span><br><span class="line">&#x27;ABC&#x27;</span><br><span class="line">&gt;&gt;&gt; b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;.decode(&#x27;utf-8&#x27;)</span><br><span class="line">&#x27;中文&#x27;</span><br></pre></td></tr></table></figure>
<p>如果<code>bytes</code>中包含无法解码的字节，<code>decode()</code>方法会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&#x27;\xe4\xb8\xad\xff&#x27;.decode(&#x27;utf-8&#x27;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">UnicodeDecodeError: &#x27;utf-8&#x27; codec can&#x27;t decode byte 0xff in position 3: invalid start byte</span><br></pre></td></tr></table></figure>
<p>如果<code>bytes</code>中只有一小部分无效的字节，可以传入<code>errors='ignore'</code>忽略错误的字节：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&#x27;\xe4\xb8\xad\xff&#x27;.decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;)</span><br><span class="line">&#x27;中&#x27;</span><br></pre></td></tr></table></figure>
<p>要计算<code>str</code>包含多少个字符，可以用<code>len()</code>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(&#x27;ABC&#x27;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; len(&#x27;中文&#x27;)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p><code>len()</code>函数计算的是<code>str</code>的字符数，如果换成<code>bytes</code>，<code>len()</code>函数就计算字节数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(b&#x27;ABC&#x27;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; len(b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;)</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; len(&#x27;中文&#x27;.encode(&#x27;utf-8&#x27;))</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p>可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。</p>
<p>在操作字符串时，我们经常遇到<code>str</code>和<code>bytes</code>的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对<code>str</code>和<code>bytes</code>进行转换。</p>
<p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure>
<p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</p>
<p>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p>
<p>申明了UTF-8编码并不意味着你的<code>.py</code>文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8编码。</p>
<p>如果<code>.py</code>文件本身使用UTF-8编码，并且也申明了<code># -*- coding: utf-8 -*-</code>，打开命令提示符测试就可以正常显示中文：</p>
<p><img src="https://liaoxuefeng.com/books/python/basic/string-encoding/cn-utf8.png" alt="py-chinese-test-in-cmd"></p>
<h3 id="格式化">格式化</h3>
<p>最后一个常见的问题是如何输出格式化的字符串。我们经常会输出类似<code>'亲爱的xxx你好！你xx月的话费是xx，余额是xx'</code>之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。</p>
<p>在Python中，采用的格式化方式和C语言是一致的，用<code>%</code>实现，举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;Hello, %s&#x27; % &#x27;world&#x27;</span><br><span class="line">&#x27;Hello, world&#x27;</span><br><span class="line">&gt;&gt;&gt; &#x27;Hi, %s, you have $%d.&#x27; % (&#x27;Michael&#x27;, 1000000)</span><br><span class="line">&#x27;Hi, Michael, you have $1000000.&#x27;</span><br></pre></td></tr></table></figure>
<p>你可能猜到了，<code>%</code>运算符就是用来格式化字符串的。在字符串内部，<code>%s</code>表示用字符串替换，<code>%d</code>表示用整数替换，有几个<code>%?</code>占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个<code>%?</code>，括号可以省略。</p>
<p>常见的占位符有：</p>
<table>
<thead>
<tr>
<th>占位符</th>
<th>替换内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>%d</td>
<td>整数</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数</td>
</tr>
<tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%x</td>
<td>十六进制整数</td>
</tr>
</tbody>
</table>
<p>其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%2d-%02d&#x27;</span> % (<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%.2f&#x27;</span> % <span class="number">3.1415926</span>)</span><br></pre></td></tr></table></figure>
<p>如果你不太确定应该用什么，<code>%s</code>永远起作用，它会把任何数据类型转换为字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;Age: %s. Gender: %s&#x27; % (25, True)</span><br><span class="line">&#x27;Age: 25. Gender: True&#x27;</span><br></pre></td></tr></table></figure>
<p>有些时候，字符串里面的<code>%</code>是一个普通字符怎么办？这个时候就需要转义，用<code>%%</code>来表示一个<code>%</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;growth rate: %d %%&#x27; % 7</span><br><span class="line">&#x27;growth rate: 7 %&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="format">format()</h3>
<p>另一种格式化字符串的方法是使用字符串的<code>format()</code>方法，它会用传入的参数依次替换字符串内的占位符<code>&#123;0&#125;</code>、<code>&#123;1&#125;</code>……，不过这种方式写起来比%要麻烦得多：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&#x27;.format(&#x27;小明&#x27;, 17.125)</span><br><span class="line">&#x27;Hello, 小明, 成绩提升了 17.1%&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="f-string">f-string</h3>
<p>最后一种格式化字符串的方法是使用以<code>f</code>开头的字符串，称之为<code>f-string</code>，它和普通字符串不同之处在于，字符串如果包含<code>&#123;xxx&#125;</code>，就会以对应的变量替换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = 2.5</span><br><span class="line">&gt;&gt;&gt; s = 3.14 * r ** 2</span><br><span class="line">&gt;&gt;&gt; print(f&#x27;The area of a circle with radius &#123;r&#125; is &#123;s:.2f&#125;&#x27;)</span><br><span class="line">The area of a circle with radius 2.5 is 19.62</span><br></pre></td></tr></table></figure>
<p>上述代码中，<code>&#123;r&#125;</code>被变量<code>r</code>的值替换，<code>&#123;s:.2f&#125;</code>被变量<code>s</code>的值替换，并且<code>:</code>后面的<code>.2f</code>指定了格式化参数（即保留两位小数），因此，<code>&#123;s:.2f&#125;</code>的替换结果是<code>19.62</code>。</p>
<h3 id="练习-2">练习</h3>
<p>小明的成绩从去年的72分提升到了今年的85分，请计算小明成绩提升的百分点，并用字符串格式化显示出<code>'xx.x%'</code>，只保留小数点后1位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="number">72</span></span><br><span class="line">s2 = <span class="number">85</span></span><br><span class="line">r = ???</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;???&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="参考源码">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/basic/string-encoding/the_string.py">the_string.py</a></p>
<h3 id="小结-3">小结</h3>
<p>Python 3的字符串使用Unicode，直接支持多语言。</p>
<p>当<code>str</code>和<code>bytes</code>互相转换时，需要指定编码。最常用的编码是<code>UTF-8</code>。Python当然也支持其他编码方式，比如把Unicode编码成<code>GB2312</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;中文&#x27;.encode(&#x27;gb2312&#x27;)</span><br><span class="line">b&#x27;\xd6\xd0\xce\xc4&#x27;</span><br></pre></td></tr></table></figure>
<p>但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用<code>UTF-8</code>编码。</p>
<p>格式化字符串的时候，可以用Python的交互式环境测试，方便快捷。</p>
<h3 id="list">list</h3>
<p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。</p>
<p>比如，列出班里所有同学的名字，就可以用一个list表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br></pre></td></tr></table></figure>
<p>变量<code>classmates</code>就是一个list。用<code>len()</code>函数可以获得list元素的个数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(classmates)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>用索引来访问list中每一个位置的元素，记得索引是从<code>0</code>开始的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates[0]</span><br><span class="line">&#x27;Michael&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates[1]</span><br><span class="line">&#x27;Bob&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates[2]</span><br><span class="line">&#x27;Tracy&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates[3]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure>
<p>当索引超出了范围时，Python会报一个<code>IndexError</code>错误，所以，要确保索引不要越界，记得最后一个元素的索引是<code>len(classmates) - 1</code>。</p>
<p>如果要取最后一个元素，除了计算索引位置外，还可以用<code>-1</code>做索引，直接获取最后一个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates[-1]</span><br><span class="line">&#x27;Tracy&#x27;</span><br></pre></td></tr></table></figure>
<p>以此类推，可以获取倒数第2个、倒数第3个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates[-2]</span><br><span class="line">&#x27;Bob&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates[-3]</span><br><span class="line">&#x27;Michael&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates[-4]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure>
<p>当然，倒数第4个就越界了。</p>
<p>list是一个可变的有序表，所以，可以往list中追加元素到末尾：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates.append(&#x27;Adam&#x27;)</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;]</span><br></pre></td></tr></table></figure>
<p>也可以把元素插入到指定的位置，比如索引号为<code>1</code>的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates.insert(1, &#x27;Jack&#x27;)</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;]</span><br></pre></td></tr></table></figure>
<p>要删除list末尾的元素，用<code>pop()</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates.pop()</span><br><span class="line">&#x27;Adam&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br></pre></td></tr></table></figure>
<p>要删除指定位置的元素，用<code>pop(i)</code>方法，其中<code>i</code>是索引位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates.pop(1)</span><br><span class="line">&#x27;Jack&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br></pre></td></tr></table></figure>
<p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates[1] = &#x27;Sarah&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Sarah&#x27;, &#x27;Tracy&#x27;]</span><br></pre></td></tr></table></figure>
<p>list里面的元素的数据类型也可以不同，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&#x27;Apple&#x27;, 123, True]</span><br></pre></td></tr></table></figure>
<p>list元素也可以是另一个list，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [&#x27;python&#x27;, &#x27;java&#x27;, [&#x27;asp&#x27;, &#x27;php&#x27;], &#x27;scheme&#x27;]</span><br><span class="line">&gt;&gt;&gt; len(s)</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>要注意<code>s</code>只有4个元素，其中<code>s[2]</code>又是一个list，如果拆开写就更容易理解了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p = [&#x27;asp&#x27;, &#x27;php&#x27;]</span><br><span class="line">&gt;&gt;&gt; s = [&#x27;python&#x27;, &#x27;java&#x27;, p, &#x27;scheme&#x27;]</span><br></pre></td></tr></table></figure>
<p>要拿到<code>'php'</code>可以写<code>p[1]</code>或者<code>s[2][1]</code>，因此<code>s</code>可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。</p>
<p>如果一个list中一个元素也没有，就是一个空的list，它的长度为0：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = []</span><br><span class="line">&gt;&gt;&gt; len(L)</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="tuple">tuple</h3>
<p>另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates = (&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;)</span><br></pre></td></tr></table></figure>
<p>现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用<code>classmates[0]</code>，<code>classmates[-1]</code>，但不能赋值成另外的元素。</p>
<p>不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。</p>
<p>tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1, 2)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1, 2)</span><br></pre></td></tr></table></figure>
<p>如果要定义一个空的tuple，可以写成<code>()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = ()</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">()</span><br></pre></td></tr></table></figure>
<p>但是，要定义一个只有1个元素的tuple，如果你这么定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>定义的不是tuple，是<code>1</code>这个数！这是因为括号<code>()</code>既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是<code>1</code>。</p>
<p>所以，只有1个元素的tuple定义时必须加一个逗号<code>,</code>，来消除歧义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1,)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1,)</span><br></pre></td></tr></table></figure>
<p>Python在显示只有1个元素的tuple时，也会加一个逗号<code>,</code>，以免你误解成数学计算意义上的括号。</p>
<p>最后来看一个“可变的”tuple：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;A&#x27;, &#x27;B&#x27;])</span><br><span class="line">&gt;&gt;&gt; t[2][0] = &#x27;X&#x27;</span><br><span class="line">&gt;&gt;&gt; t[2][1] = &#x27;Y&#x27;</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;X&#x27;, &#x27;Y&#x27;])</span><br></pre></td></tr></table></figure>
<p>这个tuple定义的时候有3个元素，分别是<code>'a'</code>，<code>'b'</code>和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？</p>
<p>别急，我们先看看定义的时候tuple包含的3个元素：</p>
<p><img src="https://liaoxuefeng.com/books/python/basic/list-tuple/step-1.png" alt="tuple-1"></p>
<p>当我们把list的元素<code>'A'</code>和<code>'B'</code>修改为<code>'X'</code>和<code>'Y'</code>后，tuple变为：</p>
<p><img src="https://liaoxuefeng.com/books/python/basic/list-tuple/step-2.png" alt="tuple-2"></p>
<p>表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向<code>'a'</code>，就不能改成指向<code>'b'</code>，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</p>
<p>理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。</p>
<h3 id="练习-3">练习</h3>
<p>请用索引取出下面list的指定元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">L = [</span><br><span class="line">    [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Microsoft&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Ruby&#x27;</span>, <span class="string">&#x27;PHP&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;Adam&#x27;</span>, <span class="string">&#x27;Bart&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印Apple:</span></span><br><span class="line"><span class="built_in">print</span>(?)</span><br><span class="line"><span class="comment"># 打印Python:</span></span><br><span class="line"><span class="built_in">print</span>(?)</span><br><span class="line"><span class="comment"># 打印Bob:</span></span><br><span class="line"><span class="built_in">print</span>(?)</span><br></pre></td></tr></table></figure>
<h3 id="参考源码-2">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/basic/list-tuple/the_list.py">the_list.py</a></p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/basic/list-tuple/the_tuple.py">the_tuple.py</a></p>
<h3 id="小结-4">小结</h3>
<p>list和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。</p>
<p>计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。</p>
<p>比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，用<code>if</code>语句实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;your age is&#x27;</span>, age)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;adult&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>根据Python的缩进规则，如果<code>if</code>语句判断是<code>True</code>，就把缩进的两行print语句执行了，否则，什么也不做。</p>
<p>也可以给<code>if</code>添加一个<code>else</code>语句，意思是，如果<code>if</code>判断是<code>False</code>，不要执行<code>if</code>的内容，去把<code>else</code>执行了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;your age is&#x27;</span>, age)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;adult&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;your age is&#x27;</span>, age)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;teenager&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>注意不要少写了冒号<code>:</code>。</p>
<p>当然上面的判断是很粗略的，完全可以用<code>elif</code>做更细致的判断：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;adult&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">6</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;teenager&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;kid&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><code>elif</code>是<code>else if</code>的缩写，完全可以有多个<code>elif</code>，所以<code>if</code>语句的完整形式就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;条件判断<span class="number">1</span>&gt;:</span><br><span class="line">    &lt;执行<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;条件判断<span class="number">2</span>&gt;:</span><br><span class="line">    &lt;执行<span class="number">2</span>&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;条件判断<span class="number">3</span>&gt;:</span><br><span class="line">    &lt;执行<span class="number">3</span>&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;执行<span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure>
<p><code>if</code>语句执行有个特点，它是从上往下判断，如果在某个判断上是<code>True</code>，把该判断对应的语句执行后，就忽略掉剩下的<code>elif</code>和<code>else</code>，所以，请测试并解释为什么下面的程序打印的是<code>teenager</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">6</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;teenager&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;adult&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;kid&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><code>if</code>判断条件还可以简写，比如写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;True&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>只要<code>x</code>是非零数值、非空字符串、非空list等，就判断为<code>True</code>，否则为<code>False</code>。</p>
<h3 id="再议input">再议input</h3>
<p>最后看一个有问题的条件判断。很多同学会用<code>input()</code>读取用户的输入，这样可以自己输入，程序运行得更有意思：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">birth = <span class="built_in">input</span>(<span class="string">&#x27;birth: &#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> birth &lt; <span class="number">2000</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;00前&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;00后&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输入<code>1982</code>，结果报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: unorderable types: str() &gt; int()</span><br></pre></td></tr></table></figure>
<p>这是因为<code>input()</code>返回的数据类型是<code>str</code>，<code>str</code>不能直接和整数比较，必须先把<code>str</code>转换成整数。Python提供了<code>int()</code>函数来完成这件事情：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">input</span>(<span class="string">&#x27;birth: &#x27;</span>)</span><br><span class="line">birth = <span class="built_in">int</span>(s)</span><br><span class="line"><span class="keyword">if</span> birth &lt; <span class="number">2000</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;00前&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;00后&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>再次运行，就可以得到正确地结果。但是，如果输入<code>abc</code>呢？又会得到一个错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">ValueError: invalid literal for int() with base 10: &#x27;abc&#x27;</span><br></pre></td></tr></table></figure>
<p>原来<code>int()</code>函数发现一个字符串并不是合法的数字时就会报错，程序就退出了。</p>
<p>如何检查并捕获程序运行期的错误呢？后面的错误和调试会讲到。</p>
<h3 id="练习-4">练习</h3>
<p>小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数：</p>
<ul>
<li>低于18.5：过轻</li>
<li>18.5-25：正常</li>
<li>25-28：过重</li>
<li>28-32：肥胖</li>
<li>高于32：严重肥胖</li>
</ul>
<p>用<code>if-elif</code>判断并打印结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">height = <span class="number">1.75</span></span><br><span class="line">weight = <span class="number">80.5</span></span><br><span class="line"></span><br><span class="line">bmi = ???</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ???:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="参考源码-3">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/basic/if/do_if.py">do_if.py</a></p>
<h3 id="小结-5">小结</h3>
<p>条件判断可以让计算机自己做选择，Python的if…elif…else很灵活。</p>
<p>条件判断从上向下匹配，当满足条件时执行对应的块内语句，后续的elif和else都不再执行。</p>
<p><img src="https://liaoxuefeng.com/books/python/basic/if/if-elif-else.png" alt="python-if"></p>
<h2 id="模式匹配">模式匹配</h2>
<p>当我们用<code>if ... elif ... elif ... else ...</code>判断时，会写很长一串代码，可读性较差。</p>
<p>如果要针对某个变量匹配若干种情况，可以使用<code>match</code>语句。</p>
<p>例如，某个学生的成绩只能是<code>A</code>、<code>B</code>、<code>C</code>，用<code>if</code>语句编写如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">if</span> score == <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;score is A.&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> score == <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;score is B.&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> score == <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;score is C.&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;invalid score.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如果用<code>match</code>语句改写，则改写如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> score:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;score is A.&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;score is B.&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;score is C.&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> _: <span class="comment"># _表示匹配到其他任何情况</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;score is ???.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>使用<code>match</code>语句时，我们依次用<code>case xxx</code>匹配，并且可以在最后（且仅能在最后）加一个<code>case _</code>表示“任意值”，代码较<code>if ... elif ... else ...</code>更易读。</p>
<h3 id="复杂匹配">复杂匹配</h3>
<p><code>match</code>语句除了可以匹配简单的单个值外，还可以匹配多个值、匹配一定范围，并且把匹配后的值绑定到变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> age:</span><br><span class="line">    <span class="keyword">case</span> x <span class="keyword">if</span> x &lt; <span class="number">10</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;&lt; 10 years old: <span class="subst">&#123;x&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;10 years old.&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span> | <span class="number">12</span> | <span class="number">13</span> | <span class="number">14</span> | <span class="number">15</span> | <span class="number">16</span> | <span class="number">17</span> | <span class="number">18</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;11~18 years old.&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">19</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;19 years old.&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;not sure.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在上面这个示例中，第一个<code>case x if x &lt; 10</code>表示当<code>age &lt; 10</code>成立时匹配，且赋值给变量<code>x</code>，第二个<code>case 10</code>仅匹配单个值，第三个<code>case 11|12|...|18</code>能匹配多个值，用<code>|</code>分隔。</p>
<p>可见，<code>match</code>语句的<code>case</code>匹配非常灵活。</p>
<h3 id="匹配列表">匹配列表</h3>
<p><code>match</code>语句还可以匹配列表，功能非常强大。</p>
<p>我们假设用户输入了一个命令，用<code>args = ['gcc', 'hello.c']</code>存储，下面的代码演示了如何用<code>match</code>匹配来解析这个列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">args = [<span class="string">&#x27;gcc&#x27;</span>, <span class="string">&#x27;hello.c&#x27;</span>, <span class="string">&#x27;world.c&#x27;</span>]</span><br><span class="line"><span class="comment"># args = [&#x27;clean&#x27;]</span></span><br><span class="line"><span class="comment"># args = [&#x27;gcc&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> args:</span><br><span class="line">    <span class="comment"># 如果仅出现gcc，报错:</span></span><br><span class="line">    <span class="keyword">case</span> [<span class="string">&#x27;gcc&#x27;</span>]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;gcc: missing source file(s).&#x27;</span>)</span><br><span class="line">    <span class="comment"># 出现gcc，且至少指定了一个文件:</span></span><br><span class="line">    <span class="keyword">case</span> [<span class="string">&#x27;gcc&#x27;</span>, file1, *files]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;gcc compile: &#x27;</span> + file1 + <span class="string">&#x27;, &#x27;</span> + <span class="string">&#x27;, &#x27;</span>.join(files))</span><br><span class="line">    <span class="comment"># 仅出现clean:</span></span><br><span class="line">    <span class="keyword">case</span> [<span class="string">&#x27;clean&#x27;</span>]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;clean&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;invalid command.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>第一个<code>case ['gcc']</code>表示列表仅有<code>'gcc'</code>一个字符串，没有指定文件名，报错；</p>
<p>第二个<code>case ['gcc', file1, *files]</code>表示列表第一个字符串是<code>'gcc'</code>，第二个字符串绑定到变量<code>file1</code>，后面的任意个字符串绑定到<code>*files</code>（符号<code>*</code>的作用将在<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/function/parameter/index.html">函数的参数</a>中讲解），它实际上表示至少指定一个文件；</p>
<p>第三个<code>case ['clean']</code>表示列表仅有<code>'clean'</code>一个字符串；</p>
<p>最后一个<code>case _</code>表示其他所有情况。</p>
<p>可见，<code>match</code>语句的匹配规则非常灵活，可以写出非常简洁的代码。</p>
<h3 id="参考源码-4">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/basic/match/do_match.py">do_match.py</a></p>
<hr>
<p>要计算1+2+3，我们可以直接写表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1 + 2 + 3</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p>要计算1+2+3+…+10，勉强也能写出来。</p>
<p>但是，要计算1+2+3+…+10000，直接写表达式就不可能了。</p>
<p>为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。</p>
<p>Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来，看例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure>
<p>执行这段代码，会依次打印<code>names</code>的每一个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Michael</span><br><span class="line">Bob</span><br><span class="line">Tracy</span><br></pre></td></tr></table></figure>
<p>所以<code>for x in ...</code>循环就是把每个元素代入变量<code>x</code>，然后执行缩进块的语句。</p>
<p>再比如我们想计算1-10的整数之和，可以用一个<code>sum</code>变量做累加：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]:</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span> + x</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>
<p>如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个<code>range()</code>函数，可以生成一个整数序列，再通过<code>list()</code>函数可以转换为list。比如<code>range(5)</code>生成的序列是从0开始小于5的整数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(5))</span><br><span class="line">[0, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
<p><code>range(101)</code>就可以生成0-100的整数序列，计算如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span> + x</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>
<p>请自行运行上述代码，看看结果是不是当年高斯同学心算出的5050。</p>
<p>第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">n = <span class="number">99</span></span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span> + n</span><br><span class="line">    n = n - <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>
<p>在循环内部变量<code>n</code>不断自减，直到变为<code>-1</code>时，不再满足while条件，循环退出。</p>
<h3 id="练习-5">练习</h3>
<p>请利用循环依次对list中的每个名字打印出<code>Hello, xxx!</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="string">&#x27;Bart&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;Adam&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="break">break</h3>
<p>在循环中，<code>break</code>语句可以提前退出循环。例如，本来要循环打印1～100的数字：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码可以打印出1~100。</p>
<p>如果要提前结束循环，可以用<code>break</code>语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">10</span>: <span class="comment"># 当n = 11时，条件满足，执行break语句</span></span><br><span class="line">        <span class="keyword">break</span> <span class="comment"># break语句会结束当前循环</span></span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>执行上面的代码可以看到，打印出1~10后，紧接着打印<code>END</code>，程序结束。</p>
<p>可见<code>break</code>的作用是提前结束循环。</p>
<h3 id="continue">continue</h3>
<p>在循环过程中，也可以通过<code>continue</code>语句，跳过当前的这次循环，直接开始下一次循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">10</span>:</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>
<p>上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用<code>continue</code>语句跳过某些循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">10</span>:</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>: <span class="comment"># 如果n是偶数，执行continue语句</span></span><br><span class="line">        <span class="keyword">continue</span> <span class="comment"># continue语句会直接继续下一轮循环，后续的print()语句不会执行</span></span><br><span class="line">    <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>
<p>执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。</p>
<p>可见<code>continue</code>的作用是提前结束本轮循环，并直接开始下一轮循环。</p>
<h3 id="参考源码-5">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/basic/loop/do_for.py">do_for.py</a></p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/basic/loop/do_while.py">do_while.py</a></p>
<h3 id="小结-6">小结</h3>
<p>循环是让计算机做重复任务的有效的方法。</p>
<p><code>break</code>语句可以在循环过程中直接退出循环，而<code>continue</code>语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都<em>必须</em>配合<code>if</code>语句使用。</p>
<p><em>要特别注意</em>，不要滥用<code>break</code>和<code>continue</code>语句。<code>break</code>和<code>continue</code>会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到<code>break</code>和<code>continue</code>语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉<code>break</code>和<code>continue</code>语句。</p>
<p>有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用<code>Ctrl+C</code>退出程序，或者强制结束Python进程。</p>
<p>请试写一个死循环程序。</p>
<h3 id="dict">dict</h3>
<p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p>
<p>举个例子，假设要根据同学的名字查找对应的成绩，如果用list实现，需要两个list：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br><span class="line">scores = [<span class="number">95</span>, <span class="number">75</span>, <span class="number">85</span>]</span><br></pre></td></tr></table></figure>
<p>给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，list越长，耗时越长。</p>
<p>如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&#x27;Michael&#x27;: 95, &#x27;Bob&#x27;: 75, &#x27;Tracy&#x27;: 85&#125;</span><br><span class="line">&gt;&gt;&gt; d[&#x27;Michael&#x27;]</span><br><span class="line">95</span><br></pre></td></tr></table></figure>
<p>为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。</p>
<p>第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。</p>
<p>dict就是第二种实现方式，给定一个名字，比如<code>'Michael'</code>，dict在内部就可以直接计算出<code>Michael</code>对应的存放成绩的“页码”，也就是<code>95</code>这个数字存放的内存地址，直接取出来，所以速度非常快。</p>
<p>你可以猜到，这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。</p>
<p>把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#x27;Adam&#x27;] = 67</span><br><span class="line">&gt;&gt;&gt; d[&#x27;Adam&#x27;]</span><br><span class="line">67</span><br></pre></td></tr></table></figure>
<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#x27;Jack&#x27;] = 90</span><br><span class="line">&gt;&gt;&gt; d[&#x27;Jack&#x27;]</span><br><span class="line">90</span><br><span class="line">&gt;&gt;&gt; d[&#x27;Jack&#x27;] = 88</span><br><span class="line">&gt;&gt;&gt; d[&#x27;Jack&#x27;]</span><br><span class="line">88</span><br></pre></td></tr></table></figure>
<p>如果key不存在，dict就会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#x27;Thomas&#x27;]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">KeyError: &#x27;Thomas&#x27;</span><br></pre></td></tr></table></figure>
<p>要避免key不存在的错误，有两种办法，一是通过<code>in</code>判断key是否存在：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;Thomas&#x27; in d</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>二是通过dict提供的<code>get()</code>方法，如果key不存在，可以返回<code>None</code>，或者自己指定的value：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.get(&#x27;Thomas&#x27;)</span><br><span class="line">&gt;&gt;&gt; d.get(&#x27;Thomas&#x27;, -1)</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<p>注意：返回<code>None</code>的时候Python的交互环境不显示结果。</p>
<p>要删除一个key，用<code>pop(key)</code>方法，对应的value也会从dict中删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.pop(&#x27;Bob&#x27;)</span><br><span class="line">75</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;Michael&#x27;: 95, &#x27;Tracy&#x27;: 85&#125;</span><br></pre></td></tr></table></figure>
<p>请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。</p>
<p>和list比较，dict有以下几个特点：</p>
<ol>
<li>查找和插入的速度极快，不会随着key的增加而变慢；</li>
<li>需要占用大量的内存，内存浪费多。</li>
</ol>
<p>而list相反：</p>
<ol>
<li>查找和插入的时间随着元素的增加而增加；</li>
<li>占用空间小，浪费内存很少。</li>
</ol>
<p>所以，dict是用空间来换取时间的一种方法。</p>
<p>dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是<strong>不可变对象</strong>。</p>
<p>这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。</p>
<p>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; key = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; d[key] = &#x27;a list&#x27;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: unhashable type: &#x27;list&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="set">set</h3>
<p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>
<p>要创建一个set，用<code>&#123;x,y,z,...&#125;</code>列出每个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &#123;1, 2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure>
<p>或者提供一个list作为输入集合：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure>
<p>注意，传入的参数<code>[1, 2, 3]</code>是一个list，而显示的<code>&#123;1, 2, 3&#125;</code>只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。</p>
<p>重复元素在set中自动被过滤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &#123;1, 1, 2, 2, 3, 3&#125;</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>add(key)</code>方法可以添加元素到set中，可以重复添加，但不会有效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.add(4)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br><span class="line">&gt;&gt;&gt; s.add(4)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>remove(key)</code>方法可以删除元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.remove(4)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure>
<p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1 = &#123;1, 2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; s2 = &#123;2, 3, 4&#125;</span><br><span class="line">&gt;&gt;&gt; s1 &amp; s2</span><br><span class="line">&#123;2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; s1 | s2</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure>
<p>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。</p>
<h3 id="再议不可变对象">再议不可变对象</h3>
<p>上面我们讲了，str是不变对象，而list是可变对象。</p>
<p>对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]</span><br><span class="line">&gt;&gt;&gt; a.sort()</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></pre></td></tr></table></figure>
<p>而对于不可变对象，比如str，对str进行操作呢：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &#x27;abc&#x27;</span><br><span class="line">&gt;&gt;&gt; a.replace(&#x27;a&#x27;, &#x27;A&#x27;)</span><br><span class="line">&#x27;Abc&#x27;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#x27;abc&#x27;</span><br></pre></td></tr></table></figure>
<p>虽然字符串有个<code>replace()</code>方法，也确实变出了<code>'Abc'</code>，但变量<code>a</code>最后仍是<code>'abc'</code>，应该怎么理解呢？</p>
<p>我们先把代码改成下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &#x27;abc&#x27;</span><br><span class="line">&gt;&gt;&gt; b = a.replace(&#x27;a&#x27;, &#x27;A&#x27;)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&#x27;Abc&#x27;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#x27;abc&#x27;</span><br></pre></td></tr></table></figure>
<p>要始终牢记的是，<code>a</code>是变量，而<code>'abc'</code>才是字符串对象！有些时候，我们经常说，对象<code>a</code>的内容是<code>'abc'</code>，但其实是指，<code>a</code>本身是一个变量，它指向的对象的内容才是<code>'abc'</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌───┐     ┌───────┐</span><br><span class="line">│ a │────▶│ &#x27;abc&#x27; │</span><br><span class="line">└───┘     └───────┘</span><br></pre></td></tr></table></figure>
<p>当我们调用<code>a.replace('a', 'A')</code>时，实际上调用方法<code>replace</code>是作用在字符串对象<code>'abc'</code>上的，而这个方法虽然名字叫<code>replace</code>，但却没有改变字符串<code>'abc'</code>的内容。相反，<code>replace</code>方法创建了一个新字符串<code>'Abc'</code>并返回，如果我们用变量<code>b</code>指向该新字符串，就容易理解了，变量<code>a</code>仍指向原有的字符串<code>'abc'</code>，但变量<code>b</code>却指向新字符串<code>'Abc'</code>了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌───┐     ┌───────┐</span><br><span class="line">│ a │────▶│ &#x27;abc&#x27; │</span><br><span class="line">└───┘     └───────┘</span><br><span class="line">┌───┐     ┌───────┐</span><br><span class="line">│ b │────▶│ &#x27;Abc&#x27; │</span><br><span class="line">└───┘     └───────┘</span><br></pre></td></tr></table></figure>
<p>所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p>
<h3 id="参考源码-6">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/basic/dict-set/the_dict.py">the_dict.py</a></p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/basic/dict-set/the_set.py">the_set.py</a></p>
<h3 id="小结-7">小结</h3>
<p>使用key-value存储结构的dict在Python中非常有用，选择不可变对象作为key很重要，最常用的key是字符串。</p>
<p>tuple虽然是不变对象，但试试把<code>(1, 2, 3)</code>和<code>(1, [2, 3])</code>放入dict或set中，并解释结果。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="2025/06/14/python/1.python%E5%9F%BA%E7%A1%80/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="2025/06/01/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E4%B9%8B-A-%E7%AE%97%E6%B3%95/"
                            aria-label=": 路径规划之 A* 算法"
                        >
                            路径规划之 A* 算法
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-06-01T15:46:52+08:00">
	
		    2025 年 6 月 1 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="categories/%E7%AE%97%E6%B3%95/">算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>A*（念做：A Star）算法是一种很常用的路径查找和图形遍历算法。它有较好的性能和准确度。本文在讲解算法的同时也会提供Python语言的代码实现，并会借助matplotlib库动态的展示算法的运算过程。</p>
<ul>
<li><a href="#id-%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D">算法介绍</a></li>
<li><a href="#id-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">广度优先搜索</a></li>
<li><a href="#id-dijkstra%E7%AE%97%E6%B3%95">Dijkstra算法</a></li>
<li><a href="#id-%E6%9C%80%E4%BD%B3%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">最佳优先搜索</a></li>
<li><a href="#id-a%E7%AE%97%E6%B3%95">A*算法</a>
<ul>
<li><a href="#id-%E5%90%AF%E5%8F%91%E5%87%BD%E6%95%B0">启发函数</a></li>
<li><a href="#id-%E5%85%B3%E4%BA%8E%E8%B7%9D%E7%A6%BB">关于距离</a>
<ul>
<li><a href="#id-%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB">曼哈顿距离</a></li>
<li><a href="#id-%E5%AF%B9%E8%A7%92%E8%B7%9D%E7%A6%BB">对角距离</a></li>
<li><a href="#id-%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E8%B7%9D%E7%A6%BB">欧几里得距离</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#id-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0">算法实现</a>
<ul>
<li><a href="#id-%E5%9D%90%E6%A0%87%E7%82%B9%E4%B8%8E%E5%9C%B0%E5%9B%BE">坐标点与地图</a></li>
<li><a href="#id-%E7%AE%97%E6%B3%95%E4%B8%BB%E4%BD%93">算法主体</a></li>
<li><a href="#id-%E6%B5%8B%E8%AF%95%E5%85%A5%E5%8F%A3">测试入口</a></li>
</ul>
</li>
<li><a href="#id-%E7%AE%97%E6%B3%95%E5%8F%98%E7%A7%8D">算法变种</a>
<ul>
<li><a href="#id-ara">ARA*</a></li>
<li><a href="#id-d">D*</a></li>
<li><a href="#id-field-d">Field D*</a></li>
<li><a href="#id-block-a">Block A*</a></li>
</ul>
</li>
<li><a href="#id-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E4%B8%8E%E6%8E%A8%E8%8D%90%E8%AF%BB%E7%89%A9">参考资料与推荐读物</a></li>
</ul>
<h2 id="算法介绍">算法介绍</h2>
<p>A*算法最初发表于1968年，由Stanford研究院的Peter Hart, Nils Nilsson以及Bertram Raphael发表。它可以被认为是Dijkstra算法的扩展。</p>
<p>由于借助启发函数的引导，A*算法通常拥有更好的性能。</p>
<h2 id="广度优先搜索">广度优先搜索</h2>
<p>为了更好的理解A*算法，我们首先从广度优先（Breadth First）算法讲起。</p>
<p>正如其名称所示，广度优先搜索以广度做为优先级进行搜索。</p>
<p>从起点开始，首先遍历起点周围邻近的点，然后再遍历已经遍历过的点邻近的点，逐步的向外扩散，直到找到终点。</p>
<p>这种算法就像洪水（Flood fill）一样向外扩张，算法的过程如下图所示：</p>
<p><img src="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/breadth_first.gif" alt=""></p>
<p>在上面这幅动态图中，算法遍历了图中所有的点，这通常没有必要。对于有明确终点的问题来说，一旦到达终点便可以提前终止算法，下面这幅图对比了这种情况：</p>
<p><img src="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/early_exit.png" alt=""></p>
<p>在执行算法的过程中，每个点需要记录达到该点的前一个点的位置 – 可以称之为父节点。这样做之后，一旦到达终点，便可以从终点开始，反过来顺着父节点的顺序找到起点，由此就构成了一条路径。</p>
<h2 id="Dijkstra算法">Dijkstra算法</h2>
<p>Dijkstra算法是由计算机科学家<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra">Edsger W. Dijkstra</a>在1956年提出的。</p>
<p>Dijkstra算法用来寻找图形中节点之间的最短路径。</p>
<p>考虑这样一种场景，在一些情况下，图形中相邻节点之间的移动代价并不相等。例如，游戏中的一幅图，既有平地也有山脉，那么游戏中的角色在平地和山脉中移动的速度通常是不相等的。</p>
<p>在Dijkstra算法中，需要计算每一个节点距离起点的总移动代价。同时，还需要一个优先队列结构。对于所有待遍历的节点，放入优先队列中会按照代价进行排序。</p>
<p>在算法运行的过程中，每次都从优先队列中选出代价最小的作为下一个遍历的节点。直到到达终点为止。</p>
<p>下面对比了不考虑节点移动代价差异的广度优先搜索与考虑移动代价的Dijkstra算法的运算结果：</p>
<p><img src="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/dijkstra.gif" alt=""></p>
<blockquote>
<p>当图形为网格图，并且每个节点之间的移动代价是相等的，那么Dijkstra算法将和广度优先算法变得一样。</p>
</blockquote>
<h2 id="最佳优先搜索">最佳优先搜索</h2>
<p>在一些情况下，如果我们可以预先计算出每个节点到终点的距离，则我们可以利用这个信息更快的到达终点。</p>
<p>其原理也很简单。与Dijkstra算法类似，我们也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级，每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点。这种算法称之为最佳优先（Best First）算法。</p>
<p>这样做可以大大加快路径的搜索速度，如下图所示：</p>
<p><img src="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/best_first.gif" alt=""></p>
<p>但这种算法会不会有什么缺点呢？答案是肯定的。</p>
<p>因为，如果起点和终点之间存在障碍物，则最佳优先算法找到的很可能不是最短路径，下图描述了这种情况。</p>
<p><img src="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/best_first_2.gif" alt=""></p>
<h2 id="A-算法">A*算法</h2>
<p>对比了上面几种算法，最后终于可以讲解本文的重点：A*算法了。</p>
<p>下面的描述我们将看到，A*算法实际上是综合上面这些算法的特点于一身的。</p>
<p>A*算法通过下面这个函数来计算每个节点的优先级。</p>
<p>\[f(n) = g(n) + h(n)\]</p>
<p>其中：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 是节点n的综合优先级。当我们选择下一个要遍历的节点时，我们总会选取综合优先级最高（值最小）的节点。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 是节点n距离起点的代价。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 是节点n距离终点的预计代价，这也就是A*算法的启发函数。关于启发函数我们在下面详细讲解。</li>
</ul>
<p>A*算法在运算过程中，每次从优先队列中选取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>值最小（优先级最高）的节点作为下一个待遍历的节点。</p>
<p>另外，A*算法使用两个集合来表示待遍历的节点，与已经遍历过的节点，这通常称之为<code>open_set</code>和<code>close_set</code>。</p>
<p>完整的A*算法描述如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* 初始化open_set和close_set；</span><br><span class="line">* 将起点加入open_set中，并设置优先级为0（优先级最高）；</span><br><span class="line">* 如果open_set不为空，则从open_set中选取优先级最高的节点n：</span><br><span class="line">    * 如果节点n为终点，则：</span><br><span class="line">        * 从终点开始逐步追踪parent节点，一直达到起点；</span><br><span class="line">        * 返回找到的结果路径，算法结束；</span><br><span class="line">    * 如果节点n不是终点，则：</span><br><span class="line">        * 将节点n从open_set中删除，并加入close_set中；</span><br><span class="line">        * 遍历节点n所有的邻近节点：</span><br><span class="line">            * 如果邻近节点m在close_set中，则：</span><br><span class="line">                * 跳过，选取下一个邻近节点</span><br><span class="line">            * 如果邻近节点m也不在open_set中，则：</span><br><span class="line">                * 设置节点m的parent为节点n</span><br><span class="line">                * 计算节点m的优先级</span><br><span class="line">                * 将节点m加入open_set中</span><br></pre></td></tr></table></figure>
<h2 id="启发函数">启发函数</h2>
<p>上面已经提到，启发函数会影响A*算法的行为。</p>
<ul>
<li>在极端情况下，当启发函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>始终为0，则将由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>决定节点的优先级，此时算法就退化成了Dijkstra算法。</li>
<li>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>始终小于等于节点n到终点的代价，则A*算法保证一定能够找到最短路径。但是当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>的值越小，算法将遍历越多的节点，也就导致算法越慢。</li>
<li>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>完全等于节点n到终点的代价，则A*算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远。</li>
<li>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>的值比节点n到终点的代价要大，则A*算法不能保证找到最短路径，不过此时会很快。</li>
<li>在另外一个极端情况下，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>相较于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>大很多，则此时只有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>产生效果，这也就变成了最佳优先搜索。</li>
</ul>
<p>由上面这些信息我们可以知道，通过调节启发函数我们可以控制算法的速度和精确度。因为在一些情况，我们可能未必需要最短路径，而是希望能够尽快找到一个路径即可。这也是A*算法比较灵活的地方。</p>
<p>对于网格形式的图，有以下这些启发函数可以使用：</p>
<ul>
<li>如果图形中只允许朝上下左右四个方向移动，则可以使用曼哈顿距离（Manhattan distance）。</li>
<li>如果图形中允许朝八个方向移动，则可以使用对角距离。</li>
<li>如果图形中允许朝任何方向移动，则可以使用欧几里得距离（Euclidean distance）。</li>
</ul>
<h2 id="关于距离">关于距离</h2>
<h3 id="曼哈顿距离">曼哈顿距离</h3>
<p>如果图形中只允许朝上下左右四个方向移动，则启发函数可以使用曼哈顿距离，它的计算方法如下图所示：</p>
<p><img src="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/Manhattan_dis.png" alt=""></p>
<p>计算曼哈顿距离的函数如下，这里的D是指两个相邻节点之间的移动代价，通常是一个固定的常数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function heuristic(node) =</span><br><span class="line">    dx = abs(node.x - goal.x)</span><br><span class="line">    dy = abs(node.y - goal.y)</span><br><span class="line">    return D * (dx + dy)</span><br></pre></td></tr></table></figure>
<h3 id="对角距离">对角距离</h3>
<p>如果图形中允许斜着朝邻近的节点移动，则启发函数可以使用对角距离。它的计算方法如下：</p>
<p><img src="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/Diagonal_dis.png" alt=""></p>
<p>计算对角距离的函数如下，这里的D2指的是两个斜着相邻节点之间的移动代价。如果所有节点都正方形，则其值就是\\sqrt{2} \* D。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function heuristic(node) =</span><br><span class="line">    dx = abs(node.x - goal.x)</span><br><span class="line">    dy = abs(node.y - goal.y)</span><br><span class="line">    return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)</span><br></pre></td></tr></table></figure>
<h3 id="欧几里得距离">欧几里得距离</h3>
<p>如果图形中允许朝任意方向移动，则可以使用欧几里得距离。</p>
<p>欧几里得距离是指两个节点之间的直线距离，因此其计算方法也是我们比较熟悉的：\\sqrt{(p2.x-p1.x)^2 + (p2.y-p1.y)^2}。其函数表示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function heuristic(node) =</span><br><span class="line">    dx = abs(node.x - goal.x)</span><br><span class="line">    dy = abs(node.y - goal.y)</span><br><span class="line">    return D * sqrt(dx * dx + dy * dy)</span><br></pre></td></tr></table></figure>
<h2 id="算法实现">算法实现</h2>
<p>虽然前面介绍了很多内容，但实际上A*算法并不复杂，实现起来也比较简单。</p>
<p>下面我们给出一个Python语言的代码示例。</p>
<p>之所以使用Python语言是因为我们可以借助matplotlib库很方便的将结果展示出来。在理解了算法之后，通过其他语言实现也并非难事。</p>
<blockquote>
<p>算法的源码可以到我的github上下载：<a target="_blank" rel="noopener" href="https://github.com/paulQuei/a-star-algorithm">paulQuei/a-star-algorithm</a>。</p>
</blockquote>
<p>我们的算法演示的是在一个二维的网格图形上从起点找寻终点的求解过程。</p>
<h2 id="坐标点与地图">坐标点与地图</h2>
<p>首先，我们创建一个非常简单的类来描述图中的点，相关代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># point.py</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">class Point:</span><br><span class="line">    def __init__(self, x, y):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        self.cost = sys.maxsize</span><br></pre></td></tr></table></figure>
<p>接着，我们实现一个描述地图结构的类。为了简化算法的描述:</p>
<p><strong>我们选定左下角坐标[0, 0]的点是算法起点，右上角坐标[size - 1, size - 1]的点为要找的终点。</strong></p>
<p>为了让算法更有趣，我们在地图的中间设置了一个障碍，并且地图中还会包含一些随机的障碍。该类的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># random_map.py</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">import point</span><br><span class="line"></span><br><span class="line">class RandomMap:</span><br><span class="line">    def __init__(self, size=50): ①</span><br><span class="line">        self.size = size</span><br><span class="line">        self.obstacle = size//8 ②</span><br><span class="line">        self.GenerateObstacle() ③</span><br><span class="line"></span><br><span class="line">    def GenerateObstacle(self):</span><br><span class="line">        self.obstacle_point = []</span><br><span class="line">        self.obstacle_point.append(point.Point(self.size//2, self.size//2))</span><br><span class="line">        self.obstacle_point.append(point.Point(self.size//2, self.size//2-1))</span><br><span class="line"></span><br><span class="line">        # Generate an obstacle in the middle</span><br><span class="line">        for i in range(self.size//2-4, self.size//2): ④</span><br><span class="line">            self.obstacle_point.append(point.Point(i, self.size-i))</span><br><span class="line">            self.obstacle_point.append(point.Point(i, self.size-i-1))</span><br><span class="line">            self.obstacle_point.append(point.Point(self.size-i, i))</span><br><span class="line">            self.obstacle_point.append(point.Point(self.size-i, i-1))</span><br><span class="line"></span><br><span class="line">        for i in range(self.obstacle-1): ⑤</span><br><span class="line">            x = np.random.randint(0, self.size)</span><br><span class="line">            y = np.random.randint(0, self.size)</span><br><span class="line">            self.obstacle_point.append(point.Point(x, y))</span><br><span class="line"></span><br><span class="line">            if (np.random.rand() &gt; 0.5): # Random boolean ⑥</span><br><span class="line">                for l in range(self.size//4):</span><br><span class="line">                    self.obstacle_point.append(point.Point(x, y+l))</span><br><span class="line">                    pass</span><br><span class="line">            else:</span><br><span class="line">                for l in range(self.size//4):</span><br><span class="line">                    self.obstacle_point.append(point.Point(x+l, y))</span><br><span class="line">                    pass</span><br><span class="line"></span><br><span class="line">    def IsObstacle(self, i ,j): ⑦</span><br><span class="line">        for p in self.obstacle_point:</span><br><span class="line">            if i==p.x and j==p.y:</span><br><span class="line">                return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>
<p>这段代码说明如下：</p>
<ol>
<li>构造函数，地图的默认大小是50x50；</li>
<li>设置障碍物的数量为地图大小除以8；</li>
<li>调用<code>GenerateObstacle</code>生成随机障碍物；</li>
<li>在地图的中间生成一个斜着的障碍物；</li>
<li>随机生成其他几个障碍物；</li>
<li>障碍物的方向也是随机的；</li>
<li>定义一个方法来判断某个节点是否是障碍物；</li>
</ol>
<h2 id="算法主体">算法主体</h2>
<p>有了基本的数据结构之后，我们就可以开始实现算法主体了。</p>
<p>这里我们通过一个类来封装我们的算法。</p>
<p>首先实现一些算法需要的基本函数，它们如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># a_star.py</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">from matplotlib.patches import Rectangle</span><br><span class="line"></span><br><span class="line">import point</span><br><span class="line">import random_map</span><br><span class="line"></span><br><span class="line">class AStar:</span><br><span class="line">    def __init__(self, map):</span><br><span class="line">        self.map=map</span><br><span class="line">        self.open_set = []</span><br><span class="line">        self.close_set = []</span><br><span class="line"></span><br><span class="line">    def BaseCost(self, p):</span><br><span class="line">        x_dis = p.x</span><br><span class="line">        y_dis = p.y</span><br><span class="line">        # Distance to start point</span><br><span class="line">        return x_dis + y_dis + (np.sqrt(2) - 2) * min(x_dis, y_dis)</span><br><span class="line"></span><br><span class="line">    def HeuristicCost(self, p):</span><br><span class="line">        x_dis = self.map.size - 1 - p.x</span><br><span class="line">        y_dis = self.map.size - 1 - p.y</span><br><span class="line">        # Distance to end point</span><br><span class="line">        return x_dis + y_dis + (np.sqrt(2) - 2) * min(x_dis, y_dis)</span><br><span class="line"></span><br><span class="line">    def TotalCost(self, p):</span><br><span class="line">        return self.BaseCost(p) + self.HeuristicCost(p)</span><br><span class="line"></span><br><span class="line">    def IsValidPoint(self, x, y):</span><br><span class="line">        if x &lt; 0 or y &lt; 0:</span><br><span class="line">            return False</span><br><span class="line">        if x &gt;= self.map.size or y &gt;= self.map.size:</span><br><span class="line">            return False</span><br><span class="line">        return not self.map.IsObstacle(x, y)</span><br><span class="line"></span><br><span class="line">    def IsInPointList(self, p, point_list):</span><br><span class="line">        for point in point_list:</span><br><span class="line">            if point.x == p.x and point.y == p.y:</span><br><span class="line">                return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    def IsInOpenList(self, p):</span><br><span class="line">        return self.IsInPointList(p, self.open_set)</span><br><span class="line"></span><br><span class="line">    def IsInCloseList(self, p):</span><br><span class="line">        return self.IsInPointList(p, self.close_set)</span><br><span class="line"></span><br><span class="line">    def IsStartPoint(self, p):</span><br><span class="line">        return p.x == 0 and p.y ==0</span><br><span class="line"></span><br><span class="line">    def IsEndPoint(self, p):</span><br><span class="line">        return p.x == self.map.size-1 and p.y == self.map.size-1</span><br></pre></td></tr></table></figure>
<p>这里的函数说明如下：</p>
<ul>
<li><code>__init__</code>：类的构造函数。</li>
<li><code>BaseCost</code>：节点到起点的移动代价，对应了上文的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>。</li>
<li><code>HeuristicCost</code>：节点到终点的启发函数，对应上文的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>。由于我们是基于网格的图形，所以这个函数和上一个函数用的是对角距离。</li>
<li><code>TotalCost</code>：代价总和，即对应上面提到的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>。</li>
<li><code>IsValidPoint</code>：判断点是否有效，不在地图内部或者障碍物所在点都是无效的。</li>
<li><code>IsInPointList</code>：判断点是否在某个集合中。</li>
<li><code>IsInOpenList</code>：判断点是否在open_set中。</li>
<li><code>IsInCloseList</code>：判断点是否在close_set中。</li>
<li><code>IsStartPoint</code>：判断点是否是起点。</li>
<li><code>IsEndPoint</code>：判断点是否是终点。</li>
</ul>
<p>有了上面这些辅助函数，就可以开始实现算法主逻辑了，相关代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># a_star.py</span><br><span class="line">def RunAndSaveImage(self, ax, plt):</span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    start_point = point.Point(0, 0)</span><br><span class="line">    start_point.cost = 0</span><br><span class="line">    self.open_set.append(start_point)</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        index = self.SelectPointInOpenList()</span><br><span class="line">        if index &lt; 0:</span><br><span class="line">            print(&#x27;No path found, algorithm failed!!!&#x27;)</span><br><span class="line">            return</span><br><span class="line">        p = self.open_set[index]</span><br><span class="line">        rec = Rectangle((p.x, p.y), 1, 1, color=&#x27;c&#x27;)</span><br><span class="line">        ax.add_patch(rec)</span><br><span class="line">        self.SaveImage(plt)</span><br><span class="line"></span><br><span class="line">        if self.IsEndPoint(p):</span><br><span class="line">            return self.BuildPath(p, ax, plt, start_time)</span><br><span class="line"></span><br><span class="line">        del self.open_set[index]</span><br><span class="line">        self.close_set.append(p)</span><br><span class="line"></span><br><span class="line">        # Process all neighbors</span><br><span class="line">        x = p.x</span><br><span class="line">        y = p.y</span><br><span class="line">        self.ProcessPoint(x-1, y+1, p)</span><br><span class="line">        self.ProcessPoint(x-1, y, p)</span><br><span class="line">        self.ProcessPoint(x-1, y-1, p)</span><br><span class="line">        self.ProcessPoint(x, y-1, p)</span><br><span class="line">        self.ProcessPoint(x+1, y-1, p)</span><br><span class="line">        self.ProcessPoint(x+1, y, p)</span><br><span class="line">        self.ProcessPoint(x+1, y+1, p)</span><br><span class="line">        self.ProcessPoint(x, y+1, p)</span><br></pre></td></tr></table></figure>
<p>这段代码应该不需要太多解释了，它就是根据前面的算法逻辑进行实现。为了将结果展示出来，我们在算法进行的每一步，都会借助于matplotlib库将状态保存成图片。</p>
<p>上面这个函数调用了其他几个函数代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># a_star.py</span><br><span class="line">def SaveImage(self, plt):</span><br><span class="line">    millis = int(round(time.time() * 1000))</span><br><span class="line">    filename = &#x27;./&#x27; + str(millis) + &#x27;.png&#x27;</span><br><span class="line">    plt.savefig(filename)</span><br><span class="line"></span><br><span class="line">def ProcessPoint(self, x, y, parent):</span><br><span class="line">    if not self.IsValidPoint(x, y):</span><br><span class="line">        return # Do nothing for invalid point</span><br><span class="line">    p = point.Point(x, y)</span><br><span class="line">    if self.IsInCloseList(p):</span><br><span class="line">        return # Do nothing for visited point</span><br><span class="line">    print(&#x27;Process Point [&#x27;, p.x, &#x27;,&#x27;, p.y, &#x27;]&#x27;, &#x27;, cost: &#x27;, p.cost)</span><br><span class="line">    if not self.IsInOpenList(p):</span><br><span class="line">        p.parent = parent</span><br><span class="line">        p.cost = self.TotalCost(p)</span><br><span class="line">        self.open_set.append(p)</span><br><span class="line"></span><br><span class="line">def SelectPointInOpenList(self):</span><br><span class="line">    index = 0</span><br><span class="line">    selected_index = -1</span><br><span class="line">    min_cost = sys.maxsize</span><br><span class="line">    for p in self.open_set:</span><br><span class="line">        cost = self.TotalCost(p)</span><br><span class="line">        if cost &lt; min_cost:</span><br><span class="line">            min_cost = cost</span><br><span class="line">            selected_index = index</span><br><span class="line">        index += 1</span><br><span class="line">    return selected_index</span><br><span class="line"></span><br><span class="line">def BuildPath(self, p, ax, plt, start_time):</span><br><span class="line">    path = []</span><br><span class="line">    while True:</span><br><span class="line">        path.insert(0, p) # Insert first</span><br><span class="line">        if self.IsStartPoint(p):</span><br><span class="line">            break</span><br><span class="line">        else:</span><br><span class="line">            p = p.parent</span><br><span class="line">    for p in path:</span><br><span class="line">        rec = Rectangle((p.x, p.y), 1, 1, color=&#x27;g&#x27;)</span><br><span class="line">        ax.add_patch(rec)</span><br><span class="line">        plt.draw()</span><br><span class="line">        self.SaveImage(plt)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    print(&#x27;===== Algorithm finish in&#x27;, int(end_time-start_time), &#x27; seconds&#x27;)</span><br></pre></td></tr></table></figure>
<p>这三个函数应该是比较容易理解的：</p>
<ul>
<li><code>SaveImage</code>：将当前状态保存到图片中，图片以当前时间命名。</li>
<li><code>ProcessPoint</code>：针对每一个节点进行处理：如果是没有处理过的节点，则计算优先级设置父节点，并且添加到open_set中。</li>
<li><code>SelectPointInOpenList</code>：从open_set中找到优先级最高的节点，返回其索引。</li>
<li><code>BuildPath</code>：从终点往回沿着<code>parent</code>构造结果路径。然后从起点开始绘制结果，结果使用绿色方块，每次绘制一步便保存一个图片。</li>
</ul>
<h2 id="测试入口">测试入口</h2>
<p>最后是程序的入口逻辑，使用上面写的类来查找路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># main.py</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">from matplotlib.patches import Rectangle</span><br><span class="line"></span><br><span class="line">import random_map</span><br><span class="line">import a_star</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(5, 5))</span><br><span class="line"></span><br><span class="line">map = random_map.RandomMap() ①</span><br><span class="line"></span><br><span class="line">ax = plt.gca()</span><br><span class="line">ax.set_xlim([0, map.size]) ②</span><br><span class="line">ax.set_ylim([0, map.size])</span><br><span class="line"></span><br><span class="line">for i in range(map.size): ③</span><br><span class="line">    for j in range(map.size):</span><br><span class="line">        if map.IsObstacle(i,j):</span><br><span class="line">            rec = Rectangle((i, j), width=1, height=1, color=&#x27;gray&#x27;)</span><br><span class="line">            ax.add_patch(rec)</span><br><span class="line">        else:</span><br><span class="line">            rec = Rectangle((i, j), width=1, height=1, edgecolor=&#x27;gray&#x27;, facecolor=&#x27;w&#x27;)</span><br><span class="line">            ax.add_patch(rec)</span><br><span class="line"></span><br><span class="line">rec = Rectangle((0, 0), width = 1, height = 1, facecolor=&#x27;b&#x27;)</span><br><span class="line">ax.add_patch(rec) ④</span><br><span class="line"></span><br><span class="line">rec = Rectangle((map.size-1, map.size-1), width = 1, height = 1, facecolor=&#x27;r&#x27;)</span><br><span class="line">ax.add_patch(rec) ⑤</span><br><span class="line"></span><br><span class="line">plt.axis(&#x27;equal&#x27;) ⑥</span><br><span class="line">plt.axis(&#x27;off&#x27;)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">#plt.show()</span><br><span class="line"></span><br><span class="line">a_star = a_star.AStar(map)</span><br><span class="line">a_star.RunAndSaveImage(ax, plt) ⑦</span><br></pre></td></tr></table></figure>
<p>这段代码说明如下：</p>
<ol>
<li>创建一个随机地图；</li>
<li>设置图像的内容与地图大小一致；</li>
<li>绘制地图：对于障碍物绘制一个灰色的方块，其他区域绘制一个白色的的方块；</li>
<li>绘制起点为蓝色方块；</li>
<li>绘制终点为红色方块；</li>
<li>设置图像的坐标轴比例相等并且隐藏坐标轴；</li>
<li>调用算法来查找路径；</li>
</ol>
<p>由于我们的地图是随机的，所以每次运行的结果可能会不一样，下面是我的电脑上某次运行的结果：</p>
<p><img src="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/a_star.gif" alt=""></p>
<blockquote>
<p>如果感兴趣这篇文章中的动图是如何制作的，请看我的另外一篇文章：<a target="_blank" rel="noopener" href="https://paul.pub/matplotlib-3d-plotting/#id-%E5%88%B6%E4%BD%9C%E5%8A%A8%E5%9B%BE">使用Matplotlib绘制3D图形 - 制作动图</a>。</p>
</blockquote>
<h2 id="算法变种">算法变种</h2>
<p>A*算法有不少的变种，这里我们介绍最主要的几个。</p>
<p>更多的内容请以访问维基百科：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/A*_search_algorithm#Variants">A* Variants</a>。</p>
<h2 id="ARA">ARA*</h2>
<p>ARA* 全称是Anytime Repairing A*，也称为Anytime A*。</p>
<p>与其他Anytime算法一样，它具有灵活的时间成本，即使在它结束之前被中断，也可以返回路径查找或图形遍历问题的有效解决方案。方法是在逐步优化之前生成快速，非最优的结果。</p>
<p>在现实世界的规划问题中，问题的解决时间往往是有限的。与时间相关的规划者对这种情况都会比较熟悉：他们能够快速找到可行的解决方案，然后不断努力改进，直到时间用完为止。</p>
<p>启发式搜索ARA*算法，它根据可用的搜索时间调整其性能边界。它首先使用松散边界快速找到次优解，然后在时间允许的情况下逐渐收紧边界。如果有足够的时间，它会找到可证明的最佳解决方方案。在改进其约束的同时，ARA*重复使用以前的搜索工作，因此，比其他随时搜索方法更有效。</p>
<p>与A*算法不同，Anytime A*算法最重要的功能是，它们可以被停止，然后可以随时重启。该方法使用控制管理器类来处理时间限制以及停止和重新启动A*算法以找到初始的，可能是次优的解决方案，然后继续搜索改进的解决方案，直到达到可证明的最佳解决方案。</p>
<p>关于ARA*的更多内容可以阅读这篇论文：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/ARA%2A-%20Anytime%20A%2A%20with%20Provable%20Bounds%20on%20Sub-Optimality.pdf">ARA* - Anytime A* with Provable Bounds on Sub-Optimality</a>。</li>
</ul>
<h2 id="D">D*</h2>
<p>D*是Dynamic A*的简写，其算法和A*类似，不同的是，其代价的计算在算法运行过程中可能会发生变化。</p>
<p>D*包含了下面三种增量搜索算法：</p>
<ul>
<li>原始的D*由Anthony Stentz发表。</li>
<li>Focussed D*由Anthony Stentz发表，是一个增量启发式搜索算法，结合了A*和原始D*的思想。</li>
<li>D* Lite是由Sven Koenig和Maxim Likhachev基于LPA*构建的算法。</li>
</ul>
<p>所有三种搜索算法都解决了相同的基于假设的路径规划问题，包括使用自由空间假设进行规划。在这些环境中，机器人必须导航到未知地形中的给定目标坐标。它假设地形的未知部分（例如：它不包含障碍物），并在这些假设下找到从当前坐标到目标坐标的最短路径。</p>
<p>然后机器人沿着路径行进。当它观察到新的地图信息（例如以前未知的障碍物）时，它会将信息添加到其地图中，并在必要时将新的最短路径从其当前坐标重新添加到给定的目标坐标。它会重复该过程，直到达到目标坐标或确定无法达到目标坐标。在穿越未知地形时，可能经常发现新的障碍，因此重新计划需要很快。增量（启发式）搜索算法通过使用先前问题的经验来加速搜索当前问题，从而加速搜索类似搜索问题的序列。假设目标坐标没有改变，则所有三种搜索算法都比重复的A*搜索更有效。</p>
<p>D*及其变体已广泛用于移动机器人和自动车辆导航。当前系统通常基于D* Lite而不是原始D*或Focussed D*。</p>
<p>关于D*的更多内容可以阅读这两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://idm-lab.org/project-a.html">Project “Fast Replanning （Incremental Heuristic Search）”</a></li>
<li><a target="_blank" rel="noopener" href="http://www.frc.ri.cmu.edu/~axs/dynamic_plan.html">Real-Time Replanning in Dynamic and Unknown Environments</a></li>
</ul>
<h2 id="Field-D">Field D*</h2>
<p>Field D*扩展了D*和D* Lite，是一种基于插值（ interpolation-based ）的规划算法，它使用线性插值来有效地生成低成本路径，从而消除不必要的转向。</p>
<p>在给定线性插值假设的情况下，路径是最优的，并且在实践中非常有效。该算法目前被各种现场机器人系统使用。</p>
<p>关于Field D*的详细内容可以看下面这篇论文：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/Field%20D%2A-%20An%20Interpolation-based%20Path%20Planner%20and%20Replanner.pdf">Field D*: An Interpolation-based Path Planner and Replanner</a></li>
</ul>
<h2 id="Block-A">Block A*</h2>
<p>Block A*扩展自A*，但它操作是一块（block）单元而不是单个单元。</p>
<p>其open_set中的每个条目都是已到达但尚未扩展的块，或者需要重新扩展的块。</p>
<p>open_set中块的优先级称为其堆值（heap value）。与A*类似，Block A*中的基本循环是删除具有最低堆值的条目并将其展开。在扩展期间使用LDDB来计算正在扩展的块中的边界单元的g值。</p>
<p>LDDB是一种新型数据库，它包含了本地邻域边界点之间的距离。</p>
<p>关于Block A*的更多内容可以看下面这篇论文：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/Block%20A%2A-%20Database-Driven%20Search%20with%20Applications%20in%20Any-angle%20Path-Planning.pdf">Block A*: Database-Driven Search with Applications in Any-angle Path-Planning</a></li>
</ul>
<h2 id="参考资料与推荐读物">参考资料与推荐读物</h2>
<ul>
<li><a target="_blank" rel="noopener" href="http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html">Stanford: Introduction to A*</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/A*_search_algorithm">Wikipedia: A* search algorithm</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/AtsushiSakai/PythonRobotics#a-algorithm">PythonRobotics: A* algorithm</a></li>
<li><a target="_blank" rel="noopener" href="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2019-02-05-a-star-algorithm/ARA%2A-%20Anytime%20A%2A%20with%20Provable%20Bounds%20on%20Sub-Optimality.pdf">ARA* - Anytime A* with Provable Bounds on Sub-Optimality</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="2025/06/01/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E4%B9%8B-A-%E7%AE%97%E6%B3%95/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="2025/05/28/%E5%88%9D%E5%BF%83%E8%80%85%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%83%80%E3%82%A4%E3%82%AF%E3%82%B9%E3%83%88%E3%83%A9%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/"
                            aria-label=": 初心者のためのダイクストラアルゴリズム"
                        >
                            初心者のためのダイクストラアルゴリズム
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-28T14:52:10+08:00">
	
		    2025 年 5 月 28 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="categories/%E7%AE%97%E6%B3%95/">算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>ダイクストラのアルゴリズムってあるじゃないですか？名前も覚えにくいしそもそも重み付きグラフの最短経路問題とか実務で実装することそうそうないのですぐ忘れちゃうんですよね。。。</p>
<h2 id="ダイクストラアルゴリズムとは"><a href="#%E3%83%80%E3%82%A4%E3%82%AF%E3%82%B9%E3%83%88%E3%83%A9%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%81%AF"></a>ダイクストラアルゴリズムとは</h2>
<p>ダイクストラアルゴリズムとはグラフの最短経路を求めるアルゴリズムです。名前だけは聞いたことのある方も多いかと思います。やってることはイージーでシンプルなんですが少しとっつきにくいですが一つ一つ理解していけば割とわかりやすいアルゴリズムです。<br>
重み付き出ない、迷路の探索などは幅優先探索で解けるのですが、各辺に重みがついてる場合は結局全通りを計算しないといけないことになります。全ての頂点を一回だけ通るとして、辺E個あるとすればO(E!)となり計算量は爆発してしまします。<br>
これだと計算するにも少し厳しいです。</p>
<p>そんな問題を効率的にといてくれるアルゴリズムそれがダイクストラアルゴリズムです。</p>
<p>ちなみに各辺のコストは非負の値(0以上)でなければなりません。負の数が含まれてる場合はベルマン-フォード法などを使用することになります。</p>
<h2 id="手順"><a href="#%E6%89%8B%E9%A0%86"></a>手順</h2>
<p>ダイクストラ法の手順はかなり単純です。</p>
<ol>
<li>始点に最短距離0を設定する</li>
<li>まだ辿ってない点の中から最短距離が分かっていて最も距離が短い頂点に移動する</li>
<li>その頂点から繋がっている頂点の最短距離を設定する。この時にその頂点の最短距離を更新できるなら更新する。</li>
<li>これを全ての頂点の最短距離をわかるまで行う</li>
</ol>
<p>さてと言われても少し難しいと思いますので、実例をみていきましょう。</p>
<h2 id="例"><a href="#%E4%BE%8B"></a>例</h2>
<p>なんともアナログな手法ですが一番表現できたので。。。<br>
以下のような図の最短経路を考えていきます。<br>
<a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F90f90a2f-8991-1bc5-adb4-fb4b053a901f.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=b9d055575e737f8a2c459474e25322c7"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F90f90a2f-8991-1bc5-adb4-fb4b053a901f.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=b9d055575e737f8a2c459474e25322c7" alt="image.png"></a></p>
<p>緑が最短経路が確定して移動ずみの頂点となります。赤が起点となる頂点です。各頂点の数字はその時の最短経路となります<br>
<a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2Fae1ddc01-e867-8894-7aee-3940269cfe2e.gif?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=0b8d3bd32321d163185bac4e6ecf4db7"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2Fae1ddc01-e867-8894-7aee-3940269cfe2e.gif?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=0b8d3bd32321d163185bac4e6ecf4db7" alt="dijkstra algo.gif"></a></p>
<p>さてみていただくと分かるようにスタート地点から順番にその時点での最短の頂点に移動してそこからまた隣り合う頂点の最短経路を計算しているのが分かるかと思います。</p>
<h2 id="実装"><a href="#%E5%AE%9F%E8%A3%85"></a>実装</h2>
<p>さて実装に入っていきましょう。<br>
上の手順を愚直に実装してみます。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function main(nodes) &#123;</span><br><span class="line">    const start = nodes[0]</span><br><span class="line">    // 訪問済みの頂点を記録</span><br><span class="line">    const visited = new Set()</span><br><span class="line">    const routesFromStart = new Map()</span><br><span class="line">     // 始点からの距離の記録</span><br><span class="line"></span><br><span class="line">    routesFromStart.set(start, &#123;distance: 0&#125;)</span><br><span class="line">    for(const n of nodes) &#123;</span><br><span class="line">        if(n != start) &#123;</span><br><span class="line">            // スタート以外の全ての頂点に無限大を代入</span><br><span class="line">            routesFromStart.set(n, &#123;distance: Number.MAX_VALUE&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let current = start</span><br><span class="line">    let routes = new Map()</span><br><span class="line">    while(current != null) &#123;</span><br><span class="line">        visited.add(current)</span><br><span class="line">        for(const edge of current.edges) &#123;</span><br><span class="line">             // その頂点から隣り合う頂点の最短距離を計算して、計算済みの値より低ければ更新</span><br><span class="line">            if(edge.cost + routesFromStart.get(current).distance &lt; routesFromStart.get(edge.to).distance) &#123;</span><br><span class="line">                routesFromStart.set(edge.to, &#123;distance: edge.cost + routesFromStart.get(current).distance&#125;)</span><br><span class="line">                routes.set(current, edge.to)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        let cheapestNodeDistance = Number.MAX_VALUE</span><br><span class="line">        current = null</span><br><span class="line">        // 訪問してない最短距離を計算済みの頂点の中から最小の頂点を選ぶ</span><br><span class="line"></span><br><span class="line">        for(const city of routesFromStart.keys()) &#123;</span><br><span class="line">            if(!visited.has(city) &amp;&amp; cheapestNodeDistance &gt; routesFromStart.get(city).distance)&#123;</span><br><span class="line">                cheapestNodeDistance = routesFromStart.get(city).distance</span><br><span class="line">                current = city</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return routesFromStart.get(nodes[nodes.length - 1]).distance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>このコードは各頂点をVとすると最大で各辺の個数を回るループの中で中で最小の頂点を選ぶためのループを回してるので計算量はO(V^2 + E)メモリについては各頂点分の記録を行わないといけないのでO(V)となります。</p>
<h2 id="Priority-Queueを用いた実装について"><a href="#priority-queue%E3%82%92%E7%94%A8%E3%81%84%E3%81%9F%E5%AE%9F%E8%A3%85%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6"></a>Priority Queueを用いた実装について</h2>
<p>さて感のいい人ならお気づきになったかもしれませんが、このコード実は最小の頂点を決めるロジックを最適化することができます。それが優先度付きキューです。<br>
優先度付きキューは挿入、取り出しにO(logN)の計算量が必要となりますが、最小の頂点を決める際の計算量が線形の探索より早くなります。</p>
<p>Priority QueueはJavaScriptには標準で実装はされてないので、Pythonでの実装です。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def dijkstra(nodes):</span><br><span class="line">    start_node = nodes[0]</span><br><span class="line">    routes_from_start = &#123;n: math.inf for n in nodes&#125;</span><br><span class="line"></span><br><span class="line">    # 最初の頂点にゼロを設定</span><br><span class="line">    routes_from_start[start_node] = 0</span><br><span class="line">    </span><br><span class="line">    minHeap = []</span><br><span class="line"></span><br><span class="line">    # 最初の頂点を追加</span><br><span class="line">    heappush(minHeap, (0, start_node))</span><br><span class="line"></span><br><span class="line">    # ヒープがなくなるまで探索</span><br><span class="line">    while minHeap:</span><br><span class="line">        (cost, current_node) = heappop(minHeap)</span><br><span class="line"></span><br><span class="line">        # priority keyは重複するのでここでチェックする</span><br><span class="line">        if cost &gt; routes_from_start[current_node]:</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        for node in current_node.routes:</span><br><span class="line">            price_info = current_node.routes[node]</span><br><span class="line">            if routes_from_start[node] &gt; price_info + routes_from_start[current_node]:</span><br><span class="line">                routes_from_start[node] = price_info + routes_from_start[current_node]</span><br><span class="line">                # 更新されたらpriorityに値を追加</span><br><span class="line">                heappush(minHeap, (price_info + routes_from_start[current_node], node))</span><br><span class="line"></span><br><span class="line">    return routes_from_start[nodes[-1]]</span><br></pre></td></tr></table></figure>
<p>Priority Queueの説明はまたの機会にしましょう。<br>
より計算効率がよく各頂点V, 各辺をVとするとVをmapに設定するO(V)とEの回数分heapを操作するのでO(ElogE)。の合計O(V + ElogE)で求まることがわかります。これは最初のアルゴリズムより効率的です。</p>
<h2 id="経路を記憶する"><a href="#%E7%B5%8C%E8%B7%AF%E3%82%92%E8%A8%98%E6%86%B6%E3%81%99%E3%82%8B"></a>経路を記憶する</h2>
<p>さて最短のコストはわかりました。しかしこの問題は&quot;最短経路&quot;問題です。最短のコストが求まったらその経路も知りたくなるのが普通です。<br>
上のコードを改善してみましょう。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">def dijkstra(nodes):</span><br><span class="line">    start_node = nodes[0]</span><br><span class="line">    routes_from_start = &#123;n: math.inf for n in nodes&#125;</span><br><span class="line"></span><br><span class="line">    # 最初の頂点にゼロを設定</span><br><span class="line">    routes_from_start[start_node] = 0</span><br><span class="line">    </span><br><span class="line">    minHeap = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # 最初の頂点を追加</span><br><span class="line">    heappush(minHeap, (0, start_node))</span><br><span class="line">    path = collections.defaultdict(Node)</span><br><span class="line"></span><br><span class="line">    # ヒープがなくなるまで探索</span><br><span class="line">    while minHeap:</span><br><span class="line">        (cost, current_node) = heappop(minHeap)</span><br><span class="line"></span><br><span class="line">        # priority keyは重複するのでここでチェックする</span><br><span class="line">        if cost &gt; routes_from_start[current_node]:</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        for node in current_node.routes:</span><br><span class="line">            price_info = current_node.routes[node]</span><br><span class="line">            if routes_from_start[node] &gt; price_info + routes_from_start[current_node]:</span><br><span class="line">                routes_from_start[node] = price_info + routes_from_start[current_node]</span><br><span class="line">                # 最短距離を更新するノードを記録する</span><br><span class="line">                path[node.id] = current_node.id</span><br><span class="line">                # 更新されたらpriorityに値を追加</span><br><span class="line">                heappush(minHeap, (price_info + routes_from_start[current_node], node))</span><br><span class="line"></span><br><span class="line">    current_node = nodes[-1].id</span><br><span class="line">    path_array = []</span><br><span class="line"></span><br><span class="line">    #最短距離を記録したノードをゴールからたどる</span><br><span class="line">    while current_node:</span><br><span class="line">        path_array.append(current_node)</span><br><span class="line">        if current_node not in path:</span><br><span class="line">            break</span><br><span class="line">        current_node = path[current_node]</span><br><span class="line"></span><br><span class="line">    return routes_from_start[nodes[-1]], path_array[::-1]</span><br></pre></td></tr></table></figure>
<p>ダイクストラアルゴリズムでは最短距離を更新するノードが分かるのでそれを記録して最後に辿ればよいことになります。<br>
計算量は最短距離のノードの数分増えてしまうことになります。</p>
<h2 id="ところでなんでこれで最短経路が求まるのか"><a href="#%E3%81%A8%E3%81%93%E3%82%8D%E3%81%A7%E3%81%AA%E3%82%93%E3%81%A7%E3%81%93%E3%82%8C%E3%81%A7%E6%9C%80%E7%9F%AD%E7%B5%8C%E8%B7%AF%E3%81%8C%E6%B1%82%E3%81%BE%E3%82%8B%E3%81%AE%E3%81%8B"></a>ところでなんでこれで最短経路が求まるのか</h2>
<p>さてここまでみてきて多くの人はこう思ったのではないでしょうか？確かにアルゴリズムは簡単だしそれを実装するのもそんなに難しくはない。でもなんで最短距離が求まるの？軽く確認していきましょう</p>
<p><a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F8623f00e-2046-445a-f386-6341b4bef518.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=4286b7e1195710b30d6ffb7ab22967c7"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F8623f00e-2046-445a-f386-6341b4bef518.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=4286b7e1195710b30d6ffb7ab22967c7" alt="image.png"></a></p>
<p>Lに入っている頂点はスタートSからの最短距離であると仮定して、そこから繋がる最短の頂点がまたSから最短距離であることを言えたら良さそうですね。</p>
<p><a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F8eb04095-91e7-85e6-93f1-93cd7f927fa0.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=b64897102d0f8dec7ed56385248d0a06"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F8eb04095-91e7-85e6-93f1-93cd7f927fa0.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=b64897102d0f8dec7ed56385248d0a06" alt="image.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2Fa10dcc01-c558-6f52-3b6f-906cb3433456.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=57a5fb3ec3b55e91b33e0184905063aa"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2Fa10dcc01-c558-6f52-3b6f-906cb3433456.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=57a5fb3ec3b55e91b33e0184905063aa" alt="image.png"></a></p>
<p>さてTに含まれるうちの最短の頂点に移動するので、最小の点をiとするとd[i] = min(T)ですよね。<br>
さてここで各頂点をkとすると最短距離d[k] は d[k] &gt;= d[i]であることは確定しますよね。d[i] は最小の点であり、各頂点は非負なので。<br>
と次々やっていくと帰納法的に証明できます。</p>
<p>さてこれってよく考えたら漸化式ですよね。</p>
<p>d[i] = min(k ⊂ T) + iに隣接するLの頂点の最短距離</p>
<p>漸化式の時には動的計画法が</p>
<p>漸化式ときたらDPですよね。DPについてはこの記事がすごく参考になります(<a target="_blank" rel="noopener" href="https://qiita.com/drken/items/a5e6fe22863b7992efdb">https://qiita.com/drken/items/a5e6fe22863b7992efdb</a>)</p>
<p>ではDPならどういう風に値が更新されていくかというと<br>
<a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F800c0d89-06f7-335a-5195-2f47d85cc22c.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=76478692796218d17f0ab00d2f2651b4"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F800c0d89-06f7-335a-5195-2f47d85cc22c.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=76478692796218d17f0ab00d2f2651b4" alt="image.png"></a></p>
<p>このような感じで値が更新されていきます。縦軸は試行の回数。横軸は頂点です。</p>
<p>なんだダイクストラアルゴリズムはDPの一種だったんだ。</p>
<h2 id="まとめ"><a href="#%E3%81%BE%E3%81%A8%E3%82%81"></a>まとめ</h2>
<p>さてみてきましたダイクストラのアルゴリズムですが、一回理解してしまうと結構簡単に理解できます。あとは実装してみてアルゴリズムの問題で類似の問題に当たった時にあこれはあの時の！！という感じで解いていきたいものです。<br>
*余談ですが僕もDPの記事書きたい</p>
<p>解説したyoutubeチャンネルはこちら<br>
<a target="_blank" rel="noopener" href="https://youtu.be/jz8b0q5R1Ss">https://youtu.be/jz8b0q5R1Ss</a></p>
<h2 id="参考"><a href="#%E5%8F%82%E8%80%83"></a>参考</h2>
<p><a target="_blank" rel="noopener" href="http://www.lab2.kuis.kyoto-u.ac.jp/~shuichi/algintro/alg-6s.pdf">http://www.lab2.kuis.kyoto-u.ac.jp/~shuichi/algintro/alg-6s.pdf</a><br>
<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=X1AsMlJdiok">https://www.youtube.com/watch?v=X1AsMlJdiok</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="2025/05/28/%E5%88%9D%E5%BF%83%E8%80%85%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%83%80%E3%82%A4%E3%82%AF%E3%82%B9%E3%83%88%E3%83%A9%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="2025/05/26/JavaScript/JavaScript-Node-js/"
                            aria-label=": JavaScript-Node.js"
                        >
                            JavaScript-Node.js
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-26T22:16:57+08:00">
	
		    2025 年 5 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/">JavaScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>从本章开始，我们就正式开启JavaScript的后端开发之旅。</p>
<p>Node.js是目前非常火热的技术，但是它的诞生经历却很奇特。</p>
<p>众所周知，在Netscape设计出JavaScript后的短短几个月，JavaScript事实上已经是前端开发的唯一标准。</p>
<p>后来，微软通过IE击败了Netscape后一统桌面，结果几年时间，浏览器毫无进步。</p>
<p>没有竞争就没有发展。微软认为IE6浏览器已经非常完善，几乎没有可改进之处，然后解散了IE6开发团队！而Google却认为支持现代Web应用的新一代浏览器才刚刚起步，尤其是浏览器负责运行JavaScript的引擎性能还可提升10倍。</p>
<p>先是Mozilla借助已壮烈牺牲的Netscape遗产在2002年推出了<a target="_blank" rel="noopener" href="https://www.mozilla.org/firefox/">Firefox</a>浏览器，紧接着Apple于2003年在开源的KHTML浏览器的基础上推出了WebKit内核的<a target="_blank" rel="noopener" href="https://www.apple.com/safari/">Safari</a>浏览器，不过仅限于Mac平台。</p>
<p>随后，Google也开始创建自家的浏览器。他们也看中了WebKit内核，于是基于WebKit内核推出了<a target="_blank" rel="noopener" href="https://www.google.com/chrome/">Chrome</a>浏览器。</p>
<p>Chrome浏览器是跨Windows和Mac平台的，并且，Google认为要运行现代Web应用，浏览器必须有一个性能非常强劲的JavaScript引擎，于是Google自己开发了一个高性能JavaScript引擎，名字叫V8，以BSD许可证开源。</p>
<p>现代浏览器大战让微软的IE浏览器远远地落后了，因为他们解散了最有经验、战斗力最强的浏览器团队！回过头再追赶却发现，支持HTML5的WebKit已经成为手机端的标准了，IE浏览器从此与主流移动端设备绝缘。</p>
<p>浏览器大战和Node有何关系？</p>
<p>话说有个叫Ryan Dahl的歪果仁，他的工作是用C/C++写高性能Web服务。对于高性能，异步IO、事件驱动是基本原则，但是用C/C++写就太痛苦了。于是这位仁兄开始设想用高级语言开发Web服务。他评估了很多种高级语言，发现很多语言虽然同时提供了同步IO和异步IO，但是开发人员一旦用了同步IO，他们就再也懒得写异步IO了，所以，最终，Ryan瞄向了JavaScript。</p>
<p>因为JavaScript是单线程执行，根本不能进行同步IO操作，所以，JavaScript的这一“缺陷”导致了它只能使用异步IO。</p>
<p>选定了开发语言，还要有运行时引擎。这位仁兄曾考虑过自己写一个，不过明智地放弃了，因为V8就是开源的JavaScript引擎。让Google投资去优化V8，咱只负责改造一下拿来用，还不用付钱，这个买卖很划算。</p>
<p>于是在2009年，Ryan正式推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为<a target="_blank" rel="noopener" href="https://nodejs.org/">Node.js</a>。虽然名字很土，但是，Node第一次把JavaScript带入到后端服务器开发，加上世界上已经有无数的JavaScript开发人员，所以Node一下子就火了起来。</p>
<p>在Node上运行的JavaScript相比其他后端开发语言有何优势？</p>
<p>最大的优势是借助JavaScript天生的事件驱动机制加V8高性能引擎，使编写高性能Web服务轻而易举。</p>
<p>其次，JavaScript语言本身是完善的函数式语言，在前端开发时，开发人员往往写得比较随意，让人感觉JavaScript就是个“玩具语言”。但是，在Node环境下，通过模块化的JavaScript代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的ECMAScript 6标准，可以完全满足工程上的需求。</p>
<p>由于Node.js平台是在后端运行JavaScript代码，所以，必须首先在本机安装Node环境。</p>
<h3 id="安装Node-js">安装Node.js</h3>
<p>目前Node.js的最新版本是22.3.0，LTS版本是20.14.0，追求稳定性如服务器上长期运行的Node环境可以选择LTS版本，本地开发和测试可以选择最新版本。</p>
<p>要安装Node.js，首先，从<a target="_blank" rel="noopener" href="https://nodejs.org/">Node.js官网</a>下载对应平台的安装程序，初学者建议选择Prebuilt Installer，选择版本，再选操作系统，最后选CPU类型后点Download下载：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/install/install-node.png" alt="download"></p>
<p>有经验的开发者可以选择Package Manager，它允许本地安装多个不同版本的Node并切换至不同版本。</p>
<p>在Windows上安装时务必选择全部组件，包括勾选<code>Add to Path</code>。</p>
<p>安装完成后，在Windows环境下，请打开命令提示符，然后输入<code>node -v</code>，如果安装正常，你应该看到<code>v22.3.0</code>这样的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\IEUser&gt; node -v</span><br><span class="line">v22.3.0</span><br></pre></td></tr></table></figure>
<p>继续在命令提示符输入<code>node</code>，此刻你将进入Node.js的交互环境。在交互环境下，你可以输入任意JavaScript语句，例如<code>100+200</code>，回车后将得到输出结果。</p>
<p>要退出Node.js环境，连按两次Ctrl+C。</p>
<h3 id="npm">npm</h3>
<p>在正式开始Node.js学习之前，我们先认识一下npm。</p>
<p>npm是什么东东？npm其实是Node.js的包管理工具（package manager）。</p>
<p>为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。</p>
<p>更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。</p>
<p>讲了这么多，npm究竟在哪？</p>
<p>其实npm已经在Node.js安装的时候顺带装好了。我们在命令提示符或者终端输入<code>npm -v</code>，应该看到类似的输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;npm -v</span><br><span class="line">10.8.0</span><br></pre></td></tr></table></figure>
<p>如果直接输入<code>npm</code>，你会看到类似下面的输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; npm</span><br><span class="line"></span><br><span class="line">Usage: npm &lt;command&gt;</span><br><span class="line"></span><br><span class="line">where &lt;command&gt; is one of:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>上面的一大堆文字告诉你，<code>npm</code>需要跟上命令。现在我们不用关心这些命令，后面会一一讲到。目前，你只需要确保npm正确安装了，能运行就行。</p>
<h3 id="小结">小结</h3>
<p>请在本机安装Node.js环境，并确保<code>node</code>和<code>npm</code>能正常运行。</p>
<p>在前面的所有章节中，我们编写的JavaScript代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。</p>
<p>从本章开始，我们编写的JavaScript代码将<em>不能</em>在浏览器环境中执行了，而是在Node环境中执行，因此，JavaScript代码将直接在你的计算机上以命令行的方式运行，所以，我们要先选择一个文本编辑器来编写JavaScript代码，并且把它保存到本地硬盘的某个目录，才能够执行。</p>
<p>那么问题来了：文本编辑器到底哪家强？</p>
<p>首先，请注意，<strong>绝对不能用Word和写字板</strong>。Word和写字板保存的不是纯文本文件。如果我们要用记事本来编写JavaScript代码，要务必注意，记事本以UTF-8格式保存文件时，会自作聪明地在文件开始的地方加上几个特殊字符（UTF-8 BOM），结果经常会导致程序运行出现莫名其妙的错误。</p>
<p>所以，用记事本写代码时请注意，保存文件时使用ANSI编码，并且暂时不要输入中文。</p>
<p>如果你的电脑上已经安装了<a target="_blank" rel="noopener" href="https://code.visualstudio.com/">Visual Studio Code</a>，也可以用来编写JavaScript代码，注意用UTF-8格式保存。</p>
<p>输入以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world.&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>第一行总是写上<code>'use strict';</code>是因为我们总是以严格模式运行JavaScript代码，避免各种潜在陷阱。</p>
<p>然后，选择一个目录，例如<code>C:\Workspace</code>，把文件保存为<code>hello.js</code>，就可以打开命令行窗口，把当前目录切换到<code>hello.js</code>所在目录，然后输入以下命令运行这个程序了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Workspace&gt; node hello.js</span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure>
<p>也可以保存为别的名字，比如<code>first.js</code>，但是必须要以<code>.js</code>结尾。此外，文件名只能是英文字母、数字和下划线的组合。</p>
<p>如果当前目录下没有<code>hello.js</code>这个文件，运行<code>node hello.js</code>就会报错：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Workspace&gt; node hello.js</span><br><span class="line">node:internal/modules/cjs/loader:1227</span><br><span class="line">    throw err;</span><br><span class="line">          ^</span><br><span class="line">Error: Cannot find module &#x27;C:\Workspace\hello.js&#x27;</span><br><span class="line">    at Module._resolveFilename</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>报错的意思就是，没有找到<code>hello.js</code>这个文件，因为文件不存在。这个时候，就要检查一下当前目录下是否有这个文件了。</p>
<h3 id="命令行模式和Node交互模式">命令行模式和Node交互模式</h3>
<p>请注意区分命令行模式和Node交互模式。</p>
<p>看到类似<code>PS C:\&gt;</code>是在Windows提供的命令行模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────┐</span><br><span class="line">│Windows PowerShell                                 - □ x │</span><br><span class="line">├─────────────────────────────────────────────────────────┤</span><br><span class="line">│Windows PowerShell                                       │</span><br><span class="line">│Copyright (C) Microsoft Corporation. All rights reserved.│</span><br><span class="line">│                                                         │</span><br><span class="line">│PS C:\Users\liaoxuefeng&gt; node hello.js                   │</span><br><span class="line">│Hello, world.                                            │</span><br><span class="line">│                                                         │</span><br><span class="line">│PS C:\Users\liaoxuefeng&gt;                                 │</span><br><span class="line">│                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>在命令行模式下，可以执行<code>node</code>进入Node交互式环境，也可以执行<code>node hello.js</code>运行一个<code>.js</code>文件。</p>
<p>看到<code>&gt;</code>是在Node交互式环境下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────┐</span><br><span class="line">│Windows PowerShell                                 - □ x │</span><br><span class="line">├─────────────────────────────────────────────────────────┤</span><br><span class="line">│Windows PowerShell                                       │</span><br><span class="line">│Copyright (C) Microsoft Corporation. All rights reserved.│</span><br><span class="line">│                                                         │</span><br><span class="line">│PS C:\Users\liaoxuefeng&gt; node                            │</span><br><span class="line">│Welcome to Node.js v22.x.x.                              │</span><br><span class="line">│&gt;                                                        │</span><br><span class="line">│                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>在Node交互式环境下，我们可以输入JavaScript代码并立刻执行。</p>
<p>此外，在命令行模式运行<code>.js</code>文件和在Node交互式环境下直接运行JavaScript代码有所不同。Node交互式环境会把每一行JavaScript代码的结果自动打印出来，但是，直接运行JavaScript文件却不会。</p>
<p>例如，在Node交互式环境下，输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 100 + 200 + 300;</span><br><span class="line">600</span><br></pre></td></tr></table></figure>
<p>直接可以看到结果<code>600</code>。</p>
<p>但是，写一个<code>calc.js</code>的文件，内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> + <span class="number">200</span> + <span class="number">300</span>;</span><br></pre></td></tr></table></figure>
<p>然后在命令行模式下执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Workspace&gt; node calc.js</span><br></pre></td></tr></table></figure>
<p>发现什么输出都没有。</p>
<p>这是正常的。想要输出结果，必须自己用<code>console.log()</code>打印出来。把<code>calc.js</code>改造一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">100</span> + <span class="number">200</span> + <span class="number">300</span>);</span><br></pre></td></tr></table></figure>
<p>再执行，就可以看到结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Workspace&gt; node calc.js</span><br><span class="line">600</span><br></pre></td></tr></table></figure>
<h3 id="小结-2">小结</h3>
<p>用文本编辑器写JavaScript程序，然后保存为后缀为<code>.js</code>的文件，就可以用node直接运行这个程序了。</p>
<p>Node的交互模式和直接运行<code>.js</code>文件有什么区别呢？</p>
<p>直接输入<code>node</code>进入交互模式，相当于启动了Node解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。</p>
<p>直接运行<code>node hello.js</code>文件相当于启动了Node解释器，然后一次性把<code>hello.js</code>文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。</p>
<p>在编写JavaScript代码的时候，完全可以一边在文本编辑器里写代码，一边开一个Node交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍！前提是得有个27’的超大显示器！</p>
<h3 id="参考源码">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/first-node-app/hello.js">hello.js</a></p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/first-node-app/calc.js">calc.js</a></p>
<p>使用文本编辑器来开发Node程序，最大的缺点是效率太低，运行Node程序还需要在命令行单独敲命令。如果还需要调试程序，就更加麻烦了。</p>
<p>所以我们需要一个IDE集成开发环境，让我们能在一个环境里编码、运行、调试，这样就可以大大提升开发效率。</p>
<p>Java的集成开发环境有Eclipse，Intellij idea等，C#的集成开发环境有Visual Studio，那么问题又来了：Node.js的集成开发环境到底哪家强？</p>
<p>考察Node.js的集成开发环境，重点放在启动速度快，执行简单，调试方便这三点上。当然，免费使用是一个加分项。</p>
<p>综合考察后，我们隆重向大家推荐Node.js集成开发环境：</p>
<h2 id="Visual-Studio-Code">Visual Studio Code</h2>
<p>Visual Studio Code由微软出品，但它不是那个大块头的Visual Studio，它是一个精简版的迷你Visual Studio，并且，Visual Studio Code可以跨！平！台！Windows、Mac和Linux通用。</p>
<h3 id="安装Visual-Studio-Code">安装Visual Studio Code</h3>
<p>可以从Visual Studio Code的<a target="_blank" rel="noopener" href="http://code.visualstudio.com/">官方网站</a>下载并安装最新的版本。</p>
<p>安装过程中，请务必钩上以下选项“将“通过Code打开”操作添加到Windows资源管理器目录上下文菜单”：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/dev-env/install-vscode.png" alt="install-vsc"></p>
<p>这将大大提升将来的操作快捷度。</p>
<h3 id="运行和调试JavaScript">运行和调试JavaScript</h3>
<p>在VS Code中，我们可以非常方便地运行JavaScript文件。</p>
<p>VS Code以文件夹作为工程目录（Workspace Dir），所有的JavaScript文件都存放在该目录下。</p>
<p>假设我们在<code>C:\Work\</code>目录下创建了一个<code>hello</code>目录作为工程目录，并编写了一个<code>hello.js</code>文件，则该工程目录的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello/        &lt;-- workspace dir</span><br><span class="line">└── hello.js  &lt;-- JavaScript file</span><br></pre></td></tr></table></figure>
<p>启动VS Code，选择菜单File - Open Folder…，选择<code>hello</code>目录，就可以直接编辑<code>hello.js</code>文件：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/dev-env/vscode-edit.png" alt="vscode-edit"></p>
<h3 id="运行JS代码">运行JS代码</h3>
<p>确保当前编辑器正在编辑<code>hello.js</code>文件，然后在VS Code中选择左侧调试按钮，直接点击<code>Run And Debug</code>按钮，如果弹出环境选项则选择<code>Node</code>，在右下侧<code>DEBUG CONSOLE</code>可直接看到运行结果。</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/dev-env/vscode-run.png" alt="vscode-run"></p>
<p>如果右下侧面板没有显示，左上角有几个按钮可以切换视图。</p>
<h3 id="调试JS代码">调试JS代码</h3>
<p>在VS Code中，可以通过断点调试方便进行JavaScript的开发和测试。我们先在<code>hello.js</code>的编辑器中打一个断点（鼠标点击行号左侧出现小红点即为断点），然后点击<code>Run And Debug</code>按钮，此时进入调试模式，会自动停在断点处，左侧窗口可查看变量，顶部按钮可选择单步执行或继续执行到下一个断点，也可以随时结束程序：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/dev-env/vscode-debug.png" alt="vscode-debug"></p>
<p>总的来说，使用VS Code，开发和调试JavaScript代码十分方便。</p>
<h3 id="参考源码-2">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/dev-env/hello.js">hello.js</a></p>
<p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。</p>
<p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Node环境中，一个.js文件就称之为一个模块（module）。</p>
<p>使用模块有什么好处？</p>
<p>最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。</p>
<p>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。</p>
<p>在上一节，我们编写了一个<code>hello.js</code>文件，这个<code>hello.js</code>文件就是一个模块，模块的名字就是文件名（去掉<code>.js</code>后缀），所以<code>hello.js</code>文件就是名为<code>hello</code>的模块。</p>
<p>我们把<code>hello.js</code>改造一下，创建一个函数，这样我们就可以在其他地方调用这个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(s + <span class="string">&#x27;, &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = greet;</span><br></pre></td></tr></table></figure>
<p>函数<code>greet()</code>是我们在<code>hello</code>模块中定义的，你可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数<code>greet</code>作为模块的输出暴露出去，这样其他模块就可以使用<code>greet</code>函数了。</p>
<p>问题是其他模块怎么使用<code>hello</code>模块的这个<code>greet</code>函数呢？我们再编写一个<code>main.js</code>文件，调用<code>hello</code>模块的<code>greet</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入hello模块:</span></span><br><span class="line"><span class="keyword">const</span> greet = <span class="built_in">require</span>(<span class="string">&#x27;./hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>(s); <span class="comment">// Hello, Michael!</span></span><br></pre></td></tr></table></figure>
<p>注意到引入<code>hello</code>模块用Node提供的<code>require</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = <span class="built_in">require</span>(<span class="string">&#x27;./hello&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>引入的模块作为变量保存在<code>greet</code>变量中，那<code>greet</code>变量到底是什么东西？其实变量<code>greet</code>就是在<code>hello.js</code>中我们用<code>module.exports = greet;</code>输出的<code>greet</code>函数。所以，<code>main.js</code>就成功地引用了<code>hello.js</code>模块中定义的<code>greet()</code>函数，接下来就可以直接使用它了。</p>
<p>在使用<code>require()</code>引入模块的时候，请注意模块的相对路径。因为<code>main.js</code>和<code>hello.js</code>位于同一个目录，所以我们用了当前目录<code>.</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = <span class="built_in">require</span>(<span class="string">&#x27;./hello&#x27;</span>); <span class="comment">// 不要忘了写相对目录!</span></span><br></pre></td></tr></table></figure>
<p>如果只写模块名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = <span class="built_in">require</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>则Node会依次在内置模块、全局模块和当前模块下查找<code>hello.js</code>，你很可能会得到一个错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">js</span></span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">          ^</span><br><span class="line"><span class="title class_">Error</span>: <span class="title class_">Cannot</span> find <span class="variable language_">module</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    at <span class="title class_">Module</span>.<span class="property">_resolveFilename</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>遇到这个错误，你要检查：</p>
<ul>
<li>模块名是否写对了；</li>
<li>模块文件是否存在；</li>
<li>相对路径是否写对了。</li>
</ul>
<h3 id="CommonJS规范">CommonJS规范</h3>
<p>这种模块加载机制被称为CommonJS规范。在这个规范下，每个<code>.js</code>文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，<code>hello.js</code>和<code>main.js</code>都申明了全局变量<code>var s = 'xxx'</code>，但互不影响。</p>
<p>一个模块想要对外暴露变量（函数也是变量），可以用<code>module.exports = variable;</code>，一个模块要引用其他模块暴露的变量，用<code>var ref = require('module_name');</code>就拿到了引用模块的变量。</p>
<h3 id="结论">结论</h3>
<p>要在模块中对外输出变量，用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = variable;</span><br></pre></td></tr></table></figure>
<p>输出的变量可以是任意对象、函数、数组等等。</p>
<p>要引入其他模块输出的对象，用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;other_module&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>引入的对象具体是什么，取决于引入模块输出的对象。</p>
<h3 id="深入了解模块原理">深入了解模块原理</h3>
<p>如果你想详细地了解CommonJS的模块实现原理，请继续往下阅读。如果不想了解，请直接跳到最后做练习。</p>
<p>当我们编写JavaScript代码时，我们可以申明全局变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;global&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>在浏览器中，大量使用全局变量可不好。如果你在<code>a.js</code>中使用了全局变量<code>s</code>，那么，在<code>b.js</code>中也使用全局变量<code>s</code>，将造成冲突，<code>b.js</code>中对<code>s</code>赋值会改变<code>a.js</code>的运行逻辑。</p>
<p>也就是说，在ESM标准之前，JavaScript语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。</p>
<p>那Node.js是如何实现这一点的？</p>
<p>其实要实现“模块”这个功能，并不需要语法层面的支持。Node.js也并不会增加任何JavaScript语法。实现“模块”功能的奥妙就在于JavaScript是一种函数式编程语言，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。</p>
<p>请注意我们编写的<code>hello.js</code>代码是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s + <span class="string">&#x27; &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>Node.js加载了<code>hello.js</code>后，它可以把代码包装一下，变成这样执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 读取的hello.js代码:</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(s + <span class="string">&#x27; &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    <span class="comment">// hello.js代码结束</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>这样一来，原来的全局变量<code>s</code>现在变成了匿名函数内部的局部变量。如果Node.js继续加载其他模块，这些模块中定义的“全局”变量<code>s</code>也互不干扰。</p>
<p>所以，Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离。</p>
<p>但是，模块的输出<code>module.exports</code>怎么实现？</p>
<p>这个也很容易实现，Node可以先准备一个对象<code>module</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备module对象:</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable language_">module</span> = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    <span class="attr">exports</span>: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> load = <span class="keyword">function</span> (<span class="params"><span class="variable language_">module</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 读取的hello.js代码:</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = greet;</span><br><span class="line">    <span class="comment">// hello.js代码结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">module</span>.<span class="property">exports</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> exported = <span class="title function_">load</span>(<span class="variable language_">module</span>);</span><br><span class="line"><span class="comment">// 保存module:</span></span><br><span class="line"><span class="title function_">save</span>(<span class="variable language_">module</span>, exported);</span><br></pre></td></tr></table></figure>
<p>可见，变量<code>module</code>是Node在加载js文件前准备的一个变量，并将其传入加载函数，我们在<code>hello.js</code>中可以直接使用变量<code>module</code>原因就在于它实际上是函数的一个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = greet;</span><br></pre></td></tr></table></figure>
<p>通过把参数<code>module</code>传递给<code>load()</code>函数，<code>hello.js</code>就顺利地把一个变量传递给了Node执行环境，Node会把<code>module</code>变量保存到某个地方。</p>
<p>由于Node保存了所有导入的<code>module</code>，当我们用<code>require()</code>获取module时，Node找到对应的<code>module</code>，把这个<code>module</code>的<code>exports</code>变量返回，这样，另一个模块就顺利拿到了模块的输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = <span class="built_in">require</span>(<span class="string">&#x27;./hello&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>以上是Node实现JavaScript模块的一个简单的原理介绍。</p>
<h3 id="module-exports-vs-exports">module.exports vs exports</h3>
<p>很多时候，你会看到，在Node环境中，有两种方法可以在一个模块中输出变量：</p>
<p>方法一：对module.exports赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">hello</span>: hello,</span><br><span class="line">    <span class="attr">greet</span>: greet</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：直接使用exports：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">hello</span> = hello;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">greet</span> = greet;</span><br></pre></td></tr></table></figure>
<p>但是你不可以直接对<code>exports</code>赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码可以执行，但是模块并没有输出任何变量:</span></span><br><span class="line"><span class="built_in">exports</span> = &#123;</span><br><span class="line">    <span class="attr">hello</span>: hello,</span><br><span class="line">    <span class="attr">greet</span>: greet</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果你对上面的写法感到十分困惑，不要着急，我们来分析Node的加载机制：</p>
<p>首先，Node会把整个待加载的<code>hello.js</code>文件放入一个包装函数<code>load</code>中执行。在执行这个<code>load()</code>函数前，Node准备好了module变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable language_">module</span> = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    <span class="attr">exports</span>: &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>load()</code>函数最终返回<code>module.exports</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> load = <span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">    <span class="comment">// hello.js的文件内容</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// load函数返回:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">module</span>.<span class="property">exports</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> exported = <span class="title function_">load</span>(<span class="variable language_">module</span>.<span class="property">exports</span>, <span class="variable language_">module</span>);</span><br></pre></td></tr></table></figure>
<p>也就是说，默认情况下，Node准备的<code>exports</code>变量和<code>module.exports</code>变量实际上是同一个变量，并且初始化为空对象<code>&#123;&#125;</code>，于是，我们可以写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">foo</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; &#125;;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">bar</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>也可以写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">foo</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; &#125;;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">bar</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>换句话说，Node默认给你准备了一个空对象<code>&#123;&#125;</code>，这样你可以直接往里面加东西。</p>
<p>但是，如果我们要输出的是一个函数或数组，那么，只能给<code>module.exports</code>赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>给<code>exports</code>赋值是无效的，因为赋值后，<code>module.exports</code>仍然是空对象<code>&#123;&#125;</code>。</p>
<h3 id="结论-2">结论</h3>
<p>如果要输出一个键值对象<code>&#123;&#125;</code>，可以利用<code>exports</code>这个已存在的空对象<code>&#123;&#125;</code>，并继续在上面添加新的键值；</p>
<p>如果要输出一个函数或数组，必须直接对<code>module.exports</code>对象赋值。</p>
<p>所以我们可以得出结论：直接对<code>module.exports</code>赋值，可以应对任何情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>最终，我们<em>强烈建议</em>使用<code>module.exports = xxx</code>的方式来输出模块变量，这样，你只需要记忆一种方法。</p>
<h3 id="练习">练习</h3>
<p>编写<code>hello.js</code>，输出一个或多个函数；</p>
<p>编写<code>main.js</code>，引入<code>hello</code>模块，调用其函数。</p>
<h3 id="参考源码-3">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/module/hello.zip">module</a></p>
<p>虽然Node.js从诞生起就支持模块，但JavaScript语言本身长期以来却一直没有模块功能，只能由CommonJS或其他AMD等模块系统来“模拟”。</p>
<p>随着ES 6标准的推出，JavaScript语言本身终于也迎来了原生内置的模块支持，称为ECMAScript Modules（简称ESM），不仅可以直接在浏览器中使用模块，也可以在Node.js中使用ESM模块。</p>
<p>不使用ESM模块时，我们用<code>module.exports</code>导出可供外部使用的JS对象，例如，以下模块导出了两个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">out</span>(<span class="params">prompt, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;prompt&#125;</span>, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title function_">out</span>(s, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hi</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title function_">out</span>(<span class="string">&#x27;Hi&#x27;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">greet</span>: greet,</span><br><span class="line">    <span class="attr">hi</span>: hi</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要把上述代码改为ESM模块，我们用<code>export</code>标识需要导出的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// out是模块内部函数，模块外部不可见:</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">out</span>(<span class="params">prompt, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;prompt&#125;</span>, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// greet是导出函数，可被外部调用:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title function_">out</span>(s, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hi是导出函数，可被外部调用:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">hi</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title function_">out</span>(<span class="string">&#x27;Hi&#x27;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并将其保存为<code>hello.mjs</code>文件，注意扩展名不是<code>.js</code>，而是<code>.mjs</code>。</p>
<p>可以再编写一个<code>main.mjs</code>文件来调用<code>hello</code>模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; greet, hi &#125; <span class="keyword">from</span> <span class="string">&#x27;./hello.mjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"><span class="title function_">greet</span>(name);</span><br><span class="line"><span class="title function_">hi</span>(name);</span><br></pre></td></tr></table></figure>
<p>可见，ESM模块用<code>export</code>关键字导出一个JS对象，用<code>import</code>关键字导入一个模块的导出对象。</p>
<p>如果要实现类似如下代码的单个函数导出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = greet;</span><br></pre></td></tr></table></figure>
<p>则可以用<code>export default</code>导出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的，导入代码修改为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> greet <span class="keyword">from</span> <span class="string">&#x27;./hello.mjs&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>细心的同学还注意到ESM模块文件第一行并没有<code>'use strict'</code>，这是因为ESM模块默认启用严格模式，因此无需再手动声明<code>'use strict'</code>。</p>
<h3 id="浏览器加载ESM">浏览器加载ESM</h3>
<p>对于浏览器来说，也可以直接使用ESM模块。当我们加载一个ESM模块时，需要用<code>type=&quot;module&quot;</code>来表示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./example.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">greet</span>(<span class="string">&#x27;Bob&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者直接使用<code>import</code>加载一个模块：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">import</span> &#123; greet &#125; <span class="keyword">from</span> <span class="string">&#x27;./example.js&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">greet</span>(<span class="string">&#x27;Bob&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="练习-2">练习</h3>
<p>在Node环境中使用ESM模块：</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/esm/esm.zip">下载练习</a></p>
<h3 id="小结-3">小结</h3>
<p>使用JavaScript内置的原生模块时，用关键字<code>export</code>和<code>import</code>来实现导出与导入；</p>
<p>ESM模块默认启用strict模式，无需声明<code>'use strict'</code>。</p>
<p>因为Node.js是运行在服务区端的JavaScript环境，服务器程序和浏览器程序相比，最大的特点是没有浏览器的安全限制了，而且，服务器程序必须能接收网络请求，读写文件，处理二进制内容，所以，Node.js内置的常用模块就是为了实现基本的服务器功能。这些模块在浏览器环境中是无法被执行的，因为它们的底层代码是用C/C++在Node.js运行环境中实现的。</p>
<h3 id="global">global</h3>
<p>在前面的JavaScript课程中，我们已经知道，JavaScript有且仅有一个全局对象，在浏览器中，叫<code>window</code>对象。而在Node.js环境中，也有唯一的全局对象，但不叫<code>window</code>，而叫<code>global</code>，这个对象的属性和方法也和浏览器环境的<code>window</code>不同。进入Node.js交互环境，可以直接输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; global.console</span><br><span class="line">Object [console] &#123;</span><br><span class="line">  log: [Function: log],</span><br><span class="line">  warn: [Function: warn],</span><br><span class="line">  dir: [Function: dir],</span><br><span class="line">  time: [Function: time],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="process">process</h3>
<p><code>process</code>也是Node.js提供的一个对象，它代表当前Node.js进程。通过<code>process</code>对象可以拿到许多有用信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; process === global.process;</span><br><span class="line">true</span><br><span class="line">&gt; process.version;</span><br><span class="line">&#x27;v22.3.0&#x27;</span><br><span class="line">&gt; process.platform;</span><br><span class="line">&#x27;darwin&#x27;</span><br><span class="line">&gt; process.arch;</span><br><span class="line">&#x27;x64&#x27;</span><br><span class="line">&gt; process.cwd(); //返回当前工作目录</span><br><span class="line">&#x27;/Users/michael&#x27;</span><br><span class="line">&gt; process.chdir(&#x27;/private/tmp&#x27;); // 切换当前工作目录</span><br><span class="line">undefined</span><br><span class="line">&gt; process.cwd();</span><br><span class="line">&#x27;/private/tmp&#x27;</span><br></pre></td></tr></table></figure>
<p>JavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。</p>
<p>如果我们想要在下一次事件响应中执行代码，可以调用<code>process.nextTick()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="comment">// process.nextTick()将在下一轮事件循环中调用:</span></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick callback!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick was set!&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>用Node执行上面的代码<code>node test.js</code>，你会看到，打印输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nextTick was set!</span><br><span class="line">nextTick callback!</span><br></pre></td></tr></table></figure>
<p>这说明传入<code>process.nextTick()</code>的函数不是立刻执行，而是要等到下一次事件循环。</p>
<p>Node.js进程本身的事件就由<code>process</code>对象来处理。如果我们响应<code>exit</code>事件，就可以在程序即将退出时执行某个回调函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序即将退出时的回调函数:</span></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;exit&#x27;</span>, <span class="keyword">function</span> (<span class="params">code</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;about to exit with code: &#x27;</span> + code);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="判断JavaScript执行环境">判断JavaScript执行环境</h3>
<p>有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">typeof</span>(<span class="variable language_">window</span>) === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;node.js&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;browser&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="导入Node模块">导入Node模块</h3>
<p>Node内置了许多模块，可以从Node.js的<a target="_blank" rel="noopener" href="https://nodejs.org/api/">在线文档</a>查询所有模块信息。</p>
<p>以<code>crypto</code>模块的<code>randomInt()</code>函数为例，导入模块有两种方法：</p>
<p>方法一：使用传统的<code>require()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; randomInt &#125; = <span class="built_in">require</span>(<span class="string">&#x27;node:crypto&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> n = <span class="title function_">randomInt</span>(<span class="number">0</span>, <span class="number">100</span>); <span class="comment">// 0~100之间的随机数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br></pre></td></tr></table></figure>
<p>方法二：使用<code>import</code>关键字导入ESM模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; randomInt &#125; <span class="keyword">from</span> <span class="string">&#x27;node:crypto&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> n = <span class="title function_">randomInt</span>(<span class="number">0</span>, <span class="number">100</span>); <span class="comment">// 0~100之间的随机数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br></pre></td></tr></table></figure>
<p>后面，我们将介绍Node.js的常用内置模块。</p>
<p>Node.js内置的<code>fs</code>模块就是文件系统模块，负责读写文件。</p>
<p>和所有其它JavaScript模块不同的是，<code>fs</code>模块同时提供了异步和同步的方法。</p>
<p>回顾一下什么是异步方法。因为JavaScript的单线程模型，执行IO操作时，JavaScript代码无需等待，而是传入回调函数后，继续执行后续JavaScript代码。比如jQuery提供的<code>getJSON()</code>操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">getJSON</span>(<span class="string">&#x27;http://example.com/ajax&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;IO结果返回后执行...&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;不等待IO结果直接执行后续代码...&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>而同步的IO操作则需要等待函数返回：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据网络耗时，函数将执行几十毫秒~几秒不等:</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="title function_">getJSONSync</span>(<span class="string">&#x27;http://example.com/ajax&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>同步操作的好处是代码简单，缺点是程序将等待IO操作，在等待时间内，无法响应其它任何事件。而异步读取不用等待IO操作，但代码较麻烦。</p>
<h3 id="异步读文件">异步读文件</h3>
<p>按照JavaScript的标准，异步读取一个文本文件的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read-text-file-async.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;BEGIN&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">readFile</span>(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;END&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>请注意，<code>sample.txt</code>文件必须在当前目录下，且文件编码为<code>utf-8</code>。</p>
<p>异步读取时，传入的回调函数接收两个参数，当正常读取时，<code>err</code>参数为<code>null</code>，<code>data</code>参数为读取到的String。当读取发生错误时，<code>err</code>参数代表一个错误对象，<code>data</code>为<code>undefined</code>。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。后面我们还会经常编写这种回调函数。</p>
<p>由于<code>err</code>是否为<code>null</code>就是判断是否出错的标志，所以通常的判断逻辑总是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 出错了</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上述代码，可以看到打印的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; BEGIN &gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; END &gt;&gt;&gt;</span><br><span class="line">Sample file content...</span><br></pre></td></tr></table></figure>
<p>因为异步读取，所以，先打印<code>END</code>后，才会执行回调函数，打印文件内容。</p>
<p>如果我们要读取的文件不是文本文件，而是二进制文件，怎么办？</p>
<p>下面的例子演示了如何读取一个图片文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">readFile</span>(<span class="string">&#x27;sample.png&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data <span class="keyword">instanceof</span> <span class="title class_">Buffer</span>); <span class="comment">// true</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// Buffer(12451) [137, 80, 78, 71, 13, ...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当读取二进制文件时，不传入文件编码时，回调函数的<code>data</code>参数将返回一个<code>Buffer</code>对象。在Node.js中，<code>Buffer</code>对象就是一个包含零个或任意个字节的数组（注意和Array不同）。</p>
<p><code>Buffer</code>对象可以和String作转换，例如，把一个<code>Buffer</code>对象转换成String：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buffer -&gt; String</span></span><br><span class="line"><span class="keyword">let</span> text = data.<span class="title function_">toString</span>(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span><br></pre></td></tr></table></figure>
<p>或者把一个String转换成<code>Buffer</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String -&gt; Buffer</span></span><br><span class="line"><span class="keyword">let</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(text, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf);</span><br></pre></td></tr></table></figure>
<h3 id="同步读文件">同步读文件</h3>
<p>除了标准的异步读取模式外，<code>fs</code>也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个<code>Sync</code>后缀，并且不接收回调函数，函数直接返回结果。</p>
<p>用<code>fs</code>模块同步读取一个文本文件的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read-text-file-sync.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFileSync &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;BEGIN&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="title function_">readFileSync</span>(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;END&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>可见，原异步调用的回调函数的<code>data</code>被函数直接返回，函数名需要改为<code>readFileSync</code>，其它参数不变。</p>
<p>如果同步读取文件发生错误，则需要用<code>try...catch</code>捕获该错误。</p>
<h3 id="写文件">写文件</h3>
<p>将数据写入文件是通过<code>fs.writeFile()</code>实现的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write-file-async.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; writeFile &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = <span class="string">&#x27;Hello, Node.js&#x27;</span>;</span><br><span class="line"><span class="title function_">writeFile</span>(<span class="string">&#x27;output.txt&#x27;</span>, data, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>writeFile()</code>的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是<code>Buffer</code>，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个<code>err</code>参数。</p>
<p>和<code>readFile()</code>类似，<code>writeFile()</code>也有一个同步方法，叫<code>writeFileSync()</code>。</p>
<h3 id="stat">stat</h3>
<p>如果我们要获取文件大小，创建时间等信息，可以使用<code>fs.stat()</code>，它返回一个<code>Stat</code>对象，能告诉我们文件或目录的详细信息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read-stat-async.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">stat</span>(<span class="string">&#x27;sample.png&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, st</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 是否是文件:</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;isFile: &#x27;</span> + st.<span class="title function_">isFile</span>());</span><br><span class="line">        <span class="comment">// 是否是目录:</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;isDirectory: &#x27;</span> + st.<span class="title function_">isDirectory</span>());</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="title function_">isFile</span>()) &#123;</span><br><span class="line">            <span class="comment">// 文件大小:</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;size: &#x27;</span> + st.<span class="property">size</span>);</span><br><span class="line">            <span class="comment">// 创建时间, Date对象:</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;birth time: &#x27;</span> + st.<span class="property">birthtime</span>);</span><br><span class="line">            <span class="comment">// 修改时间, Date对象:</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;modified time: &#x27;</span> + st.<span class="property">mtime</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isFile: true</span><br><span class="line">isDirectory: false</span><br><span class="line">size: 12451</span><br><span class="line">birth time: Mon Jun 17 2024 19:37:24 GMT+0800 (China Standard Time)</span><br><span class="line">modified time: Mon Jun 17 2024 19:37:24 GMT+0800 (China Standard Time)</span><br></pre></td></tr></table></figure>
<p><code>stat()</code>也有一个对应的同步函数<code>statSync()</code>，请试着改写上述异步代码为同步代码。</p>
<h3 id="使用Promise">使用Promise</h3>
<p>我们在介绍JavaScript的<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/browser/promise/index.html">Promise</a>时，讲到通过<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/browser/async/index.html">async</a>函数实现异步逻辑，代码更简单。</p>
<p>类似的，Node还提供Promise版本的fs，可以用如下代码在async函数中读取文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async-read.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs/promises&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">readTextFile</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">readFile</span>(path, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">readTextFile</span>(<span class="string">&#x27;sample.txt&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">s</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(s));</span><br></pre></td></tr></table></figure>
<p>在async函数中，用await调用<code>fs/promises</code>与同步方法类似，但代码却是异步执行的。</p>
<h3 id="异步还是同步">异步还是同步</h3>
<p>在<code>fs</code>模块中，提供同步方法是为了方便使用。那我们到底是应该用异步方法还是同步方法呢？</p>
<p>由于Node环境执行的JavaScript代码是服务器端代码，所以，绝大部分需要在服务器运行期反复执行业务逻辑的代码，<em>必须使用异步代码</em>，否则，同步代码在执行时期，服务器将停止响应，因为JavaScript只有一个执行线程。</p>
<p>服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。</p>
<p>如果代码中编写了大量的async函数，那么通过await异步调用<code>fs/promises</code>模块更加方便。</p>
<h3 id="参考源码-4">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/fs/fs.zip">fs</a></p>
<p><code>stream</code>是Node.js提供的又一个仅在服务区端可用的模块，目的是支持“流”这种数据结构。</p>
<p>什么是流？流是一种抽象的数据结构。想象水流，当在水管中流动时，就可以从某个地方（例如自来水厂）源源不断地到达另一个地方（比如你家的洗手池）。我们也可以把数据看成是数据流，比如你敲键盘的时候，就可以把每个字符依次连起来，看成字符流。这个流是从键盘输入到应用程序，实际上它还对应着一个名字：标准输入流（stdin）。</p>
<p>如果应用程序把字符一个一个输出到显示器上，这也可以看成是一个流，这个流也有名字：标准输出流（stdout）。流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位。</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/stream/std.png" alt="stream"></p>
<p>有些流用来读取数据，比如从文件读取数据时，可以打开一个文件流，然后从文件流中不断地读取数据。有些流用来写入数据，比如向文件写入数据时，只需要把数据不断地往文件流中写进去就可以了。</p>
<p>在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：<code>data</code>事件表示流的数据已经可以读取了，<code>end</code>事件表示这个流已经到末尾了，没有数据可以读取了，<code>error</code>事件表示出错了。</p>
<p>下面是一个从文件流读取文本内容的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createReadStream &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开流:</span></span><br><span class="line"><span class="keyword">let</span> rs = <span class="title function_">createReadStream</span>(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取到数据:</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---- chunk ----&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(chunk);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束读取:</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---- end ----&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出错:</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>要注意，<code>data</code>事件可能会有多次，每次传递的<code>chunk</code>是流的一部分数据。</p>
<p>要以流的形式写入文件，只需要不断调用<code>write()</code>方法，最后以<code>end()</code>结束：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createWriteStream &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ws = <span class="title function_">createWriteStream</span>(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;使用Stream写入文本数据...\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;继续写入...\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;DONE.\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">end</span>(); <span class="comment">// 结束写入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入二进制数据:</span></span><br><span class="line"><span class="keyword">let</span> b64array = [ ... ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ws2 = <span class="title function_">createWriteStream</span>(<span class="string">&#x27;output.png&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> b64 <span class="keyword">of</span> b64array) &#123;</span><br><span class="line">    <span class="keyword">let</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(b64, <span class="string">&#x27;base64&#x27;</span>);</span><br><span class="line">    ws2.<span class="title function_">write</span>(buf); <span class="comment">// 写入Buffer对象</span></span><br><span class="line">&#125;</span><br><span class="line">ws2.<span class="title function_">end</span>(); <span class="comment">// 结束写入</span></span><br></pre></td></tr></table></figure>
<p>所有可以读取数据的流都继承自<code>stream.Readable</code>，所有可以写入的流都继承自<code>stream.Writable</code>。</p>
<h3 id="pipe">pipe</h3>
<p>就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个<code>Readable</code>流和一个<code>Writable</code>流串起来后，所有的数据自动从<code>Readable</code>流进入<code>Writable</code>流，这种操作叫<code>pipe</code>。</p>
<p>在Node.js中，<code>Readable</code>流有一个<code>pipe()</code>方法，就是用来干这件事的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.<span class="title function_">pipe</span>(ws);</span><br></pre></td></tr></table></figure>
<p>除了直接使用<code>pipe()</code>方法，Node还提供了<code>pipeline</code>功能，它可以将一个流输出到另一个流。以下是一个复制文件的程序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createReadStream, createWriteStream &#125; <span class="keyword">from</span> <span class="string">&quot;node:fs&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; pipeline &#125; <span class="keyword">from</span> <span class="string">&#x27;node:stream/promises&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">copy</span>(<span class="params">src, dest</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> rs = <span class="title function_">createReadStream</span>(src);</span><br><span class="line">    <span class="keyword">let</span> ws = <span class="title function_">createWriteStream</span>(dest);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">pipeline</span>(rs, ws);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">copy</span>(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;output.txt&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;copied.&#x27;</span>))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err));</span><br></pre></td></tr></table></figure>
<p>使用<code>pipeline</code>的好处是，它可以添加若干个转换器，即输入流经过若干转换后，再进入输出流。如果我们添加的转换器实现了gzip功能，那么实际上就可以把输入流自动压缩后进入输出流。</p>
<h3 id="参考源码-5">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/stream/stream.zip">stream</a></p>
<p>Node.js开发的目的就是为了用JavaScript编写Web服务器程序。因为JavaScript实际上已经统治了浏览器端的脚本，其优势就是有世界上数量最多的前端开发人员。如果已经掌握了JavaScript前端开发，再学习一下如何将JavaScript应用在后端开发，就是名副其实的<em>全栈</em>了。</p>
<h3 id="HTTP协议">HTTP协议</h3>
<p>要理解Web服务器程序的工作原理，首先，我们要对HTTP协议有基本的了解。如果你对HTTP协议不太熟悉，先看一看<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/web/http/index.html">HTTP协议简介</a>。</p>
<h3 id="HTTP服务器">HTTP服务器</h3>
<p>要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的<code>http</code>模块完成了。应用程序并不直接和HTTP协议打交道，而是操作<code>http</code>模块提供的<code>request</code>和<code>response</code>对象。</p>
<p><code>request</code>对象封装了HTTP请求，我们调用<code>request</code>对象的属性和方法就可以拿到所有HTTP请求的信息；</p>
<p><code>response</code>对象封装了HTTP响应，我们操作<code>response</code>对象的方法，就可以把HTTP响应返回给浏览器。</p>
<p>用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序<code>hello.js</code>，它对于所有请求，都返回<code>Hello world!</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入http模块:</span></span><br><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">&#x27;node:http&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建http server，并传入回调函数:</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 回调函数接收request和response对象,</span></span><br><span class="line">    <span class="comment">// 获得HTTP请求的method和url:</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">method</span> + <span class="string">&#x27;: &#x27;</span> + request.<span class="property">url</span>);</span><br><span class="line">    <span class="comment">// 将HTTP响应200写入response, 同时设置Content-Type: text/html:</span></span><br><span class="line">    response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span>&#125;);</span><br><span class="line">    <span class="comment">// 将HTTP响应的HTML内容写入response:</span></span><br><span class="line">    response.<span class="title function_">end</span>(<span class="string">&#x27;&lt;h1&gt;Hello world!&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出错时返回400:</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;clientError&#x27;</span>, <span class="function">(<span class="params">err, socket</span>) =&gt;</span> &#123;</span><br><span class="line">  socket.<span class="title function_">end</span>(<span class="string">&#x27;HTTP/1.1 400 Bad Request\r\n\r\n&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让服务器监听8080端口:</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is running at http://127.0.0.1:8080/&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>在命令提示符下运行该程序，可以看到以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node simple-server.mjs </span><br><span class="line">Server is running at http://127.0.0.1:8080/</span><br></pre></td></tr></table></figure>
<p>不要关闭命令提示符，直接打开浏览器输入<code>http://localhost:8080</code>，即可看到服务器响应的内容：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/http/http-page.png" alt="http-page"></p>
<p>同时，在命令提示符窗口，可以看到程序打印的请求信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET: /</span><br><span class="line">GET: /favicon.ico</span><br></pre></td></tr></table></figure>
<p>这就是我们编写的第一个HTTP服务器程序！</p>
<h3 id="文件服务器">文件服务器</h3>
<p>让我们继续扩展一下上面的Web程序。我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析<code>request.url</code>中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。</p>
<p>观察打印的<code>request.url</code>，它实际上是浏览器请求的路径和参数，如：</p>
<ul>
<li><code>/</code></li>
<li><code>/index.html</code></li>
<li><code>/hello?name=bob</code></li>
</ul>
<p>解析出path部分可以直接用URL对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;http://localost&#x27;</span> + <span class="string">&#x27;/index.html?v=1&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> pathname = url.<span class="property">pathname</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pathname); <span class="comment">// index.html</span></span><br></pre></td></tr></table></figure>
<p>处理本地文件目录需要使用Node.js提供的<code>path</code>模块，它可以方便地构造目录：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;node:path&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析当前目录:</span></span><br><span class="line"><span class="keyword">let</span> workDir = path.<span class="title function_">resolve</span>(<span class="string">&#x27;.&#x27;</span>); <span class="comment">// &#x27;/Users/michael&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合完整的文件路径:当前目录+&#x27;pub&#x27;+&#x27;index.html&#x27;:</span></span><br><span class="line"><span class="keyword">let</span> filePath = path.<span class="title function_">join</span>(workDir, <span class="string">&#x27;pub&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>);</span><br><span class="line"><span class="comment">// &#x27;/Users/michael/pub/index.html&#x27;</span></span><br></pre></td></tr></table></figure>
<p>使用<code>path</code>模块可以正确处理操作系统相关的文件路径。在Windows系统下，返回的路径类似于<code>C:\Users\michael\static\index.html</code>，这样，我们就不关心怎么拼接路径了。</p>
<p>最后，我们实现一个文件服务器<code>simple-file-server.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入http模块:</span></span><br><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">&#x27;node:http&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;node:path&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createReadStream &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; stat &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs/promises&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定www根目录为当前目录:</span></span><br><span class="line"><span class="keyword">const</span> wwwRoot = path.<span class="title function_">resolve</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`set www root: <span class="subst">$&#123;wwwRoot&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据扩展名确定MIME类型:</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">guessMime</span>(<span class="params">pathname</span>) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建http file server，并传入回调函数:</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获得HTTP请求的method和url:</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">method</span> + <span class="string">&#x27;: &#x27;</span> + request.<span class="property">url</span>);</span><br><span class="line">    <span class="keyword">if</span> (request.<span class="property">method</span> !== <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">        response.<span class="title function_">writeHead</span>(<span class="number">400</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span> &#125;);</span><br><span class="line">        response.<span class="title function_">end</span>(<span class="string">&#x27;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 解析path: </span></span><br><span class="line">        <span class="keyword">let</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">`http://localhost<span class="subst">$&#123;request.url&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">let</span> pathname = url.<span class="property">pathname</span>;</span><br><span class="line">        <span class="keyword">let</span> filepath = path.<span class="title function_">join</span>(wwwRoot, pathname);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 必要的安全检查</span></span><br><span class="line">        <span class="comment">// 检查文件状态:</span></span><br><span class="line">        <span class="title function_">stat</span>(filepath).<span class="title function_">then</span>(<span class="function"><span class="params">st</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="title function_">isFile</span>()) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;200 OK&#x27;</span>);</span><br><span class="line">                <span class="comment">// 发送200响应:</span></span><br><span class="line">                response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="title function_">guessMime</span>(pathname) &#125;);</span><br><span class="line">                <span class="comment">// 将文件流导向response:</span></span><br><span class="line">                <span class="title function_">createReadStream</span>(filepath).<span class="title function_">pipe</span>(response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;404 Not Found&#x27;</span>);</span><br><span class="line">                response.<span class="title function_">writeHead</span>(<span class="number">404</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span> &#125;);</span><br><span class="line">                response.<span class="title function_">end</span>(<span class="string">&#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;404 Not Found&#x27;</span>);</span><br><span class="line">            response.<span class="title function_">writeHead</span>(<span class="number">404</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span> &#125;);</span><br><span class="line">            response.<span class="title function_">end</span>(<span class="string">&#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出错时返回400:</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;clientError&#x27;</span>, <span class="function">(<span class="params">err, socket</span>) =&gt;</span> &#123;</span><br><span class="line">    socket.<span class="title function_">end</span>(<span class="string">&#x27;HTTP/1.1 400 Bad Request\r\n\r\n&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让服务器监听8080端口:</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is running at http://127.0.0.1:8080/&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>没有必要手动读取文件内容。由于<code>response</code>对象本身是一个<code>Writable Stream</code>，直接用<code>pipe()</code>方法就实现了自动读取文件内容并输出到HTTP响应。</p>
<p>在命令行运行<code>node simple-file-server.mjs</code>，然后在浏览器中输入<code>http://localhost:8080/index.html</code>：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/http/http-index.png" alt="http-index-page"></p>
<p>只要当前目录下存在文件<code>index.html</code>，服务器就可以把文件内容发送给浏览器。观察控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET: /index.html</span><br><span class="line">200 OK</span><br><span class="line">GET: /next/hello.png</span><br><span class="line">200 OK</span><br><span class="line">GET: /favicon.ico</span><br><span class="line">200 OK</span><br></pre></td></tr></table></figure>
<p>第一个请求是浏览器请求<code>/</code>页面，后续请求是浏览器解析HTML后发送的其它资源请求。</p>
<h3 id="练习-3">练习</h3>
<p>在浏览器输入<code>http://localhost:8080/</code>时，会返回404，原因是程序识别出HTTP请求的不是文件，而是目录。请修改<code>simple-file-server.mjs</code>，如果遇到请求的路径是目录，则自动在目录下依次搜索<code>index.html</code>、<code>default.html</code>，如果找到了，就返回HTML文件的内容。</p>
<h3 id="参考源码-6">参考源码</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/http/simple-server.mjs">简单HTTP服务器</a></li>
<li><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/http/simple-file-server.zip">HTTP文件服务器</a></li>
</ul>
<p>crypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。</p>
<h3 id="MD5和SHA1">MD5和SHA1</h3>
<p>MD5是一种常用的哈希算法，用于给任意数据一个“签名”。这个签名通常用一个十六进制的字符串表示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> crypto <span class="keyword">from</span> <span class="string">&#x27;node:crypto&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hash = crypto.<span class="title function_">createHash</span>(<span class="string">&#x27;md5&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可任意多次调用update():</span></span><br><span class="line">hash.<span class="title function_">update</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">hash.<span class="title function_">update</span>(<span class="string">&#x27;Hello, nodejs!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">digest</span>(<span class="string">&#x27;hex&#x27;</span>)); <span class="comment">// 7e1977739c748beac0c0fd14fd26a544</span></span><br></pre></td></tr></table></figure>
<p><code>update()</code>方法默认字符串编码为<code>UTF-8</code>，也可以传入Buffer。</p>
<p>如果要计算SHA1，只需要把<code>'md5'</code>改成<code>'sha1'</code>，就可以得到SHA1的结果。还可以使用更安全的<code>sha256</code>和<code>sha512</code>。</p>
<h3 id="Hmac">Hmac</h3>
<p>Hmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。不同的是，Hmac还需要一个密钥：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> crypto <span class="keyword">from</span> <span class="string">&#x27;node:crypto&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hmac = crypto.<span class="title function_">createHmac</span>(<span class="string">&#x27;sha256&#x27;</span>, <span class="string">&#x27;secret-key&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hmac.<span class="title function_">update</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">hmac.<span class="title function_">update</span>(<span class="string">&#x27;Hello, nodejs!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hmac.<span class="title function_">digest</span>(<span class="string">&#x27;hex&#x27;</span>)); <span class="comment">// 80f7e22570...</span></span><br></pre></td></tr></table></figure>
<p>只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把Hmac理解为用随机数“增强”的哈希算法。</p>
<h3 id="AES">AES</h3>
<p>AES是一种常用的对称加密算法，加解密都用同一个密钥。crypto模块提供了AES支持，但是需要自己封装好函数，便于使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> crypto <span class="keyword">from</span> <span class="string">&#x27;node:crypto&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">aes_encrypt</span>(<span class="params">key, iv, msg</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cipher = crypto.<span class="title function_">createCipheriv</span>(<span class="string">&#x27;aes-256-cbc&#x27;</span>, key, iv);</span><br><span class="line">    <span class="comment">// input encoding: utf8</span></span><br><span class="line">    <span class="comment">// output encoding: hex</span></span><br><span class="line">    <span class="keyword">let</span> encrypted = cipher.<span class="title function_">update</span>(msg, <span class="string">&#x27;utf8&#x27;</span>, <span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">    encrypted += cipher.<span class="title function_">final</span>(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">aes_decrypt</span>(<span class="params">key, iv, encrypted</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> decipher = crypto.<span class="title function_">createDecipheriv</span>(<span class="string">&#x27;aes-256-cbc&#x27;</span>, key, iv);</span><br><span class="line">    <span class="keyword">let</span> decrypted = decipher.<span class="title function_">update</span>(encrypted, <span class="string">&#x27;hex&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">    decrypted += decipher.<span class="title function_">final</span>(<span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> decrypted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key的长度必须为32bytes:</span></span><br><span class="line"><span class="keyword">let</span> key = <span class="string">&#x27;Passw0rdPassw0rdPassw0rdPassw0rd&#x27;</span>;</span><br><span class="line"><span class="comment">// iv的长度必须为16bytes:</span></span><br><span class="line"><span class="keyword">let</span> iv = <span class="string">&#x27;a1b2c3d4e5f6g7h8&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"><span class="comment">// 加密:</span></span><br><span class="line"><span class="keyword">let</span> encrypted_msg = <span class="title function_">aes_encrypt</span>(key, iv, msg);</span><br><span class="line"><span class="comment">// 解密:</span></span><br><span class="line"><span class="keyword">let</span> decrypted_msg = <span class="title function_">aes_decrypt</span>(key, iv, encrypted_msg);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`AES encrypt: <span class="subst">$&#123;encrypted_msg&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`AES decrypt: <span class="subst">$&#123;decrypted_msg&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AES encrypt: 11cd65e5fe7e7448b491efabee2f326a</span><br><span class="line">AES decrypt: Hello, world!</span><br></pre></td></tr></table></figure>
<p>可以看出，加密后的字符串通过解密又得到了原始内容。</p>
<p>注意到AES有很多不同的算法，如<code>aes192</code>，<code>aes-128-ecb</code>，<code>aes-256-cbc</code>等，AES除了密钥外还可以指定IV（Initial Vector），不同的系统只要IV不同，用相同的密钥加密相同的数据得到的加密结果也是不同的。加密结果通常有两种表示方法：hex和base64，这些功能Node.js全部都支持，但是在应用中要注意，如果加解密双方一方用Nodejs，另一方用Java、PHP等其它语言，需要仔细测试。如果无法正确解密，要确认双方是否遵循同样的AES算法，密钥和IV是否相同，加密后的数据是否统一为hex或base64格式。</p>
<h3 id="Diffie-Hellman">Diffie-Hellman</h3>
<p>DH算法是一种密钥交换协议，它可以让双方在不泄漏密钥的情况下协商出一个密钥来。DH算法基于数学原理，比如小明和小红想要协商一个密钥，可以这么做：</p>
<ol>
<li>小明先选一个素数和一个底数，例如，素数<code>p=97</code>，底数<code>g=5</code>（底数是p的一个原根），再选择一个秘密整数<code>a=123</code>，计算<code>A=g^a mod p=34</code>，然后大声告诉小红：<code>p=97，g=5，A=34</code>；</li>
<li>小红收到小明发来的<code>p</code>，<code>g</code>，<code>A</code>后，也选一个秘密整数<code>b=456</code>，然后计算<code>B=g^b mod p=75</code>，并大声告诉小明：<code>B=75</code>；</li>
<li>小明自己计算出<code>s=B^a mod p=22</code>，小红也自己计算出<code>s=A^b mod p=22</code>，因此，最终协商的密钥<code>s</code>为<code>22</code>。</li>
</ol>
<p>在这个过程中，密钥<code>22</code>并不是小明告诉小红的，也不是小红告诉小明的，而是双方协商计算出来的。第三方只能知道<code>p=97</code>，<code>g=5</code>，<code>A=34</code>，<code>B=75</code>，由于不知道双方选的秘密整数<code>a=123</code>和<code>b=456</code>，因此无法计算出密钥<code>22</code>。</p>
<p>用crypto模块实现DH算法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> crypto <span class="keyword">from</span> <span class="string">&#x27;node:crypto&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xiaoming&#x27;s keys:</span></span><br><span class="line"><span class="keyword">let</span> ming = crypto.<span class="title function_">createDiffieHellman</span>(<span class="number">512</span>);</span><br><span class="line"><span class="keyword">let</span> ming_keys = ming.<span class="title function_">generateKeys</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> prime = ming.<span class="title function_">getPrime</span>();</span><br><span class="line"><span class="keyword">let</span> generator = ming.<span class="title function_">getGenerator</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Prime: &#x27;</span> + prime.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Generator: &#x27;</span> + generator.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// xiaohong&#x27;s keys:</span></span><br><span class="line"><span class="keyword">let</span> hong = crypto.<span class="title function_">createDiffieHellman</span>(prime, generator);</span><br><span class="line"><span class="keyword">let</span> hong_keys = hong.<span class="title function_">generateKeys</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// exchange and generate secret:</span></span><br><span class="line"><span class="keyword">let</span> ming_secret = ming.<span class="title function_">computeSecret</span>(hong_keys);</span><br><span class="line"><span class="keyword">let</span> hong_secret = hong.<span class="title function_">computeSecret</span>(ming_keys);</span><br><span class="line"></span><br><span class="line"><span class="comment">// print secret:</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Secret of Xiao Ming: &#x27;</span> + ming_secret.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Secret of Xiao Hong: &#x27;</span> + hong_secret.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>运行后，可以得到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Prime: a8224c...deead3</span><br><span class="line">Generator: 02</span><br><span class="line">Secret of Xiao Ming: 695308...d519be</span><br><span class="line">Secret of Xiao Hong: 695308...d519be</span><br></pre></td></tr></table></figure>
<p>注意每次输出都不一样，因为素数的选择是随机的。</p>
<h3 id="RSA">RSA</h3>
<p>RSA算法是一种非对称加密算法，即由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密。</p>
<p>RSA算法是1977年由Ron Rivest、Adi Shamir和Leonard Adleman共同提出的，所以以他们三人的姓氏的头字母命名。</p>
<p>当小明给小红发送信息时，可以用小明自己的私钥加密，小红用小明的公钥解密，也可以用小红的公钥加密，小红用她自己的私钥解密，这就是非对称加密。相比对称加密，非对称加密只需要每个人各自持有自己的私钥，同时公开自己的公钥，不需要像AES那样由两个人共享同一个密钥。</p>
<p>在使用Node进行RSA加密前，我们先要准备好私钥和公钥。</p>
<p>首先，在命令行执行以下命令以生成一个RSA密钥对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -aes256 -out rsa-key.pem 2048</span><br></pre></td></tr></table></figure>
<p>根据提示输入密码，这个密码是用来加密RSA密钥的，加密方式指定为AES256，生成的RSA的密钥长度是2048位。执行成功后，我们获得了加密的<code>rsa-key.pem</code>文件。</p>
<p>第二步，通过上面的<code>rsa-key.pem</code>加密文件，我们可以导出原始的私钥，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in rsa-key.pem -outform PEM -out rsa-prv.pem</span><br></pre></td></tr></table></figure>
<p>输入第一步的密码，我们获得了解密后的私钥。</p>
<p>类似的，我们用下面的命令导出原始的公钥：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in rsa-key.pem -outform PEM -pubout -out rsa-pub.pem</span><br></pre></td></tr></table></figure>
<p>这样，我们就准备好了原始私钥文件<code>rsa-prv.pem</code>和原始公钥文件<code>rsa-pub.pem</code>，编码格式均为PEM。</p>
<p>下面，使用<code>crypto</code>模块提供的方法，即可实现非对称加解密。</p>
<p>首先，我们用私钥加密，公钥解密：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> crypto <span class="keyword">from</span> <span class="string">&#x27;node:crypto&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件加载key:</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadKey</span>(<span class="params">file</span>) &#123;</span><br><span class="line">    <span class="comment">// key实际上就是PEM编码的字符串:</span></span><br><span class="line">    <span class="keyword">return</span> fs.<span class="title function_">readFileSync</span>(file, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span></span><br><span class="line">    prvKey = <span class="title function_">loadKey</span>(<span class="string">&#x27;./rsa-prv.pem&#x27;</span>),</span><br><span class="line">    pubKey = <span class="title function_">loadKey</span>(<span class="string">&#x27;./rsa-pub.pem&#x27;</span>),</span><br><span class="line">    message = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用私钥加密:</span></span><br><span class="line"><span class="keyword">let</span> enc_by_prv = crypto.<span class="title function_">privateEncrypt</span>(prvKey, <span class="title class_">Buffer</span>.<span class="title function_">from</span>(message, <span class="string">&#x27;utf8&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(enc_by_prv.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dec_by_pub = crypto.<span class="title function_">publicDecrypt</span>(pubKey, enc_by_prv);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dec_by_pub.<span class="title function_">toString</span>(<span class="string">&#x27;utf8&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>执行后，可以得到解密后的消息，与原始消息相同。</p>
<p>接下来我们使用公钥加密，私钥解密：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用公钥加密:</span></span><br><span class="line"><span class="keyword">let</span> enc_by_pub = crypto.<span class="title function_">publicEncrypt</span>(pubKey, <span class="title class_">Buffer</span>.<span class="title function_">from</span>(message, <span class="string">&#x27;utf8&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(enc_by_pub.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用私钥解密:</span></span><br><span class="line"><span class="keyword">let</span> dec_by_prv = crypto.<span class="title function_">privateDecrypt</span>(prvKey, enc_by_pub);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dec_by_prv.<span class="title function_">toString</span>(<span class="string">&#x27;utf8&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>执行得到的解密后的消息仍与原始消息相同。</p>
<p>如果我们把<code>message</code>字符串的长度增加到很长，例如1M，这时，执行RSA加密会得到一个类似这样的错误：<code>data too large for key size</code>，这是因为RSA加密的原始信息必须小于Key的长度。那如何用RSA加密一个很长的消息呢？实际上，RSA并不适合加密大数据，而是先生成一个随机的AES密码，用AES加密原始信息，然后用RSA加密AES口令，这样，实际使用RSA时，给对方传的密文分两部分，一部分是AES加密的密文，另一部分是RSA加密的AES口令。对方用RSA先解密出AES口令，再用AES解密密文，即可获得明文。</p>
<h3 id="证书">证书</h3>
<p>crypto模块也可以处理数字证书。数字证书通常用在SSL连接，也就是Web的https连接。一般情况下，https连接只需要处理服务器端的单向认证，如无特殊需求（例如自己作为Root给客户发认证证书），建议用反向代理服务器如Nginx等Web服务器去处理证书。</p>
<h3 id="参考源码-7">参考源码</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/crypto/crypto.zip">crypto常用算法</a></li>
</ul>
<p>最早的软件都是运行在大型机上的，软件使用者通过“哑终端”登陆到大型机上去运行软件。后来随着PC机的兴起，软件开始主要运行在桌面上，而数据库这样的软件运行在服务器端，这种Client/Server模式简称CS架构。</p>
<p>随着互联网的兴起，人们发现，CS架构不适合Web，最大的原因是Web应用程序的修改和升级非常迅速，而CS架构需要每个客户端逐个升级桌面App，因此，Browser/Server模式开始流行，简称BS架构。</p>
<p>在BS架构下，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web页面，并把Web页面展示给用户即可。</p>
<p>当然，Web页面也具有极强的交互性。由于Web页面是用HTML编写的，而HTML具备超强的表现力，并且，服务器端升级后，客户端无需任何部署就可以使用到新的版本，因此，BS架构迅速流行起来。</p>
<p>今天，除了重量级的软件如Office，Photoshop等，大部分软件都以Web形式提供。比如，新浪提供的新闻、博客、微博等服务，均是Web应用。</p>
<p>Web应用开发可以说是目前软件开发中最重要的部分。Web开发也经历了好几个阶段：</p>
<p>静态Web页面：由文本编辑器直接编辑并生成静态的HTML页面，如果要修改Web页面的内容，就需要再次编辑HTML源文件，早期的互联网Web页面就是静态的；</p>
<p>CGI：由于静态Web页面无法与用户交互，比如用户填写了一个注册表单，静态Web页面就无法处理。要处理用户发送的动态数据，出现了Common Gateway Interface，简称CGI，用C/C++编写。</p>
<p>ASP/JSP/PHP：由于Web应用特点是修改频繁，用C/C++这样的低级语言非常不适合Web开发，而脚本语言由于开发效率高，与HTML结合紧密，因此，迅速取代了CGI模式。ASP是微软推出的用VBScript脚本编程的Web开发技术，而JSP用Java来编写脚本，PHP本身则是开源的脚本语言。</p>
<p>MVC：为了解决直接用脚本语言嵌入HTML导致的可维护性差的问题，Web应用也引入了Model-View-Controller的模式，来简化Web开发。<a target="_blank" rel="noopener" href="http://xn--ASPASP-yy7ir59aujt.Net">ASP发展为ASP.Net</a>，JSP和PHP也有一大堆MVC框架。</p>
<p>目前，Web开发技术仍在快速发展中，异步开发、新的MVVM前端技术层出不穷。</p>
<p>由于Node.js把JavaScript引入了服务器端，因此，原来必须使用PHP/Java/C#/Python/Ruby等其他语言来开发服务器端程序，现在可以使用Node.js开发了！</p>
<p>用Node.js开发Web服务器端，有几个显著的优势：</p>
<p>一是后端语言也是JavaScript，以前掌握了前端JavaScript的开发人员，现在可以同时编写后端代码；</p>
<p>二是前后端统一使用JavaScript，就没有切换语言的障碍了；</p>
<p>三是速度快，非常快！这得益于Node.js天生是异步的。</p>
<p>在Node.js诞生后的短短几年里，出现了无数种Web框架、ORM框架、模版引擎、测试框架、自动化构建工具，数量之多，即使是JavaScript老司机，也不免眼花缭乱。</p>
<p>常见的Web框架包括：<a target="_blank" rel="noopener" href="https://expressjs.com/">Express</a>，<a target="_blank" rel="noopener" href="https://sailsjs.org/">Sails.js</a>，<a target="_blank" rel="noopener" href="https://koajs.com/">koa</a>，<a target="_blank" rel="noopener" href="https://www.meteor.com/">Meteor</a>，<a target="_blank" rel="noopener" href="https://derbyjs.com/">DerbyJS</a>，<a target="_blank" rel="noopener" href="https://www.totaljs.com/">Total.js</a>，<a target="_blank" rel="noopener" href="http://restify.com/">restify</a>……</p>
<p>ORM框架比Web框架要少一些：<a target="_blank" rel="noopener" href="https://www.sequelizejs.com/">Sequelize</a>，<a target="_blank" rel="noopener" href="https://dresende.github.io/node-orm2/">ORM2</a>，<a target="_blank" rel="noopener" href="https://bookshelfjs.org/">Bookshelf.js</a>，<a target="_blank" rel="noopener" href="https://vincit.github.io/objection.js/">Objection.js</a>……</p>
<p>模版引擎PK：<a target="_blank" rel="noopener" href="https://jade-lang.com/">Jade</a>，<a target="_blank" rel="noopener" href="https://ejs.co/">EJS</a>，<a href="httpss://github.com/paularmstrong/swig">Swig</a>，<a target="_blank" rel="noopener" href="https://mozilla.github.io/nunjucks/">Nunjucks</a>，<a target="_blank" rel="noopener" href="https://olado.github.io/doT/">doT.js</a>……</p>
<p>测试框架包括：<a target="_blank" rel="noopener" href="https://mochajs.org/">Mocha</a>，<a target="_blank" rel="noopener" href="https://visionmedia.github.io/expresso/">Expresso</a>，<a target="_blank" rel="noopener" href="https://unitjs.com/">Unit.js</a>，<a target="_blank" rel="noopener" href="https://karma-runner.github.io/">Karma</a>……</p>
<p>构建工具有：<a target="_blank" rel="noopener" href="https://gruntjs.com/">Grunt</a>，<a target="_blank" rel="noopener" href="https://gulpjs.com/">Gulp</a>，<a target="_blank" rel="noopener" href="https://webpack.github.io/">Webpack</a>……</p>
<p>目前，在npm上已发布的开源Node.js模块数量超过了30万个。</p>
<p>有选择恐惧症的朋友，看到这里可以洗洗睡了。</p>
<p>好消息是这个教程已经帮你选好了，你只需要跟着教程一条道走到黑就可以了。</p>
<h2 id="koa">koa</h2>
<p>koa是Express的下一代基于Node.js的web框架，目前有1.x和2.0两个版本。</p>
<h3 id="历史">历史</h3>
<h4 id="Express">Express</h4>
<p>Express是第一代最流行的web框架，它对Node.js的http进行了封装，用起来如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Example app listening on port 3000!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>虽然Express的API很简单，但是它是基于ES5的语法，要实现异步代码，只有一个方法：回调。如果异步嵌套层次过多，代码写起来就非常难看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/test&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(<span class="string">&#x27;/file1&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">send</span>(<span class="string">&#x27;read file1 error&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&#x27;/file2&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">send</span>(<span class="string">&#x27;read file2 error&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="title function_">type</span>(<span class="string">&#x27;text/plain&#x27;</span>);</span><br><span class="line">            res.<span class="title function_">send</span>(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>虽然可以用async这样的库来组织异步代码，但是用回调写异步实在是太痛苦了！</p>
<h4 id="koa-1-x">koa 1.x</h4>
<p>随着新版Node.js开始支持ES6，Express的团队又基于ES6的generator重新编写了下一代web框架koa。和Express相比，koa 1.x使用generator实现异步，代码看起来像同步的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> app = <span class="title function_">koa</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/test&#x27;</span>, <span class="keyword">function</span> *() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">doReadFile1</span>();</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">yield</span> <span class="title function_">doReadFile2</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">body</span> = data;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>用generator实现异步比回调简单了不少，但是generator的本意并不是异步。Promise才是为异步设计的，但是Promise的写法……想想就复杂。为了简化异步代码，JavaScript引入了新的关键字<code>async</code>和<code>await</code>，可以轻松地把一个function变为异步模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> fs.<span class="title function_">read</span>(<span class="string">&#x27;/file1&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是JavaScript标准的异步代码，非常简洁，并且易于使用。</p>
<h4 id="koa-2-x">koa 2.x</h4>
<p>koa团队并没有止步于koa 1.x，他们又开发了koa 2，和koa 1相比，koa 2完全使用Promise并配合<code>async</code>来实现异步。</p>
<p>koa 2.x的代码看上去像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> <span class="title function_">doReadFile</span>();</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/plain&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = data;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="选择哪个版本？">选择哪个版本？</h3>
<p>为了紧跟时代潮流，教程将使用最新的koa 2.x开发！</p>
<hr>
<hr>
<h3 id="创建koa工程">创建koa工程</h3>
<p>首先，我们创建一个目录<code>hello-koa</code>，作为koa工程根目录。</p>
<p>在根目录下执行<code>npm install koa</code>，我们就在当前目录下安装好了koa及其依赖项，执行完成后目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello-koa/</span><br><span class="line">├── node_modules/      &lt;-- koa以及所有依赖项</span><br><span class="line">├── package-lock.json</span><br><span class="line">└── package.json       &lt;-- npm描述文件</span><br></pre></td></tr></table></figure>
<p><code>package.json</code>包含了npm的依赖信息，以及项目描述等信息，<code>package-lock.json</code>是针对当前所有依赖的一个快照，目的是锁定各个依赖项的版本号。</p>
<p>我们打开<code>package.json</code>，内容如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;koa&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.15.3&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>它只有一个koa依赖，是由命令<code>npm install koa</code>写入的。</p>
<p><code>node_modules</code>是所有依赖项安装的地方，可以随时删除<code>node_modules</code>目录，然后用<code>npm install</code>重新安装。</p>
<p>直接运行<code>npm install</code>则根据<code>package.json</code>的<code>dependencies</code>信息下载安装依赖项，运行<code>npm install xyz</code>则将<code>xyz</code>添加到<code>dependencies</code>然后再安装<code>xyz</code>及其依赖项。因此，熟练的开发者可以先自己编辑<code>dependencies</code>内容，然后删除<code>node_modules</code>后重新安装所有依赖项。此外，<code>package.json</code>和<code>package-lock.json</code>应当添加至版本控制系统中，而<code>node_modules</code>则无需添加。</p>
<p>我们手动添加如下信息至<code>package.json</code>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello-koa&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello koa webapp.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;module&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;koa&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.15.3&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>name</code>、<code>version</code>和<code>description</code>均可任意设置，<code>type</code>为<code>module</code>表示以ESM模块执行。</p>
<p>紧接着，我们用VS Code打开<code>hello-koa</code>目录，创建<code>app.mjs</code>文件，输入以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入koa，注意导入的是大写开头的class:</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Koa</span> <span class="keyword">from</span> <span class="string">&#x27;koa&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个koa实例表示webapp本身:</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于任何请求，app将调用该异步函数处理请求：</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    <span class="comment">// 设置响应类型和文本:</span></span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Hello Koa!&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在端口3000监听:</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;app started at port 3000...&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>对于每一个http请求，koa将调用我们传入的异步函数来处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    <span class="comment">// 设置response的Content-Type:</span></span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    <span class="comment">// 设置response的内容:</span></span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Hello Koa!&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，参数<code>ctx</code>是由koa传入的封装了request和response的变量，我们可以通过它访问request和response，<code>next</code>是koa传入的将要处理的下一个异步函数。</p>
<p>上面的异步函数中，我们首先用<code>await next();</code>处理下一个异步函数，然后，设置response的<code>Content-Type</code>和内容。</p>
<p>现在，我们的工程结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello-koa/</span><br><span class="line">├── node_modules/</span><br><span class="line">├── app.mjs</span><br><span class="line">├── package-lock.json</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>
<p>在命令行执行<code>node app.mjs</code>就启动了Web服务器。我们打开浏览器，输入<code>http://localhost:3000</code>，即可看到效果：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/basic/hello-koa.png" alt="koa-browser"></p>
<h3 id="koa-middleware">koa middleware</h3>
<p>让我们再仔细看看koa的执行逻辑。核心代码是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Hello Koa!&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>每收到一个http请求，koa就会调用通过<code>app.use()</code>注册的async函数，并传入<code>ctx</code>和<code>next</code>参数。</p>
<p>我们可以对<code>ctx</code>操作，并设置返回内容。但是为什么要调用<code>await next()</code>？</p>
<p>原因是koa把很多async函数组成一个处理链，每个async函数都可以做一些自己的事情，然后用<code>await next()</code>来调用下一个async函数。我们把每个async函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。</p>
<p>例如，可以用以下3个middleware组成处理链，依次打印日志，记录处理时间，输出HTML：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;ctx.request.method&#125;</span> <span class="subst">$&#123;ctx.request.url&#125;</span>`</span>); <span class="comment">// 打印URL</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>(); <span class="comment">// 调用下一个middleware</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>(); <span class="comment">// 当前时间</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>(); <span class="comment">// 调用下一个middleware</span></span><br><span class="line">    <span class="keyword">const</span> ms = <span class="title class_">Date</span>.<span class="title function_">now</span>() - start; <span class="comment">// 耗费时间</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Time: <span class="subst">$&#123;ms&#125;</span>ms`</span>); <span class="comment">// 打印耗费时间</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Hello Koa!&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>middleware的顺序很重要，也就是调用<code>app.use()</code>的顺序决定了middleware的顺序。</p>
<p>此外，如果一个middleware没有调用<code>await next()</code>，会怎么办？答案是后续的middleware将不再执行了。这种情况也很常见，例如，一个检测用户权限的middleware可以决定是否继续处理请求，还是直接返回403错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">await</span> <span class="title function_">checkUserPermission</span>(ctx)) &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">status</span> = <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>理解了middleware，我们就已经会用koa了！</p>
<p>最后注意<code>ctx</code>对象有一些简写的方法，例如<code>ctx.url</code>相当于<code>ctx.request.url</code>，<code>ctx.type</code>相当于<code>ctx.response.type</code>。</p>
<h3 id="参考源码-8">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/basic/hello-koa.zip">hello-koa</a></p>
<p>在hello-koa工程中，我们处理http请求一律返回相同的HTML，这样虽然非常简单，但是用浏览器一测，随便输入任何URL都会返回相同的网页。</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/url/buduijin.png" alt="buduijin"></p>
<p>正常情况下，我们应该对不同的URL调用不同的处理函数，这样才能返回不同的结果。例如像这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.<span class="property">request</span>.<span class="property">path</span> === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;index page&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.<span class="property">request</span>.<span class="property">path</span> === <span class="string">&#x27;/test&#x27;</span>) &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;TEST page&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.<span class="property">request</span>.<span class="property">path</span> === <span class="string">&#x27;/error&#x27;</span>) &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;ERROR page&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这么写是可以运行的，但是好像有点蠢。</p>
<p>应该有一个能集中处理URL的middleware，它根据不同的URL调用不同的处理函数，这样，我们才能专心为每个URL编写处理函数。</p>
<h3 id="koa-router">@koa/router</h3>
<p>为了处理URL，我们需要引入<code>@koa/router</code>这个middleware，让它负责处理URL映射。</p>
<p>我们把上一节的<code>hello-koa</code>工程复制一份，重命名为<code>url-koa</code>。</p>
<p>先用命令<code>npm install @koa/router</code>安装并在<code>package.json</code>中添加依赖项，接下来，我们修改<code>app.mjs</code>，使用<code>@koa/router</code>来处理URL：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Koa</span> <span class="keyword">from</span> <span class="string">&#x27;koa&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Router</span> <span class="keyword">from</span> <span class="string">&#x27;@koa/router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// log url:</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Process <span class="subst">$&#123;ctx.request.method&#125;</span> <span class="subst">$&#123;ctx.request.url&#125;</span>...`</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析request.body:</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">bodyParser</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置路由: 处理 /</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Index Page&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置路由: 处理 /hello/:name</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/hello/:name&#x27;</span>, <span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取:name参数:</span></span><br><span class="line">    <span class="keyword">let</span> s = ctx.<span class="property">params</span>.<span class="property">name</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">`&lt;h1&gt;Hello, <span class="subst">$&#123;s&#125;</span>&lt;/h1&gt;`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用router:</span></span><br><span class="line">app.<span class="title function_">use</span>(router.<span class="title function_">routes</span>());</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;app started at port 3000...&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>我们使用<code>router.get('/path', async fn)</code>来注册一个GET请求。可以在请求路径中使用带变量的<code>/hello/:name</code>，变量可以通过<code>ctx.params.name</code>访问。</p>
<p>再运行<code>app.mjs</code>，我们就可以测试不同的URL：</p>
<p>输入首页：<a target="_blank" rel="noopener" href="http://localhost:3000/">http://localhost:3000/</a></p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/url/index-page.png" alt="url-index"></p>
<p>输入：<a target="_blank" rel="noopener" href="http://localhost:3000/hello/Bob">http://localhost:3000/hello/Bob</a></p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/url/hello-bob.png" alt="url-hello"></p>
<h3 id="处理post请求">处理post请求</h3>
<p>用<code>router.get('/path', async fn)</code>处理的是get请求。如果要处理post请求，可以用<code>router.post('/path', async fn)</code>。</p>
<p>用post请求处理URL时，我们会遇到一个问题：post请求通常会发送一个表单，或者JSON，它作为request的body发送，但无论是Node.js提供的原始request对象，还是koa提供的request对象，都<em>不提供</em>解析request的body的功能！</p>
<p>所以，我们又需要引入另一个middleware来解析原始request请求，然后，把解析后的参数，绑定到<code>ctx.request.body</code>中。<code>@koa/bodyparser</code>就是用来干这个活的。</p>
<p>我们用命令<code>npm install @koa/bodyparser</code>安装并在<code>package.json</code>中添加依赖项，然后，修改<code>app.mjs</code>，引入<code>@koa/bodyparser</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; bodyParser &#125; <span class="keyword">from</span> <span class="string">&#x27;@koa/bodyparser&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>在合适的位置加上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">bodyParser</span>());</span><br></pre></td></tr></table></figure>
<p>由于middleware的顺序很重要，这个<code>@koa/bodyparser</code>必须在<code>router</code>之前被注册到<code>app</code>对象上。</p>
<p>现在我们就可以处理post请求了。写一个简单的登录表单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;h1&gt;Index Page&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;Name: &lt;input name=&quot;name&quot; value=&quot;koa&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;Password: &lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/signin&#x27;</span>, <span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> name = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">name</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> password = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`try signin: <span class="subst">$&#123;name&#125;</span>, password: <span class="subst">$&#123;password&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">&#x27;koa&#x27;</span> &amp;&amp; password === <span class="string">&#x27;12345&#x27;</span>) &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">`&lt;h1&gt;Welcome, <span class="subst">$&#123;name&#125;</span>!&lt;/h1&gt;`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Signin failed!&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;/&quot;&gt;Retry&lt;/a&gt;&lt;/p&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意到我们用<code>let name = ctx.request.body.name || ''</code>拿到表单的<code>name</code>字段，如果该字段不存在，默认值设置为<code>''</code>。</p>
<p>类似的，put、delete、head请求也可以由router处理。</p>
<h3 id="重构">重构</h3>
<p>现在，我们已经可以处理不同的URL了，但是看看<code>app.mjs</code>，总觉得还是有点不对劲。</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/url/buduijin2.png" alt="still-buduijin"></p>
<p>所有的URL处理函数都放到<code>app.mjs</code>里显得很乱，而且，每加一个URL，就需要修改<code>app.mjs</code>。随着URL越来越多，<code>app.mjs</code>就会越来越长。</p>
<p>如果能把URL处理函数集中到某个js文件，或者某几个js文件中就好了，然后让<code>app.mjs</code>自动导入所有处理URL的函数。这样，代码一分离，逻辑就显得清楚了。最好是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">url2-koa/</span><br><span class="line">├── controller/</span><br><span class="line">│   ├── hello.mjs   &lt;-- 处理/hello/:name</span><br><span class="line">│   └── signin.mjs  &lt;-- 处理/signin</span><br><span class="line">├── app.mjs</span><br><span class="line">├── package-lock.json</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>
<p>于是我们把<code>url-koa</code>复制一份，重命名为<code>url2-koa</code>，准备重构这个项目。</p>
<p>我们先在<code>controller</code>目录下编写<code>signin.mjs</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">index</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;h1&gt;Index Page&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;Name: &lt;input name=&quot;name&quot; value=&quot;koa&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;Password: &lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST /signin</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">signin</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> name = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">name</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> password = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`try signin: <span class="subst">$&#123;name&#125;</span>, password: <span class="subst">$&#123;password&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">&#x27;koa&#x27;</span> &amp;&amp; password === <span class="string">&#x27;12345&#x27;</span>) &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">`&lt;h1&gt;Welcome, <span class="subst">$&#123;name&#125;</span>!&lt;/h1&gt;`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Signin failed!&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;/&quot;&gt;Retry&lt;/a&gt;&lt;/p&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出处理函数:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="string">&#x27;GET /&#x27;</span>: index,</span><br><span class="line">    <span class="string">&#x27;POST /signin&#x27;</span>: signin</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个<code>signin.mjs</code>通过<code>export default</code>把两个URL处理函数暴露出来。</p>
<p>类似的，<code>hello.mjs</code>把一个URL处理函数暴露出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取:name参数:</span></span><br><span class="line">    <span class="keyword">let</span> s = ctx.<span class="property">params</span>.<span class="property">name</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">`&lt;h1&gt;Hello, <span class="subst">$&#123;s&#125;</span>&lt;/h1&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="string">&#x27;GET /hello/:name&#x27;</span>: hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们修改<code>app.mjs</code>，让它自动扫描<code>controller</code>目录，找到所有<code>js</code>文件，导入，然后注册每个URL：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描controller目录:</span></span><br><span class="line"><span class="keyword">const</span> dirname = path.<span class="title function_">dirname</span>(<span class="title function_">fileURLToPath</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`scan dir <span class="subst">$&#123;dirname&#125;</span>...`</span>);</span><br><span class="line"><span class="comment">// 列举 *.mjs 文件:</span></span><br><span class="line"><span class="keyword">let</span> files = <span class="title function_">readdirSync</span>(path.<span class="title function_">join</span>(dirname, <span class="string">&#x27;controller&#x27;</span>)).<span class="title function_">filter</span>(<span class="function"><span class="params">f</span> =&gt;</span> f.<span class="title function_">endsWith</span>(<span class="string">&#x27;.mjs&#x27;</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">    <span class="comment">// 导入模块:</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`import controller/<span class="subst">$&#123;file&#125;</span>...`</span>);</span><br><span class="line">    <span class="keyword">let</span> &#123; <span class="attr">default</span>: mapping &#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">`./controller/<span class="subst">$&#123;file&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// 把每个URL映射添加到router:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> url <span class="keyword">in</span> mapping) &#123;</span><br><span class="line">        <span class="keyword">if</span> (url.<span class="title function_">startsWith</span>(<span class="string">&#x27;GET &#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 类似 &#x27;GET /hello/:name&#x27;</span></span><br><span class="line">            <span class="keyword">let</span> p = url.<span class="title function_">substring</span>(<span class="number">4</span>);</span><br><span class="line">            router.<span class="title function_">get</span>(p, mapping[url]);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`mapping: GET <span class="subst">$&#123;p&#125;</span>`</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.<span class="title function_">startsWith</span>(<span class="string">&#x27;POST &#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 类似 &#x27;POST /signin&#x27;</span></span><br><span class="line">            <span class="keyword">let</span> p = url.<span class="title function_">substring</span>(<span class="number">5</span>);</span><br><span class="line">            router.<span class="title function_">post</span>(p, mapping[url]);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`mapping: POST <span class="subst">$&#123;p&#125;</span>`</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`invalid mapping: <span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Controller-Middleware">Controller Middleware</h3>
<p>最后，我们把扫描<code>controller</code>目录和创建<code>router</code>的代码从<code>app.mjs</code>中提取出来，作为一个简单的middleware使用，命名为<code>controller.mjs</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controller.mjs:</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">scan</span>(<span class="params">router, controllerDir</span>) &#123;</span><br><span class="line">    <span class="comment">// 扫描controller目录:</span></span><br><span class="line">    <span class="keyword">const</span> dirname = path.<span class="title function_">dirname</span>(<span class="title function_">fileURLToPath</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`scan dir <span class="subst">$&#123;dirname&#125;</span>...`</span>);</span><br><span class="line">    <span class="keyword">let</span> files = <span class="title function_">readdirSync</span>(path.<span class="title function_">join</span>(dirname, controllerDir)).<span class="title function_">filter</span>(<span class="function"><span class="params">f</span> =&gt;</span> f.<span class="title function_">endsWith</span>(<span class="string">&#x27;.mjs&#x27;</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">        <span class="comment">// 导入模块:</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`import controller/<span class="subst">$&#123;file&#125;</span>...`</span>);</span><br><span class="line">        <span class="keyword">let</span> &#123; <span class="attr">default</span>: mapping &#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">`./<span class="subst">$&#123;controllerDir&#125;</span>/<span class="subst">$&#123;file&#125;</span>`</span>);</span><br><span class="line">        <span class="comment">// 把每个URL映射添加到router:</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> url <span class="keyword">in</span> mapping) &#123;</span><br><span class="line">            <span class="keyword">if</span> (url.<span class="title function_">startsWith</span>(<span class="string">&#x27;GET &#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">let</span> p = url.<span class="title function_">substring</span>(<span class="number">4</span>);</span><br><span class="line">                router.<span class="title function_">get</span>(p, mapping[url]);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`mapping: GET <span class="subst">$&#123;p&#125;</span>`</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.<span class="title function_">startsWith</span>(<span class="string">&#x27;POST &#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">let</span> p = url.<span class="title function_">substring</span>(<span class="number">5</span>);</span><br><span class="line">                router.<span class="title function_">post</span>(p, mapping[url]);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`mapping: POST <span class="subst">$&#123;p&#125;</span>`</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`invalid mapping: <span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认扫描目录为 controller:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">controllerDir = <span class="string">&#x27;controller&#x27;</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">scan</span>(router, controllerDir);</span><br><span class="line">    <span class="keyword">return</span> router.<span class="title function_">routes</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，我们在<code>app.mjs</code>的代码又简化了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> controller <span class="keyword">from</span> <span class="string">&#x27;./controller.mjs&#x27;</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 使用controller(), 注意controller模块导出的是async函数，要通过await调用:</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">await</span> <span class="title function_">controller</span>());</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>经过重新整理后的工程<code>url2-koa</code>目前具备非常好的模块化，所有处理URL的函数按功能组存放在<code>controller</code>目录，今后我们也只需要不断往这个目录下加东西就可以了，<code>app.mjs</code>保持不变。</p>
<p>最后我们整理一下koa处理一个HTTP请求的流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">           │</span><br><span class="line">           │</span><br><span class="line">           ▼</span><br><span class="line">┌─────────────────────┐</span><br><span class="line">│log:                 │</span><br><span class="line">│async(ctx,next) &#123;...&#125;│</span><br><span class="line">└─────────────────────┘</span><br><span class="line">           │</span><br><span class="line">           ▼</span><br><span class="line">┌─────────────────────┐</span><br><span class="line">│bodyParser()         │</span><br><span class="line">└─────────────────────┘     GET /             ┌─────────────────────┐</span><br><span class="line">           │              ┌──────────────────▶│async(ctx,next) &#123;...&#125;│</span><br><span class="line">           ▼              │                   └─────────────────────┘</span><br><span class="line">┌─────────────────────┐   │ POST /signin      ┌─────────────────────┐</span><br><span class="line">│router.routes()      ├───┼──────────────────▶│async(ctx,next) &#123;...&#125;│</span><br><span class="line">└─────────────────────┘   │                   └─────────────────────┘</span><br><span class="line">                          │ GET /hello/:name  ┌─────────────────────┐</span><br><span class="line">                          └──────────────────▶│async(ctx,next) &#123;...&#125;│</span><br><span class="line">                                              └─────────────────────┘</span><br></pre></td></tr></table></figure>
<p>一个HTTP请求是按顺序由一系列注册到koa的middleware处理的，首先由log函数处理，并通过<code>await next()</code>把请求传递到下一个middleware，紧接着是<code>bodyParser</code>处理，最后是<code>router</code>处理。在router的内部，又会根据注册到router的HTTP方法+Path来决定由哪个async函数处理请求。如果URL没有匹配到，则简单返回404。以上就是整个基于koa的webapp处理流程，非常清晰易懂。</p>
<h3 id="参考源码-9">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/url/url.zip">url</a></p>
<p>Nunjucks是什么东东？其实它是一个模板引擎。</p>
<p>那什么是模板引擎？</p>
<p>模板引擎就是基于模板配合数据构造出字符串输出的一个组件。比如下面的函数就是一个模板引擎：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">examResult</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;data.name&#125;</span>同学一年级期末考试语文<span class="subst">$&#123;data.chinese&#125;</span>分，数学<span class="subst">$&#123;data.math&#125;</span>分，位于年级第<span class="subst">$&#123;data.ranking&#125;</span>名。`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们输入数据如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">examResult</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">chinese</span>: <span class="number">78</span>,</span><br><span class="line">    <span class="attr">math</span>: <span class="number">87</span>,</span><br><span class="line">    <span class="attr">ranking</span>: <span class="number">999</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>该模板引擎把模板字符串里面对应的变量替换以后，就可以得到以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小明同学一年级期末考试语文78分，数学87分，位于年级第999名。</span><br></pre></td></tr></table></figure>
<p>模板引擎最常见的输出就是输出网页，也就是HTML文本。当然，也可以输出任意格式的文本，比如Text，XML，Markdown等等。</p>
<p>有同学要问了：既然JavaScript的模板字符串可以实现模板功能，那为什么我们还需要另外的模板引擎？</p>
<p>因为JavaScript的模板字符串必须写在JavaScript代码中，要想写出新浪首页这样复杂的页面，是非常困难的。</p>
<p>输出HTML有几个特别重要的问题需要考虑：</p>
<h4 id="转义">转义</h4>
<p>对特殊字符要转义，避免受到XSS攻击。比如，如果变量<code>name</code>的值不是<code>小明</code>，而是<code>小明&lt;script&gt;...&lt;/script&gt;</code>，模板引擎输出的HTML到了浏览器，就会自动执行恶意JavaScript代码。</p>
<h4 id="格式化">格式化</h4>
<p>对不同类型的变量要格式化，比如，货币需要变成<code>$12,345.00</code>这样的格式，日期需要变成<code>2016-01-01</code>这样的格式。</p>
<h4 id="简单逻辑">简单逻辑</h4>
<p>模板还需要能执行一些简单逻辑，比如，要按条件输出内容，需要if实现如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; name &#125;&#125;同学，</span><br><span class="line">&#123;% if score &gt;= 90 %&#125;</span><br><span class="line">    成绩优秀，应该奖励</span><br><span class="line">&#123;% elif score &gt;=60 %&#125;</span><br><span class="line">    成绩良好，继续努力</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    不及格，建议回家打屁股</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>所以，我们需要一个功能强大的模板引擎，来完成页面输出的功能。</p>
<h3 id="Nunjucks">Nunjucks</h3>
<p>我们选择Nunjucks作为模板引擎。Nunjucks是Mozilla开发的一个纯JavaScript编写的模板引擎，既可以用在Node环境下，又可以运行在浏览器端。但是，主要还是运行在Node环境下，因为浏览器端有更好的模板解决方案，例如MVVM框架。</p>
<p>如果你使用过Python的模板引擎<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/web/jinja">jinja2</a>，那么使用Nunjucks就非常简单，两者的语法几乎是一模一样的，因为Nunjucks就是用JavaScript重新实现了jinjia2。</p>
<p>从上面的例子我们可以看到，虽然模板引擎内部可能非常复杂，但是使用一个模板引擎是非常简单的，因为本质上我们只需要构造这样一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">view, model</span>) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>view</code>是模板的名称（又称为视图），因为可能存在多个模板，需要选择其中一个。<code>model</code>就是数据，在JavaScript中，它就是一个简单的Object。<code>render</code>函数返回一个字符串，就是模板的输出。</p>
<p>下面我们来使用Nunjucks这个模板引擎来编写几个HTML模板，并且用实际数据来渲染模板并获得最终的HTML输出。</p>
<p>我们创建一个<code>use-nunjucks</code>的VS Code工程结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use-nunjucks/</span><br><span class="line">├── app.mjs</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">└── view</span><br><span class="line">    ├── base.html    &lt;-- HTML模板文件</span><br><span class="line">    ├── extend.html  &lt;-- HTML模板文件</span><br><span class="line">    └── hello.html   &lt;-- HTML模板文件</span><br></pre></td></tr></table></figure>
<p>其中，模板文件存放在<code>view</code>目录中。</p>
<p>我们先用<code>npm install nunjucks</code>安装依赖项并在<code>package.json</code>中添加<code>nunjucks</code>的依赖：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;nunjucks&quot;</span>: <span class="string">&quot;^3.2.4&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，模板引擎是可以独立使用的，并不需要依赖koa。</p>
<p>紧接着，我们要编写使用Nunjucks的函数<code>render</code>。怎么写？方法是查看Nunjucks的<a target="_blank" rel="noopener" href="https://mozilla.github.io/nunjucks/">官方文档</a>，仔细阅读后，在<code>app.js</code>中编写代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nunjucks <span class="keyword">from</span> <span class="string">&#x27;nunjucks&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createEnv</span>(<span class="params">path, &#123; autoescape = <span class="literal">true</span>, noCache = <span class="literal">false</span>, watch = <span class="literal">false</span>, throwOnUndefined = <span class="literal">false</span> &#125;, filters = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> loader = <span class="keyword">new</span> nunjucks.<span class="title class_">FileSystemLoader</span>(path, &#123;</span><br><span class="line">        <span class="attr">noCache</span>: noCache,</span><br><span class="line">        <span class="attr">watch</span>: watch</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> env = <span class="keyword">new</span> nunjucks.<span class="title class_">Environment</span>(loader, &#123;</span><br><span class="line">        <span class="attr">autoescape</span>: autoescape,</span><br><span class="line">        <span class="attr">throwOnUndefined</span>: throwOnUndefined</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> filters) &#123;</span><br><span class="line">        env.<span class="title function_">addFilter</span>(name, filters[name]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> env;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> env = <span class="title function_">createEnv</span>(<span class="string">&#x27;view&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">noCache</span>: <span class="literal">true</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">hex</span>: <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + n.<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>变量<code>env</code>就表示Nunjucks模板引擎对象，它有一个<code>render(view, model)</code>方法，正好传入<code>view</code>和<code>model</code>两个参数，并返回字符串。</p>
<p>创建<code>env</code>需要的参数可以查看文档获知。我们用关键字参数作为默认值，最后使用<code>new nunjucks.FileSystemLoader('view')</code>创建一个文件系统加载器，从<code>view</code>目录读取模板。</p>
<p>我们编写一个<code>hello.html</code>模板文件，放到<code>view</code>目录下，内容如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后，我们就可以用下面的代码来渲染这个模板：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = env.<span class="title function_">render</span>(<span class="string">&#x27;hello.html&#x27;</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br></pre></td></tr></table></figure>
<p>获得输出如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello 小明<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>咋一看，这和使用JavaScript模板字符串没啥区别嘛。不过，试试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = env.<span class="title function_">render</span>(<span class="string">&#x27;hello.html&#x27;</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;&lt;script&gt;alert(&quot;小明&quot;)&lt;/script&gt;&#x27;</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br></pre></td></tr></table></figure>
<p>获得输出如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello <span class="symbol">&amp;lt;</span>script<span class="symbol">&amp;gt;</span>alert(&quot;小明&quot;)<span class="symbol">&amp;lt;</span>/script<span class="symbol">&amp;gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就避免了输出恶意脚本。</p>
<p>此外，可以使用Nunjucks提供的功能强大的tag，编写条件判断、循环等功能，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 循环输出名字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Fruits List<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    &#123;% for f in fruits %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; f &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Nunjucks模板引擎最强大的功能在于模板的继承。仔细观察各种网站可以发现，网站的结构实际上是类似的，头部、尾部都是固定格式，只有中间页面部分内容不同。如果每个模板都重复头尾，一旦要修改头部或尾部，那就需要改动所有模板。</p>
<p>更好的方式是使用继承。先定义一个基本的网页框架<code>base.html</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&#123;% block header %&#125; <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Unnamed<span class="tag">&lt;/<span class="name">h3</span>&gt;</span> &#123;% endblock %&#125;</span><br><span class="line">&#123;% block body %&#125; <span class="tag">&lt;<span class="name">div</span>&gt;</span>No body<span class="tag">&lt;/<span class="name">div</span>&gt;</span> &#123;% endblock %&#125;</span><br><span class="line">&#123;% block footer %&#125; <span class="tag">&lt;<span class="name">div</span>&gt;</span>copyright<span class="tag">&lt;/<span class="name">div</span>&gt;</span> &#123;% endblock %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>base.html</code>定义了三个可编辑的块，分别命名为<code>header</code>、<code>body</code>和<code>footer</code>。子模板可以有选择地对块进行重新定义：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &#x27;base.html&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block header %&#125;<span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; header &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block body %&#125;<span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; body &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们对子模板进行渲染：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(env.<span class="title function_">render</span>(<span class="string">&#x27;extend.html&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">header</span>: <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="string">&#x27;bla bla bla...&#x27;</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>输出HTML如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>bla bla bla...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>copyright<span class="tag">&lt;/<span class="name">div</span>&gt;</span> &lt;-- footer没有重定义，所以仍使用父模板的内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="性能">性能</h3>
<p>最后我们要考虑一下Nunjucks的性能。</p>
<p>对于模板渲染本身来说，速度是非常非常快的，因为就是拼字符串嘛，纯CPU操作。</p>
<p>性能问题主要出现在从文件读取模板内容这一步。这是一个IO操作，在Node.js环境中，我们知道，单线程的JavaScript最不能忍受的就是同步IO，但Nunjucks默认就使用同步IO读取模板文件。</p>
<p>好消息是Nunjucks会缓存已读取的文件内容，也就是说，模板文件最多读取一次，就会放在内存中，后面的请求是不会再次读取文件的，只要我们指定了<code>noCache: false</code>这个参数。</p>
<p>在开发环境下，可以关闭cache，这样每次重新加载模板，便于实时修改模板。在生产环境下，一定要打开cache，这样就不会有性能问题。</p>
<p>Nunjucks也提供了异步读取的方式，但是这样写起来很麻烦，有简单的写法我们就不会考虑复杂的写法。保持代码简单是可维护性的关键。</p>
<h3 id="参考源码-10">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/template/use-nunjucks.zip">use-nunjucks</a></p>
<p>我们已经可以用koa处理不同的URL，还可以用Nunjucks渲染模板。现在，是时候把这两者结合起来了！</p>
<p>当用户通过浏览器请求一个URL时，koa将调用某个异步函数处理该URL。在这个异步函数内部，我们用一行代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">render</span>(<span class="string">&#x27;home.html&#x27;</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;Michael&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>通过Nunjucks把数据用指定的模板渲染成HTML，然后输出给浏览器，用户就可以看到渲染后的页面了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">             ┌─────────────────────────────┐</span><br><span class="line">HTTP Request │GET /Bob                     │</span><br><span class="line">             └─────────────────────────────┘</span><br><span class="line">                            │</span><br><span class="line">                            │ name = Bob</span><br><span class="line">                            ▼</span><br><span class="line">             ┌─────────────────────────────┐</span><br><span class="line">     app.mjs │GET /:name                   │</span><br><span class="line">             │async (ctx, next) &#123;          │</span><br><span class="line">             │    ctx.render(&#x27;home.html&#x27;, &#123;│</span><br><span class="line">             │        name: ctx.params.name│</span><br><span class="line">             │    &#125;);                      │</span><br><span class="line">             │&#125;                            │</span><br><span class="line">             └─────────────────────────────┘</span><br><span class="line">                            │</span><br><span class="line">                            │ &#123;&#123; name &#125;&#125; ─▶ Bob</span><br><span class="line">                            ▼</span><br><span class="line">             ┌─────────────────────────────┐</span><br><span class="line">    Template │&lt;html&gt;                       │</span><br><span class="line">             │&lt;body&gt;                       │</span><br><span class="line">             │    &lt;p&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;/p&gt;│</span><br><span class="line">             │&lt;/body&gt;                      │</span><br><span class="line">             │&lt;/html&gt;                      │</span><br><span class="line">             └─────────────────────────────┘</span><br><span class="line">                            │</span><br><span class="line">                            │ Output</span><br><span class="line">                            ▼</span><br><span class="line">             ┌─────────────────────────────┐</span><br><span class="line">        HTML │&lt;html&gt;                       │</span><br><span class="line">             │&lt;body&gt;                       │</span><br><span class="line">             │    &lt;p&gt;Hello, Bob!&lt;/p&gt;       │</span><br><span class="line">             │&lt;/body&gt;                      │</span><br><span class="line">             │&lt;/html&gt;                      │</span><br><span class="line">             └─────────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>这就是传说中的MVC：Model-View-Controller，中文名“模型-视图-控制器”。</p>
<p>异步函数是C：Controller，Controller负责业务逻辑，比如检查用户名是否存在，取出用户信息等等；</p>
<p>包含变量<code>&#123;&#123; name &#125;&#125;</code>的模板就是V：View，View负责显示逻辑，通过简单地替换一些变量，View最终输出的就是用户看到的HTML。</p>
<p>MVC中的Model在哪？Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。</p>
<p>上面的例子中，Model就是一个JavaScript对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>下面，我们根据原来的<code>url2-koa</code>创建工程<code>view-koa</code>，把koa2、Nunjucks整合起来，然后，把原来直接输出字符串的方式，改为<code>ctx.render(view, model)</code>的方式。</p>
<p>工程<code>koa-mvc</code>结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">koa-mvc/</span><br><span class="line">├── app.mjs</span><br><span class="line">├── controller</span><br><span class="line">│   ├── index.mjs</span><br><span class="line">│   └── signin.mjs</span><br><span class="line">├── controller.mjs</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── static/  &lt;-- 静态资源文件</span><br><span class="line">│   ├── bootstrap.css</span><br><span class="line">│   └── favicon.ico</span><br><span class="line">├── view/  &lt;-- html模板文件</span><br><span class="line">│   ├── base.html</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── signin-failed.html</span><br><span class="line">│   └── signin-ok.html</span><br><span class="line">└── view.mjs</span><br></pre></td></tr></table></figure>
<p>在<code>package.json</code>中，我们将要用到的依赖包有：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;@koa/bodyparser&quot;: &quot;^5.1.1&quot;,</span><br><span class="line">&quot;@koa/router&quot;: &quot;^12.0.1&quot;,</span><br><span class="line">&quot;koa&quot;: &quot;^2.15.3&quot;,</span><br><span class="line">&quot;koa-mount&quot;: &quot;^4.0.0&quot;,</span><br><span class="line">&quot;koa-static&quot;: &quot;^5.0.0&quot;,</span><br><span class="line">&quot;nunjucks&quot;: &quot;^3.2.4&quot;</span><br></pre></td></tr></table></figure>
<p>先用<code>npm install</code>安装依赖包，然后，我们准备编写以下两个Controller：</p>
<h4 id="处理首页-GET">处理首页 GET /</h4>
<p>我们定义一个async函数处理首页URL<code>/</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">index</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    ctx.<span class="title function_">render</span>(<span class="string">&#x27;index.html&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;Welcome&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到koa并没有在<code>ctx</code>对象上提供<code>render</code>方法，这里我们假设应该这么使用，这样，我们在编写Controller的时候，最后一步调用<code>ctx.render(view, model)</code>就完成了页面输出。</p>
<h4 id="处理登录请求-POST-signin">处理登录请求 POST /signin</h4>
<p>我们再定义一个async函数处理登录请求<code>/signin</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">signin</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> email = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">email</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> password = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (email === <span class="string">&#x27;admin@example.com&#x27;</span> &amp;&amp; password === <span class="string">&#x27;123456&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin ok!&#x27;</span>);</span><br><span class="line">        ctx.<span class="title function_">render</span>(<span class="string">&#x27;signin-ok.html&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;Sign In OK&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;Mr Bob&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin failed!&#x27;</span>);</span><br><span class="line">        ctx.<span class="title function_">render</span>(<span class="string">&#x27;signin-failed.html&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;Sign In Failed&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于登录请求是一个POST，我们就用<code>ctx.request.body.&lt;name&gt;</code>拿到POST请求的数据，并给一个默认值。</p>
<p>登录成功时我们用<code>signin-ok.html</code>渲染，登录失败时我们用<code>signin-failed.html</code>渲染，所以，我们一共需要以下3个View：</p>
<ul>
<li>index.html</li>
<li>signin-ok.html</li>
<li>signin-failed.html</li>
</ul>
<h3 id="编写View">编写View</h3>
<p>在编写View的时候，我们实际上是在编写HTML页。为了让页面看起来美观大方，使用一个现成的CSS框架是非常有必要的。我们用<a target="_blank" rel="noopener" href="https://getbootstrap.com/">Bootstrap</a>这个CSS框架。从首页下载zip包后解压，我们把所有静态资源文件放到<code>/static</code>目录下，这样我们在编写HTML的时候，可以直接用Bootstrap的CSS，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;/static/bootstrap.css&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>现在，在使用MVC之前，第一个问题来了，如何处理静态文件？</p>
<p>我们把所有静态资源文件全部放入<code>/static</code>目录，目的就是能统一处理静态文件。在koa中，我们需要编写一个middleware，处理以<code>/static/</code>开头的URL。</p>
<p>如果不想自己编写处理静态文件的middleware，可以直接使用<code>koa-mount</code>和<code>koa-static</code>组合来处理静态文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理静态文件:</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">mount</span>(<span class="string">&#x27;/static&#x27;</span>, <span class="title function_">serve</span>(<span class="string">&#x27;static&#x27;</span>)));</span><br></pre></td></tr></table></figure>
<p>上述代码大致相当于自己手写一个middleware：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 判断是否以指定的url开头:</span></span><br><span class="line">    <span class="keyword">if</span> (ctx.<span class="property">request</span>.<span class="property">path</span>.<span class="title function_">startsWith</span>(<span class="string">&#x27;/static/&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 获取文件完整路径:</span></span><br><span class="line">        <span class="keyword">let</span> fp = ctx.<span class="property">request</span>.<span class="property">path</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">await</span> fs.<span class="title function_">exists</span>(ctx.<span class="property">request</span>.<span class="property">path</span>)) &#123;</span><br><span class="line">            <span class="comment">// 根据扩展名设置mime:</span></span><br><span class="line">            ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="title function_">lookupMime</span>(ctx.<span class="property">request</span>.<span class="property">path</span>);</span><br><span class="line">            <span class="comment">// 读取文件内容并赋值给response.body:</span></span><br><span class="line">            ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="keyword">await</span> fs.<span class="title function_">readFile</span>(fp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 文件不存在:</span></span><br><span class="line">            ctx.<span class="property">response</span>.<span class="property">status</span> = <span class="number">404</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不是指定前缀的URL，继续处理下一个middleware:</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="集成Nunjucks">集成Nunjucks</h3>
<p>集成Nunjucks实际上也是编写一个middleware，这个middleware的作用是给<code>ctx</code>对象绑定一个<code>render(view, model)</code>的方法，这样，后面的Controller就可以调用这个方法来渲染模板了。</p>
<p>我们创建一个<code>view.mjs</code>来实现这个middleware：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nunjucks <span class="keyword">from</span> <span class="string">&#x27;nunjucks&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createEnv</span>(<span class="params">path, &#123; autoescape = <span class="literal">true</span>, noCache = <span class="literal">false</span>, watch = <span class="literal">false</span>, throwOnUndefined = <span class="literal">false</span> &#125;, filters = &#123;&#125;</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> env;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> env = <span class="title function_">createEnv</span>(<span class="string">&#x27;view&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">noCache</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出env对象:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> env;</span><br></pre></td></tr></table></figure>
<p>使用的时候，我们在<code>app.mjs</code>添加如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> templateEngine <span class="keyword">from</span> <span class="string">&#x27;./view.mjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.context是每个请求创建的ctx的原型,</span></span><br><span class="line"><span class="comment">// 因此把render()方法绑定在原型对象上:</span></span><br><span class="line">app.<span class="property">context</span>.<span class="property">render</span> = <span class="keyword">function</span> (<span class="params">view, model</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">response</span>.<span class="property">body</span> = templateEngine.<span class="title function_">render</span>(view, <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, <span class="variable language_">this</span>.<span class="property">state</span> || &#123;&#125;, model || &#123;&#125;));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意到<code>createEnv()</code>函数和前面使用Nunjucks时编写的函数是一模一样的。</p>
<p>这里我们判断当前环境是否是production环境。如果是，就使用缓存，如果不是，就关闭缓存。在开发环境下，关闭缓存后，我们修改View，可以直接刷新浏览器看到效果，否则，每次修改都必须重启Node程序，会极大地降低开发效率。</p>
<p>Node.js在全局变量<code>process</code>中定义了一个环境变量<code>env.NODE_ENV</code>，为什么要使用该环境变量？因为我们在开发的时候，环境变量应该设置为<code>'development'</code>，而部署到服务器时，环境变量应该设置为<code>'production'</code>。在编写代码的时候，要根据当前环境作不同的判断。</p>
<p><em>注意</em>：生产环境上必须配置环境变量<code>NODE_ENV = 'production'</code>，而开发环境不需要配置，实际上<code>NODE_ENV</code>可能是<code>undefined</code>，所以判断的时候，不要用<code>NODE_ENV === 'development'</code>。</p>
<p>类似的，我们在使用上面编写的处理静态文件的middleware时，也可以根据环境变量判断：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isProduction) &#123;</span><br><span class="line">    app.<span class="title function_">use</span>(<span class="title function_">mount</span>(<span class="string">&#x27;/static&#x27;</span>, <span class="title function_">serve</span>(<span class="string">&#x27;static&#x27;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为在生产环境下，静态文件是由部署在最前面的反向代理服务器（如Nginx）处理的，Node程序不需要处理静态文件。而在开发环境下，我们希望koa能顺带处理静态文件，否则，就必须手动配置一个反向代理服务器，这样会导致开发环境非常复杂。</p>
<h3 id="编写View-2">编写View</h3>
<p>在编写View的时候，非常有必要先编写一个<code>base.html</code>作为骨架，其他模板都继承自<code>base.html</code>，这样，才能大大减少重复工作。</p>
<p>编写HTML不在本教程的讨论范围之内。这里我们参考Bootstrap的官网简单编写了<code>base.html</code>。</p>
<h3 id="运行">运行</h3>
<p>一切顺利的话，这个<code>koa-mvc</code>工程应该可以顺利运行。运行前，我们再检查一下<code>app.mjs</code>里的middleware的顺序：</p>
<p>第一个middleware是记录URL以及页面执行时间：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Process <span class="subst">$&#123;ctx.request.method&#125;</span> <span class="subst">$&#123;ctx.request.url&#125;</span>...`</span>);</span><br><span class="line">    <span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    <span class="keyword">const</span> execTime = <span class="title class_">Date</span>.<span class="title function_">now</span>() - start;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="title function_">set</span>(<span class="string">&#x27;X-Response-Time&#x27;</span>, <span class="string">`<span class="subst">$&#123;execTime&#125;</span>ms`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第二个middleware处理静态文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isProduction) &#123;</span><br><span class="line">    app.<span class="title function_">use</span>(<span class="title function_">mount</span>(<span class="string">&#x27;/static&#x27;</span>, <span class="title function_">serve</span>(<span class="string">&#x27;static&#x27;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三个middleware解析POST请求：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">bodyParser</span>());</span><br></pre></td></tr></table></figure>
<p>最后一个middleware处理URL路由：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">await</span> <span class="title function_">controller</span>());</span><br></pre></td></tr></table></figure>
<p>现在，用<code>node app.mjs</code>运行代码，不出意外的话，在浏览器输入<code>localhost:3000/</code>，可以看到首页内容：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/mvc/koa-index.png" alt="koa-index"></p>
<p>直接在首页登录，如果输入正确的Email和Password，进入登录成功的页面：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/mvc/koa-signin-ok.png" alt="koa-signin-ok"></p>
<p>如果输入的Email和Password不正确，进入登录失败的页面：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/mvc/koa-signin-failed.png" alt="koa-signin-failed"></p>
<p>怎么判断正确的Email和Password？目前我们在<code>signin.js</code>中是这么判断的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (email === <span class="string">&#x27;admin@example.com&#x27;</span> &amp;&amp; password === <span class="string">&#x27;123456&#x27;</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，真实的网站会根据用户输入的Email和Password去数据库查询并判断登录是否成功，不过这需要涉及到Node.js环境如何操作数据库，我们后面再讨论。</p>
<p>如果要以<code>production</code>模式启动app，需要设置环境变量，可以通过以下命令启动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ NODE_ENV=production node app.mjs</span><br></pre></td></tr></table></figure>
<p>这样模板缓存将生效，同时不再响应静态文件请求。</p>
<h3 id="扩展">扩展</h3>
<p>注意到<code>ctx.render</code>内部渲染模板时，Model对象并不是传入的model变量，而是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, ctx.<span class="property">state</span> || &#123;&#125;, model || &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>这个小技巧是为了扩展。</p>
<p>首先，<code>model || &#123;&#125;</code>确保了即使传入<code>undefined</code>，model也会变为默认值<code>&#123;&#125;</code>。<code>Object.assign()</code>会把除第一个参数外的其他参数的所有属性复制到第一个参数中。第二个参数是<code>ctx.state || &#123;&#125;</code>，这个目的是为了能把一些公共的变量放入<code>ctx.state</code>并传给View。</p>
<p>例如，某个middleware负责检查用户权限，它可以把当前用户放入<code>ctx.state</code>中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> user = <span class="title function_">tryGetUserFromCookie</span>(ctx.<span class="property">request</span>);</span><br><span class="line">    <span class="keyword">if</span> (user) &#123;</span><br><span class="line">        ctx.<span class="property">state</span>.<span class="property">user</span> = user;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">status</span> = <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样就没有必要在每个Controller的async函数中都把user变量放入model中。</p>
<h3 id="参考源码-11">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/mvc/koa-mvc.zip">koa-mvc</a></p>
<p>自从Roy Fielding博士在2000年他的博士论文中提出<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/REST">REST</a>（Representational State Transfer）风格的软件架构模式后，REST就基本上迅速取代了复杂而笨重的SOAP，成为Web API的标准了。</p>
<p>什么是Web API呢？</p>
<p>如果我们想要获取某个电商网站的某个商品，输入<code>http://localhost:3000/products/123</code>，就可以看到id为123的商品页面，但这个结果是HTML页面，它同时混合包含了Product的数据和Product的展示两个部分。对于用户来说，阅读起来没有问题，但是，如果机器读取，就很难从HTML中解析出Product的数据。</p>
<p>如果一个URL返回的不是HTML，而是机器能直接解析的数据，这个URL就可以看成是一个Web API。比如，读取<code>http://localhost:3000/api/products/123</code>，如果能直接返回Product的数据，那么机器就可以直接读取。</p>
<p>REST就是一种设计API的模式。最常用的数据格式是JSON。由于JSON能直接被JavaScript读取，所以，以JSON格式编写的REST风格的API具有简单、易读、易用的特点。</p>
<p>编写API有什么好处呢？由于API就是把Web App的功能全部封装了，所以，通过API操作数据，可以极大地把前端和后端的代码隔离，使得后端代码易于测试，前端代码编写更简单。</p>
<p>此外，如果我们把前端页面看作是一种用于展示的客户端，那么API就是为客户端提供数据、操作数据的接口。这种设计可以获得极高的扩展性。例如，当用户需要在手机上购买商品时，只需要开发针对iOS和Android的两个客户端，通过客户端访问API，就可以完成通过浏览器页面提供的功能，而后端代码基本无需改动。</p>
<p>当一个Web应用以API的形式对外提供功能时，整个应用的结构就扩展为：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/rest/rest.png" alt="REST-arch"></p>
<p>把网页视为一种客户端，是REST架构可扩展的一个关键。</p>
<h3 id="REST-API规范">REST API规范</h3>
<p>编写REST API，实际上就是编写处理HTTP请求的async函数，不过，REST请求和普通的HTTP请求有几个特殊的地方：</p>
<ol>
<li>REST请求仍然是标准的HTTP请求，但是，除了GET请求外，POST、PUT等请求的body是JSON数据格式，请求的<code>Content-Type</code>为<code>application/json</code>；</li>
<li>REST响应返回的结果是JSON数据格式，因此，响应的<code>Content-Type</code>也是<code>application/json</code>。</li>
</ol>
<p>REST规范定义了资源的通用访问格式，虽然它不是一个强制要求，但遵守该规范可以让人易于理解。</p>
<p>例如，商品Product就是一种资源。获取所有Product的URL如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/products</span><br></pre></td></tr></table></figure>
<p>而获取某个指定的Product，例如，id为<code>123</code>的Product，其URL如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/products/123</span><br></pre></td></tr></table></figure>
<p>新建一个Product使用POST请求，JSON数据包含在body中，URL如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /api/products</span><br></pre></td></tr></table></figure>
<p>更新一个Product使用PUT请求，例如，更新id为<code>123</code>的Product，其URL如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT /api/products/123</span><br></pre></td></tr></table></figure>
<p>删除一个Product使用DELETE请求，例如，删除id为<code>123</code>的Product，其URL如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /api/products/123</span><br></pre></td></tr></table></figure>
<p>资源还可以按层次组织。例如，获取某个Product的所有评论，使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/products/123/reviews</span><br></pre></td></tr></table></figure>
<p>当我们只需要获取部分数据时，可通过参数限制返回的结果集，例如，返回第2页评论，每页10项，按时间排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/products/123/reviews?page=2&amp;size=10&amp;sort=time</span><br></pre></td></tr></table></figure>
<h3 id="koa处理REST">koa处理REST</h3>
<p>既然我们已经使用koa作为Web框架处理HTTP请求，因此，我们仍然可以在koa中响应并处理REST请求。</p>
<p>我们复制上一节的工程，重命名为<code>koa-rest</code>，然后准备添加REST API。</p>
<p>对于controller来说，我们只要返回如下内容即可视为一个REST API：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="property">body</span> =  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">12345</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    <span class="attr">description</span>: <span class="string">&#x27;A rest api&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>koa检测到<code>ctx.body</code>的赋值是一个JavaScript对象时，自动把这个Object变成JSON字符串输出，无需任何额外配置和代码。</p>
<p>提示</p>
<p>ctx.body是ctx.response.body的引用，两者是等同的。</p>
<p>我们给<code>signin.mjs</code>添加两个REST API：</p>
<ul>
<li><code>GET /api/users/:id</code>：根据id获取用户信息；</li>
<li><code>POST /api/signin</code>：发送一个POST请求，并返回登录结果。</li>
</ul>
<p>获取用户信息的async函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /api/users/:id</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">user_info</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> id = ctx.<span class="property">params</span>.<span class="property">id</span>;</span><br><span class="line">    <span class="keyword">if</span> (id === <span class="string">&#x27;12345&#x27;</span>) &#123;</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">12345</span>,</span><br><span class="line">            <span class="attr">email</span>: <span class="string">&#x27;admin@example.com&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">error</span>: <span class="string">&#x27;USER_NOT_FOUND&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理登录请求的async函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">signin</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> email = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">email</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> password = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (email === <span class="string">&#x27;admin@example.com&#x27;</span> &amp;&amp; password === <span class="string">&#x27;123456&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin ok!&#x27;</span>);</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">12345</span>,</span><br><span class="line">            <span class="attr">email</span>: email,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin failed!&#x27;</span>);</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">error</span>: <span class="string">&#x27;SIGNIN_FAILED&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当发生错误时，返回的信息包含<code>error</code>字段，客户端依靠该字段来判断是否出错。</p>
<p>最后导出URL处理函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="string">&#x27;POST /api/signin&#x27;</span>: signin,</span><br><span class="line">    <span class="string">&#x27;GET /api/users/:id&#x27;</span>: user_info</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在，我们可以直接在浏览器测试GET请求：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/rest/rest-get-ok.png" alt="GET OK"></p>
<p>输入无效的ID，返回错误：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/rest/rest-get-error.png" alt="GET ERROR"></p>
<p>对于POST请求，我们无法直接在浏览器测试，可以用<code>curl</code>命令测试如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl -H &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">-d &#x27;&#123;&quot;email&quot;:&quot;admin@example.com&quot;,&quot;password&quot;:&quot;123456&quot;&#125;&#x27; \</span><br><span class="line">http://localhost:3000/api/signin</span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 12345,</span><br><span class="line">  &quot;email&quot;: &quot;admin@example.com&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;Bob&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入错误的口令，返回错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl -H &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">-d &#x27;&#123;&quot;email&quot;:&quot;admin@example.com&quot;,&quot;password&quot;:&quot;invalid&quot;&#125;&#x27; \</span><br><span class="line">http://localhost:3000/api/signin</span><br><span class="line">&#123;</span><br><span class="line">  &quot;error&quot;: &quot;SIGNIN_FAILED&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们把登录从传统的POST表单改成了REST，因此，前端页面需要编写JavaScript代码来发送REST请求，修改HTML如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 给form加上onsubmit回调函数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;signin-form&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return signin()&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>用JavaScript发送REST请求如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">signin</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取表单输入:</span></span><br><span class="line">    <span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#signin-form&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> email = form.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[name=email]&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">let</span> password = form.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[name=password]&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="comment">// REST请求的数据:</span></span><br><span class="line">    <span class="keyword">let</span> data = &#123;</span><br><span class="line">        <span class="attr">email</span>: email,</span><br><span class="line">        <span class="attr">password</span>: password</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 发送请求:</span></span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;/api/signin&#x27;</span>, &#123;</span><br><span class="line">        <span class="comment">// 以POST方式发送:</span></span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        <span class="attr">headers</span>: &#123;</span><br><span class="line">            <span class="comment">// Content-Type设置为JSON:</span></span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 发送数据序列化为JSON:</span></span><br><span class="line">        <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 收到响应后解析JSON数据:</span></span><br><span class="line">        resp.<span class="title function_">json</span>().<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 解析后的数据:</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">            <span class="comment">// 判断是否有error字段:</span></span><br><span class="line">            <span class="keyword">if</span> (result.<span class="property">error</span>) &#123;</span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">`Sign in failed: <span class="subst">$&#123;result.error&#125;</span>`</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 登录成功,取出name字段:</span></span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">`Welcome, <span class="subst">$&#123;result.name&#125;</span>!`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 必须返回false以取消浏览器自动提交表单:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，在koa中处理REST请求是非常简单的。<code>bodyParser()</code>这个middleware可以解析请求的JSON数据并绑定到<code>ctx.request.body</code>上，输出JSON时我们把JavaScript对象赋值给<code>ctx.response.body</code>就完成了REST请求的处理。</p>
<h3 id="参考源码-12">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/rest/koa-rest.zip">koa-rest</a></p>
<p>程序运行的时候，数据都是在内存中的。当程序终止的时候，通常都需要将数据保存到磁盘上，无论是保存到本地磁盘，还是通过网络保存到服务器上，最终都会将数据写入磁盘文件。</p>
<p>而如何定义数据的存储格式就是一个大问题。如果我们自己来定义存储格式，比如保存一个班级所有学生的成绩单：</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>成绩</th>
</tr>
</thead>
<tbody>
<tr>
<td>Michael</td>
<td>99</td>
</tr>
<tr>
<td>Bob</td>
<td>85</td>
</tr>
<tr>
<td>Bart</td>
<td>59</td>
</tr>
<tr>
<td>Lisa</td>
<td>87</td>
</tr>
</tbody>
</table>
<p>我们可以用一个文本文件保存，一行保存一个学生，用<code>,</code>隔开：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Michael,99</span><br><span class="line">Bob,85</span><br><span class="line">Bart,59</span><br><span class="line">Lisa,87</span><br></pre></td></tr></table></figure>
<p>还可以用JSON格式保存，也是文本文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Michael&quot;</span><span class="punctuation">,</span><span class="attr">&quot;score&quot;</span><span class="punctuation">:</span><span class="number">99</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Bob&quot;</span><span class="punctuation">,</span><span class="attr">&quot;score&quot;</span><span class="punctuation">:</span><span class="number">85</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Bart&quot;</span><span class="punctuation">,</span><span class="attr">&quot;score&quot;</span><span class="punctuation">:</span><span class="number">59</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Lisa&quot;</span><span class="punctuation">,</span><span class="attr">&quot;score&quot;</span><span class="punctuation">:</span><span class="number">87</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>还可以定义各种保存格式，但是问题来了：</p>
<p>存储和读取需要自己实现，JSON还是标准，自己定义的格式就各式各样了；</p>
<p>不能做快速查询，只有把数据全部读到内存中才能自己遍历，但有时候数据的大小远远超过了内存，根本无法全部读入内存。</p>
<p>为了便于程序保存和读取数据，而且，能直接通过条件快速查询到指定的数据，就出现了数据库（Database）这种专门用于集中存储和查询的软件。</p>
<p>数据库软件诞生的历史非常久远，早在1950年数据库就诞生了。经历了网状数据库，层次数据库，我们现在广泛使用的关系数据库是20世纪70年代基于关系模型的基础上诞生的。</p>
<p>关系模型有一套复杂的数学理论，但是从概念上是十分容易理解的。举个学校的例子：</p>
<p>假设某个XX省YY市ZZ县第一实验小学有3个年级，要表示出这3个年级，可以在Excel中用一个表格画出来：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/database/table_grade.jpg" alt="grade"></p>
<p>每个年级又有若干个班级，要把所有班级表示出来，可以在Excel中再画一个表格：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/database/table_class.jpg" alt="class"></p>
<p>这两个表格有个映射关系，就是根据Grade_ID可以在班级表中查找到对应的所有班级：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/database/table_relationship.jpg" alt="grade-classes"></p>
<p>也就是Grade表的每一行对应Class表的多行，在关系数据库中，这种基于表（Table）的一对多的关系就是关系数据库的基础。</p>
<p>根据某个年级的ID就可以查找所有班级的行，这种查询语句在关系数据库中称为SQL语句，可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> classes <span class="keyword">WHERE</span> grade_id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果也是一个表：</p>
<table>
<thead>
<tr>
<th>grade_id</th>
<th>class_id</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>11</td>
<td>一年级一班</td>
</tr>
<tr>
<td>1</td>
<td>12</td>
<td>一年级二班</td>
</tr>
<tr>
<td>1</td>
<td>13</td>
<td>一年级三班</td>
</tr>
</tbody>
</table>
<p>类似的，Class表的一行记录又可以关联到Student表的多行记录：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/database/table_relationship2.jpg" alt="class-students"></p>
<p>由于本教程不涉及到关系数据库的详细内容，如果你想从零学习关系数据库和基本的SQL语句，请参考<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/sql/index.html">SQL教程</a>。</p>
<h3 id="NoSQL">NoSQL</h3>
<p>你也许还听说过NoSQL数据库，很多NoSQL宣传其速度和规模远远超过关系数据库，所以很多同学觉得有了NoSQL是否就不需要SQL了呢？千万不要被他们忽悠了，连SQL都不明白怎么可能搞明白NoSQL呢？</p>
<h3 id="数据库类别">数据库类别</h3>
<p>既然我们要使用关系数据库，就必须选择一个关系数据库。目前广泛使用的关系数据库也就这么几种：</p>
<p>付费的商用数据库：</p>
<ul>
<li>Oracle，典型的高富帅；</li>
<li>SQL Server，微软自家产品，Windows定制专款；</li>
<li>DB2，IBM的产品，听起来挺高端；</li>
<li>Sybase，曾经跟微软是好基友，后来关系破裂，现在家境惨淡。</li>
</ul>
<p>这些数据库都是不开源而且付费的，最大的好处是花了钱出了问题可以找厂家解决，不过在Web的世界里，常常需要部署成千上万的数据库服务器，当然不能把大把大把的银子扔给厂家，所以，无论是Google、Facebook，还是国内的BAT，无一例外都选择了免费的开源数据库：</p>
<ul>
<li>MySQL，大家都在用，一般错不了；</li>
<li>PostgreSQL，学术气息有点重，其实挺不错，但知名度没有MySQL高；</li>
<li>SQLite，嵌入式数据库，适合桌面和移动应用。</li>
</ul>
<p>作为一个JavaScript全栈工程师，选择哪个免费数据库呢？这里我们用SQLite，作为嵌入式数据库，优点是不用安装任何软件，直接能用。当然，在生产环境下，应当选择MySQL或者PostgreSQL。</p>
<p>在Node.js中，访问不同的数据库需要安装不同的数据库驱动。</p>
<p>因为我们使用Sqlite，所以需要安装Sqlite的驱动。这里我们选择<code>sqlite3</code>这个驱动，它内置sqlite。</p>
<p><code>sqlite3</code>通过如下代码可以创建一个<code>db</code>对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定模式打开test.db:</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="keyword">new</span> sqlite3.<span class="title class_">Database</span>(<span class="string">&#x27;test.db&#x27;</span>, sqlite3.<span class="property">OPEN_READWRITE</span> | sqlite3.<span class="property">OPEN_CREATE</span> | sqlite3.<span class="property">OPEN_FULLMUTEX</span>);</span><br></pre></td></tr></table></figure>
<p>我们传入了<code>OPEN_CREATE</code>参数，表示如果数据库不存在则自动创建，在开发模式下非常方便。</p>
<p><code>sqlite3</code>使用回调模式执行查询和更新操作，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// query:</span></span><br><span class="line">db.<span class="title function_">all</span>(<span class="string">&#x27;SELECT * FROM users WHERE id=?&#x27;</span>, [<span class="number">1</span>], <span class="keyword">function</span> (<span class="params">err, rows</span>) &#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// update:</span></span><br><span class="line">db.<span class="title function_">run</span>(<span class="string">&#x27;UPDATE users SET name=? WHERE id=?&#x27;</span>, [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">1</span>], <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>回调模式写起来非常别扭，由于<code>sqlite3</code>没有提供Promise接口，因此无法使用await调用，怎么办？</p>
<p>答案是我们自己封装一个Promise调用，以便通过await来实现异步查询和更新：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.mjs:</span></span><br><span class="line"><span class="keyword">import</span> sqlite3 <span class="keyword">from</span> <span class="string">&#x27;sqlite3&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createDatabase</span>(<span class="params">file</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> db = <span class="keyword">new</span> sqlite3.<span class="title class_">Database</span>(file, sqlite3.<span class="property">OPEN_READWRITE</span> | sqlite3.<span class="property">OPEN_CREATE</span> | sqlite3.<span class="property">OPEN_FULLMUTEX</span>);</span><br><span class="line">    <span class="keyword">const</span> wrapper = &#123;</span><br><span class="line">        <span class="attr">db</span>: db</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 执行update:</span></span><br><span class="line">    wrapper.<span class="property">update</span> = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">strs, ...params</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> sql = strs.<span class="title function_">join</span>(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">            db.<span class="title function_">run</span>(sql, ...params, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(err);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">changes</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 执行insert并返回lastID:</span></span><br><span class="line">    wrapper.<span class="property">insert</span> = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">strs, ...params</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> sql = strs.<span class="title function_">join</span>(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">            db.<span class="title function_">run</span>(sql, ...params, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(err);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">lastID</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 查询数据,返回array:</span></span><br><span class="line">    wrapper.<span class="property">select</span> = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">strs, ...params</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> sql = strs.<span class="title function_">join</span>(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`sql = <span class="subst">$&#123;sql&#125;</span>, params = [<span class="subst">$&#123;params.join(<span class="string">&#x27;, &#x27;</span>)&#125;</span>]`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            db.<span class="title function_">all</span>(sql, ...params, <span class="keyword">function</span> (<span class="params">err, rows</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(err);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(rows);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 查询一行数据,不存在返回null:</span></span><br><span class="line">    wrapper.<span class="property">fetch</span> = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">strs, ...params</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们复制前面的<code>koa-mvc</code>工程，命名为<code>sql</code>，准备用实际数据库替换写死的登录逻辑。工程结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sql/</span><br><span class="line">├── app.mjs</span><br><span class="line">├── db.mjs</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure>
<p>通过<code>npm install sqlite3</code>安装依赖项并添加依赖：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;sqlite3&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.1.7&quot;</span></span><br></pre></td></tr></table></figure>
<p>增加了<code>db.mjs</code>，实现了对sqlite数据库的操作。</p>
<p>我们在<code>app.mjs</code>中初始化一个<code>db</code>对象并绑定到<code>app.context</code>中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createDatabase &#125; <span class="keyword">from</span> <span class="string">&#x27;./db.mjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">initDb</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> email = <span class="string">&#x27;admin@example.com&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> password = <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">    <span class="comment">// 创建db对象:</span></span><br><span class="line">    <span class="keyword">const</span> db = <span class="title function_">createDatabase</span>(<span class="string">&#x27;test.db&#x27;</span>);</span><br><span class="line">    <span class="comment">// 如果users表不存在则创建表:</span></span><br><span class="line">    <span class="keyword">await</span> db.<span class="property">update</span><span class="string">`CREATE TABLE IF NOT EXISTS users(id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, email TEXT NOT NULL UNIQUE, name TEXT NOT NULL, password TEXT NOT NULL)`</span>;</span><br><span class="line">    <span class="comment">// 查询admin用户:</span></span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> db.<span class="property">fetch</span><span class="string">`SELECT * FROM users WHERE email=<span class="subst">$&#123;email&#125;</span>`</span>;</span><br><span class="line">    <span class="comment">// 用户不存在则自动创建:</span></span><br><span class="line">    <span class="keyword">if</span> (user === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">await</span> db.<span class="property">insert</span><span class="string">`INSERT INTO users (email, name, password) VALUES (<span class="subst">$&#123;email&#125;</span>, <span class="subst">$&#123;name&#125;</span>, <span class="subst">$&#123;password&#125;</span>)`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> db;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定db到app.context:</span></span><br><span class="line">app.<span class="property">context</span>.<span class="property">db</span> = <span class="keyword">await</span> <span class="title function_">initDb</span>();</span><br></pre></td></tr></table></figure>
<p>注意到<code>initDb()</code>中自动创建表和用户的代码都是为了便于开发。</p>
<p>有了数据库支持，我们就可以把<code>signin.mjs</code>写死的代码替换为查询数据库用户：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// signin:</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">signin</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> email = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">email</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> password = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 从数据库查询用户:</span></span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> ctx.<span class="property">db</span>.<span class="property">fetch</span><span class="string">`SELECT * FROM users WHERE email=<span class="subst">$&#123;email&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">if</span> (user !== <span class="literal">null</span> &amp;&amp; user.<span class="property">password</span> === password) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin ok!&#x27;</span>);</span><br><span class="line">        ctx.<span class="title function_">render</span>(<span class="string">&#x27;signin-ok.html&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;Sign In OK&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: user.<span class="property">name</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin failed!&#x27;</span>);</span><br><span class="line">        ctx.<span class="title function_">render</span>(<span class="string">&#x27;signin-failed.html&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;Sign In Failed&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察上述代码，我们查询数据库中某个用户的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">await</span> ctx.<span class="property">db</span>.<span class="property">fetch</span><span class="string">`SELECT * FROM users WHERE email=<span class="subst">$&#123;email&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
<p>这是一个<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/function/tag-function/index.html">标签函数</a>，它自动将参数变为如下调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">await</span> ctx.<span class="property">db</span>.<span class="title function_">fetch</span>([<span class="string">&#x27;SELECT * FROM users WHERE email=&#x27;</span>, <span class="string">&#x27;&#x27;</span>], email);</span><br></pre></td></tr></table></figure>
<p>在函数内部，实际执行的SQL是<code>SELECT * FROM users WHERE email=?</code>，因此，通过标签函数，我们总是以参数化形式执行SQL，避免了SQL注入。</p>
<p>执行<code>node app.mjs</code>，可以看到页面效果，同时，后台会打印出执行的SQL语句与绑定的参数。</p>
<h3 id="参考">参考</h3>
<p>参考源码：<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/web/database/sql/sql.zip">sql</a></p>
<p>sqlite数据库：<a target="_blank" rel="noopener" href="https://www.sqlite.org/">sqlite</a></p>
<p>sqlite3文档：<a target="_blank" rel="noopener" href="https://github.com/TryGhost/node-sqlite3">sqlite3</a></p>
<p>直接使用<code>sqlite3</code>提供的接口，我们执行数据库操作时必须提供SQL语句，比较底层。</p>
<p>考虑到数据库表是一个二维表，包含多行多列，例如一个<code>users</code>的表：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>email</th>
<th>name</th>
<th>password</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><a href="mailto:admin@example.com">admin@example.com</a></td>
<td>Bob</td>
<td>123456</td>
</tr>
<tr>
<td>2</td>
<td><a href="mailto:lucy@example.com">lucy@example.com</a></td>
<td>Lucy</td>
<td>abcdef</td>
</tr>
<tr>
<td>3</td>
<td><a href="mailto:alice@example.com">alice@example.com</a></td>
<td>Alice</td>
<td>hello123</td>
</tr>
</tbody>
</table>
<p>每一行可以用一个JavaScript对象表示，例如第一行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">email</span>: <span class="string">&#x27;admin@example.com&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是传说中的ORM技术：Object-Relational Mapping，把关系数据库的表结构映射到对象上。是不是很简单？</p>
<p>但是由谁来做这个转换呢？所以ORM框架应运而生。</p>
<p>我们选择Node的ORM框架Sequelize来操作数据库。这样，我们读写的都是JavaScript对象，Sequelize帮我们把对象变成数据库中的行。</p>
<p>用Sequelize查询<code>users</code>表，代码像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> users = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">findAll</span>();</span><br></pre></td></tr></table></figure>
<p>根据<code>email</code>查询一个用户，代码像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">find</span>(&#123;</span><br><span class="line">    <span class="attr">where</span>: &#123;</span><br><span class="line">        <span class="attr">email</span>: <span class="string">&#x27;admin@example.com&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Sequelize的所有操作都是Promise，所以我们可以用await实现异步调用。</p>
<h3 id="实战">实战</h3>
<p>在使用Sequelize操作数据库之前，我们需要告诉Sequelize如何映射数据库中的每一个表。</p>
<p>以<code>users</code>表为例，我们需要定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orm.mjs:</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Sequelize</span>, <span class="title class_">DataTypes</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;sequelize&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建sequelize对象表示已连接到数据库:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sequelize = <span class="keyword">new</span> <span class="title class_">Sequelize</span>(<span class="string">&#x27;sqlite:test.db&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义User:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">User</span> = sequelize.<span class="title function_">define</span>(<span class="string">&#x27;User&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// 每一列的定义:</span></span><br><span class="line">    <span class="attr">id</span>: &#123;</span><br><span class="line">        <span class="attr">primaryKey</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">autoIncrement</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">DataTypes</span>.<span class="property">INTEGER</span>,</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">email</span>: &#123;</span><br><span class="line">        <span class="attr">unique</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">DataTypes</span>.<span class="property">STRING</span>,</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">DataTypes</span>.<span class="property">STRING</span>,</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">password</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">DataTypes</span>.<span class="property">STRING</span>,</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="comment">// 指定表名:</span></span><br><span class="line">    <span class="attr">tableName</span>: <span class="string">&#x27;users&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在定义列的时候，主键以<code>primaryKey: true</code>指定，具有唯一约束的列用<code>unique: true</code>表示，数据类型用<code>DataTypes</code>表示。</p>
<p>这样Sequelize就有了足够的信息来实现ORM。最后将<code>sequelize</code>和<code>User</code>对象导出。</p>
<p>我们根据上一节的<code>sql</code>工程结构创建<code>orm</code>工程，结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sql/</span><br><span class="line">├── app.mjs</span><br><span class="line">├── orm.mjs</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure>
<p>删除了<code>db.mjs</code>，增加<code>orm.mjs</code>。</p>
<p>然后，通过<code>npm install sequelize sqlite3</code>安装依赖项并添加依赖：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;sequelize&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^6.37.3&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sqlite3&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.1.7&quot;</span></span><br></pre></td></tr></table></figure>
<p>在<code>app.mjs</code>中，删除相关SQL操作，改为通过Sequelize初始化数据库：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sequelize, <span class="title class_">User</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./orm.mjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">initDb</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 自动创建数据库表, 仅限开发模式:</span></span><br><span class="line">    <span class="keyword">await</span> sequelize.<span class="title function_">sync</span>();</span><br><span class="line">    <span class="comment">// 查询admin用户:</span></span><br><span class="line">    <span class="keyword">const</span> email = <span class="string">&#x27;admin@example.com&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">findOne</span>(&#123;</span><br><span class="line">        <span class="attr">where</span>: &#123;</span><br><span class="line">            <span class="attr">email</span>: email</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 不存在则自动创建:</span></span><br><span class="line">    <span class="keyword">if</span> (user === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">            <span class="attr">email</span>: email,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">            <span class="attr">password</span>: <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">await</span> <span class="title function_">initDb</span>();</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>使用Sequelize时，无需绑定<code>app.context</code>，因为我们主要通过具体的Model比如<code>User</code>来操作数据库。修改<code>signin.mjs</code>如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">User</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../orm.mjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// signin:</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">signin</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> email = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">email</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> password = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 调用Model.findOne()查询一行记录:</span></span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">findOne</span>(&#123;</span><br><span class="line">        <span class="attr">where</span>: &#123;</span><br><span class="line">            <span class="attr">email</span>: email</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (user !== <span class="literal">null</span> &amp;&amp; user.<span class="property">password</span> === password) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin ok!&#x27;</span>);</span><br><span class="line">        ctx.<span class="title function_">render</span>(<span class="string">&#x27;signin-ok.html&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;Sign In OK&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: user.<span class="property">name</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin failed!&#x27;</span>);</span><br><span class="line">        ctx.<span class="title function_">render</span>(<span class="string">&#x27;signin-failed.html&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;Sign In Failed&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>node app.mjs</code>启动服务器，可以观察到Sequelize访问数据库时打印的SQL语句。这里需要注意的是，Sequelize会为每个Model自动添加一个<code>createdAt</code>和<code>updatedAt</code>字段，用来记录创建和更新时间。因此，创建的<code>users</code>表的SQL语句为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `users` (</span><br><span class="line">    `id` <span class="type">INTEGER</span> <span class="keyword">PRIMARY KEY</span> AUTOINCREMENT,</span><br><span class="line">    `email` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    `name` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `password` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `createdAt` DATETIME <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `updatedAt` DATETIME <span class="keyword">NOT NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="常用操作">常用操作</h3>
<p>Sequelize提供了<code>findAll()</code>和<code>findOne()</code>两种查询，分别返回多行和一行。</p>
<p><code>create()</code>操作可以存储一个对象到数据库的一行记录，<code>save()</code>和<code>destroy()</code>分别对应更新和删除操作。</p>
<p>Sequelize还提供了一对多等高级ORM功能，具体可以参考官方文档。</p>
<h3 id="参考-2">参考</h3>
<p>参考源码：<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/web/database/orm/orm.zip">orm</a></p>
<p>Sequelize：<a target="_blank" rel="noopener" href="https://sequelize.org/">官方网站</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="2025/05/26/JavaScript/JavaScript-Node-js/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="2025/05/26/JavaScript/JavaScript-underscore/"
                            aria-label=": JavaScript-underscore"
                        >
                            JavaScript-underscore
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-26T22:15:06+08:00">
	
		    2025 年 5 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/">JavaScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="underscore">underscore</h2>
<p>前面我们已经讲过了，JavaScript是函数式编程语言，支持高阶函数和闭包。函数式编程非常强大，可以写出非常简洁的代码。例如<code>Array</code>的<code>map()</code>和<code>filter()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>];</span><br><span class="line"><span class="keyword">let</span> a2 = a1.<span class="title function_">map</span>(<span class="title class_">Math</span>.<span class="property">sqrt</span>); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="keyword">let</span> a3 = a2.<span class="title function_">filter</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123; <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span>; &#125;); <span class="comment">// [2, 4]</span></span><br></pre></td></tr></table></figure>
<p>现在问题来了，<code>Array</code>有<code>map()</code>和<code>filter()</code>方法，可是Object没有这些方法。此外，低版本的浏览器例如IE6～8也没有这些方法，怎么办？</p>
<p>方法一，自己把这些方法添加到<code>Array.prototype</code>中，然后给<code>Object.prototype</code>也加上<code>mapObject()</code>等类似的方法。</p>
<p>方法二，直接找一个成熟可靠的第三方开源库，使用统一的函数来实现<code>map()</code>、<code>filter()</code>这些操作。</p>
<p>我们采用方法二，选择的第三方库就是underscore。</p>
<p>正如jQuery统一了不同浏览器之间的DOM操作的差异，让我们可以简单地对DOM进行操作，underscore则提供了一套完善的函数式编程的接口，让我们更方便地在JavaScript中实现函数式编程。</p>
<p>jQuery在加载时，会把自身绑定到唯一的全局变量<code>$</code>上，underscore与其类似，会把自身绑定到唯一的全局变量<code>_</code>上，这也是为啥它的名字叫underscore的原因。</p>
<p>用underscore实现<code>map()</code>操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let r = _.map([1, 2, 3], (x) =&gt; x * x);</span><br><span class="line">console.log(r); // [1, 4, 9]</span><br></pre></td></tr></table></figure>
<p>咋一看比直接用<code>Array.map()</code>要麻烦一点，可是underscore的<code>map()</code>还可以作用于Object：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.<span class="title function_">map</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;, <span class="function">(<span class="params">v, k</span>) =&gt;</span> k + <span class="string">&#x27;=&#x27;</span> + v); <span class="comment">// [&#x27;a=1&#x27;, &#x27;b=2&#x27;, &#x27;c=3&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>后面我们会详细介绍underscore提供了一系列函数式接口。</p>
<hr>
<hr>
<p>underscore为集合类对象提供了一致的接口。集合类是指Array和Object，暂不支持Map和Set。</p>
<h3 id="map-filter">map/filter</h3>
<p>和<code>Array</code>的<code>map()</code>与<code>filter()</code>类似，但是underscore的<code>map()</code>和<code>filter()</code>可以作用于Object。当作用于Object时，传入的函数为<code>function (value, key)</code>，第一个参数接收value，第二个参数接收key：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    name: &#x27;bob&#x27;,</span><br><span class="line">    school: &#x27;No.1 middle school&#x27;,</span><br><span class="line">    address: &#x27;xueyuan road&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let upper = _.map(obj, function (value, key) &#123;</span><br><span class="line">    return ???;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(JSON.stringify(upper));</span><br></pre></td></tr></table></figure>
<p>你也许会想，为啥对Object作<code>map()</code>操作的返回结果是<code>Array</code>？应该是Object才合理啊！把<code>_.map</code>换成<code>_.mapObject</code>再试试。</p>
<h3 id="every-some">every / some</h3>
<p>当集合的所有元素都满足条件时，<code>_.every()</code>函数返回<code>true</code>，当集合的至少一个元素满足条件时，<code>_.some()</code>函数返回<code>true</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有元素都大于0？</span></span><br><span class="line">_.<span class="title function_">every</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, -<span class="number">3</span>, -<span class="number">9</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x &gt; <span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 至少一个元素大于0？</span></span><br><span class="line">_.<span class="title function_">some</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, -<span class="number">3</span>, -<span class="number">9</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x &gt; <span class="number">0</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>当集合是Object时，我们可以同时获得value和key：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    name: &#x27;bob&#x27;,</span><br><span class="line">    school: &#x27;No.1 middle school&#x27;,</span><br><span class="line">    address: &#x27;xueyuan road&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 判断key和value是否全部是小写：</span><br><span class="line">let r1 = _.every(obj, function (value, key) &#123;</span><br><span class="line">    return ???;</span><br><span class="line">&#125;);</span><br><span class="line">let r2 = _.some(obj, function (value, key) &#123;</span><br><span class="line">    return ???;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#x27;every key-value are lowercase: &#x27; + r1 + &#x27;\nsome key-value are lowercase: &#x27; + r2);</span><br></pre></td></tr></table></figure>
<h3 id="max-min">max / min</h3>
<p>这两个函数直接返回集合中最大和最小的数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">_.<span class="title function_">max</span>(arr); <span class="comment">// 9</span></span><br><span class="line">_.<span class="title function_">min</span>(arr); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空集合会返回-Infinity和Infinity，所以要先判断集合不为空：</span></span><br><span class="line">_.<span class="title function_">max</span>([])</span><br><span class="line">-<span class="title class_">Infinity</span></span><br><span class="line">_.<span class="title function_">min</span>([])</span><br><span class="line"><span class="title class_">Infinity</span></span><br></pre></td></tr></table></figure>
<p>注意，如果集合是Object，<code>max()</code>和<code>min()</code>只作用于value，忽略掉key：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.<span class="title function_">max</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h3 id="groupBy">groupBy</h3>
<p><code>groupBy()</code>把集合的元素按照key归类，key由传入的函数返回：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scores = [<span class="number">20</span>, <span class="number">81</span>, <span class="number">75</span>, <span class="number">40</span>, <span class="number">91</span>, <span class="number">59</span>, <span class="number">77</span>, <span class="number">66</span>, <span class="number">72</span>, <span class="number">88</span>, <span class="number">99</span>];</span><br><span class="line"><span class="keyword">let</span> groups = _.<span class="title function_">groupBy</span>(scores, <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">60</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">80</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   A: [81, 91, 88, 99],</span></span><br><span class="line"><span class="comment">//   B: [75, 77, 66, 72],</span></span><br><span class="line"><span class="comment">//   C: [20, 40, 59]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>可见<code>groupBy()</code>用来分组是非常方便的。</p>
<h3 id="shuffle-sample">shuffle / sample</h3>
<p><code>shuffle()</code>用洗牌算法随机打乱一个集合：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意每次结果都不一样：</span></span><br><span class="line">_.<span class="title function_">shuffle</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]); <span class="comment">// [3, 5, 4, 6, 2, 1]</span></span><br></pre></td></tr></table></figure>
<p><code>sample()</code>则是随机选择一个或多个元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意每次结果都不一样：</span></span><br><span class="line"><span class="comment">// 随机选1个：</span></span><br><span class="line">_.<span class="title function_">sample</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 随机选3个：</span></span><br><span class="line">_.<span class="title function_">sample</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">3</span>); <span class="comment">// [6, 1, 4]</span></span><br></pre></td></tr></table></figure>
<p>更多完整的函数请参考underscore的文档：<a target="_blank" rel="noopener" href="https://underscorejs.org/#collections">https://underscorejs.org/#collections</a></p>
<p>underscore为<code>Array</code>提供了许多工具类方法，可以更方便快捷地操作<code>Array</code>。</p>
<h3 id="first-last">first / last</h3>
<p>顾名思义，这两个函数分别取第一个和最后一个元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line">_.<span class="title function_">first</span>(arr); <span class="comment">// 2</span></span><br><span class="line">_.<span class="title function_">last</span>(arr); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<h3 id="flatten">flatten</h3>
<p><code>flatten()</code>接收一个<code>Array</code>，无论这个<code>Array</code>里面嵌套了多少个<code>Array</code>，<code>flatten()</code>最后都把它们变成一个一维数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.<span class="title function_">flatten</span>([<span class="number">1</span>, [<span class="number">2</span>], [<span class="number">3</span>, [[<span class="number">4</span>], [<span class="number">5</span>]]]]); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h3 id="zip-unzip">zip / unzip</h3>
<p><code>zip()</code>把两个或多个数组的所有元素按索引对齐，然后按索引合并成新数组。例如，你有一个<code>Array</code>保存了名字，另一个<code>Array</code>保存了分数，现在，要把名字和分数给对上，用<code>zip()</code>轻松实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">&#x27;Adam&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;Bart&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> scores = [<span class="number">85</span>, <span class="number">92</span>, <span class="number">59</span>];</span><br><span class="line">_.<span class="title function_">zip</span>(names, scores);</span><br><span class="line"><span class="comment">// [[&#x27;Adam&#x27;, 85], [&#x27;Lisa&#x27;, 92], [&#x27;Bart&#x27;, 59]]</span></span><br></pre></td></tr></table></figure>
<p><code>unzip()</code>则是反过来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> namesAndScores = [[<span class="string">&#x27;Adam&#x27;</span>, <span class="number">85</span>], [<span class="string">&#x27;Lisa&#x27;</span>, <span class="number">92</span>], [<span class="string">&#x27;Bart&#x27;</span>, <span class="number">59</span>]];</span><br><span class="line">_.<span class="title function_">unzip</span>(namesAndScores);</span><br><span class="line"><span class="comment">// [[&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;], [85, 92, 59]]</span></span><br></pre></td></tr></table></figure>
<h3 id="object">object</h3>
<p>有时候你会想，与其用<code>zip()</code>，为啥不把名字和分数直接对应成Object呢？别急，<code>object()</code>函数就是干这个的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">&#x27;Adam&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;Bart&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> scores = [<span class="number">85</span>, <span class="number">92</span>, <span class="number">59</span>];</span><br><span class="line">_.<span class="title function_">object</span>(names, scores);</span><br><span class="line"><span class="comment">// &#123;Adam: 85, Lisa: 92, Bart: 59&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意<code>_.object()</code>是一个函数，不是JavaScript的<code>Object</code>对象。</p>
<h3 id="range">range</h3>
<p><code>range()</code>让你快速生成一个序列，不再需要用<code>for</code>循环实现了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从0开始小于10:</span></span><br><span class="line">_.<span class="title function_">range</span>(<span class="number">10</span>); <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从1开始小于11：</span></span><br><span class="line">_.<span class="title function_">range</span>(<span class="number">1</span>, <span class="number">11</span>); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从0开始小于30，步长5:</span></span><br><span class="line">_.<span class="title function_">range</span>(<span class="number">0</span>, <span class="number">30</span>, <span class="number">5</span>); <span class="comment">// [0, 5, 10, 15, 20, 25]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从0开始大于-10，步长-1:</span></span><br><span class="line">_.<span class="title function_">range</span>(<span class="number">0</span>, -<span class="number">10</span>, -<span class="number">1</span>); <span class="comment">// [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]</span></span><br></pre></td></tr></table></figure>
<p>更多完整的函数请参考underscore的文档：<a target="_blank" rel="noopener" href="https://underscorejs.org/#arrays">https://underscorejs.org/#arrays</a></p>
<h3 id="练习">练习</h3>
<p>请根据underscore官方文档，使用<code>_.uniq</code>对数组元素进行<em>不区分大小写</em>去重：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&#x27;Apple&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;ORANGE&#x27;, &#x27;apple&#x27;, &#x27;PEAR&#x27;];</span><br><span class="line">let result = ???</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">if (result.toString() === [&quot;Apple&quot;, &quot;orange&quot;, &quot;banana&quot;, &quot;PEAR&quot;].toString()) &#123;</span><br><span class="line">    console.log(&#x27;测试成功!&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&#x27;测试失败!&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为underscore本来就是为了充分发挥JavaScript的函数式编程特性，所以也提供了大量JavaScript本身没有的高阶函数。</p>
<h3 id="bind">bind</h3>
<p><code>bind()</code>有什么用？我们先看一个常见的错误用法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27; Hello  &#x27;</span>;</span><br><span class="line">s.<span class="title function_">trim</span>();</span><br><span class="line"><span class="comment">// 输出&#x27;Hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = s.<span class="property">trim</span>;</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="comment">// Uncaught TypeError: String.prototype.trim called on null or undefined</span></span><br></pre></td></tr></table></figure>
<p>如果你想用<code>fn()</code>取代<code>s.trim()</code>，按照上面的做法是不行的，因为直接调用<code>fn()</code>传入的<code>this</code>指针是<code>undefined</code>，必须这么用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27; Hello  &#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> fn = s.<span class="property">trim</span>;</span><br><span class="line"><span class="comment">// 调用call并传入s对象作为this:</span></span><br><span class="line">fn.<span class="title function_">call</span>(s)</span><br><span class="line"><span class="comment">// 输出Hello</span></span><br></pre></td></tr></table></figure>
<p>这样搞多麻烦！还不如直接用<code>s.trim()</code>。但是，<code>bind()</code>可以帮我们把<code>s</code>对象直接绑定在<code>fn()</code>的<code>this</code>指针上，以后调用<code>fn()</code>就可以直接正常调用了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27; Hello  &#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> fn = _.<span class="title function_">bind</span>(s.<span class="property">trim</span>, s);</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="comment">// 输出Hello</span></span><br></pre></td></tr></table></figure>
<p>结论：当用一个变量<code>fn</code>指向一个对象的方法时，直接调用<code>fn()</code>是不行的，因为丢失了<code>this</code>对象的引用。用<code>bind</code>可以修复这个问题。</p>
<h3 id="partial">partial</h3>
<p><code>partial()</code>就是为一个函数创建偏函数。偏函数是什么东东？看例子：</p>
<p>假设我们要计算xy，这时只需要调用<code>Math.pow(x, y)</code>就可以了。</p>
<p>假设我们经常计算2y，每次都写<code>Math.pow(2, y)</code>就比较麻烦，如果创建一个新的函数能直接这样写<code>pow2N(y)</code>就好了，这个新函数<code>pow2N(y)</code>就是根据<code>Math.pow(x, y)</code>创建出来的偏函数，它固定住了原函数的第一个参数（始终为2）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pow2N = _.<span class="title function_">partial</span>(<span class="title class_">Math</span>.<span class="property">pow</span>, <span class="number">2</span>);</span><br><span class="line"><span class="title function_">pow2N</span>(<span class="number">3</span>); <span class="comment">// 8</span></span><br><span class="line"><span class="title function_">pow2N</span>(<span class="number">5</span>); <span class="comment">// 32</span></span><br><span class="line"><span class="title function_">pow2N</span>(<span class="number">10</span>); <span class="comment">// 1024</span></span><br></pre></td></tr></table></figure>
<p>如果我们不想固定第一个参数，想固定第二个参数怎么办？比如，希望创建一个偏函数<code>cube(x)</code>，计算x3，可以用<code>_</code>作占位符，固定住第二个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cube = _.<span class="title function_">partial</span>(<span class="title class_">Math</span>.<span class="property">pow</span>, _, <span class="number">3</span>);</span><br><span class="line"><span class="title function_">cube</span>(<span class="number">3</span>); <span class="comment">// 27</span></span><br><span class="line"><span class="title function_">cube</span>(<span class="number">5</span>); <span class="comment">// 125</span></span><br><span class="line"><span class="title function_">cube</span>(<span class="number">10</span>); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>
<p>可见，创建偏函数的目的是将原函数的某些参数固定住，可以降低新函数调用的难度。</p>
<h3 id="memoize">memoize</h3>
<p>如果一个函数调用开销很大，我们就可能希望能把结果缓存下来，以便后续调用时直接获得结果。举个例子，计算阶乘就比较耗时：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start calculate &#x27;</span> + n + <span class="string">&#x27;!...&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> s = <span class="number">1</span>, i = n;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        s = s * i;</span><br><span class="line">        i --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n + <span class="string">&#x27;! = &#x27;</span> + s);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">10</span>); <span class="comment">// 3628800</span></span><br><span class="line"><span class="comment">// 注意控制台输出:</span></span><br><span class="line"><span class="comment">// start calculate 10!...</span></span><br><span class="line"><span class="comment">// 10! = 3628800</span></span><br></pre></td></tr></table></figure>
<p>用<code>memoize()</code>就可以自动缓存函数计算的结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> factorial = _.<span class="title function_">memoize</span>(<span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start calculate &#x27;</span> + n + <span class="string">&#x27;!...&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> s = <span class="number">1</span>, i = n;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        s = s * i;</span><br><span class="line">        i --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n + <span class="string">&#x27;! = &#x27;</span> + s);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次调用:</span></span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">10</span>); <span class="comment">// 3628800</span></span><br><span class="line"><span class="comment">// 注意控制台输出:</span></span><br><span class="line"><span class="comment">// start calculate 10!...</span></span><br><span class="line"><span class="comment">// 10! = 3628800</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次调用:</span></span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">10</span>); <span class="comment">// 3628800</span></span><br><span class="line"><span class="comment">// 控制台没有输出</span></span><br></pre></td></tr></table></figure>
<p>对于相同的调用，比如连续两次调用<code>factorial(10)</code>，第二次调用并没有计算，而是直接返回上次计算后缓存的结果。不过，当你计算<code>factorial(9)</code>的时候，仍然会重新计算。</p>
<p>可以对<code>factorial()</code>进行改进，让其递归调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> factorial = _.<span class="title function_">memoize</span>(<span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start calculate &#x27;</span> + n + <span class="string">&#x27;!...&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="title function_">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">10</span>); <span class="comment">// 3628800</span></span><br><span class="line"><span class="comment">// 输出结果说明factorial(1)~factorial(10)都已经缓存了:</span></span><br><span class="line"><span class="comment">// start calculate 10!...</span></span><br><span class="line"><span class="comment">// start calculate 9!...</span></span><br><span class="line"><span class="comment">// start calculate 8!...</span></span><br><span class="line"><span class="comment">// start calculate 7!...</span></span><br><span class="line"><span class="comment">// start calculate 6!...</span></span><br><span class="line"><span class="comment">// start calculate 5!...</span></span><br><span class="line"><span class="comment">// start calculate 4!...</span></span><br><span class="line"><span class="comment">// start calculate 3!...</span></span><br><span class="line"><span class="comment">// start calculate 2!...</span></span><br><span class="line"><span class="comment">// start calculate 1!...</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">9</span>); <span class="comment">// 362880</span></span><br><span class="line"><span class="comment">// console无输出</span></span><br></pre></td></tr></table></figure>
<h3 id="once">once</h3>
<p>顾名思义，<code>once()</code>保证某个函数执行且仅执行一次。如果你有一个方法叫<code>register()</code>，用户在页面上点两个按钮的任何一个都可以执行的话，就可以用<code>once()</code>保证函数仅调用一次，无论用户点击多少次：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let register = _.once(function () &#123;</span><br><span class="line">    console.log(&#x27;Register ok!&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 测试效果:</span><br><span class="line">register();</span><br><span class="line">register();</span><br><span class="line">register();</span><br></pre></td></tr></table></figure>
<h3 id="delay">delay</h3>
<p><code>delay()</code>可以让一个函数延迟执行，效果和<code>setTimeout()</code>是一样的，但是代码明显简单了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2秒后调用alert():</span></span><br><span class="line">_.<span class="title function_">delay</span>(alert, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
<p>如果要延迟调用的函数有参数，把参数也传进去：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> log = _.<span class="title function_">bind</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="variable language_">console</span>);</span><br><span class="line">_.<span class="title function_">delay</span>(log, <span class="number">2000</span>, <span class="string">&#x27;Hello,&#x27;</span>, <span class="string">&#x27;world!&#x27;</span>);</span><br><span class="line"><span class="comment">// 2秒后打印&#x27;Hello, world!&#x27;:</span></span><br></pre></td></tr></table></figure>
<p>更多完整的函数请参考underscore的文档：<a target="_blank" rel="noopener" href="https://underscorejs.org/#functions">https://underscorejs.org/#functions</a></p>
<p>和<code>Array</code>类似，underscore也提供了大量针对Object的函数。</p>
<h3 id="keys-allKeys">keys / allKeys</h3>
<p><code>keys()</code>可以非常方便地返回一个object自身所有的key，但不包含从原型链继承下来的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xiaoming = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;小明&#x27;</span>, <span class="number">20</span>);</span><br><span class="line">_.<span class="title function_">keys</span>(xiaoming); <span class="comment">// [&#x27;name&#x27;, &#x27;age&#x27;]</span></span><br></pre></td></tr></table></figure>
<p><code>allKeys()</code>除了object自身的key，还包含从原型链继承下来的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">school</span> = <span class="string">&#x27;No.1 Middle School&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> xiaoming = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;小明&#x27;</span>, <span class="number">20</span>);</span><br><span class="line">_.<span class="title function_">allKeys</span>(xiaoming); <span class="comment">// [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;school&#x27;]</span></span><br></pre></td></tr></table></figure>
<h3 id="values">values</h3>
<p>和<code>keys()</code>类似，<code>values()</code>返回object自身但不包含原型链继承的所有值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.<span class="title function_">values</span>(obj); <span class="comment">// [&#x27;小明&#x27;, 20]</span></span><br></pre></td></tr></table></figure>
<p>注意，没有<code>allValues()</code>，原因我也不知道。</p>
<h3 id="mapObject">mapObject</h3>
<p><code>mapObject()</code>就是针对object的map版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="comment">// 注意传入的函数签名，value在前，key在后:</span></span><br><span class="line">_.<span class="title function_">mapObject</span>(obj, <span class="function">(<span class="params">v, k</span>) =&gt;</span> <span class="number">100</span> + v); <span class="comment">// &#123; a: 101, b: 102, c: 103 &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="invert">invert</h3>
<p><code>invert()</code>把object的每个key-value来个交换，key变成value，value变成key：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="title class_">Adam</span>: <span class="number">90</span>,</span><br><span class="line">    <span class="title class_">Lisa</span>: <span class="number">85</span>,</span><br><span class="line">    <span class="title class_">Bart</span>: <span class="number">59</span></span><br><span class="line">&#125;;</span><br><span class="line">_.<span class="title function_">invert</span>(obj); <span class="comment">// &#123; &#x27;59&#x27;: &#x27;Bart&#x27;, &#x27;85&#x27;: &#x27;Lisa&#x27;, &#x27;90&#x27;: &#x27;Adam&#x27; &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="extend-extendOwn">extend / extendOwn</h3>
<p><code>extend()</code>把多个object的key-value合并到第一个object并返回：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;;</span><br><span class="line">_.<span class="title function_">extend</span>(a, &#123;<span class="attr">age</span>: <span class="number">15</span>&#125;, &#123;<span class="attr">age</span>: <span class="number">88</span>, <span class="attr">city</span>: <span class="string">&#x27;Beijing&#x27;</span>&#125;); <span class="comment">// &#123;name: &#x27;Bob&#x27;, age: 88, city: &#x27;Beijing&#x27;&#125;</span></span><br><span class="line"><span class="comment">// 变量a的内容也改变了：</span></span><br><span class="line">a; <span class="comment">// &#123;name: &#x27;Bob&#x27;, age: 88, city: &#x27;Beijing&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意：如果有相同的key，后面的object的value将覆盖前面的object的value。</p>
<p><code>extendOwn()</code>和<code>extend()</code>类似，但获取属性时忽略从原型链继承下来的属性。</p>
<h3 id="clone">clone</h3>
<p>如果我们要复制一个object对象，就可以用<code>clone()</code>方法，它会把原有对象的所有属性都复制到新的对象中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let source = &#123;</span><br><span class="line">    name: &#x27;小明&#x27;,</span><br><span class="line">    age: 20,</span><br><span class="line">    skills: [&#x27;JavaScript&#x27;, &#x27;CSS&#x27;, &#x27;HTML&#x27;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let copied = _.clone(source);</span><br><span class="line">console.log(JSON.stringify(copied, null, &#x27;  &#x27;));</span><br></pre></td></tr></table></figure>
<p>注意，<code>clone()</code>是“浅复制”。所谓“浅复制”就是说，两个对象相同的key所引用的value其实是同一对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source.<span class="property">skills</span> === copied.<span class="property">skills</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>也就是说，修改<code>source.skills</code>会影响<code>copied.skills</code>。</p>
<h3 id="isEqual">isEqual</h3>
<p><code>isEqual()</code>对两个object进行深度比较，如果内容完全相同，则返回<code>true</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="attr">skills</span>: &#123; <span class="title class_">Java</span>: <span class="number">90</span>, <span class="title class_">JavaScript</span>: <span class="number">99</span> &#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="attr">skills</span>: &#123; <span class="title class_">JavaScript</span>: <span class="number">99</span>, <span class="title class_">Java</span>: <span class="number">90</span> &#125;&#125;;</span><br><span class="line"></span><br><span class="line">o1 === o2; <span class="comment">// false</span></span><br><span class="line">_.<span class="title function_">isEqual</span>(o1, o2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>isEqual()</code>其实对<code>Array</code>也可以比较：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = [<span class="string">&#x27;Bob&#x27;</span>, &#123; <span class="attr">skills</span>: [<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>] &#125;];</span><br><span class="line"><span class="keyword">let</span> o2 = [<span class="string">&#x27;Bob&#x27;</span>, &#123; <span class="attr">skills</span>: [<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>] &#125;];</span><br><span class="line"></span><br><span class="line">o1 === o2; <span class="comment">// false</span></span><br><span class="line">_.<span class="title function_">isEqual</span>(o1, o2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>更多完整的函数请参考underscore的文档：<a target="_blank" rel="noopener" href="https://underscorejs.org/#objects">https://underscorejs.org/#objects</a></p>
<h2 id="Chaining">Chaining</h2>
<p>还记得jQuery支持链式调用吗？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;a&#x27;</span>).<span class="title function_">attr</span>(<span class="string">&#x27;target&#x27;</span>, <span class="string">&#x27;_blank&#x27;</span>)</span><br><span class="line">      .<span class="title function_">append</span>(<span class="string">&#x27; &lt;i class=&quot;uk-icon-external-link&quot;&gt;&lt;/i&gt;&#x27;</span>)</span><br><span class="line">      .<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>如果我们有一组操作，用underscore提供的函数，写出来像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.<span class="title function_">filter</span>(_.<span class="title function_">map</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>], <span class="title class_">Math</span>.<span class="property">sqrt</span>), <span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span> === <span class="number">1</span>);</span><br><span class="line"><span class="comment">// [1, 3, 5]</span></span><br></pre></td></tr></table></figure>
<p>能不能写成链式调用？</p>
<p>能！</p>
<p>underscore提供了把对象包装成能进行链式调用的方法，就是<code>chain()</code>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let r = _.chain([1, 4, 9, 16, 25])</span><br><span class="line">         .map(Math.sqrt)</span><br><span class="line">         .filter(x =&gt; x % 2 === 1)</span><br><span class="line">         .value();</span><br><span class="line">console.log(r); // [1, 3, 5]</span><br></pre></td></tr></table></figure>
<p>因为每一步返回的都是包装对象，所以最后一步的结果需要调用<code>value()</code>获得最终结果。</p>
<h3 id="小结">小结</h3>
<p>通过学习underscore，是不是对JavaScript的函数式编程又有了进一步的认识？</p>
<hr>
<hr>

                    
                        


                    
                    
                        <p>
                            <a
                                href="2025/05/26/JavaScript/JavaScript-underscore/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="2025/05/26/JavaScript/JavaScript-jQuery/"
                            aria-label=": JavaScript-jQuery"
                        >
                            JavaScript-jQuery
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-26T21:51:07+08:00">
	
		    2025 年 5 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/">JavaScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="jQuery">jQuery</h2>
<p>你可能听说过jQuery，它名字起得很土，但却是JavaScript世界中使用最广泛的一个库。</p>
<p>江湖传言，全世界大约有80~90%的网站直接或间接地使用了jQuery。鉴于它如此流行，又如此好用，所以每一个入门JavaScript的前端工程师都应该了解和学习它。</p>
<p>jQuery这么流行，肯定是因为它解决了一些很重要的问题。实际上，jQuery能帮我们干这些事情：</p>
<ul>
<li>消除浏览器差异：你不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写AJAX等代码；</li>
<li>简洁的操作DOM的方法：写<code>$('#test')</code>肯定比<code>document.getElementById('test')</code>来得简洁；</li>
<li>轻松实现动画、修改CSS等各种操作。</li>
</ul>
<p>jQuery的理念“Write Less, Do More“，让你写更少的代码，完成更多的工作！</p>
<h3 id="jQuery版本">jQuery版本</h3>
<p>从<a target="_blank" rel="noopener" href="https://jquery.com/download/">jQuery官网</a>可以下载最新版本。jQuery只是一个<code>jquery-xxx.js</code>文件，但你会看到有compressed（已压缩）和uncompressed（未压缩）两种版本，使用时完全一样，但如果你想深入研究jQuery源码，那就用uncompressed版本。</p>
<h3 id="使用jQuery">使用jQuery</h3>
<p>使用jQuery只需要在页面的<code>&lt;head&gt;</code>引入jQuery文件即可：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.7.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>好消息是，当你在学习这个教程时，已经引用了jQuery，所以你可以直接使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;jQuery版本：&#x27; + $.fn.jquery);</span><br></pre></td></tr></table></figure>
<h3 id="符号">$符号</h3>
<p><code>$</code>是著名的jQuery符号。实际上，jQuery把所有功能全部封装在一个全局变量<code>jQuery</code>中，而<code>$</code>也是一个合法的变量名，它是变量<code>jQuery</code>的别名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">jQuery</span>; <span class="comment">// jQuery(selector, context)</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">$</span>; <span class="comment">// jQuery(selector, context)</span></span><br><span class="line">$ === jQuery; <span class="comment">// true</span></span><br><span class="line"><span class="title function_">typeof</span>($); <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>$</code>本质上就是一个函数，但是函数也是对象，于是<code>$</code>除了可以直接调用外，也可以有很多其他属性。</p>
<p><em>注意</em>，你看到的<code>$</code>函数名可能不是<code>jQuery(selector, context)</code>，因为很多JavaScript压缩工具可以对函数名和参数改名，所以压缩过的jQuery源码<code>$</code>函数可能变成<code>a(b,c)</code>。</p>
<p>绝大多数时候，我们都直接用<code>$</code>（因为写起来更简单嘛）。但是，如果<code>$</code>这个变量不幸地被占用了，而且还不能改，那我们就只能让<code>jQuery</code>把<code>$</code>变量交出来，然后就只能使用<code>jQuery</code>这个变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$; <span class="comment">// jQuery(selector, context)</span></span><br><span class="line">jQuery.<span class="title function_">noConflict</span>();</span><br><span class="line">$; <span class="comment">// undefined</span></span><br><span class="line">jQuery; <span class="comment">// jQuery(selector, context)</span></span><br></pre></td></tr></table></figure>
<p>这种黑魔法的原理是jQuery在占用<code>$</code>之前，先在内部保存了原来的<code>$</code>,调用<code>jQuery.noConflict()</code>时会把原来保存的变量还原。</p>
<hr>
<hr>
<p>选择器是jQuery的核心。一个选择器写出来类似<code>$('#dom-id')</code>。</p>
<p>为什么jQuery要发明选择器？回顾一下DOM操作中我们经常使用的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按ID查找：</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;dom-id&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按tag查找：</span></span><br><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找&lt;p class=&quot;red&quot;&gt;：</span></span><br><span class="line"><span class="keyword">let</span> ps = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="comment">// 过滤出class=&quot;red&quot;:</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找&lt;table class=&quot;green&quot;&gt;里面的所有&lt;tr&gt;：</span></span><br><span class="line"><span class="keyword">let</span> table = ...</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;table.<span class="property">children</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 过滤出&lt;tr&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码实在太繁琐了，并且，在层级关系中，例如，查找<code>&lt;table class=&quot;green&quot;&gt;</code>里面的所有<code>&lt;tr&gt;</code>，一层循环实际上是错的，因为<code>&lt;table&gt;</code>的标准写法是：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span>...<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span>...<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>很多时候，需要递归查找所有子节点。</p>
<p>jQuery的选择器就是帮助我们快速定位到一个或多个DOM节点。</p>
<h3 id="按ID查找">按ID查找</h3>
<p>如果某个DOM节点有<code>id</code>属性，利用jQuery查找如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找&lt;div id=&quot;abc&quot;&gt;:</span></span><br><span class="line"><span class="keyword">let</span> div = $(<span class="string">&#x27;#abc&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><em>注意</em>，<code>#abc</code>以<code>#</code>开头。返回的对象是jQuery对象。</p>
<p>什么是jQuery对象？jQuery对象类似数组，它的每个元素都是一个引用了DOM节点的对象。</p>
<p>以上面的查找为例，如果<code>id</code>为<code>abc</code>的<code>&lt;div&gt;</code>存在，返回的jQuery对象如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;abc&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>]</span><br></pre></td></tr></table></figure>
<p>如果<code>id</code>为<code>abc</code>的<code>&lt;div&gt;</code>不存在，返回的jQuery对象如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>总之jQuery的选择器不会返回<code>undefined</code>或者<code>null</code>，这样的好处是你不必在下一行判断<code>if (div === undefined)</code>。</p>
<p>jQuery对象和DOM对象之间可以互相转化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = $(<span class="string">&#x27;#abc&#x27;</span>); <span class="comment">// jQuery对象</span></span><br><span class="line"><span class="keyword">let</span> divDom = div.<span class="title function_">get</span>(<span class="number">0</span>); <span class="comment">// 假设存在div，获取第1个DOM元素</span></span><br><span class="line"><span class="keyword">let</span> another = $(divDom); <span class="comment">// 重新把DOM包装为jQuery对象</span></span><br></pre></td></tr></table></figure>
<p>通常情况下你不需要获取DOM对象，直接使用jQuery对象更加方便。如果你拿到了一个DOM对象，那可以简单地调用<code>$(aDomObject)</code>把它变成jQuery对象，这样就可以方便地使用jQuery的API了。</p>
<h3 id="按tag查找">按tag查找</h3>
<p>按tag查找只需要写上tag名称就可以了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ps = $(<span class="string">&#x27;p&#x27;</span>); <span class="comment">// 返回所有&lt;p&gt;节点</span></span><br><span class="line">ps.<span class="property">length</span>; <span class="comment">// 数一数页面有多少个&lt;p&gt;节点</span></span><br></pre></td></tr></table></figure>
<h3 id="按class查找">按class查找</h3>
<p>按class查找注意在class名称前加一个<code>.</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = $(<span class="string">&#x27;.red&#x27;</span>); <span class="comment">// 所有节点包含`class=&quot;red&quot;`都将返回</span></span><br><span class="line"><span class="comment">// 例如:</span></span><br><span class="line"><span class="comment">// &lt;div class=&quot;red&quot;&gt;...&lt;/div&gt;</span></span><br><span class="line"><span class="comment">// &lt;p class=&quot;green red&quot;&gt;...&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>
<p>通常很多节点有多个class，我们可以查找同时包含<code>red</code>和<code>green</code>的节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = $(<span class="string">&#x27;.red.green&#x27;</span>); <span class="comment">// 注意没有空格！</span></span><br><span class="line"><span class="comment">// 符合条件的节点：</span></span><br><span class="line"><span class="comment">// &lt;div class=&quot;red green&quot;&gt;...&lt;/div&gt;</span></span><br><span class="line"><span class="comment">// &lt;div class=&quot;blue green red&quot;&gt;...&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="按属性查找">按属性查找</h3>
<p>一个DOM节点除了<code>id</code>和<code>class</code>外还可以有很多属性，很多时候按属性查找会非常方便，比如在一个表单中按属性来查找：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> email = $(<span class="string">&#x27;[name=email]&#x27;</span>); <span class="comment">// 找出&lt;??? name=&quot;email&quot;&gt;</span></span><br><span class="line"><span class="keyword">let</span> passwordInput = $(<span class="string">&#x27;[type=password]&#x27;</span>); <span class="comment">// 找出&lt;??? type=&quot;password&quot;&gt;</span></span><br><span class="line"><span class="keyword">let</span> a = $(<span class="string">&#x27;[items=&quot;A B&quot;]&#x27;</span>); <span class="comment">// 找出&lt;??? items=&quot;A B&quot;&gt;</span></span><br></pre></td></tr></table></figure>
<p>当属性的值包含空格等特殊字符时，需要用双引号括起来。</p>
<p>按属性查找还可以使用前缀查找或者后缀查找：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> icons = $(<span class="string">&#x27;[name^=icon]&#x27;</span>); <span class="comment">// 找出所有name属性值以icon开头的DOM</span></span><br><span class="line"><span class="comment">// 例如: name=&quot;icon-1&quot;, name=&quot;icon-2&quot;</span></span><br><span class="line"><span class="keyword">let</span> names = $(<span class="string">&#x27;[name$=with]&#x27;</span>); <span class="comment">// 找出所有name属性值以with结尾的DOM</span></span><br><span class="line"><span class="comment">// 例如: name=&quot;startswith&quot;, name=&quot;endswith&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个方法尤其适合通过class属性查找，且不受class包含多个名称的影响：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> icons = $(<span class="string">&#x27;[class^=&quot;icon-&quot;]&#x27;</span>); <span class="comment">// 找出所有class包含至少一个以`icon-`开头的DOM</span></span><br><span class="line"><span class="comment">// 例如: class=&quot;icon-clock&quot;, class=&quot;abc icon-home&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="组合查找">组合查找</h3>
<p>组合查找就是把上述简单选择器组合起来使用。如果我们查找<code>$('[name=email]')</code>，很可能把表单外的<code>&lt;div name=&quot;email&quot;&gt;</code>也找出来，但我们只希望查找<code>&lt;input&gt;</code>，就可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emailInput = $(<span class="string">&#x27;input[name=email]&#x27;</span>); <span class="comment">// 不会找出&lt;div name=&quot;email&quot;&gt;</span></span><br></pre></td></tr></table></figure>
<p>同样的，根据tag和class来组合查找也很常见：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tr = $(<span class="string">&#x27;tr.red&#x27;</span>); <span class="comment">// 找出&lt;tr class=&quot;red ...&quot;&gt;...&lt;/tr&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="多项选择器">多项选择器</h3>
<p>多项选择器就是把多个选择器用<code>,</code>组合起来一块选：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;p,div&#x27;</span>); <span class="comment">// 把&lt;p&gt;和&lt;div&gt;都选出来</span></span><br><span class="line">$(<span class="string">&#x27;p.red,p.green&#x27;</span>); <span class="comment">// 把&lt;p class=&quot;red&quot;&gt;和&lt;p class=&quot;green&quot;&gt;都选出来</span></span><br></pre></td></tr></table></figure>
<p>要注意的是，选出来的元素是按照它们在HTML中出现的顺序排列的，而且不会有重复元素。例如，<code>&lt;p class=&quot;red green&quot;&gt;</code>不会被上面的<code>$('p.red,p.green')</code>选择两次。</p>
<h3 id="练习">练习</h3>
<p>使用jQuery选择器分别选出指定元素：</p>
<ul>
<li>仅选择JavaScript</li>
<li>仅选择Erlang</li>
<li>选择JavaScript和Erlang</li>
<li>选择所有编程语言</li>
<li>选择名字input</li>
<li>选择邮件和名字input</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test-jquery&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;para-1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;color-red&quot;</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;para-2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;color-green&quot;</span>&gt;</span>Haskell<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;color-red color-green&quot;</span>&gt;</span>Erlang<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">class</span>=<span class="string">&quot;color-black&quot;</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;test-form&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">action</span>=<span class="string">&quot;#0&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return false;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">legend</span>&gt;</span>注册新用户<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>名字: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>邮件: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>口令: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>JavaScript</p>
<p>Haskell</p>
<p>Erlang</p>
<p>Python</p>
<p>运行查看结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let selected = null;</span><br><span class="line"></span><br><span class="line">selected = ???;</span><br><span class="line"></span><br><span class="line">// 高亮结果:</span><br><span class="line">if (!(selected instanceof jQuery)) &#123;</span><br><span class="line">    return console.log(&#x27;不是有效的jQuery对象!&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">$(&#x27;#test-jquery&#x27;).find(&#x27;*&#x27;).css(&#x27;background-color&#x27;, &#x27;&#x27;);</span><br><span class="line">selected.css(&#x27;background-color&#x27;, &#x27;#ff8000&#x27;);</span><br></pre></td></tr></table></figure>
<p>除了基本的选择器外，jQuery的层级选择器更加灵活，也更强大。</p>
<p>因为DOM的结构就是层级结构，所以我们经常要根据层级关系进行选择。</p>
<h3 id="层级选择器（Descendant-Selector）">层级选择器（Descendant Selector）</h3>
<p>如果两个DOM元素具有层级关系，就可以用<code>$('ancestor descendant')</code>来选择，层级之间用空格隔开。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;testing&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;lang&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;lang-javascript&quot;</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;lang-python&quot;</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;lang-lua&quot;</span>&gt;</span>Lua<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要选出JavaScript，可以用层级选择器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;ul.lang li.lang-javascript&#x27;</span>); <span class="comment">// [&lt;li class=&quot;lang-javascript&quot;&gt;JavaScript&lt;/li&gt;]</span></span><br><span class="line">$(<span class="string">&#x27;div.testing li.lang-javascript&#x27;</span>); <span class="comment">// [&lt;li class=&quot;lang-javascript&quot;&gt;JavaScript&lt;/li&gt;]</span></span><br></pre></td></tr></table></figure>
<p>因为<code>&lt;div&gt;</code>和<code>&lt;ul&gt;</code>都是<code>&lt;li&gt;</code>的祖先节点，所以上面两种方式都可以选出相应的<code>&lt;li&gt;</code>节点。</p>
<p>要选择所有的<code>&lt;li&gt;</code>节点，用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;ul.lang li&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>这种层级选择器相比单个的选择器好处在于，它缩小了选择范围，因为首先要定位父节点，才能选择相应的子节点，这样避免了页面其他不相关的元素。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;form[name=upload] input&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>就把选择范围限定在<code>name</code>属性为<code>upload</code>的表单里。如果页面有很多表单，其他表单的<code>&lt;input&gt;</code>不会被选择。</p>
<p>多层选择也是允许的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;form.test p input&#x27;</span>); <span class="comment">// 在form表单选择被&lt;p&gt;包含的&lt;input&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="子选择器（Child-Selector）">子选择器（Child Selector）</h3>
<p>子选择器<code>$('parent&gt;child')</code>类似层级选择器，但是限定了层级关系必须是父子关系，就是<code>&lt;child&gt;</code>节点必须是<code>&lt;parent&gt;</code>节点的直属子节点。还是以上面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;ul.lang&gt;li.lang-javascript&#x27;</span>); <span class="comment">// 可以选出[&lt;li class=&quot;lang-javascript&quot;&gt;JavaScript&lt;/li&gt;]</span></span><br><span class="line">$(<span class="string">&#x27;div.testing&gt;li.lang-javascript&#x27;</span>); <span class="comment">// [], 无法选出，因为&lt;div&gt;和&lt;li&gt;不构成父子关系</span></span><br></pre></td></tr></table></figure>
<h3 id="过滤器（Filter）">过滤器（Filter）</h3>
<p>过滤器一般不单独使用，它通常附加在选择器上，帮助我们更精确地定位元素。观察过滤器的效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;ul.lang li&#x27;</span>); <span class="comment">// 选出JavaScript、Python和Lua 3个节点</span></span><br><span class="line">$(<span class="string">&#x27;ul.lang li:first-child&#x27;</span>); <span class="comment">// 仅选出JavaScript</span></span><br><span class="line">$(<span class="string">&#x27;ul.lang li:last-child&#x27;</span>); <span class="comment">// 仅选出Lua</span></span><br><span class="line">$(<span class="string">&#x27;ul.lang li:nth-child(2)&#x27;</span>); <span class="comment">// 选出第N个元素，N从1开始</span></span><br><span class="line">$(<span class="string">&#x27;ul.lang li:nth-child(even)&#x27;</span>); <span class="comment">// 选出序号为偶数的元素</span></span><br><span class="line">$(<span class="string">&#x27;ul.lang li:nth-child(odd)&#x27;</span>); <span class="comment">// 选出序号为奇数的元素</span></span><br></pre></td></tr></table></figure>
<h3 id="表单相关">表单相关</h3>
<p>针对表单元素，jQuery还有一组特殊的选择器：</p>
<ul>
<li><code>:input</code>：可以选择<code>&lt;input&gt;</code>，<code>&lt;textarea&gt;</code>，<code>&lt;select&gt;</code>和<code>&lt;button&gt;</code>；</li>
<li><code>:file</code>：可以选择<code>&lt;input type=&quot;file&quot;&gt;</code>，和<code>input[type=file]</code>一样；</li>
<li><code>:checkbox</code>：可以选择复选框，和<code>input[type=checkbox]</code>一样；</li>
<li><code>:radio</code>：可以选择单选框，和<code>input[type=radio]</code>一样；</li>
<li><code>:focus</code>：可以选择当前输入焦点的元素，例如把光标放到一个<code>&lt;input&gt;</code>上，用<code>$('input:focus')</code>就可以选出；</li>
<li><code>:checked</code>：选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如<code>$('input[type=radio]:checked')</code>；</li>
<li><code>:enabled</code>：可以选择可以正常输入的<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code> 等，也就是没有灰掉的输入；</li>
<li><code>:disabled</code>：和<code>:enabled</code>正好相反，选择那些不能输入的。</li>
</ul>
<p>此外，jQuery还有很多有用的选择器，例如，选出可见的或隐藏的元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;div:visible&#x27;</span>); <span class="comment">// 所有可见的div</span></span><br><span class="line">$(<span class="string">&#x27;div:hidden&#x27;</span>); <span class="comment">// 所有隐藏的div</span></span><br></pre></td></tr></table></figure>
<h3 id="练习-2">练习</h3>
<p>针对如下HTML结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test-selector&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;test-lang&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;lang-javascript&quot;</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;lang-python&quot;</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;lang-lua&quot;</span>&gt;</span>Lua<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">&quot;test-lang&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;lang-swift&quot;</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;lang-java&quot;</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;lang-c&quot;</span>&gt;</span>C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>JavaScript</li>
<li>Python</li>
<li>Lua</li>
</ul>
<ol>
<li>Swift</li>
<li>Java</li>
<li>C</li>
</ol>
<p>选出相应的内容并观察效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 分别选择所有语言，所有动态语言，所有静态语言，JavaScript，Lua，C等:</span><br><span class="line">let selected = ???</span><br><span class="line"></span><br><span class="line">// 高亮结果:</span><br><span class="line">if (!(selected instanceof jQuery)) &#123;</span><br><span class="line">    return console.log(&#x27;不是有效的jQuery对象!&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">$(&#x27;#test-jquery&#x27;).find(&#x27;*&#x27;).css(&#x27;background-color&#x27;, &#x27;&#x27;);</span><br><span class="line">selected.css(&#x27;background-color&#x27;, &#x27;#ff8000&#x27;);</span><br></pre></td></tr></table></figure>
<p>通常情况下选择器可以直接定位到我们想要的元素，但是，当我们拿到一个jQuery对象后，还可以以这个对象为基准，进行查找和过滤。</p>
<p>最常见的查找是在某个节点的所有子节点中查找，使用<code>find()</code>方法，它本身又接收一个任意的选择器。例如如下的HTML结构：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- HTML结构 --&gt;</span><br><span class="line">&lt;ul class=&quot;lang&quot;&gt;</span><br><span class="line">    &lt;li class=&quot;js dy&quot;&gt;JavaScript&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;dy&quot;&gt;Python&lt;/li&gt;</span><br><span class="line">    &lt;li id=&quot;swift&quot;&gt;Swift&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;dy&quot;&gt;Scheme&lt;/li&gt;</span><br><span class="line">    &lt;li name=&quot;haskell&quot;&gt;Haskell&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>JavaScript</li>
<li>Python</li>
<li>Swift</li>
<li>Scheme</li>
<li>Haskell</li>
</ul>
<p>用<code>find()</code>查找：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ul = $(<span class="string">&#x27;ul.lang&#x27;</span>); <span class="comment">// 获得&lt;ul&gt;</span></span><br><span class="line"><span class="keyword">let</span> dy = ul.<span class="title function_">find</span>(<span class="string">&#x27;.dy&#x27;</span>); <span class="comment">// 获得JavaScript, Python, Scheme</span></span><br><span class="line"><span class="keyword">let</span> swf = ul.<span class="title function_">find</span>(<span class="string">&#x27;#swift&#x27;</span>); <span class="comment">// 获得Swift</span></span><br><span class="line"><span class="keyword">let</span> hsk = ul.<span class="title function_">find</span>(<span class="string">&#x27;[name=haskell]&#x27;</span>); <span class="comment">// 获得Haskell</span></span><br></pre></td></tr></table></figure>
<p>如果要从当前节点开始向上查找，使用<code>parent()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> swf = $(<span class="string">&#x27;#swift&#x27;</span>); <span class="comment">// 获得Swift</span></span><br><span class="line"><span class="keyword">let</span> parent = swf.<span class="title function_">parent</span>(); <span class="comment">// 获得Swift的上层节点&lt;ul&gt;</span></span><br><span class="line"><span class="keyword">let</span> a = swf.<span class="title function_">parent</span>(<span class="string">&#x27;.red&#x27;</span>); <span class="comment">// 获得Swift的上层节点&lt;ul&gt;，同时传入过滤条件。如果ul不符合条件，返回空jQuery对象</span></span><br></pre></td></tr></table></figure>
<p>对于位于同一层级的节点，可以通过<code>next()</code>和<code>prev()</code>方法，例如：</p>
<p>当我们已经拿到<code>Swift</code>节点后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> swift = $(<span class="string">&#x27;#swift&#x27;</span>);</span><br><span class="line"></span><br><span class="line">swift.<span class="title function_">next</span>(); <span class="comment">// Scheme</span></span><br><span class="line">swift.<span class="title function_">next</span>(<span class="string">&#x27;[name=haskell]&#x27;</span>); <span class="comment">// 空的jQuery对象，因为Swift的下一个元素Scheme不符合条件[name=haskell]</span></span><br><span class="line"></span><br><span class="line">swift.<span class="title function_">prev</span>(); <span class="comment">// Python</span></span><br><span class="line">swift.<span class="title function_">prev</span>(<span class="string">&#x27;.dy&#x27;</span>); <span class="comment">// Python，因为Python同时符合过滤器条件.dy</span></span><br></pre></td></tr></table></figure>
<h3 id="过滤">过滤</h3>
<p>和函数式编程的map、filter类似，jQuery对象也有类似的方法。</p>
<p><code>filter()</code>方法可以过滤掉不符合选择器条件的节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> langs = $(<span class="string">&#x27;ul.lang li&#x27;</span>); <span class="comment">// 拿到JavaScript, Python, Swift, Scheme和Haskell</span></span><br><span class="line"><span class="keyword">let</span> a = langs.<span class="title function_">filter</span>(<span class="string">&#x27;.dy&#x27;</span>); <span class="comment">// 拿到JavaScript, Python, Scheme</span></span><br></pre></td></tr></table></figure>
<p>或者传入一个函数，要特别注意函数内部的<code>this</code>被绑定为DOM对象，不是jQuery对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> langs = $(<span class="string">&#x27;ul.lang li&#x27;</span>); <span class="comment">// 拿到JavaScript, Python, Swift, Scheme和Haskell</span></span><br><span class="line">langs.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">innerHTML</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;S&#x27;</span>) === <span class="number">0</span>; <span class="comment">// 返回S开头的节点</span></span><br><span class="line">&#125;); <span class="comment">// 拿到Swift, Scheme</span></span><br></pre></td></tr></table></figure>
<p><code>map()</code>方法把一个jQuery对象包含的若干DOM节点转化为其他对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> langs = $(<span class="string">&#x27;ul.lang li&#x27;</span>); <span class="comment">// 拿到JavaScript, Python, Swift, Scheme和Haskell</span></span><br><span class="line"><span class="keyword">let</span> arr = langs.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">innerHTML</span>;</span><br><span class="line">&#125;).<span class="title function_">get</span>(); <span class="comment">// 用get()拿到包含string的Array：[&#x27;JavaScript&#x27;, &#x27;Python&#x27;, &#x27;Swift&#x27;, &#x27;Scheme&#x27;, &#x27;Haskell&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>此外，一个jQuery对象如果包含了不止一个DOM节点，<code>first()</code>、<code>last()</code>和<code>slice()</code>方法可以返回一个新的jQuery对象，把不需要的DOM节点去掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> langs = $(<span class="string">&#x27;ul.lang li&#x27;</span>); <span class="comment">// 拿到JavaScript, Python, Swift, Scheme和Haskell</span></span><br><span class="line"><span class="keyword">let</span> js = langs.<span class="title function_">first</span>(); <span class="comment">// JavaScript，相当于$(&#x27;ul.lang li:first-child&#x27;)</span></span><br><span class="line"><span class="keyword">let</span> haskell = langs.<span class="title function_">last</span>(); <span class="comment">// Haskell, 相当于$(&#x27;ul.lang li:last-child&#x27;)</span></span><br><span class="line"><span class="keyword">let</span> sub = langs.<span class="title function_">slice</span>(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">// Swift, Scheme, 参数和数组的slice()方法一致</span></span><br></pre></td></tr></table></figure>
<h3 id="练习-3">练习</h3>
<p>对于下面的表单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;test-form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;#0&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return false;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Email: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Gender: <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;m&quot;</span> <span class="attr">checked</span>&gt;</span> Male<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;f&quot;</span>&gt;</span> Female<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>City: <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;city&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;BJ&quot;</span> <span class="attr">selected</span>&gt;</span>Beijing<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;SH&quot;</span>&gt;</span>Shanghai<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;CD&quot;</span>&gt;</span>Chengdu<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;XM&quot;</span>&gt;</span>Xiamen<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>输入值后，用jQuery获取表单的JSON字符串，key和value分别对应每个输入的name和相应的value，例如：<code>&#123;&quot;name&quot;:&quot;Michael&quot;,&quot;email&quot;:...&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let json = ???;</span><br><span class="line"></span><br><span class="line">// 显示结果:</span><br><span class="line">if (typeof(json) === &#x27;string&#x27;) &#123;</span><br><span class="line">    console.log(json);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    console.log(&#x27;json变量不是string!&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>jQuery的选择器很强大，用起来又简单又灵活，但是搞了这么久，我拿到了jQuery对象，到底要干什么？</p>
<p>答案当然是操作对应的DOM节点啦！</p>
<p>回顾一下修改DOM的CSS、文本、设置HTML有多么麻烦，而且有的浏览器只有innerHTML，有的浏览器支持innerText，有了jQuery对象，不需要考虑浏览器差异了，全部统一操作！</p>
<h3 id="修改Text和HTML">修改Text和HTML</h3>
<p>jQuery对象的<code>text()</code>和<code>html()</code>方法分别获取节点的文本和原始HTML文本，例如，如下的HTML结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;test-ul&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;js&quot;</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">name</span>=<span class="string">&quot;book&quot;</span>&gt;</span>Java <span class="symbol">&amp;amp;</span> JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>分别获取文本和HTML：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#test-ul li[name=book]&#x27;</span>).<span class="title function_">text</span>(); <span class="comment">// &#x27;Java &amp; JavaScript&#x27;</span></span><br><span class="line">$(<span class="string">&#x27;#test-ul li[name=book]&#x27;</span>).<span class="title function_">html</span>(); <span class="comment">// &#x27;Java &amp;amp; JavaScript&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如何设置文本或HTML？jQuery的API设计非常巧妙：无参数调用<code>text()</code>是获取文本，传入参数就变成设置文本，HTML也是类似操作，自己动手试试：</p>
<ul>
<li>JavaScript</li>
<li>Java &amp; JavaScript</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let j1 = $(&#x27;#test-ul li.js&#x27;);</span><br><span class="line">let j2 = $(&#x27;#test-ul li[name=book]&#x27;);</span><br><span class="line"></span><br><span class="line">j1.html(&#x27;&lt;span style=&quot;color: #c00&quot;&gt;JavaScript&lt;/span&gt;&#x27;);</span><br><span class="line">j2.text(&#x27;JavaScript &amp; ECMAScript&#x27;);</span><br></pre></td></tr></table></figure>
<p>一个jQuery对象可以包含0个或任意个DOM对象，它的方法实际上会作用在对应的每个DOM节点上。在上面的例子中试试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#test-ul li&#x27;</span>).<span class="title function_">text</span>(<span class="string">&#x27;JS&#x27;</span>); <span class="comment">// 是不是两个节点都变成了JS？</span></span><br></pre></td></tr></table></figure>
<p>所以jQuery对象的另一个好处是我们可以执行一个操作，作用在对应的一组DOM节点上。即使选择器没有返回任何DOM节点，调用jQuery对象的方法仍然不会报错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不存在id为not-exist的节点：</span></span><br><span class="line">$(<span class="string">&#x27;#not-exist&#x27;</span>).<span class="title function_">text</span>(<span class="string">&#x27;Hello&#x27;</span>); <span class="comment">// 代码不报错，没有节点被设置为&#x27;Hello&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这意味着jQuery帮你免去了许多<code>if</code>语句。</p>
<h3 id="修改CSS">修改CSS</h3>
<p>jQuery对象有“批量操作”的特点，这用于修改CSS实在是太方便了。考虑下面的HTML结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;test-css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;lang dy&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;lang&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;lang dy&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;lang&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;lang dy&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要高亮显示动态语言，调用jQuery对象的<code>css('name', 'value')</code>方法，我们用一行语句实现：</p>
<ul>
<li>JavaScript</li>
<li>Java</li>
<li>Python</li>
<li>Swift</li>
<li>Scheme</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&#x27;#test-css li.dy&gt;span&#x27;).css(&#x27;background-color&#x27;, &#x27;#ff0&#x27;).css(&#x27;color&#x27;, &#x27;#c00&#x27;);</span><br></pre></td></tr></table></figure>
<p><em>注意</em>，jQuery对象的所有方法都返回一个jQuery对象（可能是新的也可能是自身），这样我们可以进行链式调用，非常方便。</p>
<p>jQuery对象的<code>css()</code>方法可以这么用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = $(<span class="string">&#x27;#test-div&#x27;</span>);</span><br><span class="line">div.<span class="title function_">css</span>(<span class="string">&#x27;color&#x27;</span>); <span class="comment">// &#x27;#000033&#x27;, 获取CSS属性</span></span><br><span class="line">div.<span class="title function_">css</span>(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;#336699&#x27;</span>); <span class="comment">// 设置CSS属性</span></span><br><span class="line">div.<span class="title function_">css</span>(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;&#x27;</span>); <span class="comment">// 清除CSS属性</span></span><br></pre></td></tr></table></figure>
<p>为了和JavaScript保持一致，CSS属性可以用<code>'background-color'</code>和<code>'backgroundColor'</code>两种格式。</p>
<p><code>css()</code>方法将作用于DOM节点的<code>style</code>属性，具有最高优先级。如果要修改<code>class</code>属性，可以用jQuery提供的下列方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = $(<span class="string">&#x27;#test-div&#x27;</span>);</span><br><span class="line">div.<span class="title function_">hasClass</span>(<span class="string">&#x27;highlight&#x27;</span>); <span class="comment">// false， class是否包含highlight</span></span><br><span class="line">div.<span class="title function_">addClass</span>(<span class="string">&#x27;highlight&#x27;</span>); <span class="comment">// 添加highlight这个class</span></span><br><span class="line">div.<span class="title function_">removeClass</span>(<span class="string">&#x27;highlight&#x27;</span>); <span class="comment">// 删除highlight这个class</span></span><br></pre></td></tr></table></figure>
<p>练习：分别用<code>css()</code>方法和<code>addClass()</code>方法高亮显示JavaScript：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.highlight</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: <span class="number">#c00</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="number">#ff0</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test-highlight-css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;py&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;js&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;sw&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;hk&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Haskell<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Python</li>
<li>JavaScript</li>
<li>Swift</li>
<li>Haskell</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let div = $(&#x27;#test-highlight-css&#x27;);</span><br><span class="line">// TODO:</span><br></pre></td></tr></table></figure>
<h3 id="显示和隐藏DOM">显示和隐藏DOM</h3>
<p>要隐藏一个DOM，我们可以设置CSS的<code>display</code>属性为<code>none</code>，利用<code>css()</code>方法就可以实现。不过，要显示这个DOM就需要恢复原有的<code>display</code>属性，这就得先记下来原有的<code>display</code>属性到底是<code>block</code>还是<code>inline</code>还是别的值。</p>
<p>考虑到显示和隐藏DOM元素使用非常普遍，jQuery直接提供<code>show()</code>和<code>hide()</code>方法，我们不用关心它是如何修改<code>display</code>属性的，总之它能正常工作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = $(<span class="string">&#x27;a[target=_blank]&#x27;</span>);</span><br><span class="line">a.<span class="title function_">hide</span>(); <span class="comment">// 隐藏</span></span><br><span class="line">a.<span class="title function_">show</span>(); <span class="comment">// 显示</span></span><br></pre></td></tr></table></figure>
<p><em>注意</em>，隐藏DOM节点并未改变DOM树的结构，它只影响DOM节点的显示。这和删除DOM节点是不同的。</p>
<h3 id="获取DOM信息">获取DOM信息</h3>
<p>利用jQuery对象的若干方法，我们直接可以获取DOM的高宽等信息，而无需针对不同浏览器编写特定代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器可视窗口大小:</span></span><br><span class="line">$(<span class="variable language_">window</span>).<span class="title function_">width</span>(); <span class="comment">// 800</span></span><br><span class="line">$(<span class="variable language_">window</span>).<span class="title function_">height</span>(); <span class="comment">// 600</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML文档大小:</span></span><br><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">width</span>(); <span class="comment">// 800</span></span><br><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">height</span>(); <span class="comment">// 3500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 某个div的大小:</span></span><br><span class="line"><span class="keyword">let</span> div = $(<span class="string">&#x27;#test-div&#x27;</span>);</span><br><span class="line">div.<span class="title function_">width</span>(); <span class="comment">// 600</span></span><br><span class="line">div.<span class="title function_">height</span>(); <span class="comment">// 300</span></span><br><span class="line">div.<span class="title function_">width</span>(<span class="number">400</span>); <span class="comment">// 设置CSS属性 width: 400px，是否生效要看CSS是否有效</span></span><br><span class="line">div.<span class="title function_">height</span>(<span class="string">&#x27;200px&#x27;</span>); <span class="comment">// 设置CSS属性 height: 200px，是否生效要看CSS是否有效</span></span><br></pre></td></tr></table></figure>
<p><code>attr()</code>和<code>removeAttr()</code>方法用于操作DOM节点的属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;div id=&quot;test-div&quot; name=&quot;Test&quot; start=&quot;1&quot;&gt;...&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">let</span> div = $(<span class="string">&#x27;#test-div&#x27;</span>);</span><br><span class="line">div.<span class="title function_">attr</span>(<span class="string">&#x27;data&#x27;</span>); <span class="comment">// undefined, 属性不存在</span></span><br><span class="line">div.<span class="title function_">attr</span>(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// &#x27;Test&#x27;</span></span><br><span class="line">div.<span class="title function_">attr</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Hello&#x27;</span>); <span class="comment">// div的name属性变为&#x27;Hello&#x27;</span></span><br><span class="line">div.<span class="title function_">removeAttr</span>(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// 删除name属性</span></span><br><span class="line">div.<span class="title function_">attr</span>(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p><code>prop()</code>方法和<code>attr()</code>类似，但是HTML5规定有一种属性在DOM节点中可以没有值，只有出现与不出现两种，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;test-radio&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span> <span class="attr">checked</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;test-radio&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>attr()</code>和<code>prop()</code>对于属性<code>checked</code>处理有所不同：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> radio = $(<span class="string">&#x27;#test-radio&#x27;</span>);</span><br><span class="line">radio.<span class="title function_">attr</span>(<span class="string">&#x27;checked&#x27;</span>); <span class="comment">// &#x27;checked&#x27;</span></span><br><span class="line">radio.<span class="title function_">prop</span>(<span class="string">&#x27;checked&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>prop()</code>返回值更合理一些。不过，用<code>is()</code>方法判断更好：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> radio = $(<span class="string">&#x27;#test-radio&#x27;</span>);</span><br><span class="line">radio.<span class="title function_">is</span>(<span class="string">&#x27;:checked&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>类似的属性还有<code>selected</code>，处理时最好用<code>is(':selected')</code>。</p>
<h3 id="操作表单">操作表单</h3>
<p>对于表单元素，jQuery对象统一提供<code>val()</code>方法获取和设置对应的<code>value</code>属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    &lt;input id=&quot;test-input&quot; name=&quot;email&quot; value=&quot;test&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;select id=&quot;test-select&quot; name=&quot;city&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;option value=&quot;BJ&quot; selected&gt;Beijing&lt;/option&gt;</span></span><br><span class="line"><span class="comment">        &lt;option value=&quot;SH&quot;&gt;Shanghai&lt;/option&gt;</span></span><br><span class="line"><span class="comment">        &lt;option value=&quot;SZ&quot;&gt;Shenzhen&lt;/option&gt;</span></span><br><span class="line"><span class="comment">    &lt;/select&gt;</span></span><br><span class="line"><span class="comment">    &lt;textarea id=&quot;test-textarea&quot;&gt;Hello&lt;/textarea&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span></span><br><span class="line">    input = $(<span class="string">&#x27;#test-input&#x27;</span>),</span><br><span class="line">    select = $(<span class="string">&#x27;#test-select&#x27;</span>),</span><br><span class="line">    textarea = $(<span class="string">&#x27;#test-textarea&#x27;</span>);</span><br><span class="line"></span><br><span class="line">input.<span class="title function_">val</span>(); <span class="comment">// &#x27;test&#x27;</span></span><br><span class="line">input.<span class="title function_">val</span>(<span class="string">&#x27;abc@example.com&#x27;</span>); <span class="comment">// 文本框的内容已变为abc@example.com</span></span><br><span class="line"></span><br><span class="line">select.<span class="title function_">val</span>(); <span class="comment">// &#x27;BJ&#x27;</span></span><br><span class="line">select.<span class="title function_">val</span>(<span class="string">&#x27;SH&#x27;</span>); <span class="comment">// 选择框已变为Shanghai</span></span><br><span class="line"></span><br><span class="line">textarea.<span class="title function_">val</span>(); <span class="comment">// &#x27;Hello&#x27;</span></span><br><span class="line">textarea.<span class="title function_">val</span>(<span class="string">&#x27;Hi&#x27;</span>); <span class="comment">// 文本区域已更新为&#x27;Hi&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可见，一个<code>val()</code>就统一了各种输入框的取值和赋值的问题。</p>
<p>直接使用浏览器提供的API对DOM结构进行修改，不但代码复杂，而且要针对浏览器写不同的代码。</p>
<p>有了jQuery，我们就专注于操作jQuery对象本身，底层的DOM操作由jQuery完成就可以了，这样一来，修改DOM也大大简化了。</p>
<h3 id="添加DOM">添加DOM</h3>
<p>要添加新的DOM节点，除了通过jQuery的<code>html()</code>这种暴力方法外，还可以用<code>append()</code>方法，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test-div&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如何向列表新增一个语言？首先要拿到<code>&lt;ul&gt;</code>节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ul = $(<span class="string">&#x27;#test-div&gt;ul&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>然后，调用<code>append()</code>传入HTML片段：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ul.<span class="title function_">append</span>(<span class="string">&#x27;&lt;li&gt;&lt;span&gt;Haskell&lt;/span&gt;&lt;/li&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>除了接受字符串，<code>append()</code>还可以传入原始的DOM对象，jQuery对象和函数对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建DOM对象:</span></span><br><span class="line"><span class="keyword">let</span> ps = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">ps.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;span&gt;Pascal&lt;/span&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">// 添加DOM对象:</span></span><br><span class="line">ul.<span class="title function_">append</span>(ps);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加jQuery对象:</span></span><br><span class="line">ul.<span class="title function_">append</span>($(<span class="string">&#x27;#scheme&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加函数对象:</span></span><br><span class="line">ul.<span class="title function_">append</span>(<span class="keyword">function</span> (<span class="params">index, html</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;li&gt;&lt;span&gt;Language - &#x27;</span> + index + <span class="string">&#x27;&lt;/span&gt;&lt;/li&gt;&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>传入函数时，要求返回一个字符串、DOM对象或者jQuery对象。因为jQuery的<code>append()</code>可能作用于一组DOM节点，只有传入函数才能针对每个DOM生成不同的子节点。</p>
<p><code>append()</code>把DOM添加到最后，<code>prepend()</code>则把DOM添加到最前。</p>
<p>另外注意，如果要添加的DOM节点已经存在于HTML文档中，它会首先从文档移除，然后再添加，也就是说，用<code>append()</code>，你可以移动一个DOM节点。</p>
<p>如果要把新节点插入到指定位置，例如，JavaScript和Python之间，那么，可以先定位到JavaScript，然后用<code>after()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> js = $(<span class="string">&#x27;#test-div&gt;ul&gt;li:first-child&#x27;</span>);</span><br><span class="line">js.<span class="title function_">after</span>(<span class="string">&#x27;&lt;li&gt;&lt;span&gt;Lua&lt;/span&gt;&lt;/li&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>也就是说，同级节点可以用<code>after()</code>或者<code>before()</code>方法。</p>
<h3 id="删除节点">删除节点</h3>
<p>要删除DOM节点，拿到jQuery对象后直接调用<code>remove()</code>方法就可以了。如果jQuery对象包含若干DOM节点，实际上可以一次删除多个DOM节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> li = $(<span class="string">&#x27;#test-div&gt;ul&gt;li&#x27;</span>);</span><br><span class="line">li.<span class="title function_">remove</span>(); <span class="comment">// 所有&lt;li&gt;全被删除</span></span><br></pre></td></tr></table></figure>
<h3 id="练习-4">练习</h3>
<p>除了列出的3种语言外，请再添加Pascal、Lua和Ruby，然后按字母顺序排序节点：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test-div&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>JavaScript</li>
<li>Python</li>
<li>Swift</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// TODO:</span><br><span class="line"></span><br><span class="line">// 测试:</span><br><span class="line">(function () &#123;</span><br><span class="line">    let s = $(&#x27;#test-div&gt;ul&gt;li&#x27;).map(function () &#123;</span><br><span class="line">        return $(this).text();</span><br><span class="line">    &#125;).get().join(&#x27;,&#x27;);</span><br><span class="line">    if (s === &#x27;JavaScript,Lua,Pascal,Python,Ruby,Swift&#x27;) &#123;</span><br><span class="line">        console.log(&#x27;测试通过!&#x27;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&#x27;测试失败: &#x27; + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>因为JavaScript在浏览器中以单线程模式运行，页面加载后，一旦页面上所有的JavaScript代码被执行完后，就只能依赖触发事件来执行JavaScript代码。</p>
<p>浏览器在接收到用户的鼠标或键盘输入后，会自动在对应的DOM节点上触发相应的事件。如果该节点已经绑定了对应的JavaScript处理函数，该函数就会自动调用。</p>
<p>由于不同的浏览器绑定事件的代码都不太一样，所以用jQuery来写代码，就屏蔽了不同浏览器的差异，我们总是编写相同的代码。</p>
<p>举个例子，假设要在用户点击了超链接时弹出提示框，我们用jQuery这样绑定一个<code>click</code>事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* HTML:</span><br><span class="line"> *</span><br><span class="line"> * &lt;a id=&quot;test-link&quot; href=&quot;#0&quot;&gt;点我试试&lt;/a&gt;</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">// 获取超链接的jQuery对象:</span><br><span class="line">let a = $(&#x27;#test-link&#x27;);</span><br><span class="line">a.on(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    alert(&#x27;Hello!&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>实测：<a href="#0">点我试试</a></p>
<p><code>on</code>方法用来绑定一个事件，我们需要传入事件名称和对应的处理函数。</p>
<p>另一种更简化的写法是直接调用<code>click()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Hello!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>两者完全等价。我们通常用后面的写法。</p>
<p>jQuery能够绑定的事件主要包括：</p>
<h3 id="鼠标事件">鼠标事件</h3>
<ul>
<li>click: 鼠标单击时触发；</li>
<li>dblclick：鼠标双击时触发；</li>
<li>mouseenter：鼠标进入时触发；</li>
<li>mouseleave：鼠标移出时触发；</li>
<li>mousemove：鼠标在DOM内部移动时触发；</li>
<li>hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。</li>
</ul>
<h3 id="键盘事件">键盘事件</h3>
<p>键盘事件仅作用在当前焦点的DOM上，通常是<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>。</p>
<ul>
<li>keydown：键盘按下时触发；</li>
<li>keyup：键盘松开时触发；</li>
<li>keypress：按一次键后触发。</li>
</ul>
<h3 id="其他事件">其他事件</h3>
<ul>
<li>focus：当DOM获得焦点时触发；</li>
<li>blur：当DOM失去焦点时触发；</li>
<li>change：当<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>或<code>&lt;textarea&gt;</code>的内容改变时触发；</li>
<li>submit：当<code>&lt;form&gt;</code>提交时触发；</li>
<li>ready：当页面被载入并且DOM树完成初始化后触发。</li>
</ul>
<p>其中，<code>ready</code>仅作用于<code>document</code>对象。由于<code>ready</code>事件在DOM完成初始化后触发，且只触发一次，所以非常适合用来写其他的初始化代码。假设我们想给一个<code>&lt;form&gt;</code>表单绑定<code>submit</code>事件，下面的代码没有预期的效果：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 代码有误:</span></span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&#x27;#testForm&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;submit&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&#x27;submit!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;testForm&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为JavaScript在此执行的时候，<code>&lt;form&gt;</code>尚未载入浏览器，所以<code>$('#testForm)</code>返回<code>[]</code>，并没有绑定事件到任何DOM上。</p>
<p>所以我们自己的初始化代码必须放到<code>document</code>对象的<code>ready</code>事件中，保证DOM已完成初始化：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">        $(document).on(&#x27;ready&#x27;, function () &#123;</span><br><span class="line">            $(&#x27;#testForm).on(&#x27;submit&#x27;, function () &#123;</span><br><span class="line">                alert(&#x27;submit!&#x27;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;testForm&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样写就没有问题了。因为相关代码会在DOM树初始化后再执行。</p>
<p>由于<code>ready</code>事件使用非常普遍，所以可以这样简化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// on(&#x27;submit&#x27;, function)也可以简化:</span></span><br><span class="line">    $(<span class="string">&#x27;#testForm).submit(function () &#123;</span></span><br><span class="line"><span class="string">        alert(&#x27;</span>submit!<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>
<p>甚至还可以再简化为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// init...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的这种写法最为常见。如果你遇到<code>$(function () &#123;...&#125;)</code>的形式，牢记这是<code>document</code>对象的<code>ready</code>事件处理函数。</p>
<p>完全可以反复绑定事件处理函数，它们会依次执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;init A...&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;init B...&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;init C...&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="事件参数">事件参数</h3>
<p>有些事件，如<code>mousemove</code>和<code>keypress</code>，我们需要获取鼠标位置和按键的值，否则监听这些事件就没什么意义了。所有事件都会传入<code>Event</code>对象作为参数，可以从<code>Event</code>对象上获取到更多的信息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    $(<span class="string">&#x27;#testMouseMoveDiv&#x27;</span>).<span class="title function_">mousemove</span>(<span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">        $(<span class="string">&#x27;#testMouseMoveSpan&#x27;</span>).<span class="title function_">text</span>(<span class="string">&#x27;pageX = &#x27;</span> + e.<span class="property">pageX</span> + <span class="string">&#x27;, pageY = &#x27;</span> + e.<span class="property">pageY</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="取消绑定">取消绑定</h3>
<p>一个已被绑定的事件可以解除绑定，通过<code>off('click', function)</code>实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">click</span>(hello); <span class="comment">// 绑定事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 10秒钟后解除绑定:</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    a.<span class="title function_">off</span>(<span class="string">&#x27;click&#x27;</span>, hello);</span><br><span class="line">&#125;, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure>
<p>需要特别注意的是，下面这种写法是无效的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定事件:</span></span><br><span class="line">a.<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除绑定:</span></span><br><span class="line">a.<span class="title function_">off</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这是因为两个匿名函数虽然长得一模一样，但是它们是两个<em>不同</em>的函数对象，<code>off('click', function () &#123;...&#125;)</code>无法移除已绑定的第一个匿名函数。</p>
<p>为了实现移除效果，可以使用<code>off('click')</code>一次性移除已绑定的<code>click</code>事件的所有处理函数。</p>
<p>同理，无参数调用<code>off()</code>一次性移除已绑定的所有类型的事件处理函数。</p>
<h3 id="事件触发条件">事件触发条件</h3>
<p>一个需要注意的问题是，事件的触发总是由用户操作引发的。例如，我们监控文本框的内容改动：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = $(<span class="string">&#x27;#test-input&#x27;</span>);</span><br><span class="line">input.<span class="title function_">change</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;changed...&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当用户在文本框中输入时，就会触发<code>change</code>事件。但是，如果用JavaScript代码去改动文本框的值，将<em>不会</em>触发<code>change</code>事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = $(<span class="string">&#x27;#test-input&#x27;</span>);</span><br><span class="line">input.<span class="title function_">val</span>(<span class="string">&#x27;change it!&#x27;</span>); <span class="comment">// 无法触发change事件</span></span><br></pre></td></tr></table></figure>
<p>有些时候，我们希望用代码触发<code>change</code>事件，可以直接调用无参数的<code>change()</code>方法来触发该事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = $(<span class="string">&#x27;#test-input&#x27;</span>);</span><br><span class="line">input.<span class="title function_">val</span>(<span class="string">&#x27;change it!&#x27;</span>);</span><br><span class="line">input.<span class="title function_">change</span>(); <span class="comment">// 触发change事件</span></span><br></pre></td></tr></table></figure>
<p><code>input.change()</code>相当于<code>input.trigger('change')</code>，它是<code>trigger()</code>方法的简写。</p>
<p>为什么我们希望手动触发一个事件呢？如果不这么做，很多时候，我们就得写两份一模一样的代码。</p>
<h3 id="练习-5">练习</h3>
<p>对如下的Form表单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;test-form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span>请选择想要学习的编程语言：<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;selectAll&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;selectAll&quot;</span>&gt;</span>全选<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;deselectAll&quot;</span>&gt;</span>全不选<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#0&quot;</span> <span class="attr">class</span>=<span class="string">&quot;invertSelect&quot;</span>&gt;</span>反选<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lang&quot;</span> <span class="attr">value</span>=<span class="string">&quot;javascript&quot;</span>&gt;</span> JavaScript<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lang&quot;</span> <span class="attr">value</span>=<span class="string">&quot;python&quot;</span>&gt;</span> Python<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lang&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ruby&quot;</span>&gt;</span> Ruby<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lang&quot;</span> <span class="attr">value</span>=<span class="string">&quot;haskell&quot;</span>&gt;</span> Haskell<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lang&quot;</span> <span class="attr">value</span>=<span class="string">&quot;scheme&quot;</span>&gt;</span> Scheme<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>绑定合适的事件处理函数，实现以下逻辑：</p>
<p>当用户勾上“全选”时，自动选中所有语言，并把“全选”变成“全不选”；</p>
<p>当用户去掉“全不选”时，自动不选中所有语言；</p>
<p>当用户点击“反选”时，自动把所有语言状态反转（选中的变为未选，未选的变为选中）；</p>
<p>当用户把所有语言都手动勾上时，“全选”被自动勾上，并变为“全不选”；</p>
<p>当用户手动去掉选中至少一种语言时，“全不选”自动被去掉选中，并变为“全选”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let</span><br><span class="line">    form = $(&#x27;#test-form&#x27;),</span><br><span class="line">    langs = form.find(&#x27;[name=lang]&#x27;),</span><br><span class="line">    selectAll = form.find(&#x27;label.selectAll :checkbox&#x27;),</span><br><span class="line">    selectAllLabel = form.find(&#x27;label.selectAll span.selectAll&#x27;),</span><br><span class="line">    deselectAllLabel = form.find(&#x27;label.selectAll span.deselectAll&#x27;),</span><br><span class="line">    invertSelect = form.find(&#x27;a.invertSelect&#x27;);</span><br><span class="line"></span><br><span class="line">// 重置初始化状态:</span><br><span class="line">form.find(&#x27;*&#x27;).show().off();</span><br><span class="line">form.find(&#x27;:checkbox&#x27;).prop(&#x27;checked&#x27;, false).off();</span><br><span class="line">deselectAllLabel.hide();</span><br><span class="line">// 拦截form提交事件:</span><br><span class="line">form.off().submit(function (e) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    alert(form.serialize());</span><br><span class="line">&#125;);</span><br><span class="line">// TODO:绑定事件</span><br><span class="line"></span><br><span class="line">// 测试:</span><br><span class="line">console.log(&#x27;请测试功能是否正常。&#x27;);</span><br></pre></td></tr></table></figure>
<p>用JavaScript实现动画，原理非常简单：我们只需要以固定的时间间隔（例如，0.1秒），每次把DOM元素的CSS样式修改一点（例如，高宽各增加10%），看起来就像动画了。</p>
<p>但是要用JavaScript手动实现动画效果，需要编写非常复杂的代码。如果想要把动画效果用函数封装起来便于复用，那考虑的事情就更多了。</p>
<p>使用jQuery实现动画，代码已经简单得不能再简化了：只需要一行代码！</p>
<p>让我们先来看看jQuery内置的几种动画样式：</p>
<h3 id="show-hide">show / hide</h3>
<p>直接以无参数形式调用<code>show()</code>和<code>hide()</code>，会显示和隐藏DOM元素。但是，只要传递一个时间参数进去，就变成了动画：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = $(<span class="string">&#x27;#test-show-hide&#x27;</span>);</span><br><span class="line">div.<span class="title function_">hide</span>(<span class="number">3000</span>); <span class="comment">// 在3秒钟内逐渐消失</span></span><br></pre></td></tr></table></figure>
<p>时间以毫秒为单位，但也可以是<code>'slow'</code>，<code>'fast'</code>这些字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = $(<span class="string">&#x27;#test-show-hide&#x27;</span>);</span><br><span class="line">div.<span class="title function_">show</span>(<span class="string">&#x27;slow&#x27;</span>); <span class="comment">// 在0.6秒钟内逐渐显示</span></span><br></pre></td></tr></table></figure>
<p><code>toggle()</code>方法则根据当前状态决定是<code>show()</code>还是<code>hide()</code>。</p>
<p>效果实测：</p>
<h3 id="slideUp-slideDown">slideUp / slideDown</h3>
<p>你可能已经看出来了，<code>show()</code>和<code>hide()</code>是从左上角逐渐展开或收缩的，而<code>slideUp()</code>和<code>slideDown()</code>则是在垂直方向逐渐展开或收缩的。</p>
<p><code>slideUp()</code>把一个可见的DOM元素收起来，效果跟拉上窗帘似的，<code>slideDown()</code>相反，而<code>slideToggle()</code>则根据元素是否可见来决定下一步动作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = $(<span class="string">&#x27;#test-slide&#x27;</span>);</span><br><span class="line">div.<span class="title function_">slideUp</span>(<span class="number">3000</span>); <span class="comment">// 在3秒钟内逐渐向上消失</span></span><br></pre></td></tr></table></figure>
<p>效果实测：</p>
<h3 id="fadeIn-fadeOut">fadeIn / fadeOut</h3>
<p><code>fadeIn()</code>和<code>fadeOut()</code>的动画效果是淡入淡出，也就是通过不断设置DOM元素的<code>opacity</code>属性来实现，而<code>fadeToggle()</code>则根据元素是否可见来决定下一步动作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = $(<span class="string">&#x27;#test-fade&#x27;</span>);</span><br><span class="line">div.<span class="title function_">fadeOut</span>(<span class="string">&#x27;slow&#x27;</span>); <span class="comment">// 在0.6秒内淡出</span></span><br></pre></td></tr></table></figure>
<h3 id="自定义动画">自定义动画</h3>
<p>如果上述动画效果还不能满足你的要求，那就祭出最后大招：<code>animate()</code>，它可以实现任意动画效果，我们需要传入的参数就是DOM元素最终的CSS状态和时间，jQuery在时间段内不断调整CSS直到达到我们设定的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = $(<span class="string">&#x27;#test-animate&#x27;</span>);</span><br><span class="line">div.<span class="title function_">animate</span>(&#123;</span><br><span class="line">    <span class="attr">opacity</span>: <span class="number">0.25</span>,</span><br><span class="line">    <span class="attr">width</span>: <span class="string">&#x27;256px&#x27;</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="string">&#x27;256px&#x27;</span></span><br><span class="line">&#125;, <span class="number">3000</span>); <span class="comment">// 在3秒钟内CSS过渡到设定值</span></span><br></pre></td></tr></table></figure>
<p><code>animate()</code>还可以再传入一个函数，当动画结束时，该函数将被调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = $(<span class="string">&#x27;#test-animate&#x27;</span>);</span><br><span class="line">div.<span class="title function_">animate</span>(&#123;</span><br><span class="line">    <span class="attr">opacity</span>: <span class="number">0.25</span>,</span><br><span class="line">    <span class="attr">width</span>: <span class="string">&#x27;256px&#x27;</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="string">&#x27;256px&#x27;</span></span><br><span class="line">&#125;, <span class="number">3000</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;动画已结束&#x27;</span>);</span><br><span class="line">    <span class="comment">// 恢复至初始状态:</span></span><br><span class="line">    $(<span class="variable language_">this</span>).<span class="title function_">css</span>(<span class="string">&#x27;opacity&#x27;</span>, <span class="string">&#x27;1.0&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;width&#x27;</span>, <span class="string">&#x27;128px&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;height&#x27;</span>, <span class="string">&#x27;128px&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>实际上这个回调函数参数对于基本动画也是适用的。</p>
<p>有了<code>animate()</code>，你就可以实现各种自定义动画效果了：</p>
<h3 id="串行动画">串行动画</h3>
<p>jQuery的动画效果还可以串行执行，通过<code>delay()</code>方法还可以实现暂停，这样，我们可以实现更复杂的动画效果，而代码却相当简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = $(<span class="string">&#x27;#test-animates&#x27;</span>);</span><br><span class="line"><span class="comment">// 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小</span></span><br><span class="line">div.<span class="title function_">slideDown</span>(<span class="number">2000</span>)</span><br><span class="line">   .<span class="title function_">delay</span>(<span class="number">1000</span>)</span><br><span class="line">   .<span class="title function_">animate</span>(&#123;</span><br><span class="line">       <span class="attr">width</span>: <span class="string">&#x27;256px&#x27;</span>,</span><br><span class="line">       <span class="attr">height</span>: <span class="string">&#x27;256px&#x27;</span></span><br><span class="line">   &#125;, <span class="number">2000</span>)</span><br><span class="line">   .<span class="title function_">delay</span>(<span class="number">1000</span>)</span><br><span class="line">   .<span class="title function_">animate</span>(&#123;</span><br><span class="line">       <span class="attr">width</span>: <span class="string">&#x27;128px&#x27;</span>,</span><br><span class="line">       <span class="attr">height</span>: <span class="string">&#x27;128px&#x27;</span></span><br><span class="line">   &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>因为动画需要执行一段时间，所以jQuery必须不断返回新的Promise对象才能后续执行操作。简单地把动画封装在函数中是不够的。</p>
<p>效果实测：</p>
<h3 id="为什么有的动画没有效果">为什么有的动画没有效果</h3>
<p>你可能会遇到，有的动画如<code>slideUp()</code>根本没有效果。这是因为jQuery动画的原理是逐渐改变CSS的值，如<code>height</code>从<code>100px</code>逐渐变为<code>0</code>。但是很多不是block性质的DOM元素，对它们设置<code>height</code>根本就不起作用，所以动画也就没有效果。</p>
<p>此外，jQuery也没有实现对<code>background-color</code>的动画效果，用<code>animate()</code>设置<code>background-color</code>也没有效果。这种情况下可以使用CSS3的<code>transition</code>实现动画效果。</p>
<h3 id="练习-6">练习</h3>
<p>在执行删除操作时，给用户显示一个动画比直接调用<code>remove()</code>要更好。请在表格删除一行的时候添加一个淡出的动画效果：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Email</th>
<th>Address</th>
<th>Status</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bart Simpson</td>
<td>bart.s@primary.school</td>
<td>Springfield</td>
<td>Active</td>
</tr>
<tr>
<td>Michael Scofield</td>
<td><a href="mailto:m.scofield@escape.org">m.scofield@escape.org</a></td>
<td>Fox River</td>
<td>Locked</td>
</tr>
<tr>
<td>Optimus Prime</td>
<td><a href="mailto:prime@cybertron.org">prime@cybertron.org</a></td>
<td>Cybertron</td>
<td>Active</td>
</tr>
<tr>
<td>Peter Parker</td>
<td><a href="mailto:spider@movie.org">spider@movie.org</a></td>
<td>New York</td>
<td>Active</td>
</tr>
<tr>
<td>Thor Odinson</td>
<td><a href="mailto:thor@asgard.org">thor@asgard.org</a></td>
<td>Asgard</td>
<td>Active</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function deleteFirstTR() &#123;</span><br><span class="line">    let tr = $(&#x27;#test-table&gt;tbody&gt;tr:visible&#x27;).first();</span><br><span class="line">    // TODO:</span><br><span class="line">    tr.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deleteFirstTR();</span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="2025/05/26/JavaScript/JavaScript-jQuery/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="2025/05/26/JavaScript/JavaScript-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"
                            aria-label=": JavaScript-错误处理"
                        >
                            JavaScript-错误处理
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-26T21:45:51+08:00">
	
		    2025 年 5 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/">JavaScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>在执行JavaScript代码的时候，有些情况下会发生错误。</p>
<p>错误分两种，一种是程序写的逻辑不对，导致代码执行异常。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> len = s.<span class="property">length</span>; <span class="comment">// TypeError：null变量没有length属性</span></span><br></pre></td></tr></table></figure>
<p>对于这种错误，要修复程序。</p>
<p>一种是执行过程中，程序可能遇到无法预测的异常情况而报错，例如，网络连接中断，读取不存在的文件，没有操作权限等。</p>
<p>对于这种错误，我们需要处理它，并可能需要给用户反馈。</p>
<p>错误处理是程序设计时必须要考虑的问题。对于C这样贴近系统底层的语言，错误是通过错误码返回的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/path/to/file&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Error when open file!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过错误码返回错误，就需要约定什么是正确的返回值，什么是错误的返回值。上面的<code>open()</code>函数约定返回<code>-1</code>表示错误。</p>
<p>显然，这种用错误码表示错误在编写程序时十分不便。</p>
<p>因此，高级语言通常都提供了更抽象的错误处理逻辑try … catch … finally，JavaScript也不例外。</p>
<h3 id="try-…-catch-…-finally">try … catch … finally</h3>
<p>使用try … catch … finally处理错误时，我们编写的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let r1, r2, s = null;</span><br><span class="line">try &#123;</span><br><span class="line">    r1 = s.length; // 此处应产生错误</span><br><span class="line">    r2 = 100; // 该语句不会执行</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    console.log(&#x27;出错了：&#x27; + e);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    console.log(&#x27;finally&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;r1 = &#x27; + r1); // r1应为undefined</span><br><span class="line">console.log(&#x27;r2 = &#x27; + r2); // r2应为undefined</span><br></pre></td></tr></table></figure>
<p>运行后可以发现，输出提示类似“出错了：TypeError: Cannot read property ‘length’ of null”。</p>
<p>我们来分析一下使用try … catch … finally的执行流程。</p>
<p>当代码块被<code>try &#123; ... &#125;</code>包裹的时候，就表示这部分代码执行过程中可能会发生错误，一旦发生错误，就不再继续执行后续代码，转而跳到<code>catch</code>块。<code>catch (e) &#123; ... &#125;</code>包裹的代码就是错误处理代码，变量<code>e</code>表示捕获到的错误。最后，无论有没有错误，<code>finally</code>一定会被执行。</p>
<p>所以，有错误发生时，执行流程像这样：</p>
<ol>
<li>先执行<code>try &#123; ... &#125;</code>的代码；</li>
<li>执行到出错的语句时，后续语句不再继续执行，转而执行<code>catch (e) &#123; ... &#125;</code>代码；</li>
<li>最后执行<code>finally &#123; ... &#125;</code>代码。</li>
</ol>
<p>而没有错误发生时，执行流程像这样：</p>
<ol>
<li>先执行<code>try &#123; ... &#125;</code>的代码；</li>
<li>因为没有出错，<code>catch (e) &#123; ... &#125;</code>代码不会被执行；</li>
<li>最后执行<code>finally &#123; ... &#125;</code>代码。</li>
</ol>
<p>最后请注意，<code>catch</code>和<code>finally</code>可以不必都出现。也就是说，<code>try</code>语句一共有三种形式：</p>
<p>完整的try … catch … finally：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有try … catch，没有finally：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有try … finally，没有catch：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误类型">错误类型</h3>
<p>JavaScript有一个标准的<code>Error</code>对象表示错误，还有从<code>Error</code>派生的<code>TypeError</code>、<code>ReferenceError</code>等错误对象。我们在处理错误时，可以通过<code>catch(e)</code>捕获的变量<code>e</code>访问错误对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="title class_">TypeError</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;Type error!&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="title class_">Error</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(e.<span class="property">message</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;Error: &#x27;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用变量<code>e</code>是一个习惯用法，也可以以其他变量名命名，如<code>catch(ex)</code>。</p>
<h3 id="抛出错误">抛出错误</h3>
<p>程序也可以主动抛出一个错误，让执行流程直接跳转到<code>catch</code>块。抛出错误使用<code>throw</code>语句。</p>
<p>例如，下面的代码让用户输入一个数字，程序接收到的实际上是一个字符串，然后用<code>parseInt()</code>转换为整数。当用户输入不合法的时候，我们就抛出错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let r, n, s;</span><br><span class="line">try &#123;</span><br><span class="line">    s = prompt(&#x27;请输入一个数字&#x27;);</span><br><span class="line">    n = parseInt(s);</span><br><span class="line">    if (isNaN(n)) &#123;</span><br><span class="line">        throw new Error(&#x27;输入错误&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算平方:</span><br><span class="line">    r = n * n;</span><br><span class="line">    console.log(n + &#x27; * &#x27; + n + &#x27; = &#x27; + r);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    console.log(&#x27;出错了：&#x27; + e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，JavaScript允许抛出任意对象，包括数字、字符串。但是，最好还是抛出一个Error对象。</p>
<p>最后，当我们用catch捕获错误时，一定要编写错误处理语句：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">0</span>, s;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    n = s.<span class="property">length</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br></pre></td></tr></table></figure>
<p>哪怕仅仅把错误打印出来，也不要什么也不干：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">0</span>, s;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    n = s.<span class="property">length</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br></pre></td></tr></table></figure>
<p>因为catch到错误却什么都不执行，就不知道程序执行过程中到底有没有发生错误。</p>
<p>处理错误时，请不要简单粗暴地用<code>alert()</code>把错误显示给用户。教程的代码使用<code>alert()</code>是为了便于演示。</p>
<h2 id="错误传播">错误传播</h2>
<p>如果代码发生了错误，又没有被try … catch捕获，那么，程序执行流程会跳转到哪呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getLength</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printLength</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getLength</span>(<span class="string">&#x27;abc&#x27;</span>)); <span class="comment">// 3</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getLength</span>(<span class="literal">null</span>)); <span class="comment">// Error!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printLength</span>();</span><br></pre></td></tr></table></figure>
<p>如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数，如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行。</p>
<p>所以，我们不必在每一个函数内部捕获错误，只需要在合适的地方来个统一捕获，一网打尽：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function main(s) &#123;</span><br><span class="line">    console.log(&#x27;BEGIN main()&#x27;);</span><br><span class="line">    try &#123;</span><br><span class="line">        foo(s);</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        console.log(&#x27;出错了：&#x27; + e);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#x27;END main()&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo(s) &#123;</span><br><span class="line">    console.log(&#x27;BEGIN foo()&#x27;);</span><br><span class="line">    bar(s);</span><br><span class="line">    console.log(&#x27;END foo()&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar(s) &#123;</span><br><span class="line">    console.log(&#x27;BEGIN bar()&#x27;);</span><br><span class="line">    console.log(&#x27;length = &#x27; + s.length);</span><br><span class="line">    console.log(&#x27;END bar()&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(null);</span><br></pre></td></tr></table></figure>
<p>当<code>bar()</code>函数传入参数<code>null</code>时，代码会报错，错误会向上抛给调用方<code>foo()</code>函数，<code>foo()</code>函数没有try … catch语句，所以错误继续向上抛给调用方<code>main()</code>函数，<code>main()</code>函数有try … catch语句，所以错误最终在<code>main()</code>函数被处理了。</p>
<p>至于在哪些地方捕获错误比较合适，需要视情况而定。</p>
<hr>
<hr>
<h2 id="异步错误处理">异步错误处理</h2>
<p>编写JavaScript代码时，我们要时刻牢记，JavaScript引擎是一个事件驱动的执行引擎，代码总是以单线程执行，而回调函数的执行需要等到下一个满足条件的事件出现后，才会被执行。</p>
<p>例如，<code>setTimeout()</code>函数可以传入回调函数，并在指定若干毫秒后执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printTime</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;It is time!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(printTime, <span class="number">1000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;done&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码会先打印<code>done</code>，1秒后才会打印<code>It is time!</code>。</p>
<p>如果<code>printTime()</code>函数内部发生了错误，我们试图用try包裹<code>setTimeout()</code>是无效的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function printTime() &#123;</span><br><span class="line">    throw new Error();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    setTimeout(printTime, 1000);</span><br><span class="line">    console.log(&#x27;done&#x27;);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    console.log(&#x27;error&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因就在于调用<code>setTimeout()</code>函数时，传入的<code>printTime</code>函数并未立刻执行！紧接着，JavaScript引擎会继续执行<code>console.log('done');</code>语句，而此时并没有错误发生。直到1秒钟后，执行<code>printTime</code>函数时才发生错误，但此时除了在<code>printTime</code>函数内部捕获错误外，外层代码并无法捕获。</p>
<p>所以，涉及到异步代码，无法在调用时捕获，原因就是在捕获的当时，回调函数并未执行。</p>
<p>类似的，当我们处理一个事件时，在绑定事件的代码处，无法捕获事件处理函数的错误。</p>
<p>例如，针对以下的表单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;x&quot;</span>&gt;</span> + <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;y&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;calc&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>计算<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们用下面的代码给button绑定click事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let btn = document.querySelector(&#x27;#calc&#x27;);</span><br><span class="line"></span><br><span class="line">// 取消已绑定的事件:</span><br><span class="line">btn.onclick = null;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    btn.onclick = function () &#123;</span><br><span class="line">        let</span><br><span class="line">            x = parseFloat(document.querySelector(&#x27;#x&#x27;).value),</span><br><span class="line">            y = parseFloat(document.querySelector(&#x27;#y&#x27;).value),</span><br><span class="line">            r;</span><br><span class="line">        if (isNaN(x) || isNaN(y)) &#123;</span><br><span class="line">            throw new Error(&#x27;输入有误&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        r = x + y;</span><br><span class="line">        alert(&#x27;计算结果：&#x27; + r);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    alert(&#x27;输入有误！&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，用户输入错误时，处理函数并未捕获到错误。请修复错误处理代码。</p>
<hr>
<hr>

                    
                        


                    
                    
                        <p>
                            <a
                                href="2025/05/26/JavaScript/JavaScript-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="page/2/"
                aria-label="下一頁"
            >
              <span>下一頁</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">第 1 頁 共 14 頁</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 137 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
